/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>

#include "libfifo.h"

//----- (0003121C) --------------------------------------------------------
int __fastcall notifyTracker(int result, int *a2)
{
  if ( a2 )
    result = P2PClient::addPeers(gP2PClient, result, a2);
  return result;
}
// F3D70: using guessed type int gP2PClient;

//----- (0003123C) --------------------------------------------------------
int __fastcall notifyHttpFileFinished(int a1)
{
  unsigned int *v1; // r4

  v1 = (unsigned int *)a1;
  addCdnDownloadBytes(*(_DWORD *)(a1 + 8));
  return LocalMemory::addPendingData(gLocalMemory, v1, 2);
}
// F3D6C: using guessed type int gLocalMemory;

//----- (0003126C) --------------------------------------------------------
void __fastcall sub_3126C(int *a1, int *a2)
{
  int *v2; // r10
  int v3; // r1
  unsigned int v4; // r3
  int *v5; // r11
  int *v6; // r9
  int v7; // r5
  int v8; // t1
  int v9; // r8
  int v10; // r7
  int v11; // r4
  int v12; // r1
  void *v13; // r3
  int v14; // r5
  int v15; // r7
  int v16; // r4
  int v17; // r3
  void *v18; // r0
  int v19; // r7
  int v20; // r4
  int v21; // r3
  void *v22; // r0
  int v23; // r7
  int v24; // r4
  int v25; // r3
  void *v26; // r0
  unsigned int *v27; // r1
  signed int v28; // r0
  unsigned int *v29; // r3
  signed int v30; // r2
  unsigned int *v31; // r3
  signed int v32; // r2
  unsigned int *v33; // r3
  signed int v34; // r1

  v2 = a2;
  v3 = a1[3];
  v4 = v2[3];
  v5 = a1;
  v6 = (int *)(v3 + 4);
  if ( v3 + 4 < v4 )
  {
    do
    {
      v8 = *v6;
      ++v6;
      v7 = v8;
      v9 = v8 + 500;
      v10 = v8 + 12;
      v11 = v8;
      do
      {
        v12 = *(_DWORD *)(v10 + v11 - v7);
        v13 = (void *)(v12 - 12);
        if ( (int *)(v12 - 12) != &dword_2FEF3C )
        {
          v27 = (unsigned int *)(v12 - 4);
          __dmb(0xFu);
          do
            v28 = __ldrex(v27);
          while ( __strex(v28 - 1, v27) );
          __dmb(0xFu);
          if ( v28 <= 0 )
            operator delete(v13);
        }
        v11 += 20;
      }
      while ( v9 != v11 );
      v4 = v2[3];
    }
    while ( v4 > (unsigned int)v6 );
    v3 = v5[3];
  }
  v14 = *v5;
  if ( v3 == v4 )
  {
    v23 = *v2;
    if ( v14 != *v2 )
    {
      v24 = *v5;
      do
      {
        v25 = *(_DWORD *)(v24 + 12);
        v26 = (void *)(v25 - 12);
        if ( (int *)(v25 - 12) != &dword_2FEF3C )
        {
          v29 = (unsigned int *)(v25 - 4);
          __dmb(0xFu);
          do
            v30 = __ldrex(v29);
          while ( __strex(v30 - 1, v29) );
          __dmb(0xFu);
          if ( v30 <= 0 )
            operator delete(v26);
        }
        v24 += 20;
      }
      while ( v23 != v24 );
    }
  }
  else
  {
    v15 = v5[2];
    if ( v14 != v15 )
    {
      v16 = *v5;
      do
      {
        v17 = *(_DWORD *)(v16 + 12);
        v18 = (void *)(v17 - 12);
        if ( (int *)(v17 - 12) != &dword_2FEF3C )
        {
          v33 = (unsigned int *)(v17 - 4);
          __dmb(0xFu);
          do
            v34 = __ldrex(v33);
          while ( __strex(v34 - 1, v33) );
          __dmb(0xFu);
          if ( v34 <= 0 )
            operator delete(v18);
        }
        v16 += 20;
      }
      while ( v15 != v16 );
    }
    v19 = *v2;
    if ( v2[1] != *v2 )
    {
      v20 = v2[1];
      do
      {
        v21 = *(_DWORD *)(v20 + 12);
        v22 = (void *)(v21 - 12);
        if ( (int *)(v21 - 12) != &dword_2FEF3C )
        {
          v31 = (unsigned int *)(v21 - 4);
          __dmb(0xFu);
          do
            v32 = __ldrex(v31);
          while ( __strex(v32 - 1, v31) );
          __dmb(0xFu);
          if ( v32 <= 0 )
            operator delete(v22);
        }
        v20 += 20;
      }
      while ( v19 != v20 );
    }
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000314B8) --------------------------------------------------------
signed int __fastcall read_file(const char *a1, char *a2, unsigned int a3)
{
  char *v3; // r6
  unsigned int v4; // r5
  int v5; // r4
  ssize_t v6; // r7

  v3 = a2;
  v4 = a3;
  v5 = open(a1, 0);
  if ( v5 < 0 )
    return -1;
  do
    v6 = read(v5, v3, v4);
  while ( v6 < 0 );
  close(v5);
  return v6;
}

//----- (00031504) --------------------------------------------------------
signed int getMtu(void)
{
  signed int result; // r0
  int v1; // [sp+18h] [bp-A0h]
  int v2; // [sp+1Ch] [bp-9Ch]
  char v3; // [sp+20h] [bp-98h]
  char v4; // [sp+2Ch] [bp-8Ch]
  char v5; // [sp+38h] [bp-80h]
  char s; // [sp+67h] [bp-51h]

  result = read_file("/sys/class/net/wlan0/mtu", &v3, 0xAu);
  if ( result >= 0 )
  {
    strtol(&v3, 0, 10);
    v1 = 1;
    strcpy(&v5, "http://mobile.kukuplay.com/core/a/mtu.php?mtu=");
    memset(&s, 0, 0x35u);
    strcat(&v5, &v3);
    v2 = 10;
    result = doRequest(&v1, &v5, &v4, &v2, 16.0, 0, 0, 0);
  }
  return result;
}



//----- (0003591C) --------------------------------------------------------
signed int __fastcall sub_3591C(unsigned __int8 *a1, const char *a2, size_t a3)
{
  unsigned __int8 *v3; // r5
  size_t v4; // r6
  const char *v5; // r4
  size_t v6; // r0
  unsigned __int8 *v7; // r3
  const char *v8; // r1
  int v9; // r0
  int v10; // r12
  int v11; // t1
  int v12; // t1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = strlen(a2);
  if ( v6 <= v4 )
  {
    if ( !v6 )
      return 1;
    if ( *v3 == *(unsigned __int8 *)v5 )
    {
      v7 = v3;
      v8 = v5;
      v9 = (int)&v3[v6 - 1];
      while ( v7 != (unsigned __int8 *)v9 )
      {
        v11 = (v7++)[1];
        v10 = v11;
        v12 = *((unsigned __int8 *)v8++ + 1);
        if ( v10 != v12 )
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (00035994) --------------------------------------------------------
int __fastcall _JNIEnv::NewObject(int a1, int a2, int a3, int a4)
{
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r3 = a4;
  return (*(int (**)(void))(*(_DWORD *)a1 + 116))();
}

//----- (000359CC) --------------------------------------------------------
int __fastcall _JNIEnv::CallObjectMethod(int a1, int a2, int a3, int a4)
{
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r3 = a4;
  return (*(int (**)(void))(*(_DWORD *)a1 + 140))();
}

//----- (00035A04) --------------------------------------------------------
int __fastcall _JNIEnv::CallIntMethod(int a1, int a2, int a3, int a4)
{
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r3 = a4;
  return (*(int (**)(void))(*(_DWORD *)a1 + 200))();
}

//----- (00035A3C) --------------------------------------------------------
int __fastcall _JNIEnv::CallVoidMethod(int a1, int a2, int a3, int a4)
{
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r3 = a4;
  return (*(int (**)(void))(*(_DWORD *)a1 + 248))();
}

//----- (00035A74) --------------------------------------------------------
signed int __fastcall fifo_event_callback(int a1)
{
  int v1; // r6
  signed int v2; // r7
  int v3; // r9
  int v4; // r0
  int v5; // r3
  int v6; // r5
  int v7; // r8
  int v8; // r12
  int v9; // r8
  int v11; // ST0C_4
  int v12; // r0
  int v13; // r1
  int v14; // ST10_4
  int v15; // r0
  int v16; // r1
  int v17; // ST18_4
  int v18; // r0
  int v19; // r10
  int v20; // ST20_4
  char *v21; // r0
  int v22; // r0
  int v23; // r9
  int v24; // r10
  int v25; // r2
  int v26; // [sp+2Ch] [bp-2Ch]

  v1 = a1;
  if ( !dword_F3D78 )
    return -1;
  if ( (*(int (**)(void))(*(_DWORD *)myVm + 24))() >= 0 )
  {
    v2 = 0;
    goto LABEL_5;
  }
  if ( (*(int (**)(void))(*(_DWORD *)myVm + 16))() < 0 )
    return -1;
  v2 = 1;
LABEL_5:
  v3 = (*(int (**)(void))(*(_DWORD *)v26 + 24))();
  v4 = (*(int (**)(void))(*(_DWORD *)v26 + 132))();
  v6 = _JNIEnv::NewObject(v26, v3, v4, v5);
  (*(void (**)(void))(*(_DWORD *)v26 + 132))();
  (*(void (**)(void))(*(_DWORD *)v26 + 132))();
  v7 = (*(int (**)(void))(*(_DWORD *)v26 + 132))();
  v8 = (*(int (**)(void))(*(_DWORD *)v26 + 132))();
  if ( !v1 )
  {
    v11 = v8;
    v12 = (*(int (**)(void))(*(_DWORD *)v26 + 668))();
    v13 = *(_DWORD *)(gM + 4660) + 1044;
    v14 = v12;
    (*(void (**)(void))(*(_DWORD *)v26 + 668))();
    v15 = (*(int (**)(void))(*(_DWORD *)v26 + 668))();
    v16 = *(_DWORD *)(gM + 4660) + 31045;
    v17 = v15;
    (*(void (**)(void))(*(_DWORD *)v26 + 668))();
    v18 = (*(int (**)(void))(*(_DWORD *)v26 + 668))();
    v19 = v26;
    v20 = v18;
    v21 = GlobalManager::getPlayUrl((GlobalManager *)gM);
    (*(void (__fastcall **)(int, char *))(*(_DWORD *)v19 + 668))(v19, v21);
    v22 = (*(int (**)(void))(*(_DWORD *)v26 + 668))();
    v23 = *(unsigned __int8 *)(*(_DWORD *)(gM + 4660) + 31044);
    v24 = v22;
    _JNIEnv::CallVoidMethod(v26, v6, v7, v14);
    _JNIEnv::CallVoidMethod(v26, v6, v7, v17);
    _JNIEnv::CallVoidMethod(v26, v6, v7, v20);
    _JNIEnv::CallVoidMethod(v26, v6, v11, v24);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 92))(v26);
  }
  if ( !(*(int (__cdecl **)(int))(*(_DWORD *)v26 + 124))(v26) )
  {
    if ( v2 )
      (*(void (__cdecl **)(int))(*(_DWORD *)myVm + 20))(myVm);
    return -1;
  }
  v9 = (*(int (__cdecl **)(int))(*(_DWORD *)v26 + 132))(v26);
  if ( (*(int (__cdecl **)(int))(*(_DWORD *)v26 + 912))(v26) )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 64))(v26);
    (*(void (__cdecl **)(int))(*(_DWORD *)v26 + 68))(v26);
    if ( v9 )
      goto LABEL_10;
LABEL_20:
    v25 = (*(int (__cdecl **)(int))(*(_DWORD *)v26 + 132))(v26);
    if ( v25 )
      _JNIEnv::CallVoidMethod(v26, dword_F3D78, v25, v1);
    goto LABEL_11;
  }
  if ( !v9 )
    goto LABEL_20;
LABEL_10:
  _JNIEnv::CallVoidMethod(v26, dword_F3D78, v9, v1);
LABEL_11:
  if ( v2 )
    (*(void (__cdecl **)(int))(*(_DWORD *)myVm + 20))(myVm);
  return 0;
}
// F3D78: using guessed type int dword_F3D78;
// F3DB0: using guessed type int gM;
// F3DB4: using guessed type int myVm;

//----- (00035F94) --------------------------------------------------------
int __fastcall _JNIEnv::CallStaticBooleanMethod(int a1, int a2, int a3, int a4)
{
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r3 = a4;
  return (*(int (**)(void))(*(_DWORD *)a1 + 472))();
}

//----- (00035FCC) --------------------------------------------------------
signed int __fastcall JNI_OnLoad(int a1)
{
  myVm = a1;
  return 65538;
}
// F3DB4: using guessed type int myVm;

//----- (00035FE8) --------------------------------------------------------
int getCurrentDownloadRates()
{
  int v0; // r4
  ssize_t v1; // r5
  char *v3; // r0
  int v4; // [sp+0h] [bp-1420h]
  char buf[4]; // [sp+4h] [bp-141Ch]

  v4 = -1;
  v0 = open("/proc/net/dev", 0);
  if ( v0 < 0 )
    return -1;
  do
    v1 = read(v0, buf, 0x1400u);
  while ( v1 < 0 );
  close(v0);
  if ( !v1 )
    return -1;
  if ( v1 == 5120 )
    return -1;
  buf[v1] = 0;
  v3 = strstr(buf, "wlan0:");
  if ( !v3 )
    return -1;
  sscanf(v3, "wlan0:%u", &v4);
  return v4;
}
// 35FE8: using guessed type char buf[4];

//----- (000360F0) --------------------------------------------------------
GlobalManager *__fastcall p2pStart(GlobalManager *result, const char *a2)
{
  char *v2; // r6
  GlobalManager *v3; // r7

  v2 = (char *)result;
  if ( a2 )
  {
    strcpy(&currentChannelId, a2);
    v3 = (GlobalManager *)operator new(0x1240u);
    result = GlobalManager::GlobalManager(v3, &currentChannelId, v2, &packageName, (char *)&signatureHashCode);
    gM = (int)v3;
  }
  return result;
}
// F3DB0: using guessed type int gM;
// F55EC: using guessed type char packageName;
// F5650: using guessed type char currentChannelId;

//----- (0003617C) --------------------------------------------------------
int *__fastcall fifoInit(int a1, int a2, int a3, int a4)
{
  int v4; // r9
  int v5; // r10
  int v6; // r4
  int v7; // r8
  unsigned __int8 *v8; // r7
  int v9; // r5
  int v10; // r3
  int *result; // r0
  GlobalManager *v12; // [sp+4h] [bp-2Ch]

  v4 = a3;
  v5 = a4;
  v6 = a2;
  v7 = a1;
  v12 = (GlobalManager *)(*(int (**)(void))(*(_DWORD *)a1 + 676))();
  v8 = (unsigned __int8 *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v7 + 676))(v7, v5, 0);
  isMovieChannel = sub_3591C(v8, "17803_", 6u) || sub_3591C(v8, "8745833_", 8u) || sub_3591C(v8, "8971246_", 8u);
  v9 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v7 + 452))(v7, v6, "isWifiState", "()Z");
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v7 + 912))(v7) )
  {
    (*(void (__fastcall **)(int))(*(_DWORD *)v7 + 64))(v7);
    (*(void (__fastcall **)(int))(*(_DWORD *)v7 + 68))(v7);
  }
  if ( v9 )
    wifiState = _JNIEnv::CallStaticBooleanMethod(v7, v6, v9, v10) == 0;
  else
    wifiState = 2;
  unvisibleBufferSize = 0LL;
  playerReadBytes = 0;
  attachEvent((int)fifo_event_callback);
  p2pStart(v12, (const char *)v8);
  (*(void (__fastcall **)(int, int, GlobalManager *))(*(_DWORD *)v7 + 680))(v7, v4, v12);
  (*(void (__fastcall **)(int, int, unsigned __int8 *))(*(_DWORD *)v7 + 680))(v7, v5, v8);
  result = &currentState;
  currentState = 0;
  lastCardPoint = -1.0;
  return result;
}
// F3944: using guessed type int wifiState;
// F3DA4: using guessed type int playerReadBytes;
// F3DAC: using guessed type int currentState;
// F41B7: using guessed type char isMovieChannel;

//----- (000363B4) --------------------------------------------------------
char *__fastcall Java_com_libfifo_FifoController_decryptVipPlayInfo(int a1, int a2, int a3)
{
  int v3; // r7
  int v4; // r6
  char *v5; // r0
  void *v6; // r0
  _DWORD *v7; // r9
  int v8; // r0
  char *v9; // r3
  char *result; // r0
  int v11; // r8
  unsigned int *v12; // r3
  signed int v13; // r2
  unsigned int *v14; // r3
  signed int v15; // r2
  void *src; // [sp+Ch] [bp-834h]
  int v17; // [sp+10h] [bp-830h]
  int v18; // [sp+14h] [bp-82Ch]
  char v19; // [sp+18h] [bp-828h]
  int v20; // [sp+814h] [bp-2Ch]
  int v21; // [sp+818h] [bp-28h]

  v3 = a1;
  v4 = a3;
  if ( packageName )
  {
    if ( !strcmp(&packageName, "com.zhangyu") || !strcmp(&packageName, "air.fyzb3") )
    {
      if ( v4 )
      {
        v5 = (char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 676))(v3, v4, 0);
        src = &unk_2FEF48;
        sub_C1C58((void **)&v17, v5);
        Base64Decode(&v17, (int *)&src);
        v6 = (void *)(v17 - 12);
        if ( (int *)(v17 - 12) != &dword_2FEF3C )
        {
          v14 = (unsigned int *)(v17 - 4);
          __dmb(0xFu);
          do
            v15 = __ldrex(v14);
          while ( __strex(v15 - 1, v14) );
          __dmb(0xFu);
          if ( v15 <= 0 )
            operator delete(v6);
        }
        memset(&v18, 0, 0x800u);
        v7 = src;
        memcpy(&v18, src, *((_DWORD *)src - 3));
        *((_BYTE *)&v21 + *(v7 - 3) - 2052) = 0;
        if ( isNeedDecrypt((char *)&v18) )
        {
          v17 = 0;
          v11 = decryptChunk(&v19, *((_DWORD *)src - 3) - 4, &v17);
          memmove(&v18, (char *)&v18 + v17 + 4, v11);
          *((_BYTE *)&v21 + v11 - 2052) = 0;
        }
        v8 = (*(int (__fastcall **)(int, int *))(*(_DWORD *)v3 + 668))(v3, &v18);
        v9 = (char *)src;
        v4 = v8;
        result = (char *)src - 12;
        if ( (char *)src - 12 != (char *)&dword_2FEF3C )
          goto LABEL_13;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v4 = (unsigned __int8)packageName;
  }
  while ( 1 )
  {
    result = (char *)v4;
    v9 = (char *)_stack_chk_guard;
    if ( v20 == _stack_chk_guard )
      break;
LABEL_13:
    v12 = (unsigned int *)(v9 - 4);
    __dmb(0xFu);
    do
      v13 = __ldrex(v12);
    while ( __strex(v13 - 1, v12) );
    __dmb(0xFu);
    if ( v13 <= 0 )
      operator delete(result);
  }
  return result;
}
// F55EC: using guessed type char packageName;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00036628) --------------------------------------------------------
int *__fastcall Java_com_libfifo_FifoController_createFifo(int a1, int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r9
  int v6; // r8
  int v7; // r7
  void *v8; // r5
  int v9; // r3
  int (__fastcall *v10)(int, int, _DWORD); // r3
  int v11; // r0

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = (void *)gM;
  if ( gM )
  {
    GlobalManager::~GlobalManager((GlobalManager *)gM);
    operator delete(v8);
    gM = 0;
  }
  currentPlayMode = 0;
  v9 = *(_DWORD *)v4;
  interrupt = 0;
  v10 = *(int (__fastcall **)(int, int, _DWORD))(v9 + 676);
  startChangeCdnTime = 0;
  cardLongTime = 0LL;
  v11 = v10(v4, v7, 0);
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v4 + 680))(v4, v7, v11);
  memset(&currentSourceId, 0, 0x400u);
  memset(currentSourceSrc, 0, 0x400u);
  isPlayerStarted = 0;
  preReadBytes = 0;
  return fifoInit(v4, v5, v6, v7);
}
// F30E8: using guessed type int currentPlayMode;
// F3DA0: using guessed type int preReadBytes;
// F3DA8: using guessed type char isPlayerStarted;
// F3DB0: using guessed type int gM;
// F4988: using guessed type char currentSourceId;
// F5718: using guessed type int interrupt;
// F5728: using guessed type int startChangeCdnTime;

//----- (00036760) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_multiStreamCreateFifo(int *a1, int a2, int a3, int a4)
{
  int *v4; // r5
  int v5; // r8
  int v6; // r9
  void *v7; // r6
  int v8; // r3
  int (__fastcall *v9)(int *, int, _DWORD); // r3
  unsigned __int8 *v10; // r10
  GlobalManager *v11; // r9

  v4 = a1;
  v5 = a3;
  v6 = a4;
  v7 = (void *)gM;
  if ( gM )
  {
    GlobalManager::~GlobalManager((GlobalManager *)gM);
    operator delete(v7);
    gM = 0;
  }
  currentPlayMode = 1;
  lowDelayChannel = 1;
  interrupt = 0;
  v8 = *v4;
  startChangeCdnTime = 0;
  v9 = *(int (__fastcall **)(int *, int, _DWORD))(v8 + 676);
  cardLongTime = 0LL;
  v10 = (unsigned __int8 *)v9(v4, v5, 0);
  if ( v6 )
    bitrate = (char *)(*(int (__fastcall **)(int *, int, _DWORD))(*v4 + 676))(v4, v6, 0);
  else
    bitrate = "origin";
  isPlayerStarted = 0;
  preReadBytes = 0;
  attachEvent((int)fifo_event_callback);
  if ( v10 )
  {
    isMovieChannel = sub_3591C(v10, "17803_", 6u) || sub_3591C(v10, "8745833_", 8u) || sub_3591C(v10, "8971246_", 8u);
    strcpy(&currentChannelId, (const char *)v10);
    v11 = (GlobalManager *)operator new(0x1240u);
    GlobalManager::GlobalManager(v11, &currentChannelId, &packageName, (char *)&signatureHashCode);
    gM = (int)v11;
  }
  return (*(int (__fastcall **)(int *, int, unsigned __int8 *))(*v4 + 680))(v4, v5, v10);
}
// F30E8: using guessed type int currentPlayMode;
// F3948: using guessed type char *bitrate;
// F3DA0: using guessed type int preReadBytes;
// F3DA8: using guessed type char isPlayerStarted;
// F3DB0: using guessed type int gM;
// F419A: using guessed type char lowDelayChannel;
// F41B7: using guessed type char isMovieChannel;
// F55EC: using guessed type char packageName;
// F5650: using guessed type char currentChannelId;
// F5718: using guessed type int interrupt;
// F5728: using guessed type int startChangeCdnTime;

//----- (000369B0) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_createFifo2(int *a1, int a2, int a3)
{
  int *v3; // r8
  int v4; // r10
  void *v5; // r4
  int v6; // r3
  int (__fastcall *v7)(int *, int, _DWORD); // r3
  int v8; // r0
  unsigned __int8 *v9; // r4
  GlobalManager *v10; // r7

  v3 = a1;
  v4 = a3;
  v5 = (void *)gM;
  if ( gM )
  {
    GlobalManager::~GlobalManager((GlobalManager *)gM);
    operator delete(v5);
    gM = 0;
  }
  lowDelayChannel = 1;
  v6 = *v3;
  interrupt = 0;
  v7 = *(int (__fastcall **)(int *, int, _DWORD))(v6 + 676);
  startChangeCdnTime = 0;
  cardLongTime = 0LL;
  v8 = v7(v3, v4, 0);
  isPlayerStarted = 0;
  preReadBytes = 0;
  v9 = (unsigned __int8 *)v8;
  attachEvent((int)fifo_event_callback);
  if ( v9 )
  {
    isMovieChannel = sub_3591C(v9, "17803_", 6u) || sub_3591C(v9, "8745833_", 8u) || sub_3591C(v9, "8971246_", 8u);
    strcpy(&currentChannelId, (const char *)v9);
    v10 = (GlobalManager *)operator new(0x1240u);
    GlobalManager::GlobalManager(v10, &currentChannelId, &packageName, (char *)&signatureHashCode);
    gM = (int)v10;
  }
  return (*(int (__fastcall **)(int *, int, unsigned __int8 *))(*v3 + 680))(v3, v4, v9);
}
// F3DA0: using guessed type int preReadBytes;
// F3DA8: using guessed type char isPlayerStarted;
// F3DB0: using guessed type int gM;
// F419A: using guessed type char lowDelayChannel;
// F41B7: using guessed type char isMovieChannel;
// F55EC: using guessed type char packageName;
// F5650: using guessed type char currentChannelId;
// F5718: using guessed type int interrupt;
// F5728: using guessed type int startChangeCdnTime;

//----- (00036B90) --------------------------------------------------------
int __fastcall fifoClose(int a1, int a2)
{
  int v2; // r4
  int v3; // r7
  int v4; // r6
  int result; // r0

  v2 = a1;
  v3 = a2;
  v4 = (*(int (**)(void))(*(_DWORD *)a1 + 452))();
  result = (*(int (__fastcall **)(int))(*(_DWORD *)v2 + 912))(v2);
  if ( !result )
  {
    if ( v4 )
      goto LABEL_3;
LABEL_7:
    isCompatible = v4;
    return result;
  }
  (*(void (__fastcall **)(int))(*(_DWORD *)v2 + 64))(v2);
  result = (*(int (__fastcall **)(int))(*(_DWORD *)v2 + 68))(v2);
  if ( !v4 )
    goto LABEL_7;
LABEL_3:
  isCompatible = 1;
  result = _JNIEnv::CallStaticBooleanMethod(v2, v3, v4, (int)&isCompatible);
  if ( result )
    isCardToSwitch = 0;
  return result;
}
// F41B8: using guessed type char isCompatible;
// F41BA: using guessed type char isCardToSwitch;

//----- (00036C68) --------------------------------------------------------
void __fastcall Java_com_libfifo_FifoController_closeFifo(int a1, int a2)
{
  GlobalManager *v2; // r5

  fifoClose(a1, a2);
  bitrate = "origin";
  interrupt = 1;
  isPlayerStarted = 0;
  rtmpChangedToData = 0;
  lowDelayChannel = 0;
  if ( gM )
  {
    if ( isSwitchEntry )
    {
LABEL_3:
      v2 = (GlobalManager *)gM;
LABEL_4:
      GlobalManager::~GlobalManager(v2);
      operator delete((void *)v2);
LABEL_5:
      gM = 0;
      return;
    }
    if ( currentPlayMode )
    {
      if ( currentPlayMode != 1 )
        goto LABEL_3;
      add_play_cl2();
    }
    else
    {
      add_play_cl();
    }
    v2 = (GlobalManager *)gM;
    if ( !gM )
      goto LABEL_5;
    goto LABEL_4;
  }
}
// F30E8: using guessed type int currentPlayMode;
// F3948: using guessed type char *bitrate;
// F3DA8: using guessed type char isPlayerStarted;
// F3DB0: using guessed type int gM;
// F4199: using guessed type char rtmpChangedToData;
// F419A: using guessed type char lowDelayChannel;
// F41BB: using guessed type char isSwitchEntry;
// F5718: using guessed type int interrupt;

//----- (00036D6C) --------------------------------------------------------
double procSelfPause()
{
  double result; // r0

  currentState = 3;
  if ( lastCardPoint == -1.0 )
  {
    result = COERCE_DOUBLE(getTime());
    lastCardPoint = result;
    if ( !continueSwitchCount )
    {
      result = COERCE_DOUBLE(getTime());
      noDataStartTime = *(_QWORD *)&result;
    }
  }
  else
  {
    result = COERCE_DOUBLE(getTime());
    cardLongTime = result - lastCardPoint;
  }
  return result;
}
// F3DAC: using guessed type int currentState;
// F41B0: using guessed type int continueSwitchCount;

//----- (00036E0C) --------------------------------------------------------
int procSelfPlay()
{
  int result; // r0

  result = 0;
  lastCardPoint = -1.0;
  currentState = 2;
  cardLongTime = 0LL;
  noDataStartTime = 0LL;
  return result;
}
// F3DAC: using guessed type int currentState;

//----- (00036E7C) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_getFifoVersion(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 668))();
}

//----- (00036E9C) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_setClientInfo2(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // r8
  int v8; // r4
  int v9; // r11
  char *v10; // r10
  char *v11; // r9
  char *v12; // r3
  char *v13; // r2
  char *v14; // ST0C_4
  int v15; // r0
  int v17; // [sp+10h] [bp-40h]
  int v18; // [sp+14h] [bp-3Ch]
  char *v19; // [sp+18h] [bp-38h]
  char *v20; // [sp+1Ch] [bp-34h]
  char *v21; // [sp+20h] [bp-30h]
  char *v22; // [sp+24h] [bp-2Ch]

  v7 = a3;
  v8 = a1;
  v9 = a4;
  strcpy(platform, "android");
  strcpy(device, "android_phone");
  strcpy(reportPartnerId, "androidPlayer");
  sprintf(subReportPartnerId, "sub%s", reportPartnerId);
  _android_log_print(4, "fyzb", "native version %s-%d", version, 10016);
  if ( v7 )
  {
    v18 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v8 + 676))(v8, v7, 0);
    v22 = (char *)v18;
  }
  else
  {
    v22 = 0;
  }
  if ( v9 )
  {
    v10 = (char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v8 + 676))(v8, v9, 0);
    v19 = v10;
  }
  else
  {
    v10 = 0;
  }
  if ( a5 )
  {
    v11 = (char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v8 + 676))(v8, a5, 0);
    v20 = v11;
  }
  else
  {
    v11 = 0;
  }
  if ( a6 )
  {
    v12 = (char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v8 + 676))(v8, a6, 0);
    v21 = v12;
  }
  else
  {
    v12 = 0;
  }
  if ( a7 )
  {
    v14 = v12;
    v15 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v8 + 676))(v8, a7, 0);
    v12 = v14;
    v13 = (char *)v15;
    v17 = v15;
  }
  else
  {
    v13 = 0;
  }
  setClientInfo(v22, v10, v11, v12, v13);
  if ( v7 )
    (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 680))(v8, v7, v18);
  if ( v9 )
    (*(void (__fastcall **)(int, int, char *))(*(_DWORD *)v8 + 680))(v8, v9, v19);
  if ( a5 )
    (*(void (__fastcall **)(int, int, char *))(*(_DWORD *)v8 + 680))(v8, a5, v20);
  if ( a6 )
    (*(void (__fastcall **)(int, int, char *))(*(_DWORD *)v8 + 680))(v8, a6, v21);
  if ( a7 )
    (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 680))(v8, a7, v17);
  return initStatistic();
}
// 255E0: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00037144) --------------------------------------------------------
void Java_com_libfifo_FifoController_setPlayerVout()
{
  isPlayerStarted = 1;
  isCardToSwitch = 0;
  isSwitchEntry = 0;
  clientPlayerVout();
}
// F3DA8: using guessed type char isPlayerStarted;
// F41BA: using guessed type char isCardToSwitch;
// F41BB: using guessed type char isSwitchEntry;

//----- (00037180) --------------------------------------------------------
double Java_com_libfifo_FifoController_setPlayerCard()
{
  double result; // r0

  if ( isPlayerStarted )
  {
    clientPlayerCard();
    result = procSelfPause();
  }
  return result;
}
// F3DA8: using guessed type char isPlayerStarted;

//----- (000371A8) --------------------------------------------------------
int Java_com_libfifo_FifoController_setPlayerPlay()
{
  clientPlayerPlay();
  return procSelfPlay();
}

//----- (000371B8) --------------------------------------------------------
char *__fastcall getKey(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r4
  int v5; // r0
  int v6; // r8
  int v7; // r0
  int v8; // r3
  int v9; // r0
  int v10; // r9
  int v11; // r0
  int v12; // r10
  int v13; // r0
  int v14; // r3
  char *result; // r0
  int v16; // r6
  const char *v17; // r0
  int v18; // r0
  int v19; // r6
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r6
  int v25; // r0
  int v26; // r0
  int v27; // r3
  int v28; // r0
  char s; // [sp+Ch] [bp-44h]

  v3 = a3;
  v4 = a1;
  v5 = (*(int (**)(void))(*(_DWORD *)a1 + 124))();
  v6 = v5;
  v7 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v4 + 132))(
         v4,
         v5,
         "getPackageManager",
         "()Landroid/content/pm/PackageManager;");
  v9 = _JNIEnv::CallObjectMethod(v4, v3, v7, v8);
  v10 = v9;
  v11 = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 124))(v4, v9);
  v12 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v4 + 132))(
          v4,
          v11,
          "getPackageInfo",
          "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");
  v13 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v4 + 132))(
          v4,
          v6,
          "getPackageName",
          "()Ljava/lang/String;");
  result = (char *)_JNIEnv::CallObjectMethod(v4, v3, v13, v14);
  v16 = (int)result;
  if ( result )
  {
    v17 = (const char *)(*(int (__fastcall **)(int, char *, _DWORD))(*(_DWORD *)v4 + 676))(v4, result, 0);
    strcpy(&packageName, v17);
    v18 = _JNIEnv::CallObjectMethod(v4, v10, v12, v16);
    v19 = v18;
    v20 = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 124))(v4, v18);
    v21 = (*(int (__fastcall **)(int, int, const char *, const char *, signed int))(*(_DWORD *)v4 + 376))(
            v4,
            v20,
            "signatures",
            "[Landroid/content/pm/Signature;",
            64);
    v22 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v4 + 380))(v4, v19, v21);
    v23 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v4 + 692))(v4, v22, 0);
    v24 = v23;
    v25 = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 124))(v4, v23);
    v26 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v4 + 132))(
            v4,
            v25,
            "hashCode",
            "()I");
    v28 = _JNIEnv::CallIntMethod(v4, v24, v26, v27);
    sprintf(&s, "%u", v28);
    result = strcpy((char *)&signatureHashCode, &s);
  }
  else
  {
    packageName = (char)result;
  }
  return result;
}
// F55EC: using guessed type char packageName;

//----- (00037434) --------------------------------------------------------
char *__fastcall Java_com_libfifo_ZYTVVideoPlayerActivity_getPKNameAndSign(int a1, int a2)
{
  return getKey(a1, 0, a2);
}

//----- (00037440) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_setFifoEventHandler(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r4
  int result; // r0

  v3 = a3;
  v4 = a1;
  if ( dword_F3D78 )
  {
    (*(void (**)(void))(*(_DWORD *)a1 + 88))();
    dword_F3D78 = 0;
  }
  result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 84))(v4, v3);
  dword_F3D78 = result;
  return result;
}
// F3D78: using guessed type int dword_F3D78;

//----- (000374A0) --------------------------------------------------------
char *__fastcall Java_com_libfifo_FifoController_setDebug(int a1, int a2, int a3)
{
  int v3; // r0

  v3 = a3;
  if ( a3 )
    v3 = 1;
  return playerSetDebug(v3);
}

//----- (000374AC) --------------------------------------------------------
double Java_com_libfifo_FifoController_getCurrentPlayTime()
{
  double result; // r0
  M3U8Manager *v1; // r0

  if ( !isPlayerStarted || !gM )
    return 0.0;
  if ( GlobalManager::getStreamType((GlobalManager *)gM) == (int *)((char *)&dword_0 + 1) )
  {
    if ( isThirdSource )
    {
      result = COERCE_DOUBLE(getTime()) - 30.0;
    }
    else
    {
      if ( !gM || !*(_DWORD *)gM || !ioAllow )
        return 0.0;
      result = P2PManager::getCurrentPlayTime((P2PManager *)*(_DWORD *)gM);
    }
  }
  else
  {
    if ( GlobalManager::getStreamType((GlobalManager *)gM) != (int *)((char *)&dword_0 + 2) )
      return 0.0;
    v1 = *(M3U8Manager **)(gM + 4);
    if ( !v1 )
      return 0.0;
    result = M3U8Manager::getCurrentPlayTime(v1);
  }
  return result;
}
// 0: using guessed type int dword_0;
// F3DA8: using guessed type char isPlayerStarted;
// F3DB0: using guessed type int gM;
// F41BC: using guessed type int isThirdSource;
// F41C4: using guessed type int ioAllow;

//----- (000375A0) --------------------------------------------------------
int __fastcall Java_com_libfifo_FifoController_updateDataState(int a1, int a2, int a3)
{
  int result; // r0

  playerReadBytes = a3;
  result = addRtmpDownloadBytes(a3 - preReadBytes);
  preReadBytes = playerReadBytes;
  return result;
}
// F3DA0: using guessed type int preReadBytes;
// F3DA4: using guessed type int playerReadBytes;

//----- (000375D8) --------------------------------------------------------
signed int proxyInterruptCb(void)
{
  signed int result; // r0

  if ( g_globalManager )
    result = interrupt;
  else
    result = 1;
  return result;
}
// F3DBC: using guessed type int g_globalManager;
// F5718: using guessed type int interrupt;

//----- (0003760C) --------------------------------------------------------
int __fastcall GlobalManager::parallelDownloadData(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( a1
    && doRequest(
         *(volatile int **)a1,
         (char *)(a1 + 4),
         *(char **)(a1 + 1028),
         (int *)(a1 + 1032),
         (double)*(signed int *)(a1 + 1036),
         *(_DWORD *)(a1 + 1040),
         0,
         0) >= 0
    && **(_DWORD **)v1
    && *(_DWORD *)(v1 + 1032) > *(_DWORD *)(v1 + 1044) )
  {
    **(_DWORD **)v1 = 0;
  }
  return 0;
}

//----- (0003768C) --------------------------------------------------------
char *__fastcall GlobalManager::read_android_file(GlobalManager *this, const char *a2)
{
  const char *v2; // r6
  int v3; // r5
  char *v4; // r0
  char *v5; // r0
  char *v6; // r0
  char *v7; // r1
  char *v8; // r0
  char *v9; // r0
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  char *v13; // r0
  char *v14; // r0
  char *v15; // r0
  GlobalManager *v17; // [sp+1Ch] [bp-50h]
  int dest; // [sp+2Ch] [bp-40h]
  int v19; // [sp+30h] [bp-3Ch]
  int v20; // [sp+34h] [bp-38h]
  int v21; // [sp+38h] [bp-34h]
  int v22; // [sp+3Ch] [bp-30h]
  int v23; // [sp+40h] [bp-2Ch]
  int v24; // [sp+44h] [bp-28h]
  int v25; // [sp+48h] [bp-24h]
  int v26; // [sp+4Ch] [bp-20h]
  int v27; // [sp+50h] [bp-1Ch]
  int v28; // [sp+54h] [bp-18h]
  int v29; // [sp+58h] [bp-14h]
  int v30; // [sp+5Ch] [bp-10h]
  int v31; // [sp+60h] [bp-Ch]
  int v32; // [sp+64h] [bp-8h]
  int v33; // [sp+68h] [bp-4h]
  int v34; // [sp+6Ch] [bp+0h]
  char s; // [sp+ECh] [bp+80h]
  char v36[128]; // [sp+16Ch] [bp+100h]
  char buf; // [sp+1ECh] [bp+180h]
  int v38; // [sp+79F0h] [bp+7984h]

  v19 = 0;
  v20 = 0;
  v21 = 0;
  v2 = a2;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  dest = 0;
  v25 = 0;
  v26 = 0;
  v17 = this;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  memset(&v34, 0, 0x80u);
  memset(&s, 0, 0x80u);
  memset(v36, 0, 0x80u);
  v3 = open(v2, 0);
  if ( v3 < 0 )
    return strcpy(*((char **)v17 + 1167), defaultUA);
  while ( read(v3, &buf, 0x7800u) < 0 )
    ;
  v4 = strtok(&buf, "\n");
  strcpy(v36, v4);
  if ( strchr(v36, 13) )
    *((_BYTE *)&v38 + strlen(v36) - 30853) = 0;
  else
    v36[strlen(v36)] = 0;
  v5 = strstr(v36, "ro.product.locale.language");
  if ( v5 )
  {
    v6 = strchr(v5, 61);
    strcpy((char *)&dest, v6 + 1);
  }
  while ( 1 )
  {
    v7 = strtok(0, "\n");
    if ( !v7 )
      break;
    strcpy(v36, v7);
    if ( strchr(v36, 13) )
      *((_BYTE *)&v38 + strlen(v36) - 30853) = 0;
    else
      v36[strlen(v36)] = 0;
    v8 = strstr(v36, "ro.build.version.release");
    if ( v8 )
    {
      v9 = strchr(v8, 61);
      strcpy((char *)&v26, v9 + 1);
    }
    else
    {
      v10 = strstr(v36, "ro.product.model");
      if ( v10 )
      {
        v11 = strchr(v10, 61);
        strcpy((char *)&v34, v11 + 1);
      }
      else
      {
        v12 = strstr(v36, "ro.build.id");
        if ( v12 )
        {
          v13 = strchr(v12, 61);
          strcpy(&s, v13 + 1);
        }
        else
        {
          v14 = strstr(v36, "ro.product.locale.language");
          if ( v14 )
          {
            v15 = strchr(v14, 61);
            strcpy((char *)&dest, v15 + 1);
          }
        }
      }
    }
  }
  if ( (_BYTE)dest && (_BYTE)v26 && s && (_BYTE)v34 )
    sprintf(*((char **)v17 + 1167), "User-Agent: Mozilla/5.0(Linux; U; %s; Android %s; %s/%s)", &dest, &v26, &v34, &s);
  else
    strcpy(*((char **)v17 + 1167), defaultUA);
  return (char *)close(v3);
}
// F3048: using guessed type char *defaultUA;
// 3768C: using guessed type char var_7888[128];

//----- (00037A9C) --------------------------------------------------------
void __fastcall GlobalManager::fyzbEncode(GlobalManager *this)
{
  int v1; // r0
  _BYTE *v2; // r3
  int v3; // r2
  int v4; // r4
  _DWORD *v5; // r3
  int v6; // r2
  int v7; // r4
  _DWORD *v8; // r3
  int v9; // r2
  int v10; // r4
  _DWORD *v11; // r3
  int v12; // r2
  int v13; // r4
  _DWORD *v14; // r3
  int v15; // r2
  int v16; // r4
  _DWORD *v17; // r3
  int v18; // r2
  int v19; // r4
  _DWORD *v20; // r3
  int v21; // r2
  int v22; // r4
  _DWORD *v23; // r3
  int v24; // r2
  int v25; // r4
  _DWORD *v26; // r3
  int v27; // r2
  int v28; // r7
  _DWORD *v29; // r4
  size_t v30; // r0
  int v31; // r3
  int v32; // r7
  int v33; // r11
  _DWORD *v34; // r4
  size_t v35; // r0
  int v36; // r3
  int v37; // r7
  int v38; // r11
  _DWORD *v39; // r4
  unsigned __int16 v40; // r0
  int v41; // r3
  int v42; // r7
  __int16 v43; // r11
  _DWORD *v44; // r4
  char v45; // r0
  int v46; // r3
  int v47; // r7
  char v48; // r11
  size_t v49; // r4
  _DWORD *v50; // r10
  char v51; // r11
  int v52; // r2
  size_t v53; // r0
  unsigned int v54; // r1
  unsigned int v55; // r7
  char v56; // r11
  char v57; // r11
  int v58; // r4
  _DWORD *v59; // r3
  char *v60; // r4
  char *v61; // r0
  char *v62; // r3
  char *v63; // r0
  unsigned int *v64; // r3
  signed int v65; // r2
  unsigned int *v66; // r4
  signed int v67; // r3
  GlobalManager *v68; // [sp+4h] [bp-23Ch]
  char *v69; // [sp+Ch] [bp-234h]
  char *src; // [sp+10h] [bp-230h]
  char s[512]; // [sp+14h] [bp-22Ch]
  int v72; // [sp+214h] [bp-2Ch]

  v68 = this;
  memset(s, 0, 0x200u);
  sprintf(s, "pkName=%s&sign=%s", *((_DWORD *)v68 + 265), *((_DWORD *)v68 + 266));
  v69 = (char *)&unk_2FEF48;
  v1 = time(0);
  srand48(v1);
  v2 = &unk_2FEF48;
  v3 = dword_2FEF3C;
  v4 = dword_2FEF3C + 1;
  if ( (unsigned int)(dword_2FEF3C + 1) > unk_2FEF40 || *((_DWORD *)v69 - 1) > 0 )
  {
    sub_C1264(&v69, dword_2FEF3C + 1);
    v2 = v69;
    v3 = *((_DWORD *)v69 - 3);
  }
  v2[v3] = -1;
  v5 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v4;
    *(v5 - 1) = 0;
    *((_BYTE *)v5 + v4) = 0;
    v5 = v69;
  }
  v6 = *(v5 - 3);
  v7 = v6 + 1;
  if ( (unsigned int)(v6 + 1) > *(v5 - 2) || *(v5 - 1) > 0 )
  {
    sub_C1264(&v69, v6 + 1);
    v5 = v69;
    v6 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v5 + v6) = -1;
  v8 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v7;
    *(v8 - 1) = 0;
    *((_BYTE *)v8 + v7) = 0;
    v8 = v69;
  }
  v9 = *(v8 - 3);
  v10 = v9 + 1;
  if ( (unsigned int)(v9 + 1) > *(v8 - 2) || *(v8 - 1) > 0 )
  {
    sub_C1264(&v69, v9 + 1);
    v8 = v69;
    v9 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v8 + v9) = -1;
  v11 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v10;
    *(v11 - 1) = 0;
    *((_BYTE *)v11 + v10) = 0;
    v11 = v69;
  }
  v12 = *(v11 - 3);
  v13 = v12 + 1;
  if ( (unsigned int)(v12 + 1) > *(v11 - 2) || *(v11 - 1) > 0 )
  {
    sub_C1264(&v69, v12 + 1);
    v11 = v69;
    v12 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v11 + v12) = -2;
  v14 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v13;
    *(v14 - 1) = 0;
    *((_BYTE *)v14 + v13) = 0;
    v14 = v69;
  }
  v15 = *(v14 - 3);
  v16 = v15 + 1;
  if ( (unsigned int)(v15 + 1) > *(v14 - 2) || *(v14 - 1) > 0 )
  {
    sub_C1264(&v69, v15 + 1);
    v14 = v69;
    v15 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v14 + v15) = 53;
  v17 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v16;
    *(v17 - 1) = 0;
    *((_BYTE *)v17 + v16) = 0;
    v17 = v69;
  }
  v18 = *(v17 - 3);
  v19 = v18 + 1;
  if ( (unsigned int)(v18 + 1) > *(v17 - 2) || *(v17 - 1) > 0 )
  {
    sub_C1264(&v69, v18 + 1);
    v17 = v69;
    v18 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v17 + v18) = 89;
  v20 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v19;
    *(v20 - 1) = 0;
    *((_BYTE *)v20 + v19) = 0;
    v20 = v69;
  }
  v21 = *(v20 - 3);
  v22 = v21 + 1;
  if ( (unsigned int)(v21 + 1) > *(v20 - 2) || *(v20 - 1) > 0 )
  {
    sub_C1264(&v69, v21 + 1);
    v20 = v69;
    v21 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v20 + v21) = 1;
  v23 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v22;
    *(v23 - 1) = 0;
    *((_BYTE *)v23 + v22) = 0;
    v23 = v69;
  }
  v24 = *(v23 - 3);
  v25 = v24 + 1;
  if ( (unsigned int)(v24 + 1) > *(v23 - 2) || *(v23 - 1) > 0 )
  {
    sub_C1264(&v69, v24 + 1);
    v23 = v69;
    v24 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v23 + v24) = 1;
  v26 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v25;
    *(v26 - 1) = 0;
    *((_BYTE *)v26 + v25) = 0;
    v26 = v69;
  }
  v27 = *(v26 - 3);
  v28 = v27 + 1;
  if ( (unsigned int)(v27 + 1) > *(v26 - 2) || *(v26 - 1) > 0 )
  {
    sub_C1264(&v69, v27 + 1);
    v26 = v69;
    v27 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v26 + v27) = -114;
  v29 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v28;
    *(v29 - 1) = 0;
    *((_BYTE *)v29 + v28) = 0;
    v29 = v69;
  }
  v30 = strlen(s);
  v31 = *(v29 - 3);
  v32 = v31 + 1;
  v33 = (v30 >> 24) ^ 0x35;
  if ( (unsigned int)(v31 + 1) > *(v29 - 2) || *(v29 - 1) > 0 )
  {
    sub_C1264(&v69, v31 + 1);
    v29 = v69;
    v31 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v29 + v31) = v33;
  v34 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v32;
    *(v34 - 1) = 0;
    *((_BYTE *)v34 + v32) = 0;
    v34 = v69;
  }
  v35 = strlen(s);
  v36 = *(v34 - 3);
  v37 = v36 + 1;
  v38 = (v35 >> 16) & 0xFF ^ 0x59;
  if ( (unsigned int)(v36 + 1) > *(v34 - 2) || *(v34 - 1) > 0 )
  {
    sub_C1264(&v69, v36 + 1);
    v34 = v69;
    v36 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v34 + v36) = v38;
  v39 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v37;
    *(v39 - 1) = 0;
    *((_BYTE *)v39 + v37) = 0;
    v39 = v69;
  }
  v40 = strlen(s);
  v41 = *(v39 - 3);
  v42 = v41 + 1;
  v43 = (v40 >> 8) ^ 0x35;
  if ( (unsigned int)(v41 + 1) > *(v39 - 2) || *(v39 - 1) > 0 )
  {
    sub_C1264(&v69, v41 + 1);
    v39 = v69;
    v41 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v39 + v41) = v43;
  v44 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v42;
    *(v44 - 1) = 0;
    *((_BYTE *)v44 + v42) = 0;
    v44 = v69;
  }
  v45 = strlen(s);
  v46 = *(v44 - 3);
  v47 = v46 + 1;
  v48 = v45 ^ 0x59;
  if ( (unsigned int)(v46 + 1) > *(v44 - 2) || *(v44 - 1) > 0 )
  {
    sub_C1264(&v69, v46 + 1);
    v44 = v69;
    v46 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v44 + v46) = v48;
  v49 = 0;
  v50 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v47;
    *(v50 - 1) = 0;
    *((_BYTE *)v50 + v47) = 0;
    v50 = v69;
  }
  while ( 1 )
  {
    v53 = strlen(s);
    v52 = *(v50 - 3);
    v54 = *(v50 - 2);
    if ( v49 >= v53 )
      break;
    v55 = v52 + 1;
    v56 = s[v49];
    if ( v49 & 1 )
    {
      v51 = v56 ^ 0x59;
      if ( v55 > v54 || *(v50 - 1) > 0 )
      {
        sub_C1264(&v69, v52 + 1);
        v50 = v69;
        v52 = *((_DWORD *)v69 - 3);
      }
      *((_BYTE *)v50 + v52) = v51;
      v50 = v69;
      if ( v69 - 12 != (char *)&dword_2FEF3C )
      {
        *((_DWORD *)v69 - 3) = v55;
        *(v50 - 1) = 0;
        *((_BYTE *)v50 + v55) = 0;
        v50 = v69;
      }
    }
    else
    {
      v57 = v56 ^ 0x35;
      if ( v55 > v54 || *(v50 - 1) > 0 )
      {
        sub_C1264(&v69, v52 + 1);
        v50 = v69;
        v52 = *((_DWORD *)v69 - 3);
      }
      *((_BYTE *)v50 + v52) = v57;
      v50 = v69;
      if ( v69 - 12 != (char *)&dword_2FEF3C )
      {
        *((_DWORD *)v69 - 3) = v55;
        *(v50 - 1) = 0;
        *((_BYTE *)v50 + v55) = 0;
        v50 = v69;
      }
    }
    ++v49;
  }
  v58 = v52 + 1;
  if ( v52 + 1 > v54 || *(v50 - 1) > 0 )
  {
    sub_C1264(&v69, v52 + 1);
    v50 = v69;
    v52 = *((_DWORD *)v69 - 3);
  }
  *((_BYTE *)v50 + v52) = -114;
  v59 = v69;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
  {
    *((_DWORD *)v69 - 3) = v58;
    *(v59 - 1) = 0;
    *((_BYTE *)v59 + v58) = 0;
  }
  src = (char *)&unk_2FEF48;
  Base64Encode((int *)&v69, (int *)&src);
  v60 = src;
  strcpy((char *)v68 + 1068, src);
  v61 = v60 - 12;
  if ( v60 - 12 != (char *)&dword_2FEF3C )
  {
    v66 = (unsigned int *)(v60 - 4);
    __dmb(0xFu);
    do
      v67 = __ldrex(v66);
    while ( __strex(v67 - 1, v66) );
    __dmb(0xFu);
    if ( v67 <= 0 )
      operator delete(v61);
  }
  v62 = v69;
  v63 = v69 - 12;
  if ( v69 - 12 != (char *)&dword_2FEF3C )
    goto LABEL_89;
  while ( 1 )
  {
    v62 = (char *)_stack_chk_guard;
    if ( v72 == _stack_chk_guard )
      break;
LABEL_89:
    v64 = (unsigned int *)(v62 - 4);
    __dmb(0xFu);
    do
      v65 = __ldrex(v64);
    while ( __strex(v65 - 1, v64) );
    __dmb(0xFu);
    if ( v65 <= 0 )
      operator delete(v63);
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;
// 37A9C: using guessed type char s[512];

//----- (0003822C) --------------------------------------------------------
void setCurrentSourceInvalid(void)
{
  void *v0; // r5
  int v1; // r7
  pthread_mutex_t *v2; // r8
  int v3; // r4
  const char *v4; // r6
  int v5; // r3

  if ( currentSourceId )
  {
    v0 = operator new(0x20u);
    *((_QWORD *)v0 + 2) = 0LL;
    *(_DWORD *)v0 = 0;
    *((_DWORD *)v0 + 1) = 0;
    *((_DWORD *)v0 + 2) = 0;
    *((_DWORD *)v0 + 3) = 0;
    *((_DWORD *)v0 + 6) = 0;
    *(_DWORD *)v0 = strdup(&currentSourceId);
    *((_DWORD *)v0 + 1) = strdup(currentSourceSrc);
    *((_QWORD *)v0 + 2) = getTime();
    *((_DWORD *)v0 + 6) = 0;
    *((_DWORD *)v0 + 3) = currentStreamType;
    v1 = invalidSource;
    v2 = (pthread_mutex_t *)(invalidSource + 4);
    pthread_mutex_lock((pthread_mutex_t *)(invalidSource + 4));
    if ( !*(_DWORD *)v1 )
    {
LABEL_7:
      pthread_mutex_unlock(v2);
      free(*(void **)v0);
      free(*((void **)v0 + 1));
      operator delete(v0);
      return;
    }
    v3 = *(_DWORD *)(*(_DWORD *)v1 + 24);
    *((_QWORD *)v0 + 2) = getTime();
    if ( v3 )
    {
      v4 = *(const char **)v0;
      while ( strcmp(*(const char **)v3, v4) )
      {
        v3 = *(_DWORD *)(v3 + 24);
        if ( !v3 )
          goto LABEL_8;
      }
      goto LABEL_7;
    }
LABEL_8:
    v5 = *(_DWORD *)v1;
    *((_DWORD *)v0 + 6) = *(_DWORD *)(*(_DWORD *)v1 + 24);
    *(_DWORD *)(v5 + 24) = v0;
    pthread_mutex_unlock(v2);
  }
}
// F41D4: using guessed type int currentStreamType;
// F41D8: using guessed type int invalidSource;
// F4988: using guessed type char currentSourceId;

//----- (00038368) --------------------------------------------------------
GlobalManager *__fastcall GlobalManager::GlobalManager(GlobalManager *this, char *a2, char *a3, char *a4)
{
  GlobalManager *v4; // r4
  char *v5; // r10
  char *v6; // r7

  v4 = this;
  v5 = a4;
  *((_DWORD *)this + 5) = -1;
  *((_DWORD *)this + 1165) = 0;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  v6 = a2;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 1166) = 0;
  *((_DWORD *)this + 1167) = 0;
  *((_DWORD *)this + 263) = 1;
  *((_DWORD *)this + 907) = 1;
  interrupt = 0;
  *((_DWORD *)this + 265) = strdup(a3);
  *((_DWORD *)v4 + 266) = strdup(v5);
  memset((char *)v4 + 1068, 0, 0x200u);
  if ( v6 )
    *((_DWORD *)v4 + 264) = strdup(v6);
  currentStreamType = 0;
  currentAvailableStreamNum = 0;
  cpIsNull = 1;
  initSingleChannelStatistic();
  add_fifo_cr2();
  return v4;
}
// F30D8: using guessed type char cpIsNull;
// F41D0: using guessed type int currentAvailableStreamNum;
// F41D4: using guessed type int currentStreamType;
// F5718: using guessed type int interrupt;

//----- (00038458) --------------------------------------------------------
GlobalManager *__fastcall GlobalManager::GlobalManager(GlobalManager *this, char *a2, char *a3, char *a4, char *a5)
{
  GlobalManager *v5; // r4
  char *v6; // r8
  char *v7; // r7
  char *v8; // r10
  void *v9; // r0
  GlobalManager *result; // r0

  v5 = this;
  *((_DWORD *)this + 5) = -1;
  *((_DWORD *)this + 1165) = 0;
  v6 = a2;
  *((_DWORD *)this + 2) = 0;
  v7 = a3;
  interrupt = 0;
  *((_DWORD *)this + 263) = 1;
  *((_DWORD *)this + 264) = 0;
  v8 = a4;
  *((_DWORD *)this + 265) = 0;
  *((_DWORD *)this + 266) = 0;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 1166) = 0;
  memset((char *)this + 1068, 0, 0x200u);
  v9 = malloc(0x400u);
  *((_DWORD *)v5 + 1167) = v9;
  memset(v9, 0, 0x400u);
  if ( v6 )
    *((_DWORD *)v5 + 264) = strdup(v6);
  if ( v7 )
    strcpy((char *)v5 + 28, v7);
  *((_DWORD *)v5 + 265) = strdup(v8);
  *((_DWORD *)v5 + 266) = strdup(a5);
  initSingleChannelStatistic();
  add_fifo_cr();
  currentStreamType = 0;
  currentAvailableStreamNum = 0;
  cpIsNull = 1;
  pthread_create((pthread_t *)v5 + 2, 0, (void *(*)(void *))downloadChannelInfoThreadWithFifo, (void *)v5);
  result = v5;
  g_globalManager = (int)v5;
  return result;
}
// F30D8: using guessed type char cpIsNull;
// F3DBC: using guessed type int g_globalManager;
// F41D0: using guessed type int currentAvailableStreamNum;
// F41D4: using guessed type int currentStreamType;
// F5718: using guessed type int interrupt;

//----- (000385AC) --------------------------------------------------------
int __fastcall GlobalManager::createWriteChannel(GlobalManager *this)
{
  GlobalManager *v1; // r8
  signed int v2; // r5
  int result; // r0
  int v4; // r0
  int v5; // r7
  bool v6; // nf
  int v7; // r0
  int v8; // r0
  int v9; // [sp+1Ch] [bp-44h]
  int v10; // [sp+20h] [bp-40h]
  struct sockaddr addr; // [sp+24h] [bp-3Ch]

  v1 = this;
  v2 = -1;
  close(*((_DWORD *)this + 5));
  gettimeofday((struct timeval *)&v9, 0);
  srand48(v10 / 0x3E8uLL + 1000 * v9);
  while ( !interrupt && v2 <= 0 )
  {
    v4 = lrand48();
    *(_DWORD *)&addr.sa_data[6] = 0;
    *(_DWORD *)&addr.sa_data[10] = 0;
    addr.sa_family = 2;
    v2 = v4 % 64510 + 1025;
    *(_WORD *)addr.sa_data = __rev16(v2);
    *(_DWORD *)&addr.sa_data[2] = 16777343;
    result = socket(2, 1, 0);
    v5 = result;
    if ( result >= 0 )
    {
      v9 = 1;
      setsockopt(result, 6, 1, &v9, 4u);
      v6 = bind(v5, &addr, 0x10u) < 0;
      v7 = v5;
      if ( v6 )
        goto LABEL_10;
      if ( listen(v5, 10) < 0 )
      {
        v7 = v5;
        v2 = -1;
LABEL_10:
        result = close(v7);
      }
      else
      {
        v8 = fcntl(v5, 3, 0);
        fcntl(v5, 4, v8 | 0x800);
        *((_DWORD *)v1 + 5) = v5;
        result = sprintf((char *)v1 + 3632, "http://127.0.0.1:%d", v2);
      }
    }
  }
  return result;
}
// F5718: using guessed type int interrupt;

//----- (0003876C) --------------------------------------------------------
GlobalManager *__fastcall GlobalManager::~GlobalManager(GlobalManager *this)
{
  GlobalManager *v1; // r4
  void *v2; // r1
  int v3; // r2
  pthread_t v4; // r0
  P2PManager *v5; // r5
  void *v6; // r5
  void *v7; // r5
  void *v8; // r5
  void *v9; // r0
  void *v10; // r0
  void *v11; // r0
  void *v12; // r0

  v1 = this;
  interrupt = 1;
  finishSingleChannelStatistic();
  v4 = *((_DWORD *)v1 + 2);
  *((_DWORD *)v1 + 263) = 0;
  if ( v4 )
  {
    pthread_join(v4, 0);
    *((_DWORD *)v1 + 2) = 0;
  }
  v5 = *(P2PManager **)v1;
  if ( *(_DWORD *)v1 )
  {
    P2PManager::~P2PManager(*(P2PManager **)v1);
    operator delete((void *)v5);
    *(_DWORD *)v1 = 0;
  }
  v6 = (void *)*((_DWORD *)v1 + 1);
  if ( v6 )
  {
    M3U8Manager::~M3U8Manager(*((M3U8Manager **)v1 + 1));
    operator delete(v6);
    *((_DWORD *)v1 + 1) = 0;
  }
  v7 = (void *)*((_DWORD *)v1 + 1166);
  if ( v7 )
  {
    ThirdM3U8Manager::~ThirdM3U8Manager(*((ThirdM3U8Manager **)v1 + 1166));
    operator delete(v7);
    *((_DWORD *)v1 + 1166) = 0;
  }
  v8 = (void *)*((_DWORD *)v1 + 1165);
  if ( v8 )
  {
    ChannelPlayInfoManager::~ChannelPlayInfoManager(*((ChannelPlayInfoManager **)v1 + 1165), v2, v3);
    operator delete(v8);
    *((_DWORD *)v1 + 1165) = 0;
  }
  v9 = (void *)*((_DWORD *)v1 + 264);
  if ( v9 )
  {
    free(v9);
    *((_DWORD *)v1 + 264) = 0;
  }
  v10 = (void *)*((_DWORD *)v1 + 1167);
  if ( v10 )
  {
    free(v10);
    *((_DWORD *)v1 + 1167) = 0;
  }
  v11 = (void *)*((_DWORD *)v1 + 265);
  if ( v11 )
  {
    free(v11);
    *((_DWORD *)v1 + 265) = 0;
  }
  v12 = (void *)*((_DWORD *)v1 + 266);
  if ( v12 )
  {
    free(v12);
    *((_DWORD *)v1 + 266) = 0;
  }
  return v1;
}
// F5718: using guessed type int interrupt;

//----- (000388B4) --------------------------------------------------------
_DWORD *__fastcall GlobalManager::getStreamType(GlobalManager *this)
{
  _DWORD *result; // r0

  result = (_DWORD *)*((_DWORD *)this + 1165);
  if ( result )
    result = (_DWORD *)*result;
  return result;
}

//----- (000388C8) --------------------------------------------------------
char *__fastcall GlobalManager::getPlayUrl(GlobalManager *this)
{
  return (char *)this + 3632;
}

//----- (000388D0) --------------------------------------------------------
int __fastcall GlobalManager::nativeStart(GlobalManager *this)
{
  GlobalManager *v1; // r4
  int v2; // r7
  int v4; // r9
  ThirdM3U8Manager *v5; // r8
  int v6; // r7
  M3U8Manager *v7; // r5
  int v8; // r7
  P2PManager *v9; // r5
  void *v10; // r9
  void (__fastcall *v11)(int *, char *(__fastcall *)(char *), signed int (*)(void)); // r10
  char *v12; // r3
  char *v13; // r2
  int v14; // r0
  int v15; // t1
  int v16; // t1
  int v17; // r9
  char *v18; // r8
  ThirdM3U8Manager *v19; // r7
  char v20; // [sp+Bh] [bp-425h]
  int v21; // [sp+Ch] [bp-424h]

  v1 = this;
  memset(&v21, 0, 0x400u);
  memset((char *)v1 + 3632, 0, 0x400u);
  if ( *((_DWORD *)v1 + 907) == 1 )
  {
    ChannelPlayInfoManager::selectStream(*((ChannelPlayInfoManager **)v1 + 1165));
    strcpy((char *)&v21, (const char *)(*((_DWORD *)v1 + 1165) + 33400));
    GlobalManager::createWriteChannel(v1);
  }
  switch ( **((_DWORD **)v1 + 1165) )
  {
    case 1:
      add_flv();
      v8 = *((_DWORD *)v1 + 5);
      v9 = (P2PManager *)operator new(0x604u);
      P2PManager::P2PManager(v9, *((ChannelPlayInfoManager **)v1 + 1165), v8, 0);
      *(_DWORD *)v1 = v9;
      v2 = 0;
      break;
    case 2:
      add_m3u8();
      GlobalManager::read_android_file(v1, "/system/build.prop");
      v6 = *((_DWORD *)v1 + 5);
      v7 = (M3U8Manager *)operator new(0x228u);
      M3U8Manager::M3U8Manager(v7, *((ChannelPlayInfoManager **)v1 + 1165), v6, *((char **)v1 + 1167));
      *((_DWORD *)v1 + 1) = v7;
      M3U8Manager::clientStart(v7);
      v2 = 0;
      break;
    case 3:
      add_direct();
      GlobalManager::read_android_file(v1, "/system/build.prop");
      v4 = *((_DWORD *)v1 + 5);
      v5 = (ThirdM3U8Manager *)operator new(0x80u);
      ThirdM3U8Manager::ThirdM3U8Manager(v5, *((char **)v1 + 264), v4, (char *)&v21, *((char **)v1 + 1167));
      *((_DWORD *)v1 + 1166) = v5;
      if ( !v5 )
        goto LABEL_8;
      if ( interrupt )
        goto LABEL_8;
      v2 = ThirdM3U8Manager::clientStart(v5);
      if ( v2 )
        goto LABEL_8;
      FifoM3u8DataManager::writeFifoThread(
        **((FifoM3u8DataManager ***)v1 + 1166),
        *((_DWORD *)v1 + 5),
        (int (__cdecl *)(unsigned __int8 *, int))cbReadSource);
      break;
    case 4:
      v10 = dlopen("/data/data/air.fyzb3/files/liburlgen.so", 0);
      if ( v10 || (v10 = dlopen("/data/data/air.fyzb3/lib/liburlgen.so", 0)) != 0 )
      {
        v11 = (void (__fastcall *)(int *, char *(__fastcall *)(char *), signed int (*)(void)))dlsym(v10, "parseUrl");
        dlclose(v10);
        if ( v11 )
        {
          v11(&v21, proxyParseDoneCb, proxyInterruptCb);
          if ( *((_BYTE *)v1 + 3632) )
          {
            v12 = &v20;
            v13 = &algn_E06E9[2];
            do
            {
              v15 = (unsigned __int8)(v12++)[1];
              v14 = v15;
              v16 = (unsigned __int8)(v13++)[1];
              if ( v14 != v16 )
                return 0;
            }
            while ( v12 != (char *)&v21 + 3 );
            **((_DWORD **)v1 + 1165) = 3;
            GlobalManager::read_android_file(v1, "/system/build.prop");
            v17 = *((_DWORD *)v1 + 5);
            v18 = GlobalManager::getPlayUrl(v1);
            v19 = (ThirdM3U8Manager *)operator new(0x80u);
            ThirdM3U8Manager::ThirdM3U8Manager(v19, *((char **)v1 + 264), v17, v18, *((char **)v1 + 1167));
            *((_DWORD *)v1 + 1166) = v19;
            if ( v19 )
            {
              v2 = ThirdM3U8Manager::clientStart(v19);
              if ( !v2 )
              {
                FifoM3u8DataManager::writeFifoThread(
                  **((FifoM3u8DataManager ***)v1 + 1166),
                  *((_DWORD *)v1 + 5),
                  (int (__cdecl *)(unsigned __int8 *, int))cbReadSource);
                return v2;
              }
            }
          }
        }
      }
LABEL_8:
      v2 = 1;
      break;
    default:
      v2 = -1;
      break;
  }
  return v2;
}
// F5718: using guessed type int interrupt;

//----- (00038C60) --------------------------------------------------------
int __fastcall GlobalManager::nativeRestart(GlobalManager *this)
{
  GlobalManager *v1; // ST04_4

  if ( !currentPlayMode )
  {
    v1 = this;
    setCurrentSourceInvalid();
    this = v1;
  }
  return GlobalManager::nativeStart(this);
}
// F30E8: using guessed type int currentPlayMode;

//----- (00038C98) --------------------------------------------------------
int __fastcall GlobalManager::startRoutine(GlobalManager *this, int a2)
{
  int v2; // r5
  double v3; // d9
  int v4; // r6
  void **v5; // r9
  void *v6; // r0
  double v7; // d8
  int v8; // r7
  char *v9; // r5
  char *v10; // r8
  signed int v11; // r6
  size_t v12; // r0
  size_t v13; // r0
  signed int v14; // r3
  int v15; // r12
  double v16; // d8
  int *v17; // r4
  pthread_t v18; // r0
  pthread_t v19; // t1
  char *v21; // r0
  int v22; // r5
  const void *v23; // r1
  signed int v24; // r2
  int v25; // r5
  ChannelPlayInfoManager *v26; // r6
  signed int v27; // r5
  char v28; // [sp+8h] [bp-1930h]
  char v29; // [sp+Ch] [bp-192Ch]
  int v30; // [sp+18A4h] [bp-94h]
  const char *v31; // [sp+18A8h] [bp-90h]
  const char *v32; // [sp+18ACh] [bp-8Ch]
  GlobalManager *v33; // [sp+18B0h] [bp-88h]
  int *v34; // [sp+18B4h] [bp-84h]
  GlobalManager *v35; // [sp+18B8h] [bp-80h]
  char *v36; // [sp+18BCh] [bp-7Ch]
  void *v37; // [sp+18C0h] [bp-78h]
  int v38; // [sp+18C4h] [bp-74h]
  int v39; // [sp+18C8h] [bp-70h]
  int v40; // [sp+18DCh] [bp-5Ch]
  int v41; // [sp+18E0h] [bp-58h]

  v2 = a2;
  v35 = this;
  v37 = malloc(0x7A120u);
  memset(v37, 0, 0x7A120u);
  v3 = COERCE_DOUBLE(getTime());
  v4 = 0;
  v5 = (void **)&v41;
  *((_DWORD *)v35 + 907) = v2;
  v34 = &v39;
  do
  {
    v6 = malloc(0xC800u);
    *(int *)((char *)&v41 + v4) = (int)v6;
    memset(v6, 0, 0xC800u);
    *(int *)((char *)&v39 + v4) = 0;
    v4 += 4;
  }
  while ( v4 != 24 );
  v7 = v3;
  v8 = 0;
  v38 = 1;
  v36 = &v28;
  v9 = &v29;
  v10 = (char *)v35 + 1580;
  v11 = 0;
  v31 = "http://backupapi.mobile.kukuplay.com/SourceManager/playinfo?cid=%s&version=%s&key=%s";
  v32 = "http://api.kukuplay.com/SourceManager/playinfo?cid=%s&version=%s&key=%s";
  v33 = (GlobalManager *)((char *)v35 + 1068);
  while ( !interrupt )
  {
    GlobalManager::fyzbEncode(v35);
    if ( v11 & 1 )
    {
      if ( (v11 & 1) == 1 )
        sprintf(v10, v31, *((_DWORD *)v35 + 264), version, v33);
    }
    else
    {
      sprintf(v10, v32, *((_DWORD *)v35 + 264), version, v33);
    }
    *((_DWORD *)v9 - 1) = &v38;
    v12 = strlen(v10);
    strncpy(v9, v10, v12);
    v13 = strlen(v10);
    v14 = 0;
    v15 = *(int *)((char *)&v41 + v8);
    v36[1048 * v11 + 4 + v13] = 0;
    *((_DWORD *)v9 + 258) = 6;
    *((_DWORD *)v9 + 260) = 12;
    *((_DWORD *)v9 + 257) = 0;
    if ( v11 <= 2 )
      v14 = 1;
    *((_DWORD *)v9 + 256) = v15;
    *((_DWORD *)v9 + 259) = v14;
    pthread_create((pthread_t *)((char *)&v39 + v8), 0, (void *(*)(void *))GlobalManager::parallelDownloadData, v9 - 4);
    while ( !interrupt && v38 && v7 - v3 < (double)(v11 + 1) )
    {
      usleep(0x2710u);
      v7 = COERCE_DOUBLE(getTime());
    }
    if ( v38 )
    {
      if ( interrupt )
      {
        v38 = 0;
        break;
      }
      ++v11;
      v9 += 1048;
      v8 += 4;
      if ( v11 != 6 )
        continue;
    }
    v16 = COERCE_DOUBLE(getTime());
    while ( !interrupt && v38 )
    {
      usleep(0x2710u);
      if ( COERCE_DOUBLE(getTime()) - v16 > 5.0 )
        goto LABEL_23;
    }
    if ( !interrupt )
    {
      v21 = v36;
      v22 = 0;
      while ( 1 )
      {
        v23 = (const void *)*((_DWORD *)v21 + 257);
        if ( v23 )
        {
          v24 = *((_DWORD *)v21 + 258);
          if ( v24 > *((_DWORD *)v21 + 261) )
            break;
        }
        ++v22;
        v21 += 1048;
        if ( v22 == 6 )
        {
          v25 = -1;
          goto LABEL_37;
        }
      }
      memcpy(v37, v23, v24);
      v25 = *(_DWORD *)&v36[1048 * v22 + 1032];
LABEL_37:
      if ( v25 >= *((_DWORD *)v36 + 261) )
      {
        *((_DWORD *)v35 + 1164) = 2;
        CDN_RATION = 5;
        v26 = (ChannelPlayInfoManager *)operator new(0x8678u);
        ChannelPlayInfoManager::ChannelPlayInfoManager(v26, (char *)v37, v25);
        *((_DWORD *)v35 + 1165) = v26;
        if ( !allowRtmpChangeToData || rtmpChangedToData )
        {
          rtmpChangedToData = 0;
          if ( currentPlayMode )
          {
            if ( currentPlayMode == 1 )
              add_play_cp2();
          }
          else
          {
            add_play_cp();
          }
          if ( !interrupt )
            v30 = GlobalManager::nativeStart(v35);
          if ( v30 == 1 && !interrupt )
          {
            v27 = 20;
            do
            {
              if ( GlobalManager::nativeRestart(v35) != 1 )
                break;
              if ( interrupt )
                break;
              --v27;
            }
            while ( v27 );
          }
        }
        else
        {
          add_play_cp2();
          add_play_rtmpToFifo();
          rtmpChangedToData = 1;
          cloneChannelInfo();
        }
        if ( cpIsNull || !interrupt && (sendEventToPlayer(0), cpIsNull) )
        {
          if ( !interrupt )
            add_play_cpnull();
        }
      }
    }
    break;
  }
LABEL_23:
  if ( !interrupt && *((_DWORD *)v35 + 1164) != 2 )
  {
    sendEventToPlayer(256);
    add_play_cpFail();
  }
  v17 = &v38;
  if ( v38 )
    v38 = 0;
  do
  {
    v19 = v17[1];
    ++v17;
    v18 = v19;
    if ( v19 )
      pthread_join(v18, 0);
    ffFree(v5);
    ++v5;
  }
  while ( v17 != &v40 );
  printf("resBuffer = %s \n", v37);
  ffFree(&v37);
  return 0;
}
// F30D8: using guessed type char cpIsNull;
// F30E8: using guessed type int currentPlayMode;
// F30EC: using guessed type int CDN_RATION;
// F4199: using guessed type char rtmpChangedToData;
// F419B: using guessed type char allowRtmpChangeToData;
// F5718: using guessed type int interrupt;

//----- (000391F0) --------------------------------------------------------
int __fastcall downloadChannelInfoThreadWithRtmp(void *a1)
{
  return GlobalManager::startRoutine((GlobalManager *)a1, 0);
}

//----- (000391F8) --------------------------------------------------------
int __fastcall downloadChannelInfoThreadWithFifo(void *a1)
{
  return GlobalManager::startRoutine((GlobalManager *)a1, 1);
}

//----- (00039200) --------------------------------------------------------
char *__fastcall GlobalManager::setPlayUrl(GlobalManager *this, char *a2)
{
  return strcpy((char *)this + 3632, a2);
}

//----- (00039208) --------------------------------------------------------
char *__fastcall proxyParseDoneCb(char *a1)
{
  char *v1; // r1
  char *result; // r0

  v1 = a1;
  result = (char *)g_globalManager;
  if ( g_globalManager )
    result = GlobalManager::setPlayUrl((GlobalManager *)g_globalManager, v1);
  return result;
}
// F3DBC: using guessed type int g_globalManager;

//----- (00039228) --------------------------------------------------------
_DWORD *__fastcall MD5Init(_DWORD *result)
{
  result[2] = 1732584193;
  result[3] = -271733879;
  result[4] = -1732584194;
  result[5] = 271733878;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (00039268) --------------------------------------------------------
int __fastcall MD5Encode(int result, unsigned int *a2, unsigned int a3)
{
  int v3; // r3
  unsigned int v4; // r12
  unsigned int v5; // t1

  if ( a3 )
  {
    v3 = result;
    v4 = 0;
    do
    {
      v3 += 4;
      *(_BYTE *)(result + v4) = *a2;
      v4 += 4;
      v5 = *a2;
      ++a2;
      *(_BYTE *)(v3 - 3) = BYTE1(v5);
      *(_BYTE *)(v3 - 2) = *((_WORD *)a2 - 1);
      *(_BYTE *)(v3 - 1) = *((_BYTE *)a2 - 1);
    }
    while ( a3 > v4 );
  }
  return result;
}

//----- (000392B8) --------------------------------------------------------
int __fastcall MD5Decode(int result, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // r12
  unsigned int v4; // r3
  int v5; // r4

  if ( a3 )
  {
    v3 = a2;
    v4 = 0;
    do
    {
      v5 = v3[2];
      v3 += 4;
      *(_DWORD *)(result + v4) = (v5 << 16) | (*(v3 - 3) << 8) | a2[v4] | (*(v3 - 1) << 24);
      v4 += 4;
    }
    while ( a3 > v4 );
  }
  return result;
}

//----- (00039308) --------------------------------------------------------
unsigned int __fastcall MD5Transform(unsigned int *a1, unsigned __int8 *a2)
{
  unsigned int *v2; // r4
  unsigned int v3; // r7
  unsigned int v4; // r9
  unsigned int v5; // r8
  unsigned int v6; // r6
  int v7; // r12
  int v8; // r2
  int v9; // r3
  int v10; // r8
  int v11; // r7
  int v12; // r6
  int v13; // r0
  int v14; // r1
  int v15; // r12
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r11
  int v20; // r7
  int v21; // r6
  int v22; // r2
  int v23; // r3
  int v24; // r8
  int v25; // r1
  int v26; // r7
  int v27; // r6
  int v28; // r2
  int v29; // r3
  int v30; // r11
  int v31; // r8
  int v32; // r2
  int v33; // ST0C_4
  int v34; // ST08_4
  int v35; // r3
  int v36; // r1
  int v37; // r9
  int v38; // r2
  int v39; // r3
  int v40; // r9
  int v41; // r8
  int v42; // r7
  int v43; // r6
  int v44; // r10
  int v45; // r11
  int v46; // r1
  int v47; // ST08_4
  int v48; // r6
  int v49; // r2
  int v50; // r10
  int v51; // r1
  int v52; // r2
  int v53; // r3
  unsigned int v54; // ST0C_4
  int v55; // r1
  int v56; // r10
  int v57; // r1
  int v58; // r11
  int v59; // r9
  int v60; // r2
  int v61; // r3
  int v62; // r8
  int v63; // r1
  int v64; // r2
  int v65; // r7
  int v66; // r6
  int v67; // r3
  int v68; // r1
  unsigned int v69; // r10
  int v70; // r2
  int v71; // r12
  int v72; // r11
  int v73; // r3
  int v74; // r6
  int v75; // r10
  int v76; // r11
  int v77; // r5
  int v78; // r9
  int v79; // r8
  int v80; // r12
  int v81; // r0
  int v82; // r3
  int v83; // r11
  int v84; // r1
  int v85; // r0
  int v86; // r12
  int v87; // r10
  int v88; // r7
  int v89; // r6
  int v90; // r3
  unsigned int result; // r0
  int v92; // r9
  int v93; // r8
  unsigned int v94; // r12
  int v95; // r8
  unsigned int v96; // r1
  int v97; // r10
  unsigned int v98; // [sp+10h] [bp-128h]
  int v99; // [sp+14h] [bp-124h]
  int v100; // [sp+18h] [bp-120h]
  int v101; // [sp+1Ch] [bp-11Ch]
  int v102; // [sp+20h] [bp-118h]
  int v103; // [sp+24h] [bp-114h]
  int v104; // [sp+28h] [bp-110h]
  int v105; // [sp+2Ch] [bp-10Ch]
  int v106; // [sp+30h] [bp-108h]
  int v107; // [sp+34h] [bp-104h]
  int v108; // [sp+38h] [bp-100h]
  int v109; // [sp+3Ch] [bp-FCh]
  int v110; // [sp+40h] [bp-F8h]
  int v111; // [sp+44h] [bp-F4h]
  int v112; // [sp+48h] [bp-F0h]
  int v113; // [sp+4Ch] [bp-ECh]

  v2 = a1;
  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  MD5Decode((int)&v98, a2, 0x40u);
  v7 = v4 + __ROR4__(v98 - 680876936 + v3 + (v6 & ~v4 | v5 & v4), 25);
  v8 = v7 + __ROR4__(v99 - 389564586 + v6 + (v5 & ~v7 | v7 & v4), 20);
  v9 = v8 + __ROR4__(v100 + 606105819 + v5 + (v4 & ~v8 | v8 & v7), 15);
  v10 = v9 + __ROR4__(v101 - 1044525330 + v4 + (v7 & ~v9 | v9 & v8), 10);
  v11 = v10 + __ROR4__(v102 - 176418897 + v7 + (v8 & ~v10 | v10 & v9), 25);
  v12 = v11 + __ROR4__(v103 + 1200080426 + v8 + (v9 & ~v11 | v11 & v10), 20);
  v13 = v12 + __ROR4__(v104 - 1473231341 + v9 + (v10 & ~v12 | v12 & v11), 15);
  v14 = v13 + __ROR4__(v105 - 45705983 + v10 + (v11 & ~v13 | v13 & v12), 10);
  v15 = v14 + __ROR4__(v106 + 1770035416 + v11 + (v12 & ~v14 | v14 & v13), 25);
  v16 = v15 + __ROR4__(v107 - 1958414417 + v12 + (v13 & ~v15 | v15 & v14), 20);
  v17 = v16 + __ROR4__(v108 - 42063 + v13 + (v14 & ~v16 | v16 & v15), 15);
  v18 = v17 + __ROR4__(v109 - 1990404162 + v14 + (v15 & ~v17 | v17 & v16), 10);
  v19 = v18 + __ROR4__(v110 + 1804603682 + v15 + (v16 & ~v18 | v18 & v17), 25);
  v20 = v19 + __ROR4__(v111 - 40341101 + v16 + (v17 & ~v19 | v19 & v18), 20);
  v21 = v20 + __ROR4__(v112 - 1502002290 + v17 + (~v20 & v18 | v20 & v19), 15);
  v22 = v21 + __ROR4__(v113 + 1236535329 + v18 + (~v21 & v19 | v21 & v20), 10);
  v23 = v22 + __ROR4__(v99 - 165796510 + v19 + (v22 & v20 | v21 & ~v20), 27);
  v24 = v23 + __ROR4__(v104 - 1069501632 + v20 + (v23 & v21 | v22 & ~v21), 23);
  v25 = v24 + __ROR4__(v109 + 643717713 + v21 + (v24 & v22 | v23 & ~v22), 18);
  v26 = v25 + __ROR4__(v98 - 373897302 + v22 + (v25 & v23 | v24 & ~v23), 12);
  v27 = v26 + __ROR4__(v103 - 701558691 + v23 + (v26 & v24 | v25 & ~v24), 27);
  v28 = v27 + __ROR4__(v108 + 38016083 + v24 + (v27 & v25 | v26 & ~v25), 23);
  v29 = v28 + __ROR4__(v113 - 660478335 + v25 + (v28 & v26 | v27 & ~v26), 18);
  v30 = v29 + __ROR4__(v102 - 405537848 + v26 + (v29 & v27 | v28 & ~v27), 12);
  v31 = v112 - 1019803690 + v28;
  v32 = v30 + __ROR4__(v107 + 568446438 + v27 + (v30 & v28 | v29 & ~v28), 27);
  v33 = v101 - 187363961 + v29;
  v34 = v111 - 1444681467 + v32;
  v35 = v32 + __ROR4__(v31 + (v32 & v29 | v30 & ~v29), 23);
  v36 = v35 + __ROR4__(v33 + (v35 & v30 | v32 & ~v30), 18);
  v37 = v100 - 51403784 + v35;
  v38 = v36 + __ROR4__(v106 + 1163531501 + v30 + (v36 & v32 | v35 & ~v32), 12);
  v39 = v38 + __ROR4__(v34 + (v38 & v35 | v36 & ~v35), 27);
  v40 = v39 + __ROR4__(v37 + (v39 & v36 | v38 & ~v36), 23);
  v41 = v40 + __ROR4__(v105 + 1735328473 + v36 + (v40 & v38 | v39 & ~v38), 18);
  v42 = v41 + __ROR4__(v110 - 1926607734 + v38 + (v41 & v39 | v40 & ~v39), 12);
  v43 = v42 + __ROR4__(v103 - 378558 + v39 + (v41 ^ v40 ^ v42), 28);
  v44 = v43 + __ROR4__(v106 - 2022574463 + v40 + (v42 ^ v41 ^ v43), 21);
  v45 = v102 + 1272893353 + v44;
  v46 = v44 + __ROR4__(v109 + 1839030562 + v41 + (v43 ^ v42 ^ v44), 16);
  v47 = v99 - 1530992060 + v43;
  v48 = v46 + __ROR4__(v112 - 35309556 + v42 + (v44 ^ v43 ^ v46), 9);
  v49 = v105 - 155497632 + v46;
  v50 = v48 + __ROR4__(v47 + (v46 ^ v44 ^ v48), 28);
  v51 = v50 + __ROR4__(v45 + (v48 ^ v46 ^ v50), 21);
  v52 = v51 + __ROR4__(v49 + (v50 ^ v48 ^ v51), 16);
  v53 = v52 + __ROR4__(v108 - 1094730640 + v48 + (v51 ^ v50 ^ v52), 9);
  v54 = v98 - 358537222 + v51;
  v55 = v111 + 681279174 + v50 + (v52 ^ v51 ^ v53);
  v56 = v101 - 722521979 + v52;
  v57 = v53 + __ROR4__(v55, 28);
  v58 = v104 + 76029189 + v53;
  v59 = v107 - 640364487 + v57;
  v60 = v57 + __ROR4__(v54 + (v53 ^ v52 ^ v57), 21);
  v61 = v60 + __ROR4__(v56 + (v57 ^ v53 ^ v60), 16);
  v62 = v110 - 421815835 + v60;
  v63 = v61 + __ROR4__(v58 + (v60 ^ v57 ^ v61), 9);
  v64 = v63 + __ROR4__(v59 + (v61 ^ v60 ^ v63), 28);
  v65 = v113 + 530742520 + v61;
  v66 = v100 - 995338651 + v63;
  v67 = v64 + __ROR4__(v62 + (v63 ^ v61 ^ v64), 21);
  v68 = v65 + (v64 ^ v63 ^ v67);
  v69 = v98 - 198630844 + v64;
  v70 = v67 ^ v64;
  v71 = ~v67;
  v72 = v105 + 1126891415 + v67;
  v73 = v67 + __ROR4__(v68, 16);
  v74 = v73 + __ROR4__(v66 + (v70 ^ v73), 9);
  v75 = v74 + __ROR4__(v69 + ((v74 | v71) ^ v73), 26);
  v76 = v75 + __ROR4__(v72 + ((v75 | ~v73) ^ v74), 22);
  v77 = v76 + __ROR4__(v112 - 1416354905 + v73 + ((v76 | ~v74) ^ v75), 17);
  v78 = v77 + __ROR4__(v103 - 57434055 + v74 + ((v77 | ~v75) ^ v76), 11);
  v79 = v78 + __ROR4__(v110 + 1700485571 + v75 + ((v78 | ~v76) ^ v77), 26);
  v80 = v79 + __ROR4__(v101 - 1894986606 + v76 + ((v79 | ~v77) ^ v78), 22);
  v81 = v80 + __ROR4__(v108 - 1051523 + v77 + ((v80 | ~v78) ^ v79), 17);
  v82 = v81 + __ROR4__(v99 - 2054922799 + v78 + ((v81 | ~v79) ^ v80), 11);
  v83 = v82 + __ROR4__(v106 + 1873313359 + v79 + ((v82 | ~v80) ^ v81), 26);
  v84 = v83 + __ROR4__(v113 - 30611744 + v80 + ((v83 | ~v81) ^ v82), 22);
  v85 = v84 + __ROR4__(v104 - 1560198380 + v81 + ((v84 | ~v82) ^ v83), 17);
  v86 = ~v85;
  v87 = v100 + 718787259 + v85;
  v88 = v85 + __ROR4__(v111 + 1309151649 + v82 + ((v85 | ~v83) ^ v84), 11);
  v89 = v107 - 343485551 + v88;
  v90 = (v88 | ~v84) ^ v85;
  result = v2[1];
  v92 = v88 + __ROR4__(v102 - 145523070 + v83 + v90, 26);
  v93 = v109 - 1120210379 + v84 + ((v92 | v86) ^ v88);
  v94 = v2[3];
  *v2 += v92;
  v95 = v92 + __ROR4__(v93, 22);
  v96 = v2[2];
  v2[3] = v94 + v95;
  v97 = v95 + __ROR4__(v87 + ((v95 | ~v88) ^ v92), 17);
  v2[2] = v96 + v97;
  v2[1] = v97 + result + __ROR4__(v89 + ((v97 | ~v92) ^ v95), 11);
  return result;
}

//----- (00039D6C) --------------------------------------------------------
void *__fastcall MD5Update(unsigned int *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // r6
  unsigned int v4; // r2
  char *v5; // r7
  unsigned int *v6; // r3
  unsigned int v7; // r1
  int v8; // r4
  bool v9; // cf
  bool v10; // zf
  unsigned int v11; // r2
  size_t v12; // r5
  int v13; // r0
  int v14; // r2
  unsigned __int8 *v15; // r0
  unsigned int *v17; // r8
  unsigned __int8 *v18; // r9
  unsigned int v19; // r4

  v3 = a3;
  v4 = 8 * a3;
  v5 = a2;
  v6 = a1;
  v7 = v4 + *a1;
  v8 = (*a1 >> 3) & 0x3F;
  v9 = v4 >= v7;
  v10 = v4 == v7;
  v11 = a1[1];
  v12 = 64 - v8;
  *a1 = v7;
  if ( !v10 && v9 )
    ++v11;
  v13 = v8 + 24;
  v14 = v11 + (v3 >> 29);
  if ( v12 > v3 )
    v8 = 0;
  v6[1] = v14;
  if ( v12 > v3 )
  {
    v15 = (unsigned __int8 *)v6 + v13;
    return memcpy(v15, &v5[v8], v3 - v8);
  }
  v17 = v6 + 2;
  v18 = (unsigned __int8 *)(v6 + 6);
  v19 = 128 - v8;
  memcpy((char *)v6 + v13, v5, v12);
  MD5Transform(v17, v18);
  if ( v3 < v19 )
  {
    v15 = v18;
    v8 = v12;
    return memcpy(v15, &v5[v8], v3 - v8);
  }
  while ( 1 )
  {
    MD5Transform(v17, (unsigned __int8 *)&v5[v12]);
    v12 = v19;
    if ( v3 < v19 + 64 )
      break;
    v19 += 64;
  }
  return memcpy(v18, &v5[v19], v3 - v19);
}

//----- (00039E40) --------------------------------------------------------
int __fastcall MD5Final(unsigned int *a1, int a2)
{
  unsigned int *v2; // r4
  int v3; // r7
  unsigned int v4; // r2
  unsigned int v5; // r8
  unsigned __int8 v7; // [sp+4h] [bp-24h]

  v2 = a1;
  v3 = a2;
  v4 = (*a1 >> 3) & 0x3F;
  if ( v4 > 0x37 )
    v5 = 120 - v4;
  else
    v5 = 56 - v4;
  MD5Encode((int)&v7, a1, 8u);
  MD5Update(v2, (char *)PADDING, v5);
  MD5Update(v2, (char *)&v7, 8u);
  return MD5Encode(v3, v2 + 2, 0x10u);
}
// F304C: using guessed type int *PADDING[16];

//----- (00039EE0) --------------------------------------------------------
int __fastcall data_wait(int a1)
{
  int v1; // r4
  char v2; // r6
  struct timeval timeout; // [sp+8h] [bp-98h]
  char s; // [sp+10h] [bp-90h]
  _DWORD v6[1]; // [sp+90h] [bp-10h]

  v1 = a1;
  v2 = a1 & 0x1F;
  memset(&s, 0, 0x80u);
  v6[(v1 >> 5) - 32] = 1 << v2;
  timeout.tv_sec = 1;
  timeout.tv_usec = 0;
  return select(v1 + 1, (fd_set *)&s, 0, 0, &timeout);
}

//----- (00039F50) --------------------------------------------------------
signed int __fastcall recverr(int a1, int a2)
{
  signed int v2; // r11
  ssize_t v3; // r0
  int v4; // r1
  int v5; // r2
  unsigned int v6; // r3
  int v7; // r3
  signed int v8; // r6
  unsigned int v9; // r1
  _DWORD *v10; // r3
  signed int v11; // r12
  int v12; // r4
  int v13; // r2
  unsigned int v14; // r2
  int v15; // r0
  int v16; // r3
  _DWORD *v17; // r3
  signed int result; // r0
  signed int v19; // r12
  int v20; // r2
  char *v21; // r1
  signed int v22; // ST04_4
  const char *v23; // r0
  bool v24; // zf
  signed int v25; // [sp+4h] [bp-32Ch]
  int fd; // [sp+10h] [bp-320h]
  int v27; // [sp+28h] [bp-308h]
  int *v28; // [sp+3Ch] [bp-2F4h]
  int v29; // [sp+40h] [bp-2F0h]
  struct timeval tv; // [sp+44h] [bp-2ECh]
  int s; // [sp+4Ch] [bp-2E4h]
  int v32; // [sp+50h] [bp-2E0h]
  char *v33; // [sp+58h] [bp-2D8h]
  int v34; // [sp+5Ch] [bp-2D4h]
  int *v35; // [sp+60h] [bp-2D0h]
  int v36; // [sp+64h] [bp-2CCh]
  char *v37; // [sp+68h] [bp-2C8h]
  unsigned int v38; // [sp+6Ch] [bp-2C4h]
  int v39; // [sp+70h] [bp-2C0h]
  char v40; // [sp+74h] [bp-2BCh]
  unsigned __int16 v41; // [sp+76h] [bp-2BAh]
  char buf; // [sp+84h] [bp-2ACh]
  char v43; // [sp+104h] [bp-22Ch]

  v27 = a2;
  v2 = -1;
  fd = a1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        memset(&s, -1, 0xCu);
        v38 = 512;
        v29 = 12;
        v28 = &s;
        v33 = &v40;
        v39 = 0;
        v34 = 16;
        v35 = (int *)&v28;
        v36 = 1;
        v37 = &v43;
        gettimeofday(&tv, 0);
        v3 = recvmsg(fd, (struct msghdr *)&v33, 0x2000);
        if ( v3 >= 0 )
          break;
        if ( *(_DWORD *)_errno(v3, v4, v5) == 11 )
          return v2;
      }
      v2 = mtu;
      v6 = (unsigned __int16)__rev16(v41) - (unsigned __int16)base_port;
      if ( v6 <= 0x3E && (v7 = 3 * v6, (v8 = his[v7]) != 0) )
      {
        his[v7] = 0;
        if ( v3 != 12 )
        {
LABEL_8:
          v9 = v38;
          if ( v38 < 0xC )
            return 0;
          goto LABEL_9;
        }
      }
      else
      {
        v8 = -1;
        if ( v3 != 12 )
          goto LABEL_8;
      }
      if ( !s )
        goto LABEL_8;
      v9 = v38;
      if ( v32 )
        v8 = s;
      if ( v38 < 0xC )
        return 0;
LABEL_9:
      v10 = v37;
      if ( !v37 )
        return 0;
      v11 = -1;
      v12 = 0;
      do
      {
        if ( !v10[1] )
        {
          v13 = v10[2];
          if ( v13 == 11 )
          {
            v12 = (int)(v10 + 3);
          }
          else if ( v13 == 2 )
          {
            v11 = v10[3];
          }
        }
        v10 = (_DWORD *)((char *)v10 + ((*v10 + 3) & 0xFFFFFFFC));
        v14 = (char *)(v10 + 3) - v37;
      }
      while ( v9 >= v14 && v10 );
      if ( !v12 )
        return 0;
      v15 = (unsigned __int8)byte_4[v12];
      if ( v15 == 2 )
      {
        v25 = v11;
        inet_ntop(2, (const void *)(v12 + 20), &buf, 0x80u);
        v19 = v25;
        if ( no_resolve )
        {
          v20 = show_both;
          if ( !show_both )
          {
            v21 = &buf;
LABEL_50:
            v22 = v19;
            v15 = print_host(&buf, v21, v20);
            v11 = v22;
            goto LABEL_19;
          }
        }
        fflush((FILE *)((char *)&_sF + 84));
        v23 = (const char *)gethostbyaddr((const void *)(v12 + 20), 4u, 2);
        v19 = v25;
        if ( no_resolve )
        {
          if ( v23 )
            v21 = *(char **)v23;
          else
            v21 = &buf;
          v20 = show_both;
          goto LABEL_50;
        }
        v24 = v23 == 0;
        if ( !v23 )
          v23 = &buf;
        if ( !v24 )
          v23 = *(const char **)v23;
        v15 = print_host(v23, &buf, show_both);
        v11 = v25;
      }
LABEL_19:
      v16 = *(_DWORD *)v12;
      if ( *(_DWORD *)v12 == 101 )
        return 0;
      if ( *(_DWORD *)v12 > 0x65u )
        break;
      if ( v16 == 71 )
        return 0;
      if ( v16 != 90 )
      {
        if ( v16 != 13 )
        {
LABEL_24:
          v17 = (_DWORD *)_errno(v15, v9, v14);
          result = 0;
          *v17 = *(_DWORD *)v12;
          return result;
        }
        return 0;
      }
      v2 = *(_DWORD *)&byte_8[v12];
      mtu = *(_DWORD *)&byte_8[v12];
    }
    if ( v16 == 111 )
      break;
    if ( v16 == 113 )
    {
      if ( (*(_DWORD *)&byte_4[v12] & 0xFFFFFF) != 2818 )
        return 0;
    }
    else
    {
      if ( v16 != 110 )
        goto LABEL_24;
      putchar(10);
    }
  }
  result = 0;
  if ( v8 < 0 )
    v8 = v27;
  hops_to = v8;
  hops_from = v11;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F308C: using guessed type int hops_from;
// F3090: using guessed type int hops_to;
// F3094: using guessed type int mtu;
// F3DC0: using guessed type int show_both;
// F3DC4: using guessed type int no_resolve;
// F3DC8: using guessed type __int16 base_port;

//----- (0003A348) --------------------------------------------------------
signed int __fastcall probe_ttl(int a1, int a2)
{
  int v2; // r4
  int v3; // r8
  int v4; // r3
  int v5; // r0
  int v6; // r1
  size_t v7; // r2
  _DWORD *v8; // r12
  signed int v9; // r0
  char v10; // r2
  signed int result; // r0
  char s; // [sp+8h] [bp-1003Ch]
  char v13; // [sp+Ch] [bp-10038h]
  size_t n; // [sp+1000Ch] [bp-38h]
  __int16 *v15; // [sp+10010h] [bp-34h]
  struct timeval *tv; // [sp+10014h] [bp-30h]
  int v17; // [sp+10018h] [bp-2Ch]
  char *v18; // [sp+1001Ch] [bp-28h]

  v2 = a2;
  v17 = 0;
  v3 = a1;
  n = mtu;
  tv = (struct timeval *)&v13;
  v18 = &v13;
  memset(&s, 0, mtu);
  v15 = &base_port;
  v4 = hisptr;
  while ( 1 )
  {
    *(_DWORD *)&s = v2;
    word_F3DCE = __rev16((unsigned __int16)*v15 + v4);
    gettimeofday(tv, 0);
    v5 = *(_DWORD *)v18;
    v6 = *((_DWORD *)v18 + 1);
    v7 = mtu - 28;
    v8 = &his[3 * hisptr];
    his[3 * hisptr] = v2;
    v8[1] = v5;
    v8[2] = v6;
    if ( sendto(v3, &s, v7, 0, (const struct sockaddr *)&target, 0x10u) > 0 )
      break;
    v9 = recverr(v3, v2);
    v10 = hisptr;
    v4 = hisptr;
    his[3 * hisptr] = 0;
    if ( !v9 )
      return 0;
    if ( v9 <= 0 )
    {
      if ( ++v17 > 9 )
      {
        result = 0;
        hisptr = (v10 + 1) & 0x3F;
        return result;
      }
    }
    else
    {
      v17 = 0;
    }
  }
  hisptr = ((_BYTE)hisptr + 1) & 0x3F;
  data_wait(v3);
  if ( recv(v3, &s, n, 64) > 0 )
    return 0;
  return recverr(v3, v2);
}
// 0: using guessed type int dword_0;
// F3094: using guessed type int mtu;
// F3DC8: using guessed type __int16 base_port;
// F3DCC: using guessed type __int16 target;
// F3DCE: using guessed type __int16 word_F3DCE;
// F3DDC: using guessed type int hisptr;

//----- (0003A500) --------------------------------------------------------
signed int __fastcall get_mtu(char *a1)
{
  char *v1; // r4
  int v2; // r6
  struct hostent *v3; // r0
  int v4; // r0
  int v5; // r5
  signed int v6; // r4
  int v7; // r11
  signed int v8; // r0
  bool v9; // zf
  int v11; // [sp+Ch] [bp-2Ch]

  v1 = a1;
  no_resolve = 1;
  v2 = socket(2, 2, 0);
  if ( v2 < 0 )
    return -1;
  target = 2;
  base_port = -21092;
  v3 = gethostbyname(v1);
  if ( !v3
    || (v4 = **(_DWORD **)v3->h_addr_list, v11 = 3, dword_F3DD0 = v4, setsockopt(v2, 0, 10, &v11, 4u))
    && (v11 = 2, setsockopt(v2, 0, 10, &v11, 4u))
    || (v5 = 1, v11 = 1, setsockopt(v2, 0, 11, &v11, 4u))
    || setsockopt(v2, 0, 12, &v11, 4u) )
  {
LABEL_19:
    close(v2);
    return -1;
  }
LABEL_6:
  v11 = v5;
  if ( setsockopt(v2, 0, 2, &v11, 4u) )
    goto LABEL_19;
  v6 = 0;
  v7 = mtu;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = probe_ttl(v2, v5);
      v9 = mtu == v7;
      v7 = mtu;
      if ( v9 )
        break;
      v6 = 0;
    }
    ++v6;
    if ( !v8 )
      break;
    if ( v8 > 0 || v6 > 2 )
    {
      if ( ++v5 != 32 )
        goto LABEL_6;
      break;
    }
  }
  if ( hops_to < 0 || hops_from < 0 )
    return mtu;
  close(v2);
  return mtu;
}
// F308C: using guessed type int hops_from;
// F3090: using guessed type int hops_to;
// F3094: using guessed type int mtu;
// F3DC4: using guessed type int no_resolve;
// F3DC8: using guessed type __int16 base_port;
// F3DCC: using guessed type __int16 target;
// F3DD0: using guessed type int dword_F3DD0;

//----- (0003A70C) --------------------------------------------------------
int __fastcall confErrCb(void *a1)
{
  return 0;
}

//----- (0003A714) --------------------------------------------------------
int __fastcall notifyM3u8Tracker(int result, int *a2)
{
  if ( a2 )
    result = P2PClient::addPeers(gTSP2PClient, result, a2);
  return result;
}
// F40F0: using guessed type int gTSP2PClient;

//----- (0003A734) --------------------------------------------------------
int __fastcall notifyM3u8OneFile(int result)
{
  OneFile *v1; // r5
  int v2; // r0
  TsPieceDownload *v3; // r4
  int v4; // r1
  int v5; // r0

  v1 = (OneFile *)result;
  if ( result && gTSLocalMemory )
  {
    result = OneFile::isFinished((OneFile *)result);
    if ( result )
    {
      if ( !gTSLocalMemory )
        return result;
      goto LABEL_5;
    }
    v5 = OneFile::getTotalSize(v1);
    addP2pDownloadAvailableBytes(v5);
    LocalMemory::addIncompletePendingFile((LocalMemory *)gTSLocalMemory, v1);
    result = LocalMemory::clearIncompletePendingFile((LocalMemory *)gTSLocalMemory);
    if ( gTSLocalMemory )
    {
LABEL_5:
      v2 = OneFile::getTotalSize(v1);
      addP2pDownloadAvailableBytes(v2);
      LocalMemory::addPendingFile(gTSLocalMemory, v1);
      v3 = *(TsPieceDownload **)(gM3U8Manager + 180);
      v4 = OneFile::getFileId(v1);
      return TsPieceDownload::eraseDownloadMission(v3, v4);
    }
  }
  return result;
}
// F40EC: using guessed type int gTSLocalMemory;
// F40F4: using guessed type int gM3U8Manager;

//----- (0003A7E4) --------------------------------------------------------
unsigned int __fastcall confWriteCb(char *src, unsigned int a2, unsigned int a3, void *a4)
{
  double *v4; // r4
  unsigned int v5; // r5
  unsigned int result; // r0

  v4 = (double *)((char *)a4 + 2320);
  v5 = a3 * a2;
  memcpy((void *)(*((_DWORD *)a4 + 2) + (signed int)*((double *)a4 + 290)), src, a3 * a2);
  result = v5;
  *v4 = *v4 + (double)v5;
  return result;
}

//----- (0003A82C) --------------------------------------------------------
void __fastcall sub_3A82C(int *a1, int *a2)
{
  int *v2; // r10
  int v3; // r1
  unsigned int v4; // r3
  int *v5; // r11
  int *v6; // r9
  int v7; // r5
  int v8; // t1
  int v9; // r8
  int v10; // r7
  int v11; // r4
  int v12; // r1
  void *v13; // r3
  int v14; // r5
  int v15; // r7
  int v16; // r4
  int v17; // r3
  void *v18; // r0
  int v19; // r7
  int v20; // r4
  int v21; // r3
  void *v22; // r0
  int v23; // r7
  int v24; // r4
  int v25; // r3
  void *v26; // r0
  unsigned int *v27; // r1
  signed int v28; // r0
  unsigned int *v29; // r3
  signed int v30; // r2
  unsigned int *v31; // r3
  signed int v32; // r2
  unsigned int *v33; // r3
  signed int v34; // r1

  v2 = a2;
  v3 = a1[3];
  v4 = v2[3];
  v5 = a1;
  v6 = (int *)(v3 + 4);
  if ( v3 + 4 < v4 )
  {
    do
    {
      v8 = *v6;
      ++v6;
      v7 = v8;
      v9 = v8 + 500;
      v10 = v8 + 12;
      v11 = v8;
      do
      {
        v12 = *(_DWORD *)(v10 + v11 - v7);
        v13 = (void *)(v12 - 12);
        if ( (int *)(v12 - 12) != &dword_2FEF3C )
        {
          v27 = (unsigned int *)(v12 - 4);
          __dmb(0xFu);
          do
            v28 = __ldrex(v27);
          while ( __strex(v28 - 1, v27) );
          __dmb(0xFu);
          if ( v28 <= 0 )
            operator delete(v13);
        }
        v11 += 20;
      }
      while ( v9 != v11 );
      v4 = v2[3];
    }
    while ( v4 > (unsigned int)v6 );
    v3 = v5[3];
  }
  v14 = *v5;
  if ( v3 == v4 )
  {
    v23 = *v2;
    if ( v14 != *v2 )
    {
      v24 = *v5;
      do
      {
        v25 = *(_DWORD *)(v24 + 12);
        v26 = (void *)(v25 - 12);
        if ( (int *)(v25 - 12) != &dword_2FEF3C )
        {
          v29 = (unsigned int *)(v25 - 4);
          __dmb(0xFu);
          do
            v30 = __ldrex(v29);
          while ( __strex(v30 - 1, v29) );
          __dmb(0xFu);
          if ( v30 <= 0 )
            operator delete(v26);
        }
        v24 += 20;
      }
      while ( v23 != v24 );
    }
  }
  else
  {
    v15 = v5[2];
    if ( v14 != v15 )
    {
      v16 = *v5;
      do
      {
        v17 = *(_DWORD *)(v16 + 12);
        v18 = (void *)(v17 - 12);
        if ( (int *)(v17 - 12) != &dword_2FEF3C )
        {
          v33 = (unsigned int *)(v17 - 4);
          __dmb(0xFu);
          do
            v34 = __ldrex(v33);
          while ( __strex(v34 - 1, v33) );
          __dmb(0xFu);
          if ( v34 <= 0 )
            operator delete(v18);
        }
        v16 += 20;
      }
      while ( v15 != v16 );
    }
    v19 = *v2;
    if ( v2[1] != *v2 )
    {
      v20 = v2[1];
      do
      {
        v21 = *(_DWORD *)(v20 + 12);
        v22 = (void *)(v21 - 12);
        if ( (int *)(v21 - 12) != &dword_2FEF3C )
        {
          v31 = (unsigned int *)(v21 - 4);
          __dmb(0xFu);
          do
            v32 = __ldrex(v31);
          while ( __strex(v32 - 1, v31) );
          __dmb(0xFu);
          if ( v32 <= 0 )
            operator delete(v22);
        }
        v20 += 20;
      }
      while ( v19 != v20 );
    }
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0003AA78) --------------------------------------------------------
void __fastcall M3U8Manager::checkData(M3U8Manager *this, unsigned int a2)
{
  int v2; // r3
  M3U8Manager *v3; // r4

  v2 = *((_DWORD *)this + 35);
  v3 = this;
  if ( v2 == a2 )
  {
    ++*((_DWORD *)this + 40);
    sendEventToPlayer(2);
    add_play_fd();
    if ( *((_DWORD *)v3 + 40) == 2 )
    {
LABEL_4:
      add_play_fsd();
      return;
    }
  }
  else if ( v2 + 1 == a2 )
  {
    ++*((_DWORD *)this + 40);
    sendEventToPlayer(3);
    add_play_sd();
    if ( *((_DWORD *)v3 + 40) == 2 )
      goto LABEL_4;
  }
}

//----- (0003AAEC) --------------------------------------------------------
int __fastcall notifyM3u8HttpFileFinished(int a1, int a2)
{
  int v2; // r6
  unsigned int *v3; // r4
  int v4; // r3

  v2 = a2;
  v3 = (unsigned int *)a1;
  if ( a2 == 2 )
  {
    addCdnDownloadBytes(*(_DWORD *)(a1 + 8));
  }
  else if ( a2 == 3 )
  {
    addTdnDownloadBytes(*(_DWORD *)(a1 + 8));
  }
  M3U8Manager::checkData((M3U8Manager *)gM3U8Manager, *v3);
  v4 = gM3U8Manager;
  if ( !*(_DWORD *)(gM3U8Manager + 4) )
  {
    while ( LocalMemory::addPendingData(gTSLocalMemory, v3, v2) < 0 )
    {
      usleep(0x2710u);
      v4 = gM3U8Manager;
      if ( *(_DWORD *)(gM3U8Manager + 4) )
        goto LABEL_5;
    }
    v4 = gM3U8Manager;
  }
LABEL_5:
  TsPieceDownload::eraseDownloadMission(*(TsPieceDownload **)(v4 + 180), *v3);
  return P2PClient::eraseMission(*(P2PClient **)(gM3U8Manager + 132), *v3);
}
// F40EC: using guessed type int gTSLocalMemory;
// F40F4: using guessed type int gM3U8Manager;

//----- (0003ABAC) --------------------------------------------------------
int __fastcall M3U8Manager::getNewestPieceId(M3U8Manager *this)
{
  return *((_DWORD *)this + 36);
}

//----- (0003ABB4) --------------------------------------------------------
int getWindowEndPieceId(void)
{
  return M3U8Manager::getNewestPieceId((M3U8Manager *)gM3U8Manager) - 1;
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003ABD4) --------------------------------------------------------
signed int __fastcall M3U8Manager::downloadP2PFailedPiece(M3U8Manager *this, unsigned int a2)
{
  return TsPieceDownload::downloadPieceDataWithPieceid(*((TsPieceDownload **)this + 45), a2);
}

//----- (0003ABDC) --------------------------------------------------------
signed int __fastcall notifyM3u8ToHttpDownload(unsigned int a1)
{
  return M3U8Manager::downloadP2PFailedPiece((M3U8Manager *)gM3U8Manager, a1);
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003ABF4) --------------------------------------------------------
int __fastcall M3U8Manager::setStartPieceId(int result, unsigned int a2)
{
  *(_DWORD *)(result + 140) = a2;
  return result;
}

//----- (0003ABFC) --------------------------------------------------------
int __fastcall M3U8Manager::createFifoProcess(M3U8Manager *this)
{
  return FifoDataManager::start(*((void **)this + 39), *(_DWORD *)this, (int)cbM3u8FifoCopy, *((_DWORD *)this + 35), 2);
}

//----- (0003AC34) --------------------------------------------------------
signed int __fastcall M3U8Manager::writeLocalAndNatAddr(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  char *v2; // r0
  int v3; // r5
  size_t v4; // r8
  size_t v5; // r6
  double v6; // r4
  const char *v7; // r1
  int v9; // [sp+1Ch] [bp-D4h]
  int v10; // [sp+20h] [bp-D0h]
  char s; // [sp+24h] [bp-CCh]
  char v12; // [sp+2Ch] [bp-C4h]
  char v13; // [sp+38h] [bp-B8h]
  char v14; // [sp+68h] [bp-88h]
  char v15; // [sp+A1h] [bp-4Fh]

  v1 = this;
  v2 = inet_ntoa(*(struct in_addr *)(*((_DWORD *)this + 10) + 4));
  strcpy(&v13, v2);
  sprintf(&s, "%d", (unsigned __int16)__rev16(*(unsigned __int16 *)(*((_DWORD *)v1 + 10) + 2)));
  v3 = (int)v1 + 266;
  sprintf((char *)v1 + 266, "%s:%s:%s:%s", &v13, &s, (char *)v1 + 220, &s);
  v4 = strlen(&v13);
  v5 = strlen(&s);
  v9 = 1;
  *((_BYTE *)v1 + 2 * v5 + v4 + strlen((const char *)v1 + 220) + 269) = 0;
  LODWORD(v6) = 0;
  strcpy(&v14, "http://mobile.kukuplay.com/core/a/addrInfo.php?addrInfo=");
  memset(&v15, 0, 0x2Bu);
  v7 = (const char *)v3;
  HIDWORD(v6) = 1076887552;
  strcat(&v14, v7);
  v10 = 10;
  return doRequest(&v9, &v14, &v12, &v10, v6, 0, 0, 0);
}

//----- (0003ADAC) --------------------------------------------------------
int __fastcall M3U8Manager::clientStart(M3U8Manager *this)
{
  return pthread_create((pthread_t *)this + 47, 0, (void *(*)(void *))ThreadProcess, (void *)this);
}

//----- (0003ADC8) --------------------------------------------------------
void __fastcall M3U8Manager::insertTsItem(_DWORD *a1, int a2, int a3, int a4, int src, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  bool v67; // zf
  int *v68; // r5
  int v69; // lr
  int v70; // r12
  int v71; // r1
  signed __int64 v72; // [sp+0h] [bp-4F0h]
  int v73; // [sp+8h] [bp-4E8h]
  int v74; // [sp+Ch] [bp-4E4h]
  int v75; // [sp+10h] [bp-4E0h]
  int v76; // [sp+14h] [bp-4DCh]
  int v77; // [sp+18h] [bp-4D8h]
  int v78; // [sp+1Ch] [bp-4D4h]
  int v79; // [sp+20h] [bp-4D0h]
  int v80; // [sp+24h] [bp-4CCh]
  int v81; // [sp+28h] [bp-4C8h]
  int v82; // [sp+2Ch] [bp-4C4h]
  int v83; // [sp+30h] [bp-4C0h]
  int v84; // [sp+34h] [bp-4BCh]
  int v85; // [sp+38h] [bp-4B8h]
  int v86; // [sp+3Ch] [bp-4B4h]
  int v87; // [sp+40h] [bp-4B0h]
  int v88; // [sp+44h] [bp-4ACh]
  int v89; // [sp+48h] [bp-4A8h]
  int v90; // [sp+4Ch] [bp-4A4h]
  int v91; // [sp+50h] [bp-4A0h]
  int v92; // [sp+54h] [bp-49Ch]
  int v93; // [sp+58h] [bp-498h]
  int v94; // [sp+5Ch] [bp-494h]
  int v95; // [sp+60h] [bp-490h]
  int v96; // [sp+64h] [bp-48Ch]
  int v97; // [sp+68h] [bp-488h]
  int v98; // [sp+6Ch] [bp-484h]
  int v99; // [sp+70h] [bp-480h]
  int v100; // [sp+74h] [bp-47Ch]
  int v101; // [sp+78h] [bp-478h]
  int v102; // [sp+7Ch] [bp-474h]
  int v103; // [sp+80h] [bp-470h]
  int v104; // [sp+84h] [bp-46Ch]
  int v105; // [sp+88h] [bp-468h]
  int v106; // [sp+8Ch] [bp-464h]
  int v107; // [sp+90h] [bp-460h]
  int v108; // [sp+94h] [bp-45Ch]
  int v109; // [sp+98h] [bp-458h]
  int v110; // [sp+9Ch] [bp-454h]
  int v111; // [sp+A0h] [bp-450h]
  int v112; // [sp+A4h] [bp-44Ch]
  int v113; // [sp+A8h] [bp-448h]
  int v114; // [sp+ACh] [bp-444h]
  int v115; // [sp+B0h] [bp-440h]
  int v116; // [sp+B4h] [bp-43Ch]
  int v117; // [sp+B8h] [bp-438h]
  int v118; // [sp+BCh] [bp-434h]
  int v119; // [sp+C0h] [bp-430h]
  int v120; // [sp+C4h] [bp-42Ch]
  int v121; // [sp+C8h] [bp-428h]
  int v122; // [sp+CCh] [bp-424h]
  int v123; // [sp+D0h] [bp-420h]
  int v124; // [sp+D4h] [bp-41Ch]
  int v125; // [sp+D8h] [bp-418h]
  int v126; // [sp+DCh] [bp-414h]
  int v127; // [sp+E0h] [bp-410h]
  int v128; // [sp+E4h] [bp-40Ch]
  int v129; // [sp+E8h] [bp-408h]
  int v130; // [sp+ECh] [bp-404h]
  int v131; // [sp+4D0h] [bp-20h]
  int v132; // [sp+4D4h] [bp-1Ch]
  int v133; // [sp+4E8h] [bp-8h]
  int v134; // [sp+4ECh] [bp-4h]

  v67 = a1[35] == 0;
  v68 = (int *)a1[45];
  v133 = a3;
  v134 = a4;
  if ( v67 )
  {
    a4 = a1[43];
    a3 = src;
  }
  v69 = a66;
  if ( v67 )
    a4 = *(_DWORD *)(a4 + 44);
  v70 = a67;
  if ( v67 )
  {
    a3 *= a4;
    a1[37] = a4;
    *v68 = a4;
    a1[35] = a3;
  }
  if ( v67 )
    v68[6] = a3;
  v131 = v69;
  v132 = v70;
  memcpy(&v72, &src, 0x4D0u);
  TsPieceDownload::insertTsItem(
    (int)v68,
    v71,
    v133,
    v134,
    v72,
    v73,
    v74,
    v75,
    v76,
    v77,
    v78,
    v79,
    v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    v86,
    v87,
    v88,
    v89,
    v90,
    v91,
    v92,
    v93,
    v94,
    v95,
    v96,
    v97,
    v98,
    v99,
    v100,
    v101,
    v102,
    v103,
    v104,
    v105,
    v106,
    v107,
    v108,
    v109,
    v110,
    v111,
    v112,
    v113,
    v114,
    v115,
    v116,
    v117,
    v118,
    v119,
    v120,
    v121,
    v122,
    v123,
    v124,
    v125,
    v126,
    v127,
    v128,
    v129,
    v130);
}
// 3ADC8: too many input arguments, some ignored

//----- (0003AE54) --------------------------------------------------------
void __fastcall cbInsertTsItem(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  int v66; // r1
  int v67; // [sp+0h] [bp-4F8h]
  int v68; // [sp+4h] [bp-4F4h]
  int v69; // [sp+8h] [bp-4F0h]
  int v70; // [sp+Ch] [bp-4ECh]
  int v71; // [sp+10h] [bp-4E8h]
  int v72; // [sp+14h] [bp-4E4h]
  int v73; // [sp+18h] [bp-4E0h]
  int v74; // [sp+1Ch] [bp-4DCh]
  int v75; // [sp+20h] [bp-4D8h]
  int v76; // [sp+24h] [bp-4D4h]
  int v77; // [sp+28h] [bp-4D0h]
  int v78; // [sp+2Ch] [bp-4CCh]
  int v79; // [sp+30h] [bp-4C8h]
  int v80; // [sp+34h] [bp-4C4h]
  int v81; // [sp+38h] [bp-4C0h]
  int v82; // [sp+3Ch] [bp-4BCh]
  int v83; // [sp+40h] [bp-4B8h]
  int v84; // [sp+44h] [bp-4B4h]
  int v85; // [sp+48h] [bp-4B0h]
  int v86; // [sp+4Ch] [bp-4ACh]
  int v87; // [sp+50h] [bp-4A8h]
  int v88; // [sp+54h] [bp-4A4h]
  int v89; // [sp+58h] [bp-4A0h]
  int v90; // [sp+5Ch] [bp-49Ch]
  int v91; // [sp+60h] [bp-498h]
  int v92; // [sp+64h] [bp-494h]
  int v93; // [sp+68h] [bp-490h]
  int v94; // [sp+6Ch] [bp-48Ch]
  int v95; // [sp+70h] [bp-488h]
  int v96; // [sp+74h] [bp-484h]
  int v97; // [sp+78h] [bp-480h]
  int v98; // [sp+7Ch] [bp-47Ch]
  int v99; // [sp+80h] [bp-478h]
  int v100; // [sp+84h] [bp-474h]
  int v101; // [sp+88h] [bp-470h]
  int v102; // [sp+8Ch] [bp-46Ch]
  int v103; // [sp+90h] [bp-468h]
  int v104; // [sp+94h] [bp-464h]
  int v105; // [sp+98h] [bp-460h]
  int v106; // [sp+9Ch] [bp-45Ch]
  int v107; // [sp+A0h] [bp-458h]
  int v108; // [sp+A4h] [bp-454h]
  int v109; // [sp+A8h] [bp-450h]
  int v110; // [sp+ACh] [bp-44Ch]
  int v111; // [sp+B0h] [bp-448h]
  int v112; // [sp+B4h] [bp-444h]
  int v113; // [sp+B8h] [bp-440h]
  int v114; // [sp+BCh] [bp-43Ch]
  int v115; // [sp+C0h] [bp-438h]
  int v116; // [sp+C4h] [bp-434h]
  int v117; // [sp+C8h] [bp-430h]
  int v118; // [sp+CCh] [bp-42Ch]
  int v119; // [sp+D0h] [bp-428h]
  int v120; // [sp+D4h] [bp-424h]
  int v121; // [sp+D8h] [bp-420h]
  int v122; // [sp+DCh] [bp-41Ch]
  int v123; // [sp+E0h] [bp-418h]
  int v124; // [sp+E4h] [bp-414h]
  int v125; // [sp+E8h] [bp-410h]
  int v126; // [sp+4D0h] [bp-28h]
  int v127; // [sp+4D4h] [bp-24h]
  int v128; // [sp+4E8h] [bp-10h]
  int v129; // [sp+4ECh] [bp-Ch]
  int src; // [sp+4F0h] [bp-8h]
  int v131; // [sp+4F4h] [bp-4h]

  v128 = a1;
  v129 = a2;
  src = a3;
  v131 = a4;
  v127 = a66;
  v126 = a65;
  memcpy(&v67, &src, 0x4D0u);
  M3U8Manager::insertTsItem(
    (_DWORD *)gM3U8Manager,
    v66,
    v128,
    v129,
    v67,
    v68,
    v69,
    v70,
    v71,
    v72,
    v73,
    v74,
    v75,
    v76,
    v77,
    v78,
    v79,
    v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    v86,
    v87,
    v88,
    v89,
    v90,
    v91,
    v92,
    v93,
    v94,
    v95,
    v96,
    v97,
    v98,
    v99,
    v100,
    v101,
    v102,
    v103,
    v104,
    v105,
    v106,
    v107,
    v108,
    v109,
    v110,
    v111,
    v112,
    v113,
    v114,
    v115,
    v116,
    v117,
    v118,
    v119,
    v120,
    v121,
    v122,
    v123,
    v124,
    v125);
}
// 3AE54: too many input arguments, some ignored
// F40F4: using guessed type int gM3U8Manager;

//----- (0003AEC0) --------------------------------------------------------
int __fastcall M3U8Manager::startP2P(M3U8Manager *this)
{
  return pthread_create((pthread_t *)this + 12, 0, (void *(*)(void *))startP2PRoutine, (void *)gM3U8Manager);
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003AEE8) --------------------------------------------------------
int __fastcall M3U8Manager::loadConf(M3U8Manager *this, const char *a2, char *a3)
{
  M3U8Manager *v3; // r5
  char *v4; // r8
  const char *v5; // r9
  _DWORD *v6; // r8
  _DWORD *v7; // r0
  char s; // [sp+Ch] [bp-424h]

  v3 = this;
  v4 = a3;
  v5 = a2;
  memset(&s, 0, 0x400u);
  sprintf(&s, "%s?key=-net-nativelive-%s", v5, v4);
  v6 = operator new(0x988u);
  memset(v6, 0, 0x988u);
  *((_DWORD *)v3 + 54) = v6;
  v7 = malloc(0x7A120u);
  v6[2] = v7;
  *v7 = 0;
  add_conf();
  return CurlWrapper::new_session(
           *((int **)v3 + 42),
           &s,
           *((_DWORD *)v3 + 54),
           (int)confWriteCb,
           (int)confLoadedCb,
           (int)confErrCb);
}

//----- (0003AFE4) --------------------------------------------------------
int __fastcall M3U8Manager::checkCDNMargin(int result)
{
  int v1; // r4
  signed int v2; // r1

  v1 = result;
  if ( !*(_DWORD *)(result + 4) )
  {
    v2 = (signed int)FifoDataManager::getWriteDataTime((FifoDataManager *)*(_DWORD *)(result + 156));
    if ( v2 > 0 )
      P2PClient::checkCDNMargin(*(_DWORD *)(v1 + 132), v2 + dword_F3098);
    result = (*(int (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v1 + 176) + 8))(
               *(_DWORD *)(v1 + 176),
               *(_DWORD *)(**(_DWORD **)(v1 + 176) + 8));
  }
  return result;
}
// F3098: using guessed type int dword_F3098;

//----- (0003B078) --------------------------------------------------------
pthread_t *__fastcall M3U8Manager::requestPeers(M3U8Manager *this)
{
  return TrackerClient::requestPeer(*((pthread_t **)this + 16), (pthread_t)notifyM3u8Tracker);
}

//----- (0003B08C) --------------------------------------------------------
pthread_t *notifyM3u8RequestPeer(void)
{
  return M3U8Manager::requestPeers((M3U8Manager *)gM3U8Manager);
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003B0A0) --------------------------------------------------------
int __fastcall M3U8Manager::refreshBitmap(M3U8Manager *this, int a2)
{
  pthread_mutex_t *v2; // r4
  M3U8Manager *v3; // r5
  int v4; // r6

  v2 = (pthread_mutex_t *)((char *)this + 112);
  v3 = this;
  v4 = a2;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
  *(_BYTE *)(*((_DWORD *)v3 + 27) + v4) = 1;
  return pthread_mutex_unlock(v2);
}

//----- (0003B0D0) --------------------------------------------------------
int __fastcall notifyM3u8RefreshBitmap(int a1)
{
  return M3U8Manager::refreshBitmap((M3U8Manager *)gM3U8Manager, a1);
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003B0E8) --------------------------------------------------------
__int64 __fastcall M3U8Manager::invertedInvalidTsPieceId(M3U8Manager *this, int a2, __int64 a3, int a4)
{
  M3U8Manager *v4; // r9
  LocalMemory *v5; // r0
  __int64 v6; // r4
  int v7; // r11

  v4 = this;
  v5 = (LocalMemory *)*((_DWORD *)this + 34);
  if ( !v5 )
    return 0LL;
  v6 = (a3 + 1) * a4 - 1;
  if ( a4 <= 0 )
    return v6 - a4;
  v7 = 0;
  while ( LocalMemory::readMemoryPieceLength(v5, v6 - v7) >= 0 )
  {
    if ( ++v7 == a4 )
      return v6 - a4;
    v5 = (LocalMemory *)*((_DWORD *)v4 + 34);
  }
  return v6 - v7;
}

//----- (0003B188) --------------------------------------------------------
bool __fastcall M3U8Manager::fifoCopy(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // r9
  LocalMemory *v4; // r10
  int v5; // r3
  int v6; // r2
  int v7; // r8
  _DWORD **v8; // r5
  int v9; // r4
  int v10; // r12
  int v11; // r2
  _DWORD **v12; // r6
  unsigned int v13; // r7
  signed int v14; // r0

  v3 = a3;
  v4 = (LocalMemory *)a1[34];
  if ( !v4 )
    return 0;
  v5 = a1[22];
  v6 = a1[19];
  v7 = ((a1[23] - a1[24]) >> 2) + ((((a1[26] - v5) >> 2) - 1) << 7) + ((a1[21] - v6) >> 2);
  if ( v7 <= 0 )
  {
    v9 = 0;
  }
  else
  {
    v8 = (_DWORD **)a1[19];
    v9 = 0;
    v10 = (v6 - a1[20]) >> 2;
    v11 = ~v10;
    while ( 1 )
    {
      v12 = v8;
      if ( (unsigned int)v10 > 0x7F )
      {
        v13 = v10 >> 7;
        if ( v10 <= 0 )
          v13 = ~((unsigned int)(v11 - v9) >> 7);
        v12 = (_DWORD **)(*(_DWORD *)(v5 + 4 * v13) + 4 * (v10 - (v13 << 7)));
      }
      ++v10;
      ++v8;
      if ( **v12 == a2 )
        break;
      if ( ++v9 == v7 )
        return 0;
    }
  }
  if ( v9 == v7 )
    return 0;
  *(_DWORD *)(v3 + 4) = 0;
  v14 = LocalMemory::readMemory(v4, (unsigned __int8 **)(v3 + 12), a2, (unsigned int *)v3);
  *(_DWORD *)(v3 + 8) = v14;
  return v14 >= 0;
}

//----- (0003B288) --------------------------------------------------------
bool __fastcall cbM3u8FifoCopy(unsigned int a1, int a2)
{
  return M3U8Manager::fifoCopy((_DWORD *)gM3U8Manager, a1, a2);
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003B2A4) --------------------------------------------------------
void *__fastcall M3U8Manager::getPeer(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  _DWORD *v2; // r0
  _DWORD *v3; // r3
  _DWORD *v4; // r0
  _DWORD *v5; // r3
  StunClient *v6; // r5
  _DWORD *v7; // r5
  signed int v8; // r10
  char *v9; // r3
  signed int v10; // r5
  _WORD *v11; // r2
  int v12; // r11
  in_addr_t v13; // r0
  int v14; // r3
  struct in_addr *v15; // r3
  char *v16; // r0
  char *v17; // r3
  int v18; // r2
  char *v19; // r1
  int v20; // r12
  int v21; // t1
  int v22; // r3
  char *v23; // r1
  int v24; // r2
  void *v25; // r0
  void *v26; // r0
  void *v27; // r0
  void *v28; // r0
  void *v29; // r0
  void *v30; // r0
  const char *v32; // r0
  char *v33; // r0
  void *v34; // [sp+14h] [bp-94h]
  char v35; // [sp+18h] [bp-90h]
  char v36; // [sp+80h] [bp-28h]

  v1 = this;
  v34 = &_stack_chk_guard;
  v2 = malloc(0x10u);
  *((_DWORD *)v1 + 9) = v2;
  *v2 = 0;
  v3 = v2 + 2;
  v2[1] = 0;
  *v3 = 0;
  v3[1] = 0;
  v4 = malloc(0x10u);
  *((_DWORD *)v1 + 10) = v4;
  *v4 = 0;
  v5 = v4 + 2;
  v4[1] = 0;
  *v5 = 0;
  v5[1] = 0;
  v6 = (StunClient *)operator new(0x178u);
  StunClient::StunClient(v6);
  *((_DWORD *)v1 + 13) = v6;
  v7 = operator new(0x60u);
  TrackerClient::TrackerClient(v7, *((_DWORD *)v1 + 44));
  v8 = 0;
  v9 = (char *)*((_DWORD *)v1 + 4);
  *((_DWORD *)v1 + 16) = v7;
  v10 = 0;
  while ( 1 )
  {
    v11 = (_WORD *)*((_DWORD *)v1 + 9);
    *v11 = 2;
    v11[1] = __rev16(atoi(v9));
    v12 = *((_DWORD *)v1 + 9);
    v13 = inet_addr(*((const char **)v1 + 3));
    v14 = *((_DWORD *)v1 + 1);
    *(_DWORD *)(v12 + 4) = v13;
    if ( v14 )
      return v34;
    add_stun();
    StunClient::start(
      *((StunClient **)v1 + 13),
      *((const char **)v1 + 3),
      *((sockaddr_in **)v1 + 10),
      *((_DWORD *)v1 + 14));
    v15 = (struct in_addr *)*((_DWORD *)v1 + 10);
    if ( v15 && ((v16 = inet_ntoa(v15[1]), strcmp(v16, "0.0.0.0")) || *((_DWORD *)v1 + 1)) )
    {
      if ( *((_DWORD *)v1 + 1) )
        return v34;
      add_stunConn();
      if ( wifiState )
      {
        if ( wifiState == 1 )
        {
          add_3g();
        }
        else if ( wifiState == 2 )
        {
          add_uncertain();
        }
      }
      else
      {
        add_wifi();
      }
      sprintf(&v35, "%s%s", *((_DWORD *)v1 + 3), *((_DWORD *)v1 + 4));
      v17 = (char *)&v34 + 3;
      v18 = 0;
      while ( 1 )
      {
        v21 = (unsigned __int8)(v17++)[1];
        v20 = v21;
        if ( !v21 )
          break;
        if ( v20 != 46 )
        {
          v19 = &v36 + v18++;
          *(v19 - 104) = v20;
        }
      }
      v22 = *((_DWORD *)v1 + 10);
      v23 = (char *)*((_DWORD *)v1 + 5);
      *(&v36 + v18 - 104) = v20;
      v24 = *((_DWORD *)v1 + 131);
      *(_WORD *)(v24 + 2) = *(_WORD *)(v22 + 2);
      if ( !v23 || wifiState & 0xFFFFFFFD )
        goto LABEL_19;
      if ( !TrackerClient::start(
              *((_DWORD *)v1 + 16),
              v23,
              &v35,
              (signed int *)v22,
              v24,
              *((const char **)v1 + 11),
              (void (__fastcall *)(_DWORD, signed int *))notifyM3u8Tracker)
        || *((_DWORD *)v1 + 1) )
      {
        if ( *((_DWORD *)v1 + 1) )
          return v34;
        TrackerClient::heartbeat(*((TrackerClient **)v1 + 16));
LABEL_19:
        v25 = (void *)*((_DWORD *)v1 + 3);
        if ( v25 )
        {
          free(v25);
          *((_DWORD *)v1 + 3) = 0;
        }
        v26 = (void *)*((_DWORD *)v1 + 4);
        if ( v26 )
        {
          free(v26);
          *((_DWORD *)v1 + 4) = 0;
        }
        v27 = (void *)*((_DWORD *)v1 + 5);
        if ( v27 )
        {
          free(v27);
          *((_DWORD *)v1 + 5) = 0;
        }
        v28 = (void *)*((_DWORD *)v1 + 8);
        if ( v28 )
        {
          free(v28);
          *((_DWORD *)v1 + 8) = 0;
        }
        add_rock();
        P2PClient::startToRock(
          *((P2PClient **)v1 + 33),
          *((sockaddr_in **)v1 + 10),
          *((sockaddr_in **)v1 + 9),
          *((_DWORD *)v1 + 14));
        while ( !*((_DWORD *)v1 + 1) )
        {
          if ( *((_BYTE *)v1 + 61) )
            break;
          usleep(0x64u);
        }
        if ( !*((_DWORD *)v1 + 1) )
          *((_BYTE *)v1 + 60) = 1;
        return v34;
      }
      if ( ++v8 <= 100000 )
      {
        if ( v8 == 3 && (v32 = (const char *)*((_DWORD *)v1 + 8)) != 0 )
        {
          if ( *((_DWORD *)v1 + 5) )
          {
            free(*((void **)v1 + 5));
            v32 = (const char *)*((_DWORD *)v1 + 8);
          }
          v33 = strdup(v32);
          v9 = (char *)*((_DWORD *)v1 + 4);
          *((_DWORD *)v1 + 5) = v33;
        }
        else
        {
LABEL_39:
          v9 = (char *)*((_DWORD *)v1 + 4);
        }
      }
      else
      {
        v9 = (char *)*((_DWORD *)v1 + 4);
        v8 = 4;
      }
    }
    else if ( ++v10 <= 100000 )
    {
      if ( v10 != 3 || !*((_DWORD *)v1 + 6) || !*((_DWORD *)v1 + 7) )
        goto LABEL_39;
      v29 = (void *)*((_DWORD *)v1 + 3);
      if ( v29 )
        free(v29);
      v30 = (void *)*((_DWORD *)v1 + 4);
      if ( v30 )
        free(v30);
      *((_DWORD *)v1 + 3) = strdup(*((const char **)v1 + 6));
      v9 = strdup(*((const char **)v1 + 7));
      *((_DWORD *)v1 + 4) = v9;
    }
    else
    {
      v9 = (char *)*((_DWORD *)v1 + 4);
      v10 = 4;
    }
  }
}
// F3944: using guessed type int wifiState;

//----- (0003B6D8) --------------------------------------------------------
int __fastcall startP2PRoutine(void *a1)
{
  int v1; // r2

  v1 = *((_DWORD *)a1 + 1);
  if ( !*((_DWORD *)a1 + 1) )
    M3U8Manager::getPeer((M3U8Manager *)a1);
  return 0;
}

//----- (0003B6FC) --------------------------------------------------------
signed int __fastcall M3U8Manager::getLocalIp(M3U8Manager *this)
{
  M3U8Manager *v1; // r7
  signed int result; // r0
  int v3; // r6
  unsigned int v4; // r5
  int *v5; // r4
  char *v6; // r4
  size_t v7; // r0
  int v8; // [sp+0h] [bp-22Ch]
  unsigned int v9; // [sp+208h] [bp-24h]
  int *v10; // [sp+20Ch] [bp-20h]

  v1 = this;
  result = socket(2, 2, 0);
  v3 = result;
  if ( result >= 0 )
  {
    v10 = &v8;
    v9 = 512;
    if ( !ioctl(result, 0x8912u, &v9) )
    {
      v4 = (v9 >> 5) - 1;
      v5 = &v8 + 8 * v4;
      while ( 1 )
      {
        v5 -= 8;
        if ( (signed int)(v4 + 1) <= 0 )
          break;
        if ( !ioctl(v3, 0x8915u) )
        {
          v6 = inet_ntoa((struct in_addr)*(&v8 + 8 * v4 + 5));
          goto LABEL_8;
        }
        --v4;
      }
    }
    v6 = 0;
LABEL_8:
    close(v3);
    v7 = strlen(v6);
    memcpy((char *)v1 + 220, v6, v7);
    result = (signed int)v1 + strlen(v6);
    *(_BYTE *)(result + 220) = 0;
  }
  return result;
}

//----- (0003B7E0) --------------------------------------------------------
int __fastcall M3U8Manager::destroyLocalSocket(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  int result; // r0

  v1 = this;
  result = *((_DWORD *)this + 14);
  if ( result > 0 )
  {
    result = close(result);
    *((_DWORD *)v1 + 14) = -1;
  }
  return result;
}

//----- (0003B804) --------------------------------------------------------
int __fastcall M3U8Manager::initLocalSocket(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  int v2; // r0
  int v3; // r5
  in_addr_t v4; // r0
  const struct sockaddr *v5; // r1
  int result; // r0

  v1 = this;
  if ( *((_DWORD *)this + 14) > 0 )
    M3U8Manager::destroyLocalSocket(this);
  v2 = socket(2, 2, 0);
  *((_DWORD *)v1 + 14) = v2;
  if ( v2 < 0 )
  {
    M3U8Manager::destroyLocalSocket(v1);
    result = -1;
  }
  else
  {
    M3U8Manager::getLocalIp(v1);
    v3 = *((_DWORD *)v1 + 131);
    *(_WORD *)v3 = 2;
    *(_WORD *)(v3 + 2) = 0;
    v4 = inet_addr((const char *)v1 + 220);
    v5 = (const struct sockaddr *)*((_DWORD *)v1 + 131);
    *(_DWORD *)(v3 + 4) = v4;
    result = bind(*((_DWORD *)v1 + 14), v5, 0x10u);
    if ( result )
    {
      M3U8Manager::destroyLocalSocket(v1);
      result = -2;
    }
  }
  return result;
}

//----- (0003B894) --------------------------------------------------------
signed int __fastcall M3U8Manager::initWindow(M3U8Manager *this)
{
  unsigned int v1; // r5
  M3U8Manager *v2; // r4
  int v3; // r7
  _BYTE *v4; // r0
  _BYTE *v5; // r6
  _DWORD *v6; // r3
  int v7; // r2
  int v8; // r1
  signed int result; // r0
  int v10; // r3
  int v11; // r0
  unsigned int v12; // r2
  int *v13; // r11
  _DWORD *v14; // r3
  int v15; // r3
  int v16; // r3
  _DWORD *v17; // r1
  int v18; // r10
  int v19; // r12
  unsigned int v20; // r11
  char *v21; // r0
  const void *v22; // r1
  int v23; // r2
  char *v24; // r3
  unsigned int v25; // r12
  char *v26; // ST04_4
  void *v27; // r0
  char *v28; // ST04_4
  _DWORD *v29; // ST00_4
  _DWORD *v30; // r12
  int v31; // r3
  int v32; // r3
  int v33; // r3
  int v34; // r3
  _DWORD *v35; // ST00_4
  int v36; // [sp+0h] [bp-30h]

  v1 = *((_DWORD *)this + 35);
  v2 = this;
  v3 = v1 + 6;
  do
  {
    v4 = operator new(0xCu);
    v4[4] = 1;
    v5 = v4;
    v6 = (_DWORD *)*((_DWORD *)v2 + 23);
    v7 = *((_DWORD *)v2 + 25) - 4;
    *((_DWORD *)v4 + 2) = 0;
    *(_DWORD *)v4 = v1;
    if ( v6 == (_DWORD *)v7 )
    {
      v10 = *((_DWORD *)v2 + 26);
      v11 = *((_DWORD *)v2 + 17);
      v12 = *((_DWORD *)v2 + 18);
      if ( v12 - ((v10 - v11) >> 2) <= 1 )
      {
        v17 = (_DWORD *)*((_DWORD *)v2 + 22);
        v18 = ((v10 - (signed int)v17) >> 2) + 1;
        v19 = ((v10 - (signed int)v17) >> 2) + 2;
        if ( v12 > 2 * v19 )
        {
          v33 = v10 + 4 - (_DWORD)v17;
          v30 = (_DWORD *)(v11 + 4 * ((v12 - v19) >> 1));
          if ( v17 <= v30 )
          {
            v34 = v33 >> 2;
            if ( v34 )
            {
              v35 = v30;
              memmove(&v30[v18 - v34], v17, 4 * v34);
              v30 = v35;
            }
          }
          else if ( v33 >> 2 )
          {
            v30 = memmove(v30, v17, 4 * (v33 >> 2));
          }
        }
        else
        {
          if ( v12 )
          {
            v20 = 2 * v12 + 2;
            if ( v20 > 0x3FFFFFFF )
              sub_BFA08();
          }
          else
          {
            v20 = 3;
          }
          v36 = ((v10 - (signed int)v17) >> 2) + 2;
          v21 = (char *)operator new(4 * v20);
          v22 = (const void *)*((_DWORD *)v2 + 22);
          v23 = (*((_DWORD *)v2 + 26) + 4 - (signed int)v22) >> 2;
          v24 = v21;
          v25 = (unsigned int)&v21[4 * ((v20 - v36) >> 1)];
          if ( v23 )
          {
            v26 = v21;
            v27 = memmove(&v21[4 * ((v20 - v36) >> 1)], v22, 4 * v23);
            v24 = v26;
            v25 = (unsigned int)v27;
          }
          v28 = v24;
          v29 = (_DWORD *)v25;
          operator delete(*((void **)v2 + 17));
          v30 = v29;
          *((_DWORD *)v2 + 18) = v20;
          *((_DWORD *)v2 + 17) = v28;
        }
        *((_DWORD *)v2 + 22) = v30;
        v31 = *v30;
        v13 = &v30[v18 + 0x3FFFFFFF];
        *((_DWORD *)v2 + 26) = v13;
        *((_DWORD *)v2 + 21) = v31 + 512;
        *((_DWORD *)v2 + 20) = v31;
        v32 = *v13;
        *((_DWORD *)v2 + 25) = *v13 + 512;
        *((_DWORD *)v2 + 24) = v32;
      }
      else
      {
        v13 = (int *)*((_DWORD *)v2 + 26);
      }
      v13[1] = (int)operator new(0x200u);
      v14 = (_DWORD *)*((_DWORD *)v2 + 23);
      if ( v14 )
        *v14 = v5;
      v15 = *((_DWORD *)v2 + 26);
      *((_DWORD *)v2 + 26) = v15 + 4;
      v16 = *(_DWORD *)(v15 + 4);
      *((_DWORD *)v2 + 25) = v16 + 512;
      *((_DWORD *)v2 + 24) = v16;
      *((_DWORD *)v2 + 23) = v16;
    }
    else
    {
      if ( v6 )
      {
        *v6 = v4;
        v6 = (_DWORD *)*((_DWORD *)v2 + 23);
      }
      *((_DWORD *)v2 + 23) = v6 + 1;
    }
    LocalMemory::initPendingData(*((LocalMemory **)v2 + 34), v1);
    v8 = v1++;
    result = TsPieceDownload::downloadPieceDataWithPieceid(*((TsPieceDownload **)v2 + 45), v8);
  }
  while ( v1 != v3 );
  *((_DWORD *)v2 + 36) = v1;
  *((_BYTE *)v2 + 61) = 1;
  return result;
}

//----- (0003BAC4) --------------------------------------------------------
int __fastcall M3U8Manager::setDownloading(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  int v2; // r7
  int v3; // r3
  unsigned int v4; // r5
  _BYTE *v5; // r0
  _BYTE *v6; // r11
  _DWORD *v7; // r2
  int v8; // r1
  int v9; // r7
  char *v10; // r3
  int v11; // r10
  unsigned int v12; // r1
  _BYTE *v13; // r0
  _BYTE *v14; // r3
  _DWORD *v15; // r2
  int v16; // r1
  int v17; // r3
  int v18; // r1
  int v20; // r2
  int v21; // lr
  unsigned int v22; // r0
  int v23; // r6
  _DWORD *v24; // r2
  int v25; // r3
  int v26; // r3
  int v27; // r2
  int v28; // lr
  unsigned int v29; // r0
  int v30; // r6
  _DWORD *v31; // r2
  int v32; // r3
  int v33; // r3
  _DWORD *v34; // r1
  int v35; // r6
  int v36; // r12
  char *v37; // r0
  const void *v38; // r1
  int v39; // r2
  char *v40; // r3
  unsigned int v41; // r12
  char *v42; // ST04_4
  void *v43; // r0
  char *v44; // ST04_4
  _DWORD *v45; // ST08_4
  _DWORD *v46; // r12
  int v47; // r2
  int v48; // r1
  int v49; // r2
  _DWORD *v50; // r1
  int v51; // r6
  int v52; // r12
  char *v53; // r0
  const void *v54; // r1
  _BYTE *v55; // r3
  int v56; // r2
  unsigned int v57; // r12
  void *v58; // r0
  _BYTE *v59; // ST04_4
  _DWORD *v60; // ST08_4
  _DWORD *v61; // r12
  int v62; // r2
  int v63; // r1
  int v64; // r2
  int v65; // r2
  int v66; // r2
  _BYTE *v67; // ST04_4
  _DWORD *v68; // r0
  int v69; // r2
  int v70; // r2
  int v71; // r2
  _BYTE *v72; // ST04_4
  _DWORD *v73; // ST08_4
  int v74; // r2
  _DWORD *v75; // ST08_4
  _BYTE *v76; // [sp+4h] [bp-3Ch]
  _BYTE *v77; // [sp+4h] [bp-3Ch]
  int v78; // [sp+8h] [bp-38h]
  int v79; // [sp+8h] [bp-38h]
  pthread_mutex_t *mutex; // [sp+Ch] [bp-34h]
  unsigned int v81; // [sp+10h] [bp-30h]
  unsigned int v82; // [sp+14h] [bp-2Ch]
  char *v83; // [sp+14h] [bp-2Ch]

  v1 = this;
  mutex = (pthread_mutex_t *)((char *)this + 152);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 152));
  v2 = *((_DWORD *)v1 + 36);
  v3 = dword_F40E0;
  if ( dword_F40E0 <= 0 )
  {
    v4 = *((_DWORD *)v1 + 36);
  }
  else
  {
    v4 = *((_DWORD *)v1 + 36);
    do
    {
      TsPieceDownload::downloadPieceDataWithPieceid(*((TsPieceDownload **)v1 + 45), v4);
      v5 = operator new(0xCu);
      v5[4] = 1;
      v6 = v5;
      v7 = (_DWORD *)*((_DWORD *)v1 + 23);
      v8 = *((_DWORD *)v1 + 25) - 4;
      *((_DWORD *)v5 + 2) = 0;
      *(_DWORD *)v5 = v4;
      if ( v7 == (_DWORD *)v8 )
      {
        v20 = *((_DWORD *)v1 + 26);
        v21 = *((_DWORD *)v1 + 17);
        v22 = *((_DWORD *)v1 + 18);
        if ( v22 - ((v20 - v21) >> 2) <= 1 )
        {
          v34 = (_DWORD *)*((_DWORD *)v1 + 22);
          v35 = ((v20 - (signed int)v34) >> 2) + 1;
          v36 = ((v20 - (signed int)v34) >> 2) + 2;
          if ( v22 > 2 * v36 )
          {
            v69 = v20 + 4 - (_DWORD)v34;
            v46 = (_DWORD *)(v21 + 4 * ((v22 - v36) >> 1));
            if ( v34 <= v46 )
            {
              v74 = v69 >> 2;
              if ( v74 )
              {
                v75 = v46;
                memmove(&v46[v35 - v74], v34, 4 * v74);
                v46 = v75;
              }
            }
            else
            {
              v70 = v69 >> 2;
              if ( v70 )
                v46 = memmove(v46, v34, 4 * v70);
            }
          }
          else
          {
            if ( v22 )
            {
              v82 = 2 * v22 + 2;
              if ( v82 > 0x3FFFFFFF )
LABEL_62:
                sub_BFA08();
            }
            else
            {
              v82 = 3;
            }
            v78 = ((v20 - (signed int)v34) >> 2) + 2;
            v37 = (char *)operator new(4 * v82);
            v38 = (const void *)*((_DWORD *)v1 + 22);
            v39 = (*((_DWORD *)v1 + 26) + 4 - (signed int)v38) >> 2;
            v40 = v37;
            v41 = (unsigned int)&v37[4 * ((v82 - v78) >> 1)];
            if ( v39 )
            {
              v42 = v37;
              v43 = memmove(&v37[4 * ((v82 - v78) >> 1)], v38, 4 * v39);
              v40 = v42;
              v41 = (unsigned int)v43;
            }
            v44 = v40;
            v45 = (_DWORD *)v41;
            operator delete(*((void **)v1 + 17));
            v46 = v45;
            *((_DWORD *)v1 + 17) = v44;
            *((_DWORD *)v1 + 18) = v82;
          }
          *((_DWORD *)v1 + 22) = v46;
          v47 = v35 + 0x3FFFFFFF;
          v48 = *v46;
          v23 = (int)&v46[v35 + 0x3FFFFFFF];
          *((_DWORD *)v1 + 26) = v23;
          *((_DWORD *)v1 + 21) = v48 + 512;
          *((_DWORD *)v1 + 20) = v48;
          v49 = v46[v47];
          *((_DWORD *)v1 + 25) = v49 + 512;
          *((_DWORD *)v1 + 24) = v49;
        }
        else
        {
          v23 = *((_DWORD *)v1 + 26);
        }
        *(_DWORD *)(v23 + 4) = operator new(0x200u);
        v24 = (_DWORD *)*((_DWORD *)v1 + 23);
        if ( v24 )
          *v24 = v6;
        v25 = *((_DWORD *)v1 + 26);
        *((_DWORD *)v1 + 26) = v25 + 4;
        v26 = *(_DWORD *)(v25 + 4);
        *((_DWORD *)v1 + 25) = v26 + 512;
        *((_DWORD *)v1 + 24) = v26;
        *((_DWORD *)v1 + 23) = v26;
      }
      else
      {
        if ( v7 )
        {
          *v7 = v5;
          v7 = (_DWORD *)*((_DWORD *)v1 + 23);
        }
        *((_DWORD *)v1 + 23) = v7 + 1;
      }
      LocalMemory::initPendingData(*((LocalMemory **)v1 + 34), v4++);
      v3 = dword_F40E0;
    }
    while ( dword_F40E0 > (signed int)(v4 - v2) );
    v2 = *((_DWORD *)v1 + 36);
  }
  v9 = v2 - *((_DWORD *)v1 + 35);
  if ( v9 >= dword_F3098 )
    v10 = (char *)delay_time - dword_F3098 - v3;
  else
    v10 = (char *)delay_time - v9 - v3;
  if ( (signed int)v10 > 0 )
  {
    v11 = (int)&v10[v4];
    while ( 1 )
    {
      v13 = operator new(0xCu);
      v13[4] = 1;
      v14 = v13;
      v15 = (_DWORD *)*((_DWORD *)v1 + 23);
      v16 = *((_DWORD *)v1 + 25) - 4;
      *((_DWORD *)v13 + 2) = 0;
      *(_DWORD *)v13 = v4;
      if ( v15 == (_DWORD *)v16 )
      {
        v27 = *((_DWORD *)v1 + 26);
        v28 = *((_DWORD *)v1 + 17);
        v29 = *((_DWORD *)v1 + 18);
        if ( v29 - ((v27 - v28) >> 2) <= 1 )
        {
          v50 = (_DWORD *)*((_DWORD *)v1 + 22);
          v51 = ((v27 - (signed int)v50) >> 2) + 1;
          v52 = ((v27 - (signed int)v50) >> 2) + 2;
          if ( v29 > 2 * v52 )
          {
            v65 = v27 + 4 - (_DWORD)v50;
            v61 = (_DWORD *)(v28 + 4 * ((v29 - v52) >> 1));
            if ( v50 <= v61 )
            {
              v71 = v65 >> 2;
              if ( v71 )
              {
                v72 = v14;
                v73 = v61;
                memmove(&v61[v51 - v71], v50, 4 * v71);
                v14 = v72;
                v61 = v73;
              }
            }
            else
            {
              v66 = v65 >> 2;
              if ( v66 )
              {
                v67 = v14;
                v68 = memmove(v61, v50, 4 * v66);
                v14 = v67;
                v61 = v68;
              }
            }
          }
          else
          {
            if ( v29 )
            {
              v81 = 2 * v29 + 2;
              if ( v81 > 0x3FFFFFFF )
                goto LABEL_62;
            }
            else
            {
              v81 = 3;
            }
            v77 = v14;
            v79 = ((v27 - (signed int)v50) >> 2) + 2;
            v53 = (char *)operator new(4 * v81);
            v54 = (const void *)*((_DWORD *)v1 + 22);
            v55 = v77;
            v56 = (*((_DWORD *)v1 + 26) + 4 - (signed int)v54) >> 2;
            v83 = v53;
            v57 = (unsigned int)&v53[4 * ((v81 - v79) >> 1)];
            if ( v56 )
            {
              v58 = memmove(&v53[4 * ((v81 - v79) >> 1)], v54, 4 * v56);
              v55 = v77;
              v57 = (unsigned int)v58;
            }
            v59 = v55;
            v60 = (_DWORD *)v57;
            operator delete(*((void **)v1 + 17));
            v14 = v59;
            v61 = v60;
            *((_DWORD *)v1 + 17) = v83;
            *((_DWORD *)v1 + 18) = v81;
          }
          *((_DWORD *)v1 + 22) = v61;
          v62 = v51 + 0x3FFFFFFF;
          v63 = *v61;
          v30 = (int)&v61[v51 + 0x3FFFFFFF];
          *((_DWORD *)v1 + 26) = v30;
          *((_DWORD *)v1 + 21) = v63 + 512;
          *((_DWORD *)v1 + 20) = v63;
          v64 = v61[v62];
          *((_DWORD *)v1 + 25) = v64 + 512;
          *((_DWORD *)v1 + 24) = v64;
        }
        else
        {
          v30 = *((_DWORD *)v1 + 26);
        }
        v76 = v14;
        *(_DWORD *)(v30 + 4) = operator new(0x200u);
        v31 = (_DWORD *)*((_DWORD *)v1 + 23);
        if ( v31 )
          *v31 = v76;
        v32 = *((_DWORD *)v1 + 26);
        *((_DWORD *)v1 + 26) = v32 + 4;
        v33 = *(_DWORD *)(v32 + 4);
        *((_DWORD *)v1 + 25) = v33 + 512;
        *((_DWORD *)v1 + 24) = v33;
        *((_DWORD *)v1 + 23) = v33;
      }
      else
      {
        if ( v15 )
        {
          *v15 = v13;
          v15 = (_DWORD *)*((_DWORD *)v1 + 23);
        }
        *((_DWORD *)v1 + 23) = v15 + 1;
      }
      LocalMemory::initPendingData(*((LocalMemory **)v1 + 34), v4);
      v17 = lrand48() % 100;
      if ( v17 < 0 || v17 >= CDN_RATION )
      {
        v12 = v4++;
        P2PClient::addMission(*((P2PClient **)v1 + 33), v12);
        if ( v4 == v11 )
          break;
      }
      else
      {
        v18 = v4++;
        TsPieceDownload::downloadPieceDataWithPieceid(*((TsPieceDownload **)v1 + 45), v18);
        if ( v4 == v11 )
          break;
      }
    }
  }
  *((_DWORD *)v1 + 36) = v4;
  return pthread_mutex_unlock(mutex);
}
// F3098: using guessed type int dword_F3098;
// F30DC: using guessed type int *delay_time;
// F30EC: using guessed type int CDN_RATION;
// F40E0: using guessed type int dword_F40E0;

//----- (0003C040) --------------------------------------------------------
int __fastcall M3U8Manager::moveOnStep(M3U8Manager *this)
{
  pthread_mutex_t *v1; // r5
  M3U8Manager *v2; // r4
  int v3; // r3
  LocalMemory *v4; // r0

  v1 = (pthread_mutex_t *)((char *)this + 112);
  v2 = this;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
  v3 = 0;
  do
  {
    *(_BYTE *)(*((_DWORD *)v2 + 27) + v3) = *(_BYTE *)(*((_DWORD *)v2 + 27) + v3 + 1);
    ++v3;
  }
  while ( v3 != 160 );
  *(_BYTE *)(*((_DWORD *)v2 + 27) + 159) = 0;
  v4 = (LocalMemory *)*((_DWORD *)v2 + 34);
  ++*(_DWORD *)(*((_DWORD *)v2 + 33) + 11000);
  LocalMemory::moveOnStep(v4);
  return pthread_mutex_unlock(v1);
}

//----- (0003C0A8) --------------------------------------------------------
int __fastcall M3U8Manager::assignMission(M3U8Manager *this)
{
  int v1; // r3
  M3U8Manager *v2; // r4
  int v3; // r1
  int result; // r0
  int *v5; // r5
  signed int v6; // r11
  int v7; // r6
  _BYTE *v8; // r0
  _BYTE *v9; // r5
  int v10; // r2
  _DWORD *v11; // r2
  int v12; // r3
  int v13; // r2
  int v14; // lr
  unsigned int v15; // r0
  int v16; // r3
  _DWORD *v17; // r2
  int v18; // r3
  int v19; // r3
  _DWORD *v20; // r1
  int v21; // r3
  int v22; // r12
  char *v23; // r0
  const void *v24; // r1
  int v25; // r3
  int v26; // r2
  unsigned int v27; // r12
  void *v28; // r0
  int v29; // ST04_4
  _DWORD *v30; // ST08_4
  _DWORD *v31; // r12
  int v32; // r2
  int v33; // r1
  int v34; // r2
  int v35; // r2
  int v36; // r2
  int v37; // ST04_4
  _DWORD *v38; // r0
  int v39; // r2
  int v40; // ST04_4
  _DWORD *v41; // ST08_4
  int v42; // [sp+4h] [bp-3Ch]
  int v43; // [sp+8h] [bp-38h]
  unsigned int v44; // [sp+10h] [bp-30h]
  char *v45; // [sp+14h] [bp-2Ch]

  v1 = *((_DWORD *)this + 26) - *((_DWORD *)this + 22);
  v2 = this;
  v3 = *((_DWORD *)this + 23) - *((_DWORD *)this + 24);
  result = *((_DWORD *)this + 21);
  if ( (v3 >> 2) + (((v1 >> 2) - 1) << 7) + ((result - *((_DWORD *)v2 + 19)) >> 2) )
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)v2 + 152));
    if ( *((_BYTE *)v2 + 60) )
      v5 = delay_time;
    else
      v5 = (int *)dword_F3098;
    v6 = (signed int)v5
       + (unsigned int)FifoDataManager::getWriteDataTime((FifoDataManager *)*((_DWORD *)v2 + 39))
       - *((_DWORD *)v2 + 36);
    if ( v6 > 0 )
    {
      v7 = 0;
      do
      {
        if ( (unsigned int)(((*((_DWORD *)v2 + 23) - *((_DWORD *)v2 + 24)) >> 2)
                          + ((((*((_DWORD *)v2 + 26) - *((_DWORD *)v2 + 22)) >> 2) - 1) << 7)
                          + ((*((_DWORD *)v2 + 21) - *((_DWORD *)v2 + 19)) >> 2)) > 0x9F )
          M3U8Manager::moveOnStep(v2);
        v8 = operator new(0xCu);
        v8[4] = 0;
        v9 = v8;
        v10 = *((_DWORD *)v2 + 36);
        *((_DWORD *)v8 + 2) = 0;
        v8[4] = 1;
        *(_DWORD *)v8 = v10;
        pthread_mutex_lock((pthread_mutex_t *)((char *)v2 + 112));
        v11 = (_DWORD *)*((_DWORD *)v2 + 23);
        if ( v11 == (_DWORD *)(*((_DWORD *)v2 + 25) - 4) )
        {
          v13 = *((_DWORD *)v2 + 26);
          v14 = *((_DWORD *)v2 + 17);
          v15 = *((_DWORD *)v2 + 18);
          if ( v15 - ((v13 - v14) >> 2) <= 1 )
          {
            v20 = (_DWORD *)*((_DWORD *)v2 + 22);
            v21 = ((v13 - (signed int)v20) >> 2) + 1;
            v22 = ((v13 - (signed int)v20) >> 2) + 2;
            if ( v15 > 2 * v22 )
            {
              v35 = v13 + 4 - (_DWORD)v20;
              v31 = (_DWORD *)(v14 + 4 * ((v15 - v22) >> 1));
              if ( v20 <= v31 )
              {
                v39 = v35 >> 2;
                if ( v39 )
                {
                  v40 = v21;
                  v41 = v31;
                  memmove(&v31[v21 - v39], v20, 4 * v39);
                  v21 = v40;
                  v31 = v41;
                }
              }
              else
              {
                v36 = v35 >> 2;
                if ( v36 )
                {
                  v37 = v21;
                  v38 = memmove(v31, v20, 4 * v36);
                  v21 = v37;
                  v31 = v38;
                }
              }
            }
            else
            {
              if ( v15 )
              {
                v44 = 2 * v15 + 2;
                if ( v44 > 0x3FFFFFFF )
                  sub_BFA08();
              }
              else
              {
                v44 = 3;
              }
              v42 = ((v13 - (signed int)v20) >> 2) + 1;
              v43 = ((v13 - (signed int)v20) >> 2) + 2;
              v23 = (char *)operator new(4 * v44);
              v24 = (const void *)*((_DWORD *)v2 + 22);
              v25 = v42;
              v26 = (*((_DWORD *)v2 + 26) + 4 - (signed int)v24) >> 2;
              v45 = v23;
              v27 = (unsigned int)&v23[4 * ((v44 - v43) >> 1)];
              if ( v26 )
              {
                v28 = memmove(&v23[4 * ((v44 - v43) >> 1)], v24, 4 * v26);
                v25 = v42;
                v27 = (unsigned int)v28;
              }
              v29 = v25;
              v30 = (_DWORD *)v27;
              operator delete(*((void **)v2 + 17));
              v21 = v29;
              v31 = v30;
              *((_DWORD *)v2 + 17) = v45;
              *((_DWORD *)v2 + 18) = v44;
            }
            *((_DWORD *)v2 + 22) = v31;
            v32 = v21 + 0x3FFFFFFF;
            v33 = *v31;
            v16 = (int)&v31[v21 + 0x3FFFFFFF];
            *((_DWORD *)v2 + 26) = v16;
            *((_DWORD *)v2 + 21) = v33 + 512;
            *((_DWORD *)v2 + 20) = v33;
            v34 = v31[v32];
            *((_DWORD *)v2 + 25) = v34 + 512;
            *((_DWORD *)v2 + 24) = v34;
          }
          else
          {
            v16 = *((_DWORD *)v2 + 26);
          }
          *(_DWORD *)(v16 + 4) = operator new(0x200u);
          v17 = (_DWORD *)*((_DWORD *)v2 + 23);
          if ( v17 )
            *v17 = v9;
          v18 = *((_DWORD *)v2 + 26);
          *((_DWORD *)v2 + 26) = v18 + 4;
          v19 = *(_DWORD *)(v18 + 4);
          *((_DWORD *)v2 + 25) = v19 + 512;
          *((_DWORD *)v2 + 24) = v19;
          *((_DWORD *)v2 + 23) = v19;
        }
        else
        {
          if ( v11 )
          {
            *v11 = v9;
            v11 = (_DWORD *)*((_DWORD *)v2 + 23);
          }
          *((_DWORD *)v2 + 23) = v11 + 1;
        }
        LocalMemory::initPendingData(*((LocalMemory **)v2 + 34), *((_DWORD *)v2 + 36));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)v2 + 112));
        v12 = lrand48() % 100;
        if ( (v12 < 0 || v12 >= CDN_RATION) && *((_BYTE *)v2 + 60) )
          P2PClient::addMission(*((P2PClient **)v2 + 33), *((_DWORD *)v2 + 36));
        else
          TsPieceDownload::downloadPieceDataWithPieceid(*((TsPieceDownload **)v2 + 45), *((_DWORD *)v2 + 36));
        ++v7;
        ++*((_DWORD *)v2 + 36);
      }
      while ( v6 != v7 );
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)((char *)v2 + 152));
  }
  return result;
}
// F3098: using guessed type int dword_F3098;
// F30DC: using guessed type int *delay_time;
// F30EC: using guessed type int CDN_RATION;

//----- (0003C474) --------------------------------------------------------
int __fastcall M3U8Manager::generateUrl(int result)
{
  int v1; // r4

  v1 = result;
  if ( !*(_DWORD *)(result + 4) )
  {
    M3U8Manager::assignMission((M3U8Manager *)result);
    result = (*(int (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v1 + 176) + 8))(
               *(_DWORD *)(v1 + 176),
               *(_DWORD *)(**(_DWORD **)(v1 + 176) + 8));
  }
  return result;
}

//----- (0003C4CC) --------------------------------------------------------
double __fastcall M3U8Manager::getCurrentPlayTime(M3U8Manager *this)
{
  FifoDataManager *v1; // r0
  double result; // r0

  if ( *((_DWORD *)this + 1) || (v1 = (FifoDataManager *)*((_DWORD *)this + 39)) == 0 )
    result = 0.0;
  else
    result = FifoDataManager::getWriteDataTime(v1);
  return result;
}

//----- (0003C4F4) --------------------------------------------------------
int __fastcall M3U8Manager::getCurrentContinuousPieceBytes(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  FifoDataManager *v2; // r0
  LocalMemory *v3; // r5
  double v4; // r0
  int result; // r0

  v1 = this;
  v2 = (FifoDataManager *)*((_DWORD *)this + 39);
  if ( v2 && (v3 = (LocalMemory *)*((_DWORD *)v1 + 34)) != 0 )
  {
    v4 = FifoDataManager::getWriteDataTime(v2);
    result = LocalMemory::getAvaliablePieceBytes(v3, (unsigned int)v4, (int *)v1 + 132);
    *((_DWORD *)v1 + 41) = result;
  }
  else
  {
    *((_DWORD *)v1 + 41) = 0;
    result = 0;
    *((_DWORD *)v1 + 132) = 0;
  }
  return result;
}

//----- (0003C54C) --------------------------------------------------------
int __fastcall M3U8Manager::getCurrentContinuousPieceNum(M3U8Manager *this)
{
  return *((_DWORD *)this + 132);
}

//----- (0003C554) --------------------------------------------------------
int __fastcall M3U8Manager::getCurrentPieceBytes(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  LocalMemory *v2; // r0
  int result; // r0

  v1 = this;
  if ( *((_DWORD *)this + 39) && (v2 = (LocalMemory *)*((_DWORD *)this + 34)) != 0 )
  {
    result = LocalMemory::getCurrentPieceBytes(v2, (int *)v1 + 136);
    *((double *)v1 + 67) = (double)(unsigned int)result;
  }
  else
  {
    result = 0;
    *((_DWORD *)v1 + 136) = 0;
    *((_DWORD *)v1 + 134) = 0;
    *((_DWORD *)v1 + 135) = 0;
  }
  return result;
}

//----- (0003C5AC) --------------------------------------------------------
int __fastcall M3U8Manager::getCurrentPieceNum(M3U8Manager *this)
{
  return *((_DWORD *)this + 136);
}

//----- (0003C5B4) --------------------------------------------------------
M3U8Manager *__fastcall M3U8Manager::M3U8Manager(M3U8Manager *this, ChannelPlayInfoManager *a2, int a3, char *a4)
{
  M3U8Manager *v4; // r4
  int v5; // lr
  char *v6; // r8
  char *v7; // r9
  _DWORD *v8; // r0
  unsigned int v9; // r7
  _DWORD *v10; // r5
  int v11; // r10
  int v12; // r12
  int v13; // r2
  void *v14; // r0
  int v15; // r2
  size_t v16; // r0
  char *v17; // r1
  int v18; // r3
  char *v19; // r1
  int v20; // r7
  size_t v21; // r0
  _DWORD *v22; // lr
  _DWORD *v23; // r0
  _DWORD *v24; // r3
  char *v25; // r0
  char *v26; // r7
  void *v27; // r5
  M3U8Manager *result; // r0
  int v29; // [sp+4h] [bp-83Ch]
  struct timeval tv; // [sp+8h] [bp-838h]
  char dest; // [sp+10h] [bp-830h]
  size_t v32; // [sp+810h] [bp-30h]
  int v33; // [sp+814h] [bp-2Ch]

  v4 = this;
  *((_DWORD *)this + 14) = -1;
  v5 = _stack_chk_guard;
  v6 = (char *)a2;
  *((_DWORD *)this + 18) = 8;
  *((_DWORD *)this + 9) = 0;
  v7 = a4;
  v33 = v5;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_BYTE *)this + 60) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 61) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 26) = 0;
  v29 = a3;
  v8 = operator new(0x20u);
  v9 = (unsigned int)(*((_DWORD *)v4 + 18) - 1) >> 1;
  v10 = v8;
  *((_DWORD *)v4 + 17) = v8;
  v11 = (int)&v8[v9];
  v8[v9] = operator new(0x200u);
  *((_DWORD *)v4 + 22) = v11;
  v12 = v10[v9];
  *((_DWORD *)v4 + 26) = v11;
  *((_DWORD *)v4 + 21) = v12 + 512;
  *((_DWORD *)v4 + 20) = v12;
  v13 = v10[v9];
  *((_DWORD *)v4 + 19) = v12;
  *((_DWORD *)v4 + 27) = 0;
  *((_DWORD *)v4 + 24) = v13;
  *((_DWORD *)v4 + 23) = v13;
  *((_DWORD *)v4 + 25) = v13 + 512;
  *((_DWORD *)v4 + 29) = 0;
  *((_DWORD *)v4 + 30) = 0;
  *((_DWORD *)v4 + 31) = 0;
  *((_DWORD *)v4 + 32) = 0;
  *((_DWORD *)v4 + 33) = 0;
  *((_DWORD *)v4 + 34) = 0;
  *((_DWORD *)v4 + 35) = 0;
  *((_DWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 37) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)v4 + 152), 0);
  *((_DWORD *)v4 + 40) = 0;
  *((_DWORD *)v4 + 42) = 0;
  *((_DWORD *)v4 + 43) = 0;
  *((_DWORD *)v4 + 44) = 0;
  *((_DWORD *)v4 + 45) = 0;
  *((_DWORD *)v4 + 47) = 0;
  *((_DWORD *)v4 + 49) = 0;
  *((_DWORD *)v4 + 50) = 0;
  strcpy((char *)&dword_F42A0, "self");
  *((_DWORD *)v4 + 51) = 0;
  *((_DWORD *)v4 + 52) = 0;
  *((_DWORD *)v4 + 54) = 0;
  gettimeofday(&tv, 0);
  srand48(tv.tv_usec / 0x3E8uLL + 1000 * tv.tv_sec);
  v14 = malloc(0x800u);
  *((_DWORD *)v4 + 49) = v14;
  memset(v14, 0, 0x800u);
  if ( v7 )
  {
    strcpy(&dest, v7);
    v16 = strlen(v7);
    v17 = (char *)*((_DWORD *)v4 + 51);
    v15 = *((_DWORD *)v4 + 52);
    v32 = v16;
    if ( v17 == (char *)v15 )
    {
      std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)v4 + 200, v17, &dest);
    }
    else
    {
      if ( v17 )
      {
        memcpy(v17, &dest, 0x804u);
        v18 = *((_DWORD *)v4 + 51);
      }
      else
      {
        v18 = 0;
      }
      *((_DWORD *)v4 + 51) = v18 + 2052;
    }
  }
  *((_DWORD *)v4 + 53) = v6;
  v19 = (char *)*((_DWORD *)v4 + 49);
  *(_DWORD *)v4 = v29;
  gM3U8Manager = (int)v4;
  ChannelPlayInfoManager::getCurrentCdnUrl((ChannelPlayInfoManager *)v6, v19, v15);
  v20 = *((_DWORD *)v4 + 49);
  v21 = strlen(*((const char **)v4 + 49));
  v22 = (_DWORD *)(v20 + v21);
  *(_DWORD *)(v20 + v21) = *(_DWORD *)"/playlist3.m3u8";
  v22[1] = *(_DWORD *)"ylist3.m3u8";
  v22[2] = *(_DWORD *)"t3.m3u8";
  v22[3] = *(_DWORD *)"3u8";
  v23 = malloc(0x10u);
  gM3U8Manager = (int)v4;
  *v23 = 0;
  v24 = v23 + 2;
  *((_DWORD *)v4 + 131) = v23;
  v23[1] = 0;
  *v24 = 0;
  v24[1] = 0;
  v25 = strdup(v6 + 8);
  v26 = v25;
  *((_DWORD *)v4 + 2) = v25;
  memset(&dest, 0, 0x800u);
  sprintf(&dest, "%s_default_%d", v26, 10016);
  *((_DWORD *)v4 + 11) = strdup(&dest);
  pthread_mutex_init((pthread_mutex_t *)((char *)v4 + 184), 0);
  M3U8Manager::initLocalSocket(v4);
  v27 = operator new(0x58u);
  FifoDataManager::FifoDataManager((int)v27);
  result = v4;
  *((_DWORD *)v4 + 39) = v27;
  return result;
}
// F40F4: using guessed type int gM3U8Manager;
// F42A0: using guessed type int dword_F42A0;
// F42A4: using guessed type char byte_F42A4;

//----- (0003C970) --------------------------------------------------------
char **__fastcall M3U8Manager::parseConf(M3U8Manager *this, char *a2)
{
  Json::Value *v2; // r6
  M3U8Manager *v3; // r11
  char *v4; // ST14_4
  void **v5; // r4
  Json::Value *v6; // r8
  int v7; // r5
  void *v8; // r0
  char *v9; // r3
  char **v10; // r5
  char *v11; // r0
  void *v12; // r0
  int *v13; // r9
  void *v14; // r0
  int *v15; // r0
  void *v16; // r0
  void *v17; // t1
  char **result; // r0
  int v19; // r3
  int *v20; // r0
  int v21; // r2
  void *v22; // r0
  int *v23; // r0
  int v24; // r2
  void *v25; // r0
  int *v26; // r0
  int v27; // r2
  void *v28; // r0
  int *v29; // r0
  int v30; // r2
  void *v31; // r0
  int *v32; // r0
  int v33; // r2
  void *v34; // r0
  int *v35; // r0
  int v36; // r2
  void *v37; // r0
  int *v38; // r0
  int v39; // r2
  void *v40; // r0
  int *v41; // r0
  int v42; // r2
  void *v43; // r0
  int *v44; // r0
  int v45; // r2
  void *v46; // r0
  int *v47; // r0
  int v48; // r2
  void *v49; // r0
  int *v50; // r0
  int v51; // r2
  void *v52; // r0
  char *v53; // r10
  int *v54; // r0
  int v55; // r2
  void *v56; // r0
  char *v57; // r0
  char *v58; // r3
  bool v59; // zf
  int v60; // r3
  bool v61; // zf
  char *v62; // r2
  char *v63; // r10
  int v64; // t1
  bool v65; // zf
  int *v66; // r0
  int v67; // r2
  int *v68; // r0
  int v69; // r2
  void *v70; // r0
  int *v71; // r0
  int v72; // r2
  void *v73; // r0
  int *v74; // r0
  int v75; // r2
  void *v76; // r0
  int *v77; // r0
  int v78; // r2
  void *v79; // r0
  int *v80; // r0
  int v81; // r2
  void **v82; // r0
  double v83; // r0
  float v84; // s15
  float v85; // s15
  float v86; // s15
  float v87; // s15
  float v88; // s15
  float v89; // s14
  char *v90; // r0
  char *v91; // r1
  bool v92; // zf
  int v93; // r3
  bool v94; // zf
  char *v95; // r2
  char *v96; // r9
  int v97; // t1
  bool v98; // zf
  unsigned int *v99; // r3
  signed int v100; // r2
  unsigned int *v101; // r2
  signed int v102; // r1
  unsigned int *v103; // r3
  signed int v104; // r2
  unsigned int *v105; // r3
  signed int v106; // r2
  unsigned int *v107; // r3
  signed int v108; // r2
  unsigned int *v109; // r3
  signed int v110; // r2
  unsigned int *v111; // r3
  signed int v112; // r2
  unsigned int *v113; // r3
  signed int v114; // r2
  unsigned int *v115; // r3
  signed int v116; // r2
  unsigned int *v117; // r3
  signed int v118; // r2
  unsigned int *v119; // r3
  signed int v120; // r2
  unsigned int *v121; // r3
  signed int v122; // r2
  unsigned int *v123; // r3
  signed int v124; // r2
  unsigned int *v125; // r3
  signed int v126; // r2
  unsigned int *v127; // r3
  signed int v128; // r2
  unsigned int *v129; // r3
  signed int v130; // r2
  unsigned int *v131; // r3
  signed int v132; // r2
  unsigned int *v133; // r3
  signed int v134; // r2
  unsigned int *v135; // r3
  signed int v136; // r2
  unsigned int *v137; // r3
  signed int v138; // r2
  unsigned int *v139; // r3
  signed int v140; // r2
  unsigned int *v141; // r3
  signed int v142; // r2
  char *nptr; // [sp+20h] [bp-518h]
  int v144; // [sp+24h] [bp-514h]
  int v145; // [sp+28h] [bp-510h]
  int v146; // [sp+2Ch] [bp-50Ch]
  int v147; // [sp+30h] [bp-508h]
  int v148; // [sp+34h] [bp-504h]
  int v149; // [sp+38h] [bp-500h]
  int v150; // [sp+3Ch] [bp-4FCh]
  int v151; // [sp+40h] [bp-4F8h]
  int v152; // [sp+44h] [bp-4F4h]
  int v153; // [sp+48h] [bp-4F0h]
  int v154; // [sp+4Ch] [bp-4ECh]
  int v155; // [sp+50h] [bp-4E8h]
  int v156; // [sp+54h] [bp-4E4h]
  int v157; // [sp+58h] [bp-4E0h]
  int v158; // [sp+5Ch] [bp-4DCh]
  int v159; // [sp+60h] [bp-4D8h]
  int v160; // [sp+64h] [bp-4D4h]
  char v161; // [sp+68h] [bp-4D0h]
  int v162; // [sp+7Ch] [bp-4BCh]
  int v163; // [sp+80h] [bp-4B8h]
  Json::Value *v164; // [sp+84h] [bp-4B4h]
  Json::Value *v165; // [sp+88h] [bp-4B0h]
  void **v166; // [sp+8Ch] [bp-4ACh]
  int v167; // [sp+90h] [bp-4A8h]
  int v168; // [sp+94h] [bp-4A4h]
  int v169; // [sp+98h] [bp-4A0h]
  void *v170; // [sp+9Ch] [bp-49Ch]
  unsigned int v171; // [sp+B0h] [bp-488h]
  int v172; // [sp+C0h] [bp-478h]
  char v173; // [sp+C4h] [bp-474h]
  int v174; // [sp+CCh] [bp-46Ch]
  int v175; // [sp+D0h] [bp-468h]
  Json::Value *v176; // [sp+D4h] [bp-464h]
  Json::Value *v177; // [sp+D8h] [bp-460h]
  void **v178; // [sp+DCh] [bp-45Ch]
  int v179; // [sp+E0h] [bp-458h]
  int v180; // [sp+E4h] [bp-454h]
  int v181; // [sp+E8h] [bp-450h]
  int v182; // [sp+ECh] [bp-44Ch]
  int v183; // [sp+104h] [bp-434h]
  char s; // [sp+10Ch] [bp-42Ch]
  char v185; // [sp+110h] [bp-428h]
  int v186; // [sp+50Ch] [bp-2Ch]

  v2 = (Json::Value *)&v161;
  v3 = this;
  v4 = a2;
  Json::Reader::Reader((Json::Reader *)&v170);
  Json::Value::Value((int)&v161, 0);
  v5 = (void **)&dword_2FEF3C;
  nptr = (char *)&unk_2FEF48;
  memset(&s, 0, 0x400u);
  add_confSuc();
  v6 = (Json::Value *)&v162;
  sub_C1C58((void **)&v144, v4);
  v7 = Json::Reader::parse((const char **)&v170, (int)&v144, (Json::Value *)&v161, 1);
  v8 = (void *)(v144 - 12);
  if ( (int *)(v144 - 12) != &dword_2FEF3C )
  {
    v101 = (unsigned int *)(v144 - 4);
    __dmb(0xFu);
    do
      v102 = __ldrex(v101);
    while ( __strex(v102 - 1, v101) );
    __dmb(0xFu);
    if ( v102 <= 0 )
      operator delete(v8);
  }
  if ( v7 )
  {
    v20 = Json::Value::operator[]((Json::Value *)&v161, "window_s");
    Json::Value::asString((Json::Value *)&v145, (int)v20, v21);
    v10 = &nptr;
    sub_C1700(&nptr, &v145);
    v22 = (void *)(v145 - 12);
    if ( (int *)(v145 - 12) != &dword_2FEF3C )
    {
      v125 = (unsigned int *)(v145 - 4);
      __dmb(0xFu);
      do
        v126 = __ldrex(v125);
      while ( __strex(v126 - 1, v125) );
      __dmb(0xFu);
      if ( v126 <= 0 )
        operator delete(v22);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v84 = strtod(nptr, 0);
      unk_F309C = LODWORD(v84);
    }
    v23 = Json::Value::operator[]((Json::Value *)&v161, "window_i");
    Json::Value::asString((Json::Value *)&v146, (int)v23, v24);
    sub_C1700(&nptr, &v146);
    v25 = (void *)(v146 - 12);
    if ( (int *)(v146 - 12) != &dword_2FEF3C )
    {
      v123 = (unsigned int *)(v146 - 4);
      __dmb(0xFu);
      do
        v124 = __ldrex(v123);
      while ( __strex(v124 - 1, v123) );
      __dmb(0xFu);
      if ( v124 <= 0 )
        operator delete(v25);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v85 = strtod(nptr, 0);
      unk_F30A0 = LODWORD(v85);
    }
    v26 = Json::Value::operator[]((Json::Value *)&v161, "window_p");
    Json::Value::asString((Json::Value *)&v147, (int)v26, v27);
    sub_C1700(&nptr, &v147);
    v28 = (void *)(v147 - 12);
    if ( (int *)(v147 - 12) != &dword_2FEF3C )
    {
      v107 = (unsigned int *)(v147 - 4);
      __dmb(0xFu);
      do
        v108 = __ldrex(v107);
      while ( __strex(v108 - 1, v107) );
      __dmb(0xFu);
      if ( v108 <= 0 )
        operator delete(v28);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v86 = strtod(nptr, 0);
      unk_F30A4 = LODWORD(v86);
    }
    v29 = Json::Value::operator[]((Json::Value *)&v161, "cdn_mragin");
    Json::Value::asString((Json::Value *)&v148, (int)v29, v30);
    sub_C1700(&nptr, &v148);
    v31 = (void *)(v148 - 12);
    if ( (int *)(v148 - 12) != &dword_2FEF3C )
    {
      v103 = (unsigned int *)(v148 - 4);
      __dmb(0xFu);
      do
        v104 = __ldrex(v103);
      while ( __strex(v104 - 1, v103) );
      __dmb(0xFu);
      if ( v104 <= 0 )
        operator delete(v31);
    }
    if ( *((_DWORD *)nptr - 3) )
      dword_F40E0 = atoi(nptr);
    v32 = Json::Value::operator[]((Json::Value *)&v161, "max_con");
    Json::Value::asString((Json::Value *)&v149, (int)v32, v33);
    sub_C1700(&nptr, &v149);
    v34 = (void *)(v149 - 12);
    if ( (int *)(v149 - 12) != &dword_2FEF3C )
    {
      v129 = (unsigned int *)(v149 - 4);
      __dmb(0xFu);
      do
        v130 = __ldrex(v129);
      while ( __strex(v130 - 1, v129) );
      __dmb(0xFu);
      if ( v130 <= 0 )
        operator delete(v34);
    }
    if ( *((_DWORD *)nptr - 3) )
      off_F30A8[0] = (int *)atoi(nptr);
    v35 = Json::Value::operator[]((Json::Value *)&v161, "kick_con");
    Json::Value::asString((Json::Value *)&v150, (int)v35, v36);
    sub_C1700(&nptr, &v150);
    v37 = (void *)(v150 - 12);
    if ( (int *)(v150 - 12) != &dword_2FEF3C )
    {
      v127 = (unsigned int *)(v150 - 4);
      __dmb(0xFu);
      do
        v128 = __ldrex(v127);
      while ( __strex(v128 - 1, v127) );
      __dmb(0xFu);
      if ( v128 <= 0 )
        operator delete(v37);
    }
    if ( *((_DWORD *)nptr - 3) )
      dword_F30AC = atoi(nptr);
    v38 = Json::Value::operator[]((Json::Value *)&v161, "min_con");
    Json::Value::asString((Json::Value *)&v151, (int)v38, v39);
    sub_C1700(&nptr, &v151);
    v40 = (void *)(v151 - 12);
    if ( (int *)(v151 - 12) != &dword_2FEF3C )
    {
      v105 = (unsigned int *)(v151 - 4);
      __dmb(0xFu);
      do
        v106 = __ldrex(v105);
      while ( __strex(v106 - 1, v105) );
      __dmb(0xFu);
      if ( v106 <= 0 )
        operator delete(v40);
    }
    if ( *((_DWORD *)nptr - 3) )
      dword_F30B0 = atoi(nptr);
    v41 = Json::Value::operator[]((Json::Value *)&v161, "rtt_s");
    Json::Value::asString((Json::Value *)&v152, (int)v41, v42);
    sub_C1700(&nptr, &v152);
    v43 = (void *)(v152 - 12);
    if ( (int *)(v152 - 12) != &dword_2FEF3C )
    {
      v135 = (unsigned int *)(v152 - 4);
      __dmb(0xFu);
      do
        v136 = __ldrex(v135);
      while ( __strex(v136 - 1, v135) );
      __dmb(0xFu);
      if ( v136 <= 0 )
        operator delete(v43);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v87 = strtod(nptr, 0);
      unk_F30B4 = LODWORD(v87);
    }
    v44 = Json::Value::operator[]((Json::Value *)&v161, "rtt_r");
    Json::Value::asString((Json::Value *)&v153, (int)v44, v45);
    sub_C1700(&nptr, &v153);
    v46 = (void *)(v153 - 12);
    if ( (int *)(v153 - 12) != &dword_2FEF3C )
    {
      v133 = (unsigned int *)(v153 - 4);
      __dmb(0xFu);
      do
        v134 = __ldrex(v133);
      while ( __strex(v134 - 1, v133) );
      __dmb(0xFu);
      if ( v134 <= 0 )
        operator delete(v46);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v88 = strtod(nptr, 0);
      unk_F30B8 = LODWORD(v88);
    }
    v47 = Json::Value::operator[]((Json::Value *)&v161, "cdn_ration");
    Json::Value::asString((Json::Value *)&v154, (int)v47, v48);
    sub_C1700(&nptr, &v154);
    v49 = (void *)(v154 - 12);
    if ( (int *)(v154 - 12) != &dword_2FEF3C )
    {
      v131 = (unsigned int *)(v154 - 4);
      __dmb(0xFu);
      do
        v132 = __ldrex(v131);
      while ( __strex(v132 - 1, v131) );
      __dmb(0xFu);
      if ( v132 <= 0 )
        operator delete(v49);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      v89 = strtod(nptr, 0);
      CDN_RATION = (signed int)(float)(v89 * 100.0);
    }
    v50 = Json::Value::operator[]((Json::Value *)&v161, "httpxstun");
    Json::Value::asString((Json::Value *)&v155, (int)v50, v51);
    sub_C1700(&nptr, &v155);
    v52 = (void *)(v155 - 12);
    if ( (int *)(v155 - 12) != &dword_2FEF3C )
    {
      v137 = (unsigned int *)(v155 - 4);
      __dmb(0xFu);
      do
        v138 = __ldrex(v137);
      while ( __strex(v138 - 1, v137) );
      __dmb(0xFu);
      if ( v138 <= 0 )
        operator delete(v52);
    }
    if ( !*((_DWORD *)nptr - 3) )
      goto LABEL_193;
    memset(&s, 0, 0x400u);
    strcpy(&s, nptr);
    v90 = strstr(&s, "http://");
    v92 = v90 == 0;
    if ( v90 )
      v91 = &v185;
    else
      v90 = &s;
    if ( !v92 )
      v90 = v91 + 3;
    v93 = (unsigned __int8)*v90;
    v94 = v93 == 0;
    if ( *v90 )
      v94 = v93 == 58;
    if ( v94 )
    {
      v96 = v90;
    }
    else
    {
      v95 = v90 + 1;
      do
      {
        v96 = v95;
        v97 = (unsigned __int8)*v95++;
        v93 = v97;
        v98 = v97 == 0;
        if ( v97 )
          v98 = v93 == 58;
      }
      while ( !v98 );
    }
    if ( v93 )
    {
      *v96 = 0;
      v53 = strdup(v90);
      *((_DWORD *)v3 + 3) = v53;
      *((_DWORD *)v3 + 4) = strdup(v96 + 1);
    }
    else
    {
LABEL_193:
      v53 = (char *)*((_DWORD *)v3 + 3);
    }
    if ( !v53 || !*((_DWORD *)v3 + 4) )
    {
      *((_DWORD *)v3 + 3) = strdup("50.115.126.85");
      *((_DWORD *)v3 + 4) = strdup("20000");
    }
    v54 = Json::Value::operator[]((Json::Value *)&v161, "backhttpxstun");
    v13 = &v159;
    Json::Value::asString((Json::Value *)&v156, (int)v54, v55);
    sub_C1700(&nptr, &v156);
    v56 = (void *)(v156 - 12);
    if ( (int *)(v156 - 12) != &dword_2FEF3C )
    {
      v139 = (unsigned int *)(v156 - 4);
      __dmb(0xFu);
      do
        v140 = __ldrex(v139);
      while ( __strex(v140 - 1, v139) );
      __dmb(0xFu);
      if ( v140 <= 0 )
        operator delete(v56);
    }
    if ( *((_DWORD *)nptr - 3) )
    {
      memset(&s, 0, 0x400u);
      strcpy(&s, nptr);
      v57 = strstr(&s, "http://");
      v59 = v57 == 0;
      if ( v57 )
        v58 = &v185;
      else
        v57 = &s;
      if ( !v59 )
        v57 = v58 + 3;
      v60 = (unsigned __int8)*v57;
      v61 = v60 == 0;
      if ( *v57 )
        v61 = v60 == 58;
      if ( v61 )
      {
        v63 = v57;
      }
      else
      {
        v62 = v57 + 1;
        do
        {
          v63 = v62;
          v64 = (unsigned __int8)*v62++;
          v60 = v64;
          v65 = v64 == 0;
          if ( v64 )
            v65 = v60 == 58;
        }
        while ( !v65 );
      }
      if ( v60 )
      {
        *v63 = 0;
        *((_DWORD *)v3 + 6) = strdup(v57);
        *((_DWORD *)v3 + 7) = strdup(v63 + 1);
      }
    }
    v66 = Json::Value::operator[]((Json::Value *)&v161, "tracker");
    Json::Value::asString((Json::Value *)&v157, (int)v66, v67);
    sub_C1700(&nptr, &v157);
    v19 = v157;
    result = (char **)(v157 - 12);
    if ( (int *)(v157 - 12) != &dword_2FEF3C )
      goto LABEL_103;
    goto LABEL_68;
  }
  add_confErr();
  v9 = nptr;
  v10 = (char **)-1;
  while ( 1 )
  {
    v11 = v9 - 12;
    if ( v9 - 12 != (char *)v5 )
    {
      v111 = (unsigned int *)(v9 - 4);
      __dmb(0xFu);
      do
        v112 = __ldrex(v111);
      while ( __strex(v112 - 1, v111) );
      __dmb(0xFu);
      if ( v112 <= 0 )
        operator delete(v11);
    }
    Json::Value::~Value(v2);
    v12 = (void *)(v183 - 12);
    if ( (void **)(v183 - 12) == v5 )
    {
      v13 = (int *)&v166;
    }
    else
    {
      v109 = (unsigned int *)(v183 - 4);
      __dmb(0xFu);
      do
        v110 = __ldrex(v109);
      while ( __strex(v110 - 1, v109) );
      __dmb(0xFu);
      v13 = (int *)&v166;
      if ( v110 <= 0 )
        operator delete(v12);
    }
    v14 = (void *)(v182 - 12);
    if ( (void **)(v182 - 12) != v5 )
    {
      v121 = (unsigned int *)(v182 - 4);
      __dmb(0xFu);
      do
        v122 = __ldrex(v121);
      while ( __strex(v122 - 1, v121) );
      __dmb(0xFu);
      if ( v122 <= 0 )
        operator delete(v14);
    }
    v15 = (int *)v6;
    v6 = v176;
    v2 = v177;
    v5 = v178;
    v167 = v179;
    v168 = v180;
    v169 = v181;
    v162 = v174;
    v163 = v175;
    v164 = v176;
    v165 = v177;
    v166 = v178;
    sub_3A82C(v15, (int *)&v166);
    std::_Deque_base<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::~_Deque_base((void **)&v173);
    v16 = v170;
    if ( v170 )
    {
      v5 = (void **)v171;
      v2 = (Json::Value *)(v172 + 4);
      if ( v171 < v172 + 4 )
      {
        do
        {
          v17 = *v5;
          ++v5;
          operator delete(v17);
        }
        while ( v2 > (Json::Value *)v5 );
        v16 = v170;
      }
      operator delete(v16);
    }
    result = v10;
    v19 = _stack_chk_guard;
    if ( v186 == _stack_chk_guard )
      break;
LABEL_103:
    v99 = (unsigned int *)(v19 - 4);
    __dmb(0xFu);
    do
      v100 = __ldrex(v99);
    while ( __strex(v100 - 1, v99) );
    __dmb(0xFu);
    if ( v100 <= 0 )
      operator delete(result);
LABEL_68:
    if ( *((_DWORD *)nptr - 3) )
      *((_DWORD *)v3 + 5) = strdup(nptr);
    v68 = Json::Value::operator[](v2, "backtracker");
    Json::Value::asString((Json::Value *)(v13 - 1), (int)v68, v69);
    sub_C1700(v10, v13 - 1);
    v70 = (void *)(v158 - 12);
    if ( (void **)(v158 - 12) != v5 )
    {
      v117 = (unsigned int *)(v158 - 4);
      __dmb(0xFu);
      do
        v118 = __ldrex(v117);
      while ( __strex(v118 - 1, v117) );
      __dmb(0xFu);
      if ( v118 <= 0 )
        operator delete(v70);
    }
    if ( *((_DWORD *)nptr - 3) )
      *((_DWORD *)v3 + 8) = strdup(nptr);
    v71 = Json::Value::operator[](v2, "protect_w");
    Json::Value::asString((Json::Value *)v13, (int)v71, v72);
    sub_C1700(v10, v13);
    v73 = (void *)(v159 - 12);
    if ( (void **)(v159 - 12) != v5 )
    {
      v119 = (unsigned int *)(v159 - 4);
      __dmb(0xFu);
      do
        v120 = __ldrex(v119);
      while ( __strex(v120 - 1, v119) );
      __dmb(0xFu);
      if ( v120 <= 0 )
        operator delete(v73);
    }
    if ( *((_DWORD *)nptr - 3) )
      dword_F3098 = atoi(nptr);
    v74 = Json::Value::operator[](v2, "status_server");
    Json::Value::asString((Json::Value *)&v160, (int)v74, v75);
    sub_C1700(v10, &v160);
    v76 = (void *)(v160 - 12);
    if ( (void **)(v160 - 12) != v5 )
    {
      v141 = (unsigned int *)(v160 - 4);
      __dmb(0xFu);
      do
        v142 = __ldrex(v141);
      while ( __strex(v142 - 1, v141) );
      __dmb(0xFu);
      if ( v142 <= 0 )
        operator delete(v76);
    }
    if ( *((_DWORD *)nptr - 3) )
      resetReportUrl(nptr);
    v77 = Json::Value::operator[](v2, "cont_blk_sec");
    Json::Value::asString(v6, (int)v77, v78);
    sub_C1700(v10, v6);
    v79 = (void *)(v162 - 12);
    if ( (void **)(v162 - 12) != v5 )
    {
      v115 = (unsigned int *)(v162 - 4);
      __dmb(0xFu);
      do
        v116 = __ldrex(v115);
      while ( __strex(v116 - 1, v115) );
      __dmb(0xFu);
      if ( v116 <= 0 )
        operator delete(v79);
    }
    if ( *((_DWORD *)nptr - 3) )
      unk_F30C0 = strtod(nptr, 0);
    v80 = Json::Value::operator[](v2, "src_invalid_sec");
    Json::Value::asString((Json::Value *)&v166, (int)v80, v81);
    sub_C1700(v10, &v166);
    v82 = v166 - 3;
    if ( v166 - 3 != v5 )
    {
      v113 = (unsigned int *)(v166 - 1);
      __dmb(0xFu);
      do
        v114 = __ldrex(v113);
      while ( __strex(v114 - 1, v113) );
      __dmb(0xFu);
      if ( v114 <= 0 )
        operator delete(v82);
    }
    v9 = nptr;
    v10 = (char **)*((_DWORD *)nptr - 3);
    if ( v10 )
    {
      v83 = strtod(nptr, 0);
      v9 = nptr;
      v10 = 0;
      unk_F30C8 = *(_QWORD *)&v83;
    }
  }
  return result;
}
// F3098: using guessed type int dword_F3098;
// F30A8: using guessed type int *off_F30A8[2];
// F30AC: using guessed type int dword_F30AC;
// F30B0: using guessed type int dword_F30B0;
// F30EC: using guessed type int CDN_RATION;
// F40E0: using guessed type int dword_F40E0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0003DA48) --------------------------------------------------------
int __fastcall confLoadedCb(void *a1)
{
  M3U8Manager::parseConf((M3U8Manager *)gM3U8Manager, *((char **)a1 + 2));
  M3U8Manager::startP2P((M3U8Manager *)gM3U8Manager);
  return 0;
}
// F40F4: using guessed type int gM3U8Manager;

//----- (0003DA74) --------------------------------------------------------
void __fastcall M3U8Manager::deleteP2P(M3U8Manager *this)
{
  M3U8Manager *v1; // r5
  void *v2; // r4
  void *v3; // r4
  void *v4; // r0
  int v5; // r6
  OneData *v6; // r3
  OneData *v7; // r4
  void *v8; // r0
  int v9; // r6
  OnePacket *v10; // r0
  OnePacket *v11; // r4
  void *v12; // r0
  int v13; // r6
  OneFile *v14; // r0
  OneFile *v15; // r4
  void *v16; // r0
  int v17; // r6
  OneRequest *v18; // r0
  OneRequest *v19; // r4
  void *v20; // r0

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 33);
  if ( v2 )
  {
    P2PClient::~P2PClient(*((P2PClient **)this + 33));
    operator delete(v2);
    *((_DWORD *)v1 + 33) = 0;
  }
  M3U8Manager::destroyLocalSocket(v1);
  v3 = (void *)*((_DWORD *)v1 + 34);
  if ( v3 )
  {
    LocalMemory::~LocalMemory(*((LocalMemory **)v1 + 34));
    operator delete(v3);
    *((_DWORD *)v1 + 34) = 0;
  }
  v4 = (void *)*((_DWORD *)v1 + 27);
  if ( v4 )
  {
    free(v4);
    *((_DWORD *)v1 + 27) = 0;
  }
  v5 = *((_DWORD *)v1 + 32);
  if ( v5 )
  {
    v6 = *(OneData **)(v5 + 4);
    if ( v6 )
    {
      v7 = (OneData *)((char *)v6 + 20 * *((_DWORD *)v6 - 1));
      while ( v7 != v6 )
      {
        v7 = (OneData *)((char *)v7 - 20);
        OneData::~OneData(v7);
        v6 = *(OneData **)(v5 + 4);
      }
      operator delete[]((char *)v7 - 8);
    }
    v8 = *(void **)(v5 + 8);
    if ( v8 )
      operator delete[](v8);
    pthread_mutex_destroy((pthread_mutex_t *)(v5 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v5 + 12));
    operator delete((void *)v5);
    *((_DWORD *)v1 + 32) = 0;
  }
  v9 = *((_DWORD *)v1 + 31);
  if ( v9 )
  {
    v10 = *(OnePacket **)(v9 + 4);
    if ( v10 )
    {
      v11 = (OnePacket *)((char *)v10 + 1256 * *((_DWORD *)v10 - 1));
      while ( v10 != v11 )
      {
        v11 = (OnePacket *)((char *)v11 - 1256);
        OnePacket::~OnePacket(v11);
        v10 = *(OnePacket **)(v9 + 4);
      }
      operator delete[]((char *)v10 - 8);
    }
    v12 = *(void **)(v9 + 8);
    if ( v12 )
      operator delete[](v12);
    pthread_mutex_destroy((pthread_mutex_t *)(v9 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v9 + 12));
    operator delete((void *)v9);
    *((_DWORD *)v1 + 31) = 0;
  }
  v13 = *((_DWORD *)v1 + 30);
  if ( v13 )
  {
    v14 = *(OneFile **)(v13 + 4);
    if ( v14 )
    {
      v15 = (OneFile *)((char *)v14 + 28 * *((_DWORD *)v14 - 1));
      while ( v14 != v15 )
      {
        v15 = (OneFile *)((char *)v15 - 28);
        OneFile::~OneFile(v15);
        v14 = *(OneFile **)(v13 + 4);
      }
      operator delete[]((char *)v14 - 8);
    }
    v16 = *(void **)(v13 + 8);
    if ( v16 )
      operator delete[](v16);
    pthread_mutex_destroy((pthread_mutex_t *)(v13 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v13 + 12));
    operator delete((void *)v13);
    *((_DWORD *)v1 + 30) = 0;
  }
  v17 = *((_DWORD *)v1 + 29);
  if ( v17 )
  {
    v18 = *(OneRequest **)(v17 + 4);
    if ( v18 )
    {
      v19 = (OneRequest *)((char *)v18 + 6856 * *((_DWORD *)v18 - 1));
      while ( v18 != v19 )
      {
        v19 = (OneRequest *)((char *)v19 - 6856);
        OneRequest::~OneRequest(v19);
        v18 = *(OneRequest **)(v17 + 4);
      }
      operator delete[]((char *)v18 - 8);
    }
    v20 = *(void **)(v17 + 8);
    if ( v20 )
      operator delete[](v20);
    pthread_mutex_destroy((pthread_mutex_t *)(v17 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v17 + 12));
    operator delete((void *)v17);
    *((_DWORD *)v1 + 29) = 0;
  }
}

//----- (0003DD18) --------------------------------------------------------
int __fastcall M3U8Manager::freeM3U8Manager(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  signed int v2; // r0
  pthread_t v3; // r0
  pthread_t v4; // r0
  void *v5; // r5
  void *v6; // r5
  int v7; // r0
  void *v8; // r5
  int v9; // r0
  void *v10; // r5
  void *v11; // r5
  void *v12; // r0
  void *v13; // r0
  void *v14; // r0
  void *v15; // r0
  void *v16; // r0
  void *v17; // r0

  v1 = this;
  v2 = *((_DWORD *)this + 47);
  *((_DWORD *)v1 + 1) = -1;
  if ( v2 > 0 )
  {
    pthread_join(v2, 0);
    *((_DWORD *)v1 + 47) = 0;
  }
  v3 = *((_DWORD *)v1 + 48);
  if ( v3 )
  {
    pthread_join(v3, 0);
    *((_DWORD *)v1 + 48) = 0;
  }
  v4 = *((_DWORD *)v1 + 12);
  if ( v4 )
    pthread_join(v4, 0);
  v5 = (void *)*((_DWORD *)v1 + 39);
  if ( v5 )
  {
    FifoDataManager::~FifoDataManager(*((FifoDataManager **)v1 + 39));
    operator delete(v5);
    *((_DWORD *)v1 + 39) = 0;
  }
  v6 = (void *)*((_DWORD *)v1 + 45);
  if ( v6 )
  {
    TsPieceDownload::~TsPieceDownload(*((TsPieceDownload **)v1 + 45));
    operator delete(v6);
    *((_DWORD *)v1 + 45) = 0;
  }
  v7 = *((_DWORD *)v1 + 43);
  if ( v7 )
  {
    (*(void (**)(void))(*(_DWORD *)v7 + 4))();
    *((_DWORD *)v1 + 43) = 0;
  }
  v8 = (void *)*((_DWORD *)v1 + 42);
  if ( v8 )
  {
    CurlWrapper::~CurlWrapper(*((CurlWrapper **)v1 + 42));
    operator delete(v8);
    *((_DWORD *)v1 + 42) = 0;
  }
  v9 = *((_DWORD *)v1 + 44);
  if ( v9 )
  {
    (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    *((_DWORD *)v1 + 44) = 0;
  }
  M3U8Manager::deleteP2P(v1);
  v10 = (void *)*((_DWORD *)v1 + 13);
  if ( v10 )
  {
    StunClient::~StunClient(*((StunClient **)v1 + 13));
    operator delete(v10);
    *((_DWORD *)v1 + 13) = 0;
  }
  v11 = (void *)*((_DWORD *)v1 + 16);
  if ( v11 )
  {
    TrackerClient::~TrackerClient(*((TrackerClient **)v1 + 16));
    operator delete(v11);
    *((_DWORD *)v1 + 16) = 0;
  }
  v12 = (void *)*((_DWORD *)v1 + 54);
  if ( v12 )
  {
    operator delete(v12);
    *((_DWORD *)v1 + 54) = 0;
  }
  v13 = (void *)*((_DWORD *)v1 + 49);
  if ( v13 )
  {
    free(v13);
    *((_DWORD *)v1 + 49) = 0;
  }
  v14 = (void *)*((_DWORD *)v1 + 9);
  if ( v14 )
  {
    free(v14);
    *((_DWORD *)v1 + 9) = 0;
  }
  v15 = (void *)*((_DWORD *)v1 + 10);
  if ( v15 )
  {
    free(v15);
    *((_DWORD *)v1 + 10) = 0;
  }
  v16 = (void *)*((_DWORD *)v1 + 131);
  if ( v16 )
  {
    free(v16);
    *((_DWORD *)v1 + 131) = 0;
  }
  v17 = (void *)*((_DWORD *)v1 + 50);
  if ( 133956095 * ((*((_DWORD *)v1 + 51) - (signed int)v17) >> 2) )
  {
    *((_DWORD *)v1 + 50) = 0;
    *((_DWORD *)v1 + 51) = 0;
    *((_DWORD *)v1 + 52) = 0;
    if ( v17 )
      operator delete(v17);
  }
  return pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 184));
}

//----- (0003DF38) --------------------------------------------------------
M3U8Manager *__fastcall M3U8Manager::~M3U8Manager(M3U8Manager *this)
{
  M3U8Manager *v1; // r4
  void *v2; // r0

  v1 = this;
  M3U8Manager::freeM3U8Manager(this);
  v2 = (void *)*((_DWORD *)v1 + 50);
  if ( v2 )
    operator delete(v2);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 152));
  std::_Deque_base<FILEINFO *,std::allocator<FILEINFO *>>::~_Deque_base((void **)v1 + 17);
  return v1;
}

//----- (0003DF94) --------------------------------------------------------
int __fastcall M3U8Manager::M3U8ManagerRoutine(M3U8Manager *this, volatile int *a2)
{
  char *v2; // r6
  M3U8Manager *v3; // r4
  LibEventTaskScheduler *v4; // r0
  int v5; // r7
  const void *v6; // r1
  int v7; // r12
  unsigned int v8; // r12
  size_t v9; // r8
  int v10; // r9
  char *v11; // r3
  CurlWrapper *v12; // r1
  const char *v13; // r0
  void *v14; // r7
  char *v16; // r0
  void *v17; // [sp+1Ch] [bp-2Ch]
  char *v18; // [sp+20h] [bp-28h]
  char *v19; // [sp+24h] [bp-24h]

  v2 = (char *)this + 4;
  v3 = this;
  v4 = LibEventTaskScheduler::createNew((M3U8Manager *)((char *)this + 4), a2);
  *((_DWORD *)v3 + 44) = v4;
  if ( v4 )
  {
    v5 = (int)v4;
  }
  else
  {
    M3U8Manager::freeM3U8Manager(v3);
    v5 = *((_DWORD *)v3 + 44);
  }
  v6 = (const void *)*((_DWORD *)v3 + 50);
  v7 = *((_DWORD *)v3 + 51);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v8 = -133956095 * ((v7 - (signed int)v6) >> 2);
  if ( v8 )
  {
    if ( v8 > 0x1FF007 )
      sub_BFA08();
    v10 = 2052 * v8;
    v16 = (char *)operator new(2052 * v8);
    v6 = (const void *)*((_DWORD *)v3 + 50);
    v8 = -133956095 * ((*((_DWORD *)v3 + 51) - (signed int)v6) >> 2);
    v9 = 4 * ((*((_DWORD *)v3 + 51) - (signed int)v6) >> 2);
    v11 = v16;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
  }
  v17 = v11;
  v19 = &v11[v10];
  v18 = v11;
  if ( v8 )
    v11 = (char *)memmove(v11, v6, v9);
  v18 = &v11[v9];
  v12 = CurlWrapper::createNew(v5, (int)&v17);
  *((_DWORD *)v3 + 42) = v12;
  if ( v17 )
  {
    operator delete(v17);
    v12 = (CurlWrapper *)*((_DWORD *)v3 + 42);
  }
  if ( !v12 )
  {
    M3U8Manager::freeM3U8Manager(v3);
    v12 = (CurlWrapper *)*((_DWORD *)v3 + 42);
  }
  v13 = M3U8Protocol::createNew(
          *((_DWORD *)v3 + 44),
          (int)v12,
          *((const char **)v3 + 49),
          *((_DWORD *)v3 + 53),
          (int)cbInsertTsItem);
  *((_DWORD *)v3 + 43) = v13;
  if ( !v13 )
    M3U8Manager::freeM3U8Manager(v3);
  v14 = operator new(0x274u);
  TsPieceDownload::TsPieceDownload(
    (int)v14,
    *((_DWORD *)v3 + 53),
    *((_DWORD *)v3 + 43),
    *((_DWORD *)v3 + 42),
    (int)v2,
    (int)notifyM3u8HttpFileFinished,
    *((_DWORD *)v3 + 39),
    *((_DWORD *)v3 + 44),
    (int)getWindowEndPieceId,
    (int)v3);
  *((_DWORD *)v3 + 45) = v14;
  pthread_create((pthread_t *)v3 + 48, 0, (void *(*)(void *))generateM3u8Process, (void *)v3);
  M3U8Manager::loadConf(v3, "http://liveconf.kukuplay.com:6060/FrontEndConfServer/Conf", *((char **)v3 + 11));
  return (*(int (**)(void))(**((_DWORD **)v3 + 44) + 28))();
}

//----- (0003E1D8) --------------------------------------------------------
int __fastcall ThreadProcess(void *a1, volatile int *a2)
{
  M3U8Manager::M3U8ManagerRoutine((M3U8Manager *)a1, a2);
  return 0;
}

//----- (0003E1E8) --------------------------------------------------------
int __fastcall M3U8Manager::initP2P(M3U8Manager *this)
{
  int *v1; // r8
  char *v2; // r5
  _DWORD *v3; // r0
  int v4; // r7
  signed int v5; // r6
  OneRequest *v6; // r4
  _BYTE *v7; // r0
  int v8; // r6
  _DWORD *v9; // r3
  int v10; // r2
  int v11; // r7
  _DWORD *v12; // r3
  int v13; // r3
  int v14; // r3
  _DWORD *v15; // r0
  _DWORD *v16; // r4
  _DWORD *v17; // r0
  int v18; // r11
  signed int v19; // r5
  OneFile *v20; // r6
  _BYTE *v21; // r0
  int v22; // r5
  _DWORD *v23; // r3
  int v24; // r2
  int v25; // r7
  _DWORD *v26; // r3
  int v27; // r3
  int v28; // r3
  _DWORD *v29; // r0
  _DWORD *v30; // r5
  _DWORD *v31; // r0
  int v32; // r11
  signed int v33; // r6
  OnePacket *v34; // r4
  _BYTE *v35; // r0
  int v36; // r4
  _DWORD *v37; // r3
  int v38; // r2
  int v39; // r7
  _DWORD *v40; // r3
  int v41; // r3
  int v42; // r3
  _DWORD *v43; // r0
  _DWORD *v44; // r4
  _DWORD *v45; // r0
  int v46; // r9
  signed int v47; // r5
  int v48; // r6
  _BYTE *v49; // r0
  int v50; // r5
  _DWORD *v51; // r3
  int v52; // r2
  int v53; // r7
  _DWORD *v54; // r3
  int v55; // r3
  int v56; // r3
  void *v57; // r0
  _DWORD *v58; // r4
  void *v59; // r4
  int result; // r0
  pthread_mutex_t *v61; // [sp+24h] [bp-5Ch]
  int v62; // [sp+30h] [bp-50h]
  int v63; // [sp+34h] [bp-4Ch]
  int v64; // [sp+38h] [bp-48h]
  int v65; // [sp+3Ch] [bp-44h]
  int v66; // [sp+40h] [bp-40h]
  int v67; // [sp+44h] [bp-3Ch]
  int v68; // [sp+48h] [bp-38h]
  int v69; // [sp+4Ch] [bp-34h]
  int v70; // [sp+50h] [bp-30h]
  int v71; // [sp+54h] [bp-2Ch]

  v1 = (int *)this;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 112), 0);
  v2 = (char *)operator new(0x38u);
  *(_DWORD *)v2 = 400;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v62, 0);
  std::deque<long,std::allocator<long>>::deque((_DWORD *)v2 + 3, &v62);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v62);
  pthread_mutex_init((pthread_mutex_t *)(v2 + 52), 0);
  v3 = operator new[](0x29D888u);
  v4 = (int)(v3 + 685602);
  v5 = 399;
  v61 = (pthread_mutex_t *)(v3 + 2);
  v6 = (OneRequest *)(v3 + 2);
  *v3 = 6856;
  v3[1] = 400;
  do
  {
    OneRequest::OneRequest(v6);
    --v5;
    v6 = (OneRequest *)((char *)v6 + 6856);
  }
  while ( v6 != (OneRequest *)v4 );
  *((_DWORD *)v2 + 1) = v61;
  v7 = operator new[](0x190u);
  *((_DWORD *)v2 + 2) = v7;
  v8 = 0;
  while ( 1 )
  {
    v9 = (_DWORD *)*((_DWORD *)v2 + 9);
    v10 = *((_DWORD *)v2 + 11) - 4;
    v7[v8] = 1;
    if ( v9 != (_DWORD *)v10 )
      break;
    v11 = *((_DWORD *)v2 + 12);
    if ( (unsigned int)(*((_DWORD *)v2 + 4) - ((v11 - *((_DWORD *)v2 + 3)) >> 2)) <= 1 )
    {
      std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v2 + 3, 1u, 0);
      v11 = *((_DWORD *)v2 + 12);
    }
    *(_DWORD *)(v11 + 4) = operator new(0x200u);
    v12 = (_DWORD *)*((_DWORD *)v2 + 9);
    if ( v12 )
      *v12 = v8;
    ++v8;
    v13 = *((_DWORD *)v2 + 12);
    *((_DWORD *)v2 + 12) = v13 + 4;
    v14 = *(_DWORD *)(v13 + 4);
    *((_DWORD *)v2 + 11) = v14 + 512;
    *((_DWORD *)v2 + 10) = v14;
    *((_DWORD *)v2 + 9) = v14;
    if ( v8 == 400 )
      goto LABEL_14;
LABEL_7:
    v7 = (_BYTE *)*((_DWORD *)v2 + 2);
  }
  if ( v9 )
    *v9 = v8;
  ++v8;
  *((_DWORD *)v2 + 9) = v9 + 1;
  if ( v8 != 400 )
    goto LABEL_7;
LABEL_14:
  v1[29] = (int)v2;
  v15 = operator new(0x38u);
  *v15 = v8;
  v16 = v15;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v62, 0);
  std::deque<long,std::allocator<long>>::deque(v16 + 3, &v62);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v62);
  pthread_mutex_init((pthread_mutex_t *)(v16 + 13), 0);
  v17 = operator new[](0x2BC8u);
  v18 = (int)(v17 + 2);
  v19 = 399;
  v20 = (OneFile *)(v17 + 2);
  *v17 = 28;
  v17[1] = 400;
  do
  {
    OneFile::OneFile(v20);
    --v19;
    v20 = (OneFile *)((char *)v20 + 28);
  }
  while ( v19 != -1 );
  v16[1] = v18;
  v21 = operator new[](0x190u);
  v16[2] = v21;
  v22 = 0;
  while ( 2 )
  {
    v23 = (_DWORD *)v16[9];
    v24 = v16[11] - 4;
    v21[v22] = 1;
    if ( v23 == (_DWORD *)v24 )
    {
      v25 = v16[12];
      if ( (unsigned int)(v16[4] - ((v25 - v16[3]) >> 2)) <= 1 )
      {
        std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v16 + 3, 1u, 0);
        v25 = v16[12];
      }
      *(_DWORD *)(v25 + 4) = operator new(0x200u);
      v26 = (_DWORD *)v16[9];
      if ( v26 )
        *v26 = v22;
      ++v22;
      v27 = v16[12];
      v16[12] = v27 + 4;
      v28 = *(_DWORD *)(v27 + 4);
      v16[11] = v28 + 512;
      v16[10] = v28;
      v16[9] = v28;
      if ( v22 == 400 )
        break;
      goto LABEL_20;
    }
    if ( v23 )
      *v23 = v22;
    ++v22;
    v16[9] = v23 + 1;
    if ( v22 != 400 )
    {
LABEL_20:
      v21 = (_BYTE *)v16[2];
      continue;
    }
    break;
  }
  v1[30] = (int)v16;
  v29 = operator new(0x38u);
  *v29 = 8000;
  v30 = v29;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v62, 0);
  std::deque<long,std::allocator<long>>::deque(v30 + 3, &v62);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v62);
  pthread_mutex_init((pthread_mutex_t *)(v30 + 13), 0);
  v31 = operator new[](0x995208u);
  v32 = (int)(v31 + 2);
  v33 = 7999;
  v34 = (OnePacket *)(v31 + 2);
  *v31 = 1256;
  v31[1] = 8000;
  do
  {
    OnePacket::OnePacket(v34);
    --v33;
    v34 = (OnePacket *)((char *)v34 + 1256);
  }
  while ( v33 != -1 );
  v30[1] = v32;
  v35 = operator new[](0x1F40u);
  v30[2] = v35;
  v36 = 0;
  while ( 2 )
  {
    v37 = (_DWORD *)v30[9];
    v38 = v30[11] - 4;
    v35[v36] = 1;
    if ( v37 == (_DWORD *)v38 )
    {
      v39 = v30[12];
      if ( (unsigned int)(v30[4] - ((v39 - v30[3]) >> 2)) <= 1 )
      {
        std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v30 + 3, 1u, 0);
        v39 = v30[12];
      }
      *(_DWORD *)(v39 + 4) = operator new(0x200u);
      v40 = (_DWORD *)v30[9];
      if ( v40 )
        *v40 = v36;
      ++v36;
      v41 = v30[12];
      v30[12] = v41 + 4;
      v42 = *(_DWORD *)(v41 + 4);
      v30[11] = v42 + 512;
      v30[10] = v42;
      v30[9] = v42;
      if ( v36 == 8000 )
        break;
      goto LABEL_33;
    }
    if ( v37 )
      *v37 = v36;
    ++v36;
    v30[9] = v37 + 1;
    if ( v36 != 8000 )
    {
LABEL_33:
      v35 = (_BYTE *)v30[2];
      continue;
    }
    break;
  }
  v1[31] = (int)v30;
  v43 = operator new(0x38u);
  *v43 = 400;
  v44 = v43;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v62, 0);
  std::deque<long,std::allocator<long>>::deque(v44 + 3, &v62);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v62);
  pthread_mutex_init((pthread_mutex_t *)(v44 + 13), 0);
  v45 = operator new[](0x1F48u);
  v46 = (int)(v45 + 2);
  v47 = 399;
  v48 = (int)(v45 + 2);
  *v45 = 20;
  v45[1] = 400;
  do
  {
    OneData::OneData(v48);
    --v47;
    v48 += 20;
  }
  while ( v47 != -1 );
  v44[1] = v46;
  v49 = operator new[](0x190u);
  v44[2] = v49;
  v50 = 0;
  while ( 2 )
  {
    v51 = (_DWORD *)v44[9];
    v52 = v44[11] - 4;
    v49[v50] = 1;
    if ( v51 == (_DWORD *)v52 )
    {
      if ( (unsigned int)(v44[4] - ((v44[12] - v44[3]) >> 2)) <= 1 )
        std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v44 + 3, 1u, 0);
      v53 = v44[12];
      *(_DWORD *)(v53 + 4) = operator new(0x200u);
      v54 = (_DWORD *)v44[9];
      if ( v54 )
        *v54 = v50;
      ++v50;
      v55 = v44[12];
      v44[12] = v55 + 4;
      v56 = *(_DWORD *)(v55 + 4);
      v44[11] = v56 + 512;
      v44[10] = v56;
      v44[9] = v56;
      if ( v50 == 400 )
        break;
      goto LABEL_46;
    }
    if ( v51 )
      *v51 = v50;
    ++v50;
    v44[9] = v51 + 1;
    if ( v50 != 400 )
    {
LABEL_46:
      v49 = (_BYTE *)v44[2];
      continue;
    }
    break;
  }
  v1[32] = (int)v44;
  v57 = malloc(0xA0u);
  v1[27] = (int)v57;
  memset(v57, 0, 0xA0u);
  v58 = operator new(0x6Cu);
  LocalMemory::LocalMemory(
    v58,
    v1[30],
    v1[31],
    (int)(v1 + 17),
    (int)notifyM3u8RefreshBitmap,
    (int)notifyM3u8ToHttpDownload,
    v1[32]);
  v1[34] = (int)v58;
  gTSLocalMemory = (int)v58;
  v59 = operator new(0x2B28u);
  result = P2PClient::P2PClient(
             (int)v59,
             v1[44],
             v1[29],
             v1[30],
             v1[31],
             (int)notifyM3u8OneFile,
             (int)notifyM3u8ToHttpDownload,
             v1[34],
             v1[27],
             (int)(v1 + 17),
             (int)notifyM3u8RequestPeer,
             v1[14]);
  v1[33] = (int)v59;
  gTSP2PClient = (int)v59;
  return result;
}
// F40EC: using guessed type int gTSLocalMemory;
// F40F0: using guessed type int gTSP2PClient;

//----- (0003EB10) --------------------------------------------------------
int __fastcall generateM3u8Process(void *a1)
{
  int v1; // t1
  M3U8Manager *v2; // r4

  v1 = *((_DWORD *)a1 + 1);
  v2 = (M3U8Manager *)a1;
  if ( !*((_DWORD *)a1 + 1) )
  {
    M3U8Manager::createFifoProcess((M3U8Manager *)a1);
    M3U8Manager::initP2P(v2);
    M3U8Manager::initWindow(v2);
    M3U8Manager::generateUrl((int)v2);
    M3U8Manager::checkDownload(v2);
  }
  return 0;
}

//----- (0003EB54) --------------------------------------------------------
int __fastcall setMultithreadingDownload(int result)
{
  *(_BYTE *)(result + 8) = 1;
  return result;
}

//----- (0003EB60) --------------------------------------------------------
int __fastcall TsPieceDownload::lockTsList(TsPieceDownload *this)
{
  return pthread_mutex_lock((pthread_mutex_t *)((char *)this + 52));
}

//----- (0003EB68) --------------------------------------------------------
int __fastcall TsPieceDownload::unlockTsList(TsPieceDownload *this)
{
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 52));
}

//----- (0003EB70) --------------------------------------------------------
int __fastcall TsPieceDownload::eraseDownloadMission(TsPieceDownload *this, int a2)
{
  TsPieceDownload *v2; // r5
  int v3; // r4
  LinkManager *v4; // r0
  _DWORD *v5; // r1

  v2 = this;
  v3 = a2;
  LinkManager::lockTheLink(*((LinkManager **)this + 16));
  v4 = (LinkManager *)*((_DWORD *)v2 + 16);
  v5 = *(_DWORD **)(*(_DWORD *)v4 + 16);
  if ( !v5 )
    return LinkManager::unlockTheLink(v4);
  while ( *v5 != v3 )
  {
    v5 = (_DWORD *)v5[4];
    if ( !v5 )
      return LinkManager::unlockTheLink(v4);
  }
  LinkManager::deleteElement((int *)v4, (int)v5);
  return LinkManager::unlockTheLink(*((LinkManager **)v2 + 16));
}

//----- (0003EBD8) --------------------------------------------------------
signed int __fastcall TsPieceDownload::downloadPieceDataWithDataUnit(int a1, _DWORD *a2)
{
  int v2; // r6
  _DWORD *v3; // r5
  LinkManager *v4; // r0
  int v5; // r2
  int *v6; // r0
  int i; // r1
  _DWORD *v8; // r3
  signed int result; // r0

  v2 = a1;
  v3 = a2;
  if ( *a2 < *(_DWORD *)(a1 + 24) )
  {
    LinkManager::destroyElement(a2, (int)a2, *a2);
    result = 0;
  }
  else
  {
    v4 = *(LinkManager **)(a1 + 64);
    a2[4] = 0;
    LinkManager::lockTheLink(v4);
    v6 = *(int **)(v2 + 64);
    for ( i = *v6; ; i = *(_DWORD *)(i + 16) )
    {
      v8 = *(_DWORD **)(i + 16);
      if ( !v8 )
        break;
      if ( *v8 == *v3 )
      {
        LinkManager::destroyElement(v3, i, v5);
        LinkManager::unlockTheLink(*(LinkManager **)(v2 + 64));
        return 1;
      }
      if ( *v8 > *v3 )
        break;
    }
    LinkManager::insertElement((int)v6, i, (int)v3);
    LinkManager::unlockTheLink(*(LinkManager **)(v2 + 64));
    if ( (unsigned int)(*v3 - *(_DWORD *)(v2 + 24)) > 4 )
    {
      (*(void (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v2 + 88) + 8))(
        *(_DWORD *)(v2 + 88),
        *(_DWORD *)(**(_DWORD **)(v2 + 88) + 8));
      result = 1;
    }
    else
    {
      result = *(unsigned __int8 *)(v2 + 8);
      if ( !*(_BYTE *)(v2 + 8) )
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v2 + 88) + 8))(
          *(_DWORD *)(v2 + 88),
          *(_DWORD *)(**(_DWORD **)(v2 + 88) + 8));
        result = 1;
      }
    }
  }
  return result;
}

//----- (0003ED10) --------------------------------------------------------
signed int __fastcall TsPieceDownload::downloadPieceDataWithPieceid(TsPieceDownload *this, int a2)
{
  int v2; // r5
  TsPieceDownload *v3; // r4
  _DWORD *v4; // r0

  v2 = a2;
  v3 = this;
  v4 = LinkManager::initElement(this);
  *v4 = v2;
  return TsPieceDownload::downloadPieceDataWithDataUnit((int)v3, v4);
}

//----- (0003ED34) --------------------------------------------------------
void __fastcall TsPieceDownload::checkDataStateWithTsRangeInfo(LinkManager *a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  int v3; // r3
  LinkManager *v4; // r11
  void **v5; // r6
  void *v6; // r0
  size_t v7; // r3
  void *v8; // lr
  const void *v9; // r1
  int v10; // r8
  signed int v11; // r7
  char *v12; // r4
  int v13; // t1
  int v14; // r6
  int v15; // r10
  int v16; // r8
  int v17; // r0
  int v18; // r10
  int v19; // r8
  void *v20; // r9
  __int64 v21; // r6
  __int64 v22; // r0
  signed __int64 v23; // r2
  unsigned __int64 v24; // r2
  size_t v25; // lr
  int v26; // r12
  __int64 v27; // r0
  int v28; // r1
  __int64 v29; // r0
  void **v30; // r8
  void *v31; // r0
  int v32; // r1
  __int64 v33; // r6
  size_t v34; // r2
  int v35; // lr
  int v36; // r3
  int v37; // r1
  signed int v38; // r3
  int v39; // r2
  int v40; // r3
  int v41; // r3
  __int64 v42; // [sp+20h] [bp-138h]
  _DWORD *v43; // [sp+28h] [bp-130h]
  __int64 v44; // [sp+28h] [bp-130h]
  char v45; // [sp+38h] [bp-120h]
  char v46; // [sp+3Ah] [bp-11Eh]
  char v47; // [sp+3Bh] [bp-11Dh]
  char v48; // [sp+3Ch] [bp-11Ch]
  char v49; // [sp+4Bh] [bp-10Dh]
  int v50; // [sp+4Ch] [bp-10Ch]
  int v51; // [sp+50h] [bp-108h]
  int v52; // [sp+54h] [bp-104h]
  int v53; // [sp+58h] [bp-100h]
  int v54; // [sp+5Ch] [bp-FCh]
  int v55; // [sp+60h] [bp-F8h]
  int v56; // [sp+64h] [bp-F4h]
  int v57; // [sp+68h] [bp-F0h]
  char v58; // [sp+6Ch] [bp-ECh]
  unsigned int v59[22]; // [sp+70h] [bp-E8h]
  char s; // [sp+C8h] [bp-90h]

  v2 = a2;
  v3 = a2[394];
  v4 = a1;
  if ( v3 == 2 )
    goto LABEL_16;
  if ( v3 != 3 )
  {
    if ( v3 == 1 && a2[399] == a2[396] )
    {
      v5 = (void **)LinkManager::initElement(a1);
      v6 = cumalloc(v2[396]);
      v7 = v2[396];
      v8 = (void *)v2[390];
      v9 = (const void *)v2[400];
      v5[1] = 0;
      *v5 = v8;
      v5[2] = (void *)v7;
      v5[3] = v6;
      memcpy(v6, v9, v7);
      (*((void (__fastcall **)(void **, signed int))v4 + 11))(v5, 2);
      LinkManager::deepDestroyElement(v5);
    }
    return;
  }
  v10 = a2[433];
  if ( v10 )
  {
LABEL_33:
    if ( v10 != 1 )
      return;
    goto LABEL_16;
  }
  if ( a2[396] >= 4096 )
    v11 = 4096;
  else
    v11 = a2[396];
  if ( v11 > a2[399] )
    return;
  MD5Init(v59);
  MD5Update(v59, (char *)v2[400], v11);
  MD5Final(v59, (int)&v48);
  v43 = v2;
  v12 = &v47;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  do
  {
    v13 = (unsigned __int8)(v12++)[1];
    sprintf(&v45, "%02x", v13);
    v46 = v10;
    strcat((char *)&v50, &v45);
  }
  while ( v12 != &v49 );
  v2 = v43;
  v58 = 0;
  if ( memcmp(&v50, v43 + 401, 0x20u) )
  {
    v38 = *((_DWORD *)v4 + 27);
    v43[433] = 2;
    *((_DWORD *)v4 + 27) = v38 + 1;
    v39 = v43[395];
    if ( *((_DWORD *)v4 + 27) > 2 )
      *((_BYTE *)v4 + 104) = 1;
    v40 = v39 + v43[396] - 1;
    sprintf(&s, "%d-%d");
    CurlWrapper::stopDownload(*((CurlWrapper **)v4 + 5), (char *)v43 + 1040, &s);
    v10 = v43[433];
    goto LABEL_33;
  }
  v43[398] = 0;
  v43[433] = 1;
  *((_DWORD *)v4 + 27) = 0;
LABEL_16:
  v14 = v2[399];
  v15 = v2[390] - 1;
  v16 = v15 + v2[398] / v2[397];
  v17 = v2[399] / v2[397];
  v18 = v17 + v15;
  if ( v18 - v16 > 0 )
  {
    v19 = v16 + 1;
    v20 = LinkManager::initElement((LinkManager *)v17);
    *((_DWORD *)v20 + 3) = cumalloc(v2[397]);
    if ( v18 >= v19 )
    {
      v21 = 0LL;
      v44 = v19;
      do
      {
        v22 = *(signed int *)v4;
        v23 = *((_QWORD *)v2 + 1) + 1LL;
        v42 = v44 + v21;
        HIDWORD(v22) = v23 * HIDWORD(v22) + v22 * HIDWORD(v23);
        v24 = (unsigned int)v23 * (unsigned __int64)(unsigned int)v22;
        HIDWORD(v24) += HIDWORD(v22);
        if ( v44 + v21 < (signed __int64)(v24 - 1) )
        {
          v25 = v2[397];
          v26 = v2[400];
          v27 = v42 - *((_QWORD *)v2 + 195);
          *(_DWORD *)v20 = v19;
          *((_DWORD *)v20 + 2) = v25;
          *((_DWORD *)v20 + 1) = 0;
          memcpy(*((void **)v20 + 3), (const void *)(v26 + v25 * v27), v25);
          v28 = v2[394];
          if ( v28 == 3 )
          {
            (*((void (__fastcall **)(void *))v4 + 11))(v20);
            if ( v42 >= M3U8Manager::invertedInvalidTsPieceId(
                          (M3U8Manager *)*((_DWORD *)v4 + 156),
                          *(_DWORD *)v4,
                          *((_QWORD *)v2 + 1),
                          *(_DWORD *)v4) )
            {
              v41 = v2[395] + v2[396] - 1;
              sprintf(&s, "%d-%d");
              CurlWrapper::stopDownload(*((CurlWrapper **)v4 + 5), (char *)v2 + 1040, &s);
            }
          }
          else if ( v28 == 2 )
          {
            (*((void (__fastcall **)(void *))v4 + 11))(v20);
          }
        }
        ++v19;
        ++v21;
      }
      while ( v18 >= v19 );
    }
    LinkManager::deepDestroyElement((void **)v20);
    v14 = v2[399];
  }
  if ( v2[396] == v14 )
  {
    v29 = *(_DWORD *)v4 - 1;
    if ( *((_QWORD *)v2 + 196) % (signed __int64)*(signed int *)v4 == v29 )
    {
      v30 = (void **)LinkManager::initElement((LinkManager *)v29);
      v31 = cumalloc(*v2 + v2[397] * (1 - *(_DWORD *)v4));
      v32 = v2[397];
      v33 = *((_QWORD *)v2 + 195);
      v34 = *v2 + (1 - *(_DWORD *)v4) * v32;
      v35 = v2[400];
      v36 = *(_DWORD *)v4 + *(_DWORD *)v4 * v2[2] - 1;
      v30[1] = 0;
      *v30 = (void *)v36;
      v30[2] = (void *)v34;
      v30[3] = v31;
      memcpy(v31, (const void *)(v35 + v32 * (v36 - v33)), v34);
      v37 = v2[394];
      if ( v37 == 3 || v37 == 2 )
        (*((void (__fastcall **)(void **))v4 + 11))(v30);
      LinkManager::deepDestroyElement(v30);
    }
  }
}

//----- (0003F21C) --------------------------------------------------------
unsigned int __fastcall tsDataWrite_cb(char *src, unsigned int a2, unsigned int a3, void *a4)
{
  unsigned int v4; // r5
  _DWORD *v5; // r4
  LinkManager *v6; // r6
  int v7; // r3

  v4 = a3 * a2;
  v5 = (_DWORD *)*((_DWORD *)a4 + 2);
  v6 = (LinkManager *)v5[388];
  memcpy((void *)(v5[400] + v5[399]), src, a3 * a2);
  v7 = v5[399];
  v5[399] = v4 + v7;
  v5[398] = v7;
  TsPieceDownload::checkDataStateWithTsRangeInfo(v6, v5);
  return v4;
}

//----- (0003F268) --------------------------------------------------------
int __fastcall TsPieceDownload::getTsInfoWithPieceId(TsPieceDownload *this, int a2)
{
  TsPieceDownload *v2; // r9
  signed __int64 v3; // r6
  _DWORD *v4; // r8
  __int64 v5; // r4
  unsigned int v6; // r2
  int v7; // r1
  signed __int64 v8; // r2
  int result; // r0

  v2 = this;
  LODWORD(v3) = a2;
  TsPieceDownload::lockTsList(this);
  v4 = (_DWORD *)*((_DWORD *)v2 + 9);
  if ( (_DWORD *)((char *)v2 + 36) == v4 )
  {
LABEL_7:
    TsPieceDownload::unlockTsList(v2);
    result = 0;
  }
  else
  {
    v3 = (signed int)v3;
    v5 = *(signed int *)v2;
    while ( 1 )
    {
      v6 = v4[4];
      v7 = v5 * v4[5] + v6 * HIDWORD(v5);
      v8 = v6 * (unsigned __int64)(unsigned int)v5;
      HIDWORD(v8) += v7;
      if ( v3 >= v8 && v3 < v8 + v5 )
        break;
      v4 = (_DWORD *)*v4;
      if ( (_DWORD *)((char *)v2 + 36) == v4 )
        goto LABEL_7;
    }
    TsPieceDownload::unlockTsList(v2);
    result = (int)(v4 + 2);
  }
  return result;
}

//----- (0003F2FC) --------------------------------------------------------
signed int __fastcall TsPieceDownload::initTsRangeWithPieceId(TsPieceDownload *a1, int *a2, int *a3, int a4)
{
  int v4; // r6
  int *v5; // r8
  int *v6; // r11
  TsPieceDownload *v7; // r5
  int v8; // r1
  _DWORD *v9; // r0
  _DWORD *v10; // r7
  int v11; // r4
  int v12; // r10
  unsigned int v13; // r1
  unsigned int v14; // r0
  int v15; // r1
  int v16; // r0
  int v17; // r3
  __int64 v18; // r4
  int v19; // t1
  int v20; // r1
  size_t v21; // r0
  unsigned int v23; // r10
  unsigned int v24; // r4
  int v25; // r2
  unsigned int v26; // r1
  int v27; // r12
  unsigned int v28; // r5
  int v29; // r4
  int v30; // [sp+4h] [bp-83Ch]
  char dest; // [sp+14h] [bp-82Ch]
  int v32; // [sp+818h] [bp-28h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  v7 = a1;
  if ( !a2 )
    return 0;
  v8 = *a2;
  if ( !a3 )
    v6 = v5;
  v9 = (_DWORD *)TsPieceDownload::getTsInfoWithPieceId(a1, v8);
  v10 = v9;
  if ( !v9 )
    return 0;
  v11 = v5[1];
  if ( v11 <= 0 || (v12 = v5[2], v12 <= 0) )
  {
    v23 = *v5;
    v17 = *v6;
    if ( *v5 == *v6 )
    {
      v28 = *(_DWORD *)v7;
      *(_DWORD *)(v4 + 1576) = 1;
      v29 = v9[276];
      *(_DWORD *)(v4 + 1584) = v29;
      *(_DWORD *)(v4 + 1580) = v23 % v28 * v29;
      v17 = *v9;
      if ( !((v23 + 1) % v28) )
        *(_DWORD *)(v4 + 1584) = v17 + (1 - v28) * v29;
    }
    else
    {
      v24 = *(_DWORD *)v7;
      *(_DWORD *)(v4 + 1576) = 2;
      v25 = v9[276];
      *(_DWORD *)(v4 + 1580) = v23 % v24 * v25;
      v30 = v23 % v24 * v25;
      v26 = (v17 + 1) % v24;
      v27 = v23 % v24 * v25;
      if ( v26 )
        v23 = v17 + 1 - v23;
      else
        v17 = *v9;
      if ( v26 )
        v25 *= v23;
      else
        v27 = v17 - v30;
      if ( v26 )
        v17 = *v9;
      else
        *(_DWORD *)(v4 + 1584) = v27;
      if ( v26 )
        *(_DWORD *)(v4 + 1584) = v25;
    }
  }
  else
  {
    v13 = *(_DWORD *)v7;
    v14 = *v5;
    *(_DWORD *)(v4 + 1576) = 0;
    v15 = v14 % v13;
    v16 = v10[276];
    v17 = *v10;
    *(_DWORD *)(v4 + 1584) = v12;
    *(_DWORD *)(v4 + 1580) = v11 + v16 * v15;
  }
  v18 = *((_QWORD *)v10 + 1);
  *(_DWORD *)v4 = v17;
  *(_QWORD *)(v4 + 8) = v18;
  strcpy(&dest, (const char *)v10 + 24);
  strcat(&dest, (const char *)v10 + 536);
  *((_BYTE *)&v32 + strlen(&dest) - 2052) = 0;
  strcpy((char *)(v4 + 528), &dest);
  strcpy((char *)(v4 + 16), (const char *)v10 + 536);
  strcpy((char *)(v4 + 1040), (const char *)v10 + 584);
  v19 = v10[276];
  v20 = *v6;
  *(_DWORD *)(v4 + 1560) = *v5;
  v21 = *(_DWORD *)(v4 + 1584);
  *(_DWORD *)(v4 + 1564) = 0;
  *(_DWORD *)(v4 + 1568) = v20;
  *(_DWORD *)(v4 + 1588) = v19;
  *(_DWORD *)(v4 + 1572) = 0;
  *(_DWORD *)(v4 + 1600) = malloc(v21);
  strcpy((char *)(v4 + 1604), (const char *)v10 + 1108);
  return 1;
}

//----- (0003F528) --------------------------------------------------------
int __fastcall TsPieceDownload::cutTsWithTsInfo(int *a1, _DWORD *a2)
{
  int v2; // r6
  int v3; // r4
  int result; // r0

  v2 = *a1;
  v3 = *a2 / 1280;
  if ( *a2 > 1280 * v3 )
    ++v3;
  result = v3 / *a1;
  if ( v3 > result * v2 && v2 - 1 + result * (v2 - 1) < v3 )
    ++result;
  a2[274] = v3;
  a2[275] = result;
  a2[276] = 1280 * result;
  return result;
}

//----- (0003F598) --------------------------------------------------------
void __fastcall TsPieceDownload::insertTsItem(int a1, int a2, int a3, int a4, signed __int64 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  int *v70; // r1
  int v71; // r8
  int v72; // r9
  size_t v73; // r6
  size_t v74; // r4
  signed __int64 v75; // r2
  signed int v76; // s15
  int j; // r11
  signed __int64 v78; // r4
  int v79; // r4
  _DWORD *v80; // r0
  _DWORD *v81; // r4
  void *v82; // r0
  signed __int64 i; // r4
  _DWORD *v84; // r0
  __int64 v85; // [sp+10h] [bp-1858h]
  signed __int64 v86; // [sp+18h] [bp-1850h]
  signed __int64 v87; // [sp+28h] [bp-1840h]
  char v88[2044]; // [sp+34h] [bp-1834h]
  int v89; // [sp+834h] [bp-1034h]
  int v90; // [sp+1034h] [bp-834h]
  char v91; // [sp+103Bh] [bp-82Dh]
  int v92; // [sp+1860h] [bp-8h]
  int v93; // [sp+1864h] [bp-4h]

  v71 = a1 + 36;
  v70 = *(int **)(a1 + 36);
  v72 = a1;
  v92 = a3;
  v93 = a4;
  if ( v70 == (int *)(a1 + 36) )
  {
    v75 = a5;
  }
  else
  {
    v87 = *(_QWORD *)(*(_DWORD *)(a1 + 40) + 16);
    if ( *((_BYTE *)v70 + 592) )
    {
LABEL_30:
      strcpy((char *)&v90, (const char *)v70 + 592);
    }
    else
    {
      while ( 1 )
      {
        v70 = (int *)*v70;
        if ( (int *)v71 == v70 )
          break;
        if ( *((_BYTE *)v70 + 592) )
          goto LABEL_30;
      }
    }
    v73 = strchr((const char *)&a67 + 3, 47) - (char *)&a66 - 7;
    v74 = strchr(&v91, 47) - (char *)&v90;
    strncpy(v88, (const char *)&a67 + 3, v73);
    v74 -= 7;
    v88[v73] = 0;
    strncpy((char *)&v89, &v91, v74);
    *((_BYTE *)&v89 + v74) = 0;
    v75 = a5;
    if ( v87 < a5 - 6 )
    {
      notifyPlayerToChangeSource(5);
      return;
    }
    if ( v87 < a5 - 1 )
    {
      for ( i = v87 + 1; i < a5; ++i )
      {
        v84 = operator new(0x4E0u);
        if ( v84 != (_DWORD *)-8 )
        {
          v84[2] = 0;
          *((_QWORD *)v84 + 2) = i;
          *((_QWORD *)v84 + 3) = 0LL;
          *((_BYTE *)v84 + 32) = 0;
          *((_BYTE *)v84 + 544) = 0;
          *((_BYTE *)v84 + 592) = 0;
          v84[276] = 0;
          v84[277] = 0;
          v84[278] = 0;
          *((_BYTE *)v84 + 1116) = 0;
          *((_BYTE *)v84 + 1244) = 0;
        }
        sub_94CBC(v84, v71);
        v75 = a5;
      }
    }
  }
  v85 = a69;
  v86 = a70;
  if ( v75 - a69 >= a70 )
    a68 = 1;
  TsPieceDownload::cutTsWithTsInfo((int *)v72, &v92);
  v76 = (signed int)FifoDataManager::getWriteDataTime((FifoDataManager *)*(_DWORD *)(v72 + 100));
  TsPieceDownload::lockTsList((TsPieceDownload *)v72);
  for ( j = *(_DWORD *)(v72 + 36); j != v71; j = *(_DWORD *)j )
  {
    while ( 1 )
    {
      v78 = *(_QWORD *)(j + 16);
      if ( v78 - v85 < v86 && *(_BYTE *)(j + 1244) )
        *(_BYTE *)(j + 1244) = 0;
      if ( v78 >= v76 / *(_DWORD *)v72 )
        break;
      v79 = *(_DWORD *)j;
      sub_94CCC((int *)j);
      operator delete((void *)j);
      j = v79;
      if ( v79 == v71 )
        goto LABEL_20;
    }
  }
LABEL_20:
  v80 = operator new(0x4E0u);
  v81 = v80;
  v82 = v80 + 2;
  if ( v82 )
    memcpy(v82, &v92, 0x4D8u);
  sub_94CBC(v81, v71);
  TsPieceDownload::unlockTsList((TsPieceDownload *)v72);
  (*(void (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v72 + 88) + 8))(
    *(_DWORD *)(v72 + 88),
    *(_DWORD *)(**(_DWORD **)(v72 + 88) + 8));
  (*(void (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v72 + 88) + 8))(
    *(_DWORD *)(v72 + 88),
    *(_DWORD *)(**(_DWORD **)(v72 + 88) + 8));
}
// 3F598: too many input arguments, some ignored
// 3F598: using guessed type char var_1834[2044];

//----- (0003F944) --------------------------------------------------------
int __fastcall TsPieceDownload::getDownloadableTs(TsPieceDownload *this, int a2)
{
  TsPieceDownload *v2; // r9
  int v3; // r11
  int v4; // r0
  int v5; // r8
  __int64 v6; // r4
  int *v7; // r6
  int v8; // r7
  __int64 v9; // r2
  __int64 v10; // r10
  int v11; // r1
  __int64 v12; // r0
  __int64 v13; // r0
  unsigned int v14; // r2
  int v15; // r12
  signed __int64 v16; // r2
  int result; // r0
  int v18; // r3
  int v19; // [sp+Ch] [bp-2Ch]

  v2 = this;
  v3 = a2;
  TsPieceDownload::lockTsList(this);
  if ( (signed int)FifoDataManager::getWriteDataTime((FifoDataManager *)*((_DWORD *)v2 + 25)) <= 0 )
  {
    TsPieceDownload::unlockTsList(v2);
    result = 0;
  }
  else
  {
    v4 = (*((int (**)(void))v2 + 12))();
    v5 = *(_DWORD *)v2;
    LODWORD(v6) = v4 / *(_DWORD *)v2;
    v8 = (int)v2 + 36;
    v7 = (int *)*((_DWORD *)v2 + 9);
    if ( (v4 + 1) % *(_DWORD *)v2 )
      LODWORD(v6) = v6 - 1;
    if ( v7 == (int *)v8 || (v9 = *((_QWORD *)v7 + 2), v6 = (signed int)v6, (signed int)v6 < v9) )
    {
      TsPieceDownload::unlockTsList(v2);
      v18 = *((_DWORD *)v2 + 19);
    }
    else
    {
      v19 = 0;
      v10 = v3;
      do
      {
        if ( v9 == (signed int)v6 )
          v19 = (int)(v7 + 2);
        if ( *((_BYTE *)v7 + 1244) )
        {
          if ( v9 >= v10 )
          {
            v11 = v7[2];
            if ( v11 > 0 )
            {
              v12 = M3U8Manager::invertedInvalidTsPieceId((M3U8Manager *)*((_DWORD *)v2 + 156), v11, v9, v5);
              v5 = *(_DWORD *)v2;
              if ( v12 >= (signed __int64)*(signed int *)v2 * *((_QWORD *)v7 + 2) )
              {
                TsPieceDownload::unlockTsList(v2);
                return (int)(v7 + 2);
              }
            }
          }
        }
        v7 = (int *)*v7;
        if ( v7 == (int *)v8 )
          break;
        v9 = *((_QWORD *)v7 + 2);
      }
      while ( v6 >= v9 );
      TsPieceDownload::unlockTsList(v2);
      if ( !*((_DWORD *)v2 + 19) )
      {
        if ( v19 )
        {
          v13 = M3U8Manager::invertedInvalidTsPieceId(
                  (M3U8Manager *)*((_DWORD *)v2 + 156),
                  *(_DWORD *)v2,
                  *(_QWORD *)(v19 + 8),
                  *(_DWORD *)v2);
          v14 = *(_DWORD *)(v19 + 8);
          v15 = *(_DWORD *)v2 * *(_DWORD *)(v19 + 12) + v14 * (*(_DWORD *)v2 >> 31);
          v16 = v14 * (unsigned __int64)*(unsigned int *)v2;
          HIDWORD(v16) += v15;
          if ( v13 >= v16 )
            return v19;
        }
      }
    }
    result = 0;
  }
  return result;
}

//----- (0003FB10) --------------------------------------------------------
TsPieceDownload *__fastcall TsPieceDownload::~TsPieceDownload(TsPieceDownload *this)
{
  TsPieceDownload *v1; // r6
  void *v2; // r4
  int v3; // r4
  void *v4; // r0
  void *v5; // r0
  int v6; // r7
  int v7; // r2
  int i; // r4
  void *v9; // r0
  void *v10; // r0
  TsPieceDownload **v11; // r0
  TsPieceDownload *v12; // r4

  v1 = this;
  pthread_join(*((_DWORD *)this + 23), 0);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 52));
  pthread_mutex_destroy((pthread_mutex_t *)v1 + 3);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 80));
  v2 = (void *)*((_DWORD *)v1 + 16);
  if ( v2 )
  {
    LinkManager::~LinkManager(*((LinkManager **)v1 + 16));
    operator delete(v2);
    *((_DWORD *)v1 + 16) = 0;
  }
  v3 = *((_DWORD *)v1 + 7);
  if ( v3 )
  {
    v4 = *(void **)(v3 + 4);
    if ( v4 )
      operator delete[](v4);
    v5 = *(void **)(v3 + 8);
    if ( v5 )
      operator delete[](v5);
    pthread_mutex_destroy((pthread_mutex_t *)(v3 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v3 + 12));
    operator delete((void *)v3);
    *((_DWORD *)v1 + 7) = 0;
  }
  v6 = *((_DWORD *)v1 + 8);
  if ( v6 )
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 )
    {
      for ( i = v7 + 1736 * *(_DWORD *)(v7 - 4) - 1736; v7 != i + 1736; i -= 1736 )
      {
        v9 = *(void **)(i + 1600);
        if ( v9 )
        {
          free(v9);
          *(_DWORD *)(i + 1600) = 0;
          v7 = *(_DWORD *)(v6 + 4);
        }
      }
      operator delete[]((void *)(i + 1728));
    }
    v10 = *(void **)(v6 + 8);
    if ( v10 )
      operator delete[](v10);
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 52));
    std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)(v6 + 12));
    operator delete((void *)v6);
    *((_DWORD *)v1 + 8) = 0;
  }
  v11 = (TsPieceDownload **)*((_DWORD *)v1 + 9);
  if ( v11 != (TsPieceDownload **)((char *)v1 + 36) )
  {
    while ( 1 )
    {
      v12 = *v11;
      operator delete(v11);
      if ( v12 == (TsPieceDownload *)((char *)v1 + 36) )
        break;
      v11 = (TsPieceDownload **)v12;
    }
  }
  return v1;
}

//----- (0003FCC0) --------------------------------------------------------
void __fastcall std::deque<long,std::allocator<long>>::_M_pop_front_aux(int a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  int v3; // r3

  v1 = (_DWORD *)a1;
  operator delete(*(void **)(a1 + 12));
  v2 = v1[5];
  v1[5] = v2 + 4;
  v3 = *(_DWORD *)(v2 + 4);
  v1[4] = v3 + 512;
  v1[3] = v3;
  v1[2] = v3;
}

//----- (0003FCF4) --------------------------------------------------------
int __fastcall TsPieceDownload::TsPieceDownload(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // r6
  LinkManager *v11; // r4
  char *v12; // r5
  char *v13; // r11
  char *v14; // r4
  char *v15; // r0
  _BYTE *v16; // r0
  int v17; // r4
  _DWORD *v18; // r3
  int v19; // r2
  int v20; // r11
  _DWORD *v21; // r3
  int v22; // r3
  int v23; // r3
  char *v24; // r5
  _DWORD *v25; // r0
  int v26; // r11
  int v27; // r10
  int v28; // r4
  void *v29; // r0
  _BYTE *v30; // r0
  int v31; // r4
  _DWORD *v32; // r3
  int v33; // r2
  int v34; // r11
  _DWORD *v35; // r3
  int v36; // r3
  int v37; // r3
  int result; // r0
  int v39; // [sp+0h] [bp-78h]
  int v40; // [sp+4h] [bp-74h]
  int v41; // [sp+8h] [bp-70h]
  int v42; // [sp+Ch] [bp-6Ch]
  int v43; // [sp+10h] [bp-68h]
  int v44; // [sp+14h] [bp-64h]
  int v45; // [sp+18h] [bp-60h]
  int v46; // [sp+1Ch] [bp-5Ch]
  int v47; // [sp+20h] [bp-58h]
  int v48; // [sp+24h] [bp-54h]
  int v49; // [sp+28h] [bp-50h]
  int v50; // [sp+2Ch] [bp-4Ch]
  int v51; // [sp+30h] [bp-48h]
  int v52; // [sp+34h] [bp-44h]
  int v53; // [sp+38h] [bp-40h]
  int v54; // [sp+3Ch] [bp-3Ch]
  int v55; // [sp+40h] [bp-38h]
  int v56; // [sp+44h] [bp-34h]
  int v57; // [sp+48h] [bp-30h]
  int v58; // [sp+4Ch] [bp-2Ch]

  v10 = a1;
  *(_DWORD *)(a1 + 12) = a2;
  *(_BYTE *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a4;
  *(_DWORD *)(a1 + 56) = a5;
  *(_DWORD *)(a1 + 88) = a8;
  *(_DWORD *)(a1 + 624) = a10;
  *(_DWORD *)(a1 + 44) = a6;
  *(_DWORD *)(a1 + 48) = a9;
  *(_DWORD *)(a1 + 100) = a7;
  *(_DWORD *)(a1 + 36) = a1 + 36;
  *(_DWORD *)(a1 + 40) = a1 + 36;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 52), 0);
  pthread_mutex_init((pthread_mutex_t *)(v10 + 72), 0);
  pthread_mutex_init((pthread_mutex_t *)(v10 + 80), 0);
  *(_DWORD *)(v10 + 68) = 0;
  *(_DWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 76) = 0;
  *(_DWORD *)v10 = 0;
  *(_BYTE *)(v10 + 60) = 0;
  v11 = (LinkManager *)operator new(8u);
  LinkManager::LinkManager(v11);
  *(_DWORD *)(v10 + 64) = v11;
  v12 = (char *)operator new(0x38u);
  *(_DWORD *)v12 = 12;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v39, 0);
  std::deque<long,std::allocator<long>>::deque((_DWORD *)v12 + 3, &v39);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v39);
  pthread_mutex_init((pthread_mutex_t *)(v12 + 52), 0);
  v13 = (char *)operator new[](0x7260u);
  v14 = v13;
  do
  {
    v15 = v14;
    v14 += 2440;
    memset(v15, 0, 0x988u);
  }
  while ( v14 != v13 + 29280 );
  *((_DWORD *)v12 + 1) = v13;
  v16 = operator new[](0xCu);
  *((_DWORD *)v12 + 2) = v16;
  v17 = 0;
  while ( 1 )
  {
    v18 = (_DWORD *)*((_DWORD *)v12 + 9);
    v19 = *((_DWORD *)v12 + 11) - 4;
    v16[v17] = 1;
    if ( v18 != (_DWORD *)v19 )
      break;
    if ( (unsigned int)(*((_DWORD *)v12 + 4) - ((*((_DWORD *)v12 + 12) - *((_DWORD *)v12 + 3)) >> 2)) <= 1 )
      std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v12 + 3, 1u, 0);
    v20 = *((_DWORD *)v12 + 12);
    *(_DWORD *)(v20 + 4) = operator new(0x200u);
    v21 = (_DWORD *)*((_DWORD *)v12 + 9);
    if ( v21 )
      *v21 = v17;
    ++v17;
    v22 = *((_DWORD *)v12 + 12);
    *((_DWORD *)v12 + 12) = v22 + 4;
    v23 = *(_DWORD *)(v22 + 4);
    *((_DWORD *)v12 + 11) = v23 + 512;
    *((_DWORD *)v12 + 10) = v23;
    *((_DWORD *)v12 + 9) = v23;
    if ( v17 == 12 )
      goto LABEL_14;
LABEL_7:
    v16 = (_BYTE *)*((_DWORD *)v12 + 2);
  }
  if ( v18 )
    *v18 = v17;
  ++v17;
  *((_DWORD *)v12 + 9) = v18 + 1;
  if ( v17 != 12 )
    goto LABEL_7;
LABEL_14:
  *(_DWORD *)(v10 + 28) = v12;
  v24 = (char *)operator new(0x38u);
  *(_DWORD *)v24 = 12;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(&v49, 0);
  std::deque<long,std::allocator<long>>::deque((_DWORD *)v24 + 3, &v49);
  std::_Deque_base<long,std::allocator<long>>::~_Deque_base((void **)&v49);
  pthread_mutex_init((pthread_mutex_t *)(v24 + 52), 0);
  v25 = operator new[](0x5168u);
  v26 = (int)(v25 + 2);
  *v25 = 1736;
  v27 = (int)(v25 + 5210);
  v28 = (int)(v25 + 2);
  v25[1] = 12;
  do
  {
    v29 = (void *)v28;
    v28 += 1736;
    memset(v29, 0, 0x6C8u);
  }
  while ( v28 != v27 );
  *((_DWORD *)v24 + 1) = v26;
  v30 = operator new[](0xCu);
  *((_DWORD *)v24 + 2) = v30;
  v31 = 0;
  while ( 2 )
  {
    v32 = (_DWORD *)*((_DWORD *)v24 + 9);
    v33 = *((_DWORD *)v24 + 11) - 4;
    v30[v31] = 1;
    if ( v32 == (_DWORD *)v33 )
    {
      if ( (unsigned int)(*((_DWORD *)v24 + 4) - ((*((_DWORD *)v24 + 12) - *((_DWORD *)v24 + 3)) >> 2)) <= 1 )
        std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)v24 + 3, 1u, 0);
      v34 = *((_DWORD *)v24 + 12);
      *(_DWORD *)(v34 + 4) = operator new(0x200u);
      v35 = (_DWORD *)*((_DWORD *)v24 + 9);
      if ( v35 )
        *v35 = v31;
      ++v31;
      v36 = *((_DWORD *)v24 + 12);
      *((_DWORD *)v24 + 12) = v36 + 4;
      v37 = *(_DWORD *)(v36 + 4);
      *((_DWORD *)v24 + 11) = v37 + 512;
      *((_DWORD *)v24 + 10) = v37;
      *((_DWORD *)v24 + 9) = v37;
      if ( v31 == 12 )
        break;
      goto LABEL_20;
    }
    if ( v32 )
      *v32 = v31;
    ++v31;
    *((_DWORD *)v24 + 9) = v32 + 1;
    if ( v31 != 12 )
    {
LABEL_20:
      v30 = (_BYTE *)*((_DWORD *)v24 + 2);
      continue;
    }
    break;
  }
  result = v10;
  *(_DWORD *)(v10 + 32) = v24;
  *(_DWORD *)(v10 + 4) = 0;
  return result;
}

//----- (00040154) --------------------------------------------------------
int __fastcall TsPieceDownload::tsRangeDownloadFinish(int a1, int a2)
{
  int v2; // r6
  int v3; // r7
  int v4; // r4
  pthread_mutex_t *v5; // r5
  int result; // r0
  int v7; // r5
  int v8; // r7
  int v9; // r4
  int v10; // r5
  int v11; // r3
  int v12; // r9
  int v13; // r3
  int v14; // r7
  pthread_mutex_t *v15; // r5
  _DWORD *v16; // r10
  void *v17; // r0
  int v18; // r3
  bool v19; // zf
  int v20; // r3
  int v21; // r3
  int v22; // r3
  int v23; // r7
  int *v24; // r3
  int v25; // r3
  int v26; // r3
  int v27; // r9
  int *v28; // r3
  int v29; // r3
  int v30; // r3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = a1;
  if ( *(_DWORD *)(v3 + 1576) == 3 )
  {
    v15 = (pthread_mutex_t *)(a1 + 80);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
    --*(_DWORD *)(v4 + 76);
    pthread_mutex_unlock(v15);
  }
  else
  {
    v5 = (pthread_mutex_t *)(a1 + 72);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
    --*(_DWORD *)(v4 + 68);
    pthread_mutex_unlock(v5);
    ChannelPlayInfoManager::clearErrorWithType(*(_DWORD *)(v4 + 12), 2);
  }
  result = (*(int (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v4 + 88) + 8))(
             *(_DWORD *)(v4 + 88),
             *(_DWORD *)(**(_DWORD **)(v4 + 88) + 8));
  v7 = *(_DWORD *)(v4 + 32);
  v8 = 1068793705 * ((v3 - *(_DWORD *)(v7 + 4)) >> 3);
  if ( v8 >= 0 && v8 < *(_DWORD *)v7 && !*(_BYTE *)(*(_DWORD *)(v7 + 8) + v8) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 52));
    v11 = *(_DWORD *)(v7 + 8);
    v12 = *(unsigned __int8 *)(v11 + v8);
    if ( !*(_BYTE *)(v11 + v8) )
    {
      v16 = (_DWORD *)(*(_DWORD *)(v7 + 4) + 1736 * v8);
      v17 = (void *)v16[400];
      if ( v17 )
      {
        free(v17);
        v16[400] = v12;
      }
      memset(v16, 0, 0x6C8u);
      v18 = *(_DWORD *)(v7 + 36);
      if ( v18 == *(_DWORD *)(v7 + 44) - 4 )
      {
        if ( (unsigned int)(*(_DWORD *)(v7 + 16) - ((*(_DWORD *)(v7 + 48) - *(_DWORD *)(v7 + 12)) >> 2)) <= 1 )
          std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v7 + 12), 1u, 0);
        v27 = *(_DWORD *)(v7 + 48);
        *(_DWORD *)(v27 + 4) = operator new(0x200u);
        v28 = *(int **)(v7 + 36);
        if ( v28 )
          *v28 = v8;
        v29 = *(_DWORD *)(v7 + 48);
        *(_DWORD *)(v7 + 48) = v29 + 4;
        v30 = *(_DWORD *)(v29 + 4);
        *(_DWORD *)(v7 + 44) = v30 + 512;
        *(_DWORD *)(v7 + 40) = v30;
        *(_DWORD *)(v7 + 36) = v30;
      }
      else
      {
        v19 = v18 == 0;
        v20 = v18 + 4;
        if ( !v19 )
          *(_DWORD *)(v20 - 4) = v8;
        *(_DWORD *)(v7 + 36) = v20;
      }
      *(_BYTE *)(*(_DWORD *)(v7 + 8) + v8) = 1;
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 52));
  }
  v9 = *(_DWORD *)(v4 + 28);
  v10 = -1070221359 * ((v2 - *(_DWORD *)(v9 + 4)) >> 3);
  if ( v10 >= 0
    && v10 < *(_DWORD *)v9
    && !*(_BYTE *)(*(_DWORD *)(v9 + 8) - 1070221359 * ((v2 - *(_DWORD *)(v9 + 4)) >> 3)) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 52));
    v13 = *(_DWORD *)(v9 + 8);
    v14 = *(unsigned __int8 *)(v13 + v10);
    if ( !*(_BYTE *)(v13 + v10) )
    {
      memset((void *)(*(_DWORD *)(v9 + 4) + 2440 * v10), v14, 0x988u);
      v21 = *(_DWORD *)(v9 + 36);
      if ( v21 == *(_DWORD *)(v9 + 44) - 4 )
      {
        if ( (unsigned int)(*(_DWORD *)(v9 + 16) - ((*(_DWORD *)(v9 + 48) - *(_DWORD *)(v9 + 12)) >> 2)) <= 1 )
          std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v9 + 12), 1u, v14);
        v23 = *(_DWORD *)(v9 + 48);
        *(_DWORD *)(v23 + 4) = operator new(0x200u);
        v24 = *(int **)(v9 + 36);
        if ( v24 )
          *v24 = v10;
        v25 = *(_DWORD *)(v9 + 48);
        *(_DWORD *)(v9 + 48) = v25 + 4;
        v26 = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(v9 + 44) = v26 + 512;
        *(_DWORD *)(v9 + 40) = v26;
        *(_DWORD *)(v9 + 36) = v26;
      }
      else
      {
        v19 = v21 == 0;
        v22 = v21 + 4;
        if ( !v19 )
          *(_DWORD *)(v22 - 4) = v10;
        *(_DWORD *)(v9 + 36) = v22;
      }
      *(_BYTE *)(*(_DWORD *)(v9 + 8) + v10) = 1;
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 52));
  }
  return result;
}

//----- (0004048C) --------------------------------------------------------
int __fastcall tsRangeDownloadFinish_cb(void *a1)
{
  TsPieceDownload::tsRangeDownloadFinish(*(_DWORD *)(*((_DWORD *)a1 + 2) + 1552), (int)a1);
  return 0;
}

//----- (000404A8) --------------------------------------------------------
signed int __fastcall TsPieceDownload::tsRangeDownloadError(signed int result, int a2)
{
  int v2; // r10
  int v3; // r9
  int *v4; // r8
  unsigned int v5; // r3
  pthread_mutex_t *v6; // r4
  int *v7; // r0
  int *v8; // kr00_4
  int v9; // r1
  int v10; // r12
  int v11; // r4
  int v12; // r10
  int v13; // r4
  int v14; // r9
  pthread_mutex_t *v15; // r4
  __int64 v16; // r0
  signed __int64 v17; // r4
  signed __int64 v18; // r6
  pthread_mutex_t *v19; // r4
  int v20; // r3
  int v21; // r6
  int v22; // r3
  int v23; // r6
  _DWORD *v24; // r7
  void *v25; // r0
  int v26; // r3
  bool v27; // zf
  int v28; // r3
  int v29; // r3
  int v30; // r3
  int v31; // r6
  int *v32; // r3
  int v33; // r3
  int v34; // r3
  int v35; // r6
  int *v36; // r3
  int v37; // r3
  int v38; // r3

  v2 = *(_DWORD *)(a2 + 8);
  v3 = a2;
  v4 = (int *)result;
  v5 = *(_DWORD *)(v2 + 1576);
  switch ( v5 )
  {
    case 0u:
    case 1u:
      v19 = (pthread_mutex_t *)(result + 72);
      pthread_mutex_lock((pthread_mutex_t *)(result + 72));
      --v4[17];
      pthread_mutex_unlock(v19);
      TsPieceDownload::downloadPieceDataWithPieceid((TsPieceDownload *)v4, *(_DWORD *)(v2 + 1560));
      v7 = (int *)v4[22];
      v9 = *v7;
      goto LABEL_4;
    case 2u:
      v15 = (pthread_mutex_t *)(result + 72);
      pthread_mutex_lock((pthread_mutex_t *)(result + 72));
      --v4[17];
      pthread_mutex_unlock(v15);
      v16 = *(_QWORD *)(v2 + 1560) + *(_DWORD *)(v2 + 1596) / *(_DWORD *)(v2 + 1588);
      *(_QWORD *)(v2 + 1560) = v16;
      if ( *(_QWORD *)(v2 + 1568) >= (signed __int64)(signed int)v16 )
      {
        v17 = (signed int)v16 + 1LL;
        do
        {
          TsPieceDownload::downloadPieceDataWithPieceid((TsPieceDownload *)v4, v17 - 1);
          v18 = v17++;
        }
        while ( *(_QWORD *)(v2 + 1568) >= v18 );
      }
      v7 = (int *)v4[22];
      v8 = (int *)tsRangeCheckDownloading;
      goto LABEL_3;
    case 3u:
      v6 = (pthread_mutex_t *)(result + 80);
      pthread_mutex_lock((pthread_mutex_t *)(result + 80));
      --v4[19];
      pthread_mutex_unlock(v6);
      v7 = (int *)v4[22];
      v8 = (int *)&tsCheckDownloading;
LABEL_3:
      v9 = *v7;
      v10 = *v8;
LABEL_4:
      result = (*(int (__cdecl **)(int *, _DWORD))(v9 + 8))(v7, *(_DWORD *)(v9 + 8));
      v5 = *(_DWORD *)(v2 + 1576);
      break;
    default:
      break;
  }
  if ( v5 <= 2 )
    result = ChannelPlayInfoManager::changeCdnWithType(v4[3], 2, (char *)(v2 + 528));
  v11 = v4[8];
  v12 = 1068793705 * ((v2 - *(_DWORD *)(v11 + 4)) >> 3);
  if ( v12 >= 0 && v12 < *(_DWORD *)v11 && !*(_BYTE *)(*(_DWORD *)(v11 + 8) + v12) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 52));
    v20 = *(_DWORD *)(v11 + 8);
    v21 = *(unsigned __int8 *)(v20 + v12);
    if ( !*(_BYTE *)(v20 + v12) )
    {
      v24 = (_DWORD *)(*(_DWORD *)(v11 + 4) + 1736 * v12);
      v25 = (void *)v24[400];
      if ( v25 )
      {
        free(v25);
        v24[400] = v21;
      }
      memset(v24, 0, 0x6C8u);
      v26 = *(_DWORD *)(v11 + 36);
      if ( v26 == *(_DWORD *)(v11 + 44) - 4 )
      {
        v35 = *(_DWORD *)(v11 + 48);
        if ( (unsigned int)(*(_DWORD *)(v11 + 16) - ((v35 - *(_DWORD *)(v11 + 12)) >> 2)) <= 1 )
        {
          std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v11 + 12), 1u, 0);
          v35 = *(_DWORD *)(v11 + 48);
        }
        *(_DWORD *)(v35 + 4) = operator new(0x200u);
        v36 = *(int **)(v11 + 36);
        if ( v36 )
          *v36 = v12;
        v37 = *(_DWORD *)(v11 + 48);
        *(_DWORD *)(v11 + 48) = v37 + 4;
        v38 = *(_DWORD *)(v37 + 4);
        *(_DWORD *)(v11 + 44) = v38 + 512;
        *(_DWORD *)(v11 + 40) = v38;
        *(_DWORD *)(v11 + 36) = v38;
      }
      else
      {
        v27 = v26 == 0;
        v28 = v26 + 4;
        if ( !v27 )
          *(_DWORD *)(v28 - 4) = v12;
        *(_DWORD *)(v11 + 36) = v28;
      }
      *(_BYTE *)(*(_DWORD *)(v11 + 8) + v12) = 1;
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)(v11 + 52));
  }
  v13 = v4[7];
  v14 = -1070221359 * ((v3 - *(_DWORD *)(v13 + 4)) >> 3);
  if ( v14 >= 0 && v14 < *(_DWORD *)v13 && !*(_BYTE *)(*(_DWORD *)(v13 + 8) + v14) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v13 + 52));
    v22 = *(_DWORD *)(v13 + 8);
    v23 = *(unsigned __int8 *)(v22 + v14);
    if ( !*(_BYTE *)(v22 + v14) )
    {
      memset((void *)(*(_DWORD *)(v13 + 4) + 2440 * v14), v23, 0x988u);
      v29 = *(_DWORD *)(v13 + 36);
      if ( v29 == *(_DWORD *)(v13 + 44) - 4 )
      {
        if ( (unsigned int)(*(_DWORD *)(v13 + 16) - ((*(_DWORD *)(v13 + 48) - *(_DWORD *)(v13 + 12)) >> 2)) <= 1 )
          std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v13 + 12), 1u, v23);
        v31 = *(_DWORD *)(v13 + 48);
        *(_DWORD *)(v31 + 4) = operator new(0x200u);
        v32 = *(int **)(v13 + 36);
        if ( v32 )
          *v32 = v14;
        v33 = *(_DWORD *)(v13 + 48);
        *(_DWORD *)(v13 + 48) = v33 + 4;
        v34 = *(_DWORD *)(v33 + 4);
        *(_DWORD *)(v13 + 44) = v34 + 512;
        *(_DWORD *)(v13 + 40) = v34;
        *(_DWORD *)(v13 + 36) = v34;
      }
      else
      {
        v27 = v29 == 0;
        v30 = v29 + 4;
        if ( !v27 )
          *(_DWORD *)(v30 - 4) = v14;
        *(_DWORD *)(v13 + 36) = v30;
      }
      *(_BYTE *)(*(_DWORD *)(v13 + 8) + v14) = 1;
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)(v13 + 52));
  }
  return result;
}
// F2804: using guessed type _DWORD (__fastcall *tsRangeCheckDownloading[2])(void *);
// F2808: using guessed type _DWORD (__fastcall *tsCheckDownloading)(void *);

//----- (000408C0) --------------------------------------------------------
int __fastcall tsRangeDownloadError_cb(void *a1)
{
  TsPieceDownload::tsRangeDownloadError(*(_DWORD *)(*((_DWORD *)a1 + 2) + 1552), (int)a1);
  return 0;
}

//----- (000408DC) --------------------------------------------------------
void __fastcall TsPieceDownload::startTsDownload(TsPieceDownload *this)
{
  TsPieceDownload *v1; // r10
  int v2; // r1
  _DWORD *v3; // r3
  int v4; // r7
  int v5; // r4
  int *v6; // r2
  int v7; // r5
  int v8; // r3
  _BYTE *v9; // r1
  int v10; // r11
  __int64 v11; // r8
  size_t v12; // r0
  void *v13; // r0
  __int64 v14; // r4
  int v15; // r4
  int *v16; // r3
  int v17; // r5
  int v18; // r2
  _BYTE *v19; // r1
  int v20; // r3
  void **v21; // r7
  void *v22; // r0
  signed int v23; // r2
  signed __int64 v24; // r4
  int v25; // r3
  signed __int64 v26; // r4
  void (__fastcall *v27)(void **, signed int); // r3
  signed int v28; // ST0C_4
  signed __int64 v29; // r8
  int v30; // r4
  int v31; // r6
  int v32; // r4
  int v33; // r7
  int v34; // r3
  int v35; // r6
  int v36; // r3
  int v37; // r7
  _DWORD *v38; // r8
  void *v39; // r0
  int v40; // r3
  bool v41; // zf
  int v42; // r3
  int v43; // r3
  int v44; // r3
  int v45; // r7
  int *v46; // r3
  int v47; // r3
  int v48; // r3
  int v49; // r6
  int *v50; // r3
  int v51; // r3
  int v52; // r3
  int v53; // [sp+10h] [bp-40h]

  v1 = this;
  if ( !**((_DWORD **)this + 14) && *((_BYTE *)this + 8) && !*((_BYTE *)this + 104) && *((_DWORD *)this + 19) <= 2u )
  {
    v2 = *((_DWORD *)this + 1);
    do
    {
      v4 = TsPieceDownload::getDownloadableTs(v1, v2);
      if ( !v4 )
        break;
      v5 = *((_DWORD *)v1 + 8);
      pthread_mutex_lock((pthread_mutex_t *)(v5 + 52));
      v6 = *(int **)(v5 + 20);
      if ( *(int **)(v5 + 36) != v6
        && (v7 = *v6, v8 = *(_DWORD *)(v5 + 8), v9 = (_BYTE *)(v8 + *v6), *(_BYTE *)(v8 + *v6)) )
      {
        if ( v6 == (int *)(*(_DWORD *)(v5 + 28) - 4) )
        {
          std::deque<long,std::allocator<long>>::_M_pop_front_aux(v5 + 12);
          v9 = (_BYTE *)(*(_DWORD *)(v5 + 8) + v7);
        }
        else
        {
          *(_DWORD *)(v5 + 20) = v6 + 1;
        }
        *v9 = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(v5 + 52));
        v10 = *(_DWORD *)(v5 + 4) + 1736 * v7;
      }
      else
      {
        v10 = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(v5 + 52));
      }
      v11 = *(_QWORD *)(v4 + 8);
      v12 = *(_DWORD *)v4;
      *(_DWORD *)(v10 + 1580) = 0;
      *(_DWORD *)(v10 + 1584) = v12;
      *(_DWORD *)v10 = v12;
      *(_DWORD *)(v10 + 8) = v11;
      *(_DWORD *)(v10 + 1576) = 3;
      *(_DWORD *)(v10 + 1552) = v1;
      *(_DWORD *)(v10 + 12) = HIDWORD(v11);
      v13 = malloc(v12);
      v14 = *(signed int *)v1;
      *(_DWORD *)(v10 + 1588) = *(_DWORD *)(v4 + 1104);
      *(_QWORD *)(v10 + 1560) = v11 * v14;
      *(_QWORD *)(v10 + 1568) = v14 + v11 * v14 - 1;
      *(_DWORD *)(v10 + 1600) = v13;
      sprintf((char *)(v10 + 528), "%s%s", v4 + 24, v4 + 536);
      strcpy((char *)(v10 + 1604), (const char *)(v4 + 1108));
      *(_DWORD *)(v10 + 1732) = 0;
      strcpy((char *)(v10 + 1040), (const char *)(v4 + 584));
      v15 = *((_DWORD *)v1 + 7);
      *(_DWORD *)(v10 + 1596) = 0;
      *(_DWORD *)(v10 + 1592) = 0;
      pthread_mutex_lock((pthread_mutex_t *)(v15 + 52));
      v16 = *(int **)(v15 + 20);
      if ( *(int **)(v15 + 36) == v16 )
        goto LABEL_65;
      v17 = *v16;
      v18 = *(_DWORD *)(v15 + 8);
      v19 = (_BYTE *)(v18 + *v16);
      if ( *(_BYTE *)(v18 + *v16) )
      {
        if ( v16 == (int *)(*(_DWORD *)(v15 + 28) - 4) )
        {
          std::deque<long,std::allocator<long>>::_M_pop_front_aux(v15 + 12);
          v19 = (_BYTE *)(*(_DWORD *)(v15 + 8) + v17);
        }
        else
        {
          *(_DWORD *)(v15 + 20) = v16 + 1;
        }
        *v19 = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 52));
        v53 = *(_DWORD *)(v15 + 4) + 2440 * v17;
      }
      else
      {
LABEL_65:
        v53 = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 52));
      }
      v20 = *(_DWORD *)(v10 + 1580) + *(_DWORD *)(v10 + 1584);
      *(_DWORD *)(v53 + 8) = v10;
      *(_BYTE *)(v53 + 2328) = 1;
      sprintf((char *)(v53 + 2329), "%d-%d");
      if ( *(_DWORD *)(v10 + 1584) )
      {
        CurlWrapper::new_session(
          *((int **)v1 + 5),
          (const char *)(v10 + 1040),
          v53,
          (int)tsDataWrite_cb,
          (int)tsRangeDownloadFinish_cb,
          (int)tsRangeDownloadError_cb);
        pthread_mutex_lock((pthread_mutex_t *)((char *)v1 + 80));
        ++*((_DWORD *)v1 + 19);
        pthread_mutex_unlock((pthread_mutex_t *)((char *)v1 + 80));
      }
      else
      {
        v21 = (void **)calloc(0x14u, 1u);
        v22 = malloc(0);
        v23 = 1568;
        v24 = *(_QWORD *)(v10 + 1568);
        v25 = *(_DWORD *)(v10 + 1560);
        v21[2] = 0;
        v21[1] = 0;
        v21[3] = v22;
        if ( v24 >= v25 )
        {
          v26 = v25 + 1LL;
          do
          {
            v27 = (void (__fastcall *)(void **, signed int))*((_DWORD *)v1 + 11);
            *v21 = (void *)(v26 - 1);
            v28 = v23;
            v27(v21, 2);
            v23 = v28;
            v29 = v26++;
          }
          while ( *(_QWORD *)(v10 + v28) >= v29 );
        }
        LinkManager::deepDestroyElement(v21);
        v30 = *((_DWORD *)v1 + 8);
        v31 = 1068793705 * ((v10 - *(_DWORD *)(v30 + 4)) >> 3);
        if ( v31 >= 0 && v31 < *(_DWORD *)v30 && !*(_BYTE *)(*(_DWORD *)(v30 + 8) + v31) )
        {
          pthread_mutex_lock((pthread_mutex_t *)(v30 + 52));
          v36 = *(_DWORD *)(v30 + 8);
          v37 = *(unsigned __int8 *)(v36 + v31);
          if ( !*(_BYTE *)(v36 + v31) )
          {
            v38 = (_DWORD *)(*(_DWORD *)(v30 + 4) + 1736 * v31);
            v39 = (void *)v38[400];
            if ( v39 )
            {
              free(v39);
              v38[400] = v37;
            }
            memset(v38, 0, 0x6C8u);
            v40 = *(_DWORD *)(v30 + 36);
            if ( v40 == *(_DWORD *)(v30 + 44) - 4 )
            {
              if ( (unsigned int)(*(_DWORD *)(v30 + 16) - ((*(_DWORD *)(v30 + 48) - *(_DWORD *)(v30 + 12)) >> 2)) <= 1 )
                std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v30 + 12), 1u, 0);
              v45 = *(_DWORD *)(v30 + 48);
              *(_DWORD *)(v45 + 4) = operator new(0x200u);
              v46 = *(int **)(v30 + 36);
              if ( v46 )
                *v46 = v31;
              v47 = *(_DWORD *)(v30 + 48);
              *(_DWORD *)(v30 + 48) = v47 + 4;
              v48 = *(_DWORD *)(v47 + 4);
              *(_DWORD *)(v30 + 44) = v48 + 512;
              *(_DWORD *)(v30 + 40) = v48;
              *(_DWORD *)(v30 + 36) = v48;
            }
            else
            {
              v41 = v40 == 0;
              v42 = v40 + 4;
              if ( !v41 )
                *(_DWORD *)(v42 - 4) = v31;
              *(_DWORD *)(v30 + 36) = v42;
            }
            *(_BYTE *)(*(_DWORD *)(v30 + 8) + v31) = 1;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v30 + 52));
        }
        v32 = *((_DWORD *)v1 + 7);
        v33 = -1070221359 * ((v53 - *(_DWORD *)(v32 + 4)) >> 3);
        if ( v33 >= 0
          && v33 < *(_DWORD *)v32
          && !*(_BYTE *)(*(_DWORD *)(v32 + 8) - 1070221359 * ((v53 - *(_DWORD *)(v32 + 4)) >> 3)) )
        {
          pthread_mutex_lock((pthread_mutex_t *)(v32 + 52));
          v34 = *(_DWORD *)(v32 + 8);
          v35 = *(unsigned __int8 *)(v34 + v33);
          if ( !*(_BYTE *)(v34 + v33) )
          {
            memset((void *)(*(_DWORD *)(v32 + 4) + 2440 * v33), v35, 0x988u);
            v43 = *(_DWORD *)(v32 + 36);
            if ( v43 == *(_DWORD *)(v32 + 44) - 4 )
            {
              if ( (unsigned int)(*(_DWORD *)(v32 + 16) - ((*(_DWORD *)(v32 + 48) - *(_DWORD *)(v32 + 12)) >> 2)) <= 1 )
                std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v32 + 12), 1u, v35);
              v49 = *(_DWORD *)(v32 + 48);
              *(_DWORD *)(v49 + 4) = operator new(0x200u);
              v50 = *(int **)(v32 + 36);
              if ( v50 )
                *v50 = v33;
              v51 = *(_DWORD *)(v32 + 48);
              *(_DWORD *)(v32 + 48) = v51 + 4;
              v52 = *(_DWORD *)(v51 + 4);
              *(_DWORD *)(v32 + 44) = v52 + 512;
              *(_DWORD *)(v32 + 40) = v52;
              *(_DWORD *)(v32 + 36) = v52;
            }
            else
            {
              v41 = v43 == 0;
              v44 = v43 + 4;
              if ( !v41 )
                *(_DWORD *)(v44 - 4) = v33;
              *(_DWORD *)(v32 + 36) = v44;
            }
            *(_BYTE *)(*(_DWORD *)(v32 + 8) + v33) = 1;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v32 + 52));
        }
      }
      v3 = (_DWORD *)*((_DWORD *)v1 + 14);
      v2 = *(_DWORD *)(v10 + 8) + 1;
      *((_DWORD *)v1 + 1) = v2;
      if ( *v3 )
        break;
    }
    while ( *((_BYTE *)v1 + 8) && !*((_BYTE *)v1 + 104) && *((_DWORD *)v1 + 19) <= 2u );
  }
}

//----- (00040F50) --------------------------------------------------------
void __fastcall TsPieceDownload::checkDownloading(TsPieceDownload *this)
{
  TsPieceDownload *v1; // r8
  unsigned int v2; // r3
  LinkManager *v3; // r0
  int *v4; // r4
  int *v5; // r6
  int v6; // r5
  int *v7; // r3
  int v8; // r7
  int v9; // r2
  _BYTE *v10; // r1
  int v11; // r9
  int *v12; // r5
  int v13; // r1
  int v14; // r2
  int v15; // r1
  int v16; // r2
  int v17; // r4
  int *v18; // r3
  int v19; // r5
  int v20; // r2
  _BYTE *v21; // r1
  int v22; // r10
  int v23; // r2
  int v24; // r3
  int v25; // r2
  int v26; // r2
  size_t v27; // r0
  void **v28; // r11
  void *v29; // r0
  int v30; // r4
  signed __int64 v31; // r2
  signed __int64 v32; // r4
  void (__fastcall *v33)(void **, signed int); // r3
  signed __int64 v34; // r0
  int v35; // r4
  int v36; // r9
  int v37; // r4
  int v38; // r5
  int v39; // r3
  int v40; // r7
  int v41; // r3
  int v42; // r6
  int v43; // r4
  int v44; // r5
  int v45; // r3
  int v46; // r9
  _DWORD *v47; // r7
  void *v48; // r0
  int v49; // r3
  bool v50; // zf
  int v51; // r3
  int v52; // r3
  int v53; // r3
  _DWORD *v54; // r6
  void *v55; // r0
  int v56; // r3
  int v57; // r3
  int v58; // r6
  int *v59; // r3
  int v60; // r3
  int v61; // r3
  int v62; // r7
  int *v63; // r3
  int v64; // r3
  int v65; // r3
  int v66; // r6
  int *v67; // r3
  int v68; // r3
  int v69; // r3

  v1 = this;
  if ( *((_BYTE *)this + 8) )
  {
    v2 = 3;
    dword_F30D0 = 3;
  }
  else
  {
    v2 = 1;
    dword_F30D0 = 1;
  }
  while ( *((_DWORD *)v1 + 17) < v2 && !**((_DWORD **)v1 + 14) )
  {
    LinkManager::lockTheLink(*((LinkManager **)v1 + 16));
    v3 = (LinkManager *)*((_DWORD *)v1 + 16);
    v4 = *(int **)(*(_DWORD *)v3 + 16);
    if ( !v4 )
      goto LABEL_52;
    if ( (v4[1] <= 0 || v4[2] <= 0) && (v5 = (int *)v4[4]) != 0 && *v4 == *v5 - 1 )
    {
      if ( !((unsigned int)*v5 % *(_DWORD *)v1) )
        v5 = *(int **)(*(_DWORD *)v3 + 16);
    }
    else
    {
      v5 = *(int **)(*(_DWORD *)v3 + 16);
    }
    v6 = *((_DWORD *)v1 + 8);
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 52));
    v7 = *(int **)(v6 + 20);
    if ( *(int **)(v6 + 36) != v7
      && (v8 = *v7, v9 = *(_DWORD *)(v6 + 8), v10 = (_BYTE *)(v9 + *v7), *(_BYTE *)(v9 + *v7)) )
    {
      if ( v7 == (int *)(*(_DWORD *)(v6 + 28) - 4) )
      {
        std::deque<long,std::allocator<long>>::_M_pop_front_aux(v6 + 12);
        v10 = (_BYTE *)(*(_DWORD *)(v6 + 8) + v8);
      }
      else
      {
        *(_DWORD *)(v6 + 20) = v7 + 1;
      }
      *v10 = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 52));
      v11 = *(_DWORD *)(v6 + 4) + 1736 * v8;
    }
    else
    {
      v11 = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 52));
    }
    *(_DWORD *)(v11 + 1552) = v1;
    if ( !TsPieceDownload::initTsRangeWithPieceId(v1, v4, v5, v11) )
    {
      v43 = *((_DWORD *)v1 + 8);
      v44 = 1068793705 * ((v11 - *(_DWORD *)(v43 + 4)) >> 3);
      if ( v44 >= 0 && v44 < *(_DWORD *)v43 && !*(_BYTE *)(*(_DWORD *)(v43 + 8) + v44) )
      {
        pthread_mutex_lock((pthread_mutex_t *)(v43 + 52));
        v45 = *(_DWORD *)(v43 + 8);
        v46 = *(unsigned __int8 *)(v45 + v44);
        if ( !*(_BYTE *)(v45 + v44) )
        {
          v54 = (_DWORD *)(*(_DWORD *)(v43 + 4) + 1736 * v44);
          v55 = (void *)v54[400];
          if ( v55 )
          {
            free(v55);
            v54[400] = v46;
          }
          memset(v54, 0, 0x6C8u);
          v56 = *(_DWORD *)(v43 + 36);
          if ( v56 == *(_DWORD *)(v43 + 44) - 4 )
          {
            v66 = *(_DWORD *)(v43 + 48);
            if ( (unsigned int)(*(_DWORD *)(v43 + 16) - ((v66 - *(_DWORD *)(v43 + 12)) >> 2)) <= 1 )
            {
              std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v43 + 12), 1u, 0);
              v66 = *(_DWORD *)(v43 + 48);
            }
            *(_DWORD *)(v66 + 4) = operator new(0x200u);
            v67 = *(int **)(v43 + 36);
            if ( v67 )
              *v67 = v44;
            v68 = *(_DWORD *)(v43 + 48);
            *(_DWORD *)(v43 + 48) = v68 + 4;
            v69 = *(_DWORD *)(v68 + 4);
            *(_DWORD *)(v43 + 44) = v69 + 512;
            *(_DWORD *)(v43 + 40) = v69;
            *(_DWORD *)(v43 + 36) = v69;
          }
          else
          {
            v50 = v56 == 0;
            v57 = v56 + 4;
            if ( !v50 )
              *(_DWORD *)(v57 - 4) = v44;
            *(_DWORD *)(v43 + 36) = v57;
          }
          *(_BYTE *)(*(_DWORD *)(v43 + 8) + v44) = 1;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v43 + 52));
      }
      v3 = (LinkManager *)*((_DWORD *)v1 + 16);
LABEL_52:
      LinkManager::unlockTheLink(v3);
      return;
    }
    if ( *v4 != *v5 )
    {
      do
      {
        v12 = (int *)v4[4];
        LinkManager::deleteElement(*((int **)v1 + 16), (int)v4);
        LinkManager::destroyElement(v4, v13, v14);
        v4 = v12;
      }
      while ( *v12 != *v5 );
    }
    LinkManager::deleteElement(*((int **)v1 + 16), (int)v5);
    LinkManager::destroyElement(v5, v15, v16);
    LinkManager::unlockTheLink(*((LinkManager **)v1 + 16));
    v17 = *((_DWORD *)v1 + 7);
    pthread_mutex_lock((pthread_mutex_t *)(v17 + 52));
    v18 = *(int **)(v17 + 20);
    if ( *(int **)(v17 + 36) != v18
      && (v19 = *v18, v20 = *(_DWORD *)(v17 + 8), v21 = (_BYTE *)(v20 + *v18), *(_BYTE *)(v20 + *v18)) )
    {
      if ( v18 == (int *)(*(_DWORD *)(v17 + 28) - 4) )
      {
        std::deque<long,std::allocator<long>>::_M_pop_front_aux(v17 + 12);
        v21 = (_BYTE *)(*(_DWORD *)(v17 + 8) + v19);
      }
      else
      {
        *(_DWORD *)(v17 + 20) = v18 + 1;
      }
      *v21 = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v17 + 52));
      v22 = *(_DWORD *)(v17 + 4) + 2440 * v19;
    }
    else
    {
      v22 = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v17 + 52));
    }
    v23 = *(_DWORD *)(v11 + 1580);
    v24 = *(_DWORD *)(v11 + 1584);
    *(_DWORD *)(v22 + 8) = v11;
    *(_BYTE *)(v22 + 2328) = 1;
    sprintf((char *)(v22 + 2329), "%d-%d");
    if ( *(_DWORD *)(v11 + 1584) )
    {
      ChannelPlayInfoManager::getCurrentCdnUrl(*((ChannelPlayInfoManager **)v1 + 3), (char *)v1 + 112, v25);
      ChannelPlayInfoManager::getCurrentCdnUrl(*((ChannelPlayInfoManager **)v1 + 3), (char *)(v11 + 528), v26);
      v27 = strlen((const char *)(v11 + 528));
      *(_BYTE *)(v11 + 528 + v27) = 47;
      strcpy((char *)(v11 + 528 + v27 + 1), (const char *)(v11 + 16));
      CurlWrapper::new_session(
        *((int **)v1 + 5),
        (const char *)(v11 + 528),
        v22,
        (int)tsDataWrite_cb,
        (int)tsRangeDownloadFinish_cb,
        (int)tsRangeDownloadError_cb);
      pthread_mutex_lock((pthread_mutex_t *)v1 + 3);
      ++*((_DWORD *)v1 + 17);
      pthread_mutex_unlock((pthread_mutex_t *)v1 + 3);
    }
    else
    {
      v28 = (void **)calloc(0x14u, 1u);
      v29 = malloc(0);
      v30 = *(_DWORD *)(v11 + 1560);
      v28[2] = 0;
      v31 = *(_QWORD *)(v11 + 1568);
      v28[1] = 0;
      v28[3] = v29;
      if ( v31 >= v30 )
      {
        v32 = v30 + 1LL;
        do
        {
          v33 = (void (__fastcall *)(void **, signed int))*((_DWORD *)v1 + 11);
          *v28 = (void *)(v32 - 1);
          v33(v28, 2);
          v34 = v32++;
        }
        while ( *(_QWORD *)(v11 + 1568) >= v34 );
      }
      LinkManager::deepDestroyElement(v28);
      v35 = *((_DWORD *)v1 + 8);
      v36 = 1068793705 * ((v11 - *(_DWORD *)(v35 + 4)) >> 3);
      if ( v36 >= 0 && v36 < *(_DWORD *)v35 && !*(_BYTE *)(*(_DWORD *)(v35 + 8) + v36) )
      {
        pthread_mutex_lock((pthread_mutex_t *)(v35 + 52));
        v41 = *(_DWORD *)(v35 + 8);
        v42 = *(unsigned __int8 *)(v41 + v36);
        if ( !*(_BYTE *)(v41 + v36) )
        {
          v47 = (_DWORD *)(*(_DWORD *)(v35 + 4) + 1736 * v36);
          v48 = (void *)v47[400];
          if ( v48 )
          {
            free(v48);
            v47[400] = v42;
          }
          memset(v47, 0, 0x6C8u);
          v49 = *(_DWORD *)(v35 + 36);
          if ( v49 == *(_DWORD *)(v35 + 44) - 4 )
          {
            v58 = *(_DWORD *)(v35 + 48);
            if ( (unsigned int)(*(_DWORD *)(v35 + 16) - ((v58 - *(_DWORD *)(v35 + 12)) >> 2)) <= 1 )
            {
              std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v35 + 12), 1u, 0);
              v58 = *(_DWORD *)(v35 + 48);
            }
            *(_DWORD *)(v58 + 4) = operator new(0x200u);
            v59 = *(int **)(v35 + 36);
            if ( v59 )
              *v59 = v36;
            v60 = *(_DWORD *)(v35 + 48);
            *(_DWORD *)(v35 + 48) = v60 + 4;
            v61 = *(_DWORD *)(v60 + 4);
            *(_DWORD *)(v35 + 44) = v61 + 512;
            *(_DWORD *)(v35 + 40) = v61;
            *(_DWORD *)(v35 + 36) = v61;
          }
          else
          {
            v50 = v49 == 0;
            v51 = v49 + 4;
            if ( !v50 )
              *(_DWORD *)(v51 - 4) = v36;
            *(_DWORD *)(v35 + 36) = v51;
          }
          *(_BYTE *)(*(_DWORD *)(v35 + 8) + v36) = 1;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v35 + 52));
      }
      v37 = *((_DWORD *)v1 + 7);
      v38 = -1070221359 * ((v22 - *(_DWORD *)(v37 + 4)) >> 3);
      if ( v38 >= 0
        && v38 < *(_DWORD *)v37
        && !*(_BYTE *)(*(_DWORD *)(v37 + 8) - 1070221359 * ((v22 - *(_DWORD *)(v37 + 4)) >> 3)) )
      {
        pthread_mutex_lock((pthread_mutex_t *)(v37 + 52));
        v39 = *(_DWORD *)(v37 + 8);
        v40 = *(unsigned __int8 *)(v39 + v38);
        if ( !*(_BYTE *)(v39 + v38) )
        {
          memset((void *)(*(_DWORD *)(v37 + 4) + 2440 * v38), *(unsigned __int8 *)(v39 + v38), 0x988u);
          v52 = *(_DWORD *)(v37 + 36);
          if ( v52 == *(_DWORD *)(v37 + 44) - 4 )
          {
            if ( (unsigned int)(*(_DWORD *)(v37 + 16) - ((*(_DWORD *)(v37 + 48) - *(_DWORD *)(v37 + 12)) >> 2)) <= 1 )
              std::deque<long,std::allocator<long>>::_M_reallocate_map((void **)(v37 + 12), 1u, v40);
            v62 = *(_DWORD *)(v37 + 48);
            *(_DWORD *)(v62 + 4) = operator new(0x200u);
            v63 = *(int **)(v37 + 36);
            if ( v63 )
              *v63 = v38;
            v64 = *(_DWORD *)(v37 + 48);
            *(_DWORD *)(v37 + 48) = v64 + 4;
            v65 = *(_DWORD *)(v64 + 4);
            *(_DWORD *)(v37 + 44) = v65 + 512;
            *(_DWORD *)(v37 + 40) = v65;
            *(_DWORD *)(v37 + 36) = v65;
          }
          else
          {
            v50 = v52 == 0;
            v53 = v52 + 4;
            if ( !v50 )
              *(_DWORD *)(v53 - 4) = v38;
            *(_DWORD *)(v37 + 36) = v53;
          }
          *(_BYTE *)(*(_DWORD *)(v37 + 8) + v38) = 1;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v37 + 52));
      }
    }
    v2 = dword_F30D0;
  }
}
// F30D0: using guessed type int dword_F30D0;

//----- (00041700) --------------------------------------------------------
signed int __fastcall sub_41700(unsigned __int8 *a1, const char *a2, size_t a3)
{
  unsigned __int8 *v3; // r5
  size_t v4; // r6
  const char *v5; // r4
  size_t v6; // r0
  unsigned __int8 *v7; // r3
  const char *v8; // r1
  int v9; // r0
  int v10; // r12
  int v11; // t1
  int v12; // t1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = strlen(a2);
  if ( v6 <= v4 )
  {
    if ( !v6 )
      return 1;
    if ( *v3 == *(unsigned __int8 *)v5 )
    {
      v7 = v3;
      v8 = v5;
      v9 = (int)&v3[v6 - 1];
      while ( v7 != (unsigned __int8 *)v9 )
      {
        v11 = (v7++)[1];
        v10 = v11;
        v12 = *((unsigned __int8 *)v8++ + 1);
        if ( v10 != v12 )
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (00041778) --------------------------------------------------------
char *__fastcall sub_41778(int a1, int a2, int a3, int a4)
{
  int v4; // r7
  _DWORD *v5; // r12
  int v6; // r5
  int v7; // t1
  char *result; // r0
  int v9; // [sp+2Ch] [bp-5Ch]
  int v10; // [sp+30h] [bp-58h]
  int v11; // [sp+34h] [bp-54h]
  int v12; // [sp+38h] [bp-50h]
  int v13; // [sp+3Ch] [bp-4Ch]
  int v14; // [sp+40h] [bp-48h]
  int v15; // [sp+44h] [bp-44h]
  int v16; // [sp+48h] [bp-40h]
  int v17; // [sp+4Ch] [bp-3Ch]
  int v18; // [sp+50h] [bp-38h]
  int v19; // [sp+54h] [bp-34h]
  __int16 v20; // [sp+58h] [bp-30h]

  v4 = a4;
  if ( !a2 )
  {
    v5 = *(_DWORD **)(a4 + 16);
    if ( *v5 )
    {
      v6 = (int)(v5 - 1);
      do
      {
        v10 = 0;
        v9 = 16191;
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v7 = *(_DWORD *)(v6 + 4);
        v6 += 4;
        ares_inet_ntop(*(_DWORD *)(v4 + 8), v7, &v9, 46);
        result = strcpy(&ipaddr, (const char *)&v9);
      }
      while ( *(_DWORD *)(v6 + 4) );
    }
  }
  return result;
}
// CE0C0: using guessed type int __fastcall ares_inet_ntop(_DWORD, _DWORD, _DWORD, _DWORD);
// F4100: using guessed type char ipaddr;

//----- (000418A4) --------------------------------------------------------
bool __fastcall checkIp(char *a1)
{
  unsigned int v2; // [sp+14h] [bp-1Ch]
  unsigned int v3; // [sp+18h] [bp-18h]
  unsigned int v4; // [sp+1Ch] [bp-14h]
  unsigned int v5; // [sp+20h] [bp-10h]
  char v6; // [sp+24h] [bp-Ch]

  return a1
      && sscanf(a1, "%d.%d.%d.%d%c", &v2, &v3, &v4, &v5, &v6) == 4
      && v2 <= 0xFF
      && v3 <= 0xFF
      && v4 <= 0xFF
      && v5 <= 0xFF;
}

//----- (00041930) --------------------------------------------------------
int __fastcall generateWriteFifoProcess(void *a1)
{
  if ( !*((_DWORD *)a1 + 2) )
    FifoM3u8DataManager::writeFifoThread(
      *(FifoM3u8DataManager **)a1,
      *((_DWORD *)a1 + 1),
      (int (__cdecl *)(unsigned __int8 *, int))cbReadSource);
  return 0;
}

//----- (00041964) --------------------------------------------------------
int __fastcall ThirdM3U8Manager::freeThirdM3U8Manager(ThirdM3U8Manager *this)
{
  curlMulti *v1; // r5
  ThirdM3U8Manager *v2; // r4
  signed int v3; // r0
  int v4; // r0
  int v5; // r0
  void *v6; // r5
  int v7; // r0
  void *v8; // r5
  void *v9; // r0
  void *v10; // r0
  void *v11; // r0
  pthread_t v12; // r0

  v1 = (curlMulti *)*((_DWORD *)this + 30);
  v2 = this;
  *((_DWORD *)this + 2) = -1;
  if ( v1 )
  {
    curlMulti::~curlMulti(v1);
    operator delete((void *)v1);
    *((_DWORD *)v2 + 30) = 0;
  }
  v3 = *((_DWORD *)v2 + 12);
  if ( v3 > 0 )
  {
    pthread_join(v3, 0);
    *((_DWORD *)v2 + 12) = 0;
  }
  v4 = *((_DWORD *)v2 + 7);
  if ( v4 )
  {
    (*(void (**)(void))(*(_DWORD *)v4 + 4))();
    *((_DWORD *)v2 + 7) = 0;
  }
  v5 = *((_DWORD *)v2 + 9);
  if ( v5 )
  {
    (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *((_DWORD *)v2 + 9) = 0;
  }
  v6 = (void *)*((_DWORD *)v2 + 8);
  if ( v6 )
  {
    CurlWrapper::~CurlWrapper(*((CurlWrapper **)v2 + 8));
    operator delete(v6);
    *((_DWORD *)v2 + 8) = 0;
  }
  v7 = *((_DWORD *)v2 + 10);
  if ( v7 )
  {
    (*(void (**)(void))(*(_DWORD *)v7 + 4))();
    *((_DWORD *)v2 + 10) = 0;
  }
  if ( *(_DWORD *)v2 )
  {
    FifoM3u8DataManager::stopWriteThread(*(_DWORD *)v2);
    v8 = *(void **)v2;
    if ( *(_DWORD *)v2 )
    {
      FifoM3u8DataManager::~FifoM3u8DataManager(*(FifoM3u8DataManager **)v2);
      operator delete(v8);
      *(_DWORD *)v2 = 0;
    }
  }
  v9 = (void *)*((_DWORD *)v2 + 13);
  if ( v9 )
  {
    free(v9);
    *((_DWORD *)v2 + 13) = 0;
  }
  v10 = (void *)*((_DWORD *)v2 + 16);
  if ( v10 )
  {
    free(v10);
    *((_DWORD *)v2 + 16) = 0;
  }
  v11 = (void *)*((_DWORD *)v2 + 27);
  if ( 133956095 * ((*((_DWORD *)v2 + 28) - (signed int)v11) >> 2) )
  {
    *((_DWORD *)v2 + 27) = 0;
    *((_DWORD *)v2 + 28) = 0;
    *((_DWORD *)v2 + 29) = 0;
    if ( v11 )
      operator delete(v11);
  }
  v12 = *((_DWORD *)v2 + 15);
  if ( v12 )
  {
    pthread_join(v12, 0);
    *((_DWORD *)v2 + 15) = 0;
  }
  return pthread_mutex_destroy((pthread_mutex_t *)((char *)v2 + 44));
}

//----- (00041B00) --------------------------------------------------------
ThirdM3U8Manager *__fastcall ThirdM3U8Manager::~ThirdM3U8Manager(ThirdM3U8Manager *this)
{
  ThirdM3U8Manager *v1; // r4
  void *v2; // r0

  v1 = this;
  ThirdM3U8Manager::freeThirdM3U8Manager(this);
  v2 = (void *)*((_DWORD *)v1 + 27);
  if ( v2 )
    operator delete(v2);
  return v1;
}

//----- (00041B38) --------------------------------------------------------
signed int __fastcall ThirdM3U8Manager::hostnameToIp(ThirdM3U8Manager *this, char *a2)
{
  char *v2; // r5
  ThirdM3U8Manager *v3; // r8
  signed int result; // r0
  int v5; // r3
  int v6; // r3
  struct timeval *timeout; // r0
  int v8; // r7
  int v9; // [sp+Ch] [bp-144h]
  char v10; // [sp+10h] [bp-140h]
  char v11; // [sp+14h] [bp-13Ch]
  char s; // [sp+1Ch] [bp-134h]
  char v13; // [sp+9Ch] [bp-B4h]
  char v14; // [sp+11Ch] [bp-34h]

  v2 = a2;
  v3 = this;
  result = 1;
  if ( a2 )
  {
    if ( ares_library_init(1) || ares_init(&v9) )
    {
      result = 1;
    }
    else
    {
      if ( ares_inet_pton(2, v2, &v10, v5) == 1 )
      {
        ares_gethostbyaddr(v9, &v10, 4, 2, (void (__fastcall *)(int, signed int))sub_41778, (int)v2);
      }
      else if ( ares_inet_pton(10, v2, &v14, v6) == 1 )
      {
        ares_gethostbyaddr(v9, &v14, 16, 10, (void (__fastcall *)(int, signed int))sub_41778, (int)v2);
      }
      else
      {
        ares_gethostbyname(v9, v2, 2, (int)sub_41778, (int)v2);
      }
      while ( 1 )
      {
        memset(&s, 0, 0x80u);
        memset(&v13, 0, 0x80u);
        v8 = ares_fds(v9, (int)&s, (int)&v13);
        if ( !v8 )
          break;
        timeout = (struct timeval *)ares_timeout(v9, 0, &v11);
        select(v8, (fd_set *)&s, (fd_set *)&v13, 0, timeout);
        ares_process((int *)v9, (int)&s, (int)&v13);
      }
      if ( ipaddr )
        strcpy((char *)v3 + 68, &ipaddr);
      ares_destroy(v9);
      ares_library_cleanup();
      result = 0;
    }
  }
  return result;
}
// CE0BC: using guessed type int __fastcall ares_inet_pton(_DWORD, _DWORD, _DWORD, _DWORD);
// F4100: using guessed type char ipaddr;

//----- (00041D04) --------------------------------------------------------
int __fastcall ThirdM3U8Manager::ThirdM3U8ManagerRoutine(ThirdM3U8Manager *this, volatile int *a2)
{
  ThirdM3U8Manager *v2; // r4
  LibEventTaskScheduler *v3; // r0
  int v4; // r6
  const void *v5; // r1
  int v6; // r12
  unsigned int v7; // r12
  size_t v8; // r7
  int v9; // r8
  char *v10; // r3
  TaskScheduler *v11; // r1
  const char *v12; // r3
  CurlWrapper *v13; // r2
  ThirdM3U8Protocol *v14; // r3
  _DWORD *v15; // r0
  char *v17; // r0
  void *v18; // [sp+4h] [bp-24h]
  char *v19; // [sp+8h] [bp-20h]
  char *v20; // [sp+Ch] [bp-1Ch]

  v2 = this;
  v3 = LibEventTaskScheduler::createNew((ThirdM3U8Manager *)((char *)this + 8), a2);
  *((_DWORD *)v2 + 10) = v3;
  if ( v3 )
  {
    v4 = (int)v3;
  }
  else
  {
    ThirdM3U8Manager::freeThirdM3U8Manager(v2);
    v4 = *((_DWORD *)v2 + 10);
  }
  v5 = (const void *)*((_DWORD *)v2 + 27);
  v6 = *((_DWORD *)v2 + 28);
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v7 = -133956095 * ((v6 - (signed int)v5) >> 2);
  if ( v7 )
  {
    if ( v7 > 0x1FF007 )
      sub_BFA08();
    v9 = 2052 * v7;
    v17 = (char *)operator new(2052 * v7);
    v5 = (const void *)*((_DWORD *)v2 + 27);
    v7 = -133956095 * ((*((_DWORD *)v2 + 28) - (signed int)v5) >> 2);
    v8 = 4 * ((*((_DWORD *)v2 + 28) - (signed int)v5) >> 2);
    v10 = v17;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
  }
  v18 = v10;
  v20 = &v10[v9];
  v19 = v10;
  if ( v7 )
    v10 = (char *)memmove(v10, v5, v8);
  v19 = &v10[v8];
  v11 = CurlWrapper::createNew(v4, (int)&v18);
  *((_DWORD *)v2 + 8) = v11;
  if ( v18 )
  {
    operator delete(v18);
    v11 = (TaskScheduler *)*((_DWORD *)v2 + 8);
  }
  if ( !v11 )
  {
    ThirdM3U8Manager::freeThirdM3U8Manager(v2);
    v11 = (TaskScheduler *)*((_DWORD *)v2 + 8);
  }
  v13 = ThirdM3U8Protocol::createNew(*((ThirdM3U8Protocol **)v2 + 10), v11, *((CurlWrapper **)v2 + 13), v12);
  *((_DWORD *)v2 + 9) = v13;
  if ( !v13 )
  {
    ThirdM3U8Manager::freeThirdM3U8Manager(v2);
    v13 = (CurlWrapper *)*((_DWORD *)v2 + 9);
  }
  v15 = M3u8TSSource::createNew(*((M3u8TSSource **)v2 + 10), *((TaskScheduler **)v2 + 8), v13, v14);
  *((_DWORD *)v2 + 7) = v15;
  if ( !v15 )
    ThirdM3U8Manager::freeThirdM3U8Manager(v2);
  return (*(int (**)(void))(**((_DWORD **)v2 + 10) + 28))();
}

//----- (00041EBC) --------------------------------------------------------
int __fastcall ThirdthreadProcess(void *a1, volatile int *a2)
{
  ThirdM3U8Manager::ThirdM3U8ManagerRoutine((ThirdM3U8Manager *)a1, a2);
  return 0;
}

//----- (00041ECC) --------------------------------------------------------
int __fastcall ThirdM3U8Manager::clientStart(ThirdM3U8Manager *this)
{
  pthread_t *v1; // r4
  const char *v2; // r0
  int result; // r0
  int v4; // r5

  v1 = (pthread_t *)this;
  if ( *((_DWORD *)this + 2) )
    return -1;
  v2 = (const char *)*((_DWORD *)this + 13);
  if ( !v2 || !*v2 || strstr(v2, "streamInfo unuse") )
    return -1;
  result = pthread_create(v1 + 12, 0, (void *(*)(void *))ThirdthreadProcess, v1);
  v4 = result;
  if ( result )
  {
    ThirdM3U8Manager::freeThirdM3U8Manager((ThirdM3U8Manager *)v1);
    result = v4;
  }
  return result;
}

//----- (00041F50) --------------------------------------------------------
M3u8TSSource *__fastcall ThirdM3U8Manager::ReadSource(ThirdM3U8Manager *this, unsigned __int8 *a2, int a3)
{
  M3u8TSSource *result; // r0

  result = (M3u8TSSource *)*((_DWORD *)this + 7);
  if ( result )
    result = (M3u8TSSource *)M3u8TSSource::ReadCache(result, a2, a3);
  return result;
}

//----- (00041F60) --------------------------------------------------------
M3u8TSSource *__fastcall cbReadSource(unsigned __int8 *a1, int a2)
{
  return ThirdM3U8Manager::ReadSource((ThirdM3U8Manager *)gThirdM3U8Manager, a1, a2);
}
// F4130: using guessed type int gThirdM3U8Manager;

//----- (00041F80) --------------------------------------------------------
__int64 __fastcall ThirdM3U8Manager::getCurrentContinuousPieceBytes(ThirdM3U8Manager *this)
{
  double v1; // d7
  double v2; // d6
  signed int v3; // r3

  v1 = dbl_F4280[0];
  v2 = dbl_F4280[0] / 50000.0;
  *((double *)this + 2) = dbl_F4280[0];
  v3 = (signed int)v2;
  if ( !(signed int)v2 )
    v3 = 1;
  *((_DWORD *)this + 6) = v3;
  return *(_QWORD *)&v1;
}

//----- (00041FC8) --------------------------------------------------------
int __fastcall ThirdM3U8Manager::getCurrentContinuousPieceNum(ThirdM3U8Manager *this)
{
  return *((_DWORD *)this + 6);
}

//----- (00041FD0) --------------------------------------------------------
void __fastcall ThirdM3U8Manager::IoshostnameToIp(ThirdM3U8Manager *this, char *a2)
{
  struct addrinfo *v2; // r4
  size_t v3; // r0
  char *v4; // r3
  struct addrinfo *v5; // r0
  void *v6; // r0
  int v7; // r0
  unsigned int v8; // r0
  void *v9; // r4
  int v10; // r5
  ThirdM3U8Manager *v11; // [sp+14h] [bp-8CCh]
  struct addrinfo *ai; // [sp+1Ch] [bp-8C4h]
  void *v13; // [sp+20h] [bp-8C0h]
  void *dest; // [sp+24h] [bp-8BCh]
  void *v15; // [sp+28h] [bp-8B8h]
  struct addrinfo req; // [sp+2Ch] [bp-8B4h]
  int v17; // [sp+4Ch] [bp-894h]
  char s; // [sp+50h] [bp-890h]
  char v19; // [sp+B0h] [bp-830h]
  size_t v20; // [sp+8B0h] [bp-30h]

  v11 = this;
  if ( a2 )
  {
    req.ai_family = 0;
    req.ai_protocol = 0;
    req.ai_addrlen = 0;
    req.ai_addr = 0;
    req.ai_canonname = 0;
    req.ai_next = 0;
    v13 = 0;
    dest = 0;
    v15 = 0;
    req.ai_socktype = 1;
    req.ai_flags = 2;
    if ( getaddrinfo(a2, 0, &req, &ai) )
    {
      v6 = v13;
    }
    else
    {
      v2 = ai;
      if ( ai )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v17 = 0;
            memset(&s, 0, 0x60u);
            if ( !getnameinfo((const struct sockaddr *)v2->ai_canonname, v2->ai_addrlen, (char *)&v17, 0x64u, 0, 0, 2u) )
              break;
LABEL_5:
            v2 = v2->ai_next;
            if ( !v2 )
              goto LABEL_11;
          }
          strcpy(&v19, (const char *)&v17);
          v3 = strlen(&v19);
          v4 = (char *)dest;
          v20 = v3;
          if ( dest == v15 )
          {
            std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)&v13, (char *)dest, &v19);
            goto LABEL_5;
          }
          if ( dest )
            v4 = (char *)memcpy(dest, &v19, 0x804u);
          v2 = v2->ai_next;
          dest = v4 + 2052;
          if ( !v2 )
          {
LABEL_11:
            v5 = ai;
            goto LABEL_12;
          }
        }
      }
      v5 = ai;
LABEL_12:
      freeaddrinfo(v5);
      v6 = v13;
      if ( 133956095 * (((_BYTE *)dest - (_BYTE *)v13) >> 2) )
      {
        v7 = time(0);
        srand48(v7);
        v8 = lrand48();
        v9 = v13;
        v10 = -133956095 * (((_BYTE *)dest - (_BYTE *)v13) >> 2);
        strcpy((char *)v11 + 68, (const char *)v13 + 2052 * (v8 % (-133956095 * (((_BYTE *)dest - (_BYTE *)v13) >> 2))));
        if ( v10 )
        {
          v13 = 0;
          dest = 0;
          v15 = 0;
          if ( !v9 )
            return;
          operator delete(v9);
          v6 = v13;
        }
        else
        {
          v6 = v9;
        }
      }
    }
    if ( v6 )
      operator delete(v6);
  }
}

//----- (00042228) --------------------------------------------------------
int __fastcall ThirdM3U8Manager::getStreamUrl(ThirdM3U8Manager *this, char *a2)
{
  ThirdM3U8Manager *v2; // r9
  char *v3; // r0
  char *v4; // r0
  char *v5; // r0
  char v6; // r5
  char *v7; // r3
  unsigned __int8 *v8; // r0
  const char *v9; // r5
  int v10; // r4
  void *v11; // r0
  char *v13; // r0
  char v14; // r5
  char *v15; // r3
  int v16; // r0
  unsigned int v17; // r4
  int v18; // r2
  void *v19; // [sp+4h] [bp-83Ch]
  void *dest; // [sp+8h] [bp-838h]
  void *v21; // [sp+Ch] [bp-834h]
  char v22; // [sp+10h] [bp-830h]
  size_t v23; // [sp+810h] [bp-30h]
  int v24; // [sp+818h] [bp-28h]

  v2 = this;
  v3 = strstr(a2, "http://");
  v19 = 0;
  dest = 0;
  v21 = 0;
  if ( !v3 )
  {
    v10 = 0;
LABEL_12:
    strcpy(*((char **)v2 + 13), "streamInfo unuse");
    v11 = v19;
    goto LABEL_13;
  }
  v4 = strtok(v3, "\n");
  strcpy(&v22, v4);
  v5 = strchr(&v22, 13);
  v6 = (char)v5;
  if ( v5 )
  {
    v23 = strlen(&v22) - 1;
    *((_BYTE *)&v24 + v23 - 2056) = 0;
  }
  else
  {
    v23 = strlen(&v22);
    *((_BYTE *)&v24 + v23 - 2056) = v6;
  }
  v7 = (char *)dest;
  if ( dest == v21 )
  {
    std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)&v19, (char *)dest, &v22);
  }
  else
  {
    if ( dest )
      v7 = (char *)memcpy(dest, &v22, 0x804u);
    dest = v7 + 2052;
  }
  while ( 1 )
  {
    v8 = (unsigned __int8 *)strtok(0, "\n");
    v9 = (const char *)v8;
    if ( !v8 )
      break;
    if ( sub_41700(v8, "http://", 7u) )
    {
      strcpy(&v22, v9);
      v13 = strchr(&v22, 13);
      v14 = (char)v13;
      if ( v13 )
      {
        v23 = strlen(&v22) - 1;
        *((_BYTE *)&v24 + v23 - 2056) = 0;
      }
      else
      {
        v23 = strlen(&v22);
        *((_BYTE *)&v24 + v23 - 2056) = v14;
      }
      v15 = (char *)dest;
      if ( dest == v21 )
      {
        std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)&v19, (char *)dest, &v22);
      }
      else
      {
        if ( dest )
          v15 = (char *)memcpy(dest, &v22, 0x804u);
        dest = v15 + 2052;
      }
    }
  }
  v10 = -133956095 * (((_BYTE *)dest - (_BYTE *)v19) >> 2);
  if ( !v10 )
    goto LABEL_12;
  v16 = time(0);
  srand48(v16);
  v17 = 2052 * (lrand48() % (unsigned int)(-133956095 * (((_BYTE *)dest - (_BYTE *)v19) >> 2)));
  memcpy(*((void **)v2 + 13), (char *)v19 + v17, *(_DWORD *)((char *)v19 + v17 + 2048));
  v18 = *(_DWORD *)((char *)v19 + v17 + 2048);
  v10 = 1;
  *(_BYTE *)(*((_DWORD *)v2 + 13) + v18) = 0;
  v11 = v19;
  if ( 133956095 * (((_BYTE *)dest - (_BYTE *)v19) >> 2) )
  {
    v19 = 0;
    dest = 0;
    v21 = 0;
    if ( !v11 )
      return v10;
    operator delete(v11);
    v11 = v19;
  }
LABEL_13:
  if ( v11 )
    operator delete(v11);
  return v10;
}

//----- (00042570) --------------------------------------------------------
void __fastcall ThirdM3U8Manager::getRedirectUrl(ThirdM3U8Manager *this, char *a2)
{
  ThirdM3U8Manager *v2; // r4
  char *v3; // r10
  _BYTE *v4; // r5
  char *v5; // r7
  char *v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r11
  const void *v10; // r1
  unsigned int v11; // r3
  int v12; // r7
  int v13; // r9
  char *v14; // r12
  int v15; // r0
  int v16; // r1
  int *v17; // r2
  int v18; // r6
  int v19; // r0
  size_t v20; // r0
  char *v21; // r1
  char *v22; // r2
  int v23; // r3
  char *v24; // r1
  const char *v25; // r9
  size_t v26; // r7
  char *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char v30; // r6
  char *v31; // r0
  unsigned __int8 *v32; // r0
  char *v33; // r6
  const char *v34; // r6
  int v35; // r6
  char *v36; // r0
  char v37; // r9
  char *v38; // r0
  const char *v39; // r10
  size_t v40; // ST08_4
  char *v41; // r0
  int v42; // r10
  char *v43; // r0
  void *v44; // r10
  size_t v45; // r0
  size_t v46; // r0
  char *v47; // r2
  size_t v48; // r0
  size_t v49; // r0
  size_t v50; // r0
  char *v51; // r0
  char v52; // r7
  char *v53; // r0
  size_t v54; // r0
  bool v55; // zf
  void *v56; // r6
  size_t v57; // r0
  int v58; // r1
  int v59; // r6
  int v60; // r9
  char *v61; // r6
  int v62; // r3
  const void *v63; // r1
  int v64; // r2
  unsigned int v65; // r6
  char *v66; // r12
  int v67; // r7
  int v68; // r6
  int v69; // r6
  size_t v70; // r0
  char *v71; // [sp+14h] [bp-172Ch]
  char *v72; // [sp+14h] [bp-172Ch]
  char *haystack; // [sp+18h] [bp-1728h]
  char *haystacka; // [sp+18h] [bp-1728h]
  int v75; // [sp+1Ch] [bp-1724h]
  void *v76; // [sp+20h] [bp-1720h]
  int v77; // [sp+24h] [bp-171Ch]
  int v78; // [sp+28h] [bp-1718h]
  char *v79; // [sp+2Ch] [bp-1714h]
  char *v80; // [sp+30h] [bp-1710h]
  char *v81; // [sp+34h] [bp-170Ch]
  int v82; // [sp+38h] [bp-1708h]
  char *v83; // [sp+3Ch] [bp-1704h]
  char *v84; // [sp+40h] [bp-1700h]
  char v85[20]; // [sp+44h] [bp-16FCh]
  char v86[100]; // [sp+A8h] [bp-1698h]
  char s; // [sp+10Ch] [bp-1634h]
  char v88; // [sp+30Ch] [bp-1434h]
  int v89; // [sp+70Ch] [bp-1034h]
  size_t v90; // [sp+F0Ch] [bp-834h]
  char dest; // [sp+F10h] [bp-830h]
  char v92; // [sp+F17h] [bp-829h]
  _BYTE v93[3]; // [sp+F19h] [bp-827h]
  int v94; // [sp+F1Ch] [bp-824h]
  size_t v95; // [sp+1710h] [bp-30h]
  int v96; // [sp+1714h] [bp-2Ch]
  int v97; // [sp+1718h] [bp-28h]

  v2 = this;
  v3 = a2;
  v4 = malloc(0x100004u);
  memset(v4, 0, 0x100004u);
  memset(&s, 0, 0x200u);
  v5 = (char *)*((_DWORD *)v2 + 16);
  if ( sub_41700(*((unsigned __int8 **)v2 + 16), "m3u8://", 7u) )
  {
    strcpy((char *)&v89, v3);
    v90 = strlen(v3);
  }
  else
  {
    v25 = proxyUserAgent;
    strcpy((char *)&v89, proxyUserAgent);
    v90 = strlen(v25);
  }
  if ( sub_41700((unsigned __int8 *)v5, "m3u8proxy://", 0xCu) )
  {
    strcpy(&dest, v5);
    v50 = strlen(v5);
    memset(v5, 0, v50);
    strcpy(*((char **)v2 + 16), "http://");
    strcat(*((char **)v2 + 16), (const char *)&v94);
    v5 = (char *)*((_DWORD *)v2 + 16);
  }
  if ( sub_41700((unsigned __int8 *)v5, "m3u8://", 7u) )
  {
    strcpy(&dest, v5);
    v49 = strlen(v5);
    memset(v5, 0, v49);
    strcpy(*((char **)v2 + 16), "http://");
    strcat(*((char **)v2 + 16), &v92);
    v5 = (char *)*((_DWORD *)v2 + 16);
  }
  v6 = (char *)sub_41700((unsigned __int8 *)v5, "xproxy://", 9u);
  if ( v6 )
  {
    strcpy(&dest, v5);
    v48 = strlen(v5);
    memset(v5, 0, v48);
    strcpy(*((char **)v2 + 16), "http://");
    v6 = strcat(*((char **)v2 + 16), v93);
  }
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v9 = curl_easy_init((int)v6, v7, v8);
  std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)&v76, 0, (char *)&v89);
  v10 = v76;
  v80 = 0;
  v79 = 0;
  v81 = 0;
  v71 = (char *)*((_DWORD *)v2 + 30);
  v11 = -133956095 * ((v77 - (signed int)v76) >> 2);
  haystack = (char *)*((_DWORD *)v2 + 16);
  if ( v11 )
  {
    if ( v11 > 0x1FF007 )
      sub_BFA08();
    v13 = 4 * ((v77 - (signed int)v76) >> 2);
    v14 = (char *)operator new(4 * ((v77 - (signed int)v76) >> 2));
    v10 = v76;
    v11 = -133956095 * ((v77 - (signed int)v76) >> 2);
    v12 = 4 * ((v77 - (signed int)v76) >> 2);
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
  }
  v80 = v14;
  v81 = &v14[v13];
  v79 = v14;
  if ( v11 )
    v14 = (char *)memmove(v14, v10, v12);
  v80 = &v14[v12];
  v15 = curlMulti::curlDownload(v71, (int)haystack, v9, (int *)&v79, &s, (int)v4);
  v17 = &v97;
  v18 = v15;
  v19 = (int)v79;
  if ( v79 )
    operator delete(v79);
  if ( !v18 || !*v4 || *((_DWORD *)v4 + 0x40000) <= 3 )
  {
    strcpy(&dest, v3);
    v20 = strlen(v3);
    v21 = (char *)*((_DWORD *)v2 + 28);
    v22 = (char *)*((_DWORD *)v2 + 29);
    v95 = v20;
    if ( v21 == v22 )
    {
      std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)v2 + 108, v21, &dest);
    }
    else
    {
      if ( v21 )
      {
        memcpy(v21, &dest, 0x804u);
        v23 = *((_DWORD *)v2 + 28);
      }
      else
      {
        v23 = 0;
      }
      *((_DWORD *)v2 + 28) = v23 + 2052;
    }
    v24 = *(char **)"am no use";
    strcpy(*((char **)v2 + 13), "stream no use");
    goto LABEL_22;
  }
  if ( v9 )
    v19 = curl_easy_cleanup(v9, v16);
  v9 = curl_easy_init(v19, v16, (int)v17);
  if ( isNeedDecrypt(v4) )
  {
    v58 = *((_DWORD *)v4 + 0x40000) - 4;
    v82 = 0;
    v59 = decryptChunk(v4 + 4, v58, &v82);
    memmove(v4, &v4[v82 + 4], v59);
    v4[v59] = 0;
    *((_DWORD *)v4 + 0x40000) = v59;
  }
  else
  {
    v4[*((_DWORD *)v4 + 0x40000)] = 0;
  }
  if ( strstr(v4, "#EXT-HEADER:") )
  {
    v26 = *((_DWORD *)v4 + 0x40000);
    haystacka = (char *)malloc(v26 + 1);
    memset(haystacka, 0, v26);
    strcpy(haystacka, v4);
    v27 = strstr(haystacka, "#EXT-HEADER:");
    v28 = strtok(v27 + 12, "\n");
    strcpy(&dest, v28);
    v29 = strchr(&dest, 13);
    v30 = (char)v29;
    if ( v29 )
    {
      v95 = strlen(&dest) - 1;
      *((_BYTE *)&v97 + v95 - 2056) = 0;
    }
    else
    {
      v95 = strlen(&dest);
      *((_BYTE *)&v97 + v95 - 2056) = v30;
    }
    v31 = (char *)*((_DWORD *)v2 + 28);
    v75 = (int)v2 + 108;
    if ( v31 == *((char **)v2 + 29) )
    {
      std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux(v75, v31, &dest);
    }
    else
    {
      if ( v31 )
      {
        memcpy(v31, &dest, 0x804u);
        v31 = (char *)*((_DWORD *)v2 + 28);
      }
      *((_DWORD *)v2 + 28) = v31 + 2052;
    }
    while ( 1 )
    {
      v32 = (unsigned __int8 *)strtok(0, "\n");
      v12 = (int)v32;
      if ( !v32 )
        break;
      if ( sub_41700(v32, "#EXT-HEADER:", 0xCu) )
      {
        strcpy(&dest, (const char *)(v12 + 12));
        v51 = strchr(&dest, 13);
        v52 = (char)v51;
        if ( v51 )
        {
          v95 = strlen(&dest) - 1;
          *((_BYTE *)&v97 + v95 - 2056) = 0;
        }
        else
        {
          v95 = strlen(&dest);
          *((_BYTE *)&v97 + v95 - 2056) = v52;
        }
        v53 = (char *)*((_DWORD *)v2 + 28);
        if ( v53 == *((char **)v2 + 29) )
        {
          std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux(v75, *((char **)v2 + 28), &dest);
        }
        else
        {
          if ( v53 )
          {
            memcpy(v53, &dest, 0x804u);
            v53 = (char *)*((_DWORD *)v2 + 28);
          }
          *((_DWORD *)v2 + 28) = v53 + 2052;
        }
      }
    }
    if ( haystacka )
      free(haystacka);
  }
  v33 = (char *)*((_DWORD *)v2 + 28);
  if ( !(133956095 * ((signed int)&v33[-*((_DWORD *)v2 + 27)] >> 2)) || !strstr(v4, "User-Agent: ") )
  {
    v12 = (int)&dest;
    strcpy(&dest, v3);
    v54 = strlen(v3);
    v55 = v33 == *((char **)v2 + 29);
    v95 = v54;
    if ( v55 )
    {
      std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)v2 + 108, v33, &dest);
    }
    else
    {
      if ( v33 )
      {
        memcpy(v33, &dest, 0x804u);
        v33 = (char *)*((_DWORD *)v2 + 28);
      }
      *((_DWORD *)v2 + 28) = v33 + 2052;
    }
  }
  v34 = (const char *)*((_DWORD *)v2 + 16);
  if ( strcmp(*((const char **)v2 + 16), &s) )
    goto LABEL_76;
  if ( strstr(v4, "#EXT-X-STREAM-INF") )
  {
    if ( ThirdM3U8Manager::getStreamUrl(v2, v4) )
    {
      v35 = *((_DWORD *)v2 + 13);
      v36 = strstr(*((const char **)v2 + 13), "streaminfo unuse");
      v37 = (char)v36;
      if ( !v36 )
      {
        v12 = (int)v85;
        memset(v85, 0, 0x64u);
        v38 = strchr((const char *)(v35 + 7), 47);
        v39 = v38;
        v40 = (size_t)&v38[-v35 - 7];
        memcpy(v86, (const void *)(v35 + 7), v40);
        v86[v40] = v37;
        v41 = strchr(v86, 58);
        if ( v41 )
        {
          v42 = v41 - v86;
          memcpy(v85, v86, v41 - v86);
          v85[v42] = v37;
          v43 = strchr((const char *)(v35 + 7), 58);
          strcpy(&v88, v43);
        }
        else
        {
          strcpy(v85, v86);
          strcpy(&v88, v39);
        }
        if ( v85[0] )
        {
          if ( !checkIp(v85) )
          {
            ThirdM3U8Manager::hostnameToIp(v2, v85);
            if ( *((_BYTE *)v2 + 68) )
            {
              v44 = (void *)*((_DWORD *)v2 + 13);
              v12 = (int)&dest;
              v45 = strlen(*((const char **)v2 + 13));
              memset(v44, 0, v45);
              sprintf(*((char **)v2 + 13), "%s%s%s", "http://", (char *)v2 + 68, &v88);
              sprintf(&dest, "Host: %s", v86);
              v46 = strlen(&dest);
              v24 = (char *)*((_DWORD *)v2 + 28);
              v47 = (char *)*((_DWORD *)v2 + 29);
              v95 = v46;
              if ( v24 == v47 )
                goto LABEL_101;
              if ( v24 )
              {
                memcpy(v24, &dest, 0x804u);
                v24 = (char *)*((_DWORD *)v2 + 28);
              }
              *((_DWORD *)v2 + 28) = v24 + 2052;
            }
          }
        }
      }
    }
    goto LABEL_22;
  }
  if ( !strstr(v4, "#EXT-X-STREAM-REDIRECT") )
  {
    strcpy(*((char **)v2 + 13), v34);
    goto LABEL_22;
  }
  if ( ThirdM3U8Manager::getStreamUrl(v2, v4) )
  {
    v60 = *((_DWORD *)v2 + 13);
    v61 = strstr(*((const char **)v2 + 13), "streaminfo unuse");
    if ( !v61 )
    {
      memset(&s, 0, 0x200u);
      v62 = *((_DWORD *)v2 + 28);
      v63 = (const void *)*((_DWORD *)v2 + 27);
      v72 = (char *)*((_DWORD *)v2 + 30);
      v64 = (v62 - (signed int)v63) >> 2;
      v82 = 0;
      v83 = 0;
      v84 = 0;
      v65 = -133956095 * v64;
      if ( -133956095 * v64 )
      {
        if ( v65 > 0x1FF007 )
          sub_BFA08();
        v67 = 133956096 * v64;
        v66 = (char *)operator new(4 * v64);
        v62 = *((_DWORD *)v2 + 28);
        v63 = (const void *)*((_DWORD *)v2 + 27);
      }
      else
      {
        v66 = 0;
        v67 = -133956095 * v64;
      }
      v82 = (int)v66;
      v84 = &v66[4 * (v67 + v65)];
      v68 = -133956095 * ((v62 - (signed int)v63) >> 2);
      v83 = v66;
      if ( v68 )
      {
        v12 = 133956096 * ((v62 - (signed int)v63) >> 2);
        v66 = (char *)memmove(v66, v63, 4 * ((v62 - (signed int)v63) >> 2));
      }
      else
      {
        v12 = 0;
      }
      v83 = &v66[4 * (v12 + v68)];
      v69 = curlMulti::curlDownload(v72, v60, v9, &v82, &s, 0);
      if ( v82 )
        operator delete((void *)v82);
      if ( !v69 )
      {
        v12 = *((_DWORD *)v2 + 13);
        v70 = strlen(*((const char **)v2 + 13));
        memset((void *)v12, 0, v70);
        v24 = *(char **)"aminfo unuse";
        strcpy(*((char **)v2 + 13), "streaminfo unuse");
        goto LABEL_22;
      }
      v56 = (void *)*((_DWORD *)v2 + 13);
      v57 = strlen(*((const char **)v2 + 13));
      memset(v56, 0, v57);
LABEL_76:
      strcpy(*((char **)v2 + 13), &s);
      goto LABEL_22;
    }
  }
  while ( 1 )
  {
LABEL_22:
    curl_easy_cleanup(v9, (int)v24);
    curl_global_cleanup();
    if ( v4 )
      free(v4);
    if ( v76 )
      operator delete(v76);
    if ( v96 == _stack_chk_guard )
      break;
LABEL_101:
    std::vector<tagInfo,std::allocator<tagInfo>>::_M_insert_aux((int)v2 + 108, v24, (char *)v12);
  }
}
// F30D4: using guessed type char *proxyUserAgent;
// 42570: using guessed type char var_16FC[20];
// 42570: using guessed type char var_1698[100];

//----- (000432B0) --------------------------------------------------------
ThirdM3U8Manager *__fastcall ThirdM3U8Manager::ThirdM3U8Manager(ThirdM3U8Manager *this, char *a2, int a3, char *a4, char *a5)
{
  ThirdM3U8Manager *v5; // r4
  char *v6; // r6
  int v7; // r7
  void *v8; // r0
  void *v9; // r0
  curlMulti *v10; // r5
  void *v12; // r5

  v5 = this;
  *((_DWORD *)this + 27) = 0;
  v6 = a4;
  *((_DWORD *)this + 28) = 0;
  v7 = a3;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 15) = 0;
  v8 = malloc(0x800u);
  *((_DWORD *)v5 + 13) = v8;
  memset(v8, 0, 0x800u);
  v9 = malloc(0x800u);
  *((_DWORD *)v5 + 16) = v9;
  memset(v9, 0, 0x800u);
  memset((char *)v5 + 68, 0, 0x28u);
  v10 = (curlMulti *)operator new(8u);
  curlMulti::curlMulti(v10);
  *((_DWORD *)v5 + 30) = v10;
  pthread_mutex_init((pthread_mutex_t *)((char *)v5 + 44), 0);
  strcpy(*((char **)v5 + 16), v6);
  if ( !**((_BYTE **)v5 + 16) )
    return v5;
  ThirdM3U8Manager::getRedirectUrl(v5, a5);
  if ( !strcmp(*((const char **)v5 + 13), "streamInfo unuse") )
  {
    *(_DWORD *)v5 = 0;
    *((_DWORD *)v5 + 2) = -1;
    gThirdM3U8Manager = 0;
  }
  else
  {
    *((_DWORD *)v5 + 1) = v7;
    gThirdM3U8Manager = (int)v5;
    v12 = operator new(0x10u);
    FifoM3u8DataManager::FifoM3u8DataManager((int)v12);
    *(_DWORD *)v5 = v12;
  }
  return v5;
}
// F4130: using guessed type int gThirdM3U8Manager;

//----- (00043410) --------------------------------------------------------
M3u8TSSource *__fastcall M3u8TSSource::~M3u8TSSource(M3u8TSSource *this)
{
  M3u8TSSource *v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  _DWORD *v6; // r0
  _DWORD *v7; // r4
  _DWORD *v8; // r0
  _DWORD *v9; // r4
  M3u8TSSource *result; // r0

  v1 = this;
  v2 = (_DWORD *)*((_DWORD *)this + 4);
  *(_DWORD *)v1 = off_F01D8;
  if ( v2 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      free(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = (_DWORD *)*((_DWORD *)v1 + 6);
  if ( v4 )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      free(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = (_DWORD *)*((_DWORD *)v1 + 8);
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      free(v6);
      v6 = v7;
    }
    while ( v7 );
  }
  v8 = (_DWORD *)*((_DWORD *)v1 + 9);
  if ( v8 )
  {
    do
    {
      v9 = (_DWORD *)*v8;
      free(v8);
      v8 = v9;
    }
    while ( v9 );
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 4));
  result = v1;
  --M3u8TSSource::nTSSource;
  return result;
}
// F01D8: using guessed type _DWORD (__fastcall *[2])(M3u8TSSource *__hidden this);
// F4138: using guessed type int M3u8TSSource::nTSSource;

//----- (000434D4) --------------------------------------------------------
M3u8TSSource *__fastcall M3u8TSSource::~M3u8TSSource(M3u8TSSource *this)
{
  M3u8TSSource *v1; // r4

  v1 = this;
  M3u8TSSource::~M3u8TSSource(this);
  operator delete((void *)v1);
  return v1;
}

//----- (000434F0) --------------------------------------------------------
signed __int64 hls_gettime(void)
{
  int v1; // [sp+0h] [bp-10h]
  int v2; // [sp+4h] [bp-Ch]

  gettimeofday((struct timeval *)&v1, 0);
  return 1000000LL * v1 + v2;
}

//----- (00043524) --------------------------------------------------------
__int64 __fastcall M3u8TSSource::echoDownloadTime(M3u8TSSource *this)
{
  return *((_QWORD *)this + 16);
}

//----- (0004352C) --------------------------------------------------------
_DWORD *__fastcall M3u8TSSource::M3u8TSSource(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // r4
  signed __int64 v5; // r0
  _DWORD *v6; // r3
  signed int v7; // r2

  a1[2] = a3;
  a1[3] = a4;
  v4 = a1;
  a1[11] = 1;
  *a1 = off_F01D8;
  a1[16] = a2;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[12] = 0;
  a1[17] = 0;
  v5 = hls_gettime();
  v6 = v4;
  v7 = 5;
  v4[30] = 0;
  v4[32] = 0;
  v4[33] = 0;
  *((_QWORD *)v4 + 9) = v5;
  do
  {
    --v7;
    v6[20] = 0;
    v6[21] = 0;
    v6 += 2;
  }
  while ( v7 );
  pthread_mutex_init((pthread_mutex_t *)(v4 + 1), 0);
  ThirdM3U8Protocol::ThirdgetNextUrl(v4[3], (void (__cdecl *)(void *, char *))M3u8TSSource::processTSUrl, v4);
  return v4;
}
// F01D8: using guessed type _DWORD (__fastcall *off_F01D8[2])(M3u8TSSource *__hidden this);

//----- (000435F0) --------------------------------------------------------
_DWORD *__fastcall M3u8TSSource::createNew(M3u8TSSource *this, TaskScheduler *a2, CurlWrapper *a3, ThirdM3U8Protocol *a4)
{
  M3u8TSSource *v4; // r7
  TaskScheduler *v5; // r6
  CurlWrapper *v6; // r5
  _DWORD *v7; // r4

  v4 = this;
  v5 = a2;
  v6 = a3;
  if ( M3u8TSSource::nTSSource )
    return 0;
  M3u8TSSource::nTSSource = 1;
  v7 = operator new(0x88u);
  M3u8TSSource::M3u8TSSource(v7, (int)v4, (int)v5, (int)v6);
  return v7;
}
// F4138: using guessed type int M3u8TSSource::nTSSource;

//----- (00043658) --------------------------------------------------------
int __fastcall M3u8TSSource::ReadCache(M3u8TSSource *this, unsigned __int8 *a2, int a3)
{
  M3u8TSSource *v3; // r6
  int v4; // r9
  unsigned __int8 *v5; // r11
  int *v7; // r4
  int v8; // r3
  size_t v9; // r5
  char *v10; // r1
  int v11; // r7
  int v12; // r3
  unsigned __int8 *v13; // r0
  int v14; // r3
  int v15; // r3
  bool v16; // zf
  pthread_mutex_t *mutex; // [sp+4h] [bp-2Ch]

  v3 = this;
  v4 = a3;
  v5 = a2;
  if ( *((_DWORD *)this + 7) < (unsigned int)a3 )
    return 0;
  mutex = (pthread_mutex_t *)((char *)this + 4);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 4));
  if ( v4 > 0 )
  {
    v7 = (int *)*((_DWORD *)v3 + 4);
    if ( v7 )
    {
      v8 = v7[51202];
      v9 = v7[51201] - v8;
      v10 = (char *)v7 + v8 + 4;
      if ( v7[51201] != v8 )
      {
        v11 = v4;
        while ( 1 )
        {
          if ( v9 >= v11 )
            v9 = v11;
          v13 = v5;
          v11 -= v9;
          v5 += v9;
          memcpy(v13, v10, v9);
          v14 = v9 + v7[51202];
          *((_DWORD *)v3 + 7) -= v9;
          v7[51202] = v14;
          if ( v14 == 204800 )
          {
            v15 = *v7;
            v16 = *v7 == 0;
            *((_DWORD *)v3 + 4) = *v7;
            if ( v16 )
              *((_DWORD *)v3 + 5) = v15;
            *v7 = *((_DWORD *)v3 + 6);
            *((_DWORD *)v3 + 6) = v7;
            if ( v11 <= 0 )
              break;
          }
          else if ( v11 <= 0 )
          {
            break;
          }
          v7 = (int *)*((_DWORD *)v3 + 4);
          if ( v7 )
          {
            v12 = v7[51202];
            v9 = v7[51201] - v12;
            v10 = (char *)v7 + v12 + 4;
            if ( v7[51201] != v12 )
              continue;
          }
          break;
        }
      }
    }
  }
  pthread_mutex_unlock(mutex);
  return v4;
}

//----- (0004377C) --------------------------------------------------------
int __fastcall M3u8TSSource::Rewind(M3u8TSSource *this, int a2)
{
  M3u8TSSource *v2; // r3
  int v3; // r1
  int result; // r0

  v2 = this;
  v3 = *((_DWORD *)this + 7) + a2;
  *(_DWORD *)(*((_DWORD *)this + 4) + 204808) = 0;
  result = 0;
  *((_DWORD *)v2 + 7) = v3;
  return result;
}

//----- (000437B0) --------------------------------------------------------
unsigned int __fastcall M3u8TSSource::PeekCache(M3u8TSSource *this, unsigned __int8 *a2, int a3)
{
  M3u8TSSource *v3; // r5
  _DWORD *v4; // r8
  unsigned __int8 *v5; // r7
  unsigned int v6; // r6
  int v7; // r3
  pthread_mutex_t *v9; // r11
  char *v10; // r1
  size_t v11; // r4
  int v12; // r5
  unsigned int v13; // r9

  v3 = this;
  v4 = (_DWORD *)*((_DWORD *)this + 4);
  v5 = a2;
  v6 = a3;
  if ( !v4 )
    return 0;
  if ( *((_DWORD *)this + 7) >= (unsigned int)a3 )
  {
    v7 = ioAllow;
  }
  else
  {
    while ( 1 )
    {
      v7 = ioAllow;
      if ( ioAllow != 1 )
        break;
      usleep(0x186A0u);
      if ( *((_DWORD *)v3 + 7) >= v6 )
      {
        if ( !ioAllow )
          return 0;
        goto LABEL_9;
      }
    }
  }
  if ( !v7 )
    return 0;
LABEL_9:
  v9 = (pthread_mutex_t *)((char *)v3 + 4);
  pthread_mutex_lock((pthread_mutex_t *)((char *)v3 + 4));
  if ( v6 )
  {
    v10 = (char *)(v4 + 1);
    v11 = v4[51201];
    if ( v6 < v11 )
      v11 = v6;
    if ( v11 )
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v12 += v11;
        v13 += v11;
        memcpy(v5, v10, v11);
        v5 += v11;
        if ( v12 == 204800 )
        {
          v4 = (_DWORD *)*v4;
          v12 = 0;
        }
        if ( v13 >= v6 )
          break;
        v10 = (char *)v4 + v12 + 4;
        v11 = v4[51201] - v12;
        if ( v11 >= v6 )
          v11 = v6;
      }
      while ( v11 );
    }
  }
  pthread_mutex_lock(v9);
  return v6;
}
// F41C4: using guessed type int ioAllow;

//----- (000438D8) --------------------------------------------------------
signed __int64 __fastcall M3u8TSSource::SeekCache(M3u8TSSource *this, int a2, unsigned __int64 a3)
{
  return 1LL;
}

//----- (000438E4) --------------------------------------------------------
int __fastcall M3u8TSSource::CacheIt(M3u8TSSource *this, char *a2, unsigned int a3)
{
  M3u8TSSource *v3; // r6
  unsigned int v4; // r7
  char *v5; // r10
  _DWORD *v6; // r1
  int v7; // r5
  _DWORD *v8; // r4
  unsigned int v9; // r0
  unsigned int v10; // r2
  size_t v11; // r5
  char *v12; // r1
  int v13; // r2
  pthread_mutex_t *mutex; // [sp+4h] [bp-2Ch]

  v3 = this;
  v4 = a3;
  mutex = (pthread_mutex_t *)((char *)this + 4);
  v5 = a2;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 4));
  for ( ; v4; *((_DWORD *)v3 + 7) = v13 + v11 )
  {
    v7 = *((_DWORD *)v3 + 4);
    if ( !v7 || (v8 = (_DWORD *)*((_DWORD *)v3 + 5), v9 = v8[51201], v10 = 204800 - v9, v9 > 0x31FFF) )
    {
      v8 = (_DWORD *)*((_DWORD *)v3 + 6);
      if ( v8 )
        *((_DWORD *)v3 + 6) = *v8;
      else
        v8 = malloc(0x3200Cu);
      v9 = 0;
      v10 = 204800;
      if ( v7 )
        v6 = (_DWORD *)*((_DWORD *)v3 + 5);
      else
        v9 = 0;
      *v8 = 0;
      v8[51201] = 0;
      v8[51202] = 0;
      if ( v7 )
      {
        *v6 = v8;
      }
      else
      {
        *((_DWORD *)v3 + 5) = v8;
        *((_DWORD *)v3 + 4) = v8;
      }
      if ( v7 )
        *((_DWORD *)v3 + 5) = v8;
    }
    if ( v10 >= v4 )
      v11 = v4;
    else
      v11 = v10;
    v12 = v5;
    v5 += v11;
    memcpy((char *)v8 + v9 + 4, v12, v11);
    v13 = *((_DWORD *)v3 + 7);
    v4 -= v11;
    v6 = (_DWORD *)(v11 + v8[51201]);
    v8[51201] = v6;
  }
  pthread_mutex_unlock(mutex);
  return 0;
}

//----- (00043A04) --------------------------------------------------------
unsigned int __fastcall tswrite_cb(char *a1, unsigned int a2, unsigned int a3, void *a4)
{
  char *v4; // r5
  unsigned int v5; // r4
  M3u8TSSource *v6; // r6

  v4 = a1;
  v5 = a3 * a2;
  v6 = (M3u8TSSource *)*((_DWORD *)a4 + 2);
  addXcdbBytes(a3 * a2);
  if ( firstRecvData )
  {
    firstRecvData = 0;
    sendEventToPlayer(2);
  }
  M3u8TSSource::CacheIt(v6, v4, v5);
  return v5;
}
// F3958: using guessed type int firstRecvData;

//----- (00043A5C) --------------------------------------------------------
void __fastcall M3u8TSSource::ProcessError(_DWORD *a1, int a2)
{
  int v2; // r2
  unsigned int v3; // r3
  _DWORD *v4; // r4
  int *v5; // r0
  int v6; // r1

  v2 = a1[11];
  v3 = a1[10] + 1;
  v4 = a1;
  a1[10] = v3;
  a1[11] = v2 - 1;
  if ( v3 > 0xA )
  {
    notifyPlayerToChangeSource(6);
  }
  else
  {
    v5 = (int *)a1[16];
    v4[17] = a2;
    v6 = *v5;
    v4[11] = v2;
    v4[15] = (*(int (__cdecl **)(int *, _DWORD))(v6 + 8))(v5, *(_DWORD *)(v6 + 8));
  }
}

//----- (00043AD8) --------------------------------------------------------
int __fastcall downloadTSFragError_cb(void *a1)
{
  M3u8TSSource::ProcessError(*((_DWORD **)a1 + 2), (int)a1);
  return 0;
}

//----- (00043AF0) --------------------------------------------------------
int __fastcall M3u8TSSource::recycleHttpItem(int result, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r3
  int v4; // r3

  v2 = *a2;
  v3 = (_DWORD *)a2[1];
  if ( v3 )
  {
    *v3 = v2;
    v2 = *a2;
  }
  else
  {
    *(_DWORD *)(result + 32) = v2;
  }
  if ( v2 )
    *(_DWORD *)(v2 + 4) = v3;
  v4 = *(_DWORD *)(result + 36);
  if ( v4 )
  {
    *a2 = v4;
    v2 = 0;
  }
  else
  {
    *(_DWORD *)(result + 36) = a2;
  }
  if ( v4 )
    a2[1] = v2;
  else
    a2[1] = 0;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = a2;
    *(_DWORD *)(result + 36) = a2;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

//----- (00043B38) --------------------------------------------------------
int __fastcall M3u8TSSource::finishOneTSDownload(int a1, int a2)
{
  int v2; // r4
  int result; // r0

  v2 = a1;
  ++*(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 40) = 0;
  result = M3u8TSSource::recycleHttpItem(a1, (int *)(a2 - 8));
  if ( *(_DWORD *)(v2 + 44) == 1 )
  {
    result = (*(int (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v2 + 64) + 8))(
               *(_DWORD *)(v2 + 64),
               *(_DWORD *)(**(_DWORD **)(v2 + 64) + 8));
    *(_DWORD *)(v2 + 60) = result;
  }
  else
  {
    --*(_DWORD *)(v2 + 44);
  }
  return result;
}

//----- (00043BA8) --------------------------------------------------------
int __fastcall processTSFrag_cb(void *a1)
{
  M3u8TSSource::finishOneTSDownload(*((_DWORD *)a1 + 2), (int)a1);
  return 0;
}

//----- (00043BC0) --------------------------------------------------------
int __fastcall M3u8TSSource::processTSUrl1(M3u8TSSource *this, char *a2)
{
  int *v2; // r2
  M3u8TSSource *v3; // r4
  char *v4; // r5
  int v5; // r3
  bool v6; // zf
  int v7; // r3

  v2 = (int *)*((_DWORD *)this + 9);
  v3 = this;
  v4 = a2;
  if ( v2 )
  {
    v5 = *v2;
    v6 = *v2 == 0;
    *((_DWORD *)this + 9) = *v2;
    if ( !v6 )
      *(_DWORD *)(v5 + 4) = 0;
  }
  else
  {
    v2 = (int *)calloc(1u, 0x990u);
  }
  v7 = *((_DWORD *)v3 + 8);
  v2[4] = (int)v3;
  *v2 = 0;
  v2[1] = 0;
  if ( v7 )
    *v2 = v7;
  if ( v7 )
    *(_DWORD *)(v7 + 4) = v2;
  *((_DWORD *)v3 + 8) = v2;
  return CurlWrapper::new_session(
           *((int **)v3 + 2),
           v4,
           (int)(v2 + 2),
           (int)tswrite_cb,
           (int)processTSFrag_cb,
           (int)downloadTSFragError_cb);
}

//----- (00043C70) --------------------------------------------------------
int __fastcall M3u8TSSource::downloadTS1(M3u8TSSource *this)
{
  return ThirdM3U8Protocol::ThirdgetNextUrl(
           *((_DWORD *)this + 3),
           (void (__cdecl *)(void *, char *))M3u8TSSource::processTSUrl,
           (void *)this);
}

//----- (00043C8C) --------------------------------------------------------
void __fastcall M3u8TSSource::reDownloadTS1(int a1, _DWORD *a2)
{
  int v2; // r6
  int v3; // r4
  const char *v4; // r0
  char *v5; // r5

  v2 = a1;
  v3 = (int)a2;
  v4 = (const char *)CurlWrapper::getUrlFromHttpInfo(a2);
  if ( v4 )
  {
    v5 = strdup(v4);
    CurlWrapper::new_session(
      *(int **)(v2 + 8),
      v5,
      v3,
      (int)tswrite_cb,
      (int)processTSFrag_cb,
      (int)downloadTSFragError_cb);
    free(v5);
  }
}

//----- (00043D08) --------------------------------------------------------
void __fastcall reDownloadTS(void *a1)
{
  _DWORD *v1; // r1

  v1 = (_DWORD *)*((_DWORD *)a1 + 17);
  *((_DWORD *)a1 + 17) = 0;
  M3u8TSSource::reDownloadTS1((int)a1, v1);
}

//----- (00043D18) --------------------------------------------------------
unsigned int __fastcall write_data(void *src, unsigned int a2, unsigned int a3, void *a4)
{
  unsigned int v4; // r5
  _DWORD *v5; // r4
  unsigned int result; // r0

  v4 = a3 * a2;
  v5 = a4;
  memcpy((char *)a4 + *((_DWORD *)a4 + 0x40000), src, a3 * a2);
  result = v4;
  v5[0x40000] += v4;
  return result;
}

//----- (00043D50) --------------------------------------------------------
curlMulti *__fastcall curlMulti::curlMulti(curlMulti *this)
{
  curlMulti *v1; // r4

  v1 = this;
  *((_DWORD *)this + 1) = 0;
  curl_global_init(3);
  *(_DWORD *)v1 = curl_multi_init();
  return v1;
}

//----- (00043D78) --------------------------------------------------------
int __fastcall curlMulti::curlDownload(char *dest, int a2, int a3, int *a4, char *desta, int a6)
{
  int *v6; // r6
  int v7; // r4
  int v8; // r3
  int *v9; // r5
  char *v10; // r7
  int v11; // r9
  int *v12; // r0
  _DWORD *v13; // r0
  int v14; // r0
  signed int v15; // r4
  int v17; // [sp+10h] [bp-1C8h]
  char *src; // [sp+18h] [bp-1C0h]
  int v19; // [sp+1Ch] [bp-1BCh]
  struct timeval timeout; // [sp+20h] [bp-1B8h]
  struct timeval v21; // [sp+28h] [bp-1B0h]
  char v22; // [sp+30h] [bp-1A8h]
  char v23; // [sp+B0h] [bp-128h]
  fd_set v24; // [sp+130h] [bp-A8h]

  v6 = a4;
  v7 = *a4;
  v8 = a4[1];
  v9 = 0;
  v10 = dest;
  v11 = a2;
  v17 = a3;
  src = 0;
  if ( v7 != v8 )
  {
    v12 = 0;
    do
    {
      v12 = curl_slist_append((int)v12, v7);
      v7 += 2052;
    }
    while ( v7 != v6[1] );
    v9 = v12;
  }
  curl_easy_setopt(v17, 0x2712u, v11);
  curl_easy_setopt(v17, 0x2Au, 0);
  curl_easy_setopt(v17, 0x34u, 1);
  curl_easy_setopt(v17, 0xDu, 3);
  if ( a6 )
  {
    curl_easy_setopt(v17, 0x4E2Bu, write_data);
    curl_easy_setopt(v17, 0x2711u, a6);
  }
  if ( v9 )
    curl_easy_setopt(v17, 0x2727u, v9);
  curl_multi_add_handle(*(_DWORD **)v10, v17);
  while ( 1 )
  {
    v19 = -1;
    memset(&v22, 0, 0x80u);
    memset(&v23, 0, 0x80u);
    memset(&v24, 0, 0x80u);
    v13 = *(_DWORD **)v10;
    timeout.tv_sec = 0;
    timeout.tv_usec = 300000;
    if ( curl_multi_fdset(v13, (int)&v22, (int)&v23, (int)&v24, &v19) )
      break;
    if ( v19 == -1 )
    {
      v21.tv_sec = 0;
      v21.tv_usec = 100000;
      v14 = select(0, 0, 0, 0, &v21);
    }
    else
    {
      v14 = select(v19 + 1, (fd_set *)&v22, (fd_set *)&v23, &v24, &timeout);
    }
    if ( v14 != -1 )
      curl_multi_perform(*(_DWORD **)v10, (_DWORD *)v10 + 1);
    if ( !*((_DWORD *)v10 + 1) || interrupt )
    {
      if ( !interrupt )
      {
        curl_easy_getinfo(v17, 0x100001u, &src);
        v24.__fds_bits[0] = 0;
        v15 = curl_easy_getinfo(v17, 0x200002u, &v24);
        curl_multi_remove_handle(*(_DWORD **)v10, v17);
        if ( !v15 && (unsigned int)(v24.__fds_bits[0] - 200) <= 0x6B && src )
        {
          strcpy(desta, src);
          return 1;
        }
      }
      return 0;
    }
  }
  return 0;
}
// F5718: using guessed type int interrupt;

//----- (00044028) --------------------------------------------------------
void __fastcall curlMulti::curlCleanup(curlMulti *this)
{
  curlMulti *v1; // r4
  int v2; // r0

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( v2 )
  {
    curl_multi_cleanup(v2);
    *(_DWORD *)v1 = 0;
  }
  j_curl_global_cleanup();
}

//----- (00044050) --------------------------------------------------------
curlMulti *__fastcall curlMulti::~curlMulti(curlMulti *this)
{
  curlMulti *v1; // r4

  v1 = this;
  curlMulti::curlCleanup(this);
  return v1;
}

//----- (00044064) --------------------------------------------------------
signed int __fastcall sub_44064(unsigned __int8 *a1, const char *a2, size_t a3)
{
  unsigned __int8 *v3; // r5
  size_t v4; // r6
  const char *v5; // r4
  size_t v6; // r0
  unsigned __int8 *v7; // r3
  const char *v8; // r1
  int v9; // r0
  int v10; // r12
  int v11; // t1
  int v12; // t1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = strlen(a2);
  if ( v6 <= v4 )
  {
    if ( !v6 )
      return 1;
    if ( *v3 == *(unsigned __int8 *)v5 )
    {
      v7 = v3;
      v8 = v5;
      v9 = (int)&v3[v6 - 1];
      while ( v7 != (unsigned __int8 *)v9 )
      {
        v11 = (v7++)[1];
        v10 = v11;
        v12 = *((unsigned __int8 *)v8++ + 1);
        if ( v10 != v12 )
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (000440DC) --------------------------------------------------------
M3U8Protocol *__fastcall M3U8Protocol::~M3U8Protocol(M3U8Protocol *this)
{
  M3U8Protocol *v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  void *v6; // r0
  void *v7; // r0

  v1 = this;
  v2 = (_DWORD *)*((_DWORD *)this + 48);
  *(_DWORD *)v1 = off_F01E8;
  if ( v2 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      free(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = (_DWORD *)*((_DWORD *)v1 + 50);
  if ( v4 )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      free(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = (void *)*((_DWORD *)v1 + 51);
  if ( v6 )
  {
    free(v6);
    *((_DWORD *)v1 + 51) = 0;
  }
  v7 = (void *)*((_DWORD *)v1 + 52);
  if ( v7 )
  {
    free(v7);
    *((_DWORD *)v1 + 52) = 0;
  }
  return v1;
}
// F01E8: using guessed type _DWORD (__fastcall *[2])(M3U8Protocol *__hidden this);

//----- (00044170) --------------------------------------------------------
M3U8Protocol *__fastcall M3U8Protocol::~M3U8Protocol(M3U8Protocol *this)
{
  M3U8Protocol *v1; // r4

  v1 = this;
  M3U8Protocol::~M3U8Protocol(this);
  operator delete((void *)v1);
  return v1;
}

//----- (0004418C) --------------------------------------------------------
bool __fastcall fyzb_strstart(const char *a1, const char *a2, const char **a3)
{
  int v3; // r4
  const char *v4; // r12
  const char *v5; // r3
  int v6; // t1

  v3 = *(unsigned __int8 *)a2;
  if ( *a2 )
  {
    if ( *(unsigned __int8 *)a1 != v3 )
      return v3 == 0;
    v4 = a2 + 1;
    v5 = a1 + 1;
    while ( 1 )
    {
      a2 = v4;
      v6 = *(unsigned __int8 *)v4++;
      v3 = v6;
      a1 = v5++;
      if ( !v6 )
        break;
      if ( *(unsigned __int8 *)a1 != v3 )
        return v3 == 0;
    }
  }
  if ( a3 )
    *a3 = a1;
  v3 = *(unsigned __int8 *)a2;
  return v3 == 0;
}

//----- (000441F4) --------------------------------------------------------
size_t __fastcall fyzb_strlcpy(char *a1, const char *a2, unsigned int a3)
{
  char v3; // r3
  unsigned int v4; // r4
  const char *v5; // r12
  char *v6; // lr
  int v7; // t1

  if ( a3 <= 1 )
  {
    v4 = 1;
    goto LABEL_10;
  }
  v3 = *a2;
  if ( *a2 )
  {
    v5 = a2 + 1;
    v6 = &a1[a3 - 1];
    v4 = 1;
    while ( 1 )
    {
      *a1++ = v3;
      ++v4;
      a2 = v5;
      if ( a1 == v6 )
        break;
      v7 = *(unsigned __int8 *)v5++;
      v3 = v7;
      if ( !v7 )
        goto LABEL_7;
    }
LABEL_10:
    if ( a3 < v4 )
      return strlen(a2) + v4 - 1;
    goto LABEL_7;
  }
  v4 = 1;
LABEL_7:
  *a1 = 0;
  return strlen(a2) + v4 - 1;
}

//----- (0004426C) --------------------------------------------------------
size_t __fastcall fyzb_strlcat(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // r5
  const char *v4; // r6
  char *v5; // r7
  size_t v6; // r0
  size_t result; // r0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = strlen(a1);
  if ( v6 + 1 < v3 )
    result = fyzb_strlcpy(&v5[v6], v4, v3 - v6) + v6;
  else
    result = strlen(v4) + v6;
  return result;
}

//----- (000442B8) --------------------------------------------------------
char *__fastcall fyzb_make_absolute_url(char *a1, unsigned int a2, const char *a3, const char *a4)
{
  const char *v4; // r6
  char *v5; // r5
  unsigned int v6; // r7
  const char *v7; // r4
  char *result; // r0
  char *v9; // r0
  char *v10; // r6
  bool v11; // zf
  char *v12; // r0
  const char *v13; // r0

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  if ( !a3 )
    return (char *)fyzb_strlcpy(v5, v7, v6);
  if ( strstr(a3, "://") && *v7 == 47 )
  {
    if ( v4 != v5 )
      fyzb_strlcpy(v5, v4, v6);
    result = strstr(v5, "://");
    if ( result )
    {
      if ( v7[1] == 47 )
      {
        result[1] = 0;
      }
      else
      {
        result = strchr(result + 3, 47);
        if ( result )
          *result = 0;
      }
    }
    return result;
  }
  if ( strstr(v7, "://") || *v7 == 47 )
    return (char *)fyzb_strlcpy(v5, v7, v6);
  if ( v4 != v5 )
    fyzb_strlcpy(v5, v4, v6);
  result = strchr(v5, 63);
  if ( result )
    *result = 0;
  if ( *v7 != 63 )
  {
    v9 = strrchr(v5, 47);
    v10 = v9;
    if ( v9 )
      v9[1] = 0;
    else
      *v5 = (char)v9;
    while ( 1 )
    {
      v11 = fyzb_strstart(v7, "../", 0) == 0;
      result = v5;
      if ( v11 || !v10 )
        break;
      *v10 = 0;
      v12 = strrchr(v5, 47);
      v10 = v12;
      v11 = v12 == 0;
      v13 = v12 + 1;
      if ( v11 )
      {
        if ( !strcmp(v5, "..") )
          return (char *)fyzb_strlcat(v5, "/", v6);
        *v5 = (char)v10;
      }
      else
      {
        if ( !strcmp(v13, "..") )
          return (char *)fyzb_strlcat(v5, "/", v6);
        v10[1] = 0;
      }
      v7 += 3;
    }
  }
  return result;
}

//----- (000444A4) --------------------------------------------------------
char *__fastcall M3U8Protocol::parseExtInfo(M3U8Protocol *this, char *a2, unsigned int a3)
{
  char *v3; // r4
  M3U8Protocol *v4; // r6
  unsigned int v5; // r5
  char *result; // r0
  const char *v7; // r0
  signed int v8; // r0
  char v9; // r7
  char *v10; // r0
  const char *v11; // r1
  size_t v12; // r2
  int v13; // r4

  v3 = a2;
  v4 = this;
  v5 = a3;
  if ( sub_44064((unsigned __int8 *)a2, "EXT-X-TARGETDURATION", a3) )
  {
    result = (char *)atoi(v3 + 21);
    *((_DWORD *)v4 + 7) = result;
  }
  else if ( sub_44064((unsigned __int8 *)v3, "EXT-X-MEDIA-SEQUENCE", v5) )
  {
    result = (char *)atoi(v3 + 21);
    *((_DWORD *)v4 + 6) = result;
  }
  else if ( sub_44064((unsigned __int8 *)v3, "EXT-X-ALLOW-CACHE", v5) )
  {
    result = (char *)sub_44064((unsigned __int8 *)v3 + 18, "YES", v5 - 18);
    if ( result )
      *((_BYTE *)v4 + 184) = 1;
    else
      *((_BYTE *)v4 + 184) = 0;
  }
  else
  {
    result = (char *)sub_44064((unsigned __int8 *)v3, "EXT-X-ENDLIST", v5);
    if ( result )
    {
      *((_BYTE *)v4 + 185) = 1;
    }
    else if ( *((_DWORD *)v4 + 9) == -1 && sub_44064((unsigned __int8 *)v3, "EXT-X-VERSION", v5) )
    {
      result = (char *)atoi(v3 + 14);
      *((_DWORD *)v4 + 9) = result;
    }
    else if ( sub_44064((unsigned __int8 *)v3, "EXTBYTE", v5) )
    {
      result = (char *)atoi(v3 + 8);
      *((_DWORD *)v4 + 10) = result;
    }
    else if ( sub_44064((unsigned __int8 *)v3, "EXT-X-SOURCE-PIECE-NUM", v5) )
    {
      if ( *((_BYTE *)v4 + 6832) )
      {
        result = (char *)(atoi(v3 + 23) - 1);
        *((_DWORD *)v4 + 11) = result;
      }
      else
      {
        v7 = v3 + 23;
        if ( *((_BYTE *)v4 + 6833) )
          result = (char *)(atoi(v7) - 2);
        else
          result = (char *)atoi(v7);
        *((_DWORD *)v4 + 11) = result;
      }
    }
    else if ( sub_44064((unsigned __int8 *)v3, "EXT-X-SOURCE-WINDOW", v5) )
    {
      result = (char *)atoi(v3 + 20);
      *((_DWORD *)v4 + 12) = result;
    }
    else
    {
      v8 = sub_44064((unsigned __int8 *)v3, "EXT-X-OURS-WINDOW", v5);
      v9 = v8;
      if ( v8 )
      {
        result = (char *)atoi(v3 + 18);
        *((_DWORD *)v4 + 13) = result;
      }
      else
      {
        result = (char *)sub_44064((unsigned __int8 *)v3, "EXT4KHASH", v5);
        if ( result )
        {
          v10 = strchr(v3, 10);
          v11 = v3 + 10;
          v12 = v10 - v3 - 10;
          v13 = (int)v4 + v12;
          result = strncpy((char *)v4 + 56, v11, v12);
          *(_BYTE *)(v13 + 56) = v9;
        }
      }
    }
  }
  return result;
}

//----- (00044714) --------------------------------------------------------
int __fastcall M3U8Protocol::downloadM3u8Url1(M3U8Protocol *this)
{
  int *v1; // lr
  const char *v2; // r1

  v1 = (int *)*((_DWORD *)this + 47);
  v2 = (const char *)*((_DWORD *)this + 51);
  *((_DWORD *)this + 58) = this;
  return CurlWrapper::new_conn(v1, v2, (int)this + 224, (int)parseM3u8_cb, (int)downloadM3u8Error_cb);
}

//----- (0004475C) --------------------------------------------------------
int __fastcall M3U8Protocol::M3U8Protocol(int a1, int a2, int a3, const char *a4, int a5, int a6)
{
  void *v6; // r8
  int v7; // r6
  int v8; // r9
  const char *v9; // r4
  size_t v10; // r0
  size_t v11; // r9
  size_t v12; // r5
  void *v13; // r0
  char *v14; // r0
  char **v15; // r3
  bool v16; // zf
  _BYTE *v17; // r5
  char *v18; // r0
  signed int v19; // r4
  void *v20; // r0

  v6 = (void *)(a1 + 224);
  v7 = a1;
  *(_DWORD *)(a1 + 188) = a3;
  v8 = a2;
  *(_DWORD *)a1 = off_F01E8;
  *(_QWORD *)(a1 + 8) = -1LL;
  *(_DWORD *)(a1 + 32) = 3;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v9 = a4;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 185) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 212) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 36) = -1;
  memset((void *)(a1 + 224), 0, 0x988u);
  *(_DWORD *)(v7 + 2668) = v8;
  *(_DWORD *)(v7 + 6820) = -1;
  *(_BYTE *)(v7 + 6824) = 0;
  *(_BYTE *)(v7 + 6832) = 0;
  *(_BYTE *)(v7 + 6833) = 0;
  v10 = strlen(v9);
  v11 = v10 + 8;
  v12 = v10;
  v13 = malloc(v10 + 8);
  *(_DWORD *)(v7 + 204) = v13;
  memset(v13, 0, v11);
  v14 = strstr(v9, "http://");
  v16 = v14 == 0;
  if ( !v14 )
  {
    v14 = *(char **)"http://";
    v15 = *(char ***)(v7 + 204);
    v15[1] = *(char **)"://";
  }
  if ( v16 )
    *v15 = v14;
  strcat(*(char **)(v7 + 204), v9);
  *(_BYTE *)(*(_DWORD *)(v7 + 204) + v12 + 7) = 0;
  v17 = *(_BYTE **)(v7 + 204);
  v18 = strrchr(*(const char **)(v7 + 204), 47);
  if ( v18 )
  {
    v19 = v18 - v17 + 1;
    if ( v19 >= 2047 )
      v19 = 2047;
    *(_DWORD *)(v7 + 212) = v19;
    v20 = calloc(0x800u, 1u);
    *(_DWORD *)(v7 + 208) = v20;
    memcpy(v20, v17, v19);
    memset(v6, 0, 0x988u);
    *(_DWORD *)(v7 + 6816) = a5;
    *(_DWORD *)(v7 + 6828) = a6;
    M3U8Protocol::downloadM3u8Url1((M3U8Protocol *)v7);
  }
  return v7;
}
// F01E8: using guessed type _DWORD (__fastcall *off_F01E8[2])(M3U8Protocol *__hidden this);

//----- (00044914) --------------------------------------------------------
const char *__fastcall M3U8Protocol::createNew(int a1, int a2, const char *a3, int a4, int a5)
{
  const char *v5; // r4
  int v6; // r6
  int v7; // r5
  int v8; // r7
  void *v9; // r8

  v5 = a3;
  v6 = a1;
  v7 = a2;
  v8 = a4;
  if ( !a3 )
    return a3;
  v9 = operator new(0x1AB8u);
  M3U8Protocol::M3U8Protocol((int)v9, v6, v7, v5, v8, a5);
  return (const char *)v9;
}

//----- (00044978) --------------------------------------------------------
int __fastcall M3U8Protocol::ProcessError(M3U8Protocol *this)
{
  M3U8Protocol *v1; // r4
  char *v2; // r0
  int result; // r0

  v1 = this;
  free(*((void **)this + 51));
  v2 = (char *)malloc(0x800u);
  *((_DWORD *)v1 + 51) = v2;
  *((_DWORD *)v1 + 1705) = 2;
  ChannelPlayInfoManager::changeCdnWithType(*((_DWORD *)v1 + 1704), 2, v2);
  strcat(*((char **)v1 + 51), "/playlist3.m3u8");
  *((_DWORD *)v1 + 7);
  result = (*(int (__cdecl **)(_DWORD, _DWORD))(**((_DWORD **)v1 + 667) + 8))(
             *((_DWORD *)v1 + 667),
             *(_DWORD *)(**((_DWORD **)v1 + 667) + 8));
  *((_DWORD *)v1 + 666) = result;
  return result;
}

//----- (00044A3C) --------------------------------------------------------
int __fastcall downloadM3u8Error_cb(void *a1)
{
  M3U8Protocol::ProcessError(*((M3U8Protocol **)a1 + 2));
  return 0;
}

//----- (00044A50) --------------------------------------------------------
int __fastcall M3U8Protocol::parsePlaylist(M3U8Protocol *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  M3U8Protocol *v68; // r7
  int v69; // r0
  char *v70; // r6
  int v71; // r11
  __int64 v72; // r2
  bool v73; // zf
  signed __int64 v74; // r0
  unsigned int v75; // r12
  char *v76; // r0
  char *v77; // r9
  unsigned int v78; // r8
  char *v79; // r0
  char *v80; // r5
  size_t v81; // r4
  char *v82; // r0
  int v83; // r4
  const char *v84; // r0
  int v85; // r5
  signed int v86; // r9
  signed int v87; // r3
  _DWORD *v88; // r4
  _DWORD *v89; // r3
  bool v90; // zf
  int v91; // r3
  int v92; // r3
  __int64 v93; // r2
  __int64 v94; // r0
  int v95; // r2
  int v96; // r1
  int v97; // r2
  int v98; // r3
  int (__fastcall *v99)(int, int, int, int); // r4
  int v100; // r3
  int *v101; // r0
  int v102; // lr
  int v103; // r12
  char *v104; // r0
  int v105; // r1
  int v106; // r5
  _DWORD *v107; // r4
  int v108; // r6
  _DWORD (__fastcall *v110)(void *); // [sp+0h] [bp-1A10h]
  M3U8Protocol *v111; // [sp+4h] [bp-1A0Ch]
  int v112; // [sp+4C8h] [bp-1548h]
  int v113; // [sp+4CCh] [bp-1544h]
  unsigned int v114; // [sp+4D4h] [bp-153Ch]
  const char *v115; // [sp+4D8h] [bp-1538h]
  char *needle; // [sp+4DCh] [bp-1534h]
  void *v117; // [sp+4E0h] [bp-1530h]
  int v118; // [sp+4E4h] [bp-152Ch]
  int *v119; // [sp+4E8h] [bp-1528h]
  const char *v120; // [sp+4ECh] [bp-1524h]
  __int64 v121; // [sp+4F0h] [bp-1520h]
  void *src; // [sp+4F8h] [bp-1518h]
  const char *v123; // [sp+4FCh] [bp-1514h]
  int v124; // [sp+504h] [bp-150Ch]
  int v125; // [sp+508h] [bp-1508h]
  __int64 v126; // [sp+510h] [bp-1500h]
  int v127; // [sp+518h] [bp-14F8h]
  char v128; // [sp+520h] [bp-14F0h]
  int v129; // [sp+720h] [bp-12F0h]
  int v130; // [sp+750h] [bp-12C0h]
  int v131; // [sp+95Ch] [bp-10B4h]
  int v132; // [sp+960h] [bp-10B0h]
  int v133; // [sp+964h] [bp-10ACh]
  int v134; // [sp+968h] [bp-10A8h]
  char v135; // [sp+9DCh] [bp-1034h]
  int v136; // [sp+9E4h] [bp-102Ch]
  int v137; // [sp+11E4h] [bp-82Ch]
  int v138; // [sp+19E8h] [bp-28h]

  v68 = this;
  v69 = *((_DWORD *)this + 57);
  v117 = &_stack_chk_guard;
  v70 = (char *)sub_81070(v69, 0xFFFFFFFF, (unsigned int)&a68);
  v71 = sub_80154(*((_DWORD *)v68 + 57));
  if ( isNeedDecrypt(v70) )
  {
    v124 = 0;
    v71 = decryptChunk(v70 + 4, v71 - 4, &v124);
    v114 = (unsigned int)&v70[v71];
    memmove(v70, &v70[v124 + 4], v71);
    v70[v71] = 0;
  }
  else
  {
    v70[v71] = 0;
    v114 = (unsigned int)&v70[v71];
  }
  *((_DWORD *)v68 + 1) = 0;
  if ( sub_44064((unsigned __int8 *)v70, "#EXTM3U", v71) )
  {
    v72 = *((_QWORD *)v68 + 1);
    v73 = HIDWORD(v72) == -1;
    if ( HIDWORD(v72) == -1 )
      v73 = (_DWORD)v72 == -1;
    if ( v73 )
    {
      add_play_fh();
      sendEventToPlayer(1);
    }
    *((_BYTE *)v68 + 6832) = strstr(v70, "qqlive") || strstr(v70, "/sohu/");
    LODWORD(v74) = strstr(v70, "vapptime");
    v75 = v114;
    if ( (_DWORD)v74 )
      *((_BYTE *)v68 + 6833) = 1;
    else
      *((_BYTE *)v68 + 6833) = 0;
    if ( (unsigned int)v70 < v75 )
    {
      v119 = &v125;
      v115 = "#EXTBYTE";
      v123 = "http://";
      src = &v127;
      needle = "http://";
      v120 = "There is no md5";
      v118 = 0;
      while ( 1 )
      {
        v76 = (char *)memchr(v70, 10, v71);
        if ( v76 || (v76 = (char *)memchr(v70, 13, v71)) != 0 )
          v77 = v76 - 1;
        else
          v77 = (char *)v114;
        v78 = (unsigned int)(v77 + 2);
        if ( sub_44064((unsigned __int8 *)v70, v115, v71) )
          *((_BYTE *)v68 + 6824) = 1;
        if ( *v77 == 13 )
          --v77;
        v79 = strchr(v70, 13);
        v71 = v114 - v78;
        v80 = v79;
        if ( v79 || (v80 = strchr(v70, 10)) != 0 )
        {
          v81 = v80 - v70;
          strncpy((char *)&v137, v70, v80 - v70);
          *((_BYTE *)&v138 + v80 - v70 - 2052) = 0;
          if ( *v70 == 35 )
            goto LABEL_55;
        }
        else
        {
          v81 = strlen(v70);
          memcpy(&v137, v70, v81 + 1);
          *((_BYTE *)&v138 + v81 - 2052) = 0;
          if ( *v70 == 35 )
          {
LABEL_55:
            LODWORD(v74) = M3U8Protocol::parseExtInfo(v68, v70 + 1, v77 - v70 + 1);
            goto LABEL_18;
          }
        }
        if ( *((_BYTE *)v68 + 6824) )
        {
          LODWORD(v74) = strstr((const char *)&v137, needle);
          if ( (_DWORD)v74 )
          {
            if ( v118 )
            {
              v121 = v118;
              strcpy((char *)v68 + 4768, (const char *)&v137);
              v94 = v121;
              v73 = *((_BYTE *)v68 + 56) == 0;
              v95 = *((_DWORD *)v68 + 10);
              *((_BYTE *)v68 + v81 + 4768) = 0;
              v126 = v94;
              v125 = v95;
              if ( v73 )
              {
                v96 = *((_DWORD *)v120 + 1);
                v97 = *((_DWORD *)v120 + 2);
                v98 = *((_DWORD *)v120 + 3);
                v131 = *(_DWORD *)v120;
                v132 = v96;
                v133 = v97;
                v134 = v98;
              }
              else
              {
                strcpy((char *)&v131, (const char *)v68 + 56);
              }
              *(_QWORD *)src = v121;
              v135 = 0;
              strcpy(&v128, (const char *)v68 + 2672);
              strcpy((char *)&v129, (const char *)v68 + 4720);
              LODWORD(v74) = strcpy((char *)&v130, (const char *)v68 + 4768);
              v99 = (int (__fastcall *)(int, int, int, int))*((_DWORD *)v68 + 1707);
              if ( v99 )
              {
                v100 = *((_DWORD *)v68 + 13) - *((_DWORD *)v68 + 12);
                v112 = *((_DWORD *)v68 + 6);
                v113 = v100;
                memcpy(&v110, src, 0x4C8u);
                LODWORD(v74) = v99(*v119, v119[1], v119[2], v119[3]);
              }
            }
LABEL_18:
            if ( v78 >= v114 )
              break;
            goto LABEL_19;
          }
        }
        v82 = strchr((const char *)&v137, 46);
        v83 = v82 - (char *)&v137;
        v84 = (const char *)memcpy(&v125, &v137, v82 - (char *)&v137);
        v84[v83] = 0;
        v85 = atoi(v84);
        v74 = *((_QWORD *)v68 + 1);
        if ( v74 >= v85 )
          goto LABEL_18;
        v86 = v77 - v70 + 1;
        if ( !*((_DWORD *)v68 + 54) )
        {
          LODWORD(v74) = sub_44064((unsigned __int8 *)v70, v123, v86);
          if ( (_DWORD)v74 )
            v87 = 1;
          else
            v87 = 2;
          *((_DWORD *)v68 + 54) = v87;
        }
        v88 = (_DWORD *)*((_DWORD *)v68 + 50);
        if ( v88 )
        {
          *((_DWORD *)v68 + 50) = *v88;
        }
        else
        {
          LODWORD(v74) = malloc(0x808u);
          v88 = (_DWORD *)v74;
        }
        v89 = (_DWORD *)*((_DWORD *)v68 + 49);
        *v88 = 0;
        v90 = v89 == 0;
        if ( v89 )
          *v89 = v88;
        else
          *((_DWORD *)v68 + 49) = v88;
        v91 = *((_DWORD *)v68 + 54);
        if ( v90 )
          *((_DWORD *)v68 + 48) = v88;
        else
          *((_DWORD *)v68 + 49) = v88;
        v88[513] = v85;
        if ( v91 == 2 )
        {
          if ( v86 >= 2047 - *((_DWORD *)v68 + 53) )
            v86 = 2047 - *((_DWORD *)v68 + 53);
          memcpy(&v136, v70, v86);
          *((_BYTE *)&v136 + v86) = 0;
          strcpy((char *)v68 + 4720, (const char *)&v136);
          fyzb_make_absolute_url((char *)v68 + 2672, 0x800u, *((const char **)v68 + 51), (const char *)&v136);
          LODWORD(v74) = (char *)v68 + strlen((const char *)v68 + 2672);
          *(_BYTE *)(v74 + 2672) = 0;
        }
        else if ( v91 == 1 )
        {
          if ( v86 >= 2047 )
            v86 = 2047;
          LODWORD(v74) = memcpy(v88 + 1, v70, v86);
          *((_BYTE *)v88 + v86 + 4) = 0;
        }
        v118 = v85;
        if ( v78 >= v114 )
          break;
LABEL_19:
        v70 = (char *)v78;
      }
    }
    v92 = *((_DWORD *)v68 + 49);
    if ( v92 )
    {
      v74 = *((_QWORD *)v68 + 2);
      v93 = *(unsigned int *)(v92 + 2052);
      *((_QWORD *)v68 + 1) = v93;
      if ( v74 )
      {
        *((_DWORD *)v68 + 1705) = 3;
        if ( v93 == v74 )
        {
          free(*((void **)v68 + 51));
          v104 = (char *)malloc(0x800u);
          v105 = *((_DWORD *)v68 + 1705);
          *((_DWORD *)v68 + 51) = v104;
          ChannelPlayInfoManager::changeCdnWithType(*((_DWORD *)v68 + 1704), v105, v104);
          v106 = *((_DWORD *)v68 + 51);
          LODWORD(v74) = strlen(*((const char **)v68 + 51));
          v107 = (_DWORD *)(v106 + v74);
          v108 = v74;
          LODWORD(v74) = *(_DWORD *)"/playlist3.m3u8";
          *(_DWORD *)(v106 + v108) = *(_DWORD *)"/playlist3.m3u8";
          v107[1] = *(_DWORD *)"ylist3.m3u8";
          v107[2] = *(_DWORD *)"t3.m3u8";
          v107[3] = *(_DWORD *)"3u8";
        }
        else
        {
          LODWORD(v74) = ChannelPlayInfoManager::clearErrorWithType(*((_DWORD *)v68 + 1704), 3);
        }
        v93 = *((_QWORD *)v68 + 1);
      }
      *((_QWORD *)v68 + 2) = v93;
    }
    if ( !*((_BYTE *)v68 + 185) )
    {
      v101 = (int *)*((_DWORD *)v68 + 667);
      v102 = *((_DWORD *)v68 + 7);
      v103 = *v101;
      v111 = v68;
      v110 = downloadM3u8Url;
      LODWORD(v74) = (*(int (__cdecl **)(int *, _DWORD))(v103 + 8))(v101, *(_DWORD *)(v103 + 8));
      *((_DWORD *)v68 + 666) = v74;
    }
  }
  else
  {
    LODWORD(v74) = M3U8Protocol::ProcessError(v68);
  }
  return v74;
}
// 44A50: too many input arguments, some ignored

//----- (000451C4) --------------------------------------------------------
#error "451E8: call analysis failed (funcsize=14)"

//----- (000451FC) --------------------------------------------------------
signed int __fastcall sub_451FC(unsigned __int8 *a1, const char *a2, size_t a3)
{
  unsigned __int8 *v3; // r5
  size_t v4; // r6
  const char *v5; // r4
  size_t v6; // r0
  unsigned __int8 *v7; // r3
  const char *v8; // r1
  int v9; // r0
  int v10; // r12
  int v11; // t1
  int v12; // t1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = strlen(a2);
  if ( v6 <= v4 )
  {
    if ( !v6 )
      return 1;
    if ( *v3 == *(unsigned __int8 *)v5 )
    {
      v7 = v3;
      v8 = v5;
      v9 = (int)&v3[v6 - 1];
      while ( v7 != (unsigned __int8 *)v9 )
      {
        v11 = (v7++)[1];
        v10 = v11;
        v12 = *((unsigned __int8 *)v8++ + 1);
        if ( v10 != v12 )
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (00045274) --------------------------------------------------------
ThirdM3U8Protocol *__fastcall ThirdM3U8Protocol::~ThirdM3U8Protocol(ThirdM3U8Protocol *this)
{
  ThirdM3U8Protocol *v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  void *v6; // r0
  void *v7; // r0

  v1 = this;
  v2 = (_DWORD *)*((_DWORD *)this + 14);
  *(_DWORD *)v1 = off_F01F8;
  if ( v2 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      free(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = (_DWORD *)*((_DWORD *)v1 + 16);
  if ( v4 )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      free(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = (void *)*((_DWORD *)v1 + 17);
  if ( v6 )
  {
    free(v6);
    *((_DWORD *)v1 + 17) = 0;
  }
  v7 = (void *)*((_DWORD *)v1 + 18);
  if ( v7 )
  {
    free(v7);
    *((_DWORD *)v1 + 18) = 0;
  }
  return v1;
}
// F01F8: using guessed type _DWORD (__fastcall *[2])(ThirdM3U8Protocol *__hidden this);

//----- (00045308) --------------------------------------------------------
ThirdM3U8Protocol *__fastcall ThirdM3U8Protocol::~ThirdM3U8Protocol(ThirdM3U8Protocol *this)
{
  ThirdM3U8Protocol *v1; // r4

  v1 = this;
  ThirdM3U8Protocol::~ThirdM3U8Protocol(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00045324) --------------------------------------------------------
bool __fastcall third_fyzb_strstart(const char *a1, const char *a2, const char **a3)
{
  int v3; // r4
  const char *v4; // r12
  const char *v5; // r3
  int v6; // t1

  v3 = *(unsigned __int8 *)a2;
  if ( *a2 )
  {
    if ( *(unsigned __int8 *)a1 != v3 )
      return v3 == 0;
    v4 = a2 + 1;
    v5 = a1 + 1;
    while ( 1 )
    {
      a2 = v4;
      v6 = *(unsigned __int8 *)v4++;
      v3 = v6;
      a1 = v5++;
      if ( !v6 )
        break;
      if ( *(unsigned __int8 *)a1 != v3 )
        return v3 == 0;
    }
  }
  if ( a3 )
    *a3 = a1;
  v3 = *(unsigned __int8 *)a2;
  return v3 == 0;
}

//----- (0004538C) --------------------------------------------------------
size_t __fastcall third_fyzb_strlcpy(char *a1, const char *a2, unsigned int a3)
{
  char v3; // r3
  unsigned int v4; // r4
  const char *v5; // r12
  char *v6; // lr
  int v7; // t1

  if ( a3 <= 1 )
  {
    v4 = 1;
    goto LABEL_10;
  }
  v3 = *a2;
  if ( *a2 )
  {
    v5 = a2 + 1;
    v6 = &a1[a3 - 1];
    v4 = 1;
    while ( 1 )
    {
      *a1++ = v3;
      ++v4;
      a2 = v5;
      if ( a1 == v6 )
        break;
      v7 = *(unsigned __int8 *)v5++;
      v3 = v7;
      if ( !v7 )
        goto LABEL_7;
    }
LABEL_10:
    if ( a3 < v4 )
      return strlen(a2) + v4 - 1;
    goto LABEL_7;
  }
  v4 = 1;
LABEL_7:
  *a1 = 0;
  return strlen(a2) + v4 - 1;
}

//----- (00045404) --------------------------------------------------------
size_t __fastcall third_fyzb_strlcat(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // r5
  const char *v4; // r6
  char *v5; // r7
  size_t v6; // r0
  size_t result; // r0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = strlen(a1);
  if ( v6 + 1 < v3 )
    result = third_fyzb_strlcpy(&v5[v6], v4, v3 - v6) + v6;
  else
    result = strlen(v4) + v6;
  return result;
}

//----- (00045450) --------------------------------------------------------
size_t __fastcall third_fyzb_make_absolute_url(char *a1, unsigned int a2, const char *a3, const char *a4)
{
  const char *v4; // r6
  char *v5; // r5
  unsigned int v6; // r7
  const char *v7; // r4
  char *v9; // r0
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  char *v13; // r0
  char *v14; // r6
  char *v15; // r0
  bool v16; // zf
  const char *v17; // r0

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  if ( !a3 )
    return third_fyzb_strlcpy(v5, v7, v6);
  if ( strstr(a3, "://") && *v7 == 47 )
  {
    if ( v4 == v5 )
    {
      v9 = strstr(v5, "://");
    }
    else
    {
      third_fyzb_strlcpy(v5, v4, v6);
      v9 = strstr(v5, "://");
      if ( !v9 )
        goto LABEL_12;
    }
    if ( v7[1] == 47 )
    {
      v9[1] = 0;
    }
    else
    {
      v10 = strchr(v9 + 3, 47);
      if ( v10 )
        *v10 = 0;
    }
    goto LABEL_12;
  }
  if ( strstr(v7, "://") || *v7 == 47 )
    return third_fyzb_strlcpy(v5, v7, v6);
  if ( v4 != v5 )
    third_fyzb_strlcpy(v5, v4, v6);
  v12 = strchr(v5, 63);
  if ( v12 )
    *v12 = 0;
  v11 = v5;
  if ( *v7 == 63 )
    return third_fyzb_strlcat(v11, v7, v6);
  v13 = strrchr(v5, 47);
  v14 = v13;
  if ( v13 )
    v13[1] = 0;
  else
    *v5 = (char)v13;
  while ( third_fyzb_strstart(v7, "../", 0) && v14 )
  {
    *v14 = 0;
    v15 = strrchr(v5, 47);
    v14 = v15;
    v16 = v15 == 0;
    v17 = v15 + 1;
    if ( v16 )
    {
      if ( !strcmp(v5, "..") )
      {
LABEL_34:
        third_fyzb_strlcat(v5, "/", v6);
        break;
      }
      *v5 = (char)v14;
    }
    else
    {
      if ( !strcmp(v17, "..") )
        goto LABEL_34;
      v14[1] = 0;
    }
    v7 += 3;
  }
LABEL_12:
  v11 = v5;
  return third_fyzb_strlcat(v11, v7, v6);
}

//----- (00045658) --------------------------------------------------------
int __fastcall ThirdM3U8Protocol::ThirdgetNextUrl(int result, void (__cdecl *a2)(void *, char *), void *a3)
{
  int v3; // r4
  _DWORD *v4; // r5
  void (__cdecl *v5)(void *, char *); // r3
  int v6; // r3
  int v7; // r1

  v3 = result;
  v4 = *(_DWORD **)(result + 56);
  v5 = a2;
  if ( v4 )
  {
    result = ((int (__fastcall *)(void *, _DWORD *))a2)(a3, v4 + 1);
    v6 = **(_DWORD **)(v3 + 56);
    *(_DWORD *)(v3 + 56) = v6;
    if ( !v6 )
      *(_DWORD *)(v3 + 60) = 0;
    *v4 = *(_DWORD *)(v3 + 64);
    *(_DWORD *)(v3 + 64) = v4;
  }
  else
  {
    v7 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 44) = v5;
    *(_DWORD *)(result + 48) = a3;
    *(_DWORD *)(result + 32) = v7 + 1;
  }
  return result;
}

//----- (000456B8) --------------------------------------------------------
int __fastcall ThirdM3U8Protocol::ThirdparseExtInfo(ThirdM3U8Protocol *this, char *a2, unsigned int a3)
{
  char *v3; // r4
  ThirdM3U8Protocol *v4; // r5
  unsigned int v5; // r6
  double v6; // r0
  unsigned int v7; // r4

  v3 = a2;
  v4 = this;
  v5 = a3;
  if ( sub_451FC((unsigned __int8 *)a2, "EXT-X-TARGETDURATION", a3) )
  {
    v7 = atoi(v3 + 21);
    *((_DWORD *)v4 + 7) = v7;
    if ( 0x5A % v7 )
      *((_DWORD *)v4 + 634) = 0x5A / v7 + 1;
    else
      *((_DWORD *)v4 + 634) = 0x5A / v7;
    if ( 0x28 % v7 )
    {
      LODWORD(v6) = 0x28 / v7 + 1;
      *((_DWORD *)v4 + 4) = LODWORD(v6);
    }
    else
    {
      LODWORD(v6) = 0x28 / v7;
      *((_DWORD *)v4 + 4) = 0x28 / v7;
    }
  }
  else if ( *((_BYTE *)v4 + 2560) || !sub_451FC((unsigned __int8 *)v3, "EXT-X-MEDIA-SEQUENCE", v5) )
  {
    if ( sub_451FC((unsigned __int8 *)v3, "EXT-X-ALLOW-CACHE", v5) )
    {
      LODWORD(v6) = sub_451FC((unsigned __int8 *)v3 + 18, "YES", v5 - 18);
      if ( LODWORD(v6) )
        *((_BYTE *)v4 + 40) = 1;
      else
        *((_BYTE *)v4 + 40) = 0;
    }
    else
    {
      LODWORD(v6) = sub_451FC((unsigned __int8 *)v3, "EXT-X-ENDLIST", v5);
      if ( LODWORD(v6) )
      {
        *((_BYTE *)v4 + 41) = 1;
      }
      else if ( *((_DWORD *)v4 + 9) == -1 && (LODWORD(v6) = sub_451FC((unsigned __int8 *)v3, "EXT-X-VERSION", v5)) != 0 )
      {
        LODWORD(v6) = atoi(v3 + 14);
        *((_DWORD *)v4 + 9) = LODWORD(v6);
      }
      else if ( *((_BYTE *)v4 + 2540) )
      {
        LODWORD(v6) = sub_451FC((unsigned __int8 *)v3, "EXTINF", v5);
        if ( LODWORD(v6) )
        {
          v6 = strtod(v3 + 7, 0);
          *((double *)v4 + 319) = *((double *)v4 + 319) + v6;
        }
      }
    }
  }
  else
  {
    LODWORD(v6) = atoi(v3 + 21);
    *((_BYTE *)v4 + 2560) = 1;
    *((_DWORD *)v4 + 6) = LODWORD(v6);
  }
  return LODWORD(v6);
}

//----- (000458A8) --------------------------------------------------------
int __fastcall ThirdM3U8Protocol::ThirddownloadM3u8Url1(ThirdM3U8Protocol *this)
{
  int *v1; // lr
  const char *v2; // r1

  v1 = (int *)*((_DWORD *)this + 13);
  v2 = (const char *)*((_DWORD *)this + 17);
  *((_DWORD *)this + 24) = this;
  return CurlWrapper::new_conn(v1, v2, (int)this + 88, (int)ThirdparseM3u8_cb, (int)ThirddownloadM3u8Error_cb);
}

//----- (000458F0) --------------------------------------------------------
ThirdM3U8Protocol *__fastcall ThirdM3U8Protocol::ThirdM3U8Protocol(ThirdM3U8Protocol *this, TaskScheduler *a2, CurlWrapper *a3, const char *a4)
{
  char *v4; // r7
  ThirdM3U8Protocol *v5; // r4
  TaskScheduler *v6; // r8
  const char *v7; // r6
  size_t v8; // r0
  size_t v9; // r9
  size_t v10; // r8
  void *v11; // r0
  char *v12; // r0
  char **v13; // r3
  bool v14; // zf
  _BYTE *v15; // r6
  char *v16; // r0
  signed int v17; // r5
  void *v18; // r0

  v4 = (char *)this + 88;
  v5 = this;
  *((_DWORD *)this + 13) = a3;
  v6 = a2;
  *(_DWORD *)this = off_F01F8;
  *((_DWORD *)this + 5) = -1;
  *((_DWORD *)this + 9) = -1;
  v7 = a4;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_BYTE *)this + 41) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  memset((char *)this + 88, 0, 0x988u);
  *((_BYTE *)v5 + 2540) = 1;
  *((_DWORD *)v5 + 633) = v6;
  *((_DWORD *)v5 + 634) = 0;
  *((_DWORD *)v5 + 636) = 0;
  *((_QWORD *)v5 + 319) = 0LL;
  *((_BYTE *)v5 + 2560) = 0;
  v8 = strlen(v7);
  v9 = v8 + 8;
  v10 = v8;
  v11 = malloc(v8 + 8);
  *((_DWORD *)v5 + 17) = v11;
  memset(v11, 0, v9);
  v12 = strstr(v7, "http://");
  v14 = v12 == 0;
  if ( !v12 )
  {
    v12 = *(char **)"http://";
    v13 = (char **)*((_DWORD *)v5 + 17);
    v13[1] = *(char **)"://";
  }
  if ( v14 )
    *v13 = v12;
  strcat(*((char **)v5 + 17), v7);
  *(_BYTE *)(*((_DWORD *)v5 + 17) + v10 + 7) = 0;
  v15 = (_BYTE *)*((_DWORD *)v5 + 17);
  v16 = strrchr(*((const char **)v5 + 17), 47);
  if ( v16 )
  {
    v17 = v16 - v15 + 1;
    if ( v17 >= 2047 )
      v17 = 2047;
    *((_DWORD *)v5 + 19) = v17;
    v18 = calloc(0x800u, 1u);
    *((_DWORD *)v5 + 18) = v18;
    memcpy(v18, v15, v17);
    memset(v4, 0, 0x988u);
    ThirdM3U8Protocol::ThirddownloadM3u8Url1(v5);
  }
  return v5;
}
// F01F8: using guessed type _DWORD (__fastcall *off_F01F8[2])(ThirdM3U8Protocol *__hidden this);

//----- (00045A88) --------------------------------------------------------
CurlWrapper *__fastcall ThirdM3U8Protocol::createNew(ThirdM3U8Protocol *this, TaskScheduler *a2, CurlWrapper *a3, const char *a4)
{
  CurlWrapper *v4; // r4
  ThirdM3U8Protocol *v5; // r6
  TaskScheduler *v6; // r5
  ThirdM3U8Protocol *v7; // r7

  v4 = a3;
  v5 = this;
  v6 = a2;
  if ( !a3 )
    return a3;
  v7 = (ThirdM3U8Protocol *)operator new(0xA08u);
  ThirdM3U8Protocol::ThirdM3U8Protocol(v7, v5, v6, (const char *)v4);
  return v7;
}

//----- (00045AD4) --------------------------------------------------------
void __fastcall ThirdM3U8Protocol::ThirdProcessError(ThirdM3U8Protocol *this)
{
  unsigned int v1; // r2
  unsigned int v2; // r3

  v1 = *((_DWORD *)this + 4);
  v2 = *((_DWORD *)this + 1) + 1;
  *((_DWORD *)this + 1) = v2;
  if ( v2 > v1 )
    notifyPlayerToChangeSource(3);
  else
    *((_DWORD *)this + 632) = (*(int (__cdecl **)(_DWORD, _DWORD))(**((_DWORD **)this + 633) + 8))(
                                *((_DWORD *)this + 633),
                                *(_DWORD *)(**((_DWORD **)this + 633) + 8));
}

//----- (00045B44) --------------------------------------------------------
int __fastcall ThirddownloadM3u8Error_cb(void *a1)
{
  ThirdM3U8Protocol::ThirdProcessError(*((ThirdM3U8Protocol **)a1 + 2));
  return 0;
}

//----- (00045B58) --------------------------------------------------------
void __fastcall ThirdM3U8Protocol::ThirdparsePlaylist(ThirdM3U8Protocol *this, int a2, unsigned int a3)
{
  ThirdM3U8Protocol *v3; // r4
  char *v4; // r5
  unsigned int v5; // r0
  bool v6; // cf
  bool v7; // zf
  int v8; // r6
  int v9; // r7
  unsigned int v10; // r11
  int v11; // r10
  int v12; // r9
  char *v13; // r0
  char *v14; // r12
  unsigned int v15; // r7
  int v16; // r3
  signed int v17; // r2
  signed int v18; // r12
  int v19; // ST10_4
  signed int v20; // ST0C_4
  signed int v21; // r0
  char *v22; // r8
  int v23; // r3
  _DWORD *v24; // r3
  int v25; // r2
  int v26; // r5
  signed int v27; // r8
  signed int v28; // r7
  int v29; // r3
  int v30; // r2
  _DWORD *v31; // r5
  void (__fastcall *v32)(_DWORD, _DWORD *); // r2
  _DWORD *v33; // r3
  int v34; // r2
  int v35; // r9
  char *v36; // r1
  signed int v37; // r5
  int v38; // r2
  int v39; // r1
  int v40; // r3
  signed int v41; // ST0C_4
  int v42; // r3
  signed int v43; // ST14_4
  int v44; // ST10_4
  signed int v45; // ST0C_4
  char *v46; // r0
  _DWORD *v47; // r6
  int v48; // r8
  int v49; // r5
  _DWORD *i; // r0
  _DWORD *v51; // r7
  int v52; // r3
  int v53; // [sp+18h] [bp-840h]
  int v54; // [sp+28h] [bp-830h]
  char v55; // [sp+2Ch] [bp-82Ch]
  char v56; // [sp+830h] [bp-28h]

  v3 = this;
  v4 = (char *)sub_81070(*((_DWORD *)this + 23), 0xFFFFFFFF, a3);
  v5 = sub_80154(*((_DWORD *)v3 + 23));
  v6 = 1;
  v7 = v4 == 0;
  if ( v4 )
  {
    v6 = v5 >= 3;
    v7 = v5 == 3;
  }
  v8 = v5;
  if ( !v7 && v6 )
    v9 = 0;
  else
    v9 = 1;
  if ( v7 || !v6 )
    return;
  if ( isNeedDecrypt(v4) )
  {
    v54 = v9;
    v8 = decryptChunk(v4 + 4, v8 - 4, &v54);
    v10 = (unsigned int)&v4[v8];
    memmove(v4, &v4[v54 + 4], v8);
    v4[v8] = v9;
  }
  else
  {
    v4[v8] = 0;
    v10 = (unsigned int)&v4[v8];
  }
  *((_DWORD *)v3 + 1) = 0;
  if ( !sub_451FC((unsigned __int8 *)v4, "#EXTM3U", v8) )
  {
    ThirdM3U8Protocol::ThirdProcessError(v3);
    return;
  }
  if ( *((_DWORD *)v3 + 5) == -1 )
  {
    add_play_fh();
    sendEventToPlayer(1);
  }
  if ( v10 > (unsigned int)v4 )
  {
    v11 = 0;
    v53 = 0;
    v12 = -1;
    while ( 1 )
    {
      v13 = (char *)memchr(v4, 10, v8);
      if ( v13 || (v13 = (char *)memchr(v4, 13, v8)) != 0 )
        v14 = v13 - 1;
      else
        v14 = (char *)v10;
      v15 = (unsigned int)(v14 + 2);
      v8 = v10 - (_DWORD)(v14 + 2);
      if ( *v14 == 13 )
        --v14;
      if ( *v4 == 35 )
        break;
      if ( v12 != -1
        || (v35 = *((_DWORD *)v3 + 5), v16 = *((_DWORD *)v3 + 6), v35 != -1) && (v12 = v35 - v16 + 1, v12 >= 0) )
      {
        if ( v12 > v11 )
        {
          ++v11;
          goto LABEL_16;
        }
        v16 = *((_DWORD *)v3 + 6);
      }
      else
      {
        v12 = 0;
      }
      v17 = *((_DWORD *)v3 + 20);
      v18 = v14 - v4 + 1;
      if ( !v17 )
      {
        v19 = v16;
        v20 = v18;
        v21 = sub_451FC((unsigned __int8 *)v4, "http://", v18);
        v16 = v19;
        v18 = v20;
        if ( v21 )
          v17 = 1;
        else
          v17 = 2;
        *((_DWORD *)v3 + 20) = v17;
      }
      v22 = (char *)*((_DWORD *)v3 + 16);
      if ( v22 )
      {
        *((_DWORD *)v3 + 16) = *(_DWORD *)v22;
      }
      else
      {
        v43 = v17;
        v44 = v16;
        v45 = v18;
        v46 = (char *)malloc(0x808u);
        v17 = v43;
        v16 = v44;
        v18 = v45;
        v22 = v46;
      }
      v23 = v53++ + v11 + v16;
      *((_DWORD *)v22 + 513) = v23;
      if ( v17 == 2 )
      {
        v36 = v4;
        v37 = 2047 - *((_DWORD *)v3 + 19);
        if ( v37 >= v18 )
          v37 = v18;
        memcpy(&v55, v36, v37);
        *(&v56 + v37 - 2052) = 0;
        if ( !v55 )
        {
LABEL_64:
          *(_DWORD *)v22 = *((_DWORD *)v3 + 16);
          *((_DWORD *)v3 + 16) = v22;
LABEL_16:
          if ( v10 <= v15 )
            goto LABEL_40;
          goto LABEL_17;
        }
        third_fyzb_make_absolute_url(v22 + 4, 0x800u, *((const char **)v3 + 17), &v55);
      }
      else if ( v17 == 1 )
      {
        if ( v18 >= 2047 )
          v18 = 2047;
        v41 = v18;
        memcpy(v22 + 4, v4, v18);
        v22[v41 + 4] = 0;
        if ( !v22[4] )
          goto LABEL_64;
      }
      v24 = (_DWORD *)*((_DWORD *)v3 + 15);
      *(_DWORD *)v22 = 0;
      if ( v24 )
      {
        v25 = *((unsigned __int8 *)v3 + 2540);
        *v24 = v22;
        *((_DWORD *)v3 + 15) = v22;
        if ( !v25 )
          goto LABEL_16;
      }
      else
      {
        v42 = *((unsigned __int8 *)v3 + 2540);
        *((_DWORD *)v3 + 15) = v22;
        *((_DWORD *)v3 + 14) = v22;
        if ( !v42 )
          goto LABEL_16;
      }
      ++*((_DWORD *)v3 + 636);
      if ( v10 <= v15 )
        goto LABEL_40;
LABEL_17:
      v4 = (char *)v15;
    }
    ThirdM3U8Protocol::ThirdparseExtInfo(v3, v4 + 1, v14 - v4 + 1);
    goto LABEL_16;
  }
  v53 = 0;
LABEL_40:
  v26 = *((_DWORD *)v3 + 15);
  if ( !v26 )
  {
    *((_BYTE *)v3 + 2540) = 0;
    *((_DWORD *)v3 + 636) = 0;
    goto LABEL_83;
  }
  if ( !*((_BYTE *)v3 + 2540) )
    goto LABEL_43;
  v27 = *((_DWORD *)v3 + 636);
  v28 = *((_DWORD *)v3 + 634);
  if ( v27 <= v28 )
    goto LABEL_43;
  v47 = (_DWORD *)*((_DWORD *)v3 + 14);
  if ( (signed int)(ceil(*((double *)v3 + 319)) / (double)v27) >= *((_DWORD *)v3 + 7) / 3u || v27 <= 10 )
  {
    v48 = v27 - v28;
    if ( v48 <= 0 )
    {
LABEL_43:
      *((_BYTE *)v3 + 2540) = 0;
      *((_DWORD *)v3 + 636) = 0;
      goto LABEL_44;
    }
  }
  else
  {
    v48 = v27 - 10;
    *((_DWORD *)v3 + 634) = 10;
  }
  v49 = 0;
  for ( i = v47; ; i = v51 )
  {
    v51 = (_DWORD *)*i;
    ++v49;
    free(i);
    *((_DWORD *)v3 + 14) = v51;
    if ( v49 == v48 )
      break;
  }
  v26 = *((_DWORD *)v3 + 15);
  *((_BYTE *)v3 + 2540) = 0;
  *((_DWORD *)v3 + 636) = 0;
  if ( !v26 )
  {
LABEL_83:
    v52 = *((_DWORD *)v3 + 2);
    if ( v52 && v52 == *((_DWORD *)v3 + 5) )
      ++*((_DWORD *)v3 + 3);
    goto LABEL_46;
  }
LABEL_44:
  v29 = *(_DWORD *)(v26 + 2052);
  v30 = *((_DWORD *)v3 + 2);
  *((_DWORD *)v3 + 5) = v29;
  *((_DWORD *)v3 + 2) = v29;
  if ( v29 != v30 )
    *((_DWORD *)v3 + 3) = 0;
LABEL_46:
  if ( v53 )
  {
    if ( *((_DWORD *)v3 + 8) )
    {
      v31 = (_DWORD *)*((_DWORD *)v3 + 14);
      if ( v31 )
      {
        v32 = (void (__fastcall *)(_DWORD, _DWORD *))*((_DWORD *)v3 + 11);
        if ( v32 )
        {
          while ( 1 )
          {
            v32(*((_DWORD *)v3 + 12), v31 + 1);
            v33 = (_DWORD *)**((_DWORD **)v3 + 14);
            *((_DWORD *)v3 + 14) = v33;
            if ( !v33 )
              break;
            v34 = *((_DWORD *)v3 + 8) - 1;
            v7 = *((_DWORD *)v3 + 8) == 1;
            *v31 = *((_DWORD *)v3 + 16);
            *((_DWORD *)v3 + 8) = v34;
            *((_DWORD *)v3 + 16) = v31;
            if ( v7 )
              goto LABEL_66;
            v32 = (void (__fastcall *)(_DWORD, _DWORD *))*((_DWORD *)v3 + 11);
            if ( !v32 )
              goto LABEL_66;
            v31 = v33;
          }
          v38 = *((_DWORD *)v3 + 16);
          v39 = *((_DWORD *)v3 + 8);
          *((_DWORD *)v3 + 15) = 0;
          *v31 = v38;
          *((_DWORD *)v3 + 16) = v31;
          *((_DWORD *)v3 + 8) = v39 - 1;
        }
      }
    }
  }
LABEL_66:
  v40 = *((unsigned __int8 *)v3 + 41);
  *((_BYTE *)v3 + 2560) = 0;
  if ( !v40 )
    *((_DWORD *)v3 + 632) = (*(int (__cdecl **)(_DWORD, _DWORD))(**((_DWORD **)v3 + 633) + 8))(
                              *((_DWORD *)v3 + 633),
                              *(_DWORD *)(**((_DWORD **)v3 + 633) + 8));
}

//----- (00046128) --------------------------------------------------------
int __fastcall ThirdparseM3u8_cb(void *a1, int a2, unsigned int a3)
{
  ThirdM3U8Protocol::ThirdparsePlaylist(*((ThirdM3U8Protocol **)a1 + 2), a2, a3);
  return 0;
}

//----- (0004613C) --------------------------------------------------------
unsigned int __fastcall flvDataWrite_cb(char *src, unsigned int a2, unsigned int a3, void *a4)
{
  int v4; // r4
  unsigned int v5; // r5
  unsigned int result; // r0

  v4 = *((_DWORD *)a4 + 2);
  v5 = a3 * a2;
  memcpy((void *)(v4 + *(_DWORD *)(v4 + 8) + 20), src, a3 * a2);
  result = v5;
  *(_DWORD *)(v4 + 8) += v5;
  return result;
}

//----- (0004615E) --------------------------------------------------------
unsigned __int64 __fastcall sub_4615E(int a1, int a2)
{
  int v3; // [sp+0h] [bp-10h]
  int v4; // [sp+4h] [bp-Ch]

  v3 = a1;
  v4 = a2;
  gettimeofday((struct timeval *)&v3, 0);
  return 1000LL * v3 + v4 / 0x3E8uLL;
}

//----- (00046184) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::parallelDownloadData(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( a1
    && doRequest(
         *(volatile int **)a1,
         (char *)(a1 + 4),
         *(char **)(a1 + 1028),
         (int *)(a1 + 1032),
         (double)*(signed int *)(a1 + 1036),
         *(_DWORD *)(a1 + 1040),
         0,
         0) >= 0
    && **(_DWORD **)v1
    && *(_DWORD *)(v1 + 1032) > *(_DWORD *)(v1 + 1044) )
  {
    **(_DWORD **)v1 = 0;
  }
  return 0;
}

//----- (000461D8) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::increaseMaxDownload(AcquireChannelPlayInfo *this)
{
  --*((_DWORD *)this + 24);
  return (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(**((_DWORD **)this + 26) + 8))(
           *((_DWORD *)this + 26),
           *(_DWORD *)(**((_DWORD **)this + 26) + 8),
           0);
}

//----- (00046208) --------------------------------------------------------
bool __fastcall AcquireChannelPlayInfo::isDataDecryptChunkValid(AcquireChannelPlayInfo *this, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  char v4; // r6
  char v5; // r7
  int v6; // r2
  char *v7; // r3
  unsigned __int8 *v8; // r1
  int v9; // r2
  bool v10; // nf
  int v11; // r4
  char v12; // r5

  v3 = *((unsigned __int8 *)this + 2);
  v4 = *(_BYTE *)this;
  v5 = *((_BYTE *)this + 1);
  v6 = -4 - v3 - *((unsigned __int8 *)this + 3);
  v7 = (char *)this + v3;
  v8 = &a2[v6];
  v9 = 0;
  do
  {
    v10 = v9 << 31 < 0;
    v11 = (int)&v7[v9++];
    if ( v10 )
      v12 = v5;
    else
      v12 = v4;
    *(_BYTE *)(v11 + 4) ^= v12;
  }
  while ( v9 != 4 );
  return _byteswap_ulong(*((_DWORD *)v7 + 1)) - (unsigned int)(v8 - 4) <= 0;
}

//----- (0004625A) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::isDataValid(LinkManager *a1)
{
  LinkManager *v1; // r4
  int result; // r0
  unsigned __int8 *v3; // r3
  signed int v4; // r2
  int v5; // r1
  signed int v6; // r3
  LinkManager *v7; // r0
  int v8; // r2
  void **v9; // r5
  _BOOL4 v10; // r4

  v1 = a1;
  if ( !a1 )
    return 4;
  v3 = (unsigned __int8 *)*((_DWORD *)a1 + 3);
  if ( !v3 )
    return 4;
  v4 = *((_DWORD *)a1 + 2);
  if ( v4 <= 3 )
    return 4;
  v5 = (v3[1] << 16) | (*v3 << 24) | v3[3];
  v6 = _byteswap_ulong(*(_DWORD *)v3);
  if ( v6 > 0 )
  {
    result = v6 - (v4 - 4);
    if ( v6 != v4 - 4 )
      result = 1;
    return result;
  }
  if ( !v6 )
    return 2;
  if ( v6 == -1 )
  {
    *((_DWORD *)a1 + 2) = 4;
    return 3;
  }
  v7 = LinkManager::deepCopyElement(a1);
  v9 = (void **)v7;
  if ( !v7 )
    return 4;
  v10 = AcquireChannelPlayInfo::isDataDecryptChunkValid(
          (AcquireChannelPlayInfo *)(*((_DWORD *)v7 + 3) + 4),
          (unsigned __int8 *)(*((_DWORD *)v1 + 2) - 4),
          v8);
  LinkManager::deepDestroyElement(v9);
  if ( v10 )
    result = 0;
  else
    result = 4;
  return result;
}

//----- (000462CC) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::getStartPieceId(AcquireChannelPlayInfo *this)
{
  return *((_DWORD *)this + 11);
}

//----- (000462D0) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::parseCdnName(AcquireChannelPlayInfo *this, char *a2, char *a3)
{
  pthread_mutex_t *v3; // r4
  char *v4; // r7
  char *v5; // r6
  char *v6; // r0
  char *v7; // r3
  char *v8; // r1
  int v9; // r2
  int v10; // t1
  const char *v11; // r1
  char *v12; // r5

  v3 = (pthread_mutex_t *)((char *)this + 72);
  v4 = a2;
  v5 = a3;
  pthread_mutex_lock((pthread_mutex_t *)this + 3);
  v6 = strstr(v4, "cdn.");
  if ( v6 )
  {
    v7 = v6;
    while ( 1 )
    {
      v8 = v7;
      if ( v7 < v4 )
        break;
      v10 = (unsigned __int8)*v7--;
      v9 = v10;
      if ( v10 == 46 )
        break;
      if ( (unsigned int)(v9 - 48) <= 9 )
      {
        v11 = v8 + 1;
        v12 = &v5[v6 - v11];
        strncpy(v5, v11, v6 - v11);
        strcpy(v12, "cdb");
        v12[3] = 0;
        return j_pthread_mutex_unlock(v3);
      }
    }
  }
  return j_pthread_mutex_unlock(v3);
}

//----- (00046330) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::pollingCDNList(int result, char *a2, int a3)
{
  int v3; // r4
  char *v4; // r7
  pthread_mutex_t *v5; // r5
  int v6; // ST04_4
  double v7; // d7
  int v8; // r0
  int v9; // r6

  v3 = result;
  v4 = a2;
  if ( *(_DWORD *)(result + 52) )
  {
    v5 = (pthread_mutex_t *)(result + 76);
    v6 = a3;
    pthread_mutex_lock((pthread_mutex_t *)(result + 76));
    v7 = (double)v6 - FifoDataManager::getWriteDataTime((FifoDataManager *)*(_DWORD *)(v3 + 52));
    if ( v7 <= (double)(signed int)delay_time * 0.25 )
    {
      v8 = *(_DWORD *)(v3 + 60);
      v9 = *(_DWORD *)(v8 + 32072);
      ChannelPlayInfoManager::changeCdnWithType(v8, 1, v4);
      if ( v9 != *(_DWORD *)(*(_DWORD *)(v3 + 60) + 32072) )
      {
        add_chcdn();
        if ( !*(_BYTE *)(v3 + 100) )
        {
          add_chcdnonce();
          *(_BYTE *)(v3 + 100) = 1;
        }
      }
    }
    else if ( v7 <= (double)(signed int)delay_time * 0.75 )
    {
      add_chcdnmid();
    }
    else
    {
      add_chcdnlast();
    }
    result = j_pthread_mutex_unlock(v5);
  }
  return result;
}
// F30DC: using guessed type int *delay_time;

//----- (000463E4) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::insertInfoWithDataUnit(int a1, int *a2)
{
  int *i; // r4
  int v3; // r6
  int *v4; // r3
  int *v5; // r2
  int v6; // r1
  int v7; // r0
  int v8; // t1
  unsigned __int64 v9; // r0
  int v10; // r7
  int *v11; // r3
  int *v12; // r2
  int v13; // r0
  int v14; // r1
  int *v15; // r4
  int v16; // r0
  _DWORD *v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r4
  int v22; // r1
  unsigned __int64 v23; // r2
  int v25; // [sp+0h] [bp-38h]
  int v26; // [sp+4h] [bp-34h]
  int v27; // [sp+8h] [bp-30h]
  int v28; // [sp+Ch] [bp-2Ch]
  int v29; // [sp+10h] [bp-28h]
  int v30; // [sp+14h] [bp-24h]
  unsigned __int64 v31; // [sp+18h] [bp-20h]

  v3 = a1 + 84;
  for ( i = *(int **)(a1 + 84); i != (int *)v3; i = (int *)*i )
  {
    if ( !i[2] )
    {
      v4 = a2;
      v5 = i + 2;
      v6 = (int)(a2 + 5);
      do
      {
        v8 = *v4;
        ++v4;
        v7 = v8;
        *v5 = v8;
        ++v5;
      }
      while ( v4 != (int *)v6 );
      v9 = sub_4615E(v7, v6);
      *((_QWORD *)i + 4) = v9;
      return v9;
    }
  }
  v10 = (int)(a2 + 4);
  v11 = a2;
  v12 = &v25;
  do
  {
    v13 = *v11;
    v11 += 2;
    v14 = *(v11 - 1);
    *v12 = v13;
    v12[1] = v14;
    v15 = v12 + 2;
    v12 += 2;
  }
  while ( v11 != (int *)v10 );
  v16 = *v11;
  *v15 = *v11;
  v31 = sub_4615E(v16, v14);
  v17 = operator new(0x28u);
  if ( v17 != (_DWORD *)-8 )
  {
    v18 = v26;
    v19 = v27;
    v20 = v28;
    v17[2] = v25;
    v17[3] = v18;
    v17[4] = v19;
    v17[5] = v20;
    v21 = (int)(v17 + 6);
    v22 = v30;
    v23 = v31;
    *(_DWORD *)v21 = v29;
    *(_DWORD *)(v21 + 4) = v22;
    *(_QWORD *)(v21 + 8) = v23;
  }
  LODWORD(v9) = sub_94CBC(v17, v3);
  return v9;
}

//----- (0004646A) --------------------------------------------------------
char *__fastcall AcquireChannelPlayInfo::resetInfoWithPieceId(AcquireChannelPlayInfo *this, unsigned int a2)
{
  char *result; // r0
  char *i; // r3
  char *v4; // t1

  v4 = (char *)*((_DWORD *)this + 21);
  result = (char *)this + 84;
  for ( i = v4; i != result; i = *(char **)i )
  {
    if ( a2 == *((_DWORD *)i + 2) )
      return (char *)j_memset(i + 8, 0, 0x20u);
  }
  return result;
}

//----- (0004648A) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::isValidFlvDataWithDataUnit(int a1, LinkManager *a2)
{
  LinkManager *v2; // r6
  int v3; // r0
  int *i; // r7
  int *v5; // t1
  unsigned __int64 v6; // r0
  int v7; // r8
  unsigned __int64 v8; // r4
  int v9; // r3

  v2 = a2;
  v5 = *(int **)(a1 + 84);
  v3 = a1 + 84;
  for ( i = v5; ; i = (int *)*i )
  {
    if ( i == (int *)v3 )
      return 0;
    if ( *(_DWORD *)a2 == i[2] )
      break;
  }
  v6 = sub_4615E(v3, (int)a2);
  v7 = i[4];
  v8 = v6 - *((_QWORD *)i + 4);
  memset(i + 2, 0, 0x20u);
  addFlvCDNRecveiveTime(v8);
  v9 = *((_DWORD *)v2 + 1);
  if ( v9 > 0 && v9 + v7 == *((_DWORD *)v2 + 2) )
    *((_DWORD *)v2 + 1) = 0;
  if ( *((_DWORD *)v2 + 1) )
  {
    if ( *((_DWORD *)v2 + 2) != v7 )
    {
      add_FlvP2pCDNLenVerifyFailCount();
      return 0;
    }
    add_FlvP2pCDNLenVerifySucCount();
  }
  else
  {
    switch ( AcquireChannelPlayInfo::isDataValid(v2) )
    {
      case 0:
        add_FlvCDNDataVerifySucCount();
        return 1;
      case 1:
        add_FlvCDNLenVerifyFailCount();
        return 0;
      case 2:
        add_FlvCDNEmptyDataCount();
        return 1;
      case 3:
        add_FlvCDNEndDataCount();
        return 1;
      case 4:
        add_FlvCDNDataVerifyFailCount();
        return 0;
      default:
        return 1;
    }
  }
  return 1;
}

//----- (00046530) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::downloadPieceDataWithDataUnit(int a1, unsigned int *a2)
{
  int v2; // r4
  unsigned int v3; // r2
  unsigned int *v4; // r5
  signed int result; // r0
  int *v6; // r0
  int i; // r1
  unsigned int *v8; // r3

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 44);
  v4 = a2;
  if ( *a2 >= v3 )
  {
    a2[4] = 0;
    LinkManager::lockTheLink(*(LinkManager **)(a1 + 56));
    v6 = *(int **)(v2 + 56);
    for ( i = *v6; ; i = *(_DWORD *)(i + 16) )
    {
      v8 = *(unsigned int **)(i + 16);
      if ( !v8 )
        break;
      if ( *v8 == *v4 )
      {
        LinkManager::destroyElement(v4, i, *v4);
        LinkManager::unlockTheLink(*(LinkManager **)(v2 + 56));
        goto LABEL_10;
      }
      if ( *v8 > *v4 )
        break;
    }
    LinkManager::insertElement((int)v6, i, (int)v4);
    LinkManager::unlockTheLink(*(LinkManager **)(v2 + 56));
    (*(void (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v2 + 104) + 8))(
      *(_DWORD *)(v2 + 104),
      *(_DWORD *)(**(_DWORD **)(v2 + 104) + 8));
LABEL_10:
    result = 1;
  }
  else
  {
    LinkManager::destroyElement(a2, (int)a2, v3);
    result = 0;
  }
  return result;
}

//----- (000465A4) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::downloadPieceDataWithPieceid(AcquireChannelPlayInfo *this, unsigned int a2)
{
  unsigned int v2; // r5
  AcquireChannelPlayInfo *v3; // r4
  unsigned int *v4; // r0

  v2 = a2;
  v3 = this;
  v4 = (unsigned int *)LinkManager::initElement(this);
  *v4 = v2;
  return AcquireChannelPlayInfo::downloadPieceDataWithDataUnit((int)v3, v4);
}

//----- (000465BC) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::acquireChannelPlayInfoWithCid(AcquireChannelPlayInfo *this, void *a2)
{
  int *v2; // r6
  unsigned __int8 *v3; // r4
  char *v4; // r10
  int v5; // r1
  int v6; // r0
  int v7; // r3
  int v8; // r5
  int v9; // r1
  int v10; // r3
  __int64 v11; // r8
  void *v12; // r0
  int *v13; // r11
  signed int v14; // r5
  double v15; // d9
  __int64 v16; // r0
  signed int v17; // r8
  double v18; // d8
  ChannelPlayInfoManager *v19; // r0
  int v20; // ST08_4
  int v21; // ST0C_4
  size_t v22; // r0
  size_t v23; // r0
  pthread_attr_t *v24; // r3
  void **v25; // r1
  void *v26; // r2
  int v27; // r1
  int v28; // r5
  char *i; // r3
  const void *v30; // r1
  signed int v31; // r2
  int v32; // r5
  signed int v33; // r3
  pthread_t v34; // r0
  int result; // r0
  char *v36; // r5
  unsigned int v37; // r10
  unsigned int v38; // r9
  int v39; // r3
  unsigned int v40; // lr
  int j; // r3
  int v42; // r3
  _DWORD *v43; // r3
  char *v44; // r5
  int v45; // r2
  int v46; // t1
  int v47; // r5
  unsigned int v48; // r1
  char v49; // [sp+10h] [bp-2530h]
  char v50; // [sp+24F0h] [bp-50h]
  char v51; // [sp+2518h] [bp-28h]
  pthread_attr_t *attr; // [sp+2540h] [bp+0h]
  char *dest; // [sp+2544h] [bp+4h]
  char *format; // [sp+2548h] [bp+8h]
  _DWORD *v55; // [sp+254Ch] [bp+Ch]
  __int64 v56; // [sp+2550h] [bp+10h]
  char *v57; // [sp+2558h] [bp+18h]
  int v58; // [sp+255Ch] [bp+1Ch]
  void **v59; // [sp+2560h] [bp+20h]
  int v60; // [sp+2564h] [bp+24h]
  void *v61; // [sp+256Ch] [bp+2Ch]
  int v62; // [sp+2570h] [bp+30h]
  int v63; // [sp+2574h] [bp+34h]
  int v64; // [sp+2768h] [bp+228h]
  int v65; // [sp+295Ch] [bp+41Ch]

  v2 = &GLOBAL_OFFSET_TABLE_;
  v3 = (unsigned __int8 *)this;
  *((_DWORD *)this + 5) = 0;
  v61 = malloc(0x7A120u);
  memset(v61, 0, 0x7A120u);
  getTime();
  v57 = &v50;
  v4 = &v49;
  v5 = 0;
  v59 = (void **)&v51;
  v55 = &_stack_chk_guard;
  do
  {
    v6 = (int)v57;
    v59[v5] = 0;
    *(_DWORD *)(v6 + v5 * 4) = 0;
    ++v5;
  }
  while ( v5 != 9 );
  v7 = *((_DWORD *)v3 + 15);
  v8 = 0;
  v9 = *(_DWORD *)(v7 + 1032);
  v10 = *(_DWORD *)(v7 + 4);
  v60 = v9;
  v11 = v10;
  v62 = 1;
  v58 = 3 * v9;
  while ( v8 < v58 )
  {
    v12 = malloc(0x2800u);
    v59[v8++] = v12;
    memset(v12, 0, 0x2800u);
  }
  v13 = &v62;
  v14 = (signed int)&v49;
  v15 = COERCE_DOUBLE(getTime());
  v16 = v11;
  v17 = 0;
  v18 = v15;
  v56 = v16 / 5000;
  format = "%s/flv.head?time=%lld&platform=%s&device=%s";
  while ( 1 )
  {
    if ( v3[36] || v17 >= v58 )
      goto LABEL_71;
    attr = (pthread_attr_t *)v3[36];
    v19 = (ChannelPlayInfoManager *)*((_DWORD *)v3 + 15);
    dest = (char *)&v63;
    ChannelPlayInfoManager::getCdnUrlWithIndex(v19, (char *)&v63, v17 % v60);
    v20 = *(int *)((char *)v2 + 0xFFFFFA30);
    v21 = *(int *)((char *)v2 + 0xFFFFFA34);
    sprintf((char *)&v64, format, dest);
    *(_DWORD *)v14 = v13;
    dest = (char *)(v14 + 4);
    v22 = strlen((const char *)&v64);
    strncpy(dest, (const char *)&v64, v22);
    v23 = strlen((const char *)&v64);
    v24 = attr;
    v25 = v59;
    v4[1048 * v17 + 4 + v23] = (char)attr;
    v26 = v25[v17];
    v27 = (int)v57;
    *(_DWORD *)(v14 + 1032) = v24;
    *(_DWORD *)(v14 + 1028) = v26;
    *(_DWORD *)(v14 + 1044) = 12;
    *(_DWORD *)(v14 + 1036) = 6;
    *(_DWORD *)(v14 + 1040) = v24;
    pthread_create((pthread_t *)(v27 + 4 * v17), v24, *(void *(**)(void *))((char *)v2 + 0xFFFFFB68), (void *)v14);
    while ( !v3[36] && *v13 && v18 - v15 < (double)(v17 + 1) )
    {
      usleep(0x2710u);
      v18 = COERCE_DOUBLE(getTime());
    }
    if ( !*v13 )
    {
LABEL_71:
      if ( v3[36] )
        goto LABEL_23;
      v18 = 4.0;
      v15 = COERCE_DOUBLE(getTime());
      while ( !v3[36] && v62 )
      {
        usleep(0x2710u);
        if ( COERCE_DOUBLE(getTime()) - v15 > 4.0 )
          goto LABEL_23;
      }
      v28 = v3[36];
      if ( v3[36] )
        goto LABEL_23;
      for ( i = v4; ; i += 1048 )
      {
        if ( v28 >= v58 )
        {
          v17 = -1;
          goto LABEL_22;
        }
        v30 = (const void *)*((_DWORD *)i + 257);
        if ( v30 )
        {
          v31 = *((_DWORD *)i + 258);
          if ( v31 > *((_DWORD *)v4 + 261) )
            break;
        }
        ++v28;
      }
      memcpy(v61, v30, v31);
      v17 = *(_DWORD *)&v4[1048 * v28 + 1032];
      v32 = v28 % v60;
      ChannelPlayInfoManager::setCdnSrcIndex(*((ChannelPlayInfoManager **)v3 + 15), v32);
      if ( v32 )
        add_fhchcdn();
LABEL_22:
      if ( v17 < *((_DWORD *)v4 + 261) )
        goto LABEL_23;
      if ( v3[36] )
      {
LABEL_23:
        v33 = 0;
      }
      else
      {
        v36 = (char *)v61;
        v37 = _byteswap_ulong(*(_DWORD *)v61);
        v38 = _byteswap_ulong(*((_DWORD *)v61 + 1));
        *((_DWORD *)v3 + 11) = _byteswap_ulong(*((_DWORD *)v61 + 2));
        v13 = (int *)*((_DWORD *)v3 + 11);
        *(_QWORD *)*(int *)((char *)v2 + 0xFFFFFB6C) = getTime();
        v39 = **(_DWORD **)((char *)v2 + 0xFFFFF998);
        v60 = *(int *)((char *)v2 + 0xFFFFF998);
        v40 = v37 - v39;
        for ( j = (int)(v36 + 12);
              v38 - 1 > (-8 - (signed int)v36 + j) >> 2;
              *((_DWORD *)v3 + 11) = (*(unsigned __int8 *)(j - 3) << 16) | (*(unsigned __int8 *)(j - 4) << 24) | *(unsigned __int8 *)(j - 1) | (*(unsigned __int8 *)(j - 2) << 8) )
        {
          j += 4;
          if ( *((_DWORD *)v3 + 11) >= v40 )
            break;
          v13 = (int *)*((_DWORD *)v3 + 11);
        }
        v42 = *(_DWORD *)v60;
        if ( *((_DWORD *)v3 + 11) > v37 - *(_DWORD *)v60 )
          *((_DWORD *)v3 + 11) = v13;
        v4 = (char *)(v37 - *((_DWORD *)v3 + 11));
        *((_DWORD *)v3 + 12) = &v4[-v42];
        if ( **(_BYTE **)((char *)v2 + 0xFFFFFA74) && **(_BYTE **)((char *)v2 + 0xFFFFFA0C) )
          add_rtmpToData_delayTime(*((_DWORD *)v3 + 12) + 6);
        add_play_fh();
        sendEventToPlayer(1);
        v2 = (int *)*((_DWORD *)v3 + 11);
        if ( v17 != -1 )
        {
          v43 = v3;
          v44 = &v36[4 * (v38 + 2)];
          v45 = (int)(v44 + 12);
          do
          {
            v46 = *(_DWORD *)v44;
            v44 += 4;
            *v43 = v46;
            ++v43;
          }
          while ( v44 != (char *)v45 );
          *(_BYTE *)v43 = *v44;
        }
        v47 = 0;
        *((_DWORD *)v3 + 5) = 2;
        while ( 1 )
        {
          v48 = (unsigned int)v2 + v47;
          if ( v47 >= *((_DWORD *)v3 + 8) )
            break;
          ++v47;
          AcquireChannelPlayInfo::downloadPieceDataWithPieceid((AcquireChannelPlayInfo *)v3, v48);
        }
        v33 = 1;
      }
    }
    else
    {
      v14 += 1048;
      if ( !v3[36] )
        goto LABEL_43;
      v33 = 0;
      *v13 = 0;
    }
    if ( *((_DWORD *)v3 + 5) != 2 )
      *((_DWORD *)v3 + 5) = 3;
    if ( !v3[36] && !v33 )
      sendEventToPlayer(257);
    if ( v62 )
      v62 = 0;
    v3 = (unsigned __int8 *)v59;
    v14 = 0;
    while ( v14 < v58 )
    {
      v34 = *(_DWORD *)&v57[4 * v14];
      if ( v34 )
        pthread_join(v34, 0);
      ++v14;
      ffFree((void **)v3);
      v3 += 4;
    }
    ffFree(&v61);
    result = 0;
    if ( v65 == *v55 )
      return result;
LABEL_43:
    ++v17;
  }
}
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (00046A34) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::downloadPieceDataWithPieceid(AcquireChannelPlayInfo *this, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // r5
  AcquireChannelPlayInfo *v5; // r4
  int v6; // r6
  int v7; // r7
  unsigned int *v8; // r0

  v4 = a2;
  v5 = this;
  v6 = a3;
  v7 = a4;
  v8 = (unsigned int *)LinkManager::initElement(this);
  *v8 = v4;
  v8[1] = v6;
  v8[2] = v7;
  return AcquireChannelPlayInfo::downloadPieceDataWithDataUnit((int)v5, v8);
}

//----- (00046A52) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::stopDownloadThread(int result)
{
  *(_BYTE *)(result + 36) = 1;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

//----- (00046A5E) --------------------------------------------------------
_DWORD *__fastcall std::_List_base<DataUnitInfo,std::allocator<DataUnitInfo>>::_M_clear(_DWORD **a1)
{
  _DWORD *v1; // r4
  _DWORD *result; // r0
  _DWORD *v3; // r5

  v1 = a1;
  for ( result = *a1; result != v1; result = v3 )
  {
    v3 = (_DWORD *)*result;
    operator delete(result);
  }
  return result;
}

//----- (00046A74) --------------------------------------------------------
void __fastcall std::deque<long,std::allocator<long>>::pop_front(int a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  int v3; // r3
  int v4; // r3

  v1 = (_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 == *(_DWORD *)(a1 + 16) - 4 )
  {
    operator delete(*(void **)(a1 + 12));
    v4 = v1[5];
    v1[5] = v4 + 4;
    v3 = *(_DWORD *)(v4 + 4);
    v1[4] = v3 + 512;
    v1[3] = v3;
  }
  else
  {
    v3 = v2 + 4;
  }
  v1[2] = v3;
}

//----- (00046AA0) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_iterator<long,long &,long *>::_Deque_iterator(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  return result;
}

//----- (00046AB2) --------------------------------------------------------
int __fastcall std::deque<long,std::allocator<long>>::~deque(int a1)
{
  int v1; // r4
  void **v2; // r5
  unsigned int v3; // r6
  void *v4; // t1
  int v6; // [sp+0h] [bp-30h]
  char v7; // [sp+10h] [bp-20h]

  v1 = a1;
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v6, (_DWORD *)(a1 + 8));
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v7, (_DWORD *)(v1 + 24));
  if ( *(_DWORD *)v1 )
  {
    v2 = *(void ***)(v1 + 20);
    v3 = *(_DWORD *)(v1 + 36) + 4;
    while ( (unsigned int)v2 < v3 )
    {
      v4 = *v2;
      ++v2;
      operator delete(v4);
    }
    operator delete(*(void **)v1);
  }
  return v1;
}

//----- (00046AF0) --------------------------------------------------------
AcquireChannelPlayInfo *__fastcall AcquireChannelPlayInfo::~AcquireChannelPlayInfo(AcquireChannelPlayInfo *this)
{
  AcquireChannelPlayInfo *v1; // r4
  _DWORD **v2; // r6
  pthread_t v3; // r0
  void *v4; // r5
  int v5; // r5
  void *v6; // r0
  void *v7; // r0
  int v8; // r5
  void *v9; // r0
  void *v10; // r0

  v1 = this;
  v2 = (_DWORD **)((char *)this + 84);
  AcquireChannelPlayInfo::stopDownloadThread((int)this);
  v3 = *((_DWORD *)v1 + 20);
  if ( v3 )
    pthread_join(v3, 0);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 76));
  pthread_mutex_destroy((pthread_mutex_t *)v1 + 3);
  v4 = (void *)*((_DWORD *)v1 + 14);
  if ( v4 )
  {
    LinkManager::~LinkManager(*((LinkManager **)v1 + 14));
    operator delete(v4);
    *((_DWORD *)v1 + 14) = 0;
  }
  v5 = *((_DWORD *)v1 + 16);
  if ( v5 )
  {
    v6 = *(void **)(v5 + 4);
    if ( v6 )
      operator delete[](v6);
    v7 = *(void **)(v5 + 8);
    if ( v7 )
      operator delete[](v7);
    pthread_mutex_destroy((pthread_mutex_t *)(v5 + 52));
    std::deque<long,std::allocator<long>>::~deque(v5 + 12);
    operator delete((void *)v5);
    *((_DWORD *)v1 + 16) = 0;
  }
  v8 = *((_DWORD *)v1 + 17);
  if ( v8 )
  {
    v9 = *(void **)(v8 + 4);
    if ( v9 )
      operator delete[](v9);
    v10 = *(void **)(v8 + 8);
    if ( v10 )
      operator delete[](v10);
    pthread_mutex_destroy((pthread_mutex_t *)(v8 + 52));
    std::deque<long,std::allocator<long>>::~deque(v8 + 12);
    operator delete((void *)v8);
    *((_DWORD *)v1 + 17) = 0;
  }
  std::_List_base<DataUnitInfo,std::allocator<DataUnitInfo>>::_M_clear(v2);
  return v1;
}

//----- (00046BB0) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::checkDownloading(int result)
{
  int i; // r4
  LinkManager *v2; // r0
  int *v3; // r5
  LinkManager *v4; // r0
  int v5; // r6
  int v6; // r9
  int v7; // r7
  int v8; // r6
  int v9; // r9
  int v10; // r2
  int v11; // r6
  pthread_mutex_t *v12; // r0
  int *v13; // r3
  int *v14; // r2
  int v15; // t1
  int v16; // r1
  int v17; // r2
  int *v18; // [sp+10h] [bp-38h]

  for ( i = result;
        *(_DWORD *)(i + 96) <= 3 && !*(_BYTE *)(i + 36);
        result = CurlWrapper::new_session(
                   *(int **)(i + 108),
                   (const char *)(v7 + 12),
                   v7,
                   (int)flvDataWrite_cb,
                   (int)flvDataDownloadFinish_cb,
                   (int)flvDataDownloadError_cb) )
  {
    LinkManager::lockTheLink(*(LinkManager **)(i + 56));
    v2 = *(LinkManager **)(i + 56);
    v3 = *(int **)(*(_DWORD *)v2 + 16);
    if ( !v3 )
      return LinkManager::unlockTheLink(v2);
    LinkManager::deleteElement((int *)v2, *(_DWORD *)(*(_DWORD *)v2 + 16));
    v4 = *(LinkManager **)(i + 56);
    ++*(_DWORD *)(i + 96);
    LinkManager::unlockTheLink(v4);
    v5 = *(_DWORD *)(i + 68);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 52));
    if ( *(_DWORD *)(v5 + 36) != *(_DWORD *)(v5 + 20)
      && (std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v18, (_DWORD *)(v5 + 20)),
          v6 = *v18,
          *(_BYTE *)(*(_DWORD *)(v5 + 8) + *v18)) )
    {
      std::deque<long,std::allocator<long>>::pop_front(v5 + 12);
      *(_BYTE *)(*(_DWORD *)(v5 + 8) + v6) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 52));
      v7 = *(_DWORD *)(v5 + 4) + 2440 * v6;
    }
    else
    {
      v7 = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 52));
    }
    v8 = *(_DWORD *)(i + 64);
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 52));
    if ( *(_DWORD *)(v8 + 36) != *(_DWORD *)(v8 + 20)
      && (std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v18, (_DWORD *)(v8 + 20)),
          v9 = *v18,
          *(_BYTE *)(*(_DWORD *)(v8 + 8) + *v18)) )
    {
      std::deque<long,std::allocator<long>>::pop_front(v8 + 12);
      *(_BYTE *)(*(_DWORD *)(v8 + 8) + v9) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 52));
      v10 = *(_DWORD *)(v8 + 4);
      v11 = v10 + (_DWORD)&unk_100018 * v9;
    }
    else
    {
      v12 = (pthread_mutex_t *)(v8 + 52);
      v11 = 0;
      pthread_mutex_unlock(v12);
    }
    *(_DWORD *)(v7 + 8) = v11;
    *(_DWORD *)(v11 + 1048596) = i;
    ChannelPlayInfoManager::getCurrentCdnUrl(*(ChannelPlayInfoManager **)(i + 60), (char *)(v7 + 12), v10);
    sprintf((char *)(v7 + 12), "%s/%x.data?cdnversion=%d", v7 + 12, *v3, cdnversion);
    *(_BYTE *)(v7 + 2328) = 1;
    sprintf((char *)(v7 + 2329), "%d-", v3[1]);
    v13 = v3;
    v14 = (int *)v11;
    do
    {
      v15 = *v13;
      ++v13;
      *v14 = v15;
      ++v14;
    }
    while ( v13 != v3 + 5 );
    *(_DWORD *)(v11 + 8) = 0;
    AcquireChannelPlayInfo::insertInfoWithDataUnit(i, v3);
    add_FlvCDNRequestCount();
    if ( v3[1] > 0 )
      add_FlvP2pCDNCount();
    LinkManager::destroyElement(v3, v16, v17);
  }
  return result;
}
// F3930: using guessed type int cdnversion;

//----- (00046D74) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_base<long,std::allocator<long>>::_Deque_base(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  std::_Deque_base<long,std::allocator<long>>::_M_initialize_map(a1, 0);
  return v1;
}

//----- (00046D96) --------------------------------------------------------
_DWORD *__fastcall std::__copy_move_a2<false,std::_Deque_iterator<long,long const&,long const*>,std::_Deque_iterator<long,long &,long *>>(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, _DWORD *a10)
{
  _DWORD *v10; // r6
  int v11; // r2
  int *v12; // r3
  int v13; // r0
  int i; // r1
  int v15; // t1
  _DWORD *v16; // r4
  int v18; // [sp+0h] [bp-A0h]
  char v19; // [sp+10h] [bp-90h]
  int *v20; // [sp+20h] [bp-80h]
  int v21; // [sp+24h] [bp-7Ch]
  int v22; // [sp+28h] [bp-78h]
  int v23; // [sp+2Ch] [bp-74h]
  int v24; // [sp+30h] [bp-70h]
  int v25; // [sp+34h] [bp-6Ch]
  int v26; // [sp+38h] [bp-68h]
  int v27; // [sp+3Ch] [bp-64h]
  int v28; // [sp+40h] [bp-60h]
  int v29; // [sp+44h] [bp-5Ch]
  int v30; // [sp+48h] [bp-58h]
  int v31; // [sp+4Ch] [bp-54h]
  int v32; // [sp+50h] [bp-50h]
  int v33; // [sp+54h] [bp-4Ch]
  int v34; // [sp+58h] [bp-48h]
  int v35; // [sp+5Ch] [bp-44h]
  int v36; // [sp+60h] [bp-40h]
  int v37; // [sp+64h] [bp-3Ch]
  int v38; // [sp+68h] [bp-38h]
  int v39; // [sp+6Ch] [bp-34h]
  int v40; // [sp+70h] [bp-30h]
  int v41; // [sp+74h] [bp-2Ch]
  int v42; // [sp+78h] [bp-28h]
  int v43; // [sp+7Ch] [bp-24h]
  int *v44; // [sp+80h] [bp-20h]
  int v45; // [sp+84h] [bp-1Ch]
  int v46; // [sp+88h] [bp-18h]
  int v47; // [sp+8Ch] [bp-14h]
  int v48; // [sp+90h] [bp-10h]
  int v49; // [sp+94h] [bp-Ch]
  int v50; // [sp+98h] [bp-8h]
  int v51; // [sp+9Ch] [bp-4h]
  _DWORD *v52; // [sp+A0h] [bp+0h]
  _DWORD *v53; // [sp+A4h] [bp+4h]
  _DWORD *v54; // [sp+A8h] [bp+8h]
  _DWORD *v55; // [sp+ACh] [bp+Ch]
  int vars1C; // [sp+CCh] [bp+2Ch]
  int anonymous0; // [sp+D0h] [bp+30h]
  int anonymous1; // [sp+D4h] [bp+34h]

  v10 = a1;
  vars1C = a2;
  anonymous0 = a3;
  anonymous1 = a4;
  v28 = a2;
  v29 = a3;
  v30 = a4;
  v31 = a5;
  v20 = (int *)a2;
  v21 = a3;
  v22 = a4;
  v23 = a5;
  v32 = a2;
  v33 = a3;
  v34 = a4;
  v35 = a5;
  v36 = a6;
  v37 = a7;
  v38 = a8;
  v39 = a9;
  v40 = a6;
  v41 = a7;
  v42 = a8;
  v43 = a9;
  v24 = a6;
  v25 = a7;
  v26 = a8;
  v27 = a9;
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v18, a10);
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v52, &v18);
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v19, &v52);
  v44 = v20;
  v45 = v21;
  v46 = v22;
  v47 = v23;
  v48 = v24;
  v49 = v25;
  v50 = v26;
  v51 = v27;
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(&v52, &v19);
  v11 = v47;
  v12 = v44;
  v13 = v46;
  for ( i = ((v48 - v49) >> 2) + ((((v51 - v47) >> 2) - 1) << 7) + ((v46 - (signed int)v44) >> 2); i > 0; --i )
  {
    v15 = *v12;
    ++v12;
    *v52 = v15;
    if ( v12 == (int *)v13 )
    {
      v12 = *(int **)(v11 + 4);
      v11 += 4;
      v13 = (int)(v12 + 128);
    }
    ++v52;
    if ( v52 == v54 )
    {
      ++v55;
      v16 = (_DWORD *)*v55;
      v54 = (_DWORD *)(*v55 + 512);
      v53 = v16;
      v52 = v16;
    }
  }
  std::_Deque_iterator<long,long &,long *>::_Deque_iterator(v10, &v52);
  return v10;
}

//----- (00046E7A) --------------------------------------------------------
char *__fastcall std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<long *>(void *src, int a2, char *a3)
{
  int v3; // r1
  char *v4; // r3
  size_t v5; // r4

  v3 = a2 - (_DWORD)src;
  v4 = a3;
  v5 = 4 * (v3 >> 2);
  if ( v3 >> 2 )
    v4 = (char *)memmove(a3, src, v5);
  return &v4[v5];
}

//----- (00046E9A) --------------------------------------------------------
unsigned int *__fastcall std::deque<long,std::allocator<long>>::push_back(unsigned int *result, _DWORD *a2)
{
  void **v2; // r4
  _DWORD *v3; // r8
  _DWORD *v4; // r3
  int v5; // r3
  unsigned int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r3
  unsigned int v9; // r6
  int v10; // r7
  int v11; // r9
  int v12; // r1
  char *v13; // r5
  int v14; // r1
  signed int v15; // r2
  unsigned int v16; // r6
  char *v17; // r0
  char *v18; // r10
  char *v19; // r3
  int v20; // r3
  _DWORD *v21; // r5
  _DWORD *v22; // r3
  _DWORD *v23; // r3

  v2 = (void **)result;
  v3 = a2;
  v4 = (_DWORD *)result[6];
  if ( v4 == (_DWORD *)(result[8] - 4) )
  {
    v6 = result[9];
    v7 = *result;
    v8 = result[1];
    if ( v8 - ((signed int)(v6 - *result) >> 2) <= 1 )
    {
      v9 = result[5];
      v10 = ((signed int)(v6 - v9) >> 2) + 1;
      v11 = ((signed int)(v6 - v9) >> 2) + 2;
      if ( v8 <= 2 * v11 )
      {
        if ( v8 )
          v15 = result[1];
        else
          v15 = 1;
        v16 = v8 + 2 + v15;
        if ( v16 >= 0x40000000 )
          sub_BFA08();
        v17 = (char *)operator new(4 * v16);
        v13 = &v17[4 * ((v16 - v11) >> 1)];
        v18 = v17;
        std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<long *>(v2[5], (int)v2[9] + 4, v13);
        operator delete(*v2);
        *v2 = v18;
        v2[1] = (void *)v16;
      }
      else
      {
        v12 = v6 + 4;
        v13 = (char *)(v7 + 4 * ((v8 - v11) >> 1));
        if ( (unsigned int)v13 >= v9 )
        {
          v14 = (signed int)(v12 - v9) >> 2;
          if ( v14 )
            memmove(&v13[4 * v10 + -4 * v14], (const void *)result[5], 4 * v14);
        }
        else
        {
          std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<long *>(
            (void *)result[5],
            v12,
            (char *)(v7 + 4 * ((v8 - v11) >> 1)));
        }
      }
      v2[5] = v13;
      v19 = *(char **)v13;
      v2[3] = *(void **)v13;
      v2[4] = v19 + 512;
      v2[9] = &v13[4 * (v10 + 0x3FFFFFFF)];
      v20 = *(_DWORD *)&v13[4 * (v10 + 0x3FFFFFFF)];
      v2[7] = (void *)v20;
      v2[8] = (void *)(v20 + 512);
    }
    v21 = v2[9];
    result = (unsigned int *)operator new(0x200u);
    v21[1] = result;
    v22 = v2[6];
    if ( v22 )
      *v22 = *v3;
    v23 = v2[9];
    v2[9] = v23 + 1;
    v5 = v23[1];
    v2[8] = (void *)(v5 + 512);
    v2[7] = (void *)v5;
  }
  else
  {
    if ( v4 )
      *v4 = *a2;
    v5 = result[6] + 4;
  }
  v2[6] = (void *)v5;
  return result;
}

//----- (00046F9C) --------------------------------------------------------
int __fastcall ResManager<PieceInfo>::free(int result, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r1
  int v5; // r3
  pthread_mutex_t *v6; // r5
  int v7; // r2
  int v8; // [sp+4h] [bp-14h]
  int v9; // [sp+8h] [bp-10h]

  v8 = a2;
  v9 = a3;
  v3 = (_DWORD *)result;
  v4 = a2 - *(_DWORD *)(result + 4);
  v5 = -1908888917 * (v4 >> 3);
  v8 = -1908888917 * (v4 >> 3);
  if ( v5 >= 0 && v5 < *(_DWORD *)result && !*(_BYTE *)(*(_DWORD *)(result + 8) - 1908888917 * (v4 >> 3)) )
  {
    v6 = (pthread_mutex_t *)(result + 52);
    pthread_mutex_lock((pthread_mutex_t *)(result + 52));
    v7 = v3[2];
    if ( !*(_BYTE *)(v7 + v8) )
    {
      memset((void *)(v3[1] + (_DWORD)&unk_100018 * v8), *(unsigned __int8 *)(v7 + v8), (size_t)&unk_100018);
      std::deque<long,std::allocator<long>>::push_back(v3 + 3, &v8);
      *(_BYTE *)(v3[2] + v8) = 1;
    }
    result = pthread_mutex_unlock(v6);
  }
  return result;
}

//----- (00047000) --------------------------------------------------------
int __fastcall ResManager<HttpInfo>::free(int result, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r1
  int v5; // r3
  pthread_mutex_t *v6; // r5
  int v7; // r2
  int v8; // [sp+4h] [bp-14h]
  int v9; // [sp+8h] [bp-10h]

  v8 = a2;
  v9 = a3;
  v3 = (_DWORD *)result;
  v4 = a2 - *(_DWORD *)(result + 4);
  v5 = -1070221359 * (v4 >> 3);
  v8 = -1070221359 * (v4 >> 3);
  if ( v5 >= 0 && v5 < *(_DWORD *)result && !*(_BYTE *)(*(_DWORD *)(result + 8) - 1070221359 * (v4 >> 3)) )
  {
    v6 = (pthread_mutex_t *)(result + 52);
    pthread_mutex_lock((pthread_mutex_t *)(result + 52));
    v7 = v3[2];
    if ( !*(_BYTE *)(v7 + v8) )
    {
      memset((void *)(v3[1] + 2440 * v8), *(unsigned __int8 *)(v7 + v8), 0x988u);
      std::deque<long,std::allocator<long>>::push_back(v3 + 3, &v8);
      *(_BYTE *)(v3[2] + v8) = 1;
    }
    result = pthread_mutex_unlock(v6);
  }
  return result;
}

//----- (00047060) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::flvDataDownloadFinish(int a1, int a2)
{
  int v2; // r4
  unsigned int *v3; // r5
  int v4; // r6
  int v5; // r2
  unsigned int v6; // r7
  int v7; // r0
  unsigned int v8; // r7
  int v9; // r0
  int v10; // r2

  v2 = a1;
  v3 = *(unsigned int **)(a2 + 8);
  v4 = a2;
  v3[3] = (unsigned int)(v3 + 5);
  add_FlvCDNReceiveCount();
  ChannelPlayInfoManager::clearErrorWithType(*(_DWORD *)(v2 + 60), 1);
  if ( !AcquireChannelPlayInfo::isValidFlvDataWithDataUnit(v2, (LinkManager *)v3) )
  {
    AcquireChannelPlayInfo::downloadPieceDataWithPieceid((AcquireChannelPlayInfo *)v2, *v3);
    goto LABEL_11;
  }
  AcquireChannelPlayInfo::parseCdnName((AcquireChannelPlayInfo *)v2, (char *)(v4 + 12), (char *)&dword_F42A0);
  if ( *(_DWORD *)(v2 + 40) && *(_DWORD *)(v2 + 24) )
  {
    v6 = *v3;
    if ( v6 == AcquireChannelPlayInfo::getStartPieceId((AcquireChannelPlayInfo *)v2) )
    {
      v7 = 2;
    }
    else
    {
      v8 = *v3;
      if ( v8 != AcquireChannelPlayInfo::getStartPieceId((AcquireChannelPlayInfo *)v2) + 1 )
      {
LABEL_10:
        (*(void (__fastcall **)(unsigned int *))(v2 + 24))(v3);
        goto LABEL_11;
      }
      v7 = 3;
    }
    sendEventToPlayer(v7);
    goto LABEL_10;
  }
LABEL_11:
  v9 = *(_DWORD *)(v2 + 64);
  --*(_DWORD *)(v2 + 96);
  ResManager<PieceInfo>::free(v9, (int)v3, v5);
  ResManager<HttpInfo>::free(*(_DWORD *)(v2 + 68), v4, v10);
  return (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(v2 + 104) + 8))(
           *(_DWORD *)(v2 + 104),
           *(_DWORD *)(**(_DWORD **)(v2 + 104) + 8),
           0);
}
// F42A0: using guessed type int dword_F42A0;

//----- (0004710C) --------------------------------------------------------
int __fastcall flvDataDownloadFinish_cb(void *a1)
{
  AcquireChannelPlayInfo::flvDataDownloadFinish(*(_DWORD *)(*((_DWORD *)a1 + 2) + 1048596), (int)a1);
  return 0;
}

//----- (00047120) --------------------------------------------------------
int __fastcall AcquireChannelPlayInfo::flvDataDownloadError(int a1, int a2)
{
  int v2; // r7
  int v3; // r4
  int v4; // r6
  int v5; // r5
  int v6; // r0
  int v7; // r2
  int v8; // r2
  char *v10; // r0

  v2 = a2;
  v3 = a1;
  v4 = *(_DWORD *)(a2 + 8);
  add_FlvCDNErrorCount();
  v5 = *(_DWORD *)(v2 + 2060);
  if ( v5 )
  {
    if ( (unsigned int)(v5 - 100) > 0x63 )
    {
      if ( (unsigned int)(v5 - 200) > 0x63 )
      {
        if ( (unsigned int)(v5 - 300) > 0x63 )
        {
          if ( (unsigned int)(v5 - 400) > 0x63 )
          {
            if ( (unsigned int)(v5 - 500) > 0x63 )
            {
              if ( (unsigned int)(v5 - 600) > 0x63 )
                add_FlvCDNErrorxCount();
              else
                add_FlvCDNError6Count();
            }
            else
            {
              add_FlvCDNError5Count();
            }
          }
          else
          {
            add_FlvCDNError4Count();
          }
        }
        else
        {
          add_FlvCDNError3Count();
        }
      }
      else
      {
        add_FlvCDNError2Count();
      }
    }
    else
    {
      add_FlvCDNError1Count();
    }
  }
  else
  {
    add_FlvCDNError0Count();
  }
  if ( *(_DWORD *)(v4 + 4) > 0 )
    add_FlvP2pToRangeCDNToCDNCount();
  if ( v5 != 312 )
  {
    v6 = v3;
    goto LABEL_22;
  }
  if ( !strstr((const char *)(v4 + 20), "video") )
  {
    v6 = v3;
LABEL_22:
    AcquireChannelPlayInfo::pollingCDNList(v6, 0, *(_DWORD *)v4);
    goto LABEL_23;
  }
  v10 = strstr((const char *)(v4 + 20), "\r\n");
  if ( !v10 )
  {
    v10 = strchr((const char *)(v4 + 20), 13);
    if ( !v10 )
      v10 = strchr((const char *)(v4 + 20), 10);
  }
  *v10 = 0;
  ChannelPlayInfoManager::setCdnSrcKey(*(ChannelPlayInfoManager **)(v3 + 60), (char *)(v4 + 20));
  startChangeCdnTime = time(0);
LABEL_23:
  AcquireChannelPlayInfo::downloadPieceDataWithPieceid((AcquireChannelPlayInfo *)v3, *(_DWORD *)v4);
  AcquireChannelPlayInfo::resetInfoWithPieceId((AcquireChannelPlayInfo *)v3, *(_DWORD *)v4);
  ResManager<PieceInfo>::free(*(_DWORD *)(v3 + 64), v4, v7);
  ResManager<HttpInfo>::free(*(_DWORD *)(v3 + 68), v2, v8);
  return (*(int (__cdecl **)(_DWORD, _DWORD))(**(_DWORD **)(v3 + 104) + 8))(
           *(_DWORD *)(v3 + 104),
           *(_DWORD *)(**(_DWORD **)(v3 + 104) + 8));
}
// F5728: using guessed type int startChangeCdnTime;

//----- (00047250) --------------------------------------------------------
int __fastcall flvDataDownloadError_cb(void *a1)
{
  AcquireChannelPlayInfo::flvDataDownloadError(*(_DWORD *)(*((_DWORD *)a1 + 2) + 1048596), (int)a1);
  return 0;
}

//----- (00047264) --------------------------------------------------------
unsigned int *__fastcall ResManager<PieceInfo>::ResManager(unsigned int *a1, unsigned int a2)
{
  unsigned int *v2; // r4
  unsigned int *v3; // r6
  unsigned int v4; // r5
  unsigned int v5; // r0
  int v6; // r8
  char *v7; // r11
  char *v8; // r9
  int v9; // r8
  int v11; // [sp+0h] [bp-50h]

  v2 = a1;
  *a1 = a2;
  v3 = a1 + 3;
  v4 = a2;
  std::_Deque_base<long,std::allocator<long>>::_Deque_base(&v11);
  std::deque<long,std::allocator<long>>::deque(v3, &v11);
  std::deque<long,std::allocator<long>>::~deque((int)&v11);
  pthread_mutex_init((pthread_mutex_t *)(v2 + 13), 0);
  if ( v4 > 0x7F0 )
    v5 = -1;
  else
    v5 = (unsigned int)&unk_100018;
  if ( v4 <= 0x7F0 )
    v5 *= v4;
  v6 = v4 - 1;
  v7 = (char *)operator new[](v5);
  v8 = v7;
  while ( v6 != -1 )
  {
    memset(v8, 0, (size_t)&unk_100018);
    v8 += 1048600;
    --v6;
  }
  v2[1] = (unsigned int)v7;
  v9 = 0;
  v2[2] = (unsigned int)operator new[](v4);
  while ( v9 < (signed int)v4 )
  {
    *(_BYTE *)(v2[2] + v9) = 1;
    v11 = v9;
    std::deque<long,std::allocator<long>>::push_back(v3, &v11);
    ++v9;
  }
  return v2;
}

//----- (00047320) --------------------------------------------------------
unsigned int *__fastcall ResManager<HttpInfo>::ResManager(unsigned int *a1, unsigned int a2)
{
  unsigned int *v2; // r4
  unsigned int *v3; // r6
  unsigned int v4; // r5
  unsigned int v5; // r0
  int v6; // r8
  char *v7; // r11
  char *v8; // r9
  void *v9; // r0
  int v10; // r8
  int v12; // [sp+0h] [bp-50h]

  v2 = a1;
  *a1 = a2;
  v3 = a1 + 3;
  v4 = a2;
  std::_Deque_base<long,std::allocator<long>>::_Deque_base(&v12);
  std::deque<long,std::allocator<long>>::deque(v3, &v12);
  std::deque<long,std::allocator<long>>::~deque((int)&v12);
  pthread_mutex_init((pthread_mutex_t *)(v2 + 13), 0);
  if ( v4 > 0xD6000 )
    v5 = -1;
  else
    v5 = 2440;
  if ( v4 <= 0xD6000 )
    v5 *= v4;
  v6 = v4 - 1;
  v7 = (char *)operator new[](v5);
  v8 = v7;
  while ( v6 != -1 )
  {
    v9 = v8;
    v8 += 2440;
    memset(v9, 0, 0x988u);
    --v6;
  }
  v2[1] = (unsigned int)v7;
  v10 = 0;
  v2[2] = (unsigned int)operator new[](v4);
  while ( v10 < (signed int)v4 )
  {
    *(_BYTE *)(v2[2] + v10) = 1;
    v12 = v10;
    std::deque<long,std::allocator<long>>::push_back(v3, &v12);
    ++v10;
  }
  return v2;
}

//----- (000473D8) --------------------------------------------------------
pthread_mutex_t *__fastcall AcquireChannelPlayInfo::AcquireChannelPlayInfo(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  pthread_mutex_t *v7; // r4
  int v8; // r7
  unsigned int *v9; // r6
  unsigned int *v10; // r6
  LinkManager *v11; // r6

  v7 = (pthread_mutex_t *)a1;
  *(_DWORD *)(a1 + 108) = a2;
  v7[3].__kind = (int)&v7[3].__kind;
  *(_DWORD *)(a1 + 52) = a7;
  v7[3].__nusers = (unsigned int)&v7[3].__kind;
  v8 = a4;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = a3;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 76), 0);
  pthread_mutex_init(v7 + 3, 0);
  v7[2].__kind = v8;
  v7[1].__lock = a5;
  v7[1].__owner = a6;
  v9 = (unsigned int *)operator new(0x38u);
  ResManager<PieceInfo>::ResManager(v9, 8u);
  v7[2].__nusers = (unsigned int)v9;
  v10 = (unsigned int *)operator new(0x38u);
  ResManager<HttpInfo>::ResManager(v10, 8u);
  v7[1].__size[12] = 0;
  v7[1].__nusers = 1;
  v7[2].__spins = (int)v10;
  v7[2].__lock = 0;
  v11 = (LinkManager *)operator new(8u);
  LinkManager::LinkManager(v11);
  v7[2].__owner = (int)v11;
  pthread_create(
    (pthread_t *)&v7[3].__owner,
    0,
    (void *(*)(void *))AcquireChannelPlayInfo::acquireChannelPlayInfoWithCid,
    v7);
  return v7;
}

//----- (00047480) --------------------------------------------------------
_DWORD *sub_47480()
{
  sub_C0AD8(&unk_F415C);
  sub_C0AD8(&unk_F4158);
  sub_C0AD8(&unk_F4154);
  return sub_C0AD8(VideoDefinitionString);
}

//----- (000474AC) --------------------------------------------------------
signed int __fastcall getEnumDefinitionFromString(const void **a1)
{
  const void **v1; // r6
  int v2; // r4

  v1 = a1;
  v2 = 0;
  do
  {
    if ( !sub_C0840(v1, (const void **)&VideoDefinitionString[v2]) )
      return v2;
    ++v2;
  }
  while ( v2 != 4 );
  return 5;
}

//----- (000474D8) --------------------------------------------------------
signed int __fastcall searchSuitableDefinition(signed int result)
{
  signed int i; // r3

  for ( i = result; i >= 0; --i )
  {
    if ( currentVideoDefinitionInfo[i + 4] == 1 )
      return i;
  }
  while ( ++result <= 3 )
  {
    if ( currentVideoDefinitionInfo[result + 4] == 1 )
      return result;
  }
  return 5;
}
// F4160: using guessed type int currentVideoDefinitionInfo[];

//----- (00047518) --------------------------------------------------------
_DWORD *__fastcall resetVideoDefinitionInfo(_DWORD *result)
{
  result[2] = 5;
  *result = 0;
  result[1] = 5;
  result[3] = 5;
  result[4] = 0;
  result[8] = 5;
  result[5] = 0;
  result[9] = 5;
  result[6] = 0;
  result[10] = 5;
  result[7] = 0;
  result[11] = 5;
  return result;
}

//----- (00047536) --------------------------------------------------------
_DWORD *__fastcall std::_Destroy_aux<false>::__destroy<Json::Reader::ErrorInfo *>(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r0

  v2 = result;
  v3 = a2;
  while ( v2 != v3 )
  {
    v4 = v2 + 3;
    v2 += 5;
    result = sub_C0AD8(v4);
  }
  return result;
}

//----- (00047550) --------------------------------------------------------
int __fastcall checkMultiDefinitionState(char *a1)
{
  char *v1; // r11
  int v2; // r11
  int v3; // r5
  int *v4; // r0
  int v5; // r2
  int *v6; // r0
  int v7; // r2
  int *v8; // r0
  int *v9; // r0
  int v10; // r1
  int v11; // r2
  double v12; // d8
  int *v13; // r5
  int *v14; // r0
  int *v15; // r0
  int v16; // r1
  int v17; // r2
  signed int v18; // r3
  int *v19; // r0
  int v20; // r2
  signed int v21; // ST04_4
  signed int v22; // r0
  signed int v23; // r0
  signed int v25; // [sp+8h] [bp-118h]
  _DWORD *v26; // [sp+1Ch] [bp-104h]
  void *v27; // [sp+20h] [bp-100h]
  void *v28; // [sp+24h] [bp-FCh]
  void *v29; // [sp+28h] [bp-F8h]
  char v30; // [sp+2Ch] [bp-F4h]
  char v31; // [sp+30h] [bp-F0h]
  const void *v32; // [sp+34h] [bp-ECh]
  char v33; // [sp+38h] [bp-E8h]
  const void *v34; // [sp+3Ch] [bp-E4h]
  char v35; // [sp+40h] [bp-E0h]
  char v36; // [sp+50h] [bp-D0h]
  char v37; // [sp+60h] [bp-C0h]
  char v38; // [sp+70h] [bp-B0h]

  v1 = a1;
  Json::Reader::Reader((Json::Reader *)&v38);
  Json::Value::Value((int)&v35, 0);
  Json::Value::Value((int)&v36, 0);
  v26 = &unk_2FEF48;
  v27 = &unk_2FEF48;
  Json::Value::Value((int)&v37, 0);
  v28 = &unk_2FEF48;
  resetVideoDefinitionInfo(currentVideoDefinitionInfo);
  sub_C1C58(&v29, v1);
  v2 = Json::Reader::parse((const char **)&v38, (int)&v29, (Json::Value *)&v35, 1);
  sub_C0AD8(&v29);
  if ( v2
    && (v4 = Json::Value::operator[]((Json::Value *)&v35, "usetopo"),
        Json::Value::asString((Json::Value *)&v30, (int)v4, v5),
        sub_C1778(&v26, &v30),
        sub_C0AD8(&v30),
        *(v26 - 3)) )
  {
    if ( sub_C08E8((const void **)&v26, "true") )
      goto LABEL_23;
    v6 = Json::Value::operator[]((Json::Value *)&v35, "DefaultDefinition");
    Json::Value::asString((Json::Value *)&v31, (int)v6, v7);
    sub_C1778(&v26, &v31);
    sub_C0AD8(&v31);
    if ( !*(v26 - 3) )
      goto LABEL_23;
    sub_C16AC(&v32, (int *)&v26);
    dword_F4168 = getEnumDefinitionFromString(&v32);
    sub_C0AD8(&v32);
    if ( dword_F4168 == 5 )
      goto LABEL_23;
    v8 = Json::Value::operator[]((Json::Value *)&v35, "output");
    Json::Value::operator=((int)&v36, (const Json::Value *)v8);
    if ( Json::Value::isNull((Json::Value *)&v36) )
      goto LABEL_23;
    v9 = Json::Value::operator[]((Json::Value *)&v35, "serverTime");
    v12 = COERCE_DOUBLE(Json::Value::asDouble((Json::Value *)v9, v10, v11));
    v13 = currentVideoDefinitionInfo;
    v25 = 0;
    do
    {
      v14 = Json::Value::operator[]((Json::Value *)&v36, &VideoDefinitionString[v25]);
      Json::Value::operator=((int)&v37, (const Json::Value *)v14);
      if ( Json::Value::isNull((Json::Value *)&v37)
        || (v15 = Json::Value::operator[]((Json::Value *)&v37, "lastSplitTime"),
            v12 / 1000.0 - COERCE_DOUBLE(Json::Value::asDouble((Json::Value *)v15, v16, v17)) > 60.0) )
      {
        v13[4] = 0;
        v18 = 5;
      }
      else
      {
        v13[4] = 1;
        v19 = Json::Value::operator[]((Json::Value *)&v37, "path");
        Json::Value::asString((Json::Value *)&v33, (int)v19, v20);
        sub_C1778(&v28, &v33);
        sub_C0AD8(&v33);
        sub_C16AC(&v34, (int *)&v28);
        v21 = getEnumDefinitionFromString(&v34);
        sub_C0AD8(&v34);
        v18 = v21;
        if ( v21 == 5 )
          v18 = v25;
      }
      v13[8] = v18;
      ++v13;
      ++v25;
    }
    while ( v25 != 4 );
    v22 = dword_F416C;
    if ( dword_F416C >= dword_F4168 )
      v22 = dword_F4168;
    v23 = searchSuitableDefinition(v22);
    if ( v23 == 5 )
    {
LABEL_23:
      v3 = 1;
    }
    else
    {
      v3 = 2;
      dword_F4164 = v23;
    }
  }
  else
  {
    v3 = 0;
  }
  currentVideoDefinitionInfo[0] = v3;
  sub_C0AD8(&v28);
  Json::Value::~Value((Json::Value *)&v37);
  sub_C0AD8(&v27);
  sub_C0AD8(&v26);
  Json::Value::~Value((Json::Value *)&v36);
  Json::Value::~Value((Json::Value *)&v35);
  Json::Reader::~Reader((Json::Reader *)&v38);
  return v3;
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);
// F4160: using guessed type int currentVideoDefinitionInfo[];
// F4164: using guessed type int dword_F4164;
// F4168: using guessed type int dword_F4168;
// F416C: using guessed type int dword_F416C;

//----- (00047830) --------------------------------------------------------
int __fastcall FifoDataManager::decryptChunk(FifoDataManager *this, unsigned __int8 *a2, int a3, int *a4)
{
  int v4; // r5
  unsigned __int8 v5; // r7
  unsigned __int8 v6; // r12
  int v7; // r0
  unsigned __int8 *v8; // r6
  int v9; // r4
  int v10; // r2
  bool v11; // nf
  unsigned __int8 v12; // r1
  int result; // r0

  v4 = a2[2];
  v5 = *a2;
  v6 = a2[1];
  v7 = -4 - v4 - a2[3] + a3;
  v8 = &a2[v4];
  v9 = 0;
  while ( v9 < v7 )
  {
    v10 = (int)&v8[v9];
    v11 = v9++ << 31 < 0;
    if ( v11 )
      v12 = v6;
    else
      v12 = v5;
    *(_BYTE *)(v10 + 4) ^= v12;
  }
  result = v7 - 4;
  *a4 = v4 + 8;
  return result;
}

//----- (00047874) --------------------------------------------------------
LinkManager *__fastcall FifoDataManager::decryptChunk(FifoDataManager *a1, LinkManager *a2, int a3)
{
  FifoDataManager *v3; // r6
  LinkManager *v4; // r4
  LinkManager *v5; // r5
  LinkManager *v6; // r0
  unsigned __int8 *v7; // r3
  int v8; // r7
  int v9; // r1
  int v10; // r0
  int v11; // r3
  int v12; // r2
  int v13; // r1
  int v14; // r0
  int v16; // [sp+4h] [bp-1Ch]
  int v17; // [sp+8h] [bp-18h]

  v16 = (int)a2;
  v17 = a3;
  v3 = a1;
  v4 = a2;
  if ( !a2 )
    return 0;
  v5 = (LinkManager *)*((_DWORD *)a2 + 3);
  if ( v5 )
  {
    v6 = LinkManager::deepCopyElement(a2);
    v7 = (unsigned __int8 *)*((_DWORD *)v4 + 3);
    v8 = v7[1];
    v9 = v7[2];
    v5 = v6;
    v10 = *v7;
    v11 = v7[3];
    v16 = 0;
    v12 = *((_DWORD *)v5 + 2) - 4;
    *((_DWORD *)v5 + 2) = v12;
    if ( v12 > 12 )
    {
      v13 = v11 | (v8 << 16) | (v10 << 24) | (v9 << 8);
      if ( (v13 + 1 < 0) ^ __OFADD__(v13, 1) )
      {
        v14 = FifoDataManager::decryptChunk(v3, (unsigned __int8 *)(*((_DWORD *)v4 + 3) + 4), v12, &v16);
        *((_DWORD *)v5 + 2) = v14 & ~(v14 >> 31);
      }
      memcpy(*((void **)v5 + 3), (const void *)(v16 + 4 + *((_DWORD *)v4 + 3)), *((_DWORD *)v5 + 2));
    }
    *((_DWORD *)v5 + 1) = 0;
  }
  return v5;
}

//----- (000478E6) --------------------------------------------------------
int __fastcall FifoDataManager::rewriteData(int result, unsigned __int8 *a2, int a3)
{
  int v3; // r12
  unsigned __int8 *v4; // r5
  int v5; // r1
  unsigned __int8 *v6; // r4
  unsigned __int8 v7; // r9
  int v8; // r3
  int v9; // r10
  __int64 v10; // r6
  int v11; // r9
  unsigned __int64 v12; // r2
  signed __int64 v13; // r2
  __int64 v14; // r2
  __int64 v15; // r6
  int v16; // [sp+4h] [bp-2Ch]

  v3 = a3 - 13;
  v4 = a2;
  v5 = 0;
  while ( v5 < v3 )
  {
    v6 = &v4[v5];
    v7 = v4[v5];
    v16 = (v4[v5 + 2] << 8) | (v4[v5 + 1] << 16) | v4[v5 + 3];
    v8 = *(_DWORD *)(result + 72);
    v9 = (v4[v5 + 4] << 16) | (v4[v5 + 7] << 24) | v4[v5 + 6] | (v4[v5 + 5] << 8);
    if ( !*(_QWORD *)(result + 48) )
      *(_QWORD *)(result + 48) = (v4[v5 + 4] << 16) | (v4[v5 + 7] << 24) | v4[v5 + 6] | (v4[v5 + 5] << 8);
    v10 = *(_QWORD *)(result + 64);
    if ( v8 < 0 )
    {
      v11 = v7 & 0x1F;
      if ( v11 == 18 || v11 == 9 && (v6[11] & 0xF0) == 16 )
      {
        *(_DWORD *)(result + 72) = v5;
        *(_QWORD *)(result + 48) = v10;
      }
    }
    v12 = v9 - *(_QWORD *)(result + 56);
    if ( v12 <= 0x3E7 )
      v13 = v12 + v10;
    else
      v13 = v10 + 10;
    *(_QWORD *)(result + 64) = v13;
    v14 = *(_QWORD *)(result + 48);
    v15 = *(_QWORD *)(result + 64);
    *(_QWORD *)(result + 56) = v9;
    v6[7] = (unsigned int)(v15 - v14) >> 24;
    v5 += 15 + v16;
    v6[4] = ((unsigned int)*(_QWORD *)(result + 64) - (unsigned int)*(_QWORD *)(result + 48)) >> 16;
    v6[5] = (unsigned __int16)(*(_WORD *)(result + 64) - *(_WORD *)(result + 48)) >> 8;
    v6[6] = *(_BYTE *)(result + 64) - *(_BYTE *)(result + 48);
  }
  return result;
}

//----- (000479EE) --------------------------------------------------------
int __fastcall FifoDataManager::writeBytesToFd(int result, int a2, unsigned __int8 *a3, int a4)
{
  int v4; // r6
  int v5; // r7
  unsigned __int8 *v6; // r8
  int v7; // r5
  int v8; // r4
  size_t v9; // r2
  ssize_t v10; // r0

  v4 = result;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = 0;
  while ( !*(_BYTE *)(v4 + 8) && v8 < v7 )
  {
    v9 = v7 - v8;
    if ( v7 - v8 >= 4096 )
      v9 = 4096;
    v10 = write(v5, &v6[v8], v9);
    if ( v10 > 0 )
      v8 += v10;
    result = usleep(0x1388u);
  }
  return result;
}

//----- (00047A30) --------------------------------------------------------
int __fastcall FifoDataManager::writeVideoData(FifoDataManager *this, void *a2)
{
  FifoDataManager *v2; // r4
  int v3; // r5
  int v4; // r6
  char *v5; // r5
  int v6; // r0
  const char *v7; // r3
  int v8; // r0
  int v9; // r1
  _DWORD *v10; // r7
  int v11; // r0
  LinkManager *v12; // r0
  int result; // r0
  int v14; // r2
  int v15; // r2
  void *ptr; // [sp+4h] [bp-C4h]
  LinkManager *v17; // [sp+8h] [bp-C0h]
  int v18; // [sp+Ch] [bp-BCh]
  size_t n; // [sp+14h] [bp-B4h]
  void *src; // [sp+18h] [bp-B0h]
  char v21; // [sp+20h] [bp-A8h]
  int v22; // [sp+30h] [bp-98h]
  char v23; // [sp+88h] [bp-40h]
  int v24; // [sp+9Ch] [bp-2Ch]

  v2 = this;
  v3 = *((_DWORD *)this + 3);
  fstat(*((_DWORD *)this + 3), (struct stat *)&v21);
  if ( (v22 & 0xF000) == 49152 )
  {
    v4 = v3;
LABEL_3:
    if ( !*((_BYTE *)v2 + 8) )
    {
      v4 = accept(v3, (struct sockaddr *)*((unsigned __int8 *)v2 + 8), 0);
      if ( v4 < 0 )
        goto LABEL_28;
    }
    v5 = &v23;
    v6 = fcntl(v4, 3, 0);
    fcntl(v4, 4, v6 | 0x800);
    v7 = "HTTP/1.1 200 OK\r\n\r\n";
    do
    {
      v8 = *(_DWORD *)v7;
      v7 += 8;
      v9 = *((_DWORD *)v7 - 1);
      *(_DWORD *)v5 = v8;
      *((_DWORD *)v5 + 1) = v9;
      v10 = v5 + 8;
      v5 += 8;
    }
    while ( v7 != "\n\r\n" );
    v3 = v4;
    *v10 = *(_DWORD *)v7;
    v11 = strlen(&v23);
    FifoDataManager::writeBytesToFd((int)v2, v4, (unsigned __int8 *)&v23, v11);
  }
  if ( *((_DWORD *)v2 + 6) == 1 )
    FifoDataManager::writeBytesToFd((int)v2, v3, (unsigned __int8 *)v2 + 28, 13);
  v4 = 0x80000;
  ptr = calloc(0x80000u, 1u);
  *((_QWORD *)v2 + 10) = getTime();
  memset(&v18, 0, 0x14u);
  while ( !*((_BYTE *)v2 + 8) )
  {
    v17 = 0;
    if ( !(*((int (__fastcall **)(_DWORD, int *))v2 + 1))(*((_DWORD *)v2 + 5), &v18)
      || !src
      || v18 != *((_DWORD *)v2 + 5) )
    {
      goto LABEL_17;
    }
    if ( (signed int)n <= 0 )
    {
      if ( n )
        goto LABEL_17;
LABEL_29:
      if ( *((_DWORD *)v2 + 6) != 2 )
        goto LABEL_17;
      goto LABEL_23;
    }
    if ( *((_DWORD *)v2 + 6) != 1 )
      goto LABEL_29;
LABEL_23:
    if ( v4 < (signed int)n )
    {
      free(ptr);
      v4 = n;
      ptr = cumalloc(n);
      if ( !ptr )
        break;
    }
    memcpy(ptr, src, n);
    src = ptr;
    if ( *((_DWORD *)v2 + 6) == 1 )
    {
      v17 = FifoDataManager::decryptChunk(v2, (LinkManager *)&v18, v14);
      FifoDataManager::rewriteData((int)v2, *((unsigned __int8 **)v17 + 3), *((_DWORD *)v17 + 2));
      if ( *(_DWORD *)v17 == *(_DWORD *)v2 )
      {
        v15 = *((_DWORD *)v2 + 18);
        if ( v15 > 0 )
          *((_DWORD *)v17 + 1) = v15;
      }
    }
LABEL_17:
    if ( v17 )
    {
      FifoDataManager::writeBytesToFd(
        (int)v2,
        v3,
        (unsigned __int8 *)(*((_DWORD *)v17 + 3) + *((_DWORD *)v17 + 1)),
        *((_DWORD *)v17 + 2) - *((_DWORD *)v17 + 1));
      v12 = v17;
      ++*((_DWORD *)v2 + 5);
      ffFree((void **)v12 + 3);
      ffFree((void **)&v17);
    }
    else
    {
      if ( currentState == 3 )
        *((double *)v2 + 10) = *((double *)v2 + 10) + 0.01;
      usleep(0x2710u);
    }
  }
  ffFree(&ptr);
  if ( (v22 & 0xF000) == 49152 )
    close(v3);
  result = 0;
  if ( v24 != _stack_chk_guard )
  {
LABEL_28:
    usleep(0x2710u);
    goto LABEL_3;
  }
  return result;
}
// F3DAC: using guessed type int currentState;

//----- (00047C38) --------------------------------------------------------
int __fastcall FifoDataManager::start(void *arg, int a2, int a3, int a4, int a5)
{
  pthread_t *v5; // r4
  signed int v6; // r5
  int result; // r0

  v5 = (pthread_t *)arg;
  *(_DWORD *)arg = a4;
  *((_DWORD *)arg + 5) = a4;
  *((_DWORD *)arg + 6) = a5;
  if ( a2 <= 0 )
    return -100;
  *((_DWORD *)arg + 3) = a2;
  if ( !a3 )
    return -99;
  v6 = 0;
  *((_DWORD *)arg + 1) = a3;
  *((_BYTE *)arg + 8) = 0;
  while ( 1 )
  {
    result = pthread_create(v5 + 4, 0, (void *(*)(void *))FifoDataManager::writeVideoData, v5);
    if ( !result )
      break;
    if ( ++v6 == 4 )
      return -94;
  }
  if ( v6 <= 2 )
    return result;
  return -94;
}

//----- (00047C8C) --------------------------------------------------------
_DWORD *__fastcall FifoDataManager::setHeaderBytes(FifoDataManager *this, char *a2)
{
  _DWORD *result; // r0
  char *v3; // r3
  int v4; // t1

  result = (_DWORD *)((char *)this + 28);
  v3 = a2 + 12;
  do
  {
    v4 = *(_DWORD *)a2;
    a2 += 4;
    *result = v4;
    ++result;
  }
  while ( a2 != v3 );
  *(_BYTE *)result = *a2;
  return result;
}

//----- (00047CA8) --------------------------------------------------------
double __fastcall FifoDataManager::getWriteDataTime(FifoDataManager *this)
{
  FifoDataManager *v1; // r4
  double v2; // d8
  double v3; // d6
  double result; // r0

  v1 = this;
  v2 = (double)*(signed int *)this;
  v3 = v2 + COERCE_DOUBLE(getTime()) - *((double *)this + 10);
  if ( (double)*((signed int *)v1 + 5) + 0.0 >= v3 )
    result = v3;
  else
    result = (double)*((signed int *)v1 + 5) + 0.0;
  return result;
}

//----- (00047D00) --------------------------------------------------------
int __fastcall FifoDataManager::stopWriteThread(int result)
{
  *(_BYTE *)(result + 8) = 1;
  return result;
}

//----- (00047D06) --------------------------------------------------------
int __fastcall FifoDataManager::FifoDataManager(int result)
{
  *(_QWORD *)(result + 48) = 0LL;
  *(_BYTE *)(result + 8) = 0;
  *(_QWORD *)(result + 56) = 0LL;
  *(_QWORD *)(result + 64) = 0LL;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)result = 0;
  *(_QWORD *)(result + 80) = 0LL;
  *(_DWORD *)(result + 72) = -1;
  return result;
}

//----- (00047D30) --------------------------------------------------------
FifoDataManager *__fastcall FifoDataManager::~FifoDataManager(FifoDataManager *this)
{
  FifoDataManager *v1; // r4

  v1 = this;
  *((_BYTE *)this + 8) = 1;
  pthread_join(*((_DWORD *)this + 4), 0);
  close(*((_DWORD *)v1 + 3));
  return v1;
}

//----- (00047D4A) --------------------------------------------------------
int __fastcall FifoM3u8DataManager::writeBytesToChannel(int result, int a2, unsigned __int8 *a3, int a4)
{
  int v4; // r5
  int v5; // r7
  unsigned __int8 *v6; // r8
  int v7; // r6
  int v8; // r4

  v4 = result;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = 0;
  while ( !*(_BYTE *)(v4 + 4) && v8 < v7 )
  {
    result = write(v5, &v6[v8], v7 - v8);
    if ( result <= 0 )
    {
      if ( !*(_BYTE *)(v4 + 4) )
        result = usleep(0x2710u);
    }
    else
    {
      v8 += result;
    }
  }
  return result;
}

//----- (00047D88) --------------------------------------------------------
int __fastcall FifoM3u8DataManager::writeFifoThreadProcess(FifoM3u8DataManager *this, void *a2)
{
  FifoM3u8DataManager *v2; // r5
  void *v3; // r6
  unsigned __int8 *v4; // r0
  int v5; // r4
  int v6; // r7
  int result; // r0
  char *v8; // r4
  int v9; // r0
  const char *v10; // r3
  int v11; // r0
  int v12; // r1
  _DWORD *v13; // r7
  int v14; // r0
  unsigned __int8 *v15; // [sp+4h] [bp-A4h]
  char v16; // [sp+8h] [bp-A0h]
  int v17; // [sp+18h] [bp-90h]
  char v18; // [sp+70h] [bp-38h]
  int v19; // [sp+84h] [bp-24h]

  v2 = this;
  v3 = &_stack_chk_guard;
  v4 = (unsigned __int8 *)cumalloc(0x4000u);
  v5 = *((_DWORD *)v2 + 2);
  v15 = v4;
  fstat(v5, (struct stat *)&v16);
  if ( (v17 & 0xF000) != 49152 )
    goto LABEL_8;
  v3 = (void *)v5;
  while ( !*((_BYTE *)v2 + 4) )
  {
    v3 = (void *)accept(v5, (struct sockaddr *)*((unsigned __int8 *)v2 + 4), 0);
    if ( (signed int)v3 >= 0 )
      break;
    usleep(0x2710u);
  }
  do
  {
    v8 = &v18;
    v9 = fcntl((int)v3, 3, 0);
    fcntl((int)v3, 4, v9 | 0x800);
    v10 = "HTTP/1.1 200 OK\r\n\r\n";
    do
    {
      v11 = *(_DWORD *)v10;
      v10 += 8;
      v12 = *((_DWORD *)v10 - 1);
      *(_DWORD *)v8 = v11;
      *((_DWORD *)v8 + 1) = v12;
      v13 = v8 + 8;
      v8 += 8;
    }
    while ( v10 != "\n\r\n" );
    v5 = (int)v3;
    *v13 = *(_DWORD *)v10;
    v14 = strlen(&v18);
    FifoM3u8DataManager::writeBytesToChannel((int)v2, (int)v3, (unsigned __int8 *)&v18, v14);
LABEL_8:
    while ( !*((_BYTE *)v2 + 4) )
    {
      v6 = (*(int (__fastcall **)(unsigned __int8 *, signed int))v2)(v15, 0x4000);
      if ( v6 <= 0 )
      {
        usleep(0x2710u);
      }
      else
      {
        FifoM3u8DataManager::writeBytesToChannel((int)v2, v5, v15, v6);
        consumeXBytes(v6);
        addXWriteFifoBytes(v6);
      }
    }
    ffFree((void **)&v15);
    close(v5);
    result = 0;
  }
  while ( v19 != _stack_chk_guard );
  return result;
}

//----- (00047E90) --------------------------------------------------------
int __fastcall FifoM3u8DataManager::writeFifoThread(FifoM3u8DataManager *this, int a2, int (__cdecl *a3)(unsigned __int8 *, int))
{
  FifoM3u8DataManager *v3; // r5
  signed int v4; // r4
  pthread_t *v5; // r6
  int result; // r0

  v3 = this;
  if ( a2 <= 0 )
    return -100;
  *((_DWORD *)this + 2) = a2;
  if ( !a3 )
    return -99;
  v4 = 0;
  *(_DWORD *)this = a3;
  v5 = (pthread_t *)((char *)this + 12);
  while ( 1 )
  {
    result = pthread_create(v5, 0, (void *(*)(void *))FifoM3u8DataManager::writeFifoThreadProcess, (void *)v3);
    if ( !result )
      break;
    if ( ++v4 == 4 )
      return -94;
  }
  if ( v4 <= 2 )
    return result;
  return -94;
}

//----- (00047EDC) --------------------------------------------------------
int __fastcall FifoM3u8DataManager::stopWriteThread(int result)
{
  *(_BYTE *)(result + 4) = 1;
  return result;
}

//----- (00047EE2) --------------------------------------------------------
int __fastcall FifoM3u8DataManager::FifoM3u8DataManager(int result)
{
  *(_BYTE *)(result + 4) = 0;
  return result;
}

//----- (00047EE8) --------------------------------------------------------
FifoM3u8DataManager *__fastcall FifoM3u8DataManager::~FifoM3u8DataManager(FifoM3u8DataManager *this)
{
  FifoM3u8DataManager *v1; // r4

  v1 = this;
  FifoM3u8DataManager::stopWriteThread((int)this);
  pthread_join(*((_DWORD *)v1 + 3), 0);
  close(*((_DWORD *)v1 + 2));
  return v1;
}

//----- (00047F02) --------------------------------------------------------
void *__fastcall RegularInfo::resetRegularStatistic(RegularInfo *this)
{
  RegularInfo *v1; // r6
  __int64 v2; // r0
  void *result; // r0

  *((_DWORD *)this + 36) = 0;
  v1 = this;
  *(_QWORD *)this = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 3) = 0LL;
  *((_QWORD *)this + 6) = 0LL;
  *((_QWORD *)this + 7) = 0LL;
  *((_QWORD *)this + 8) = 0LL;
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  *((_QWORD *)this + 12) = 0LL;
  *((_QWORD *)this + 13) = 0LL;
  *((_QWORD *)this + 14) = 0LL;
  *((_QWORD *)this + 15) = 0LL;
  *((_QWORD *)this + 16) = 0LL;
  *((_QWORD *)this + 17) = 0LL;
  v2 = getTime();
  *((_QWORD *)v1 + 5) = 0LL;
  *((_DWORD *)v1 + 46) = 0;
  *((_DWORD *)v1 + 47) = 0;
  *((_QWORD *)v1 + 19) = 0LL;
  *((_QWORD *)v1 + 21) = 0LL;
  *((_QWORD *)v1 + 20) = 0LL;
  *((_QWORD *)v1 + 22) = 0LL;
  *((_DWORD *)v1 + 53) = 0;
  *((_DWORD *)v1 + 54) = 0;
  *((_DWORD *)v1 + 55) = 0;
  *((_DWORD *)v1 + 56) = 0;
  *((_DWORD *)v1 + 57) = 0;
  *((_QWORD *)v1 + 4) = v2;
  result = memset((char *)v1 + 192, 0, 0x14u);
  *((_DWORD *)v1 + 58) = 0;
  *((_DWORD *)v1 + 59) = 0;
  *((_DWORD *)v1 + 60) = 0;
  *((_DWORD *)v1 + 61) = 0;
  *((_DWORD *)v1 + 62) = 0;
  *((_DWORD *)v1 + 63) = 0;
  *((_DWORD *)v1 + 64) = 0;
  *((_DWORD *)v1 + 65) = 0;
  *((_DWORD *)v1 + 66) = 0;
  *((_DWORD *)v1 + 67) = 0;
  *((_DWORD *)v1 + 68) = 0;
  *((_DWORD *)v1 + 69) = 0;
  *((_DWORD *)v1 + 70) = 0;
  *((_DWORD *)v1 + 76) = 0;
  *((_DWORD *)v1 + 77) = 0;
  *((_DWORD *)v1 + 78) = 0;
  *((_DWORD *)v1 + 79) = 0;
  *((_DWORD *)v1 + 80) = 0;
  *((_DWORD *)v1 + 71) = 0;
  *((_DWORD *)v1 + 72) = 0;
  *((_DWORD *)v1 + 73) = 0;
  *((_DWORD *)v1 + 74) = 0;
  *((_DWORD *)v1 + 75) = 0;
  *((_DWORD *)v1 + 81) = 0;
  *((_DWORD *)v1 + 82) = 0;
  *((_DWORD *)v1 + 83) = 0;
  *((_DWORD *)v1 + 84) = 0;
  *((_DWORD *)v1 + 85) = 0;
  *((_DWORD *)v1 + 86) = 0;
  *((_DWORD *)v1 + 87) = 0;
  *((_DWORD *)v1 + 88) = 0;
  *((_DWORD *)v1 + 89) = 0;
  *((_DWORD *)v1 + 90) = 0;
  *((_DWORD *)v1 + 91) = 0;
  *((_DWORD *)v1 + 92) = 0;
  *((_DWORD *)v1 + 93) = 0;
  *((_DWORD *)v1 + 94) = 0;
  *((_DWORD *)v1 + 95) = 0;
  *((_DWORD *)v1 + 96) = 0;
  *((_DWORD *)v1 + 97) = 0;
  *((_DWORD *)v1 + 98) = 0;
  *((_DWORD *)v1 + 99) = 0;
  *((_DWORD *)v1 + 100) = 0;
  *((_DWORD *)v1 + 101) = 0;
  *((_DWORD *)v1 + 102) = 0;
  *((_DWORD *)v1 + 103) = 0;
  *((_DWORD *)v1 + 104) = 0;
  *((_DWORD *)v1 + 105) = 0;
  *((_DWORD *)v1 + 106) = 0;
  *((_DWORD *)v1 + 107) = 0;
  *((_DWORD *)v1 + 108) = 0;
  *((_DWORD *)v1 + 109) = 0;
  *((_DWORD *)v1 + 110) = 0;
  *((_DWORD *)v1 + 111) = 0;
  *((_DWORD *)v1 + 112) = 0;
  *((_DWORD *)v1 + 113) = 0;
  *((_DWORD *)v1 + 114) = 0;
  *((_DWORD *)v1 + 115) = 0;
  *((_DWORD *)v1 + 116) = 0;
  *((_DWORD *)v1 + 117) = 0;
  *((_DWORD *)v1 + 118) = 0;
  *((_DWORD *)v1 + 119) = 0;
  *((_DWORD *)v1 + 120) = 0;
  *((_DWORD *)v1 + 121) = 0;
  *((_DWORD *)v1 + 122) = 0;
  *((_DWORD *)v1 + 123) = 0;
  *((_DWORD *)v1 + 124) = 0;
  *((_DWORD *)v1 + 125) = 0;
  *((_DWORD *)v1 + 126) = 0;
  *((_DWORD *)v1 + 127) = 0;
  *((_DWORD *)v1 + 128) = 0;
  *((_DWORD *)v1 + 129) = 0;
  *((_DWORD *)v1 + 130) = 0;
  *((_DWORD *)v1 + 131) = 0;
  *((_DWORD *)v1 + 132) = 0;
  *((_DWORD *)v1 + 133) = 0;
  *((_DWORD *)v1 + 134) = 0;
  *((_DWORD *)v1 + 135) = 0;
  *((_DWORD *)v1 + 136) = 0;
  *((_DWORD *)v1 + 137) = 0;
  *((_DWORD *)v1 + 138) = 0;
  *((_DWORD *)v1 + 139) = 0;
  *((_DWORD *)v1 + 140) = 0;
  *((_DWORD *)v1 + 141) = 0;
  *((_DWORD *)v1 + 142) = 0;
  *((_DWORD *)v1 + 143) = 0;
  *((_DWORD *)v1 + 144) = 0;
  *((_DWORD *)v1 + 145) = 0;
  *((_DWORD *)v1 + 146) = 0;
  *((_DWORD *)v1 + 147) = 0;
  *((_DWORD *)v1 + 148) = 0;
  *((_QWORD *)v1 + 75) = 0LL;
  *((_QWORD *)v1 + 76) = 0LL;
  *((_QWORD *)v1 + 77) = 0LL;
  *((_QWORD *)v1 + 78) = 0LL;
  *((_QWORD *)v1 + 79) = 0LL;
  *((_QWORD *)v1 + 80) = 0LL;
  *((_QWORD *)v1 + 81) = 0LL;
  *((_QWORD *)v1 + 82) = 0LL;
  *((_QWORD *)v1 + 83) = 0LL;
  *((_QWORD *)v1 + 84) = 0LL;
  *((_QWORD *)v1 + 85) = 0LL;
  *((_QWORD *)v1 + 87) = 0LL;
  *((_QWORD *)v1 + 88) = 0LL;
  *((_QWORD *)v1 + 89) = 0LL;
  *((_QWORD *)v1 + 90) = 0LL;
  *((_DWORD *)v1 + 182) = 0;
  *((_DWORD *)v1 + 183) = 0;
  return result;
}

//----- (00048146) --------------------------------------------------------
RegularInfo *__fastcall RegularInfo::~RegularInfo(RegularInfo *this)
{
  RegularInfo *v1; // r4

  v1 = this;
  RegularInfo::resetRegularStatistic(this);
  return v1;
}

//----- (00048152) --------------------------------------------------------
unsigned int __fastcall isNeedDecrypt(char *a1)
{
  return (unsigned int)(unsigned __int8)*a1 >> 7;
}

//----- (00048158) --------------------------------------------------------
int __fastcall decryptChunk(char *a1, int a2, int *a3)
{
  int v3; // r4
  char v4; // r7
  char v5; // r12
  char *v6; // r6
  int v7; // r1
  int v8; // r3
  int v9; // r0
  bool v10; // nf
  char v11; // r5
  int result; // r0

  v3 = (unsigned __int8)a1[2];
  v4 = a1[1];
  v5 = *a1;
  v6 = &a1[v3];
  v7 = a2 + -4 - v3 - (unsigned __int8)a1[3];
  v8 = 0;
  while ( v8 < v7 )
  {
    v9 = (int)&v6[v8];
    v10 = v8++ << 31 < 0;
    if ( v10 )
      v11 = v4;
    else
      v11 = v5;
    *(_BYTE *)(v9 + 4) ^= v11;
  }
  result = v7 - 4;
  *a3 = v3 + 8;
  return result;
}

//----- (0004819C) --------------------------------------------------------
int __fastcall setClientId(int result)
{
  const char *v1; // r5
  size_t v2; // r0

  v1 = (const char *)result;
  if ( result )
  {
    v2 = strlen((const char *)result);
    strncpy(clientId, v1, v2);
    result = strlen(v1);
    clientId[result] = 0;
  }
  return result;
}

//----- (000481C8) --------------------------------------------------------
size_t __fastcall setPlatform(char *a1)
{
  char *v1; // r4
  size_t v2; // r0
  size_t result; // r0

  v1 = a1;
  v2 = strlen(a1);
  strncpy(platform, v1, v2);
  result = strlen(v1);
  clientId[result] = 0;
  return result;
}

//----- (000481F8) --------------------------------------------------------
char *__fastcall playerSetDebug(int a1)
{
  char *result; // r0

  if ( a1 )
    result = (char *)j_sprintf(debugInfo, "%s%s");
  else
    result = j_strcpy(debugInfo, defaultCookie);
  return result;
}

//----- (0004822C) --------------------------------------------------------
int __fastcall setClientInfo(int result, char *a2, char *a3)
{
  char *v3; // r5
  char *v4; // r4

  v3 = a2;
  v4 = a3;
  if ( result && *(_BYTE *)result )
    result = (int)strcpy(platform, (const char *)result);
  if ( v3 && *v3 )
    result = (int)strcpy(clientId, v3);
  if ( v4 )
  {
    if ( *v4 )
      result = (int)j_strcpy((char *)&sysinfo, v4);
  }
  return result;
}

//----- (0004827C) --------------------------------------------------------
char *__fastcall setClientInfo(char *a1, char *a2, char *a3, char *a4, char *a5)
{
  char *v5; // r5
  char *v6; // r4
  char *result; // r0

  v5 = a4;
  v6 = a5;
  result = (char *)setClientInfo((int)a1, a2, a3);
  if ( v5 && *v5 )
    result = strcpy(device, v5);
  if ( v6 )
  {
    if ( *v6 )
    {
      strcpy(reportPartnerId, v6);
      result = (char *)j_sprintf(subReportPartnerId, "sub%s");
    }
  }
  return result;
}

//----- (000482D8) --------------------------------------------------------
int __fastcall setWifiState(int result)
{
  wifiState = result == 0;
  return result;
}
// F3944: using guessed type int wifiState;

//----- (000482F0) --------------------------------------------------------
char *getVersion(void)
{
  return version;
}

//----- (000482FC) --------------------------------------------------------
__int64 getPlaytime(void)
{
  return 0LL;
}

//----- (00048304) --------------------------------------------------------
int initStatistic(void)
{
  int result; // r0

  if ( !isInitialized )
  {
    result = initAppStatistic();
    isInitialized = 1;
  }
  return result;
}
// F572C: using guessed type char isInitialized;

//----- (00048320) --------------------------------------------------------
void clientPlayerVout(void)
{
  continueSwitchCount = 0;
  if ( !firstVout )
  {
    firstVout = 1;
    if ( currentPlayMode )
    {
      if ( currentPlayMode == 1 )
        add_play_vo2();
    }
    else
    {
      add_play_vo();
      switch ( currentStreamType )
      {
        case 1:
          add_flv_vo();
          break;
        case 2:
          add_ts_vo();
          break;
        case 3:
          add_direct_vo();
          break;
      }
    }
  }
}
// F30E8: using guessed type int currentPlayMode;
// F41B0: using guessed type int continueSwitchCount;
// F41C0: using guessed type char firstVout;
// F41D4: using guessed type int currentStreamType;

//----- (00048394) --------------------------------------------------------
void clientPlayerCard(void)
{
  if ( currentPlayMode )
  {
    if ( currentPlayMode == 1 )
      add_ses_play_pc2();
  }
  else
  {
    add_ses_play_pc();
    switch ( currentStreamType )
    {
      case 1:
        add_ses_flv_pc();
        break;
      case 2:
        add_ses_ts_pc();
        break;
      case 3:
        add_ses_direct_pc();
        break;
    }
  }
  if ( !firstCard )
  {
    firstCard = 1;
    if ( currentPlayMode )
    {
      if ( currentPlayMode == 1 )
        add_play_pc2();
    }
    else
    {
      add_play_pc();
      switch ( currentStreamType )
      {
        case 1:
          add_flv_pc();
          break;
        case 2:
          add_ts_pc();
          break;
        case 3:
          add_direct_pc();
          break;
      }
    }
  }
}
// F30E8: using guessed type int currentPlayMode;
// F41C1: using guessed type char firstCard;
// F41D4: using guessed type int currentStreamType;

//----- (00048434) --------------------------------------------------------
int __fastcall attachEvent(int result)
{
  player_callback = (int (__fastcall *)(_DWORD))result;
  return result;
}
// F573C: using guessed type int (__fastcall *player_callback)(_DWORD);

//----- (00048444) --------------------------------------------------------
int __fastcall sendEventToPlayer(int a1)
{
  return player_callback(a1);
}
// F573C: invalid function type has been ignored
// F573C: using guessed type int (__fastcall *player_callback)(_DWORD);

//----- (00048458) --------------------------------------------------------
void notifyPlayerToRestart(void)
{
  *(_QWORD *)&currentTime = getTime();
  isSwitchEntry = 1;
  isNeedToSwitch = 1;
  add_noVoutCh();
  if ( currentTime - lastSwitchTime > 3.0 )
  {
    if ( currentPlayMode )
    {
      if ( currentPlayMode == 1 )
        add_cpFailedSwitchRtmp();
    }
    else
    {
      add_cpFailedSwitch();
    }
    sendEventToPlayer(258);
    add_play_blk();
    if ( currentPlayMode )
    {
      if ( currentPlayMode == 1 )
        add_play_cl2();
    }
    else
    {
      add_play_cl();
    }
    ++continueSwitchCount;
    lastSwitchTime = currentTime;
  }
}
// F30E8: using guessed type int currentPlayMode;
// F41B0: using guessed type int continueSwitchCount;
// F41B4: using guessed type char isNeedToSwitch;
// F41BB: using guessed type char isSwitchEntry;

//----- (00048504) --------------------------------------------------------
void __fastcall notifyPlayerToChangeSource(int a1)
{
  int v1; // r7
  void *v2; // r4
  char *v3; // r0
  int v4; // r10
  pthread_mutex_t *v5; // r9
  int v6; // r11

  v1 = a1;
  *(_QWORD *)&currentTime = getTime();
  isSwitchEntry = 1;
  isNeedToSwitch = 1;
  add_noVoutCh();
  if ( currentTime - lastSwitchTime > 3.0 )
  {
    if ( currentSourceId )
    {
      v2 = operator new(0x20u);
      *(_DWORD *)v2 = strdup(&currentSourceId);
      v3 = strdup(currentSourceSrc);
      *((_DWORD *)v2 + 2) = 0;
      *((_DWORD *)v2 + 1) = v3;
      *((double *)v2 + 2) = currentTime;
      *((_DWORD *)v2 + 6) = 0;
      *((_DWORD *)v2 + 3) = currentStreamType;
      v4 = invalidSource;
      v5 = (pthread_mutex_t *)(invalidSource + 4);
      pthread_mutex_lock((pthread_mutex_t *)(invalidSource + 4));
      if ( *(_DWORD *)v4 )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v4 + 24);
        *((_QWORD *)v2 + 2) = getTime();
        while ( v6 )
        {
          if ( !strcmp(*(const char **)v6, *(const char **)v2) )
            goto LABEL_5;
          v6 = *(_DWORD *)(v6 + 24);
        }
        *((_DWORD *)v2 + 6) = *(_DWORD *)(*(_DWORD *)v4 + 24);
        *(_DWORD *)(*(_DWORD *)v4 + 24) = v2;
        pthread_mutex_unlock(v5);
      }
      else
      {
LABEL_5:
        pthread_mutex_unlock(v5);
        free(*(void **)v2);
        free(*((void **)v2 + 1));
        operator delete(v2);
      }
    }
    sendEventToPlayer(258);
    switch ( v1 )
    {
      case 0:
        if ( currentPlayMode )
        {
          if ( currentPlayMode == 1 )
            add_cpFailedSwitchRtmp();
        }
        else
        {
          add_cpFailedSwitch();
        }
        break;
      case 1:
        if ( currentPlayMode )
        {
          if ( currentPlayMode == 1 )
            add_timeout_switch2();
        }
        else
        {
          add_timeoutSwitch();
        }
        break;
      case 2:
        if ( currentPlayMode )
        {
          if ( currentPlayMode == 1 )
            add_cardLongSwitchRtmp();
        }
        else
        {
          add_cardLongSwitch();
        }
        break;
      case 3:
        add_m3u8FailedSwitch();
        break;
      case 4:
        add_m3u8NotUpdateSwitch();
        break;
      case 5:
        add_m3u8ExcepSwitch();
        break;
      case 6:
        add_tsFailedSwitch();
        break;
      case 7:
        add_startFailedSwitch();
        break;
      default:
        break;
    }
    add_play_blk();
    if ( currentPlayMode )
    {
      if ( currentPlayMode == 1 )
        add_play_cl2();
    }
    else
    {
      add_play_cl();
    }
    ++continueSwitchCount;
    lastSwitchTime = currentTime;
  }
}
// F30E8: using guessed type int currentPlayMode;
// F41B0: using guessed type int continueSwitchCount;
// F41B4: using guessed type char isNeedToSwitch;
// F41BB: using guessed type char isSwitchEntry;
// F41D4: using guessed type int currentStreamType;
// F41D8: using guessed type int invalidSource;
// F4988: using guessed type char currentSourceId;

//----- (000486C8) --------------------------------------------------------
signed int readBuildProp(void)
{
  FILE *v0; // r7
  char *v1; // r1
  char *v2; // r2
  const char *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r7
  int v7; // r0
  __int16 v8; // r1
  char v9; // r3
  int v11; // [sp+18h] [bp-840h]
  int v12; // [sp+1Ch] [bp-83Ch]
  char v13; // [sp+20h] [bp-838h]
  char v14[512]; // [sp+2Ch] [bp-82Ch]
  char v15; // [sp+22Ch] [bp-62Ch]
  char v16; // [sp+42Ch] [bp-42Ch]
  char v17; // [sp+463h] [bp-3F5h]

  v0 = fopen("/system/build.prop", "rb");
  memset(v14, 0, 0x200u);
  memset(&v15, 0, 0x200u);
  memset(cpuArchInfo, 0, 0x400u);
  if ( v0 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets(&v15, 512, v0) )
          {
            fclose(v0);
            goto LABEL_15;
          }
          v1 = strtok(&v15, "\n");
        }
        while ( !v1 );
        strcpy(v14, v1);
        if ( strchr(v14, 13) )
          v14[strlen(v14) - 1] = 0;
        else
          v14[strlen(v14)] = 0;
        if ( !strstr(v14, "ro.product.cpu.abi=") )
          break;
LABEL_12:
        strcat(cpuArchInfo, v14);
      }
      if ( strstr(v14, "ro.product.cpu.abi2=") || strstr(v14, "ro.product.cpu.abilist=") )
      {
        strcat(cpuArchInfo, "::");
        goto LABEL_12;
      }
    }
  }
  strcpy(cpuArchInfo, "faild read buildprop");
LABEL_15:
  v11 = 1;
  v2 = &v16;
  v3 = "http://mobile.kukuplay.com/core/a/cpuArch.php?cpuArch=";
  do
  {
    v4 = *(_DWORD *)v3;
    v3 += 8;
    v5 = *((_DWORD *)v3 - 1);
    *(_DWORD *)v2 = v4;
    *((_DWORD *)v2 + 1) = v5;
    v6 = (int)(v2 + 8);
    v2 += 8;
  }
  while ( v3 != "uArch=" );
  v7 = *(_DWORD *)v3;
  v8 = *((_WORD *)v3 + 2);
  v9 = v3[6];
  *(_DWORD *)v6 = v7;
  *(_WORD *)(v6 + 4) = v8;
  *(_BYTE *)(v6 + 6) = v9;
  memset(&v17, 0, 0x3C9u);
  strcat(&v16, cpuArchInfo);
  v12 = 10;
  return doRequest(&v11, &v16, &v13, &v12, 16.0, 0, 0, 0);
}
// 486C8: using guessed type char var_82C[512];

//----- (00048878) --------------------------------------------------------
ChannelPlayInfoManager *__fastcall ChannelPlayInfoManager::~ChannelPlayInfoManager(ChannelPlayInfoManager *this, void *a2, int a3)
{
  char *v3; // r5
  ChannelPlayInfoManager *v4; // r4
  void *v5; // r0
  int v6; // r6
  void *v7; // r3
  int i; // r5
  _DWORD *v9; // r0
  int v10; // r6
  void *v11; // r0
  void *v12; // r0
  void *v13; // r0
  void *v15; // [sp+4h] [bp-1Ch]
  int v16; // [sp+8h] [bp-18h]

  v15 = a2;
  v16 = a3;
  v3 = (char *)this + 32000;
  v4 = this;
  v5 = (void *)*((_DWORD *)this + 8028);
  if ( v5 )
    operator delete[](v5);
  if ( *((_DWORD *)v3 + 27) )
  {
    v6 = 0;
    while ( v6 < *((_DWORD *)v4 + 258) )
    {
      v7 = *(void **)(*((_DWORD *)v4 + 8027) + 4 * v6++);
      v15 = v7;
      ffFree(&v15);
    }
    ffFree((void **)v4 + 8027);
  }
  if ( *((_DWORD *)v4 + 260) > 0 )
  {
    for ( i = 0; ; ++i )
    {
      v9 = (_DWORD *)*((_DWORD *)v4 + 259);
      if ( i >= *((_DWORD *)v4 + 260) )
        break;
      v10 = 32 * i;
      v11 = (void *)v9[8 * i];
      if ( v11 )
        free(v11);
      v12 = *(void **)(*((_DWORD *)v4 + 259) + v10 + 4);
      if ( v12 )
        free(v12);
      v13 = *(void **)(v10 + *((_DWORD *)v4 + 259) + 8);
      if ( v13 )
        free(v13);
    }
    if ( v9 )
      operator delete[](v9);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v4 + 33396));
  return v4;
}

//----- (0004890C) --------------------------------------------------------
__int64 __fastcall ChannelPlayInfoManager::updateInvalidSpan(ChannelPlayInfoManager *this, int a2, double a3, double a4, double a5)
{
  double v5; // d7
  int i; // r1
  int v7; // r4
  int v8; // r1
  int v9; // r4

  v5 = a3;
  if ( a5 <= a3 || a5 >= a3 + a3 )
  {
    if ( a5 == a3 )
    {
      for ( i = *(_DWORD *)invalidSource; i; i = *(_DWORD *)(i + 24) )
      {
        v7 = *(_DWORD *)(i + 24);
        if ( !v7 )
          break;
        *(_QWORD *)(v7 + 16) = -4616189618054758400LL;
      }
      v8 = 0;
      while ( v8 < *((_DWORD *)this + 260) )
      {
        v9 = *((_DWORD *)this + 259) + 32 * v8++;
        *(_QWORD *)(v9 + 16) = -4616189618054758400LL;
      }
      v5 = a4;
    }
    else
    {
      v5 = a5 * 0.5;
    }
  }
  return *(_QWORD *)&v5;
}
// F41D8: using guessed type int invalidSource;

//----- (00048990) --------------------------------------------------------
void __fastcall ChannelPlayInfoManager::rewriteCdnList(ChannelPlayInfoManager *this, int *a2)
{
  ChannelPlayInfoManager *v2; // r4
  int v3; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r0
  int v7; // r8
  int v8; // r0
  int v9; // r1
  int v10; // r5
  void **v11; // r2
  int v12; // r3
  signed int v13; // r11
  size_t v14; // r0
  void *v15; // t1
  int i; // r5
  size_t v17; // r0
  void *src; // [sp+0h] [bp+0h]
  ChannelPlayInfoManager *v19; // [sp+4h] [bp+4h]

  v2 = this;
  v3 = *((_DWORD *)this + 258);
  v4 = 0;
  v5 = 0;
  while ( v4 < v3 )
  {
    v6 = a2[v4];
    v5 += v6;
    *(&src + v4++) = (void *)v6;
  }
  v7 = 0;
  v8 = time(0);
  srand48(v8);
  v19 = (ChannelPlayInfoManager *)((char *)v2 + 32000);
  while ( v7 < *((_DWORD *)v2 + 258) )
  {
    v9 = lrand48() % v5;
    v10 = 0;
    v11 = &src - 1;
    v12 = 0;
    while ( v10 < *((_DWORD *)v2 + 258) )
    {
      if ( v9 >= v12 )
      {
        v13 = (signed int)v11[1];
        if ( v9 < v12 + v13 )
        {
          v5 -= v13;
          src = *(void **)(*((_DWORD *)v19 + 27) + 4 * v10);
          v14 = strlen((const char *)src);
          memcpy(&src + 256 * v7, src, v14 + 1);
          *(&src + v10) = 0;
          break;
        }
      }
      v15 = v11[1];
      ++v11;
      ++v10;
      v12 += (int)v15;
    }
    ++v7;
  }
  for ( i = 0; i < *((_DWORD *)v2 + 258); ++i )
  {
    v17 = strlen((const char *)&src + 1024 * i);
    memcpy(*(void **)(*((_DWORD *)v2 + 8027) + 4 * i), &src + 256 * i, v17 + 1);
  }
}

//----- (00048A80) --------------------------------------------------------
void __fastcall ChannelPlayInfoManager::selectStream(ChannelPlayInfoManager *this)
{
  ChannelPlayInfoManager *v1; // r4
  int v2; // r6
  void *v3; // r0
  void *v4; // r0
  int v5; // r7
  int v6; // r0
  int v7; // r3
  int v8; // r2
  int i; // r10
  int v10; // r6
  double v11; // d8
  int v12; // r11
  int j; // r7
  int v14; // r9
  double v15; // r0
  int v16; // r9
  int k; // r7
  int v18; // r6
  const char *v19; // r1
  const char *v20; // r1
  const char *v21; // r1
  const char *v22; // r1
  const char ***v23; // r6
  pthread_mutex_t *v24; // r8
  const char **v25; // r7
  const char **l; // r6
  char *s1; // [sp+10h] [bp-60h]
  int v28; // [sp+14h] [bp-5Ch]
  char s; // [sp+1Ch] [bp-54h]
  int v30; // [sp+20h] [bp-50h]
  int v31; // [sp+24h] [bp-4Ch]
  int v32; // [sp+28h] [bp-48h]
  int v33; // [sp+2Ch] [bp-44h]
  _DWORD v34[1]; // [sp+30h] [bp-40h]

  v1 = this;
  memset(&s, 0, 0x14u);
  *(_DWORD *)v1 = 0;
  if ( *((_DWORD *)v1 + 260) > 0 )
  {
    if ( strcmp(&currentChannelId, preChannelId) )
    {
      v2 = invalidSource;
      if ( *(_DWORD *)invalidSource )
      {
        while ( 1 )
        {
          v5 = *(_DWORD *)(*(_DWORD *)v2 + 24);
          if ( !v5 )
            break;
          *(_DWORD *)(*(_DWORD *)v2 + 24) = *(_DWORD *)(v5 + 24);
          if ( *(_DWORD *)v5 )
            free(*(void **)v5);
          v3 = *(void **)(v5 + 4);
          if ( v3 )
            free(v3);
          v4 = *(void **)(v5 + 8);
          if ( v4 )
            free(v4);
          operator delete((void *)v5);
        }
      }
      strcpy(preChannelId, &currentChannelId);
      memset(&preSourceId, 0, 0x400u);
    }
    v6 = *((_DWORD *)v1 + 260);
    v7 = 0;
    while ( v7 < v6 )
    {
      v8 = *((_DWORD *)v1 + 259) + 32 * v7++;
      ++v34[*(_DWORD *)(v8 + 12) - 5];
    }
    currentAvailableStreamNum = v31 + v30 + v32 + v33;
    if ( currentAvailableStreamNum )
    {
      for ( i = *(_DWORD *)invalidSource; i; i = *(_DWORD *)(i + 24) )
      {
        v10 = *(_DWORD *)(i + 24);
        if ( !v10 )
          break;
        v12 = *((_DWORD *)v1 + 260);
        for ( j = 0; j < v12; ++j )
        {
          v14 = *((_DWORD *)v1 + 259) + 32 * j;
          if ( *(_DWORD *)v14 )
          {
            if ( *(_DWORD *)(v14 + 4) )
            {
              s1 = *(char **)(v14 + 4);
              if ( !strcmp(*(const char **)v14, *(const char **)v10) && !strcmp(s1, *(const char **)(v10 + 4)) )
              {
                *(_QWORD *)(v14 + 16) = *(_QWORD *)(v10 + 16);
                break;
              }
            }
          }
        }
      }
      v11 = 900.0;
      do
      {
        for ( k = 0; ; ++k )
        {
          HIDWORD(v15) = *((_DWORD *)v1 + 260);
          if ( k >= SHIDWORD(v15) )
            break;
          HIDWORD(v15) = k % SHIDWORD(v15);
          v16 = 32 * HIDWORD(v15);
          v28 = HIDWORD(v15);
          if ( *(double *)(*((_DWORD *)v1 + 259) + 32 * HIDWORD(v15) + 16) > 0.0 )
          {
            v15 = COERCE_DOUBLE(getTime());
            if ( v15 - *(double *)(*((_DWORD *)v1 + 259) + v16 + 16) < v11 )
              continue;
          }
          *(_DWORD *)v1 = *(_DWORD *)(*((_DWORD *)v1 + 259) + v16 + 12);
          break;
        }
        if ( *(_DWORD *)v1 )
          break;
        v11 = COERCE_DOUBLE(ChannelPlayInfoManager::updateInvalidSpan(v1, SHIDWORD(v15), 120.0, 900.0, v11));
      }
      while ( v11 >= 120.0 );
      currentStreamType = *(_DWORD *)v1;
      if ( *(_DWORD *)v1 )
      {
        v18 = 32 * v28;
        v19 = *(const char **)(*((_DWORD *)v1 + 259) + 32 * v28);
        if ( v19 )
          strcpy((char *)v1 + 8, v19);
        v20 = *(const char **)(*((_DWORD *)v1 + 259) + v18 + 8);
        if ( v20 )
          strcpy((char *)v1 + 32116, v20);
        v21 = *(const char **)(*((_DWORD *)v1 + 259) + v18 + 4);
        if ( v21 )
        {
          strcpy((char *)v1 + 33400, v21);
          strcpy(currentSourceSrc, *(const char **)(*((_DWORD *)v1 + 259) + v18 + 4));
          strcpy((char *)&preSourceSrc, *(const char **)(*((_DWORD *)v1 + 259) + v18 + 4));
        }
        v22 = *(const char **)(*((_DWORD *)v1 + 259) + v18);
        if ( v22 )
        {
          strcpy(&currentSourceId, v22);
          strcpy((char *)&preSourceId, *(const char **)(*((_DWORD *)v1 + 259) + v18));
        }
        v23 = (const char ***)invalidSource;
        v24 = (pthread_mutex_t *)(invalidSource + 4);
        pthread_mutex_lock((pthread_mutex_t *)(invalidSource + 4));
        v25 = *v23;
        if ( *v23 )
        {
          for ( l = (const char **)v25[6]; l; l = (const char **)l[6] )
          {
            if ( !strcmp(*l, &currentSourceId) && !strcmp(l[1], currentSourceSrc) )
            {
              v25[6] = l[6];
              operator delete(l);
              break;
            }
            v25 = l;
          }
        }
        pthread_mutex_unlock(v24);
      }
      ChannelPlayInfoManager::rewriteCdnList(v1, *((int **)v1 + 8028));
    }
  }
}
// F41D0: using guessed type int currentAvailableStreamNum;
// F41D4: using guessed type int currentStreamType;
// F41D8: using guessed type int invalidSource;
// F4988: using guessed type char currentSourceId;
// F5650: using guessed type char currentChannelId;

//----- (00048D70) --------------------------------------------------------
signed int __fastcall ChannelPlayInfoManager::changeCdnWithType(int a1, int a2, char *a3)
{
  char *v3; // r7
  char *v4; // r4
  int v5; // r5
  pthread_mutex_t *v6; // r6
  int v8; // [sp+4h] [bp-24h]
  char *v9; // [sp+8h] [bp-20h]

  v8 = a2;
  v9 = a3;
  v3 = a3;
  v4 = (char *)a1;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 1032) <= 0 )
    return -2;
  v6 = (pthread_mutex_t *)(a1 + 33396);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 33396));
  if ( ++*(_DWORD *)&v4[4 * v5 + 32076] >= *(_DWORD *)&v4[4 * v5 + 32092] )
  {
    *(_DWORD *)&v4[4 * v5 + 32076] = 0;
    *((_DWORD *)v4 + 8018) = (*((_DWORD *)v4 + 8018) + 1) % *((_DWORD *)v4 + 258);
    memset(v4 + 33140, 0, 0x100u);
    strcpy(v4 + 33140, *(const char **)(*((_DWORD *)v4 + 8027) + 4 * *((_DWORD *)v4 + 8018)));
  }
  if ( v3 )
    sprintf(v3, "%s%s%s", v4 + 32116, v4 + 33140, v4 + 8, v8, v9);
  pthread_mutex_unlock(v6);
  return 0;
}

//----- (00048E14) --------------------------------------------------------
int __fastcall ChannelPlayInfoManager::clearErrorWithType(int a1, int a2)
{
  int result; // r0

  result = a1 + 4 * (a2 + 8018);
  *(_DWORD *)(result + 4) = 0;
  return result;
}

//----- (00048E24) --------------------------------------------------------
signed int __fastcall ChannelPlayInfoManager::getCurrentCdnUrl(ChannelPlayInfoManager *this, char *a2, int a3)
{
  if ( !a2 )
    return -1;
  sprintf(a2, "%s%s%s", (char *)this + 32116, (char *)this + 33140, (char *)this + 8, a2, a3);
  return 0;
}

//----- (00048E54) --------------------------------------------------------
char *__fastcall ChannelPlayInfoManager::setCdnSrcIndex(ChannelPlayInfoManager *this, int a2)
{
  char *v2; // r4
  char *v3; // r5

  v2 = (char *)this + 32000;
  v3 = (char *)this + 33140;
  *((_DWORD *)this + 8018) = a2;
  memset((char *)this + 33140, 0, 0x100u);
  return j_strcpy(v3, *(const char **)(*((_DWORD *)v2 + 27) + 4 * *((_DWORD *)v2 + 18)));
}

//----- (00048E80) --------------------------------------------------------
char *__fastcall ChannelPlayInfoManager::setCdnSrcKey(ChannelPlayInfoManager *this, char *a2)
{
  char *v2; // r4
  char *v3; // r5

  v2 = (char *)this + 33140;
  v3 = a2;
  memset((char *)this + 33140, 0, 0x100u);
  return j_strcpy(v2, v3);
}

//----- (00048EA4) --------------------------------------------------------
signed int __fastcall ChannelPlayInfoManager::getCdnUrlWithIndex(ChannelPlayInfoManager *this, char *a2, int a3)
{
  int v3; // r3

  if ( a3 >= *((_DWORD *)this + 258) || a3 < 0 || !a2 )
    return -1;
  v3 = *(_DWORD *)(*((_DWORD *)this + 8027) + 4 * a3);
  sprintf(a2, "%s%s%s");
  return 0;
}

//----- (00048EE4) --------------------------------------------------------
signed int __fastcall ChannelPlayInfoManager::parseInfo(ChannelPlayInfoManager *this, char *a2, int a3)
{
  int v3; // r7
  ChannelPlayInfoManager *v4; // r4
  char *v5; // r8
  char *v6; // r11
  unsigned int v7; // r0
  char v8; // r9
  int v9; // r7
  int v10; // r7
  int v11; // r7
  int *v12; // r0
  int v13; // r1
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  const char *v18; // r0
  int *v19; // r0
  int *v20; // r0
  const char *v21; // r0
  int *v22; // r0
  int *v23; // r0
  const char *v24; // r0
  int v25; // r3
  char v26; // r2
  int *v27; // r0
  int *v28; // r0
  const char *v29; // r0
  bool v30; // r3
  _BOOL4 v31; // r9
  int *v32; // r0
  int *v33; // r0
  const char *v34; // r0
  bool v35; // r3
  int *v36; // r0
  int v37; // r0
  signed int v38; // r4
  unsigned int v39; // r0
  unsigned int v40; // r0
  int v41; // r6
  int *v42; // r8
  int v43; // r5
  unsigned int v45; // r0
  int v46; // r5
  int v47; // r6
  int v48; // r7
  int *v49; // r0
  int *v50; // r0
  int *v51; // r0
  int *v52; // r0
  const char *v53; // r0
  char *v54; // r0
  int v55; // r7
  int *v56; // r0
  int *v57; // r0
  int *v58; // r0
  int *v59; // r0
  const char *v60; // r0
  char *v61; // r0
  int v62; // r7
  int *v63; // r0
  int *v64; // r0
  int *v65; // r0
  int *v66; // r0
  const char *v67; // r0
  char *v68; // r0
  int v69; // r6
  char *v70; // r7
  signed int v71; // r3
  int *v72; // r0
  int v73; // r0
  int *v74; // r0
  int *v75; // r0
  int *v76; // r0
  int *v77; // r0
  int v78; // r1
  int v79; // ST1C_4
  size_t v80; // r0
  int *v81; // r0
  int *v82; // r0
  const char *v83; // r0
  int *v84; // r3
  int *v85; // r0
  int *v86; // r0
  const char *v87; // r0
  int *v88; // r0
  const char *v89; // r0
  int *v90; // r0
  int *v91; // r0
  const char *v92; // r0
  int *v93; // r0
  const char *v94; // r0
  const char *v95; // r1
  int *v96; // r0
  const char *v97; // r0
  char *s; // [sp+4h] [bp-12Ch]
  signed int v99; // [sp+18h] [bp-118h]
  void *v100; // [sp+20h] [bp-110h]
  pthread_t newthread; // [sp+24h] [bp-10Ch]
  char v102; // [sp+28h] [bp-108h]
  char v103; // [sp+38h] [bp-F8h]
  char v104; // [sp+48h] [bp-E8h]
  char v105; // [sp+58h] [bp-D8h]
  char v106; // [sp+68h] [bp-C8h]
  int v107; // [sp+78h] [bp-B8h]
  int v108; // [sp+90h] [bp-A0h]

  v3 = a3;
  v4 = this;
  v5 = a2;
  Json::Reader::Reader((Json::Reader *)&v108);
  Json::Value::Value((int)&v102, 0);
  Json::Value::Value((int)&v103, 0);
  Json::Value::Value((int)&v104, 0);
  v100 = &unk_2FEF48;
  Json::Value::Value((int)&v105, 0);
  Json::Value::Value((int)&v106, 0);
  if ( !v5 )
    goto LABEL_37;
  v6 = (char *)malloc(v3 + 1);
  v7 = isNeedDecrypt(v5);
  v8 = v7;
  if ( v7 )
  {
    v9 = v3 - 4;
    memcpy(v6, v5 + 4, v9);
    v107 = 0;
    v10 = decryptChunk(v6, v9, &v107);
    memmove(v6, &v6[v107], v10);
    v6[v10] = 0;
  }
  else
  {
    memcpy(v6, v5, v3);
    v6[v3] = v8;
  }
  strcpy((char *)v4 + 1044, v6);
  if ( strlen(v6) > 2 )
  {
    cpIsNull = 0;
  }
  else
  {
    cpIsNull = 1;
    if ( !continueSwitchCount )
      noDataStartTime = getTime();
  }
  sub_C1C58((void **)&v107, v6);
  v11 = Json::Reader::parse((const char **)&v108, (int)&v107, (Json::Value *)&v102, 1);
  sub_C0AD8(&v107);
  if ( !v11 )
    goto LABEL_44;
  v12 = Json::Value::operator[]((Json::Value *)&v102, "serverTime");
  *((_DWORD *)v4 + 1) = Json::Value::asInt((Json::Value *)v12, v13);
  v14 = Json::Value::operator[]((Json::Value *)&v102, "streamList");
  Json::Value::operator=((int)&v103, (const Json::Value *)v14);
  v15 = Json::Value::operator[]((Json::Value *)&v102, "rtmpurl");
  Json::Value::operator=((int)&v104, (const Json::Value *)v15);
  v16 = Json::Value::operator[]((Json::Value *)&v102, "rtmplist");
  Json::Value::operator=((int)&v106, (const Json::Value *)v16);
  v17 = Json::Value::operator[]((Json::Value *)&v102, "global");
  Json::Value::operator=((int)&v105, (const Json::Value *)v17);
  if ( !Json::Value::empty((Json::Value *)&v104) )
  {
    v18 = (const char *)Json::Value::asCString((Json::Value *)&v104);
    strcpy((char *)v4 + 31045, v18);
  }
  if ( !Json::Value::empty((Json::Value *)&v106) )
  {
    v19 = Json::Value::operator[]((Json::Value *)&v106, bitrate);
    if ( Json::Value::asCString((Json::Value *)v19) )
    {
      v20 = Json::Value::operator[]((Json::Value *)&v106, bitrate);
      v21 = (const char *)Json::Value::asCString((Json::Value *)v20);
      strcpy((char *)v4 + 31045, v21);
    }
  }
  if ( !Json::Value::empty((Json::Value *)&v105)
    && (v22 = Json::Value::operator[]((Json::Value *)&v105, "hwd_enable"), Json::Value::asCString((Json::Value *)v22))
    && (v23 = Json::Value::operator[]((Json::Value *)&v105, "hwd_enable"),
        v24 = (const char *)Json::Value::asCString((Json::Value *)v23),
        !strcmp(v24, "true")) )
  {
    v25 = (int)v4 + 30976;
    v26 = 1;
  }
  else
  {
    v25 = (int)v4 + 30976;
    v26 = 0;
  }
  *(_BYTE *)(v25 + 68) = v26;
  v30 = 0;
  if ( !Json::Value::empty((Json::Value *)&v105) )
  {
    v27 = Json::Value::operator[]((Json::Value *)&v105, "report_cpu_arch");
    if ( Json::Value::asCString((Json::Value *)v27) )
    {
      v28 = Json::Value::operator[]((Json::Value *)&v105, "report_cpu_arch");
      v29 = (const char *)Json::Value::asCString((Json::Value *)v28);
      if ( !strcmp(v29, "true") )
        v30 = 1;
    }
  }
  isReportCpuArch = v30;
  v31 = strcmp(&packageName, "com.zhangyu") == 0;
  if ( isReportCpuArch && !reportedCpuArch )
  {
    pthread_attr_init((pthread_attr_t *)&v107);
    pthread_attr_setdetachstate((pthread_attr_t *)&v107, 1);
    newthread = 0;
    pthread_create(&newthread, 0, (void *(*)(void *))readBuildProp, 0);
    reportedCpuArch = 1;
  }
  v35 = 0;
  if ( !Json::Value::empty((Json::Value *)&v105) )
  {
    v32 = Json::Value::operator[]((Json::Value *)&v105, "allow_increase_delay");
    if ( Json::Value::asCString((Json::Value *)v32) )
    {
      v33 = Json::Value::operator[]((Json::Value *)&v105, "allow_increase_delay");
      v34 = (const char *)Json::Value::asCString((Json::Value *)v33);
      if ( !strcmp(v34, "true") )
        v35 = 1;
    }
  }
  allowIncreaseDelay = v35;
  if ( !isCardToSwitch || !isCompatible || !allowIncreaseDelay )
  {
    if ( !v31 )
      goto LABEL_92;
    goto LABEL_50;
  }
  if ( v31 )
  {
LABEL_50:
    if ( currentChannelId == 122 && byte_F5651 == 121 && byte_F5652 == 95 )
    {
      if ( lowDelayChannel )
      {
        if ( !Json::Value::empty((Json::Value *)&v105) )
        {
          v81 = Json::Value::operator[]((Json::Value *)&v105, "zhubo_allow_rtmp_to_data");
          if ( Json::Value::asCString((Json::Value *)v81) )
          {
            v82 = Json::Value::operator[]((Json::Value *)&v105, "zhubo_allow_rtmp_to_data");
            v83 = (const char *)Json::Value::asCString((Json::Value *)v82);
            if ( !strcmp(v83, "true") )
            {
              allowRtmpChangeToData = 1;
              strcpy((char *)v4 + 31045, (const char *)&unk_E9B9C);
              v84 = (_DWORD *)&byte_6;
LABEL_90:
              delay_time = v84;
LABEL_91:
              isCardToSwitch = 0;
              goto LABEL_36;
            }
          }
        }
      }
      if ( Json::Value::empty((Json::Value *)&v105)
        || (v90 = Json::Value::operator[]((Json::Value *)&v105, "zhubo_delay_time"),
            !Json::Value::asCString((Json::Value *)v90))
        || (v91 = Json::Value::operator[]((Json::Value *)&v105, "zhubo_delay_time"),
            v92 = (const char *)Json::Value::asCString((Json::Value *)v91),
            atoi(v92) <= 0)
        || (v93 = Json::Value::operator[]((Json::Value *)&v105, "zhubo_delay_time"),
            v94 = (const char *)Json::Value::asCString((Json::Value *)v93),
            atoi(v94) > 159) )
      {
LABEL_102:
        v84 = &dword_64;
        goto LABEL_90;
      }
      v95 = "zhubo_delay_time";
LABEL_107:
      v96 = Json::Value::operator[]((Json::Value *)&v105, v95);
      v97 = (const char *)Json::Value::asCString((Json::Value *)v96);
      delay_time = (int *)atoi(v97);
      goto LABEL_91;
    }
LABEL_92:
    if ( isMovieChannel
      || Json::Value::empty((Json::Value *)&v105)
      || (v85 = Json::Value::operator[]((Json::Value *)&v105, "mobile_delay_time"),
          !Json::Value::asCString((Json::Value *)v85))
      || (v86 = Json::Value::operator[]((Json::Value *)&v105, "mobile_delay_time"),
          v87 = (const char *)Json::Value::asCString((Json::Value *)v86),
          atoi(v87) <= 0)
      || (v88 = Json::Value::operator[]((Json::Value *)&v105, "mobile_delay_time"),
          v89 = (const char *)Json::Value::asCString((Json::Value *)v88),
          atoi(v89) > 159) )
    {
      if ( isMovieChannel )
      {
        v84 = &dword_78;
        goto LABEL_90;
      }
      goto LABEL_102;
    }
    v95 = "mobile_delay_time";
    goto LABEL_107;
  }
  if ( (signed int)delay_time <= 140 )
    delay_time = (int *)((char *)delay_time + 15);
LABEL_36:
  v36 = Json::Value::operator[]((Json::Value *)&v102, "parameters");
  Json::Value::operator=((int)&v104, (const Json::Value *)v36);
  v37 = Json::Value::size((Json::Value *)&v103);
  *((_DWORD *)v4 + 260) = v37;
  if ( v37 > 0 )
  {
    if ( (unsigned int)v37 > 0x3F80000 )
      v45 = -1;
    else
      v45 = 32 * v37;
    v46 = 0;
    *((_DWORD *)v4 + 259) = operator new[](v45);
    while ( v46 < *((_DWORD *)v4 + 260) )
    {
      v47 = 32 * v46;
      v48 = *((_DWORD *)v4 + 259);
      v49 = Json::Value::operator[]((int)&v103, v46);
      v50 = Json::Value::operator[]((Json::Value *)v49, "sid");
      if ( Json::Value::type((Json::Value *)v50) == 4 )
      {
        v51 = Json::Value::operator[]((int)&v103, v46);
        v52 = Json::Value::operator[]((Json::Value *)v51, "sid");
        v53 = (const char *)Json::Value::asCString((Json::Value *)v52);
        v54 = strdup(v53);
      }
      else
      {
        v54 = 0;
      }
      *(_DWORD *)(v48 + v47) = v54;
      v55 = *((_DWORD *)v4 + 259) + v47;
      v56 = Json::Value::operator[]((int)&v103, v46);
      v57 = Json::Value::operator[]((Json::Value *)v56, "ssrc");
      if ( Json::Value::type((Json::Value *)v57) == 4 )
      {
        v58 = Json::Value::operator[]((int)&v103, v46);
        v59 = Json::Value::operator[]((Json::Value *)v58, "ssrc");
        v60 = (const char *)Json::Value::asCString((Json::Value *)v59);
        v61 = strdup(v60);
      }
      else
      {
        v61 = 0;
      }
      *(_DWORD *)(v55 + 4) = v61;
      v62 = *((_DWORD *)v4 + 259) + v47;
      v63 = Json::Value::operator[]((int)&v103, v46);
      v64 = Json::Value::operator[]((Json::Value *)v63, "cdnString");
      if ( Json::Value::type((Json::Value *)v64) == 4 )
      {
        v65 = Json::Value::operator[]((int)&v103, v46);
        v66 = Json::Value::operator[]((Json::Value *)v65, "cdnString");
        v67 = (const char *)Json::Value::asCString((Json::Value *)v66);
        v68 = strdup(v67);
      }
      else
      {
        v68 = 0;
      }
      *(_DWORD *)(v62 + 8) = v68;
      *(double *)(*((_DWORD *)v4 + 259) + v47 + 16) = -1.0;
      v69 = v47 + *((_DWORD *)v4 + 259);
      v70 = *(char **)(v69 + 4);
      if ( v70 )
      {
        if ( v70 == strstr(*(const char **)(v69 + 4), "m3u8p2p://") )
        {
          v71 = 2;
        }
        else if ( v70 == strstr(v70, "flvp2p://") )
        {
          v71 = 1;
        }
        else if ( v70 != strstr(v70, "m3u8://") && v70 != strstr(v70, "m3u8proxy://") && v70 != strstr(v70, "xproxy://") )
        {
          v71 = 4;
        }
        else
        {
          v71 = 3;
        }
        *(_DWORD *)(v69 + 12) = v71;
      }
      ++v46;
    }
    v72 = Json::Value::operator[]((Json::Value *)&v102, "cdnList");
    Json::Value::operator=((int)&v103, (const Json::Value *)v72);
    v73 = Json::Value::size((Json::Value *)&v103);
    *((_DWORD *)v4 + 258) = v73;
    if ( v73 <= 0 )
    {
      free(v6);
      goto LABEL_37;
    }
    *((_DWORD *)v4 + 8027) = cucalloc(v73, 4u);
    v39 = *((_DWORD *)v4 + 258);
    if ( v39 > 0x1FC00000 )
      v40 = -1;
    else
      v40 = 4 * v39;
    v41 = 0;
    v42 = (int *)((char *)v4 + 32108);
    *((_DWORD *)v4 + 8028) = operator new[](v40);
    v43 = 0;
    while ( v41 < *((_DWORD *)v4 + 258) )
    {
      v74 = Json::Value::operator[]((int)&v103, v41);
      v75 = Json::Value::operator[]((Json::Value *)v74, "key");
      s = (char *)Json::Value::asCString((Json::Value *)v75);
      v76 = Json::Value::operator[]((int)&v103, v41);
      v77 = Json::Value::operator[]((Json::Value *)v76, "value");
      v99 = Json::Value::asInt((Json::Value *)v77, v78);
      if ( v99 > 0 )
      {
        v79 = *v42;
        v80 = strlen(s);
        *(_DWORD *)(v79 + 4 * v43) = cucalloc(v80 + 1, 1u);
        strcpy(*(char **)(*v42 + 4 * v43), s);
        *(_DWORD *)(*((_DWORD *)v4 + 8028) + 4 * v43++) = v99;
      }
      ++v41;
    }
    *((_DWORD *)v4 + 258) = v43;
LABEL_44:
    v38 = 0;
    free(v6);
    goto LABEL_45;
  }
LABEL_37:
  v38 = -1;
LABEL_45:
  Json::Value::~Value((Json::Value *)&v106);
  Json::Value::~Value((Json::Value *)&v105);
  sub_C0AD8(&v100);
  Json::Value::~Value((Json::Value *)&v104);
  Json::Value::~Value((Json::Value *)&v103);
  Json::Value::~Value((Json::Value *)&v102);
  Json::Reader::~Reader((Json::Reader *)&v108);
  return v38;
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// 64: using guessed type int dword_64;
// 78: using guessed type int dword_78;
// F30D8: using guessed type char cpIsNull;
// F30DC: using guessed type int *delay_time;
// F3948: using guessed type char *bitrate;
// F419A: using guessed type char lowDelayChannel;
// F419B: using guessed type char allowRtmpChangeToData;
// F41B0: using guessed type int continueSwitchCount;
// F41B5: using guessed type char isReportCpuArch;
// F41B6: using guessed type char reportedCpuArch;
// F41B7: using guessed type char isMovieChannel;
// F41B8: using guessed type char isCompatible;
// F41B9: using guessed type char allowIncreaseDelay;
// F41BA: using guessed type char isCardToSwitch;
// F55EC: using guessed type char packageName;
// F5650: using guessed type char currentChannelId;
// F5651: using guessed type char byte_F5651;
// F5652: using guessed type char byte_F5652;

//----- (0004975C) --------------------------------------------------------
ChannelPlayInfoManager *__fastcall ChannelPlayInfoManager::ChannelPlayInfoManager(ChannelPlayInfoManager *this, char *a2, int a3)
{
  ChannelPlayInfoManager *v3; // r4
  char *v4; // r6
  char *v5; // r9
  int v6; // r8
  int v7; // r5
  int v8; // r2
  int v9; // r3
  int v11; // [sp+0h] [bp-30h]
  int v12; // [sp+4h] [bp-2Ch]
  int v13; // [sp+8h] [bp-28h]
  int v14; // [sp+Ch] [bp-24h]

  v3 = this;
  v4 = (char *)this + 30976;
  v5 = a2;
  v6 = a3;
  v7 = 0;
  memset((char *)this + 1044, 0, 0x7530u);
  memset(v4 + 69, 0, 0x400u);
  memset((char *)v3 + 33140, 0, 0x100u);
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 259) = 0;
  *((_DWORD *)v3 + 260) = 0;
  allowIncreaseDelay = 0;
  *((_DWORD *)v3 + 1) = 0;
  *((_DWORD *)v3 + 258) = 0;
  *((_DWORD *)v3 + 8018) = 0;
  allowRtmpChangeToData = 0;
  *((_BYTE *)v3 + 8) = 0;
  *((_BYTE *)v3 + 33400) = 0;
  v4[68] = 0;
  v11 = 1;
  v12 = 5;
  v13 = 3;
  v14 = 20;
  do
  {
    v8 = (int)v3 + 4 * v7 + 32000;
    *((_DWORD *)v3 + v7 + 8018 + 1) = 0;
    v9 = *(&v11 + v7++);
    *(_DWORD *)(v8 + 92) = v9;
  }
  while ( v7 != 4 );
  *((_DWORD *)v3 + 8027) = 0;
  *((_DWORD *)v3 + 8028) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)v3 + 33396), 0);
  ChannelPlayInfoManager::parseInfo(v3, v5, v6);
  return v3;
}
// F419B: using guessed type char allowRtmpChangeToData;
// F41B9: using guessed type char allowIncreaseDelay;

//----- (0004982C) --------------------------------------------------------
int __fastcall boost::detail::sp_counted_base::~sp_counted_base(int result)
{
  *(_DWORD *)result = off_F0208;
  return result;
}
// F0208: using guessed type _DWORD (__fastcall *[2])(boost::detail::sp_counted_base *__hidden this);

//----- (00049844) --------------------------------------------------------
int __fastcall boost::detail::sp_counted_base::destroy(int result)
{
  if ( result )
    result = (*(int (**)(void))(*(_DWORD *)result + 4))();
  return result;
}

//----- (00049860) --------------------------------------------------------
_DWORD *__fastcall boost::detail::sp_counted_impl_p<CBuffer>::~sp_counted_impl_p(_DWORD *result)
{
  *result = off_F0208;
  return result;
}
// F0208: using guessed type _DWORD (__fastcall *off_F0208[2])(boost::detail::sp_counted_base *__hidden this);

//----- (00049878) --------------------------------------------------------
int boost::detail::sp_counted_impl_p<CBuffer>::get_deleter()
{
  return 0;
}

//----- (00049880) --------------------------------------------------------
int boost::detail::sp_counted_impl_p<CBuffer>::get_untyped_deleter()
{
  return 0;
}

//----- (00049888) --------------------------------------------------------
boost::detail::sp_counted_base *__fastcall boost::detail::sp_counted_base::~sp_counted_base(boost::detail::sp_counted_base *this)
{
  boost::detail::sp_counted_base *v1; // r4

  v1 = this;
  *(_DWORD *)this = off_F0208;
  operator delete((void *)this);
  return v1;
}
// F0208: using guessed type _DWORD (__fastcall *off_F0208[2])(boost::detail::sp_counted_base *__hidden this);

//----- (000498B0) --------------------------------------------------------
_DWORD *__fastcall boost::detail::sp_counted_impl_p<CBuffer>::~sp_counted_impl_p(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = off_F0208;
  operator delete(a1);
  return v1;
}
// F0208: using guessed type _DWORD (__fastcall *off_F0208[2])(boost::detail::sp_counted_base *__hidden this);

//----- (000498D8) --------------------------------------------------------
void __fastcall boost::detail::sp_counted_impl_p<CBuffer>::dispose(int a1)
{
  _DWORD *v1; // r4
  void *v2; // r0

  v1 = *(_DWORD **)(a1 + 12);
  if ( v1 )
  {
    v2 = (void *)v1[3];
    if ( v2 )
      operator delete[](v2);
    operator delete(v1);
  }
}

//----- (00049904) --------------------------------------------------------
int __fastcall boost::detail::sp_counted_base::release(int result)
{
  unsigned int *v1; // r3
  int v2; // r4
  unsigned int v3; // r2
  unsigned int *v4; // r5
  unsigned int v5; // r3

  v1 = (unsigned int *)(result + 4);
  __dmb(0xFu);
  v2 = result;
  do
    v3 = __ldrex(v1);
  while ( __strex(v3 - 1, v1) );
  __dmb(0xFu);
  if ( v3 == 1 )
  {
    v4 = (unsigned int *)(result + 8);
    result = (*(int (**)(void))(*(_DWORD *)result + 8))();
    __dmb(0xFu);
    do
      v5 = __ldrex(v4);
    while ( __strex(v5 - 1, v4) );
    __dmb(0xFu);
    if ( v5 == 1 )
      result = (*(int (__fastcall **)(int))(*(_DWORD *)v2 + 12))(v2);
  }
  return result;
}

//----- (0004997C) --------------------------------------------------------
StunClient *__fastcall StunClient::StunClient(StunClient *this)
{
  StunClient *v1; // r4
  _DWORD *v2; // r0
  _DWORD *v3; // r3
  void *v4; // r6
  StunClient *result; // r0

  v1 = this;
  CSocketAddress::CSocketAddress((int)this);
  *((_DWORD *)v1 + 13) = &unk_2FEF48;
  CSocketAddress::CSocketAddress((int)v1 + 56);
  CStunSocket::CStunSocket((StunClient *)((char *)v1 + 84));
  StunClientResults::StunClientResults((StunClient *)((char *)v1 + 148));
  v2 = malloc(0x10u);
  *v2 = 0;
  v3 = v2 + 2;
  *((_DWORD *)v1 + 91) = v2;
  v2[1] = 0;
  *v3 = 0;
  v3[1] = 0;
  v4 = operator new(0xBF0u);
  UpnpManager::UpnpManager((int)v4);
  result = v1;
  *((_DWORD *)v1 + 92) = v4;
  *((_BYTE *)v1 + 372) = 1;
  return result;
}

//----- (00049A40) --------------------------------------------------------
StunClient *__fastcall StunClient::~StunClient(StunClient *this)
{
  StunClient *v1; // r4
  void *v2; // r0
  void *v3; // r5
  int v4; // r2
  void *v5; // r0
  unsigned int *v7; // r2
  signed int v8; // r3

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 91);
  if ( v2 )
  {
    free(v2);
    *((_DWORD *)v1 + 91) = 0;
  }
  v3 = (void *)*((_DWORD *)v1 + 92);
  if ( v3 )
  {
    UpnpManager::~UpnpManager(*((UpnpManager **)v1 + 92));
    operator delete(v3);
    *((_DWORD *)v1 + 92) = 0;
  }
  CStunSocket::~CStunSocket((StunClient *)((char *)v1 + 84));
  v4 = *((_DWORD *)v1 + 13);
  v5 = (void *)(v4 - 12);
  if ( (int *)(v4 - 12) != &dword_2FEF3C )
  {
    v7 = (unsigned int *)(v4 - 4);
    __dmb(0xFu);
    do
      v8 = __ldrex(v7);
    while ( __strex(v8 - 1, v7) );
    __dmb(0xFu);
    if ( v8 <= 0 )
      operator delete(v5);
  }
  return v1;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00049B0C) --------------------------------------------------------
int __fastcall StunClient::GetMillisecondCounter(StunClient *this)
{
  int v2; // [sp+0h] [bp-10h]
  int v3; // [sp+4h] [bp-Ch]

  v2 = 0;
  v3 = 0;
  gettimeofday((struct timeval *)&v2, 0);
  return v3 / 1000 + 1000 * v2;
}

//----- (00049B58) --------------------------------------------------------
char *__fastcall StunClient::ResolveHostName(StunClient *this, const char *a2, int a3, int a4, CSocketAddress *a5)
{
  int v5; // r7
  int v6; // r8
  int v7; // r0
  struct addrinfo *v8; // r7
  int v9; // r1
  int v10; // r2
  int v11; // r3
  unsigned int v12; // r5
  _DWORD *v13; // r12
  int v14; // r1
  int v15; // r2
  char *v16; // r2
  char *result; // r0
  unsigned int *v18; // r2
  signed int v19; // r3
  struct addrinfo *pai; // [sp+8h] [bp-60h]
  char *name; // [sp+Ch] [bp-5Ch]
  struct addrinfo req; // [sp+10h] [bp-58h]
  char v23; // [sp+30h] [bp-38h]
  int v24; // [sp+34h] [bp-34h]
  int v25; // [sp+38h] [bp-30h]
  int v26; // [sp+3Ch] [bp-2Ch]
  int v27; // [sp+40h] [bp-28h]
  int v28; // [sp+44h] [bp-24h]
  int v29; // [sp+48h] [bp-20h]
  char *v30; // [sp+4Ch] [bp-1Ch]

  v5 = a3;
  v6 = a4;
  pai = 0;
  req.ai_flags = 0;
  req.ai_family = 0;
  req.ai_socktype = 0;
  req.ai_protocol = 0;
  req.ai_addrlen = 0;
  req.ai_addr = 0;
  req.ai_canonname = 0;
  req.ai_next = 0;
  sub_C1C58((void **)&name, (char *)a2);
  if ( *((_DWORD *)name - 3) && a5 )
  {
    if ( v6 )
      req.ai_flags = 4;
    req.ai_family = v5;
    req.ai_socktype = 1;
    v7 = getaddrinfo(name, 0, &req, &pai);
    if ( v7 )
    {
      v12 = v7 | 0x88000000;
      v8 = pai;
    }
    else
    {
      v8 = pai;
      if ( pai )
      {
        CSocketAddress::CSocketAddress((CSocketAddress *)&v23, (const sockaddr *)pai->ai_canonname);
        v9 = v24;
        v10 = v25;
        v11 = v26;
        v12 = 0;
        v8 = pai;
        *(_DWORD *)a5 = *(_DWORD *)&v23;
        *((_DWORD *)a5 + 1) = v9;
        *((_DWORD *)a5 + 2) = v10;
        *((_DWORD *)a5 + 3) = v11;
        v13 = (_DWORD *)((char *)a5 + 16);
        v14 = v28;
        v15 = v29;
        *v13 = v27;
        v13[1] = v14;
        v13[2] = v15;
      }
      else
      {
        v12 = -2147467259;
      }
    }
  }
  else
  {
    v12 = -2147024809;
    v8 = pai;
  }
  freeaddrinfo(v8);
  v16 = name;
  result = name - 12;
  if ( name - 12 != (char *)&dword_2FEF3C )
    goto LABEL_14;
  while ( 1 )
  {
    v16 = v30;
    result = (char *)v12;
    if ( v30 == (char *)_stack_chk_guard )
      break;
LABEL_14:
    v18 = (unsigned int *)(v16 - 4);
    __dmb(0xFu);
    do
      v19 = __ldrex(v18);
    while ( __strex(v19 - 1, v18) );
    __dmb(0xFu);
    if ( v19 <= 0 )
      operator delete(result);
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00049CF0) --------------------------------------------------------
int __fastcall StunClient::GetLocalPortNumberFromSocket(StunClient *this, int a2, CSocketAddress *a3)
{
  StunClient *v3; // r7
  int v4; // r8
  int result; // r0
  int v6; // r1
  int v7; // [sp+0h] [bp-A0h]
  __int16 s; // [sp+4h] [bp-9Ch]
  unsigned __int16 v9; // [sp+6h] [bp-9Ah]

  v3 = this;
  v4 = a2;
  memset(&s, 0, 0x80u);
  v7 = 128;
  result = getsockname((int)v3, (struct sockaddr *)&s, (socklen_t *)&v7);
  if ( result != -1 )
  {
    if ( s == 2 )
      v6 = (unsigned __int16)__rev16(v9);
    else
      v6 = 0;
    result = CSocketAddress::SetPort(v4, v6);
  }
  return result;
}

//----- (00049D90) --------------------------------------------------------
int __fastcall StunClient::InitSocketAddress(int result, int a2, CSocketAddress *a3)
{
  _DWORD *v3; // r6
  int v4; // r1
  int v5; // r2
  int v6; // r3
  _DWORD *v7; // r12
  int v8; // r1
  int v9; // r2
  int v10; // [sp+0h] [bp-40h]
  int v11; // [sp+4h] [bp-3Ch]
  int v12; // [sp+8h] [bp-38h]
  int v13; // [sp+Ch] [bp-34h]
  char v14; // [sp+10h] [bp-30h]
  int v15; // [sp+14h] [bp-2Ch]
  int v16; // [sp+18h] [bp-28h]
  int v17; // [sp+1Ch] [bp-24h]
  int v18; // [sp+20h] [bp-20h]
  int v19; // [sp+24h] [bp-1Ch]
  int v20; // [sp+28h] [bp-18h]

  v3 = (_DWORD *)a2;
  if ( result == 2 )
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    LOWORD(v10) = 2;
    CSocketAddress::CSocketAddress((CSocketAddress *)&v14, (const sockaddr_in *)&v10);
    v4 = v15;
    v5 = v16;
    v6 = v17;
    *v3 = *(_DWORD *)&v14;
    v3[1] = v4;
    v3[2] = v5;
    v3[3] = v6;
    v7 = v3 + 4;
    result = v18;
    v8 = v19;
    v9 = v20;
    *v7 = v18;
    v7[1] = v8;
    v7[2] = v9;
  }
  return result;
}

//----- (00049E18) --------------------------------------------------------
ssize_t __fastcall StunClient::recvfromex(StunClient *this, int a2, void *a3, unsigned int a4, int flags, CSocketAddress *a6, CSocketAddress *a7)
{
  StunClient *v7; // r10
  void *v8; // r11
  unsigned int v9; // ST04_4
  ssize_t v10; // r5
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r9
  int v15; // r1
  int v16; // r2
  _DWORD *v17; // r3
  in_addr_t v19; // r12
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r12
  int v24; // r1
  CSocketAddress *v25; // r2
  void *v26; // [sp+Ch] [bp-4E4h]
  unsigned int v27; // [sp+10h] [bp-4E0h]
  char *v28; // [sp+14h] [bp-4DCh]
  int v29; // [sp+18h] [bp-4D8h]
  int *v30; // [sp+1Ch] [bp-4D4h]
  int v31; // [sp+20h] [bp-4D0h]
  char *v32; // [sp+24h] [bp-4CCh]
  unsigned int v33; // [sp+28h] [bp-4C8h]
  int v34; // [sp+2Ch] [bp-4C4h]
  sockaddr_in v35; // [sp+30h] [bp-4C0h]
  char v36; // [sp+40h] [bp-4B0h]
  int v37; // [sp+44h] [bp-4ACh]
  int v38; // [sp+48h] [bp-4A8h]
  int v39; // [sp+4Ch] [bp-4A4h]
  int v40; // [sp+50h] [bp-4A0h]
  int v41; // [sp+54h] [bp-49Ch]
  CSocketAddress *v42; // [sp+58h] [bp-498h]
  char s; // [sp+5Ch] [bp-494h]
  char v44; // [sp+DCh] [bp-414h]
  int v45; // [sp+4C8h] [bp-28h]

  v7 = (StunClient *)a2;
  v8 = a3;
  v34 = 0;
  v9 = a4;
  memset(&s, 0, 0x80u);
  v27 = v9;
  v30 = (int *)&v26;
  v31 = 1;
  v26 = v8;
  v28 = &s;
  v29 = 128;
  v32 = &v44;
  v33 = 1000;
  v10 = recvmsg((int)v7, (struct msghdr *)&v28, flags);
  if ( v10 > 0 )
  {
    if ( a6 )
    {
      CSocketAddress::CSocketAddress((CSocketAddress *)&v36, (const sockaddr *)&s);
      v11 = v37;
      v12 = v38;
      v13 = v39;
      *(_DWORD *)a6 = *(_DWORD *)&v36;
      *((_DWORD *)a6 + 1) = v11;
      *((_DWORD *)a6 + 2) = v12;
      *((_DWORD *)a6 + 3) = v13;
      v14 = (_DWORD *)((char *)a6 + 16);
      v15 = v41;
      v16 = (int)v42;
      *v14 = v40;
      v14[1] = v15;
      v14[2] = v16;
    }
    if ( a7 )
    {
      StunClient::InitSocketAddress(*(unsigned __int16 *)&s, (int)a7, (CSocketAddress *)&v45);
      if ( v33 < 0xC )
        v17 = 0;
      else
        v17 = v32;
      while ( v17 )
      {
        if ( !v17[1] && v17[2] == 8 && v17 != (_DWORD *)-12 )
        {
          *(_DWORD *)v35.sin_zero = v17[1];
          *(_DWORD *)&v35.sin_zero[4] = 0;
          v19 = v17[5];
          *(_DWORD *)&v35.sin_family = 0;
          v35.sin_addr.s_addr = v19;
          v35.sin_family = 2;
          CSocketAddress::CSocketAddress((CSocketAddress *)&v36, &v35);
          v20 = v37;
          v21 = v38;
          v22 = v39;
          *(_DWORD *)a7 = *(_DWORD *)&v36;
          *((_DWORD *)a7 + 1) = v20;
          *((_DWORD *)a7 + 2) = v21;
          *((_DWORD *)a7 + 3) = v22;
          v23 = (_DWORD *)((char *)a7 + 16);
          v24 = v41;
          v25 = v42;
          *v23 = v40;
          v23[1] = v24;
          v23[2] = v25;
          StunClient::GetLocalPortNumberFromSocket(v7, (int)a7, v25);
          return v10;
        }
        v17 = (_DWORD *)((char *)v17 + ((*v17 + 3) & 0xFFFFFFFC));
        if ( v33 < (char *)(v17 + 3) - v32 )
          return v10;
      }
    }
  }
  return v10;
}

//----- (00049FFC) --------------------------------------------------------
char *__fastcall StunClient::InitialSocket(StunClient *this, const char *a2)
{
  const void **v2; // r7
  StunClient *v3; // r4
  int v4; // r12
  const char *v5; // r8
  int v6; // r5
  int v7; // r1
  int v8; // r2
  int v9; // r3
  _DWORD *v10; // r12
  int v11; // r9
  _DWORD *v12; // r12
  int v13; // r1
  int v14; // r2
  char *v15; // r5
  char v17; // [sp+8h] [bp-88h]
  int v18; // [sp+Ch] [bp-84h]
  int v19; // [sp+10h] [bp-80h]
  int v20; // [sp+14h] [bp-7Ch]
  int v21; // [sp+18h] [bp-78h]
  int v22; // [sp+1Ch] [bp-74h]
  int v23; // [sp+20h] [bp-70h]
  int v24; // [sp+6Ch] [bp-24h]

  v2 = (const void **)((char *)this + 52);
  v3 = this;
  *((_DWORD *)this + 11) = 2;
  v4 = _stack_chk_guard;
  *((_DWORD *)this + 12) = 2;
  v5 = a2;
  v24 = v4;
  sub_C0F20((int *)this + 13, "udp", 3u);
  v6 = sub_C08E8(v2, "udp");
  if ( v6 )
  {
    v15 = (char *)-2147024809;
    puts("Only udp is supported protocol versions");
  }
  else
  {
    CSocketAddress::CSocketAddress((int)&v17, 0, 0);
    v7 = v18;
    v8 = v19;
    v9 = v20;
    v10 = (_DWORD *)((char *)v3 + 56);
    v11 = *((_DWORD *)v3 + 11);
    *v10 = *(_DWORD *)&v17;
    v10[1] = v7;
    v10[2] = v8;
    v10[3] = v9;
    v12 = (_DWORD *)((char *)v3 + 72);
    v13 = v22;
    v14 = v23;
    *v12 = v21;
    v12[1] = v13;
    v12[2] = v14;
    *((_BYTE *)v3 + 40) = 0;
    *((_BYTE *)v3 + 28) = 0;
    *((_DWORD *)v3 + 8) = 0;
    *((_DWORD *)v3 + 9) = 0;
    v15 = StunClient::ResolveHostName(v3, v5, v11, 0, v3);
    CSocketAddress::ToStringBuffer(v3, &v17, 0x64u);
    printf("Resolved %s to %s\n", v5, &v17);
    CSocketAddress::SetPort((int)v3, 20000);
  }
  return v15;
}

//----- (0004A12C) --------------------------------------------------------
int *__fastcall StunClient::NatBehaviorToString(int a1, int a2, int *a3)
{
  int *result; // r0

  switch ( a2 )
  {
    case 0:
      result = sub_D1124(a3, "Unknown Behavior", 0x10u);
      break;
    case 1:
      result = sub_D1124(a3, "Direct Mapping", 0xEu);
      break;
    case 2:
      result = sub_D1124(a3, "Endpoint Independent Mapping", 0x1Cu);
      break;
    case 3:
      result = sub_D1124(a3, "Address Dependent Mapping", 0x19u);
      break;
    case 4:
      result = sub_D1124(a3, "Address and Port Dependent Mapping", 0x22u);
      break;
    default:
      result = sub_D1124(a3, &unk_E00F2, 0);
      break;
  }
  return result;
}

//----- (0004A1C8) --------------------------------------------------------
void __fastcall StunClient::DumpResults(StunClient *this)
{
  StunClient *v1; // r4
  bool v2; // zf
  const char *v3; // r1
  char *v4; // r0
  _DWORD *v5; // r8
  int v6; // r1
  int v7; // r2
  int v8; // r3
  unsigned int *v9; // r3
  signed int v10; // r2
  int v11; // [sp+0h] [bp-98h]
  int v12; // [sp+4h] [bp-94h]
  int v13; // [sp+8h] [bp-90h]
  int v14; // [sp+Ch] [bp-8Ch]
  char *v15; // [sp+14h] [bp-84h]
  char v16; // [sp+18h] [bp-80h]

  v1 = this;
  v2 = *((_BYTE *)this + 148) == 0;
  v15 = (char *)&unk_2FEF48;
  if ( v2 )
    v3 = "fail";
  else
    v3 = "success";
  printf("Binding test: %s\n", v3);
  if ( *((_BYTE *)v1 + 148) )
  {
    CSocketAddress::ToStringBuffer((StunClient *)((char *)v1 + 152), &v16, 0x64u);
    printf("Local address: %s\n", &v16);
    CSocketAddress::ToStringBuffer((StunClient *)((char *)v1 + 180), &v16, 0x64u);
    printf("Mapped address: %s\n", &v16);
    v5 = (_DWORD *)*((_DWORD *)v1 + 91);
    CSocketAddress::GetSockAddr4((CSocketAddress *)&v11, (int *)v1 + 45);
    v6 = v12;
    v7 = v13;
    v8 = v14;
    *v5 = v11;
    v5[1] = v6;
    v5[2] = v7;
    v5[3] = v8;
  }
  if ( *((_BYTE *)v1 + 40) )
  {
    *((_BYTE *)v1 + 296);
    printf("Behavior test: %s\n");
    if ( *((_BYTE *)v1 + 296) )
    {
      StunClient::NatBehaviorToString((int)v1, *((_DWORD *)v1 + 75), (int *)&v15);
      printf("Nat behavior: %s\n", v15);
    }
  }
  v4 = v15 - 12;
  if ( v15 - 12 != (char *)&dword_2FEF3C )
  {
    v9 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v10 = __ldrex(v9);
    while ( __strex(v10 - 1, v9) );
    __dmb(0xFu);
    if ( v10 <= 0 )
      operator delete(v4);
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0004A398) --------------------------------------------------------
int __fastcall StunClient::stop(int result)
{
  *(_BYTE *)(result + 372) = 0;
  return result;
}

//----- (0004A3A4) --------------------------------------------------------
char *__fastcall StunClient::StunConnect(StunClient *this, const char *a2, sockaddr_in *a3, int a4)
{
  int v4; // r8
  StunClient *v5; // r4
  const char *v6; // r7
  CBuffer *v7; // r9
  boost::detail::sp_counted_base *v8; // r0
  signed int v11; // r1
  const void *v12; // r11
  size_t n; // ST10_4
  struct sockaddr *addr; // ST14_4
  signed int addr_len; // r0
  ssize_t v16; // r0
  int v17; // r1
  int v18; // r2
  char *v19; // r0
  int v20; // r0
  int v21; // r0
  char *v22; // r5
  char *v23; // r0
  char *v24; // r3
  char *result; // r0
  boost::detail::sp_counted_base *v26; // r4
  unsigned int *v27; // r3
  unsigned int v28; // r2
  _DWORD *v29; // r0
  int *v30; // r3
  int v31; // r0
  in_addr_t v32; // r1
  int v33; // r2
  int v34; // r3
  signed int v35; // r6
  unsigned int *v36; // r3
  unsigned int v37; // r2
  unsigned int *v42; // r3
  signed int v43; // r2
  unsigned int *v44; // r3
  signed int v45; // r2
  unsigned int *v46; // r3
  signed int v47; // r2
  sockaddr_in *v48; // [sp+2Ch] [bp-2C4h]
  char *v49; // [sp+44h] [bp-2ACh]
  char *v50; // [sp+48h] [bp-2A8h]
  char *v51; // [sp+4Ch] [bp-2A4h]
  CBuffer *v52; // [sp+50h] [bp-2A0h]
  boost::detail::sp_counted_base *v53; // [sp+54h] [bp-29Ch]
  int v54; // [sp+58h] [bp-298h]
  int v55; // [sp+5Ch] [bp-294h]
  char s; // [sp+60h] [bp-290h]
  char v57; // [sp+E0h] [bp-210h]
  char v58; // [sp+FCh] [bp-1F4h]
  char v59; // [sp+118h] [bp-1D8h]
  char v60; // [sp+134h] [bp-1BCh]
  void *v61; // [sp+2B4h] [bp-3Ch]
  int v62; // [sp+2C4h] [bp-2Ch]
  _DWORD v63[1]; // [sp+2C8h] [bp-28h]

  v4 = a4;
  v5 = this;
  v48 = a3;
  v6 = a2;
  v7 = (CBuffer *)operator new(0x10u);
  CBuffer::CBuffer(v7, 0x320u);
  v52 = v7;
  v8 = (boost::detail::sp_counted_base *)operator new(0x10u);
  *((_DWORD *)v8 + 2) = 1;
  *((_DWORD *)v8 + 1) = 1;
  *((_DWORD *)v8 + 3) = v7;
  *(_DWORD *)v8 = off_F0228;
  v53 = v8;
  CSocketAddress::CSocketAddress((int)&v57);
  CSocketAddress::CSocketAddress((int)&v58);
  CSocketAddress::CSocketAddress((int)&v59);
  v54 = 0;
  v55 = 0;
  v49 = (char *)&unk_2FEF48;
  v50 = (char *)&unk_2FEF48;
  if ( (signed int)StunClient::InitialSocket(v5, v6) < 0 )
  {
    puts("Can't start client");
    v22 = 0;
  }
  else
  {
    CStunClientLogic::CStunClientLogic((CStunClientLogic *)&v60);
    v11 = CStunClientLogic::Initialize((int)&v60, v5);
    if ( v11 < 0 )
    {
      printf("Unable to initialize client: (error = x%x)\n", v11);
LABEL_16:
      v22 = 0;
    }
    else
    {
      while ( *((_BYTE *)v5 + 372) )
      {
        CBuffer::SetSize(v52, 0);
        v20 = StunClient::GetMillisecondCounter(v5);
        v21 = CStunClientLogic::GetNextMessage((int)&v60, (int)&v52, (int)&v57, v20);
        if ( v21 >= 0 )
        {
          CSocketAddress::ToString((CSocketAddress *)&v57, (int *)&v49);
          v51 = (char *)&unk_2FEF48;
          CSocketAddress::ToString((CSocketAddress *)&v57, (int *)&v51);
          printf("Sending message to %s\n", v51);
          v12 = *(const void **)v52;
          n = *((_DWORD *)v52 + 1);
          addr = (struct sockaddr *)CSocketAddress::GetSockAddr((CSocketAddress *)&v57);
          addr_len = CSocketAddress::GetSockAddrLength((CSocketAddress *)&v57);
          v16 = sendto(v4, v12, n, 0, addr, addr_len);
          if ( v16 <= 0 )
          {
            v29 = (_DWORD *)_errno(v16, v17, v18);
            printf("ERROR.  sendto failed (errno = %d)\n", *v29);
          }
          v19 = v51 - 12;
          if ( v51 - 12 != (char *)&dword_2FEF3C )
          {
            v42 = (unsigned int *)(v51 - 4);
            __dmb(0xFu);
            do
              v43 = __ldrex(v42);
            while ( __strex(v43 - 1, v42) );
            __dmb(0xFu);
            if ( v43 <= 0 )
              operator delete(v19);
          }
        }
        else
        {
          if ( v21 != -2130640895 )
          {
            if ( v21 != -2130640894 )
            {
              printf("Fatal error (hr == %x)\n", v21);
              goto LABEL_16;
            }
            break;
          }
          puts("Continuing to wait for response...");
        }
        CBuffer::SetSize(v52, 0);
        memset(&s, 0, 0x80u);
        v54 = *((_DWORD *)v5 + 8);
        v63[(v4 >> 5) - 154] = 1 << (v4 & 0x1F);
        v55 = 500000;
        if ( select(v4 + 1, (fd_set *)&s, 0, 0, (struct timeval *)&v54) > 0 )
        {
          v35 = StunClient::recvfromex(
                  v5,
                  v4,
                  *(void **)v52,
                  *((_DWORD *)v52 + 2),
                  64,
                  (CSocketAddress *)&v58,
                  (CSocketAddress *)&v59);
          if ( v35 > 0 )
          {
            CSocketAddress::ToString((CSocketAddress *)&v58, (int *)&v49);
            CSocketAddress::ToString((CSocketAddress *)&v59, (int *)&v50);
            printf("Got response (%d bytes) from %s on interface %s\n", v35, v49, v50);
            CBuffer::SetSize(v52, v35);
            CStunClientLogic::ProcessResponse((int)&v60, (int)&v52, (int)&v58, (int)&v59);
          }
        }
      }
      StunClientResults::Init((StunClient *)((char *)v5 + 148));
      CStunClientLogic::GetResults((int)&v60, (char *)v5 + 148);
      StunClient::DumpResults(v5);
      v30 = (int *)*((_DWORD *)v5 + 91);
      v31 = *v30;
      v32 = v30[1];
      v33 = v30[2];
      v34 = v30[3];
      *(_DWORD *)&v48->sin_family = v31;
      v48->sin_addr.s_addr = v32;
      *(_DWORD *)v48->sin_zero = v33;
      *(_DWORD *)&v48->sin_zero[4] = v34;
      v22 = (char *)*((unsigned __int8 *)v5 + 148);
      if ( *((_BYTE *)v5 + 148) )
        v22 = (char *)*((unsigned __int8 *)v5 + 296);
    }
    if ( v61 )
      operator delete(v61);
  }
  v23 = v50 - 12;
  if ( v50 - 12 != (char *)&dword_2FEF3C )
  {
    v46 = (unsigned int *)(v50 - 4);
    __dmb(0xFu);
    do
      v47 = __ldrex(v46);
    while ( __strex(v47 - 1, v46) );
    __dmb(0xFu);
    if ( v47 <= 0 )
      operator delete(v23);
  }
  v24 = v49;
  result = v49 - 12;
  if ( v49 - 12 != (char *)&dword_2FEF3C )
    goto LABEL_47;
  while ( 1 )
  {
    v26 = v53;
    if ( v53 )
    {
      v27 = (unsigned int *)((char *)v53 + 4);
      __dmb(0xFu);
      do
        v28 = __ldrex(v27);
      while ( __strex(v28 - 1, v27) );
      __dmb(0xFu);
      if ( v28 == 1 )
      {
        (*(void (__fastcall **)(boost::detail::sp_counted_base *))(*(_DWORD *)v26 + 8))(v26);
        v36 = (unsigned int *)((char *)v26 + 8);
        __dmb(0xFu);
        do
          v37 = __ldrex(v36);
        while ( __strex(v37 - 1, v36) );
        __dmb(0xFu);
        if ( v37 == 1 )
          (*(void (__fastcall **)(boost::detail::sp_counted_base *))(*(_DWORD *)v26 + 12))(v26);
      }
    }
    result = v22;
    v24 = (char *)_stack_chk_guard;
    if ( v62 == _stack_chk_guard )
      break;
LABEL_47:
    v44 = (unsigned int *)(v24 - 4);
    __dmb(0xFu);
    do
      v45 = __ldrex(v44);
    while ( __strex(v45 - 1, v44) );
    __dmb(0xFu);
    if ( v45 <= 0 )
      operator delete(result);
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F0228: using guessed type int (*[3])();
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0004AA3C) --------------------------------------------------------
int __fastcall UpnpManager::UpnpManager(int result)
{
  *(_BYTE *)(result + 2978) = 0;
  *(_BYTE *)(result + 2972) = 0;
  *(_DWORD *)(result + 2968) = "UDP";
  *(_BYTE *)(result + 2992) = 0;
  return result;
}

//----- (0004AA60) --------------------------------------------------------
void __fastcall UpnpManager::IntToShort(UpnpManager *this, unsigned int a2, unsigned __int16 *a3)
{
  unsigned int v3; // r4
  unsigned __int16 *v4; // r5
  _DWORD *v5; // r0

  v3 = a2;
  v4 = a3;
  v5 = operator new[](4u);
  *v5 = v3;
  *v4 = v3;
  operator delete(v5);
}

//----- (0004AA90) --------------------------------------------------------
int __fastcall UpnpManager::GetIntPort(UpnpManager *this)
{
  return *((unsigned __int16 *)this + 1493);
}

//----- (0004AA9C) --------------------------------------------------------
signed int __fastcall UpnpManager::Upnp_Discover(UpnpManager *this)
{
  UpnpManager *v1; // r6
  const char *v2; // r0
  signed int v3; // r7
  const char *v4; // r4
  signed int result; // r0
  signed int v6; // r5
  int v7; // [sp+Ch] [bp-1Ch]

  v1 = this;
  v7 = 0;
  v2 = upnpDiscover(0x1F4u, 0, 0, 0, 0, &v7);
  v3 = (signed int)v2;
  if ( v2 )
  {
    v4 = v2;
    puts("List of UPNP devices found on the network : ");
    do
    {
      printf("desc: %s\n st: %s\n\n", *((_DWORD *)v4 + 1), *((_DWORD *)v4 + 2));
      v4 = *(const char **)v4;
    }
    while ( v4 );
  }
  result = UPNP_GetValidIGD(v3, (const char **)v1, (int)v1 + 20, (char *)v1 + 2992, 0x40u);
  if ( result )
  {
    switch ( result )
    {
      case 2:
        v6 = 0;
        printf("Found a (not connected?) IGD : %s\n", *(_DWORD *)v1);
        puts("Trying to continue anyway");
        break;
      case 3:
        v6 = 0;
        printf("UPnP device found. Is it an IGD ? : %s\n", *(_DWORD *)v1);
        puts("Trying to continue anyway");
        break;
      case 1:
        v6 = 1;
        printf("Found valid IGD : %s\n", *(_DWORD *)v1);
        break;
      default:
        v6 = 0;
        printf("Found device (igd ?) : %s\n", *(_DWORD *)v1);
        puts("Trying to continue anyway");
        break;
    }
    printf("Local LAN ip address : %s\n", (char *)v1 + 2992);
    result = v6;
  }
  return result;
}

//----- (0004AC08) --------------------------------------------------------
signed int __fastcall UpnpManager::UpnpListRedirections(UpnpManager *this)
{
  char *v1; // r6
  char *v2; // r5
  unsigned int v3; // r4
  const char *v4; // r0
  signed int v5; // r0
  signed int v6; // ST24_4
  const char *v7; // r0
  int v8; // r2
  int v9; // r12
  bool v10; // zf
  UpnpManager *v12; // [sp+30h] [bp-34h]
  char *v13; // [sp+34h] [bp-30h]
  int v14; // [sp+38h] [bp-2Ch]
  int v15; // [sp+44h] [bp-20h]
  char v16; // [sp+50h] [bp-14h]
  char v17; // [sp+54h] [bp-10h]
  char v18; // [sp+5Ch] [bp-8h]
  int v19; // [sp+64h] [bp+0h]
  char v20; // [sp+6Ch] [bp+8h]
  char v21; // [sp+74h] [bp+10h]
  char v22; // [sp+84h] [bp+20h]
  char v23; // [sp+ACh] [bp+48h]
  char v24; // [sp+ECh] [bp+88h]

  v1 = &v17;
  v2 = &v18;
  v12 = this;
  v13 = (char *)this + 1304;
  v14 = 0;
  v3 = 0;
  v15 = 0;
  while ( 1 )
  {
    snprintf((char *)&v19, 6u, "%d", v3);
    v23 = 0;
    v4 = *(const char **)v12;
    v20 = 0;
    v21 = 0;
    v24 = 0;
    v17 = 0;
    v18 = 0;
    v22 = 0;
    v5 = UPNP_GetGenericPortMappingEntry(v4, (int)v13, (int)&v19, &v17, &v22, &v18, &v16, &v24, &v20, &v23, &v21);
    if ( v5 )
      break;
    printf("%2d %s %5s->%s:%-5s '%s' '%s' %s\n", v3, &v16, &v17, &v22, &v18, &v24, &v23, &v21);
    if ( v15 < atoi(&v18) )
      v15 = atoi(&v18);
    if ( v14 < atoi(&v17) )
      v14 = atoi(&v17);
    ++v3;
  }
  v6 = v5;
  v7 = strupnperror(v5);
  printf("GetGenericPortMappingEntry() returned %d (%s) \n", v6, v7);
  v10 = v3 == 0;
  if ( v3 )
  {
    v9 = v15;
  }
  else
  {
    v3 = 9001;
    v8 = 9001;
    v1 = (_BYTE *)(&stru_2328 + 1);
    v2 = (_BYTE *)(&stru_2328 + 1);
  }
  if ( !v10 )
  {
    v8 = v9 + 1;
    v2 = (char *)(v14 + 1);
  }
  if ( !v10 )
    v3 = v8;
  if ( !v10 )
    v1 = v2;
  sprintf((char *)v12 + 2978, "%d", v8);
  sprintf((char *)v12 + 2972, "%d", v2);
  UpnpManager::IntToShort(v12, (unsigned int)v1, (unsigned __int16 *)v12 + 1492);
  UpnpManager::IntToShort(v12, v3, (unsigned __int16 *)v12 + 1493);
  return 1;
}
// 2: found interdependent unknown calls
// 2328: using guessed type Elf32_Sym;

//----- (0004AE74) --------------------------------------------------------
signed int __fastcall UpnpManager::UpnpSetRedirect(UpnpManager *this, sockaddr_in *a2)
{
  char *v2; // r6
  UpnpManager *v3; // r4
  sockaddr_in *v4; // r11
  signed int v5; // r10
  in_addr_t v6; // r0
  unsigned int v7; // r3
  int v8; // r2
  const char *v9; // r0
  signed int v10; // r0
  signed int v11; // r0
  signed int v12; // r10
  signed int result; // r0
  signed int v14; // ST1C_4
  const char *v15; // r0
  const char *v16; // r0
  char v17; // [sp+24h] [bp-10h]
  unsigned __int8 v18; // [sp+34h] [bp+0h]

  v2 = (char *)this + 1304;
  v3 = this;
  v4 = a2;
  UPNP_GetExternalIPAddress(*(const char **)this, (int)this + 1304, (char *)&v18);
  v5 = v18;
  if ( v18 )
  {
    printf("ExternalIPAddress = %s\n", &v18);
    v6 = inet_addr((const char *)&v18);
    v7 = *((unsigned __int16 *)v3 + 1492);
    v4->sin_addr.s_addr = v6;
    v8 = *((_DWORD *)v3 + 742);
    v9 = *(const char **)v3;
    v4->sin_port = __rev16(v7);
    v10 = UPNP_AddPortMapping(v9, (int)v2, (int)v3 + 2972, (int)v3 + 2978, (int)v3 + 2992, 0, v8, 0, 0);
    if ( v10 )
    {
      v14 = v10;
      v15 = strupnperror(v10);
      printf(
        "AddPortMapping(%s, %s, %s) failed with code %d (%s)\n",
        (char *)v3 + 2972,
        (char *)v3 + 2978,
        (char *)v3 + 2992,
        v14,
        v15);
      result = 0;
    }
    else
    {
      v11 = UPNP_GetSpecificPortMappingEntry(
              *(const char **)v3,
              (int)v2,
              (int)v3 + 2972,
              *((_DWORD *)v3 + 742),
              (char *)v3 + 2992,
              (char *)v3 + 2978,
              0,
              0,
              &v17);
      v12 = v11;
      if ( v11 )
      {
        v16 = strupnperror(v11);
        printf("GetSpecificPortMappintEntry() failed with code %d (%s)\n", v12, v16);
      }
      if ( *((_BYTE *)v3 + 2992) )
      {
        printf("InternalIP: Port = %s:%s\n", (char *)v3 + 2992, (char *)v3 + 2978);
        printf(
          "External %s:%s %s is redirected to internal %s:%s (duration=%s)\n",
          &v18,
          (char *)v3 + 2972,
          *((_DWORD *)v3 + 742),
          (char *)v3 + 2992,
          (char *)v3 + 2978,
          &v17);
      }
      result = 1;
    }
  }
  else
  {
    puts("GetExternalIPAddress failed.");
    result = v5;
  }
  return result;
}

//----- (0004B04C) --------------------------------------------------------
int __fastcall UpnpManager::UpnpRemoveRedirect(int result)
{
  signed int v1; // r0

  if ( *(_BYTE *)(result + 2972) )
  {
    v1 = UPNP_DeletePortMapping(*(const char **)result, result + 1304, result + 2972, *(_DWORD *)(result + 2968), 0);
    result = printf("UPNP_DeletePortMapping() returned : %d\n", v1);
  }
  return result;
}

//----- (0004B0AC) --------------------------------------------------------
UpnpManager *__fastcall UpnpManager::~UpnpManager(UpnpManager *this)
{
  UpnpManager *v1; // r4

  v1 = this;
  UpnpManager::UpnpRemoveRedirect((int)this);
  return v1;
}

//----- (0004B0C0) --------------------------------------------------------
signed int __fastcall UpnpManager::UpnpConnect(UpnpManager *this, sockaddr_in *a2, int *a3)
{
  sockaddr_in *v3; // r8
  int *v4; // r7
  UpnpManager *v5; // r6
  signed int v6; // r5
  int v7; // r0
  in_addr_t v8; // r0
  unsigned int v9; // r3
  int v10; // r0
  struct sockaddr addr; // [sp+4h] [bp-2Ch]

  v3 = a2;
  v4 = a3;
  v5 = this;
  v6 = UpnpManager::Upnp_Discover(this);
  if ( v6 )
  {
    v6 = UpnpManager::UpnpListRedirections(v5);
    if ( v6 )
    {
      v6 = UpnpManager::UpnpSetRedirect(v5, v3);
      if ( v6 )
      {
        if ( *v4 != -1 )
        {
          close(*v4);
          puts("close sock");
        }
        v7 = socket(2, 2, 0);
        *v4 = v7;
        if ( v7 < 0 )
          perror("new socket failed");
        else
          puts("new socket success");
        addr.sa_family = 2;
        v8 = inet_addr((const char *)v5 + 2992);
        v9 = *((unsigned __int16 *)v5 + 1493);
        *(_DWORD *)&addr.sa_data[2] = v8;
        v10 = *v4;
        *(_WORD *)addr.sa_data = __rev16(v9);
        if ( bind(v10, &addr, 0x10u) < 0 )
        {
          v6 = 0;
          perror("bind failed");
        }
        else
        {
          puts("bind success");
        }
      }
      else
      {
        puts("upnp set redirection failed");
      }
    }
    else
    {
      puts("upnp list redirection failed");
    }
  }
  else
  {
    puts("upnp discover failed");
  }
  return v6;
}

//----- (0004B238) --------------------------------------------------------
int __fastcall exitProcess(void *a1)
{
  const char *v1; // r9
  pthread_t v2; // r0
  int v4; // [sp+1Ch] [bp-8h]
  int v5; // [sp+20h] [bp-4h]
  int v6; // [sp+24h] [bp+0h]

  v1 = (const char *)a1;
  v4 = 1;
  memset(&v6, 0, 0x1400u);
  v5 = -1;
  v2 = pthread_self();
  pthread_detach(v2);
  downloadPath(&v4, v1, (char *)&v6, &v5, 16.0, 0, 0, 0);
  return 0;
}

//----- (0004B2C4) --------------------------------------------------------
_DWORD *__fastcall TrackerClient::TrackerClient(_DWORD *result, int a2)
{
  result[11] = a2;
  *result = 0;
  result[5] = -1;
  result[6] = -1;
  result[1] = 0;
  result[10] = 1;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[12] = 1;
  result[13] = 0;
  result[17] = 1;
  result[18] = 0;
  result[16] = 0;
  return result;
}

//----- (0004B2EC) --------------------------------------------------------
TrackerClient *__fastcall TrackerClient::~TrackerClient(TrackerClient *this)
{
  TrackerClient *v1; // r4
  pthread_t v2; // r0
  pthread_t v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0

  v1 = this;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  v2 = *((_DWORD *)this + 13);
  if ( v2 )
    pthread_join(v2, 0);
  v3 = *((_DWORD *)v1 + 14);
  if ( v3 )
    pthread_join(v3, 0);
  if ( *(_DWORD *)v1 )
  {
    free(*(void **)v1);
    *(_DWORD *)v1 = 0;
  }
  v4 = (void *)*((_DWORD *)v1 + 4);
  if ( v4 )
  {
    free(v4);
    *((_DWORD *)v1 + 4) = 0;
  }
  v5 = (void *)*((_DWORD *)v1 + 1);
  if ( v5 )
  {
    free(v5);
    *((_DWORD *)v1 + 1) = 0;
  }
  v6 = (void *)*((_DWORD *)v1 + 2);
  if ( v6 )
  {
    free(v6);
    *((_DWORD *)v1 + 2) = 0;
  }
  v7 = (void *)*((_DWORD *)v1 + 3);
  if ( v7 )
  {
    free(v7);
    *((_DWORD *)v1 + 3) = 0;
  }
  return v1;
}

//----- (0004B348) --------------------------------------------------------
int __fastcall TrackerClient::heartbeat(TrackerClient *this)
{
  *((_DWORD *)this + 12) = 1;
  *((_DWORD *)this + 10) = 1;
  pthread_create((pthread_t *)this + 13, 0, (void *(*)(void *))heartbeatProcess, (void *)this);
  return 0;
}

//----- (0004B368) --------------------------------------------------------
pthread_t *__fastcall TrackerClient::requestPeer(pthread_t *result, pthread_t a2)
{
  if ( result[17] )
  {
    result[16] = a2;
    result[17] = 0;
    result = (pthread_t *)j_pthread_create(result + 14, 0, (void *(*)(void *))requestPeerProcess, result);
  }
  else
  {
    result[18] = 1;
  }
  return result;
}

//----- (0004B38C) --------------------------------------------------------
void __fastcall TrackerClient::freePeerList(int a1, void **a2)
{
  void **v2; // r4
  int v3; // r5
  int v4; // r7
  void *v5; // r0

  v2 = a2;
  if ( a2 )
  {
    v3 = 0;
    v4 = ((_BYTE *)a2[1] - (_BYTE *)*a2) >> 2;
    while ( v3 < v4 )
    {
      v5 = (void *)*((_DWORD *)*v2 + v3);
      if ( v5 )
      {
        operator delete(v5);
        *((_DWORD *)*v2 + v3) = 0;
      }
      ++v3;
    }
    if ( *v2 )
      operator delete(*v2);
    operator delete(v2);
  }
}

//----- (0004B3CC) --------------------------------------------------------
signed int __fastcall TrackerClient::exit(TrackerClient *this)
{
  TrackerClient *v1; // r4
  int v2; // r2
  int v3; // r3
  signed int result; // r0

  v1 = this;
  v2 = *((_DWORD *)this + 4);
  if ( !v2 )
    return -1;
  v3 = *((_DWORD *)this + 5);
  if ( v3 == -1 )
    return -1;
  result = *((_DWORD *)this + 6);
  if ( result != -1 )
  {
    sprintf(
      (char *)&exitUrl,
      "%s?src=%s_%s&msg=exit&id=%s&srcidx=%d&uidx=%d&key=%lld",
      *(_DWORD *)v1,
      *((_DWORD *)v1 + 2),
      v2,
      *((_DWORD *)v1 + 3),
      v3,
      result,
      *((_QWORD *)v1 + 4));
    pthread_create((pthread_t *)v1 + 15, 0, (void *(*)(void *))exitProcess, &exitUrl);
    result = 0;
  }
  return result;
}

//----- (0004B438) --------------------------------------------------------
unsigned __int64 __fastcall TrackerClient::getKey(TrackerClient *this, const char *a2, const char *a3, const char *a4)
{
  const char *v4; // r9
  const char *v5; // r7
  __int64 v6; // r4
  signed __int64 v7; // r0
  unsigned int v8; // r6
  unsigned int v9; // r2
  unsigned __int64 v10; // r10
  __int64 v11; // ST08_8
  signed __int64 v12; // r8
  signed __int64 v13; // ST08_8
  unsigned __int64 v14; // r0
  int v15; // r3
  unsigned __int64 v16; // r0
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // r10
  __int64 v19; // r4
  signed __int64 v20; // r0
  unsigned int v21; // r6
  unsigned int v22; // r2
  unsigned __int64 v23; // r8
  __int64 v24; // ST00_8
  signed __int64 v25; // r10
  signed __int64 v26; // ST00_8
  unsigned __int64 v27; // r0
  int v28; // r3
  unsigned __int64 v29; // r10
  unsigned __int64 v30; // r8
  __int64 v32; // [sp+8h] [bp-118h]
  unsigned __int64 v33; // [sp+10h] [bp-110h]
  __int64 v34; // [sp+18h] [bp-108h]
  char s[100]; // [sp+2Ch] [bp-F4h]
  char v36[100]; // [sp+90h] [bp-90h]

  v6 = (unsigned int)a4;
  v4 = a2;
  v5 = a3;
  memset(s, 0, 0x64u);
  memset(v36, 0, 0x64u);
  sprintf(s, "%s%s", v4, (_DWORD)v6, s);
  sprintf(v36, "%s%s", v5, (_DWORD)v6);
  LODWORD(v6) = 0;
  v34 = strlen(s);
  v33 = 0LL;
  while ( v6 < v34 )
  {
    v7 = (unsigned int)v6 * (unsigned __int64)(unsigned int)v6;
    v8 = (unsigned __int8)s[v6];
    HIDWORD(v7) += 2 * v6 * HIDWORD(v6);
    v9 = (unsigned __int8)s[(unsigned __int64)(v7 % v34)];
    v10 = (unsigned int)(v6 + 1) * (unsigned __int64)(unsigned int)(v6 + 1);
    LODWORD(v11) = v8 * v6;
    HIDWORD(v7) = v6 * (unsigned __int64)(unsigned __int8)s[v6] >> 32;
    v12 = ++v6 + 1;
    HIDWORD(v11) = HIDWORD(v7);
    LODWORD(v7) = v10 * v8;
    HIDWORD(v10) += 2 * v6 * HIDWORD(v6);
    HIDWORD(v7) = v10 * v8 >> 32;
    v13 = v11 + v7 * v9;
    v14 = (unsigned int)v12 * (unsigned __int64)(unsigned int)v12;
    v15 = v14 * ((unsigned __int64)(v6 + 1) >> 32) + v12 * (HIDWORD(v14) + 2 * v12 * HIDWORD(v12));
    v16 = (unsigned int)v14 * (unsigned __int64)(unsigned int)(v6 + 1);
    HIDWORD(v16) += v15;
    v17 = v16 * v8 * v8 * v9 * v9;
    HIDWORD(v16) = HIDWORD(v33);
    v18 = v17 + v13;
    LODWORD(v16) = v33 + v18;
    v33 = v16 + v18;
  }
  v19 = 0LL;
  v32 = strlen(v36);
  while ( v19 < v32 )
  {
    v20 = (unsigned int)v19 * (unsigned __int64)(unsigned int)v19;
    v21 = (unsigned __int8)v36[v19];
    HIDWORD(v20) += 2 * v19 * HIDWORD(v19);
    v22 = (unsigned __int8)v36[(unsigned __int64)(v20 % v32)];
    v23 = (unsigned int)(v19 + 1) * (unsigned __int64)(unsigned int)(v19 + 1);
    LODWORD(v24) = v21 * v19;
    HIDWORD(v20) = v19 * (unsigned __int64)(unsigned __int8)v36[v19] >> 32;
    v25 = ++v19 + 1;
    HIDWORD(v24) = HIDWORD(v20);
    LODWORD(v20) = v23 * v21;
    HIDWORD(v23) += 2 * v19 * HIDWORD(v19);
    HIDWORD(v20) = v23 * v21 >> 32;
    v26 = v24 + v20 * v22;
    v27 = (unsigned int)v25 * (unsigned __int64)(unsigned int)v25;
    v28 = v27 * ((unsigned __int64)(v19 + 1) >> 32) + v25 * (HIDWORD(v27) + 2 * v25 * HIDWORD(v25));
    v29 = (unsigned int)v27 * (unsigned __int64)(unsigned int)(v19 + 1);
    HIDWORD(v29) += v28;
    HIDWORD(v27) = HIDWORD(v33);
    v30 = v29 * v21 * v21 * v22 * v22 + v26;
    LODWORD(v27) = v33 + v30;
    v33 = v27 + v30;
  }
  return v33;
}
// 4B438: using guessed type char s[100];
// 4B438: using guessed type char var_90[100];

//----- (0004B668) --------------------------------------------------------
char *__fastcall std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<sockaddr_in *>(void *src, int a2, char *a3)
{
  int v3; // r1
  char *v4; // r3
  size_t v5; // r4

  v3 = a2 - (_DWORD)src;
  v4 = a3;
  v5 = 4 * (v3 >> 2);
  if ( v3 >> 2 )
    v4 = (char *)memmove(a3, src, v5);
  return &v4[v5];
}

//----- (0004B688) --------------------------------------------------------
void __fastcall std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::_M_insert_aux(signed int *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r9
  _DWORD *v4; // r3
  signed int *v5; // r4
  _DWORD *v6; // r6
  int v7; // r0
  int v8; // r4
  int v9; // r2
  int v10; // r5
  int v11; // r1
  unsigned __int8 v12; // cf
  unsigned int v13; // r1
  signed int v14; // r5
  int v15; // r7
  int v16; // r8
  char *v17; // r0
  char *v18; // r6

  v3 = a3;
  v4 = (_DWORD *)a1[1];
  v5 = a1;
  v6 = a2;
  if ( v4 == (_DWORD *)a1[2] )
  {
    v10 = ((signed int)v4 - *a1) >> 2;
    if ( v10 )
      v11 = ((signed int)v4 - *a1) >> 2;
    else
      v11 = 1;
    v12 = __CFADD__(v11, v10);
    v13 = v11 + v10;
    v14 = 0x3FFFFFFF;
    if ( !v12 && v13 < 0x3FFFFFFF )
      v14 = v13;
    v15 = 4 * v14;
    v16 = ((signed int)v6 - *a1) >> 2;
    if ( v14 )
      v14 = (signed int)operator new(4 * v14);
    if ( v14 + 4 * v16 )
      *(_DWORD *)(v14 + 4 * v16) = *v3;
    v17 = std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<sockaddr_in *>(
            (void *)*v5,
            (int)v6,
            (char *)v14);
    v18 = std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<sockaddr_in *>(v6, v5[1], v17 + 4);
    if ( *v5 )
      operator delete((void *)*v5);
    *v5 = v14;
    v5[1] = (signed int)v18;
    v5[2] = v14 + v15;
  }
  else
  {
    if ( v4 )
      *v4 = *(v4 - 1);
    v7 = a1[1];
    v5[1] = v7 + 4;
    v8 = *a3;
    v9 = (v7 - 4 - (signed int)a2) >> 2;
    if ( v9 )
      memmove((void *)(v7 - 4 * v9), a2, 4 * v9);
    *v6 = v8;
  }
}

//----- (0004B72A) --------------------------------------------------------
void __fastcall std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::push_back(signed int *a1, _DWORD *a2)
{
  _DWORD *v2; // r2
  _DWORD *v3; // r1

  v2 = a2;
  v3 = (_DWORD *)a1[1];
  if ( v3 == (_DWORD *)a1[2] )
  {
    std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::_M_insert_aux(a1, v3, v2);
  }
  else
  {
    if ( v3 )
      *v3 = *v2;
    a1[1] += 4;
  }
}

//----- (0004B74C) --------------------------------------------------------
signed int *__fastcall TrackerClient::join(TrackerClient *this)
{
  TrackerClient *v1; // r4
  char *v2; // r10
  unsigned int *v3; // r9
  unsigned __int8 *v4; // r6
  unsigned __int64 v5; // r0
  int v6; // r2
  int v7; // ST00_4
  int v8; // ST04_4
  int v9; // r3
  signed int *v10; // r5
  signed int *result; // r0
  signed int *v12; // r0
  int v13; // r2
  int i; // r3
  const char *v15; // r0
  char *v16; // r0
  int v17; // ST18_4
  char *v18; // r0
  int v19; // r12
  const void *v20; // r1
  void *v21; // ST1C_4
  char *v22; // r0
  const void *v23; // r1
  size_t v24; // ST18_4
  const char *v25; // ST1C_4
  size_t v26; // r0
  _WORD *v27; // r11
  _WORD *v28; // r2
  const char *v29; // r1
  char *v30; // [sp+18h] [bp-A4h]
  int v31; // [sp+18h] [bp-A4h]
  void *src; // [sp+1Ch] [bp-A0h]
  int v33; // [sp+20h] [bp-9Ch]
  int v34; // [sp+2Ch] [bp-90h]
  int v35; // [sp+30h] [bp-8Ch]
  int v36; // [sp+3Ch] [bp-80h]
  unsigned int v37; // [sp+40h] [bp-7Ch]
  _WORD *v38; // [sp+44h] [bp-78h]
  int v39; // [sp+48h] [bp-74h]
  int v40; // [sp+54h] [bp-68h]
  char v41[20]; // [sp+68h] [bp-54h]
  char s[4]; // [sp+7Ch] [bp-40h]
  char v43[1028]; // [sp+BCh] [bp+0h]
  char v44[1028]; // [sp+4BCh] [bp+400h]
  char v45; // [sp+4C0h] [bp+404h]
  int v46; // [sp+18BCh] [bp+1800h]

  v1 = this;
  v2 = &v45;
  v3 = (unsigned int *)v44;
  v4 = 0;
  memset(v44, 0, 0x1400u);
  v36 = -1;
  memset(v43, 0, 0x400u);
  add_join();
  v5 = TrackerClient::getKey(v1, (const char *)*((_DWORD *)v1 + 3), (const char *)*((_DWORD *)v1 + 2), "tracker");
  v6 = *(_DWORD *)v1;
  v7 = *((_DWORD *)v1 + 4);
  v8 = *((_DWORD *)v1 + 3);
  v9 = *((_DWORD *)v1 + 2);
  *((_QWORD *)v1 + 4) = v5;
  sprintf(v43, "%s?src=%s_%s&msg=join&id=%s&srcidx=-1&uidx=-1&key=%lld", v6, v9, v7, v8, v5);
  if ( downloadPath((volatile int *)v1 + 10, v43, v44, &v36, 16.0, 0, 0, 0) < 0 )
  {
    v10 = 0;
  }
  else
  {
    v10 = (signed int *)*((_DWORD *)v1 + 10);
    if ( v10 )
      goto LABEL_6;
  }
  while ( 1 )
  {
    result = v10;
    if ( v46 == _stack_chk_guard )
      return result;
LABEL_6:
    v12 = (signed int *)operator new(0xCu);
    *v12 = (signed int)v4;
    v10 = v12;
    v12[1] = (signed int)v4;
    v12[2] = (signed int)v4;
    v4 = (unsigned __int8 *)(v2 + 4);
    *((_DWORD *)v1 + 5) = _byteswap_ulong(*v3);
    v13 = *((unsigned __int8 *)v3 + 6);
    *((_DWORD *)v1 + 6) = _byteswap_ulong(v3[1]);
    for ( v36 -= 8; v36 > 2; v36 = v36 - 2 - v33 )
    {
      v33 = v4[1] | (*v4 << 8);
      v34 = (int)(v4 + 2);
      memset(s, 0, 0x40u);
      for ( i = 0; i < v33; ++i )
        s[i] = v4[i + 2];
      v15 = (const char *)base64Decode(s, &v37, 1);
      v4 = (unsigned __int8 *)v15;
      v16 = strchr(v15, 58);
      v3 = (unsigned int *)v16;
      if ( !v16 )
        goto LABEL_26;
      v2 = (char *)&v40;
      v17 = v16 - (char *)v4;
      memcpy(&v40, v4, v16 - (char *)v4);
      *((_BYTE *)&v40 + v17) = 0;
      src = (char *)v3 + 1;
      v18 = strchr((const char *)v3 + 1, 58);
      if ( !v18 )
        goto LABEL_26;
      v19 = v18 - (char *)v3;
      v3 = (unsigned int *)&v39;
      v20 = src;
      v30 = v18;
      v21 = (void *)(v19 - 1);
      memcpy(&v39, v20, v19 - 1);
      *((_BYTE *)&v39 + (_DWORD)v21) = 0;
      v35 = atoi((const char *)&v39);
      v22 = strchr(v30 + 1, 58);
      if ( !v22 )
      {
LABEL_26:
        if ( v4 )
          operator delete[](v4);
        break;
      }
      v23 = v30 + 1;
      v24 = v22 - v30 - 1;
      v25 = v22;
      memcpy(v41, v23, v24);
      v41[v24] = 0;
      v26 = strlen(++v25);
      memcpy(&v39, v25, v26);
      *((_BYTE *)&v39 + strlen(v25)) = 0;
      v3 = (unsigned int *)&v38;
      v31 = atoi((const char *)&v39);
      v38 = operator new(0x10u);
      v27 = v38;
      if ( !strcmp((const char *)v1 + 76, (const char *)&v40) )
      {
        *v27 = 2;
        v38[1] = __rev16(v31);
        v28 = v38;
        v29 = v41;
      }
      else
      {
        *v27 = 2;
        v38[1] = __rev16(v35);
        v28 = v38;
        v29 = (const char *)&v40;
      }
      inet_pton(2, v29, v28 + 2);
      std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::push_back(v10, &v38);
      if ( v4 )
        operator delete[](v4);
      v4 = (unsigned __int8 *)(v34 + v33);
    }
    add_joinSuc();
    if ( (unsigned int)(v10[1] - *v10) >> 2 )
    {
      add_getPeer();
      addCurrentPeerNum((v10[1] - *v10) >> 2);
    }
  }
}
// 4B74C: using guessed type char var_185C[20];
// 4B74C: using guessed type char s[4];

//----- (0004BA48) --------------------------------------------------------
signed int __fastcall TrackerClient::start(int a1, char *a2, const char *a3, signed int *a4, int a5, const char *a6, void (__fastcall *a7)(_DWORD, signed int *))
{
  signed int *v7; // r5
  int v8; // r4
  const char *v9; // r10
  char *v10; // r0
  char *v11; // r0
  signed int result; // r0
  char *v13; // r11
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  int v17; // r5
  unsigned int v18; // r0
  char *v19; // r5
  char *s; // [sp+4h] [bp-10h]
  int v21; // [sp+14h] [bp+0h]
  char v22; // [sp+78h] [bp+64h]
  int v23; // [sp+DCh] [bp+C8h]

  v7 = a4;
  s = a2;
  v8 = a1;
  v9 = a3;
  memset(&v21, 0, 0x64u);
  memset(&v22, 0, 0x64u);
  if ( v9 )
  {
    if ( a5 )
    {
      if ( v7 )
      {
        v10 = inet_ntoa(*(struct in_addr *)(a5 + 4));
        if ( strcmp(v10, "0.0.0.0") )
          goto LABEL_8;
        v11 = inet_ntoa((struct in_addr)v7[1]);
        if ( strcmp(v11, "0.0.0.0") )
          goto LABEL_8;
      }
    }
  }
LABEL_6:
  result = -1;
  while ( v23 != _stack_chk_guard )
  {
LABEL_8:
    v13 = inet_ntoa((struct in_addr)v7[1]);
    strcpy((char *)(v8 + 76), v13);
    *(_BYTE *)(strlen(v13) + v8 + 76) = 0;
    *(_DWORD *)(v8 + 16) = strdup(v9);
    *(_DWORD *)v8 = strdup(s);
    *(_DWORD *)(v8 + 8) = strdup(a6);
    if ( (unsigned __int16)__rev16(*(unsigned __int16 *)(a5 + 2)) < 0x400u )
      add_selfInvalid();
    v14 = inet_ntoa((struct in_addr)v7[1]);
    sprintf((char *)&v21, "%s:%d:", v14, (unsigned __int16)__rev16(*((unsigned __int16 *)v7 + 1)));
    v15 = inet_ntoa(*(struct in_addr *)(a5 + 4));
    sprintf(&v22, "%s:%d", v15, (unsigned __int16)__rev16(*(unsigned __int16 *)(a5 + 2)));
    strcat((char *)&v21, &v22);
    v16 = strdup((const char *)&v21);
    *(_DWORD *)(v8 + 4) = v16;
    v17 = (int)v16;
    v18 = strlen(v16);
    v19 = (char *)base64Encode(v17, v18);
    *(_DWORD *)(v8 + 12) = strdup(v19);
    if ( v19 )
      operator delete[](v19);
    v7 = TrackerClient::join((TrackerClient *)v8);
    if ( a7 )
      a7(*(_DWORD *)(v8 + 4), v7);
    if ( !v7 )
      goto LABEL_6;
    TrackerClient::freePeerList(v8, (void **)v7);
    result = 0;
  }
  return result;
}

//----- (0004BBAC) --------------------------------------------------------
signed int __fastcall TrackerClient::heartbeatOnce(TrackerClient *this)
{
  TrackerClient *v1; // r4
  int v2; // r2
  signed int result; // r0
  int v4; // r3
  signed int v5; // r0
  unsigned int v6; // r11
  int v7; // ST1C_4
  int v8; // r6
  int *v9; // r0
  int v10; // r1
  int v11; // r2
  float v12; // s14
  unsigned int v13; // [sp+20h] [bp-520h]
  int v14; // [sp+2Ch] [bp-514h]
  void *v15; // [sp+30h] [bp-510h]
  int v16; // [sp+34h] [bp-50Ch]
  int v17; // [sp+38h] [bp-508h]
  const char *v18[28]; // [sp+4Ch] [bp-4F4h]
  char v19[128]; // [sp+BCh] [bp-484h]
  char s; // [sp+13Ch] [bp-404h]
  unsigned int v21; // [sp+53Ch] [bp-4h]
  unsigned int v22; // [sp+540h] [bp+0h]
  unsigned __int8 v23; // [sp+544h] [bp+4h]
  unsigned __int8 v24; // [sp+545h] [bp+5h]
  __int16 v25; // [sp+546h] [bp+6h]
  int v26; // [sp+193Ch] [bp+13FCh]

  v1 = this;
  memset(&s, 0, 0x400u);
  memset(&v21, 0, 0x1400u);
  v2 = *((_DWORD *)v1 + 4);
  result = -1;
  v14 = -1;
  if ( !v2 )
    goto LABEL_8;
  v4 = *((_DWORD *)v1 + 5);
  if ( v4 == -1 )
  {
    result = *((_DWORD *)v1 + 5);
    goto LABEL_8;
  }
  result = *((_DWORD *)v1 + 6);
  if ( result == -1 )
    goto LABEL_8;
  sprintf(
    &s,
    "%s?src=%s_%s&msg=htbt&id=%s&srcidx=%d&uidx=%d&mbr=500&key=%lld",
    *(_DWORD *)v1,
    *((_DWORD *)v1 + 2),
    v2,
    *((_DWORD *)v1 + 3),
    v4,
    result,
    *((_QWORD *)v1 + 4));
  v5 = downloadPath((volatile int *)v1 + 12, &s, (char *)&v21, &v14, 16.0, 0, 0, 0);
  if ( *((_DWORD *)v1 + 10) && v5 >= 0 )
  {
    memset(v19, 0, 0x80u);
    Json::Reader::Reader((Json::Reader *)v18);
    Json::Value::Value((int)&v17, 0);
    v15 = &unk_2FEF48;
    v6 = _byteswap_ulong(v21);
    v13 = _byteswap_ulong(v22);
    if ( (v24 | (v23 << 8)) < v14 - 10 )
    {
      v7 = v24 | (v23 << 8);
      strncpy(v19, (const char *)&v25, v7);
      v19[v7] = 0;
      sub_C1C58((void **)&v16, v19);
      v8 = Json::Reader::parse(v18, (int)&v16, (Json::Value *)&v17, 1);
      sub_C0AD8(&v16);
      if ( v8 )
      {
        v9 = Json::Value::operator[]((Json::Value *)&v17, "r_ij_r");
        v12 = COERCE_DOUBLE(Json::Value::asDouble((Json::Value *)v9, v10, v11));
        CDN_RATION = (signed int)(float)(v12 * 100.0);
      }
    }
    if ( v6 == -1 || v13 == -1 )
      TrackerClient::join(v1);
    sub_C0AD8(&v15);
    Json::Value::~Value((Json::Value *)&v17);
    Json::Reader::~Reader((Json::Reader *)v18);
    goto LABEL_10;
  }
  do
  {
    TrackerClient::join(v1);
LABEL_10:
    result = 0;
LABEL_8:
    ;
  }
  while ( v26 != _stack_chk_guard );
  return result;
}
// F30EC: using guessed type int CDN_RATION;
// 4BBAC: using guessed type char var_1888[128];

//----- (0004BDD4) --------------------------------------------------------
int __fastcall heartbeatProcess(TrackerClient *this)
{
  TrackerClient *v1; // r4
  signed int v2; // r5

  v1 = this;
LABEL_2:
  if ( *((_DWORD *)v1 + 10) )
  {
    v2 = 160;
    TrackerClient::heartbeatOnce(v1);
    while ( *((_DWORD *)v1 + 10) && *((_DWORD *)v1 + 12) )
    {
      usleep((__useconds_t)"");
      if ( !--v2 )
        goto LABEL_2;
    }
  }
  return 0;
}

//----- (0004BE00) --------------------------------------------------------
void *__fastcall TrackerClient::requestPeerOnce(int a1, void (__fastcall *a2)(_DWORD, signed int *))
{
  int v2; // r4
  int v3; // r1
  int v4; // r2
  int v5; // r3
  signed int *v6; // r6
  unsigned int *v7; // r5
  signed int *v8; // r0
  signed int i; // r3
  const char *v10; // r0
  char *v11; // r5
  char *v12; // r0
  char *v13; // r9
  int v14; // ST1C_4
  char *v15; // r0
  char *src; // ST20_4
  char *v17; // r0
  const void *v18; // r1
  size_t v19; // ST1C_4
  const char *v20; // ST20_4
  size_t v21; // r0
  _WORD *v22; // r11
  char *v23; // r2
  const char *v24; // r1
  char *v26; // [sp+1Ch] [bp-18D4h]
  int v27; // [sp+1Ch] [bp-18D4h]
  signed int v28; // [sp+24h] [bp-18CCh]
  void (__fastcall *v29)(_DWORD, signed int *); // [sp+2Ch] [bp-18C4h]
  int v30; // [sp+34h] [bp-18BCh]
  int v31; // [sp+38h] [bp-18B8h]
  int v32; // [sp+44h] [bp-18ACh]
  unsigned int v33; // [sp+48h] [bp-18A8h]
  _WORD *v34; // [sp+4Ch] [bp-18A4h]
  int v35; // [sp+50h] [bp-18A0h]
  int v36; // [sp+5Ch] [bp-1894h]
  char v37[20]; // [sp+70h] [bp-1880h]
  char v38[4]; // [sp+84h] [bp-186Ch]
  char s; // [sp+C4h] [bp-182Ch]
  unsigned int v40; // [sp+4C4h] [bp-142Ch]
  unsigned int v41; // [sp+4C8h] [bp-1428h]
  int v42; // [sp+4CCh] [bp-1424h]

  v2 = a1;
  v29 = a2;
  memset(&s, 0, 0x400u);
  memset(&v40, 0, 0x1400u);
  v3 = *(_DWORD *)(v2 + 16);
  v32 = -1;
  if ( v3 )
  {
    v4 = *(_DWORD *)(v2 + 20);
    if ( v4 != -1 )
    {
      v5 = *(_DWORD *)(v2 + 24);
      if ( v5 != -1 )
      {
        sprintf(
          &s,
          "%s?src=%s_%s&msg=rqstpeer&id=%s&srcidx=%d&uidx=%d&key=%lld",
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 8),
          v3,
          *(_DWORD *)(v2 + 12),
          v4,
          v5,
          *(_QWORD *)(v2 + 32));
        if ( downloadPath((volatile int *)(v2 + 40), &s, (char *)&v40, &v32, 16.0, 0, 0, 0) < 0 )
        {
          v6 = 0;
        }
        else
        {
          v6 = *(signed int **)(v2 + 40);
          if ( v6 )
          {
            v7 = (unsigned int *)&v42;
            v8 = (signed int *)operator new(0xCu);
            *v8 = 0;
            v6 = v8;
            v8[1] = 0;
            v8[2] = 0;
            *(_DWORD *)(v2 + 20) = _byteswap_ulong(v40);
            *(_DWORD *)(v2 + 24) = _byteswap_ulong(v41);
            for ( v32 -= 8; v32 > 4; v32 = v32 - 4 - v28 )
            {
              v28 = _byteswap_ulong(*v7);
              v30 = (int)(v7 + 1);
              memset(v38, 0, 0x40u);
              for ( i = 0; i < v28; ++i )
                v38[i] = *((_BYTE *)v7 + i + 4);
              v10 = (const char *)base64Decode(v38, &v33, 1);
              v11 = (char *)v10;
              v12 = strchr(v10, 58);
              v13 = v12;
              if ( !v12 )
                goto LABEL_30;
              v14 = v12 - v11;
              memcpy(&v36, v11, v12 - v11);
              *((_BYTE *)&v36 + v14) = 0;
              v15 = strchr(v13 + 1, 58);
              if ( !v15
                || (v26 = v15,
                    src = (char *)(v15 - v13 - 1),
                    memcpy(&v35, v13 + 1, (size_t)src),
                    *((_BYTE *)&v35 + (_DWORD)src) = 0,
                    v31 = atoi((const char *)&v35),
                    (v17 = strchr(v26 + 1, 58)) == 0) )
              {
LABEL_30:
                if ( v11 )
                  operator delete[](v11);
                break;
              }
              v18 = v26 + 1;
              v19 = v17 - v26 - 1;
              v20 = v17;
              memcpy(v37, v18, v19);
              v37[v19] = 0;
              v21 = strlen(++v20);
              memcpy(&v35, v20, v21);
              *((_BYTE *)&v35 + strlen(v20)) = 0;
              v27 = atoi((const char *)&v35);
              v34 = operator new(0x10u);
              v22 = v34;
              if ( !strcmp((const char *)(v2 + 76), (const char *)&v36) )
              {
                *v22 = 2;
                v34[1] = __rev16(v27);
                v23 = (char *)v34;
                v24 = v37;
              }
              else
              {
                *v22 = 2;
                v34[1] = __rev16(v31);
                v23 = (char *)v34;
                v24 = (const char *)&v36;
              }
              inet_pton(2, v24, v23 + 4);
              std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::push_back(v6, &v34);
              if ( v11 )
                operator delete[](v11);
              v7 = (unsigned int *)(v30 + v28);
            }
            if ( v29 )
              v29(*(_DWORD *)(v2 + 4), v6);
          }
        }
        TrackerClient::freePeerList(v2, (void **)v6);
      }
    }
  }
  return &_stack_chk_guard;
}
// 4BE00: using guessed type char var_1880[20];
// 4BE00: using guessed type char var_186C[4];

//----- (0004C100) --------------------------------------------------------
int *__fastcall TrackerClient::requestPeerOnce(TrackerClient *this)
{
  TrackerClient *v1; // r4
  int v2; // r1
  int v3; // r2
  int v4; // r3
  signed int *v5; // r6
  signed int *v6; // r0
  int v7; // r2
  unsigned int *v8; // r5
  signed int i; // r3
  const char *v10; // r0
  char *v11; // r5
  char *v12; // r0
  char *v13; // r9
  int v14; // ST18_4
  char *v15; // r0
  char *src; // ST1C_4
  char *v17; // r0
  const void *v18; // r1
  size_t v19; // ST18_4
  const char *v20; // ST1C_4
  size_t v21; // r0
  _WORD *v22; // r11
  char *v23; // r2
  const char *v24; // r1
  void (__fastcall *v25)(_DWORD, signed int *, int); // r3
  char *v27; // [sp+18h] [bp-18D0h]
  int v28; // [sp+18h] [bp-18D0h]
  signed int v29; // [sp+20h] [bp-18C8h]
  int v30; // [sp+2Ch] [bp-18BCh]
  int v31; // [sp+30h] [bp-18B8h]
  int v32; // [sp+3Ch] [bp-18ACh]
  unsigned int v33; // [sp+40h] [bp-18A8h]
  _WORD *v34; // [sp+44h] [bp-18A4h]
  int v35; // [sp+48h] [bp-18A0h]
  int v36; // [sp+54h] [bp-1894h]
  char v37[20]; // [sp+68h] [bp-1880h]
  char v38[4]; // [sp+7Ch] [bp-186Ch]
  char s; // [sp+BCh] [bp-182Ch]
  unsigned int v40; // [sp+4BCh] [bp-142Ch]
  unsigned int v41; // [sp+4C0h] [bp-1428h]
  int v42; // [sp+4C4h] [bp-1424h]
  int v43; // [sp+18BCh] [bp-2Ch]

  v1 = this;
  memset(&s, 0, 0x400u);
  memset(&v40, 0, 0x1400u);
  v2 = *((_DWORD *)v1 + 4);
  v32 = -1;
  if ( v2 )
  {
    v3 = *((_DWORD *)v1 + 5);
    if ( v3 != -1 )
    {
      v4 = *((_DWORD *)v1 + 6);
      if ( v4 != -1 )
      {
        sprintf(
          &s,
          "%s?src=%s_%s&msg=rqstpeer&id=%s&srcidx=%d&uidx=%d&key=%lld",
          *(_DWORD *)v1,
          *((_DWORD *)v1 + 2),
          v2,
          *((_DWORD *)v1 + 3),
          v3,
          v4,
          *((_QWORD *)v1 + 4));
        if ( downloadPath((volatile int *)v1 + 10, &s, (char *)&v40, &v32, 16.0, 0, 0, 0) < 0 )
        {
          v5 = 0;
        }
        else
        {
          v5 = (signed int *)*((_DWORD *)v1 + 10);
          if ( v5 )
          {
            v6 = (signed int *)operator new(0xCu);
            *v6 = 0;
            v5 = v6;
            v6[1] = 0;
            v6[2] = 0;
            *((_DWORD *)v1 + 5) = _byteswap_ulong(v40);
            v7 = BYTE2(v41);
            v8 = (unsigned int *)&v42;
            *((_DWORD *)v1 + 6) = _byteswap_ulong(v41);
            for ( v32 -= 8; v32 > 4; v32 = v32 - 4 - v29 )
            {
              v29 = _byteswap_ulong(*v8);
              v30 = (int)(v8 + 1);
              memset(v38, 0, 0x40u);
              for ( i = 0; i < v29; ++i )
                v38[i] = *((_BYTE *)v8 + i + 4);
              v10 = (const char *)base64Decode(v38, &v33, 1);
              v11 = (char *)v10;
              v12 = strchr(v10, 58);
              v13 = v12;
              if ( !v12 )
                goto LABEL_30;
              v14 = v12 - v11;
              memcpy(&v36, v11, v12 - v11);
              *((_BYTE *)&v36 + v14) = 0;
              v15 = strchr(v13 + 1, 58);
              v7 = (int)(v13 + 1);
              if ( !v15
                || (v27 = v15,
                    src = (char *)(v15 - v13 - 1),
                    memcpy(&v35, v13 + 1, (size_t)src),
                    *((_BYTE *)&v35 + (_DWORD)src) = 0,
                    v31 = atoi((const char *)&v35),
                    v17 = strchr(v27 + 1, 58),
                    v7 = (int)(v27 + 1),
                    !v17) )
              {
LABEL_30:
                if ( v11 )
                  operator delete[](v11);
                break;
              }
              v18 = v27 + 1;
              v19 = v17 - v27 - 1;
              v20 = v17;
              memcpy(v37, v18, v19);
              v37[v19] = 0;
              v21 = strlen(++v20);
              memcpy(&v35, v20, v21);
              *((_BYTE *)&v35 + strlen(v20)) = 0;
              v28 = atoi((const char *)&v35);
              v34 = operator new(0x10u);
              v22 = v34;
              if ( !strcmp((const char *)v1 + 76, (const char *)&v36) )
              {
                *v22 = 2;
                v34[1] = __rev16(v28);
                v23 = (char *)v34;
                v24 = v37;
              }
              else
              {
                *v22 = 2;
                v34[1] = __rev16(v31);
                v23 = (char *)v34;
                v24 = (const char *)&v36;
              }
              inet_pton(2, v24, v23 + 4);
              std::vector<sockaddr_in *,std::allocator<sockaddr_in *>>::push_back(v5, &v34);
              if ( v11 )
                operator delete[](v11);
              v8 = (unsigned int *)(v30 + v29);
            }
            v25 = (void (__fastcall *)(_DWORD, signed int *, int))*((_DWORD *)v1 + 16);
            if ( v25 )
              v25(*((_DWORD *)v1 + 1), v5, v7);
          }
        }
        TrackerClient::freePeerList((int)v1, (void **)v5);
      }
    }
  }
  return &v43;
}
// 4C100: using guessed type char var_1880[20];
// 4C100: using guessed type char var_186C[4];

//----- (0004C3F0) --------------------------------------------------------
int __fastcall requestPeerProcess(TrackerClient *this)
{
  TrackerClient *i; // r4
  signed int v2; // r5

  for ( i = this; *((_DWORD *)i + 10); TrackerClient::requestPeerOnce(i) )
  {
    v2 = 160;
    do
    {
      if ( *((_DWORD *)i + 18) )
      {
        *((_DWORD *)i + 18) = 0;
        TrackerClient::requestPeerOnce(i);
      }
      else
      {
        if ( !*((_DWORD *)i + 10) || !*((_DWORD *)i + 12) )
          return 0;
        usleep((__useconds_t)"");
      }
      --v2;
    }
    while ( v2 );
  }
  return 0;
}

//----- (0004C42C) --------------------------------------------------------
int __fastcall strdupSize(int result)
{
  size_t v1; // r0

  if ( result )
  {
    v1 = strlen((const char *)result);
    result = (int)operator new[](v1 + 1);
  }
  return result;
}

//----- (0004C440) --------------------------------------------------------
void *__fastcall base64Decode(const char *a1, unsigned int *a2, int a3)
{
  int v3; // r9
  const char *v4; // r8
  unsigned int *v5; // r7
  int v6; // r3
  int v7; // r3
  int v8; // r3
  char *v9; // r2
  char v10; // r1
  signed int v11; // r4
  signed int v12; // r6
  char *v13; // r4
  char *v14; // r5
  signed int v15; // r0
  int v16; // r3
  int v17; // r3
  char v18; // r2
  char v19; // r3
  void *v20; // r5
  unsigned int *v22; // [sp+4h] [bp-24h]

  v22 = a2;
  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = (unsigned __int8)byte_F5F51[0];
  if ( !byte_F5F51[0] )
  {
    do
      *((_BYTE *)&unk_F5F52 + v6++) = -128;
    while ( v6 != 256 );
    v7 = 0;
    do
    {
      *((_BYTE *)&unk_F5F52 + v7 + 65) = v7;
      ++v7;
    }
    while ( v7 != 26 );
    v8 = 0;
    do
    {
      v9 = (char *)&unk_F5F52 + v8;
      v10 = v8++ + 26;
      v9[97] = v10;
    }
    while ( v8 != 26 );
    v11 = 48;
    do
    {
      *((_BYTE *)&unk_F5F52 + v11) = v11 + 4;
      ++v11;
    }
    while ( v11 != 58 );
    byte_F5F7D = 62;
    byte_F5F81 = 63;
    byte_F5F8F = 0;
    byte_F5F51[0] = 1;
  }
  v12 = 0;
  v13 = (char *)strdupSize((int)a1);
  v14 = v13;
  v15 = strlen(v4) - 3;
  while ( 1 )
  {
    v16 = v14 - v13;
    if ( v12 >= v15 )
      break;
    v17 = 0;
    do
    {
      if ( byte_F5F51[(unsigned __int8)v4[v12 + v17] + 1] & 0x80 )
        *((_BYTE *)&v22 + v17) = 0;
      else
        *((_BYTE *)&v22 + v17) = byte_F5F51[(unsigned __int8)v4[v12 + v17] + 1];
      ++v17;
    }
    while ( v17 != 4 );
    v12 += 4;
    v18 = BYTE1(v22);
    v14 += 3;
    *(v14 - 3) = 4 * (_BYTE)v22 | (BYTE1(v22) >> 4);
    v19 = BYTE2(v22);
    *(v14 - 2) = 16 * v18 | (BYTE2(v22) >> 2);
    *(v14 - 1) = HIBYTE(v22) | (v19 << 6);
  }
  if ( v3 )
  {
    while ( v16 && !v13[v16 - 1] )
      --v16;
  }
  *v5 = v16;
  v20 = operator new[](v16 + 1);
  memmove(v20, v13, *v5);
  *((_BYTE *)v20 + *v5) = 0;
  if ( v13 )
    operator delete[](v13);
  return v20;
}
// 3C: using guessed type int *off_3C[4];
// F5F7D: using guessed type char byte_F5F7D;
// F5F81: using guessed type char byte_F5F81;
// F5F8F: using guessed type char byte_F5F8F;

//----- (0004C578) --------------------------------------------------------
int __fastcall base64Encode(int result, unsigned int a2)
{
  unsigned int v2; // r8
  int v3; // r4
  int v4; // r7
  unsigned int v5; // r5
  unsigned int v6; // r9
  _BOOL4 v7; // r11
  unsigned int v8; // r10
  int v9; // r3
  int i; // r2
  char v11; // r1
  _BYTE *v12; // r3
  int v13; // r5
  char v14; // r2

  v2 = a2;
  v3 = result;
  if ( result )
  {
    v4 = 0;
    v5 = 3 * (a2 / 3);
    v6 = a2 / 3;
    v7 = a2 > 3 * (a2 / 3);
    v8 = v7 + a2 / 3;
    result = (int)operator new[](4 * (v7 + a2 / 3) + 1);
    v9 = v3;
    for ( i = result; ; *(_BYTE *)(i - 1) = aAbcdefghijklmn[*(_BYTE *)(v9 - 1) & 0x3F] )
    {
      v9 += 3;
      i += 4;
      if ( v4 == v6 )
        break;
      ++v4;
      *(_BYTE *)(i - 4) = aAbcdefghijklmn[(unsigned int)*(unsigned __int8 *)(v9 - 3) >> 2];
      *(_BYTE *)(i - 3) = aAbcdefghijklmn[((signed int)*(unsigned __int8 *)(v9 - 2) >> 4) | 16
                                                                                          * (*(_BYTE *)(v9 - 3) & 3)];
      *(_BYTE *)(i - 2) = aAbcdefghijklmn[((unsigned __int8)(4 * *(_BYTE *)(v9 - 2)) | (unsigned __int8)(*(_BYTE *)(v9 - 1) >> 6)) & 0x3F];
    }
    if ( v7 )
    {
      *(_BYTE *)(result + 4 * v4) = aAbcdefghijklmn[(unsigned int)*(unsigned __int8 *)(v3 + v5) >> 2];
      v11 = *(_BYTE *)(v3 + v5);
      v12 = (_BYTE *)(result + 4 * v4);
      if ( v2 == v5 + 2 )
      {
        v13 = v5 + 1;
        v12[1] = aAbcdefghijklmn[16 * (v11 & 3) | ((unsigned int)*(unsigned __int8 *)(v3 + v13) >> 4)];
        v14 = aAbcdefghijklmn[4 * *(_BYTE *)(v3 + v13) & 0x3F];
      }
      else
      {
        v12[1] = aAbcdefghijklmn[16 * (v11 & 3)];
        v14 = 61;
      }
      v12[2] = v14;
      v12[3] = 61;
    }
    *(_BYTE *)(result + 4 * v8) = 0;
  }
  return result;
}

//----- (0004C688) --------------------------------------------------------
__int64 getTime(void)
{
  signed int v0; // r4
  double v1; // d7
  double v2; // d6
  signed int v4; // [sp+0h] [bp-30h]
  signed int v5; // [sp+4h] [bp-2Ch]
  struct timeval tv; // [sp+8h] [bp-28h]

  v0 = 10;
  while ( 1 )
  {
    gettimeofday((struct timeval *)&v4, 0);
    gettimeofday(&tv, 0);
    v1 = (double)tv.tv_sec + (double)tv.tv_usec * 0.000001;
    v2 = v1 - ((double)v4 + (double)v5 * 0.000001);
    if ( v2 >= 0.0 && v2 <= 1.0 )
      break;
    if ( !--v0 )
    {
      gettimeofday((struct timeval *)&v4, 0);
      v1 = (double)v4 + (double)v5 * 0.000001;
      return *(_QWORD *)&v1;
    }
  }
  return *(_QWORD *)&v1;
}

//----- (0004C728) --------------------------------------------------------
void __fastcall ffFree(void **a1)
{
  void **v1; // r4
  void *v2; // r0

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( v2 )
    {
      free(v2);
      *v1 = 0;
    }
  }
}

//----- (0004C73C) --------------------------------------------------------
int __fastcall printfTimeWith(char *a1)
{
  getTime();
  return j_printf("%s time:%f\n");
}

//----- (0004C75C) --------------------------------------------------------
void *__fastcall cumalloc(size_t size)
{
  size_t v1; // r6
  signed int v2; // r4
  void *v3; // r5

  v1 = size;
  v2 = 3;
  do
  {
    v3 = malloc(v1);
    if ( v3 )
      break;
    usleep(0x2710u);
    --v2;
  }
  while ( v2 );
  return v3;
}

//----- (0004C77C) --------------------------------------------------------
void *__fastcall cucalloc(size_t nmemb, size_t size)
{
  size_t v2; // r6
  size_t v3; // r7
  signed int v4; // r4
  void *v5; // r5

  v2 = nmemb;
  v3 = size;
  v4 = 3;
  do
  {
    v5 = calloc(v2, v3);
    if ( v5 )
      break;
    usleep(0x2710u);
    --v4;
  }
  while ( v4 );
  return v5;
}

//----- (0004C7A0) --------------------------------------------------------
void *__fastcall LinkManager::initElement(LinkManager *this)
{
  return j_calloc(0x14u, 1u);
}

//----- (0004C7A8) --------------------------------------------------------
_DWORD *__fastcall LinkManager::initElement(LinkManager *a1)
{
  LinkManager *v1; // r4
  _DWORD *result; // r0

  v1 = a1;
  result = LinkManager::initElement(a1);
  *result = *(_DWORD *)v1;
  result[3] = *((_DWORD *)v1 + 3);
  result[1] = *((_DWORD *)v1 + 1);
  result[2] = *((_DWORD *)v1 + 2);
  result[4] = *((_DWORD *)v1 + 4);
  return result;
}

//----- (0004C7C6) --------------------------------------------------------
void *__fastcall LinkManager::bzeroElement(void *result)
{
  if ( result )
    result = j_memset(result, 0, 0x14u);
  return result;
}

//----- (0004C7D2) --------------------------------------------------------
void __fastcall LinkManager::destroyElement(void *a1, int a2, int a3)
{
  void *v3; // [sp+4h] [bp-Ch]
  int v4; // [sp+8h] [bp-8h]

  v4 = a3;
  v3 = a1;
  if ( a1 )
    ffFree(&v3);
}

//----- (0004C7E4) --------------------------------------------------------
void __fastcall LinkManager::deepDestroyElement(void **a1)
{
  void **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  if ( a1 )
  {
    ffFree(a1 + 3);
    LinkManager::destroyElement(v1, v2, v3);
  }
}

//----- (0004C7FC) --------------------------------------------------------
int __fastcall LinkManager::getTotalLength(LinkManager *this)
{
  int v1; // r3
  int result; // r0
  int v3; // r3
  int v4; // r2

  v1 = *(_DWORD *)this;
  result = 0;
  v3 = *(_DWORD *)(v1 + 16);
  while ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 8);
    v3 = *(_DWORD *)(v3 + 16);
    result += v4;
  }
  return result;
}

//----- (0004C80E) --------------------------------------------------------
int __fastcall LinkManager::getLength(int a1, int a2)
{
  int v2; // r3

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 + 16);
    a2 = 0;
    while ( v2 )
    {
      ++a2;
      v2 = *(_DWORD *)(v2 + 16);
    }
  }
  return a2;
}

//----- (0004C820) --------------------------------------------------------
int __fastcall LinkManager::getLength(LinkManager *this)
{
  return LinkManager::getLength((int)this, *(_DWORD *)this);
}

//----- (0004C826) --------------------------------------------------------
signed int __fastcall LinkManager::insertElement(int a1, int a2, int a3)
{
  int v3; // r3
  signed int result; // r0

  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  v3 = *(_DWORD *)(a2 + 16);
  result = 1;
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a3 + 16) = v3;
  return result;
}

//----- (0004C83C) --------------------------------------------------------
signed int __fastcall LinkManager::deleteElement(int a1, int a2, int a3)
{
  signed int result; // r0

  if ( !a2 )
    return 0;
  if ( a3 && a3 != a2 )
  {
    while ( 1 )
    {
      result = *(_DWORD *)(a2 + 16);
      if ( result == a3 )
        break;
      if ( !result )
        return result;
      a2 = *(_DWORD *)(a2 + 16);
    }
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
  }
  return 1;
}

//----- (0004C85E) --------------------------------------------------------
void __fastcall LinkManager::destroyAllElement(int a1, int a2)
{
  int v2; // r6
  int v3; // r5
  void *v4; // r4
  int v5; // r1
  int v6; // r2

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v4 = *(void **)(v3 + 16);
      if ( !v4 )
        break;
      LinkManager::deleteElement(v2, v3, *(_DWORD *)(v3 + 16));
      LinkManager::destroyElement(v4, v5, v6);
    }
  }
}

//----- (0004C87E) --------------------------------------------------------
void __fastcall LinkManager::destroyAllElement(LinkManager *this)
{
  LinkManager::destroyAllElement((int)this, *(_DWORD *)this);
}

//----- (0004C884) --------------------------------------------------------
void __fastcall LinkManager::deepDestroyAllElement(int a1, int a2)
{
  int v2; // r6
  int v3; // r5
  void **v4; // r4

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v4 = *(void ***)(v3 + 16);
      if ( !v4 )
        break;
      LinkManager::deleteElement(v2, v3, *(_DWORD *)(v3 + 16));
      LinkManager::deepDestroyElement(v4);
    }
  }
}

//----- (0004C8A4) --------------------------------------------------------
void __fastcall LinkManager::deepDestroyAllElement(LinkManager *this)
{
  LinkManager::deepDestroyAllElement((int)this, *(_DWORD *)this);
}

//----- (0004C8AA) --------------------------------------------------------
signed int __fastcall LinkManager::deleteElement(int *a1, int a2)
{
  return LinkManager::deleteElement((int)a1, *a1, a2);
}

//----- (0004C8B2) --------------------------------------------------------
signed int __fastcall LinkManager::deepDeleteElement(int a1, int a2, int a3)
{
  int v3; // r3

  if ( !a2 )
    return 0;
  if ( !a3 )
    return 1;
  if ( a3 == a2 )
  {
LABEL_6:
    LinkManager::deepDestroyElement((void **)a3);
    return 1;
  }
  while ( 1 )
  {
    v3 = *(_DWORD *)(a2 + 16);
    if ( v3 == a3 )
    {
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
      goto LABEL_6;
    }
    if ( !v3 )
      return 0;
    a2 = *(_DWORD *)(a2 + 16);
  }
}

//----- (0004C8E0) --------------------------------------------------------
signed int __fastcall LinkManager::deepDeleteElement(int *a1, int a2)
{
  return LinkManager::deepDeleteElement((int)a1, *a1, a2);
}

//----- (0004C8E8) --------------------------------------------------------
_DWORD *__fastcall LinkManager::simpleCopyElement(_DWORD *result, int *a2)
{
  int v2; // r3
  int v3; // t1

  if ( result )
  {
    if ( a2 )
    {
      v2 = (int)(a2 + 5);
      do
      {
        v3 = *a2;
        ++a2;
        *result = v3;
        ++result;
      }
      while ( a2 != (int *)v2 );
      result = &dword_0 + 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0004C904) --------------------------------------------------------
LinkManager *__fastcall LinkManager::copyElement(LinkManager *result)
{
  int *v1; // r4
  LinkManager *v2; // r5

  v1 = (int *)result;
  if ( result )
  {
    v2 = (LinkManager *)LinkManager::initElement(result);
    LinkManager::simpleCopyElement(v2, v1);
    result = v2;
  }
  return result;
}

//----- (0004C91C) --------------------------------------------------------
LinkManager *__fastcall LinkManager::deepCopyElement(LinkManager *a1)
{
  LinkManager *v1; // r4
  LinkManager *v3; // r5
  void *v4; // r0

  v1 = a1;
  if ( !a1 )
    return 0;
  v3 = LinkManager::copyElement(a1);
  v4 = cumalloc(*((_DWORD *)v1 + 2));
  *((_DWORD *)v3 + 3) = v4;
  if ( !v4 )
    return 0;
  memcpy(v4, *((const void **)v1 + 3), *((_DWORD *)v1 + 2));
  return v3;
}

//----- (0004C944) --------------------------------------------------------
int __fastcall LinkManager::getLastElement(int a1, int a2)
{
  if ( a2 )
  {
    while ( *(_DWORD *)(a2 + 16) )
      a2 = *(_DWORD *)(a2 + 16);
  }
  return a2;
}

//----- (0004C952) --------------------------------------------------------
int __fastcall LinkManager::appendElement(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  int result; // r0

  v3 = a1;
  v4 = a3;
  result = LinkManager::getLastElement(a1, a2);
  if ( result )
    result = LinkManager::insertElement(v3, result, v4);
  return result;
}

//----- (0004C96E) --------------------------------------------------------
int __fastcall LinkManager::appendElement(int *a1, int a2)
{
  return LinkManager::appendElement((int)a1, *a1, a2);
}

//----- (0004C976) --------------------------------------------------------
int __fastcall LinkManager::getLastElement(LinkManager *this)
{
  return LinkManager::getLastElement((int)this, *(_DWORD *)this);
}

//----- (0004C97C) --------------------------------------------------------
int __fastcall LinkManager::lockTheLink(LinkManager *this)
{
  return j_pthread_mutex_lock((pthread_mutex_t *)((char *)this + 4));
}

//----- (0004C982) --------------------------------------------------------
int __fastcall LinkManager::unlockTheLink(LinkManager *this)
{
  return j_pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 4));
}

//----- (0004C988) --------------------------------------------------------
LinkManager *__fastcall LinkManager::LinkManager(LinkManager *this)
{
  LinkManager *v1; // r4
  LinkManager *v2; // r0

  v1 = this;
  v2 = (LinkManager *)pthread_mutex_init((pthread_mutex_t *)((char *)this + 4), 0);
  *(_DWORD *)v1 = LinkManager::initElement(v2);
  return v1;
}

//----- (0004C99E) --------------------------------------------------------
LinkManager *__fastcall LinkManager::~LinkManager(LinkManager *this)
{
  LinkManager *v1; // r5
  int v2; // r1
  int v3; // r2

  v1 = this;
  LinkManager::destroyAllElement(this);
  LinkManager::destroyElement(*(void **)v1, v2, v3);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)v1 + 4));
  return v1;
}

//----- (0004C9C0) --------------------------------------------------------
signed int __fastcall downloadPath(volatile int *a1, const char *a2, char *a3, int *a4, double a5, int a6, char *a7, int a8)
{
  const char *v8; // r5
  volatile int *v9; // r11
  char *v10; // r0
  char *v11; // r4
  void *v12; // r0
  void *v13; // r10
  _BYTE *v14; // r0
  _BYTE *v15; // r9
  _BYTE *v16; // r0
  _BYTE *v17; // r7
  void *v18; // r0
  char *v19; // r0
  char *v20; // r8
  char *v21; // r0
  const char *v22; // r6
  size_t v23; // r0
  const char *v24; // r0
  char *v25; // r0
  const char *v26; // r0
  size_t v27; // r0
  size_t v28; // r5
  size_t v29; // r0
  size_t v30; // r0
  char *v31; // r0
  const char *v32; // r1
  signed int v33; // r5
  void *v34; // r0
  void *v35; // r0
  void *v36; // r0
  char *v38; // [sp+30h] [bp-38h]
  int *v39; // [sp+34h] [bp-34h]
  size_t nmemb; // [sp+3Ch] [bp-2Ch]

  v8 = a2;
  v9 = a1;
  v38 = a3;
  v39 = a4;
  downloadInit();
  nmemb = strlen(v8);
  v10 = (char *)malloc(0x14u);
  v11 = v10;
  if ( !v10 )
    exit(1);
  memset(v10, 0, 0x14u);
  v12 = calloc(nmemb, 1u);
  *(_DWORD *)v11 = v12;
  v13 = v12;
  v14 = calloc(nmemb, 1u);
  *((_DWORD *)v11 + 1) = v14;
  v15 = v14;
  v16 = calloc(nmemb, 1u);
  *((_DWORD *)v11 + 2) = v16;
  v17 = v16;
  v18 = calloc(0x1Eu, 1u);
  *((_DWORD *)v11 + 4) = v18;
  if ( !v13 || !v15 || !v17 || !v18 )
  {
    v11 = 0;
    fputs("memery calloc error!", (FILE *)((char *)&_sF + 168));
    goto LABEL_18;
  }
  v19 = strstr(v8, "http://");
  if ( v19 )
  {
    v8 = v19 + 7;
    nmemb -= 7;
  }
  v20 = strchr(v8, 47);
  v21 = strrchr(v8, 47);
  v22 = v21;
  if ( v20 && v21 )
  {
    v27 = strlen(v20);
    memcpy(v13, v8, nmemb - v27);
    v28 = strlen(v20);
    v29 = strlen(v22);
    memcpy(v15, v20, v28 + 1 - v29);
    v30 = strlen(v22);
    memcpy(v17, v22 + 1, v30);
    v31 = strchr(*(const char **)v11, 58);
    if ( v31 )
    {
      v26 = v31 + 1;
      goto LABEL_17;
    }
LABEL_15:
    *((_DWORD *)v11 + 3) = 80;
    goto LABEL_18;
  }
  v23 = strlen(v8);
  strncpy((char *)v13, v8, v23);
  v24 = *(const char **)v11;
  *v15 = 47;
  *v17 = 32;
  v25 = strchr(v24, 58);
  if ( !v25 )
    goto LABEL_15;
  v26 = v25 + 1;
LABEL_17:
  sscanf(v26, "%d", v11 + 12);
  *strchr(*(const char **)v11, 58) = 0;
LABEL_18:
  if ( parse_addr2((const char **)v11) )
  {
    v33 = -1;
    if ( !v11 )
      return v33;
  }
  else
  {
    v32 = (const char *)*((_DWORD *)v11 + 4);
    if ( *v32 )
      v33 = httpDownload(
              *(float *)&v9,
              v32,
              *(_DWORD *)v11,
              *((_DWORD *)v11 + 3),
              *((_DWORD *)v11 + 1),
              *((_DWORD *)v11 + 2),
              (int)v38,
              v39,
              a5,
              a6,
              (int)a7,
              a8);
    else
      v33 = -1;
  }
  if ( *(_DWORD *)v11 )
    free(*(void **)v11);
  v34 = (void *)*((_DWORD *)v11 + 1);
  if ( v34 )
    free(v34);
  v35 = (void *)*((_DWORD *)v11 + 2);
  if ( v35 )
    free(v35);
  v36 = (void *)*((_DWORD *)v11 + 4);
  if ( v36 )
    free(v36);
  *(_DWORD *)v11 = 0;
  *((_DWORD *)v11 + 1) = 0;
  *((_DWORD *)v11 + 2) = 0;
  *((_DWORD *)v11 + 4) = 0;
  free(v11);
  return v33;
}

//----- (0004CBAC) --------------------------------------------------------
signed int __fastcall doRequest(volatile int *a1, char *a2, char *a3, int *a4, double a5, int a6, char *a7, int a8)
{
  return downloadPath(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (0004CBB8) --------------------------------------------------------
double __fastcall getTime_http(float a1, float a2, int a3)
{
  signed int v4; // [sp+0h] [bp-10h]
  signed int v5; // [sp+4h] [bp-Ch]
  int v6; // [sp+8h] [bp-8h]

  *(float *)&v4 = a1;
  *(float *)&v5 = a2;
  v6 = a3;
  gettimeofday((struct timeval *)&v4, 0);
  return (double)v4 + (double)v5 * 0.000001;
}

//----- (0004CBF0) --------------------------------------------------------
signed int __fastcall httpDownload(float a1, const char *a2, int a3, unsigned int a4, int a5, int a6, int a7, _DWORD *a8, double a9, int a10, int a11, int a12)
{
  unsigned int v12; // r4
  const char *v13; // r5
  int v14; // r8
  double v15; // r0
  double v16; // d9
  int v17; // r0
  int v18; // r6
  int v19; // r2
  signed int v20; // r4
  int v21; // r5
  size_t v22; // r0
  int v23; // r2
  size_t v24; // r10
  size_t v25; // r0
  int v26; // r9
  ssize_t v27; // r0
  ssize_t v28; // r0
  char *v29; // r0
  char *v30; // r0
  _BOOL4 v31; // r8
  char *v32; // r0
  size_t v33; // r0
  int v34; // r7
  char *v35; // r1
  signed int v36; // r4
  void *v37; // r0
  float v38; // r1
  int v39; // r2
  double v40; // r0
  char *v41; // r5
  double v42; // d12
  double i; // d11
  double v44; // r0
  double v45; // d8
  char *v46; // r0
  signed int result; // r0
  char *c; // [sp+14h] [bp-2Ch]
  float v49; // [sp+18h] [bp-28h]
  int v50; // [sp+1Ch] [bp-24h]
  char *v51; // [sp+1Ch] [bp-24h]
  int v52; // [sp+30h] [bp-10h]
  char v53; // [sp+34h] [bp-Ch]
  char *v54; // [sp+38h] [bp-8h]
  __int16 s; // [sp+3Ch] [bp-4h]
  __int16 v56; // [sp+3Eh] [bp-2h]
  char v57; // [sp+40h] [bp+0h]
  int v58; // [sp+4Ch] [bp+Ch]
  char v59[4080]; // [sp+B0h] [bp+70h]
  int v60; // [sp+10B4h] [bp+1074h]
  int v61; // [sp+20B8h] [bp+2078h]
  int v62; // [sp+30BCh] [bp+307Ch]

  v12 = a4;
  v13 = a2;
  v50 = a3;
  v49 = a1;
  if ( !a4 )
    v12 = 80;
  v14 = a12;
  v15 = getTime_http(a1, COERCE_FLOAT(&a12), (int)&v62);
  if ( !a11 )
    v14 = 0;
  v52 = 0;
  v16 = v15;
  v17 = socket(2, 1, 0);
  v18 = v17;
  if ( v17 == -1 )
    goto LABEL_106;
  v19 = fcntl(v17, 3, 0, v17 + 1);
  if ( v19 < 0 || fcntl(v18, 4, v19 | 0x800) )
  {
    v20 = -20;
    goto LABEL_100;
  }
  memset(&s, 0, 0x10u);
  s = 2;
  v56 = __rev16(v12);
  inet_pton(2, v13, &v57);
  v21 = connect(v18, (const struct sockaddr *)&s, 0x10u);
  memset(v59, 0, 0x1001u);
  memset(&v60, 0, 0x1001u);
  if ( v14 <= 0 )
  {
    if ( a10 )
      v22 = sprintf(
              v59,
              "GET %s%s HTTP/1.0\r\n"
              "Host: %s\r\n"
              "Accept-Encoding: gzip\r\n"
              "User-agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2 Fengyun\r\n"
              "%sConection: close\r\n"
              "\r\n",
              a5,
              a6,
              v50,
              debugInfo);
    else
      v22 = sprintf(
              v59,
              "GET %s%s HTTP/1.0\r\n"
              "Host: %s\r\n"
              "User-agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2 Fengyun\r\n"
              "%sConection: close\r\n"
              "\r\n",
              a5,
              a6,
              v50,
              debugInfo);
  }
  else if ( a10 )
  {
    v22 = sprintf(
            v59,
            "POST %s%s HTTP/1.0\r\n"
            "Host: %s\r\n"
            "Accept-Encoding: gzip\r\n"
            "User-agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2 Fengyun\r\n"
            "Content-Type: application/binary\r\n"
            "Content-Length: %d\r\n"
            "%sConection: close\r\n"
            "\r\n",
            a5,
            a6,
            v50,
            v14,
            debugInfo);
  }
  else
  {
    v22 = sprintf(
            v59,
            "POST %s%s HTTP/1.0\r\n"
            "Host: %s\r\n"
            "User-agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0.2) Gecko/20100101 Firefox/6.0.2 Fengyun\r\n"
            "Content-Type: application/binary\r\n"
            "Content-Length: %d\r\n"
            "%sConection: close\r\n"
            "\r\n",
            a5,
            a6,
            v50,
            v14,
            debugInfo);
  }
  v24 = 0;
  while ( v49 == 0.0 || *(_DWORD *)LODWORD(v49) )
  {
    if ( getTime_http(*(float *)&v22, v49, v23) - v16 > a9 )
    {
LABEL_30:
      v20 = -30;
      goto LABEL_100;
    }
    v25 = strlen(v59);
    v21 = write(v18, &v59[v24], v25 - v24);
    if ( v21 > 0 )
    {
      v24 += v21;
      v22 = strlen(v59);
      if ( v24 >= v22 )
        break;
    }
    v22 = usleep(0xC350u);
  }
  v26 = 0;
  while ( v49 == 0.0 || *(_DWORD *)LODWORD(v49) )
  {
    if ( v14 <= 0 )
      break;
    v23 = a11;
    if ( !a11 )
      break;
    if ( getTime_http(*(float *)&v22, v49, a11) - v16 > a9 )
      goto LABEL_30;
    v27 = write(v18, (const void *)(a11 + v26), v14 - v26);
    v21 = v27;
    if ( v27 > 0 )
    {
      v26 += v27;
      if ( v26 >= v14 )
      {
LABEL_42:
        while ( v49 == 0.0 || *(_DWORD *)LODWORD(v49) )
        {
          if ( getTime_http(*(float *)&v27, v49, v23) - v16 > a9 )
          {
            v20 = -38;
            goto LABEL_100;
          }
          v28 = read(v18, &v60, 0x1000u);
          v21 = v28;
          if ( !v28 )
          {
            v20 = -40;
            goto LABEL_100;
          }
          if ( v28 != -1 )
            goto LABEL_45;
          v27 = usleep(0xC350u);
        }
        if ( v21 == -1 )
        {
          v20 = -50;
          goto LABEL_100;
        }
LABEL_45:
        v54 = (char *)-1;
        v29 = strstr((const char *)&v60, "HTTP/");
        if ( !v29 )
        {
          v20 = -55;
          goto LABEL_100;
        }
        sscanf(v29, "HTTP/%f %d", &v52, &v53);
        v30 = strstr((const char *)&v60, "Content-Length");
        if ( v30 )
          sscanf(v30, "Content-Length: %d", &v54);
        else
          v54 = (char *)-1;
        if ( strstr((const char *)&v60, "Content-Encoding")
          && (puts("content encoding"),
              v32 = strstr((const char *)&v60, "Content-Encoding"),
              sscanf(v32, "Content-Encoding: %s", &v58),
              (v58 & 0xDF) == 71)
          && (BYTE1(v58) & 0xDF) == 90
          && (BYTE2(v58) & 0xDF) == 73 )
        {
          v31 = (HIBYTE(v58) & 0xDFu) - 80 <= 0;
        }
        else
        {
          v31 = 0;
        }
        if ( (signed int)v54 < 0 && v31 )
        {
          v20 = -58;
          goto LABEL_100;
        }
        if ( *(_DWORD *)&v53 != 200 )
        {
          v20 = -60;
          goto LABEL_100;
        }
        if ( !a7 )
        {
          v20 = 0;
          goto LABEL_100;
        }
        if ( !a8 )
        {
          v20 = 0;
          goto LABEL_100;
        }
        if ( !v54 )
        {
          *a8 = 0;
          v20 = 0;
          goto LABEL_100;
        }
        memset(&v61, 0, 0x1001u);
        if ( v31 )
        {
          v33 = (size_t)v54;
          if ( (signed int)v54 <= 0 )
            v33 = 64512;
          v34 = (int)calloc(v33, 1u);
          if ( !v34 )
          {
            v20 = -65;
            goto LABEL_100;
          }
        }
        else
        {
          v34 = a7;
        }
        v35 = strstr((const char *)&v60, "\r\n\r\n") + 4;
        if ( v35 < (char *)&v60 || (c = v35, v35 > (char *)&v60 + strlen((const char *)&v60)) )
        {
          v20 = -66;
        }
        else
        {
          v51 = (char *)(v21 + (char *)&v60 - c);
          v36 = 0;
          v37 = memcpy((void *)v34, c, v21 + (char *)&v60 - c);
          v40 = getTime_http(*(float *)&v37, v38, v39);
          v41 = (char *)(v21 + (char *)&v60 - c);
          v42 = v40;
          for ( i = v40; ; i = v45 )
          {
            if ( v49 != 0.0 && !*(_DWORD *)LODWORD(v49) || (signed int)v41 >= (signed int)v54 && (signed int)v54 >= 0 )
            {
              if ( v36 == -1 )
              {
                v20 = -70;
                goto LABEL_97;
              }
              goto LABEL_91;
            }
            v44 = getTime_http(*(float *)&v40, v49, (int)v54);
            v45 = v44;
            if ( v44 - v16 > a9 || v44 - i > 5.0 || v44 - v42 > 1.0 && v51 == v41 && (signed int)v54 < 0 )
              break;
            v36 = read(v18, &v61, 0x1001u);
            if ( v36 > 0 )
            {
              v46 = &v41[v34];
              v41 += v36;
              memcpy(v46, &v61, v36);
              LODWORD(v40) = memset(&v61, 0, 0x1001u);
              if ( (signed int)v41 >= (signed int)v54 && (signed int)v54 >= 0 )
                goto LABEL_91;
            }
            else
            {
              v45 = i;
              LODWORD(v40) = usleep(0xC350u);
            }
          }
          if ( (signed int)v54 >= 0 || (signed int)v41 <= 0 )
          {
            v20 = -67;
            goto LABEL_97;
          }
          v54 = v41;
LABEL_91:
          if ( (signed int)v41 >= (signed int)v54 )
          {
            if ( !v31 )
            {
              v20 = 0;
              *a8 = v54;
              goto LABEL_100;
            }
            v20 = 0;
            ungz(v34, (int)v54, a7, a8);
            if ( v34 == a7 )
              goto LABEL_100;
LABEL_99:
            free((void *)v34);
            goto LABEL_100;
          }
          v20 = -75;
        }
LABEL_97:
        if ( v34 == a7 || !v31 )
          goto LABEL_100;
        goto LABEL_99;
      }
    }
    v22 = usleep(0xC350u);
  }
  v27 = v21 + 1;
  if ( v21 != -1 )
    goto LABEL_42;
  v20 = -35;
LABEL_100:
  if ( !v18 )
    goto LABEL_102;
  while ( 1 )
  {
    close(v18);
LABEL_102:
    if ( v20 )
    {
      if ( a8 )
        *a8 = -1;
    }
    result = v20;
    if ( v62 == _stack_chk_guard )
      break;
LABEL_106:
    v20 = -10;
  }
  return result;
}
// 4CBF0: using guessed type char var_304C[4080];

//----- (0004D19C) --------------------------------------------------------
size_t __fastcall callback(size_t result, int a2, int a3, int a4)
{
  size_t v4; // r5
  const void *v5; // r1
  size_t v6; // r0
  char buf; // [sp+4h] [bp-4Ch]

  v4 = result;
  if ( a4 && !a2 )
  {
    v5 = **(const void ***)(a4 + 16);
    if ( v5 )
    {
      inet_ntop(*(_DWORD *)(a4 + 8), v5, &buf, 0x2Eu);
      v6 = strlen(&buf);
      strncpy(*(char **)(v4 + 16), &buf, v6);
      result = strlen(&buf);
      *(_BYTE *)(*(_DWORD *)(v4 + 16) + result) = 0;
    }
  }
  return result;
}

//----- (0004D1F4) --------------------------------------------------------
void __fastcall free_ip_list(_DWORD *a1)
{
  _DWORD *v1; // r4

  if ( a1 )
  {
    while ( 1 )
    {
      v1 = (_DWORD *)a1[4];
      free(a1);
      if ( !v1 )
        break;
      a1 = v1;
    }
  }
}

//----- (0004D208) --------------------------------------------------------
char *__fastcall parse_addr(const char *a1)
{
  const char *v1; // r9
  char *v2; // r4
  const char *v3; // r0
  struct addrinfo *i; // r6
  char *v6; // r0
  char *v7; // r3
  struct addrinfo *pai; // [sp+4h] [bp-28h]
  int ecode; // [sp+8h] [bp-24h]
  char s; // [sp+Ch] [bp-20h]
  int v11; // [sp+10h] [bp-1Ch]
  int v12; // [sp+14h] [bp-18h]
  int v13; // [sp+2Ch] [bp+0h]

  v1 = a1;
  memset(&v13, 0, 0x10u);
  v2 = (char *)calloc(1u, 0x14u);
  if ( !v2 )
  {
    fputs("memery calloc error!", (FILE *)((char *)&_sF + 168));
    return v2;
  }
  memset(&s, 0, 0x20u);
  v11 = 2;
  v12 = 1;
  ecode = getaddrinfo(v1, 0, (const struct addrinfo *)&s, &pai);
  if ( ecode )
  {
    v3 = gai_strerror(ecode);
    fprintf((FILE *)((char *)&_sF + 168), "getaddrinfo: %s\n", v3);
    free_ip_list(v2);
    return 0;
  }
  for ( i = pai; i; i = i->ai_next )
  {
    inet_ntop(2, i->ai_canonname + 4, (char *)&v13, 0x10u);
    if ( *((_DWORD *)v2 + 4) || *v2 )
    {
      v6 = (char *)calloc(1u, 0x14u);
      v7 = v2;
      if ( !v6 )
      {
        fputs("memery calloc error!", (FILE *)((char *)&_sF + 168));
        continue;
      }
      while ( *((_DWORD *)v7 + 4) )
        v7 = (char *)*((_DWORD *)v7 + 4);
      *((_DWORD *)v7 + 4) = v6;
    }
    else
    {
      v6 = v2;
    }
    strncpy(v6, (const char *)&v13, 0x10u);
  }
  freeaddrinfo(pai);
  return v2;
}

//----- (0004D318) --------------------------------------------------------
double __fastcall getTime(float a1, float a2, int a3)
{
  signed int v4; // [sp+0h] [bp-10h]
  signed int v5; // [sp+4h] [bp-Ch]
  int v6; // [sp+8h] [bp-8h]

  *(float *)&v4 = a1;
  *(float *)&v5 = a2;
  v6 = a3;
  gettimeofday((struct timeval *)&v4, 0);
  return (double)v4 + (double)v5 * 0.000001;
}

//----- (0004D350) --------------------------------------------------------
int initParse()
{
  int result; // r0

  if ( !hasInitParse )
  {
    result = pthread_mutex_init((pthread_mutex_t *)&parse_lock, (const pthread_mutexattr_t *)hasInitParse);
    hasInitParse = 1;
  }
  return result;
}
// F6058: using guessed type int hasInitParse;

//----- (0004D374) --------------------------------------------------------
int __fastcall wait_ares2(int *a1)
{
  int *i; // r7
  int result; // r0
  int v3; // r9
  int timeout; // [sp+8h] [bp-128h]
  int v5; // [sp+Ch] [bp-124h]
  char s; // [sp+10h] [bp-120h]
  char v7; // [sp+90h] [bp-A0h]

  for ( i = a1; ; ares_process(i, (int)&s, (int)&v7) )
  {
    memset(&s, 0, 0x80u);
    memset(&v7, 0, 0x80u);
    result = ares_fds((int)i, (int)&s, (int)&v7);
    v3 = result;
    if ( !result )
      break;
    timeout = 1;
    v5 = 0;
    ares_timeout((int)i, &timeout, &timeout);
    select(v3, (fd_set *)&s, (fd_set *)&v7, 0, (struct timeval *)&timeout);
  }
  return result;
}

//----- (0004D3D8) --------------------------------------------------------
int __fastcall add2DnsBuffer(const char *a1, const char *a2)
{
  const char *v2; // r5
  const char *v3; // r8
  int v4; // r4
  char *v5; // r6
  size_t v6; // r0
  size_t v7; // r0
  char *v8; // r0
  float v9; // r1
  int v10; // r2
  double v11; // r0
  float v12; // r1
  int v13; // r2
  char *v14; // r6
  size_t v15; // r0
  size_t v16; // r0
  char *v17; // r0
  float v18; // r1
  int v19; // r2
  double v20; // r0

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&parse_lock);
  v4 = dnsBuffer;
  if ( dnsBuffer )
  {
    while ( 1 )
    {
      if ( !strcmp((const char *)v4, v2) )
      {
        *(double *)(v4 + 160) = getTime(0.0, v12, v13);
        return j_pthread_mutex_unlock((pthread_mutex_t *)&parse_lock);
      }
      if ( !*(_DWORD *)(v4 + 168) )
        break;
      v4 = *(_DWORD *)(v4 + 168);
    }
    v14 = (char *)calloc(1u, 0xB0u);
    v15 = strlen(v2);
    strncpy(v14, v2, v15);
    v16 = strlen(v3);
    v17 = strncpy(v14 + 128, v3, v16);
    v20 = getTime(*(float *)&v17, v18, v19);
    *((_DWORD *)v14 + 42) = 0;
    *((double *)v14 + 20) = v20;
    *(_DWORD *)(v4 + 168) = v14;
  }
  else
  {
    v5 = (char *)calloc(1u, 0xB0u);
    v6 = strlen(v2);
    strncpy(v5, v2, v6);
    v7 = strlen(v3);
    v8 = strncpy(v5 + 128, v3, v7);
    v11 = getTime(*(float *)&v8, v9, v10);
    *((_DWORD *)v5 + 42) = 0;
    dnsBuffer = (int)v5;
    *((double *)v5 + 20) = v11;
  }
  return j_pthread_mutex_unlock((pthread_mutex_t *)&parse_lock);
}
// F605C: using guessed type int dnsBuffer;

//----- (0004D4B0) --------------------------------------------------------
int __fastcall checkDnsBuffer(const char *a1)
{
  const char *v1; // r6
  int i; // r4
  float v3; // r1
  int v4; // r2

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&parse_lock);
  for ( i = dnsBuffer; ; i = *(_DWORD *)(i + 168) )
  {
    if ( !i )
      goto LABEL_5;
    if ( !strcmp((const char *)i, v1) )
      break;
  }
  if ( getTime(0.0, v3, v4) - *(double *)(i + 160) >= 600.0 )
  {
LABEL_5:
    pthread_mutex_unlock((pthread_mutex_t *)&parse_lock);
    return 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&parse_lock);
  return i;
}
// F605C: using guessed type int dnsBuffer;

//----- (0004D520) --------------------------------------------------------
signed int __fastcall parse_addr_ios(const char **a1)
{
  const char **v1; // r4
  int v2; // r0
  const char *v3; // r6
  const char *v4; // r6
  size_t v5; // r0
  const char *v6; // r0
  int v7; // r0
  char v8; // r6
  const char *v9; // r0
  size_t v11; // r0
  struct addrinfo *pai; // [sp+8h] [bp-58h]
  char v13; // [sp+Ch] [bp-54h]
  int v14; // [sp+10h] [bp-50h]
  int v15; // [sp+14h] [bp-4Ch]
  char s; // [sp+2Ch] [bp-34h]

  v1 = a1;
  v2 = checkDnsBuffer(*a1);
  v3 = (const char *)v2;
  if ( v2 )
  {
    v4 = (const char *)(v2 + 128);
    v5 = strlen((const char *)(v2 + 128));
    strncpy((char *)v1[4], v4, v5);
    v1[4][strlen(v4)] = 0;
  }
  else
  {
    memset(&s, 0, 0x10u);
    memset(&v13, (int)v3, 0x20u);
    v15 = 1;
    v6 = *v1;
    v14 = 2;
    v7 = getaddrinfo(v6, v3, (const struct addrinfo *)&v13, &pai);
    v8 = v7;
    if ( v7 )
    {
      v9 = gai_strerror(v7);
      fprintf((FILE *)((char *)&_sF + 168), "getaddrinfo: %s\n", v9);
      return -1;
    }
    if ( pai )
    {
      inet_ntop(2, pai->ai_canonname + 4, &s, 0x10u);
      v11 = strlen(&s);
      strncpy((char *)v1[4], &s, v11);
      v1[4][strlen(&s)] = v8;
      add2DnsBuffer(*v1, v1[4]);
    }
    freeaddrinfo(pai);
  }
  return 0;
}

//----- (0004D610) --------------------------------------------------------
signed int __fastcall parse_addr2(const char **a1)
{
  char **v1; // r4
  int v2; // r0
  const char *v3; // r5
  size_t v4; // r0
  signed int result; // r0
  const char *v6; // r1
  int v7; // [sp+8h] [bp-58h]
  char v8; // [sp+Ch] [bp-54h]
  int (*v9)(); // [sp+3Ch] [bp-24h]

  v1 = (char **)a1;
  v2 = checkDnsBuffer(*a1);
  if ( v2 )
  {
    v3 = (const char *)(v2 + 128);
    v4 = strlen((const char *)(v2 + 128));
    strncpy(v1[4], v3, v4);
    v1[4][strlen(v3)] = 0;
    result = 0;
  }
  else if ( ares_library_init(1) || (v9 = state_cb, ares_init_options(&v7, (int)&v8, 512)) )
  {
    result = 1;
  }
  else
  {
    ares_gethostbyname(v7, *v1, 2, (int)callback, (int)v1);
    wait_ares2((int *)v7);
    ares_destroy(v7);
    ares_library_cleanup();
    v6 = v1[4];
    result = *(unsigned __int8 *)v6;
    if ( *v6 )
    {
      add2DnsBuffer(*v1, v6);
      result = 0;
    }
  }
  return result;
}
// 4D198: using guessed type int state_cb();

//----- (0004D6A4) --------------------------------------------------------
size_t __fastcall readn(const void **a1, int a2, void *a3, unsigned int a4)
{
  const void **v4; // r4
  unsigned int v5; // r1
  size_t v6; // r5
  size_t result; // r0

  v4 = a1;
  v5 = a2 - (_DWORD)*a1;
  if ( v5 >= a4 )
    v6 = a4;
  else
    v6 = v5;
  memcpy(a3, *a1, v6);
  result = v6;
  *v4 = (char *)*v4 + v6;
  return result;
}

//----- (0004D6C8) --------------------------------------------------------
signed int __fastcall go(signed int a1, int a2, int a3, void **a4)
{
  signed int v4; // r7
  int v5; // r10
  void **v6; // r6
  int v7; // r0
  signed int result; // r0
  int v9; // r2
  unsigned int v10; // r1
  signed int v11; // r4
  int v12; // [sp+Ch] [bp-6Ch]
  void *s; // [sp+14h] [bp-64h]
  int v14; // [sp+18h] [bp-60h]
  void *v15; // [sp+20h] [bp-58h]
  int v16; // [sp+24h] [bp-54h]

  v4 = a1;
  v12 = a2;
  v5 = a3;
  v6 = a4;
  memset(&s, 0, 0x3Cu);
  if ( v4 )
    v7 = mz_deflateInit2(&s, v4, 8, -15, 6, 0);
  else
    v7 = mz_inflateInit2(&s, -15);
  result = v7 != 0;
  if ( !result )
  {
    while ( 1 )
    {
      result = readn((const void **)&v12, v5, (char *)&unk_F6060 + v14, 0x100000 - v14);
      if ( result < 0 )
        break;
      s = &unk_F6060;
      v15 = &unk_1F6060;
      v14 += result;
      v16 = 0x100000;
      if ( v4 )
      {
        v10 = result ? 4 : 2;
        result = mz_deflate((unsigned __int8 **)&s, v10, v9, 0x100000);
      }
      else
      {
        result = mz_inflate((int)&s, 2);
      }
      v11 = result;
      if ( result == -3 )
        break;
      if ( (unsigned __int8)((result + 3 < 0) ^ __OFADD__(result, 3)) | (result == -3) )
      {
        if ( result == -10000 )
          return result;
      }
      else if ( !result || result == 1 )
      {
        result = (signed int)memcpy(*v6, &unk_1F6060, 0x100000 - v16);
        *v6 = (char *)*v6 + 2 * (0x100000 - v16);
        v14 = 0;
        if ( v11 )
          return result;
      }
    }
  }
  return result;
}

//----- (0004D7BC) --------------------------------------------------------
size_t __fastcall skipString(size_t result, int a2)
{
  const void **v2; // r5
  int v3; // r6
  int v4; // [sp+4h] [bp-14h]

  v4 = a2;
  v2 = (const void **)result;
  v3 = a2;
  LOBYTE(v4) = 1;
  while ( (_BYTE)v4 )
    result = readn(v2, v3, &v4, 1u);
  return result;
}

//----- (0004D7E4) --------------------------------------------------------
size_t __fastcall ungz(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r9
  int v5; // r4
  int v6; // r8
  size_t result; // r0
  int v8; // r7
  int v9; // [sp+0h] [bp-40h]
  unsigned __int8 v10; // [sp+4h] [bp-3Ch]
  unsigned __int8 v11; // [sp+5h] [bp-3Bh]
  int v12; // [sp+8h] [bp-38h]
  int v13; // [sp+Ch] [bp-34h]
  char v14; // [sp+10h] [bp-30h]
  unsigned __int8 v15; // [sp+11h] [bp-2Fh]
  char v16; // [sp+12h] [bp-2Eh]
  char v17; // [sp+13h] [bp-2Dh]

  v4 = a4;
  v5 = a1 + a2;
  v12 = a1;
  v13 = a3;
  v6 = a3;
  result = readn((const void **)&v12, a1 + a2, &v14, 0xAu);
  if ( v14 == 31 && v15 == 139 && v16 == 8 )
  {
    if ( v17 & 4 )
    {
      readn((const void **)&v12, v5, &v10, 2u);
      v8 = v10 | (v11 << 8);
      while ( v8 )
      {
        v8 = (unsigned __int16)(v8 - 1);
        readn((const void **)&v12, v5, &v9, 1u);
      }
    }
    if ( v17 & 8 )
      skipString((size_t)&v12, v5);
    if ( v17 & 0x10 )
      skipString((size_t)&v12, v5);
    if ( v17 & 2 )
      readn((const void **)&v12, v5, &v10, 2u);
    result = go(0, v12, v5, (void **)&v13);
    *v4 = v13 - v6;
  }
  return result;
}

//----- (0004D8B8) --------------------------------------------------------
int __fastcall storLE32(int result, int a2)
{
  *(_WORD *)result = a2;
  *(_BYTE *)(result + 2) = BYTE2(a2);
  *(_BYTE *)(result + 3) = HIBYTE(a2);
  return result;
}

//----- (0004D8C8) --------------------------------------------------------
bool __fastcall sub_4D8C8(int a1)
{
  unsigned __int8 *v1; // r4
  unsigned int i; // r3
  int v3; // r5
  int v4; // r9
  int v5; // r3
  int v6; // r8
  int v7; // r10
  unsigned int v8; // r2
  int v9; // r10
  int v10; // r11
  int v11; // r10
  int v12; // r5
  unsigned int v13; // r5
  int v14; // r10
  _BYTE *v15; // r9
  int v16; // r9
  int v17; // r8
  int v18; // r5
  unsigned int v19; // r5
  int v20; // r10
  _BYTE *v21; // r8
  int v22; // r9
  int v23; // r8
  char *v24; // r8
  int v25; // r11
  int v26; // r9
  int v27; // r5
  unsigned int v28; // r5
  int v29; // r9
  _BYTE *v30; // r10
  int v31; // r2
  _BYTE *v32; // r5
  int v33; // r2
  int v34; // r8
  _BYTE *v35; // r5
  int v36; // r2
  unsigned int v37; // r3
  unsigned int v38; // r2
  bool v39; // cf
  bool v40; // zf
  _BYTE *v41; // r3

  v1 = (unsigned __int8 *)(a1 + 37494);
  for ( i = 1; ; i >>= 1 )
  {
    v3 = *(_DWORD *)(a1 + 72);
    v4 = *(_DWORD *)(a1 + 76);
    if ( (unsigned int)v1 >= *(_DWORD *)(a1 + 44) )
      break;
    if ( i == 1 )
    {
      v5 = *v1++;
      i = v5 | 0x100;
    }
    v6 = *v1;
    if ( i & 1 )
    {
      v7 = v1[2];
      v1 += 3;
      v8 = *(v1 - 2) | (v7 << 8);
      v9 = *((unsigned __int16 *)dword_E9BF4 + v6);
      v10 = *(unsigned __int8 *)(a1 + v9 + 36630);
      v11 = *(unsigned __int16 *)(a1 + 2 * (v9 + 17408) + 86) << v3;
      v12 = v3 + v10;
      *(_DWORD *)(a1 + 76) = v4 | v11;
      while ( 1 )
      {
        *(_DWORD *)(a1 + 72) = v12;
        v13 = *(_DWORD *)(a1 + 72);
        v14 = *(_DWORD *)(a1 + 76);
        if ( v13 <= 7 )
          break;
        v15 = *(_BYTE **)(a1 + 52);
        if ( (unsigned int)v15 < *(_DWORD *)(a1 + 56) )
        {
          *(_DWORD *)(a1 + 52) = v15 + 1;
          *v15 = v14;
        }
        *(_DWORD *)(a1 + 76) >>= 8;
        v12 = *(_DWORD *)(a1 + 72) - 8;
      }
      v16 = *((unsigned __int8 *)&dword_E9BF4[128] + v6);
      v17 = (v6 & dword_E9BF4[v16 + 192]) << v13;
      v18 = v13 + v16;
      *(_DWORD *)(a1 + 76) = v14 | v17;
      while ( 1 )
      {
        *(_DWORD *)(a1 + 72) = v18;
        v19 = *(_DWORD *)(a1 + 72);
        v20 = *(_DWORD *)(a1 + 76);
        if ( v19 <= 7 )
          break;
        v21 = *(_BYTE **)(a1 + 52);
        if ( (unsigned int)v21 < *(_DWORD *)(a1 + 56) )
        {
          *(_DWORD *)(a1 + 52) = v21 + 1;
          *v21 = v20;
        }
        *(_DWORD *)(a1 + 76) >>= 8;
        v18 = *(_DWORD *)(a1 + 72) - 8;
      }
      if ( v8 > 0x1FF )
      {
        v24 = (char *)dword_E9BF4 + (v8 >> 8);
        v22 = (unsigned __int8)v24[1860];
        v23 = (unsigned __int8)v24[1988];
      }
      else
      {
        v22 = *((unsigned __int8 *)&dword_E9BF4[209] + v8);
        v23 = *((unsigned __int8 *)&dword_E9BF4[337] + v8);
      }
      v25 = *(unsigned __int8 *)(a1 + v22 + 36918);
      v26 = *(unsigned __int16 *)(a1 + 2 * (v22 + 17664) + 150) << v19;
      v27 = v19 + v25;
      *(_DWORD *)(a1 + 76) = v20 | v26;
      while ( 1 )
      {
        *(_DWORD *)(a1 + 72) = v27;
        v28 = *(_DWORD *)(a1 + 72);
        v29 = *(_DWORD *)(a1 + 76);
        if ( v28 <= 7 )
          break;
        v30 = *(_BYTE **)(a1 + 52);
        if ( (unsigned int)v30 < *(_DWORD *)(a1 + 56) )
        {
          *(_DWORD *)(a1 + 52) = v30 + 1;
          *v30 = v29;
        }
        *(_DWORD *)(a1 + 76) >>= 8;
        v27 = *(_DWORD *)(a1 + 72) - 8;
      }
      v31 = (v8 & dword_E9BF4[v23 + 192]) << v28;
      *(_DWORD *)(a1 + 72) = v28 + v23;
      *(_DWORD *)(a1 + 76) = v29 | v31;
      while ( *(_DWORD *)(a1 + 72) > 7u )
      {
        v32 = *(_BYTE **)(a1 + 52);
        if ( (unsigned int)v32 < *(_DWORD *)(a1 + 56) )
        {
          *(_DWORD *)(a1 + 52) = v32 + 1;
          *v32 = *(_DWORD *)(a1 + 76);
        }
        *(_DWORD *)(a1 + 76) >>= 8;
        *(_DWORD *)(a1 + 72) -= 8;
      }
    }
    else
    {
      ++v1;
      v33 = *(unsigned __int8 *)(a1 + v6 + 36630);
      v34 = *(unsigned __int16 *)(a1 + 2 * (v6 + 17408) + 86) << v3;
      *(_DWORD *)(a1 + 72) = v3 + v33;
      *(_DWORD *)(a1 + 76) = v4 | v34;
      while ( *(_DWORD *)(a1 + 72) > 7u )
      {
        v35 = *(_BYTE **)(a1 + 52);
        if ( (unsigned int)v35 < *(_DWORD *)(a1 + 56) )
        {
          *(_DWORD *)(a1 + 52) = v35 + 1;
          *v35 = *(_DWORD *)(a1 + 76);
        }
        *(_DWORD *)(a1 + 76) >>= 8;
        *(_DWORD *)(a1 + 72) -= 8;
      }
    }
  }
  v36 = *(unsigned __int16 *)(a1 + 35414) << v3;
  *(_DWORD *)(a1 + 72) = v3 + *(unsigned __int8 *)(a1 + 36886);
  *(_DWORD *)(a1 + 76) = v4 | v36;
  while ( 1 )
  {
    v37 = *(_DWORD *)(a1 + 72);
    v38 = *(_DWORD *)(a1 + 56);
    v39 = v37 >= 7;
    v40 = v37 == 7;
    v41 = *(_BYTE **)(a1 + 52);
    if ( v40 || !v39 )
      break;
    if ( (unsigned int)v41 < v38 )
    {
      *(_DWORD *)(a1 + 52) = v41 + 1;
      *v41 = *(_DWORD *)(a1 + 76);
    }
    *(_DWORD *)(a1 + 76) >>= 8;
    *(_DWORD *)(a1 + 72) -= 8;
  }
  return (unsigned int)v41 < v38;
}

//----- (0004DB2C) --------------------------------------------------------
int __fastcall sub_4DB2C(int a1, int a2)
{
  _BYTE *v2; // r3
  int v3; // r3
  int result; // r0

  ++*(_DWORD *)(a1 + 64);
  v2 = *(_BYTE **)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v2 + 1;
  *v2 = a2;
  **(_BYTE **)(a1 + 48) >>= 1;
  if ( *(_DWORD *)(a1 + 60) == 1 )
  {
    *(_DWORD *)(a1 + 60) = 8;
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = v3 + 1;
    *(_DWORD *)(a1 + 48) = v3;
  }
  else
  {
    --*(_DWORD *)(a1 + 60);
  }
  result = a1 + 2 * a2 + 33024;
  ++*(_WORD *)(result + 150);
  return result;
}

//----- (0004DB6C) --------------------------------------------------------
int __fastcall sub_4DB6C(int a1, int a2, int a3)
{
  unsigned int v3; // r2
  int v4; // r1
  int v5; // r3
  int v6; // r2
  int v7; // r2
  int result; // r0

  v3 = a3 - 1;
  *(_DWORD *)(a1 + 64) += a2;
  v4 = a2 - 3;
  **(_BYTE **)(a1 + 44) = v4;
  *(_WORD *)(*(_DWORD *)(a1 + 44) + 1) = v3;
  *(_DWORD *)(a1 + 44) += 3;
  **(_BYTE **)(a1 + 48) = (**(_BYTE **)(a1 + 48) >> 1) | 0x80;
  if ( *(_DWORD *)(a1 + 60) == 1 )
  {
    *(_DWORD *)(a1 + 60) = 8;
    v5 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = v5 + 1;
    *(_DWORD *)(a1 + 48) = v5;
  }
  else
  {
    --*(_DWORD *)(a1 + 60);
  }
  if ( v3 < 0x200 )
    v6 = *((unsigned __int8 *)&dword_E9BF4[209] + (v3 & 0x1FF));
  else
    v6 = *((unsigned __int8 *)&dword_E9BF4[465] + (v3 >> 8));
  v7 = a1 + 2 * v6 + 33536;
  result = a1 + 2 * *((unsigned __int16 *)dword_E9BF4 + v4) + 33024;
  ++*(_WORD *)(v7 + 214);
  ++*(_WORD *)(result + 150);
  return result;
}

//----- (0004DC0A) --------------------------------------------------------
int __fastcall sub_4DC0A(int a1, int a2, int a3, signed int a4, signed int a5)
{
  int v5; // r11
  signed int v6; // r7
  signed int v7; // r5
  int v8; // r3
  int result; // r0
  int v10; // r2
  int v11; // r3
  int v12; // r0
  char *v13; // r1
  int v14; // r3
  unsigned int v15; // r0
  char *v16; // r4
  signed int v17; // r3
  int v18; // r3
  int v19; // r0
  int v20; // r1
  int v21; // r2
  char *v22; // r12
  int v23; // r1
  int v24; // r0
  int v25; // r10
  int v26; // r9
  char *v27; // r1
  signed int v28; // r3
  char *v29; // r1
  int v30; // lr
  signed int v31; // r2
  int v32; // r3
  int v33; // r0
  unsigned int v34; // r0
  __int16 v35; // r8
  int v36; // r0
  __int16 v37; // r8
  int v38; // r0
  __int16 v39; // r0
  int v40; // r2
  int i; // r3
  int v42; // r1
  int v43; // r3
  int v44; // lr
  int v45; // r12
  int v46; // r2
  int v47; // r12
  int j; // r9
  int v49; // r2
  signed int v50; // r3
  char *v51; // r3
  int v52; // r2
  char *v53; // r0
  int v54; // t1
  int v55; // r2
  int v56; // r1
  int v57; // r0
  char *v58; // r0
  int k; // r2
  int v60; // r12
  int v61; // t1
  int v62; // r0
  int v63; // r1
  int v64; // r2
  signed int v65; // r3
  int v66; // r1
  int v67; // r6
  int l; // r3
  unsigned int v69; // r4
  int v70; // r1
  int v71; // r5
  char *v72; // [sp+4h] [bp-15C4h]
  int v73; // [sp+8h] [bp-15C0h]
  int v74; // [sp+10h] [bp-15B8h]
  unsigned int v75; // [sp+14h] [bp-15B4h]
  char s[132]; // [sp+1Ch] [bp-15ACh]
  char v77[1024]; // [sp+A0h] [bp-1528h]
  char v78[1152]; // [sp+4A0h] [bp-1128h]
  char v79; // [sp+920h] [bp-CA8h]
  char v80[4]; // [sp+DA0h] [bp-828h]
  int v81; // [sp+DA4h] [bp-824h]
  int v82; // [sp+11A0h] [bp-428h]

  v5 = a1;
  v6 = a4;
  v73 = a2;
  v74 = a3;
  v7 = a5;
  memset(s, 0, 0x84u);
  if ( a5 )
  {
    v8 = 0;
    result = v5 + 288 * v73;
    while ( v8 < v74 )
    {
      v10 = result + v8++;
      ++*(_DWORD *)&s[4 * *(unsigned __int8 *)(v10 + 36630)];
    }
  }
  else
  {
    v11 = 0;
    v12 = v5 + 576 * v73 + 33174;
    while ( v11 < v74 )
    {
      if ( *(_WORD *)(v12 + 2 * v11) )
      {
        *(_WORD *)&v78[4 * v7] = *(_WORD *)(v12 + 2 * v11);
        v13 = &v78[4 * v7++];
        *((_WORD *)v13 + 1) = v11;
      }
      ++v11;
    }
    memset(v80, 0, 0x800u);
    v14 = 0;
    while ( v14 != v7 )
    {
      v15 = *(unsigned __int16 *)&v78[4 * v14++];
      ++*(_DWORD *)&v80[4 * (unsigned __int8)v15];
      ++*(_DWORD *)&v80[4 * ((v15 >> 8) + 256)];
    }
    v16 = &v79;
    v72 = v78;
    if ( v7 == v82 )
      v17 = 1;
    else
      v17 = 2;
    v75 = v17;
    v18 = 0;
    while ( 1 )
    {
      v19 = 0;
      v20 = 0;
      do
      {
        *(_DWORD *)&v77[v19] = v20;
        v21 = *(_DWORD *)&v80[1024 * v18 + v19];
        v19 += 4;
        v20 += v21;
      }
      while ( v19 != 1024 );
      v22 = v72;
      v23 = 0;
      while ( 1 )
      {
        v22 += 4;
        if ( v23 == v7 )
          break;
        ++v23;
        v24 = *((_DWORD *)v22 - 1);
        v25 = (unsigned __int8)((signed int)*((unsigned __int16 *)v22 - 2) >> 8 * v18);
        v26 = *(_DWORD *)&v77[4 * v25];
        *(_DWORD *)&v77[4 * v25] = v26 + 1;
        *(_DWORD *)&v16[4 * v26] = v24;
      }
      if ( ++v18 >= v75 )
        break;
      v27 = v72;
      v72 = v16;
      v16 = v27;
    }
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        *(_WORD *)v16 = 1;
      }
      else
      {
        v29 = v16;
        v30 = 1;
        v31 = 2;
        *(_WORD *)v16 += *((_WORD *)v16 + 2);
        v32 = 0;
        while ( 1 )
        {
          v33 = v7 - 1;
          if ( v30 >= v7 - 1 )
            break;
          if ( v31 < v7 && (v34 = *(unsigned __int16 *)&v16[4 * v31], *(unsigned __int16 *)&v16[4 * v32] >= v34) )
          {
            ++v31;
            *((_WORD *)v29 + 2) = v34;
          }
          else
          {
            v35 = *(_WORD *)&v16[4 * v32];
            v36 = 4 * v32++;
            *((_WORD *)v29 + 2) = v35;
            *(_WORD *)&v16[v36] = v30;
          }
          if ( v31 < v7
            && (v32 >= v30 || *(unsigned __int16 *)&v16[4 * v32] >= (unsigned int)*(unsigned __int16 *)&v16[4 * v31]) )
          {
            v39 = *(_WORD *)&v16[4 * v31++];
            *((_WORD *)v29 + 2) += v39;
          }
          else
          {
            v37 = *(_WORD *)&v16[4 * v32];
            v38 = 4 * v32++;
            *((_WORD *)v29 + 2) += v37;
            *(_WORD *)&v16[v38] = v30;
          }
          ++v30;
          v29 += 4;
        }
        *(_WORD *)&v16[4 * (v7 + 1073741822)] = 0;
        v40 = v7 - 3;
        for ( i = (int)&v16[4 * (v7 + 1073741822) + 8];
              ;
              *(_WORD *)(i - 8) = *(_WORD *)&v16[4 * *(unsigned __int16 *)(i - 8)] + 1 )
        {
          i -= 4;
          if ( v40 == -1 )
            break;
          --v40;
        }
        v42 = v7 - 2;
        v43 = 1;
        v44 = 0;
        do
        {
          v45 = (int)&v16[4 * v42];
          v46 = 0;
          while ( v42 != -1 && *(unsigned __int16 *)(v45 - 4 * v46) == v44 )
          {
            ++v46;
            --v42;
          }
          v47 = v33 - v43;
          for ( j = (int)&v16[4 * (v33 + 0x3FFFFFFF * v43)]; ; *(_WORD *)(j + 4 * v43--) = v44 )
          {
            v33 = v47 + v43;
            if ( v43 <= v46 )
              break;
          }
          v43 = 2 * v46;
          ++v44;
        }
        while ( 2 * v46 );
      }
    }
    v28 = 0;
    while ( v28 < v7 )
    {
      v49 = *(unsigned __int16 *)&v16[4 * v28++];
      ++*(_DWORD *)&s[4 * v49];
    }
    if ( v7 > 1 )
    {
      v51 = &s[4 * v6];
      v52 = v6 + 1;
      v53 = &s[4 * v6];
      while ( v52 <= 32 )
      {
        v54 = *((_DWORD *)v53 + 1);
        v53 += 4;
        ++v52;
        *(_DWORD *)v51 += v54;
      }
      v55 = 0;
      v56 = 0;
      while ( v6 - v55 > 0 )
      {
        v57 = *(_DWORD *)&v51[-4 * v55] << v55;
        ++v55;
        v56 += v57;
      }
      while ( v56 != 1 << v6 )
      {
        v58 = &s[4 * v6];
        --*(_DWORD *)v51;
        for ( k = v6 - 1; k > 0; --k )
        {
          v61 = *((_DWORD *)v58 - 1);
          v58 -= 4;
          v60 = v61;
          if ( v61 )
          {
            *(_DWORD *)v58 = v60 - 1;
            *(_DWORD *)&s[4 * (k + 1)] += 2;
            break;
          }
        }
        --v56;
      }
    }
    memset((void *)(288 * v73 + 36608 + v5 + 22), 0, 0x120u);
    result = (int)memset((void *)(v5 + 576 * v73 + 34902), 0, 0x240u);
    v50 = 1;
    while ( v50 <= v6 )
    {
      v62 = *(_DWORD *)&s[4 * v50];
      v63 = 0;
      v64 = *(_DWORD *)&s[4 * v50];
      while ( 1 )
      {
        v63 -= 4;
        if ( v64 <= 0 )
          break;
        --v64;
        *(_BYTE *)(*(unsigned __int16 *)&v16[4 * v7 + 2 + v63] + v5 + 288 * v73 + 36630) = v50;
      }
      result = v62 & ~(v62 >> 31);
      ++v50;
      v7 -= result;
    }
  }
  v65 = 2;
  v66 = 0;
  v81 = 0;
  while ( v65 <= v6 )
  {
    result = *(_DWORD *)&s[4 * v65 - 4];
    v66 = 2 * (v66 + result);
    *(_DWORD *)&v80[4 * v65++] = v66;
  }
  v67 = v5 + 288 * v73;
  for ( l = 0; l < v74; ++l )
  {
    result = *(unsigned __int8 *)(v67 + l + 36630);
    if ( *(_BYTE *)(v67 + l + 36630) )
    {
      v69 = *(_DWORD *)&v80[4 * result];
      *(_DWORD *)&v80[4 * result] = v69 + 1;
      v70 = 0;
      v71 = 0;
      while ( result != v70 )
      {
        ++v70;
        v71 = v69 & 1 | 2 * v71;
        v69 >>= 1;
      }
      *(_WORD *)(v67 + 288 * v73 + 2 * l + 34902) = v71;
    }
  }
  return result;
}
// 4DC0A: using guessed type char s[132];
// 4DC0A: using guessed type char var_1128[1152];
// 4DC0A: using guessed type char var_828[4];
// 4DC0A: using guessed type char var_1528[1024];

//----- (0004DFD6) --------------------------------------------------------
int __fastcall sub_4DFD6(_DWORD *a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  int v3; // r5
  int result; // r0
  int v5; // r3
  signed int v6; // r6
  int v7; // r3
  _BYTE *v8; // r3

  v1 = (int)a1 + 36630;
  v2 = a1;
  v3 = 0;
  do
    *(_BYTE *)(v1 + v3++) = 8;
  while ( v3 != 144 );
  do
    *(_BYTE *)(v1 + v3++) = 9;
  while ( v3 != 256 );
  do
    *(_BYTE *)(v1 + v3++) = 7;
  while ( v3 != 280 );
  do
    *(_BYTE *)(v1 + v3++) = 8;
  while ( v3 != 288 );
  memset((char *)a1 + 36918, 5, 0x20u);
  sub_4DC0A((int)v2, 0, 288, 15, 1);
  result = sub_4DC0A((int)v2, 1, 32, 15, 1);
  v5 = v2[18];
  v6 = 1 << v5;
  v7 = v5 + 2;
  v2[19] |= v6;
  while ( 1 )
  {
    v2[18] = v7;
    if ( v2[18] <= 7u )
      break;
    v8 = (_BYTE *)v2[13];
    if ( (unsigned int)v8 < v2[14] )
    {
      v2[13] = v8 + 1;
      *v8 = v2[19];
    }
    v2[19] >>= 8;
    v7 = v2[18] - 8;
  }
  return result;
}

//----- (0004E070) --------------------------------------------------------
unsigned int __fastcall sub_4E070(int a1)
{
  int v1; // r4
  signed int v2; // r3
  size_t v3; // r6
  signed int i; // r3
  size_t v5; // r8
  unsigned int v6; // r3
  unsigned int v7; // r1
  unsigned int v8; // r5
  int v9; // r10
  int v10; // lr
  int v11; // r9
  int v12; // r9
  __int16 v13; // r3
  int v14; // r3
  int v15; // r9
  __int16 v16; // r9
  char v17; // r1
  int v18; // r9
  __int16 v19; // r9
  int v20; // r1
  __int16 v21; // r2
  int v22; // r2
  __int16 v23; // r3
  int v24; // r3
  unsigned int v25; // r7
  int v26; // r2
  char *v27; // r0
  char v28; // r1
  char *v29; // r0
  int v30; // r3
  signed int v31; // r1
  int v32; // r3
  unsigned int v33; // r3
  int v34; // r2
  _BYTE *v35; // r3
  int v36; // r6
  int v37; // r3
  unsigned int v38; // r3
  int v39; // r2
  _BYTE *v40; // r3
  int v41; // r8
  int v42; // r3
  unsigned int v43; // r2
  _BYTE *v44; // r3
  signed int v45; // r3
  bool v46; // cf
  int v47; // r3
  unsigned int result; // r0
  int v49; // r2
  _BYTE *v50; // r2
  int j; // r2
  int v52; // r1
  int v53; // r7
  int v54; // r1
  _BYTE *v55; // r1
  unsigned int v56; // r3
  unsigned int v57; // r2
  int v58; // r7
  int v59; // r12
  int v60; // r8
  unsigned int v61; // r12
  _BYTE *v62; // r12
  int v63; // r2
  _BYTE *v64; // r2
  int v65; // r3
  int v66; // [sp+0h] [bp-2D0h]
  int v67; // [sp+Ch] [bp-2C4h]
  _WORD *v68; // [sp+10h] [bp-2C0h]
  unsigned int v69; // [sp+14h] [bp-2BCh]
  int *v70; // [sp+18h] [bp-2B8h]
  char *v71; // [sp+1Ch] [bp-2B4h]
  char dest[320]; // [sp+24h] [bp-2ACh]
  char v73[320]; // [sp+164h] [bp-16Ch]

  v1 = a1;
  *(_WORD *)(a1 + 33686) = 1;
  sub_4DC0A(a1, 0, 288, 15, 0);
  sub_4DC0A(v1, 1, 32, 15, 0);
  v2 = 286;
  v70 = (int *)&_stack_chk_guard;
  while ( 1 )
  {
    v3 = v2 - 1;
    if ( *(_BYTE *)(v1 + v2 - 1 + 36630) )
      break;
    if ( v3 == 257 )
      goto LABEL_6;
    --v2;
  }
  v3 = v2;
LABEL_6:
  for ( i = 30; ; --i )
  {
    v5 = i - 1;
    if ( *(_BYTE *)(v1 + i - 1 + 36918) )
      break;
    if ( v5 == 1 )
      goto LABEL_11;
  }
  v5 = i;
LABEL_11:
  memcpy(dest, (const void *)(v1 + 36630), v3);
  memcpy(&dest[v3], (const void *)(v1 + 36918), v5);
  v69 = v3 + v5;
  v68 = (_WORD *)(v1 + 34326);
  memset((void *)(v1 + 34326), 0, 0x26u);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v67 = 255;
  v71 = dest;
  while ( 1 )
  {
    v10 = *((unsigned __int8 *)&v66 + v9 + 36);
    if ( *((_BYTE *)&v66 + v9 + 36) )
    {
      if ( v7 )
      {
        if ( v7 > 2 )
        {
          if ( v7 > 0xA )
          {
            v19 = *(_WORD *)(v1 + 34362);
            v17 = v7 - 11;
            v73[v8] = 18;
            *(_WORD *)(v1 + 34362) = v19 + 1;
          }
          else
          {
            v16 = *(_WORD *)(v1 + 34360);
            v17 = v7 - 3;
            v73[v8] = 17;
            *(_WORD *)(v1 + 34360) = v16 + 1;
          }
          v18 = v8 + 1;
          v8 += 2;
          v73[v18] = v17;
        }
        else
        {
          *v68 += v7;
          v15 = 0;
          do
            v73[v8 + v15++] = 0;
          while ( v15 != v7 );
          v8 += v15;
        }
      }
      if ( v10 != v67 )
      {
        if ( v6 )
        {
          if ( v6 > 2 )
          {
            v21 = *(_WORD *)(v1 + 34358);
            v73[v8] = 16;
            *(_WORD *)(v1 + 34358) = v21 + 1;
            v22 = v8 + 1;
            v8 += 2;
            v73[v22] = v6 - 3;
          }
          else
          {
            *(_WORD *)(v1 + 2 * v67 + 34326) += v6;
            v20 = 0;
            do
              v73[v8 + v20++] = v67;
            while ( v20 != v6 );
            v8 += v20;
          }
        }
        v73[v8++] = v10;
        ++*(_WORD *)(v1 + 2 * v10 + 34326);
        goto LABEL_41;
      }
      if ( ++v6 == 6 )
      {
        v23 = *(_WORD *)(v1 + 34358);
        v73[v8] = 16;
        *(_WORD *)(v1 + 34358) = v23 + 1;
        v24 = v8 + 1;
        v8 += 2;
        v73[v24] = 3;
LABEL_41:
        v6 = 0;
        v7 = 0;
        goto LABEL_44;
      }
      v7 = 0;
    }
    else
    {
      if ( v6 )
      {
        if ( v6 > 2 )
        {
          v12 = v8 + 1;
          ++*(_WORD *)(v1 + 34358);
          v73[v8] = 16;
          v8 += 2;
          v73[v12] = v6 - 3;
        }
        else
        {
          *(_WORD *)(v1 + 2 * v67 + 34326) += v6;
          v11 = v10;
          do
            v73[v8 + v11++] = v67;
          while ( v11 != v6 );
          v8 += v11;
        }
      }
      if ( ++v7 == 138 )
      {
        v13 = *(_WORD *)(v1 + 34362);
        v73[v8] = 18;
        v7 = 0;
        *(_WORD *)(v1 + 34362) = v13 + 1;
        v14 = v8 + 1;
        v8 += 2;
        v73[v14] = 127;
      }
      v6 = 0;
    }
LABEL_44:
    if ( ++v9 >= v69 )
      break;
    v67 = v10;
  }
  v25 = v8;
  if ( v6 )
  {
    if ( v6 > 2 )
    {
      ++*(_WORD *)(v1 + 34358);
      v73[v8] = 16;
      v27 = &v73[v8];
      v8 += 2;
      v27[1] = v6 - 3;
    }
    else
    {
      *(_WORD *)(v1 + 2 * v10 + 34326) += v6;
      v26 = 0;
      do
        v73[v8 + v26++] = v10;
      while ( v26 != v6 );
      v8 += v26;
    }
  }
  else if ( v7 )
  {
    if ( v7 > 2 )
    {
      if ( v7 > 0xA )
      {
        v28 = v7 - 11;
        ++*(_WORD *)(v1 + 34362);
        v73[v8] = 18;
        v29 = &v73[v8];
        v8 += 2;
      }
      else
      {
        v28 = v7 - 3;
        ++*(_WORD *)(v1 + 34360);
        v73[v8] = 17;
        v8 += 2;
        v29 = &v73[v25];
      }
      v29[1] = v28;
    }
    else
    {
      *(_WORD *)(v1 + 34326) += v7;
      do
        v73[v8 + v6++] = 0;
      while ( v6 != v7 );
      v8 += v6;
    }
  }
  sub_4DC0A(v1, 2, 19, 7, 0);
  v30 = *(_DWORD *)(v1 + 72);
  v31 = 2 << v30;
  v32 = v30 + 2;
  *(_DWORD *)(v1 + 76) |= v31;
  while ( 1 )
  {
    *(_DWORD *)(v1 + 72) = v32;
    v33 = *(_DWORD *)(v1 + 72);
    v34 = *(_DWORD *)(v1 + 76);
    if ( v33 <= 7 )
      break;
    v35 = *(_BYTE **)(v1 + 52);
    if ( (unsigned int)v35 < *(_DWORD *)(v1 + 56) )
    {
      *(_DWORD *)(v1 + 52) = v35 + 1;
      *v35 = v34;
    }
    *(_DWORD *)(v1 + 76) >>= 8;
    v32 = *(_DWORD *)(v1 + 72) - 8;
  }
  v36 = (v3 - 257) << v33;
  v37 = v33 + 5;
  *(_DWORD *)(v1 + 76) = v34 | v36;
  while ( 1 )
  {
    *(_DWORD *)(v1 + 72) = v37;
    v38 = *(_DWORD *)(v1 + 72);
    v39 = *(_DWORD *)(v1 + 76);
    if ( v38 <= 7 )
      break;
    v40 = *(_BYTE **)(v1 + 52);
    if ( (unsigned int)v40 < *(_DWORD *)(v1 + 56) )
    {
      *(_DWORD *)(v1 + 52) = v40 + 1;
      *v40 = v39;
    }
    *(_DWORD *)(v1 + 76) >>= 8;
    v37 = *(_DWORD *)(v1 + 72) - 8;
  }
  v41 = (v5 - 1) << v38;
  v42 = v38 + 5;
  *(_DWORD *)(v1 + 76) = v39 | v41;
  while ( 1 )
  {
    *(_DWORD *)(v1 + 72) = v42;
    v43 = *(_DWORD *)(v1 + 72);
    if ( v43 <= 7 )
      break;
    v44 = *(_BYTE **)(v1 + 52);
    if ( (unsigned int)v44 < *(_DWORD *)(v1 + 56) )
    {
      *(_DWORD *)(v1 + 52) = v44 + 1;
      *v44 = *(_DWORD *)(v1 + 76);
    }
    *(_DWORD *)(v1 + 76) >>= 8;
    v42 = *(_DWORD *)(v1 + 72) - 8;
  }
  v45 = 18;
  while ( !*(_BYTE *)(*((unsigned __int8 *)&dword_E9BF4[529] + v45) + v1 + 37206) )
  {
    v46 = v45-- != 0;
    if ( !v46 )
      goto LABEL_82;
  }
  if ( v45 > 2 )
  {
    v47 = v45 + 1;
    goto LABEL_83;
  }
LABEL_82:
  v47 = 4;
LABEL_83:
  result = (v47 - 4) << v43;
  v49 = v43 + 4;
  *(_DWORD *)(v1 + 76) |= result;
  while ( 1 )
  {
    *(_DWORD *)(v1 + 72) = v49;
    if ( *(_DWORD *)(v1 + 72) <= 7u )
      break;
    v50 = *(_BYTE **)(v1 + 52);
    if ( (unsigned int)v50 < *(_DWORD *)(v1 + 56) )
    {
      *(_DWORD *)(v1 + 52) = v50 + 1;
      *v50 = *(_DWORD *)(v1 + 76);
    }
    *(_DWORD *)(v1 + 76) >>= 8;
    v49 = *(_DWORD *)(v1 + 72) - 8;
  }
  for ( j = 0; j < v47; ++j )
  {
    v52 = *(_DWORD *)(v1 + 72);
    v53 = *(unsigned __int8 *)(*((unsigned __int8 *)&dword_E9BF4[529] + j) + v1 + 37206) << v52;
    v54 = v52 + 3;
    result = *(_DWORD *)(v1 + 76) | v53;
    *(_DWORD *)(v1 + 76) = result;
    while ( 1 )
    {
      *(_DWORD *)(v1 + 72) = v54;
      if ( *(_DWORD *)(v1 + 72) <= 7u )
        break;
      v55 = *(_BYTE **)(v1 + 52);
      result = *(_DWORD *)(v1 + 56);
      if ( (unsigned int)v55 < result )
      {
        *(_DWORD *)(v1 + 52) = v55 + 1;
        result = *(_DWORD *)(v1 + 76);
        *v55 = result;
      }
      *(_DWORD *)(v1 + 76) >>= 8;
      v54 = *(_DWORD *)(v1 + 72) - 8;
    }
  }
  v56 = 0;
  while ( v56 < v8 )
  {
    v57 = (unsigned __int8)v73[v56];
    v58 = v56 + 1;
    v59 = *(_DWORD *)(v1 + 72);
    v60 = *(unsigned __int8 *)(v1 + v57 + 37206);
    *(_DWORD *)(v1 + 76) |= *(unsigned __int16 *)(v1 + 2 * (v57 + 17920) + 214) << v59;
    for ( result = v60 + v59; ; result = *(_DWORD *)(v1 + 72) - 8 )
    {
      *(_DWORD *)(v1 + 72) = result;
      v61 = *(_DWORD *)(v1 + 72);
      if ( v61 <= 7 )
        break;
      v62 = *(_BYTE **)(v1 + 52);
      if ( (unsigned int)v62 < *(_DWORD *)(v1 + 56) )
      {
        *(_DWORD *)(v1 + 52) = v62 + 1;
        *v62 = *(_DWORD *)(v1 + 76);
      }
      *(_DWORD *)(v1 + 76) >>= 8;
    }
    if ( v57 > 0xF )
    {
      v56 += 2;
      v63 = byte_E4483[v57 - 16] + v61;
      result = *(_DWORD *)(v1 + 76) | ((unsigned __int8)v73[v58] << v61);
      *(_DWORD *)(v1 + 76) = result;
      while ( 1 )
      {
        *(_DWORD *)(v1 + 72) = v63;
        if ( *(_DWORD *)(v1 + 72) <= 7u )
          break;
        v64 = *(_BYTE **)(v1 + 52);
        result = *(_DWORD *)(v1 + 56);
        if ( (unsigned int)v64 < result )
        {
          *(_DWORD *)(v1 + 52) = v64 + 1;
          result = *(_DWORD *)(v1 + 76);
          *v64 = result;
        }
        *(_DWORD *)(v1 + 76) >>= 8;
        v63 = *(_DWORD *)(v1 + 72) - 8;
      }
    }
    else
    {
      ++v56;
    }
  }
  v65 = *v70;
  return result;
}
// 4E070: using guessed type char dest[320];
// 4E070: using guessed type char var_16C[320];

//----- (0004E588) --------------------------------------------------------
int __fastcall sub_4E588(_DWORD *a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r3
  _DWORD *v3; // r3
  int v4; // r2
  size_t v5; // r5
  int v6; // r5
  int *v7; // r3
  int result; // r0

  v1 = a1;
  v2 = (_DWORD *)a1[31];
  if ( v2 )
    *v2 = a1[34] - a1[29];
  v3 = (_DWORD *)a1[32];
  if ( v3 )
  {
    v4 = a1[36];
    v5 = *v3 - v4;
    if ( v5 >= a1[24] )
      v5 = a1[24];
    memcpy((void *)(a1[30] + v4), (char *)a1 + a1[23] + 234102, v5);
    v1[23] += v5;
    v1[24] -= v5;
    v6 = v5 + v1[36];
    v7 = (int *)v1[32];
    v1[36] = v6;
    *v7 = v6;
  }
  result = v1[25];
  if ( result )
    result = v1[24] == 0;
  return result;
}

//----- (0004E5F2) --------------------------------------------------------
int __fastcall sub_4E5F2(void *src, size_t n, int a3)
{
  void *v3; // r8
  size_t v4; // r7
  size_t v5; // r5
  size_t *v6; // r4
  size_t v7; // r6
  void *v9; // r0

  v3 = src;
  v4 = n;
  v5 = *(_DWORD *)(a3 + 4);
  v6 = (size_t *)a3;
  v7 = *(_DWORD *)a3 + n;
  if ( v7 > v5 )
  {
    if ( !*(_DWORD *)(a3 + 12) )
      return 0;
    do
    {
      v5 *= 2;
      if ( v5 < 0x80 )
        v5 = 128;
    }
    while ( v7 > v5 );
    v9 = realloc(*(void **)(a3 + 8), v5);
    if ( !v9 )
      return 0;
    v6[2] = (size_t)v9;
    v6[1] = v5;
  }
  memcpy((void *)(*v6 + v6[2]), v3, v4);
  *v6 = v7;
  return 1;
}

//----- (0004E644) --------------------------------------------------------
signed int __fastcall sub_4E644(int a1, int a2)
{
  int v2; // r4
  int v3; // r9
  int v4; // r2
  int v5; // r3
  char *v6; // r5
  int v7; // r3
  int v8; // r3
  int v9; // r0
  int v10; // r3
  int v11; // r3
  signed int v12; // r0
  int v13; // r3
  unsigned int v14; // r3
  int v15; // r1
  _BYTE *v16; // r3
  signed int v17; // r0
  int v18; // r3
  _BYTE *v19; // r3
  unsigned int v20; // r7
  int v21; // r10
  _BYTE *v22; // r6
  _BOOL4 v23; // r0
  unsigned int v24; // r3
  _BYTE *v25; // r3
  unsigned int v26; // r3
  int i; // r3
  _BYTE *v28; // r3
  _BYTE *v29; // r2
  int v30; // r2
  int v31; // r2
  int v32; // r0
  _BYTE *v33; // r2
  int v34; // r2
  int v35; // r2
  int v36; // r0
  unsigned int v37; // r2
  int v38; // r6
  int v39; // r2
  unsigned int v40; // r6
  int v41; // r3
  unsigned int v42; // r2
  signed int v43; // r3
  int j; // r3
  _BYTE *v45; // r3
  _BYTE *v46; // r1
  int v47; // r1
  int v48; // r1
  unsigned int v49; // r6
  int k; // r3
  unsigned int v51; // r3
  _BYTE *v52; // r3
  signed int v53; // r3
  int v54; // r2
  int l; // r3
  _BYTE *v56; // r3
  _BYTE *v57; // r1
  int v58; // r1
  int v59; // r1
  int v60; // r6
  int v61; // r0
  signed int result; // r0
  int v63; // r3
  size_t v64; // r7
  int v65; // r6

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 8) & 0x100000;
  if ( v4 )
    v4 = (unsigned int)(*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 68)) <= *(_DWORD *)(a1 + 40);
  if ( *(_DWORD *)a1 || (v5 = *(_DWORD *)(a1 + 144), (unsigned int)(**(_DWORD **)(a1 + 128) - v5) <= 0x14CCB) )
    v6 = (char *)(a1 + 234102);
  else
    v6 = (char *)(*(_DWORD *)(a1 + 120) + v5);
  *(_DWORD *)(a1 + 52) = v6;
  *(_DWORD *)(a1 + 56) = v6 + 85180;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  **(_BYTE **)(a1 + 48) = (signed int)**(unsigned __int8 **)(a1 + 48) >> *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)(a1 + 60) == 8 )
    v7 = *(_DWORD *)(a1 + 44) - 1;
  else
    v7 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = v7;
  if ( *(_DWORD *)(a1 + 8) & 0x1000 && !*(_DWORD *)(a1 + 104) )
  {
    v11 = *(_DWORD *)(a1 + 72);
    v12 = 120 << v11;
    v13 = v11 + 8;
    *(_DWORD *)(v2 + 76) |= v12;
    while ( 1 )
    {
      *(_DWORD *)(v2 + 72) = v13;
      v14 = *(_DWORD *)(v2 + 72);
      v15 = *(_DWORD *)(v2 + 76);
      if ( v14 <= 7 )
        break;
      v16 = *(_BYTE **)(v2 + 52);
      if ( (unsigned int)v16 < *(_DWORD *)(v2 + 56) )
      {
        *(_DWORD *)(v2 + 52) = v16 + 1;
        *v16 = v15;
      }
      *(_DWORD *)(v2 + 76) >>= 8;
      v13 = *(_DWORD *)(v2 + 72) - 8;
    }
    v17 = 1 << v14;
    v18 = v14 + 8;
    *(_DWORD *)(v2 + 76) = v15 | v17;
    while ( 1 )
    {
      *(_DWORD *)(v2 + 72) = v18;
      if ( *(_DWORD *)(v2 + 72) <= 7u )
        break;
      v19 = *(_BYTE **)(v2 + 52);
      if ( (unsigned int)v19 < *(_DWORD *)(v2 + 56) )
      {
        *(_DWORD *)(v2 + 52) = v19 + 1;
        *v19 = *(_DWORD *)(v2 + 76);
      }
      *(_DWORD *)(v2 + 76) >>= 8;
      v18 = *(_DWORD *)(v2 + 72) - 8;
    }
  }
  v8 = *(_DWORD *)(v2 + 72);
  v9 = ((unsigned int)(v3 - 4) <= 0) << v8;
  v10 = v8 + 1;
  *(_DWORD *)(v2 + 76) |= v9;
  while ( 1 )
  {
    *(_DWORD *)(v2 + 72) = v10;
    v20 = *(_DWORD *)(v2 + 72);
    v21 = *(_DWORD *)(v2 + 76);
    v22 = *(_BYTE **)(v2 + 52);
    if ( v20 <= 7 )
      break;
    if ( (unsigned int)v22 < *(_DWORD *)(v2 + 56) )
    {
      *(_DWORD *)(v2 + 52) = v22 + 1;
      *v22 = v21;
    }
    *(_DWORD *)(v2 + 76) >>= 8;
    v10 = *(_DWORD *)(v2 + 72) - 8;
  }
  if ( v4 )
  {
    v23 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v2 + 8) & 0x80000 || *(_DWORD *)(v2 + 64) <= 0x2Fu )
      sub_4DFD6((_DWORD *)v2);
    else
      sub_4E070(v2);
    v23 = sub_4D8C8(v2);
    v37 = *(_DWORD *)(v2 + 64);
    if ( !v37 || *(_DWORD *)(v2 + 52) - (signed int)v22 + 1 < v37 )
      goto LABEL_60;
  }
  if ( (unsigned int)(*(_DWORD *)(v2 + 32) - *(_DWORD *)(v2 + 68)) <= *(_DWORD *)(v2 + 40) )
  {
    *(_DWORD *)(v2 + 52) = v22;
    *(_DWORD *)(v2 + 76) = v21;
    for ( *(_DWORD *)(v2 + 72) = v20 + 2; ; *(_DWORD *)(v2 + 72) -= 8 )
    {
      v24 = *(_DWORD *)(v2 + 72);
      if ( v24 <= 7 )
        break;
      v25 = *(_BYTE **)(v2 + 52);
      if ( (unsigned int)v25 < *(_DWORD *)(v2 + 56) )
      {
        *(_DWORD *)(v2 + 52) = v25 + 1;
        *v25 = *(_DWORD *)(v2 + 76);
      }
      *(_DWORD *)(v2 + 76) >>= 8;
    }
    if ( v24 )
    {
      for ( i = 8; ; i = *(_DWORD *)(v2 + 72) - 8 )
      {
        *(_DWORD *)(v2 + 72) = i;
        if ( *(_DWORD *)(v2 + 72) <= 7u )
          break;
        v28 = *(_BYTE **)(v2 + 52);
        if ( (unsigned int)v28 < *(_DWORD *)(v2 + 56) )
        {
          *(_DWORD *)(v2 + 52) = v28 + 1;
          *v28 = *(_DWORD *)(v2 + 76);
        }
        *(_DWORD *)(v2 + 76) >>= 8;
      }
    }
    v26 = 2;
    do
    {
      v31 = *(_DWORD *)(v2 + 72);
      v32 = *(unsigned __int16 *)(v2 + 64) << v31;
      v30 = v31 + 16;
      *(_DWORD *)(v2 + 76) |= v32;
      while ( 1 )
      {
        *(_DWORD *)(v2 + 72) = v30;
        if ( *(_DWORD *)(v2 + 72) <= 7u )
          break;
        v29 = *(_BYTE **)(v2 + 52);
        if ( (unsigned int)v29 < *(_DWORD *)(v2 + 56) )
        {
          *(_DWORD *)(v2 + 52) = v29 + 1;
          *v29 = *(_DWORD *)(v2 + 76);
        }
        *(_DWORD *)(v2 + 76) >>= 8;
        v30 = *(_DWORD *)(v2 + 72) - 8;
      }
      --v26;
      *(_DWORD *)(v2 + 64) ^= 0xFFFFu;
    }
    while ( v26 );
    while ( v26 < *(_DWORD *)(v2 + 64) )
    {
      v35 = *(_DWORD *)(v2 + 72);
      v36 = *(unsigned __int8 *)((((unsigned __int16)*(_DWORD *)(v2 + 68) + (_WORD)v26) & 0x7FFF) + v2 + 148) << v35;
      v34 = v35 + 8;
      *(_DWORD *)(v2 + 76) |= v36;
      while ( 1 )
      {
        *(_DWORD *)(v2 + 72) = v34;
        if ( *(_DWORD *)(v2 + 72) <= 7u )
          break;
        v33 = *(_BYTE **)(v2 + 52);
        if ( (unsigned int)v33 < *(_DWORD *)(v2 + 56) )
        {
          *(_DWORD *)(v2 + 52) = v33 + 1;
          *v33 = *(_DWORD *)(v2 + 76);
        }
        *(_DWORD *)(v2 + 76) >>= 8;
        v34 = *(_DWORD *)(v2 + 72) - 8;
      }
      ++v26;
    }
    goto LABEL_62;
  }
LABEL_60:
  if ( !v23 )
  {
    *(_DWORD *)(v2 + 52) = v22;
    *(_DWORD *)(v2 + 76) = v21;
    *(_DWORD *)(v2 + 72) = v20;
    sub_4DFD6((_DWORD *)v2);
    sub_4D8C8(v2);
  }
LABEL_62:
  if ( v3 )
  {
    v41 = *(_DWORD *)(v2 + 72);
    if ( (unsigned int)(v3 - 4) <= 0 )
    {
      if ( v41 )
      {
        for ( j = 8; ; j = *(_DWORD *)(v2 + 72) - 8 )
        {
          *(_DWORD *)(v2 + 72) = j;
          if ( *(_DWORD *)(v2 + 72) <= 7u )
            break;
          v45 = *(_BYTE **)(v2 + 52);
          if ( (unsigned int)v45 < *(_DWORD *)(v2 + 56) )
          {
            *(_DWORD *)(v2 + 52) = v45 + 1;
            *v45 = *(_DWORD *)(v2 + 76);
          }
          *(_DWORD *)(v2 + 76) >>= 8;
        }
      }
      if ( *(_DWORD *)(v2 + 8) & 0x1000 )
      {
        v42 = *(_DWORD *)(v2 + 24);
        v43 = 4;
        do
        {
          v48 = *(_DWORD *)(v2 + 72);
          v49 = v42 >> 24 << v48;
          v47 = v48 + 8;
          *(_DWORD *)(v2 + 76) |= v49;
          while ( 1 )
          {
            *(_DWORD *)(v2 + 72) = v47;
            if ( *(_DWORD *)(v2 + 72) <= 7u )
              break;
            v46 = *(_BYTE **)(v2 + 52);
            if ( (unsigned int)v46 < *(_DWORD *)(v2 + 56) )
            {
              *(_DWORD *)(v2 + 52) = v46 + 1;
              *v46 = *(_DWORD *)(v2 + 76);
            }
            *(_DWORD *)(v2 + 76) >>= 8;
            v47 = *(_DWORD *)(v2 + 72) - 8;
          }
          --v43;
          v42 <<= 8;
        }
        while ( v43 );
      }
    }
    else
    {
      for ( k = v41 + 3; ; k = *(_DWORD *)(v2 + 72) - 8 )
      {
        *(_DWORD *)(v2 + 72) = k;
        v51 = *(_DWORD *)(v2 + 72);
        if ( v51 <= 7 )
          break;
        v52 = *(_BYTE **)(v2 + 52);
        if ( (unsigned int)v52 < *(_DWORD *)(v2 + 56) )
        {
          *(_DWORD *)(v2 + 52) = v52 + 1;
          *v52 = *(_DWORD *)(v2 + 76);
        }
        *(_DWORD *)(v2 + 76) >>= 8;
      }
      if ( v51 )
      {
        for ( l = 8; ; l = *(_DWORD *)(v2 + 72) - 8 )
        {
          *(_DWORD *)(v2 + 72) = l;
          if ( *(_DWORD *)(v2 + 72) <= 7u )
            break;
          v56 = *(_BYTE **)(v2 + 52);
          if ( (unsigned int)v56 < *(_DWORD *)(v2 + 56) )
          {
            *(_DWORD *)(v2 + 52) = v56 + 1;
            *v56 = *(_DWORD *)(v2 + 76);
          }
          *(_DWORD *)(v2 + 76) >>= 8;
        }
      }
      v53 = 2;
      v54 = 0;
      do
      {
        v59 = *(_DWORD *)(v2 + 72);
        v60 = v54 << v59;
        v58 = v59 + 16;
        *(_DWORD *)(v2 + 76) |= v60;
        while ( 1 )
        {
          *(_DWORD *)(v2 + 72) = v58;
          if ( *(_DWORD *)(v2 + 72) <= 7u )
            break;
          v57 = *(_BYTE **)(v2 + 52);
          if ( (unsigned int)v57 < *(_DWORD *)(v2 + 56) )
          {
            *(_DWORD *)(v2 + 52) = v57 + 1;
            *v57 = *(_DWORD *)(v2 + 76);
          }
          *(_DWORD *)(v2 + 76) >>= 8;
          v58 = *(_DWORD *)(v2 + 72) - 8;
        }
        --v53;
        v54 ^= 0xFFFFu;
      }
      while ( v53 );
    }
  }
  memset((void *)(v2 + 33174), 0, 0x240u);
  memset((void *)(v2 + 33750), 0, 0x40u);
  v38 = *(_DWORD *)(v2 + 52);
  *(_DWORD *)(v2 + 44) = v2 + 37495;
  *(_DWORD *)(v2 + 48) = v2 + 37494;
  v39 = *(_DWORD *)(v2 + 68);
  v40 = v38 - (_DWORD)v6;
  *(_DWORD *)(v2 + 60) = 8;
  *(_DWORD *)(v2 + 68) = *(_DWORD *)(v2 + 64) + v39;
  *(_DWORD *)(v2 + 64) = 0;
  ++*(_DWORD *)(v2 + 104);
  if ( v40 )
  {
    v61 = v2 + 234102;
    if ( *(_DWORD *)v2 )
    {
      **(_DWORD **)(v2 + 124) = *(_DWORD *)(v2 + 136) - *(_DWORD *)(v2 + 116);
      if ( !(*(int (__fastcall **)(int, unsigned int, _DWORD))v2)(v61, v40, *(_DWORD *)(v2 + 4)) )
      {
        result = -1;
        *(_DWORD *)(v2 + 112) = -1;
        return result;
      }
    }
    else
    {
      v63 = *(_DWORD *)(v2 + 144);
      if ( v6 == (char *)v61 )
      {
        v64 = **(_DWORD **)(v2 + 128) - v63;
        if ( v40 < v64 )
          v64 = v40;
        memcpy((void *)(*(_DWORD *)(v2 + 120) + v63), v6, v64);
        v65 = v40 - v64;
        *(_DWORD *)(v2 + 144) += v64;
        if ( v65 )
        {
          *(_DWORD *)(v2 + 92) = v64;
          *(_DWORD *)(v2 + 96) = v65;
        }
      }
      else
      {
        *(_DWORD *)(v2 + 144) = v40 + v63;
      }
    }
  }
  return *(_DWORD *)(v2 + 96);
}

//----- (0004EA74) --------------------------------------------------------
int __fastcall mz_adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // r4
  unsigned int v4; // r5
  unsigned int v5; // r6
  unsigned int v6; // r8
  unsigned int v7; // r7
  unsigned __int8 *v8; // r3
  int v9; // r1
  int v10; // r5
  int v11; // r6
  int v12; // r5
  int v13; // r6
  int v14; // r5
  int v15; // r6
  int v16; // r5
  int v17; // r6
  int v18; // r5
  int v19; // r6
  int v20; // r5
  int v21; // r6
  int v22; // r5
  int v23; // r6
  unsigned int v24; // r3
  int v25; // t1

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  v6 = a3;
  v7 = a3 % 0x15B0;
  if ( !a2 )
    return 1;
  while ( v6 )
  {
    v8 = v3;
    while ( (unsigned int)&v8[7 - (_DWORD)v3] < v7 )
    {
      v9 = *v8;
      v8 += 8;
      v10 = v4 + v9;
      v11 = v5 + v10;
      v12 = v10 + *(v8 - 7);
      v13 = v11 + v12;
      v14 = v12 + *(v8 - 6);
      v15 = v13 + v14;
      v16 = v14 + *(v8 - 5);
      v17 = v15 + v16;
      v18 = v16 + *(v8 - 4);
      v19 = v17 + v18;
      v20 = v18 + *(v8 - 3);
      v21 = v19 + v20;
      v22 = v20 + *(v8 - 2);
      v23 = v21 + v22;
      v4 = v22 + *(v8 - 1);
      v5 = v23 + v4;
    }
    v3 += v7 & 0xFFFFFFF8;
    v24 = (v7 & 0xFFFFFFF8) - (_DWORD)v3;
    while ( (unsigned int)&v3[v24] < v7 )
    {
      v25 = *v3++;
      v4 += v25;
      v5 += v4;
    }
    v6 -= v7;
    v7 = 5552;
    v4 %= 0xFFF1u;
    v5 %= 0xFFF1u;
  }
  return v4 + (v5 << 16);
}

//----- (0004EB2C) --------------------------------------------------------
int __fastcall mz_crc32(int a1, unsigned __int8 *a2, int a3)
{
  int v3; // r2
  unsigned int v4; // r0
  unsigned int v5; // t1
  unsigned int v6; // r0

  if ( !a2 )
    return 0;
  v3 = (int)&a2[a3];
  v4 = ~a1;
  while ( a2 != (unsigned __int8 *)v3 )
  {
    v5 = *a2++;
    v6 = dword_E9BF4[(((unsigned __int8)v4 ^ (unsigned __int8)v5) & 0xF) + 534] ^ (v4 >> 4);
    v4 = dword_E9BF4[(v6 & 0xF ^ (v5 >> 4)) + 534] ^ (v6 >> 4);
  }
  return ~v4;
}

//----- (0004EB78) --------------------------------------------------------
const char *mz_version()
{
  return "9.1.12";
}

//----- (0004EB84) --------------------------------------------------------
signed int __fastcall mz_deflateEnd(int a1)
{
  int v1; // r4
  signed int result; // r0

  v1 = a1;
  if ( !a1 )
    return -2;
  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  (*(void (__fastcall **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
  result = 0;
  *(_DWORD *)(v1 + 28) = 0;
  return result;
}

//----- (0004EBA4) --------------------------------------------------------
unsigned int __fastcall mz_deflateBound(int a1, unsigned int a2)
{
  unsigned int result; // r0

  result = 110 * a2 / 0x64 + 128;
  if ( a2 + 128 + 5 * (a2 / 0x7C00 + 1) >= result )
    result = a2 + 128 + 5 * (a2 / 0x7C00 + 1);
  return result;
}

//----- (0004EBD2) --------------------------------------------------------
unsigned int __fastcall mz_compressBound(unsigned int a1)
{
  return mz_deflateBound(0, a1);
}

//----- (0004EBDC) --------------------------------------------------------
signed int __fastcall mz_inflateInit2(_DWORD *a1, int a2)
{
  int v2; // r5
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r2
  signed int result; // r0

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return -2;
  if ( a2 != 15 && a2 != -15 )
    return -10000;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[6] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[14] = 0;
  if ( !a1[8] )
    a1[8] = sub_4DC02;
  if ( !a1[9] )
    a1[9] = sub_4DBFC;
  v4 = (_DWORD *)((int (__fastcall *)(_DWORD, signed int, signed int))a1[8])(a1[10], 1, 43800);
  if ( !v4 )
    return -4;
  v3[7] = v4;
  v5 = v4 + 2752;
  *v4 = 0;
  *v5 = 0;
  v5[1] = 0;
  v4[10949] = 1;
  result = 0;
  v5[2] = 1;
  v5[3] = 0;
  v5[4] = v2;
  return result;
}
// 4DBFC: using guessed type int sub_4DBFC();
// 4DC02: using guessed type int sub_4DC02();

//----- (0004EC60) --------------------------------------------------------
signed int __fastcall mz_inflateInit(_DWORD *a1)
{
  return mz_inflateInit2(a1, 15);
}

//----- (0004EC66) --------------------------------------------------------
signed int __fastcall mz_inflateEnd(int a1)
{
  int v1; // r4
  signed int result; // r0

  v1 = a1;
  if ( !a1 )
    return -2;
  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  (*(void (__fastcall **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
  result = 0;
  *(_DWORD *)(v1 + 28) = 0;
  return result;
}

//----- (0004EC88) --------------------------------------------------------
int __fastcall mz_error(int a1)
{
  int v1; // r3

  v1 = 0;
  do
  {
    if ( *((_DWORD *)&unk_EF5A0 + 2 * v1) == a1 )
      return *((_DWORD *)&unk_EF5A0 + 2 * v1 + 1);
    ++v1;
  }
  while ( v1 != 10 );
  return 0;
}

//----- (0004ECB0) --------------------------------------------------------
signed int __fastcall tinfl_decompress(int a1, _BYTE *a2, _DWORD *a3, unsigned int a4, char *a5, unsigned int *a6, char a7)
{
  int v7; // r7
  _BYTE *v8; // r10
  signed int result; // r0
  unsigned int v10; // r9
  unsigned int v11; // r11
  signed int v12; // r4
  char *v13; // r8
  char *v14; // r6
  int v15; // r3
  int v16; // r3
  unsigned int v17; // r4
  int v18; // r8
  int v19; // r3
  _BOOL4 v20; // r2
  int v21; // r4
  int v22; // r0
  signed int v23; // r3
  unsigned __int64 v24; // r0
  unsigned int v25; // r3
  int v26; // r0
  unsigned __int64 v27; // r0
  unsigned __int64 v28; // r0
  int v29; // r0
  unsigned __int64 v30; // r0
  char v31; // r2
  signed int v32; // r3
  int v33; // r0
  unsigned __int64 v34; // r0
  signed int v35; // r3
  size_t v36; // r4
  char *v37; // r0
  char *v38; // r1
  int v39; // r4
  unsigned int v40; // r3
  int v41; // r0
  unsigned __int64 v42; // r0
  int v43; // r4
  unsigned __int64 v44; // r0
  int v45; // r3
  _DWORD *v46; // r2
  int v47; // r0
  unsigned __int64 v48; // r0
  char v49; // r2
  char *v50; // r3
  int v51; // r0
  int v52; // r4
  unsigned int v53; // r4
  unsigned __int64 v54; // r0
  signed int j; // r5
  int v56; // r3
  size_t v57; // r2
  unsigned int v58; // r3
  __int16 v59; // r3
  int v60; // r4
  int v61; // r5
  signed int k; // r2
  bool v63; // cf
  int v64; // r0
  unsigned __int64 v65; // r0
  unsigned __int64 v66; // r0
  int v67; // r3
  size_t v68; // r4
  unsigned int v69; // r0
  unsigned __int64 v70; // r0
  char v71; // r2
  int v72; // r3
  int v73; // r3
  int v74; // r4
  int v75; // ST0C_4
  int v76; // r0
  int v77; // r3
  int v78; // r2
  int v79; // r3
  int v80; // r2
  unsigned int v81; // r1
  int v82; // r12
  int v83; // r2
  char *v84; // r12
  unsigned int v85; // r0
  signed int v86; // r3
  int v87; // r2
  unsigned int v88; // r1
  char *v89; // r2
  unsigned int v90; // r5
  int v91; // r12
  unsigned int v92; // r2
  __int16 v93; // r5
  signed int v94; // r1
  int v95; // r12
  int v96; // r12
  signed int v97; // r5
  unsigned int v98; // r2
  int v99; // r12
  int v100; // r4
  unsigned int v101; // r4
  signed int n; // r5
  int v103; // r0
  unsigned __int64 v104; // r0
  unsigned int v105; // r0
  unsigned __int64 v106; // r0
  char v107; // r2
  __int16 v108; // r2
  int v109; // r5
  int v110; // r4
  signed int ii; // r2
  char v112; // r2
  int v113; // r3
  int v114; // r0
  __int64 v115; // r0
  signed int v116; // r5
  int v117; // r4
  signed int l; // r2
  unsigned __int64 v119; // r0
  int v120; // r4
  int v121; // r12
  signed int m; // r2
  _DWORD *v123; // r3
  unsigned int v124; // r5
  bool jj; // cf
  int v126; // r0
  unsigned __int64 v127; // r0
  int v128; // r4
  unsigned int v129; // r4
  signed int kk; // r5
  int v131; // r0
  unsigned __int64 v132; // r0
  unsigned int v133; // r0
  unsigned __int64 v134; // r0
  char v135; // r2
  __int16 v136; // r3
  int v137; // r4
  int v138; // r5
  signed int ll; // r2
  _DWORD *v140; // r4
  unsigned int v141; // r3
  int v142; // r0
  unsigned __int64 v143; // r0
  char *v144; // r3
  unsigned int v145; // r2
  char v146; // r2
  int v147; // r0
  unsigned __int64 v148; // r0
  unsigned __int64 v149; // r0
  int v150; // r0
  unsigned __int64 v151; // r0
  int v152; // r3
  unsigned int v153; // r8
  unsigned int v154; // r6
  unsigned int v155; // r5
  unsigned int v156; // r6
  unsigned int v157; // r9
  char *v158; // r3
  int v159; // r1
  int v160; // r5
  int v161; // r6
  int v162; // r5
  int v163; // r6
  int v164; // r5
  int v165; // r6
  int v166; // r5
  int v167; // r6
  int v168; // r5
  int v169; // r6
  int v170; // r5
  int v171; // r6
  int v172; // r5
  int v173; // r6
  unsigned int v174; // r3
  int v175; // r5
  int i; // [sp+4h] [bp-ECh]
  unsigned int v177; // [sp+8h] [bp-E8h]
  unsigned int v178; // [sp+8h] [bp-E8h]
  unsigned __int64 v179; // [sp+10h] [bp-E0h]
  unsigned int v180; // [sp+18h] [bp-D8h]
  unsigned int v181; // [sp+1Ch] [bp-D4h]
  unsigned int v182; // [sp+20h] [bp-D0h]
  int v183; // [sp+28h] [bp-C8h]
  unsigned int v184; // [sp+2Ch] [bp-C4h]
  int v185; // [sp+30h] [bp-C0h]
  unsigned int v186; // [sp+34h] [bp-BCh]
  _DWORD *v187; // [sp+38h] [bp-B8h]
  char s[64]; // [sp+44h] [bp-ACh]
  int v189; // [sp+84h] [bp-6Ch]
  int v190; // [sp+88h] [bp-68h]
  char v191[40]; // [sp+C8h] [bp-28h]

  v7 = a1;
  v8 = a2;
  v186 = a4;
  v180 = (unsigned int)&a2[*a3];
  v187 = a3;
  v184 = (unsigned int)&a5[*a6];
  if ( a7 & 4 )
    v185 = -1;
  else
    v185 = (int)&a5[*a6 - 1 - a4];
  if ( (v185 + 1) & v185 || (unsigned int)a5 < a4 )
  {
    result = -3;
    *a6 = 0;
    *a3 = 0;
    return result;
  }
  v10 = *(_DWORD *)(a1 + 4);
  v182 = *(_DWORD *)(a1 + 40);
  v179 = *(_QWORD *)(a1 + 64);
  v11 = *(_DWORD *)(a1 + 44);
  v181 = *(_DWORD *)(a1 + 48);
  v183 = *(_DWORD *)(a1 + 72);
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      *(_DWORD *)(a1 + 32) = 1;
      *(_DWORD *)(a1 + 16) = 1;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      if ( !(a7 & 1) )
      {
        v13 = a5;
        v14 = a2;
        v11 = a7 & 1;
        v10 = a7 & 1;
        v181 = 0;
        v179 = 0LL;
        v182 = 0;
        goto LABEL_42;
      }
      if ( (unsigned int)a2 >= v180 )
      {
        v11 = 0;
        v10 = 0;
        v181 = 0;
        v179 = 0LL;
        v182 = 0;
        goto LABEL_11;
      }
      v14 = a2 + 1;
      v11 = 0;
      v10 = 0;
      *(_DWORD *)(a1 + 8) = (unsigned __int8)*a2;
      v179 = 0LL;
      v181 = 0;
      v182 = 0;
      goto LABEL_17;
    case 1:
      if ( (unsigned int)a2 >= v180 )
      {
LABEL_11:
        if ( a7 & 2 )
        {
          v12 = 1;
          v13 = a5;
          *(_DWORD *)a1 = 1;
          v14 = a2;
          goto LABEL_417;
        }
        *(_DWORD *)(a1 + 8) = 0;
        v14 = a2;
      }
      else
      {
        v14 = a2 + 1;
        *(_DWORD *)(a1 + 8) = (unsigned __int8)*a2;
      }
LABEL_17:
      if ( (unsigned int)v14 >= v180 )
        goto LABEL_21;
      v16 = (unsigned __int8)*v14++;
      *(_DWORD *)(a1 + 12) = v16;
      goto LABEL_26;
    case 2:
      if ( (unsigned int)a2 < v180 )
      {
        v15 = (unsigned __int8)*a2;
        v14 = a2 + 1;
      }
      else
      {
        v14 = a2;
LABEL_21:
        v15 = a7 & 2;
        if ( a7 & 2 )
        {
          v13 = a5;
          *(_DWORD *)a1 = 2;
          goto LABEL_49;
        }
      }
      *(_DWORD *)(a1 + 12) = v15;
LABEL_26:
      v17 = *(_DWORD *)(a1 + 8);
      v18 = *(_DWORD *)(a1 + 12);
      if ( (v18 + (v17 << 8)) % 0x1F || v18 & 0x20 )
      {
        v19 = 1;
      }
      else
      {
        v19 = (*(_DWORD *)(a1 + 8) & 0xF) - 8;
        if ( (*(_DWORD *)(a1 + 8) & 0xF) != 8 )
          v19 = 1;
      }
      v11 = v19;
      if ( !(a7 & 4) )
      {
        v20 = 1;
        v21 = (v17 >> 4) + 8;
        if ( (unsigned int)(1 << v21) <= 0x8000 )
          v20 = (unsigned int)(v185 + 1) >> v21 == 0;
        v11 = v19 | v20;
      }
      if ( !v11 )
      {
        v13 = a5;
        goto LABEL_53;
      }
      v11 = 1;
LABEL_39:
      v13 = a5;
      *(_DWORD *)a1 = 36;
      goto LABEL_416;
    case 3:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_46;
      }
      v14 = a2 + 1;
      v22 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_52;
    case 5:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_60;
      }
      v14 = a2 + 1;
      v26 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_64;
    case 6:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_72;
      }
      v14 = a2 + 1;
      v29 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_76;
    case 7:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_82;
      }
      v14 = a2 + 1;
      v13 = a5;
      *(_BYTE *)(a1 + v11 + 10540) = *a2;
      goto LABEL_87;
    case 9:
      v13 = a5;
      v14 = a2;
      goto LABEL_109;
    case 0xA:
      v13 = a5;
      v14 = a2;
      goto LABEL_126;
    case 0xB:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_141;
      }
      v14 = a2 + 1;
      v41 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_145;
    case 0xE:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_150;
      }
      v14 = a2 + 1;
      v47 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_156;
    case 0x10:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_165;
      }
      v14 = a2 + 1;
      v51 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_172;
    case 0x11:
      v13 = a5;
      v14 = a2;
      goto LABEL_194;
    case 0x12:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_201;
      }
      v14 = a2 + 1;
      v64 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_205;
    case 0x15:
      v13 = a5;
      v14 = a2;
      goto LABEL_218;
    case 0x17:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_269;
      }
      v14 = a2 + 1;
      v103 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_273;
    case 0x18:
      v13 = a5;
      v14 = a2;
      goto LABEL_284;
    case 0x19:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_310;
      }
      v14 = a2 + 1;
      v126 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_314;
    case 0x1A:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_331;
      }
      v14 = a2 + 1;
      v131 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_335;
    case 0x1B:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_349;
      }
      v14 = a2 + 1;
      v142 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_353;
    case 0x20:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_385;
      }
      v14 = a2 + 1;
      v147 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_389;
    case 0x22:
      v13 = a5;
      v14 = a2;
      goto LABEL_414;
    case 0x23:
      v13 = a5;
      v14 = a2;
      goto LABEL_161;
    case 0x24:
      v14 = a2;
      goto LABEL_39;
    case 0x25:
      v13 = a5;
      v14 = a2;
      goto LABEL_359;
    case 0x26:
      v13 = a5;
      v14 = a2;
      goto LABEL_114;
    case 0x27:
      v13 = a5;
      v14 = a2;
      goto LABEL_91;
    case 0x28:
      v13 = a5;
      v14 = a2;
      goto LABEL_112;
    case 0x29:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_397;
      }
      v14 = a2 + 1;
      v150 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_401;
    case 0x2A:
      if ( (unsigned int)a2 >= v180 )
      {
        v13 = a5;
        v14 = a2;
        goto LABEL_407;
      }
      v14 = a2 + 1;
      v152 = (unsigned __int8)*a2;
      v13 = a5;
      goto LABEL_411;
    case 0x33:
      if ( (unsigned int)a2 < v180 )
      {
        v14 = a2 + 1;
        v33 = (unsigned __int8)*a2;
        v13 = a5;
        goto LABEL_103;
      }
      v13 = a5;
      v14 = a2;
      break;
    case 0x34:
      v13 = a5;
      v14 = a2;
      goto LABEL_106;
    case 0x35:
      v13 = a5;
      v14 = a2;
      goto LABEL_366;
    default:
      v13 = a5;
      v14 = a2;
      goto LABEL_416;
  }
LABEL_94:
  v33 = a7 & 2;
  if ( a7 & 2 )
  {
    v23 = 51;
    goto LABEL_48;
  }
LABEL_103:
  v34 = (unsigned __int64)(unsigned int)v33 << v10;
  v10 += 8;
  v179 |= v34;
  do
  {
    if ( v10 <= 7 )
    {
      if ( (unsigned int)v14 >= v180 )
        goto LABEL_94;
      v33 = (unsigned __int8)*v14++;
      goto LABEL_103;
    }
    v10 -= 8;
    v182 = (unsigned __int8)v179;
    v179 >>= 8;
LABEL_106:
    if ( (unsigned int)v13 >= v184 )
    {
      v35 = 52;
      goto LABEL_368;
    }
    --v11;
    *(++v13 - 1) = v182;
LABEL_98:
    if ( !v11 )
      goto LABEL_378;
  }
  while ( v10 );
  while ( 1 )
  {
LABEL_109:
    if ( (unsigned int)v13 >= v184 )
    {
      v35 = 9;
      goto LABEL_368;
    }
LABEL_114:
    if ( (unsigned int)v14 >= v180 )
      break;
    v36 = v180 - (_DWORD)v14;
    v37 = v13;
    v38 = v14;
    if ( v180 - (unsigned int)v14 >= v184 - (unsigned int)v13 )
      v36 = v184 - (_DWORD)v13;
    if ( v36 >= v11 )
      v36 = v11;
    v14 += v36;
    v13 += v36;
    memcpy(v37, v38, v36);
    v11 -= v36;
    if ( !v11 )
    {
      while ( 1 )
      {
LABEL_378:
        if ( *(_DWORD *)(v7 + 24) & 1 )
        {
          if ( a7 & 1 )
          {
            while ( 1 )
            {
              if ( v10 >= (v10 & 7) )
              {
                v149 = v179 >> (v10 & 7);
                v10 &= 0xFFFFFFF8;
                v11 = 0;
                v179 = v149;
                while ( 1 )
                {
                  if ( v10 )
                  {
                    while ( v10 <= 7 )
                    {
                      if ( (unsigned int)v14 < v180 )
                      {
                        v150 = (unsigned __int8)*v14++;
                      }
                      else
                      {
LABEL_397:
                        v150 = a7 & 2;
                        if ( a7 & 2 )
                        {
                          v23 = 41;
                          goto LABEL_48;
                        }
                      }
LABEL_401:
                      v151 = (unsigned __int64)(unsigned int)v150 << v10;
                      v10 += 8;
                      v179 |= v151;
                    }
                    v10 -= 8;
                    v152 = (unsigned __int8)v179;
                    v179 >>= 8;
                  }
                  else if ( (unsigned int)v14 < v180 )
                  {
                    v152 = (unsigned __int8)*v14++;
                  }
                  else
                  {
LABEL_407:
                    v152 = a7 & 2;
                    if ( a7 & 2 )
                    {
                      v23 = 42;
                      goto LABEL_48;
                    }
                  }
LABEL_411:
                  ++v11;
                  *(_DWORD *)(v7 + 16) = v152 | (*(_DWORD *)(v7 + 16) << 8);
                  if ( v11 > 3 )
                    goto LABEL_414;
                }
              }
              if ( (unsigned int)v14 < v180 )
              {
                v147 = (unsigned __int8)*v14++;
              }
              else
              {
LABEL_385:
                v147 = a7 & 2;
                if ( a7 & 2 )
                {
                  v23 = 32;
                  goto LABEL_48;
                }
              }
LABEL_389:
              v148 = (unsigned __int64)(unsigned int)v147 << v10;
              v10 += 8;
              v179 |= v148;
            }
          }
LABEL_414:
          v12 = 0;
          *(_DWORD *)v7 = 34;
          goto LABEL_417;
        }
LABEL_53:
        while ( v10 <= 2 )
        {
LABEL_42:
          if ( (unsigned int)v14 < v180 )
          {
            v22 = (unsigned __int8)*v14++;
          }
          else
          {
LABEL_46:
            v22 = a7 & 2;
            if ( a7 & 2 )
            {
              v23 = 3;
LABEL_48:
              *(_DWORD *)v7 = v23;
LABEL_49:
              v12 = 1;
              goto LABEL_417;
            }
          }
LABEL_52:
          v24 = (unsigned __int64)(unsigned int)v22 << v10;
          v10 += 8;
          v179 |= v24;
        }
        v10 -= 3;
        *(_DWORD *)(v7 + 24) = v179 & 7;
        v25 = (unsigned int)(v179 & 7) >> 1;
        v179 >>= 3;
        *(_DWORD *)(v7 + 28) = v25;
        switch ( v25 )
        {
          case 0u:
            while ( v10 < (v10 & 7) )
            {
              if ( (unsigned int)v14 < v180 )
              {
                v26 = (unsigned __int8)*v14++;
              }
              else
              {
LABEL_60:
                v26 = a7 & 2;
                if ( a7 & 2 )
                {
                  v23 = 5;
                  goto LABEL_48;
                }
              }
LABEL_64:
              v27 = (unsigned __int64)(unsigned int)v26 << v10;
              v10 += 8;
              v179 |= v27;
            }
            v28 = v179 >> (v10 & 7);
            v10 &= 0xFFFFFFF8;
            v11 = 0;
            v179 = v28;
            do
            {
              if ( v10 )
              {
                while ( v10 <= 7 )
                {
                  if ( (unsigned int)v14 < v180 )
                  {
                    v29 = (unsigned __int8)*v14++;
                  }
                  else
                  {
LABEL_72:
                    v29 = a7 & 2;
                    if ( a7 & 2 )
                    {
                      v23 = 6;
                      goto LABEL_48;
                    }
                  }
LABEL_76:
                  v30 = (unsigned __int64)(unsigned int)v29 << v10;
                  v10 += 8;
                  v179 |= v30;
                }
                v10 -= 8;
                *(_BYTE *)(v7 + v11 + 10540) = v179;
                v179 >>= 8;
              }
              else if ( (unsigned int)v14 < v180 )
              {
                v31 = *v14++;
                *(_BYTE *)(v7 + v11 + 10540) = v31;
              }
              else
              {
LABEL_82:
                if ( a7 & 2 )
                {
                  v23 = 7;
                  goto LABEL_48;
                }
                *(_BYTE *)(v7 + v11 + 10540) = 0;
              }
LABEL_87:
              ++v11;
            }
            while ( v11 <= 3 );
            v11 = *(unsigned __int8 *)(v7 + 10540) | (*(unsigned __int8 *)(v7 + 10541) << 8);
            if ( v11 != ((*(unsigned __int8 *)(v7 + 10542) | (*(unsigned __int8 *)(v7 + 10543) << 8)) ^ 0xFFFF) )
            {
LABEL_91:
              v32 = 39;
              goto LABEL_162;
            }
            goto LABEL_98;
          case 3u:
LABEL_126:
            v32 = 10;
            goto LABEL_162;
          case 1u:
            *(_DWORD *)(v7 + 52) = 288;
            *(_DWORD *)(v7 + 56) = 32;
            v39 = v7 + 76;
            memset((void *)(v7 + 3564), 5, 0x20u);
            v40 = 0;
            do
              *(_BYTE *)(v39 + v40++) = 8;
            while ( v40 != 144 );
            do
              *(_BYTE *)(v39 + v40++) = 9;
            while ( v40 != 256 );
            while ( v40 != 280 )
              *(_BYTE *)(v39 + v40++) = 7;
            do
              *(_BYTE *)(v39 + v40++) = 8;
            while ( v40 <= 0x11F );
            break;
          default:
            v11 = 0;
            do
            {
              while ( v10 < byte_E448E[v11] )
              {
                if ( (unsigned int)v14 < v180 )
                {
                  v41 = (unsigned __int8)*v14++;
                }
                else
                {
LABEL_141:
                  v41 = a7 & 2;
                  if ( a7 & 2 )
                  {
                    v23 = 11;
                    goto LABEL_48;
                  }
                }
LABEL_145:
                v42 = (unsigned __int64)(unsigned int)v41 << v10;
                v10 += 8;
                v179 |= v42;
              }
              v43 = byte_E448E[v11];
              v10 -= v43;
              v44 = v179 >> byte_E448E[v11];
              v45 = v7 + 4 * v11;
              v46 = &dword_E9BF4[v11++];
              *(_DWORD *)(v45 + 52) = (((1 << v43) - 1) & v179) + v46[550];
              v179 = v44;
            }
            while ( v11 <= 2 );
            memset((void *)(v7 + 7052), 0, 0x120u);
            v11 = 0;
            while ( v11 < *(_DWORD *)(v7 + 60) )
            {
              while ( v10 <= 2 )
              {
                if ( (unsigned int)v14 >= v180 )
                {
LABEL_150:
                  v47 = a7 & 2;
                  if ( a7 & 2 )
                  {
                    v23 = 14;
                    goto LABEL_48;
                  }
                }
                else
                {
                  v47 = (unsigned __int8)*v14++;
                }
LABEL_156:
                v48 = (unsigned __int64)(unsigned int)v47 << v10;
                v10 += 8;
                v179 |= v48;
              }
              v10 -= 3;
              v49 = v179 & 7;
              v179 >>= 3;
              v50 = (char *)dword_E9BF4 + v11++;
              *(_BYTE *)((unsigned __int8)v50[2212] + v7 + 7052) = v49;
            }
            *(_DWORD *)(v7 + 60) = 19;
            break;
        }
        while ( 1 )
        {
          v72 = *(_DWORD *)(v7 + 28);
          if ( v72 < 0 )
            break;
          v73 = v7 + 3488 * v72;
          v74 = v73 + 76;
          v75 = v73 + 72;
          memset(s, 0, 0x40u);
          memset((void *)(v75 + 292), 0, 0x800u);
          memset((void *)(v74 + 2336), 0, 0x480u);
          v76 = *(_DWORD *)(v7 + 4 * *(_DWORD *)(v7 + 28) + 52);
          v77 = 0;
          while ( v77 != v76 )
          {
            v78 = *(unsigned __int8 *)(v74 + v77++);
            ++*(_DWORD *)&v191[4 * v78 - 132];
          }
          v79 = 0;
          v80 = 0;
          v81 = 0;
          v190 = 0;
          v189 = 0;
          do
          {
            v82 = *(_DWORD *)&s[v79 + 4];
            v83 = v80 + v82;
            v81 += v82;
            v84 = (char *)&v189 + v79;
            v79 += 4;
            v80 = 2 * v83;
            *((_DWORD *)v84 + 2) = v80;
          }
          while ( v79 != 60 );
          if ( v80 != 0x10000 && v81 > 1 )
          {
LABEL_161:
            v32 = 35;
            goto LABEL_162;
          }
          v85 = 0;
          v86 = -1;
          while ( 1 )
          {
            v87 = *(_DWORD *)(v7 + 28);
            if ( v85 >= *(_DWORD *)(v7 + 4 * v87 + 52) )
              break;
            v88 = *(unsigned __int8 *)(v74 + v85);
            if ( *(_BYTE *)(v74 + v85) )
            {
              v89 = &v191[4 * v88];
              v90 = *((_DWORD *)v89 - 17);
              *((_DWORD *)v89 - 17) = v90 + 1;
              v91 = 0;
              v177 = v90;
              v92 = 0;
              do
              {
                ++v91;
                v92 = v177 & 1 | 2 * v92;
                v177 >>= 1;
              }
              while ( v88 != v91 );
              if ( v88 > 0xA )
              {
                v96 = v74 + 2 * (v92 & 0x3FF);
                v97 = *(signed __int16 *)(v96 + 288);
                if ( !*(_WORD *)(v96 + 288) )
                {
                  *(_WORD *)(v96 + 288) = v86;
                  v97 = v86;
                  v86 -= 2;
                }
                v178 = v92 >> 9;
                for ( i = 0; ; ++i )
                {
                  v98 = v178 >> 1;
                  if ( v88 - i == 11 )
                    break;
                  v178 >>= 1;
                  v99 = v74 + 2 * ~(v97 - (v98 & 1));
                  if ( *(_WORD *)(v99 + 2336) )
                  {
                    v97 = *(signed __int16 *)(v99 + 2336);
                  }
                  else
                  {
                    *(_WORD *)(v99 + 2336) = v86;
                    v97 = v86;
                    v86 -= 2;
                  }
                }
                *(_WORD *)(v74 + 2 * (~(v97 - ((v178 >> 1) & 1)) + 1168)) = v85;
              }
              else
              {
                v93 = v85 | ((_WORD)v88 << 9);
                v94 = 1 << v88;
                while ( v92 <= 0x3FF )
                {
                  v95 = v74 + 2 * v92;
                  v92 += v94;
                  *(_WORD *)(v95 + 288) = v93;
                }
              }
            }
            ++v85;
          }
          if ( v87 != 2 )
            goto LABEL_219;
          v11 = 0;
LABEL_183:
          v57 = *(_DWORD *)(v7 + 52);
          v58 = *(_DWORD *)(v7 + 56) + v57;
          if ( v11 < v58 )
          {
            if ( v10 > 0xE )
              goto LABEL_185;
            if ( (signed int)(v180 - (_DWORD)v14) > 1 )
            {
              v69 = (unsigned __int8)*v14;
              v14 += 2;
              v70 = (unsigned __int64)v69 << v10;
              v71 = v10 + 8;
              v10 += 16;
              v179 |= ((unsigned __int64)(unsigned __int8)*(v14 - 1) << v71) | v70;
              goto LABEL_185;
            }
            while ( 1 )
            {
              v52 = *(signed __int16 *)(v7 + 2 * ((v179 & 0x3FF) + 3668) + 4);
              if ( v52 < 0 )
              {
                if ( v10 > 0xA )
                {
                  for ( j = 10; ; ++j )
                  {
                    v52 = *(signed __int16 *)(v7 + 2 * (((v179 >> j) & 1) - v52 + 4691) + 4);
                    if ( v52 >= 0 )
                      break;
                    if ( v10 < j + 2 )
                      goto LABEL_170;
                  }
LABEL_185:
                  v59 = *(_WORD *)(v7 + 2 * ((v179 & 0x3FF) + 3668) + 4);
                  v60 = v59;
                  if ( v59 < 0 )
                  {
                    for ( k = 10; ; ++k )
                    {
                      v61 = k + 1;
                      v60 = *(signed __int16 *)(v7 + 2 * (((v179 >> k) & 1) - v60 + 4691) + 4);
                      if ( v60 >= 0 )
                        break;
                    }
                  }
                  else
                  {
                    v61 = v59 >> 9;
                    v60 = v59 & 0x1FF;
                  }
                  v182 = v60;
                  v10 -= v61;
                  v179 >>= v61;
                  if ( (unsigned int)v60 <= 0xF )
                  {
                    v56 = v7 + v11++;
                    *(_BYTE *)(v56 + 10544) = v60;
                    goto LABEL_183;
                  }
                  if ( v60 == 16 && !v11 )
                  {
LABEL_194:
                    v32 = 17;
                    goto LABEL_162;
                  }
                  v63 = v10 >= byte_E4483[v60 - 16];
                  v181 = byte_E4483[v60 - 16];
                  while ( !v63 )
                  {
                    if ( (unsigned int)v14 < v180 )
                    {
                      v64 = (unsigned __int8)*v14++;
                    }
                    else
                    {
LABEL_201:
                      v64 = a7 & 2;
                      if ( a7 & 2 )
                      {
                        v23 = 18;
                        goto LABEL_48;
                      }
                    }
LABEL_205:
                    v65 = (unsigned __int64)(unsigned int)v64 << v10;
                    v10 += 8;
                    v179 |= v65;
                    v63 = v10 >= v181;
                  }
                  v66 = v179 >> v181;
                  v10 -= v181;
                  v67 = byte_E4492[v182 - 16];
                  v68 = (((1 << v181) - 1) & v179) + v67;
                  if ( v182 == 16 )
                    v67 = v7 + v11 + 10496;
                  v179 >>= v181;
                  if ( v182 == 16 )
                    HIDWORD(v66) = *(unsigned __int8 *)(v67 + 47);
                  if ( v182 != 16 )
                    HIDWORD(v66) = 0;
                  memset((void *)(v11 + 10544 + v7), SHIDWORD(v66), v68);
                  v11 += v68;
                  goto LABEL_183;
                }
              }
              else
              {
                v53 = v52 >> 9;
                if ( v53 && v10 >= v53 )
                  goto LABEL_185;
              }
LABEL_170:
              if ( (unsigned int)v14 >= v180 )
              {
LABEL_165:
                v51 = a7 & 2;
                if ( a7 & 2 )
                {
                  v23 = 16;
                  goto LABEL_48;
                }
              }
              else
              {
                v51 = (unsigned __int8)*v14++;
              }
LABEL_172:
              v54 = (unsigned __int64)(unsigned int)v51 << v10;
              v10 += 8;
              v179 |= v54;
              if ( v10 > 0xE )
                goto LABEL_185;
            }
          }
          if ( v58 != v11 )
          {
LABEL_218:
            v32 = 21;
            goto LABEL_162;
          }
          memcpy((void *)(v7 + 76), (const void *)(v7 + 10544), v57);
          memcpy((void *)(v7 + 3564), (const void *)(*(_DWORD *)(v7 + 52) + 10544 + v7), *(_DWORD *)(v7 + 56));
LABEL_219:
          --*(_DWORD *)(v7 + 28);
        }
LABEL_250:
        while ( 2 )
        {
          while ( 2 )
          {
            if ( (signed int)(v180 - (_DWORD)v14) > 3 && (signed int)(v184 - (_DWORD)v13) > 1 )
            {
              if ( v10 <= 0x1D )
              {
                v112 = v10;
                v113 = (unsigned __int8)v14[1];
                v114 = (unsigned __int8)v14[2];
                v14 += 4;
                v10 += 32;
                v115 = (v114 << 16) | (v113 << 8) | (unsigned int)(unsigned __int8)*(v14 - 4);
                LODWORD(v115) = v115 | ((unsigned __int8)*(v14 - 1) << 24);
                v179 |= v115 << v112;
              }
              v116 = *(signed __int16 *)(v7 + 2 * (v179 & 0x3FF) + 364);
              if ( v116 < 0 )
              {
                for ( l = 10; ; ++l )
                {
                  v117 = l + 1;
                  v116 = *(signed __int16 *)(v7 + 2 * (((v179 >> l) & 1) - v116) + 2410);
                  if ( v116 >= 0 )
                    break;
                }
              }
              else
              {
                v117 = v116 >> 9;
              }
              v119 = v179 >> v117;
              v11 = v116;
              v10 -= v117;
              v179 >>= v117;
              if ( !(v116 & 0x100) )
              {
                v120 = *(signed __int16 *)(v7 + 2 * (v119 & 0x3FF) + 364);
                if ( v120 < 0 )
                {
                  for ( m = 10; ; ++m )
                  {
                    v121 = m + 1;
                    v120 = *(signed __int16 *)(v7 + 2 * (((v179 >> m) & 1) - v120) + 2410);
                    if ( v120 >= 0 )
                      break;
                  }
                }
                else
                {
                  v121 = v120 >> 9;
                }
                *v13 = v116;
                v10 -= v121;
                v179 >>= v121;
                if ( !(v120 & 0x100) )
                {
                  v13[1] = v120;
                  v13 += 2;
                  continue;
                }
                ++v13;
                LOWORD(v11) = v120;
              }
              goto LABEL_302;
            }
            break;
          }
          if ( v10 > 0xE )
            goto LABEL_276;
          if ( (signed int)(v180 - (_DWORD)v14) > 1 )
          {
            v105 = (unsigned __int8)*v14;
            v14 += 2;
            v106 = (unsigned __int64)v105 << v10;
            v107 = v10 + 8;
            v10 += 16;
            v179 |= ((unsigned __int64)(unsigned __int8)*(v14 - 1) << v107) | v106;
            goto LABEL_276;
          }
          while ( 1 )
          {
            v100 = *(signed __int16 *)(v7 + 2 * (v179 & 0x3FF) + 364);
            if ( v100 >= 0 )
            {
              v101 = v100 >> 9;
              if ( v101 && v10 >= v101 )
                goto LABEL_276;
              goto LABEL_265;
            }
            if ( v10 > 0xA )
              break;
LABEL_265:
            if ( (unsigned int)v14 < v180 )
            {
              v103 = (unsigned __int8)*v14++;
            }
            else
            {
LABEL_269:
              v103 = a7 & 2;
              if ( a7 & 2 )
              {
                v23 = 23;
                goto LABEL_48;
              }
            }
LABEL_273:
            v104 = (unsigned __int64)(unsigned int)v103 << v10;
            v10 += 8;
            v179 |= v104;
            if ( v10 > 0xE )
              goto LABEL_276;
          }
          for ( n = 10; ; ++n )
          {
            v100 = *(signed __int16 *)(v7 + 2 * (((v179 >> n) & 1) - v100) + 2410);
            if ( v100 >= 0 )
              break;
            if ( v10 < n + 2 )
              goto LABEL_265;
          }
LABEL_276:
          v108 = *(_WORD *)(v7 + 2 * (v179 & 0x3FF) + 364);
          v109 = v108;
          if ( v108 < 0 )
          {
            for ( ii = 10; ; ++ii )
            {
              v110 = ii + 1;
              v109 = *(signed __int16 *)(v7 + 2 * (((v179 >> ii) & 1) - v109) + 2410);
              if ( v109 >= 0 )
                break;
            }
          }
          else
          {
            v110 = v108 >> 9;
            v109 = v108 & 0x1FF;
          }
          v11 = v109;
          v10 -= v110;
          v179 >>= v110;
          if ( (unsigned int)v109 <= 0xFF )
          {
LABEL_284:
            if ( (unsigned int)v13 < v184 )
            {
              *v13++ = v11;
              continue;
            }
            v35 = 24;
LABEL_368:
            *(_DWORD *)v7 = v35;
            v12 = 2;
            goto LABEL_417;
          }
          break;
        }
LABEL_302:
        v11 &= 0x1FFu;
        if ( v11 != 256 )
        {
          v123 = &dword_E9BF4[v11 - 257];
          v124 = v123[558];
          v11 = v123[589];
          v181 = v124;
          if ( v124 )
          {
            for ( jj = v10 >= v124; !jj; jj = v10 >= v181 )
            {
              if ( (unsigned int)v14 < v180 )
              {
                v126 = (unsigned __int8)*v14++;
              }
              else
              {
LABEL_310:
                v126 = a7 & 2;
                if ( a7 & 2 )
                {
                  v23 = 25;
                  goto LABEL_48;
                }
              }
LABEL_314:
              v127 = (unsigned __int64)(unsigned int)v126 << v10;
              v10 += 8;
              v179 |= v127;
            }
            v10 -= v181;
            v11 += ((1 << v181) - 1) & v179;
            v179 >>= v181;
          }
          if ( v10 > 0xE )
            goto LABEL_338;
          if ( (signed int)(v180 - (_DWORD)v14) > 1 )
          {
            v133 = (unsigned __int8)*v14;
            v14 += 2;
            v134 = (unsigned __int64)v133 << v10;
            v135 = v10 + 8;
            v10 += 16;
            v179 |= ((unsigned __int64)(unsigned __int8)*(v14 - 1) << v135) | v134;
            goto LABEL_338;
          }
          while ( 1 )
          {
            v128 = *(signed __int16 *)(v7 + 2 * (v179 & 0x3FF) + 3852);
            if ( v128 < 0 )
            {
              if ( v10 > 0xA )
              {
                for ( kk = 10; ; ++kk )
                {
                  v128 = *(signed __int16 *)(v7 + 2 * (((v179 >> kk) & 1) - v128 + 2947) + 4);
                  if ( v128 >= 0 )
                    break;
                  if ( v10 < kk + 2 )
                    goto LABEL_327;
                }
LABEL_338:
                v136 = *(_WORD *)(v7 + 2 * (v179 & 0x3FF) + 3852);
                v137 = v136;
                if ( v136 < 0 )
                {
                  for ( ll = 10; ; ++ll )
                  {
                    v138 = ll + 1;
                    v137 = *(signed __int16 *)(v7 + 2 * (((v179 >> ll) & 1) - v137 + 2947) + 4);
                    if ( v137 >= 0 )
                      break;
                  }
                }
                else
                {
                  v138 = v136 >> 9;
                  v137 = v136 & 0x1FF;
                }
                v10 -= v138;
                v140 = &dword_E9BF4[v137];
                v141 = v140[620];
                v181 = v141;
                v182 = v140[652];
                v179 >>= v138;
                if ( v141 )
                {
                  while ( v10 < v141 )
                  {
                    if ( (unsigned int)v14 < v180 )
                    {
                      v142 = (unsigned __int8)*v14++;
                    }
                    else
                    {
LABEL_349:
                      v142 = a7 & 2;
                      if ( a7 & 2 )
                      {
                        v23 = 27;
                        goto LABEL_48;
                      }
                    }
LABEL_353:
                    v143 = (unsigned __int64)(unsigned int)v142 << v10;
                    v10 += 8;
                    v179 |= v143;
                    v141 = v181;
                  }
                  v10 -= v181;
                  v182 += ((1 << v181) - 1) & v179;
                  v179 >>= v181;
                }
                v183 = (int)&v13[-v186];
                if ( v182 > (unsigned int)&v13[-v186] && a7 & 4 )
                {
LABEL_359:
                  v32 = 37;
                  goto LABEL_162;
                }
                v144 = (char *)(((v183 - v182) & v185) + v186);
                if ( v144 < v13 )
                  v145 = (unsigned int)&v13[v11];
                else
                  v145 = (unsigned int)&v144[v11];
                if ( v184 < v145 )
                {
                  while ( v11 )
                  {
                    --v11;
LABEL_366:
                    if ( (unsigned int)v13 >= v184 )
                    {
                      v35 = 53;
                      goto LABEL_368;
                    }
                    *(++v13 - 1) = *(_BYTE *)(v186 + ((v183++ - v182) & v185));
                  }
                  v11 = -1;
                }
                else
                {
                  do
                  {
                    v146 = *v144;
                    v11 -= 3;
                    v13 += 3;
                    v144 += 3;
                    *(v13 - 3) = v146;
                    *(v13 - 2) = *(v144 - 2);
                    *(v13 - 1) = *(v144 - 1);
                  }
                  while ( (signed int)v11 > 2 );
                  if ( (signed int)v11 > 0 )
                  {
                    *v13 = *v144;
                    if ( v11 == 2 )
                      v13[1] = v144[1];
                    v13 += v11;
                  }
                }
                goto LABEL_250;
              }
            }
            else
            {
              v129 = v128 >> 9;
              if ( v129 && v10 >= v129 )
                goto LABEL_338;
            }
LABEL_327:
            if ( (unsigned int)v14 < v180 )
            {
              v131 = (unsigned __int8)*v14++;
            }
            else
            {
LABEL_331:
              v131 = a7 & 2;
              if ( a7 & 2 )
              {
                v23 = 26;
                goto LABEL_48;
              }
            }
LABEL_335:
            v132 = (unsigned __int64)(unsigned int)v131 << v10;
            v10 += 8;
            v179 |= v132;
            if ( v10 > 0xE )
              goto LABEL_338;
          }
        }
      }
    }
  }
  if ( a7 & 2 )
  {
    v23 = 38;
    goto LABEL_48;
  }
LABEL_112:
  v32 = 40;
LABEL_162:
  *(_DWORD *)v7 = v32;
LABEL_416:
  v12 = -1;
LABEL_417:
  *(_DWORD *)(v7 + 40) = v182;
  *(_DWORD *)(v7 + 48) = v181;
  *(_DWORD *)(v7 + 72) = v183;
  *(_DWORD *)(v7 + 4) = v10;
  v153 = v13 - a5;
  *(_QWORD *)(v7 + 64) = v179;
  *(_DWORD *)(v7 + 44) = v11;
  *v187 = v14 - v8;
  *a6 = v153;
  if ( !(a7 & 9) )
    return v12;
  if ( v12 == -1 )
    return v12;
  v154 = *(_DWORD *)(v7 + 32);
  v155 = (unsigned __int16)v154;
  v156 = v154 >> 16;
  v157 = v153 % 0x15B0;
  while ( v153 )
  {
    v158 = a5;
    while ( (unsigned int)&v158[7 - (_DWORD)a5] < v157 )
    {
      v159 = (unsigned __int8)*v158;
      v158 += 8;
      v160 = v155 + v159;
      v161 = v156 + v160;
      v162 = v160 + (unsigned __int8)*(v158 - 7);
      v163 = v161 + v162;
      v164 = v162 + (unsigned __int8)*(v158 - 6);
      v165 = v163 + v164;
      v166 = v164 + (unsigned __int8)*(v158 - 5);
      v167 = v165 + v166;
      v168 = v166 + (unsigned __int8)*(v158 - 4);
      v169 = v167 + v168;
      v170 = v168 + (unsigned __int8)*(v158 - 3);
      v171 = v169 + v170;
      v172 = v170 + (unsigned __int8)*(v158 - 2);
      v173 = v171 + v172;
      v155 = v172 + (unsigned __int8)*(v158 - 1);
      v156 = v173 + v155;
    }
    a5 += v157 & 0xFFFFFFF8;
    v174 = (v157 & 0xFFFFFFF8) - (_DWORD)a5;
    while ( (unsigned int)&a5[v174] < v157 )
    {
      v155 += (unsigned __int8)*a5++;
      v156 += v155;
    }
    v153 -= v157;
    v157 = 5552;
    v155 %= 0xFFF1u;
    v156 %= 0xFFF1u;
  }
  v175 = v155 + (v156 << 16);
  *(_DWORD *)(v7 + 32) = v175;
  if ( v12 || !(a7 & 1) )
    return v12;
  if ( v175 == *(_DWORD *)(v7 + 16) )
    return 0;
  return -2;
}
// 4ECB0: using guessed type char s[64];
// 4ECB0: using guessed type char var_28[40];

//----- (00050004) --------------------------------------------------------
signed int __fastcall mz_inflate(int a1, signed int a2)
{
  int v2; // r4
  signed int result; // r0
  _DWORD *v4; // r6
  int *v5; // r5
  int v6; // r2
  char v7; // r9
  int v8; // r3
  unsigned int v9; // r1
  _BOOL4 v10; // r10
  signed int v11; // r0
  int v12; // r3
  int v13; // r2
  size_t v14; // r3
  size_t v15; // r3
  unsigned int v16; // r12
  size_t v17; // r7
  void *v18; // r0
  int v19; // r3
  int v20; // r3
  signed int v21; // r0
  int v22; // r2
  size_t v23; // r2
  size_t v24; // r7
  int v25; // r2
  int v26; // r1
  unsigned int v27; // [sp+10h] [bp-40h]
  signed int v28; // [sp+14h] [bp-3Ch]
  int v29; // [sp+18h] [bp-38h]
  int v30; // [sp+20h] [bp-30h]
  size_t n; // [sp+24h] [bp-2Ch]

  v2 = a1;
  if ( !a1 )
    return -2;
  v4 = *(_DWORD **)(a1 + 28);
  if ( !v4 )
    return -2;
  if ( a2 == 1 )
  {
    a2 = 2;
  }
  else if ( a2 & 0xFFFFFFFD && a2 != 4 )
  {
    return -2;
  }
  v5 = v4 + 2752;
  v6 = v4[2754];
  if ( v4[2756] <= 0 )
    v7 = 8;
  else
    v7 = 9;
  v29 = *(_DWORD *)(a1 + 4);
  v4[2754] = 0;
  if ( v4[10949] < 0 )
    return -3;
  v8 = v4[2755];
  if ( v8 && a2 != 4 )
    return -2;
  v9 = a2 - 4;
  v10 = v9 <= 0;
  v4[2755] = v10 | v8;
  if ( v9 > 0 )
  {
    v7 |= 2u;
    goto LABEL_23;
  }
  if ( !v6 )
  {
LABEL_23:
    v15 = v4[2753];
    if ( v15 )
    {
      v17 = *(_DWORD *)(a1 + 16);
      v18 = *(void **)(a1 + 12);
      if ( v15 < v17 )
        v17 = v4[2753];
      memcpy(v18, (char *)v4 + *v5 + 11028, v17);
      *(_DWORD *)(v2 + 12) += v17;
      *(_DWORD *)(v2 + 16) -= v17;
      *(_DWORD *)(v2 + 20) += v17;
      v19 = v4[2753] - v17;
      *v5 = ((unsigned __int16)*v5 + (_WORD)v17) & 0x7FFF;
      v4[2753] = v19;
      if ( v4[10949] || v19 )
        return 0;
      return 1;
    }
    v16 = (unsigned int)(v4 + 2757);
    while ( 1 )
    {
      while ( 1 )
      {
        v30 = *(_DWORD *)(v2 + 4);
        v20 = (int)v4 + *v5 + 11008;
        n = 0x8000 - *v5;
        v27 = v16;
        v21 = tinfl_decompress((int)v4, *(_BYTE **)v2, &v30, v16, (char *)(v20 + 20), &n, v7);
        v22 = v30;
        v4[10949] = v21;
        *(_DWORD *)v2 += v22;
        *(_DWORD *)(v2 + 4) -= v22;
        *(_DWORD *)(v2 + 8) += v22;
        *(_DWORD *)(v2 + 48) = v4[8];
        *(_DWORD *)(v2 + 52) = v4[9];
        v23 = n;
        v4[2753] = n;
        v24 = *(_DWORD *)(v2 + 16);
        if ( v23 < v24 )
          v24 = v23;
        v28 = v21;
        memcpy(*(void **)(v2 + 12), (char *)v4 + *v5 + 11028, v24);
        *(_DWORD *)(v2 + 12) += v24;
        *(_DWORD *)(v2 + 16) -= v24;
        *(_DWORD *)(v2 + 20) += v24;
        v25 = v4[2753] - v24;
        v26 = ((unsigned __int16)*v5 + (_WORD)v24) & 0x7FFF;
        v4[2753] = v25;
        *v5 = v26;
        v16 = v27;
        if ( v28 < 0 )
          return -3;
        if ( v28 != 1 )
          break;
        if ( !v29 )
          return -5;
        if ( v10 )
          goto LABEL_34;
LABEL_46:
        if ( !*(_DWORD *)(v2 + 4) || !*(_DWORD *)(v2 + 16) || v25 )
          return 0;
      }
      if ( !v10 )
      {
        if ( !v28 )
        {
          if ( !v25 )
            return 1;
          return 0;
        }
        goto LABEL_46;
      }
      if ( !v28 )
      {
        if ( v25 )
          result = -5;
        else
          result = 1;
        return result;
      }
LABEL_34:
      if ( !*(_DWORD *)(v2 + 16) )
        return -5;
    }
  }
  v30 = *(_DWORD *)(a1 + 4);
  n = *(_DWORD *)(a1 + 16);
  v11 = tinfl_decompress((int)v4, *(_BYTE **)a1, &v30, *(_DWORD *)(a1 + 12), *(char **)(a1 + 12), &n, v7 | 4);
  v12 = v30;
  v4[10949] = v11;
  *(_DWORD *)v2 += v12;
  *(_DWORD *)(v2 + 4) -= v12;
  *(_DWORD *)(v2 + 8) += v12;
  v13 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 48) = v4[8];
  *(_DWORD *)(v2 + 52) = v4[9];
  v14 = n;
  *(_DWORD *)(v2 + 12) = v13 + n;
  *(_DWORD *)(v2 + 16) -= v14;
  *(_DWORD *)(v2 + 20) += v14;
  if ( v11 < 0 )
    return -3;
  if ( !v11 )
    return 1;
  v4[10949] = -1;
  return -5;
}

//----- (0005023C) --------------------------------------------------------
signed int __fastcall mz_uncompress(int a1, int *a2, int a3, int a4)
{
  int v4; // r5
  int *v5; // r6
  int v6; // r7
  int v7; // r8
  int v8; // r3
  signed int result; // r0
  signed int v10; // r5
  int s; // [sp+4h] [bp-54h]
  int v12; // [sp+8h] [bp-50h]
  int v13; // [sp+10h] [bp-48h]
  int v14; // [sp+14h] [bp-44h]
  int v15; // [sp+18h] [bp-40h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  memset(&s, 0, 0x3Cu);
  v8 = *v5;
  s = v6;
  v12 = v7;
  v13 = v4;
  v14 = v8;
  result = mz_inflateInit(&s);
  if ( !result )
  {
    v10 = mz_inflate((int)&s, 4);
    if ( v10 == 1 )
    {
      *v5 = v15;
      result = mz_inflateEnd((int)&s);
    }
    else
    {
      mz_inflateEnd((int)&s);
      if ( v10 == -5 )
      {
        if ( v12 )
          result = -5;
        else
          result = -3;
      }
      else
      {
        result = v10;
      }
    }
  }
  return result;
}

//----- (000502A8) --------------------------------------------------------
char *__fastcall tinfl_decompress_mem_to_heap(int a1, int a2, int *a3, char a4)
{
  char v4; // r11
  int *v5; // r6
  int v6; // r10
  size_t v7; // r5
  int v8; // r7
  char *v9; // r4
  int v10; // r3
  char *v11; // r3
  signed int v12; // r0
  char *v13; // r0
  int v15; // [sp+18h] [bp-2B40h]
  int v16; // [sp+20h] [bp-2B38h]
  size_t v17; // [sp+24h] [bp-2B34h]
  int v18; // [sp+28h] [bp-2B30h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v15 = a1;
  *a3 = 0;
  v18 = 0;
  while ( 1 )
  {
    v16 = v6 - v8;
    v10 = *v5;
    v17 = v7 - *v5;
    if ( v9 )
      v11 = &v9[v10];
    else
      v11 = 0;
    v12 = tinfl_decompress((int)&v18, (_BYTE *)(v15 + v8), &v16, (unsigned int)v9, v11, &v17, v4 & 0xF9 | 4);
    if ( v12 < 0 || v12 == 1 )
    {
      free(v9);
LABEL_13:
      *v5 = 0;
      return 0;
    }
    v8 += v16;
    *v5 += v17;
    if ( !v12 )
      return v9;
    v7 *= 2;
    if ( v7 <= 0x7F )
      v7 = 128;
    v13 = (char *)realloc(v9, v7);
    if ( !v13 )
    {
      free(v9);
      goto LABEL_13;
    }
    v9 = v13;
  }
}

//----- (00050390) --------------------------------------------------------
signed int __fastcall tinfl_decompress_mem_to_mem(char *a1, int a2, _BYTE *a3, int a4, char a5)
{
  signed int result; // r0
  int v6; // [sp+10h] [bp-2B20h]
  int v7; // [sp+14h] [bp-2B1Ch]
  int v8; // [sp+18h] [bp-2B18h]

  v7 = a2;
  v6 = a4;
  v8 = 0;
  if ( tinfl_decompress((int)&v8, a3, &v6, (unsigned int)a1, a1, (unsigned int *)&v7, a5 & 0xF9 | 4) )
    result = -1;
  else
    result = v7;
  return result;
}

//----- (00050404) --------------------------------------------------------
signed int __fastcall tinfl_decompress_mem_to_callback(int a1, _DWORD *a2, int (__fastcall *a3)(char *), int a4, char a5)
{
  _DWORD *v5; // r10
  char *v6; // r6
  int v7; // r5
  int v8; // r4
  signed int v9; // r0
  _BOOL4 v10; // r5
  signed int v12; // [sp+14h] [bp-2B4Ch]
  int v13; // [sp+1Ch] [bp-2B44h]
  int (__fastcall *v14)(char *); // [sp+20h] [bp-2B40h]
  int v15; // [sp+28h] [bp-2B38h]
  int v16; // [sp+2Ch] [bp-2B34h]
  int v17; // [sp+30h] [bp-2B30h]

  v5 = a2;
  v13 = a1;
  v14 = a3;
  v6 = (char *)malloc(0x8000u);
  if ( !v6 )
    return -1;
  v7 = 0;
  v8 = 0;
  v17 = 0;
  while ( 1 )
  {
    v15 = *v5 - v8;
    v16 = 0x8000 - v7;
    v9 = tinfl_decompress(
           (int)&v17,
           (_BYTE *)(v13 + v8),
           &v15,
           (unsigned int)v6,
           &v6[v7],
           (unsigned int *)&v16,
           a5 & 0xF9);
    v8 += v15;
    v12 = v9;
    if ( v16 )
    {
      if ( !v14(&v6[v7]) )
        break;
    }
    if ( v12 != 2 )
    {
      v10 = v12 == 0;
      goto LABEL_9;
    }
    v7 = ((_WORD)v7 + (_WORD)v16) & 0x7FFF;
  }
  v10 = 0;
LABEL_9:
  free(v6);
  *v5 = v8;
  return v10;
}

//----- (000504F4) --------------------------------------------------------
int __fastcall tdefl_compress(_DWORD *a1, unsigned __int8 *a2, unsigned int *a3, int a4, _DWORD *a5, int a6)
{
  unsigned __int8 *v6; // r9
  _DWORD *v7; // r4
  unsigned int v8; // r7
  _BOOL4 v9; // r5
  signed int v10; // r0
  int v11; // r5
  int result; // r0
  int v13; // r3
  unsigned __int8 *v14; // r11
  int v15; // r2
  unsigned int v16; // r5
  int v17; // r0
  int v18; // r3
  unsigned int v19; // r1
  int v20; // r6
  int v21; // r0
  int v22; // lr
  unsigned __int8 *v23; // r2
  char v24; // r0
  unsigned __int16 v25; // t1
  int v26; // r12
  bool v27; // cf
  bool v28; // zf
  unsigned int v29; // r2
  int v30; // r1
  int v31; // r3
  int v32; // t1
  __int16 v33; // r6
  int v34; // r2
  unsigned int v35; // r6
  int v36; // r2
  int v37; // r3
  unsigned int v38; // r0
  int v39; // r3
  int v40; // r0
  unsigned int v41; // r10
  unsigned int i; // r3
  unsigned int v43; // r6
  int v44; // r8
  signed int v45; // r2
  int v46; // r2
  unsigned int v47; // r5
  int v48; // r2
  int v49; // r2
  int v50; // r1
  int v51; // r2
  int v52; // r1
  int v53; // r2
  int v54; // r1
  unsigned int j; // r1
  int v56; // r3
  unsigned int v57; // r2
  unsigned int v58; // r3
  unsigned int v59; // r3
  signed int v60; // r0
  int v61; // r3
  unsigned int v62; // [sp+4h] [bp-5Ch]
  unsigned int v63; // [sp+8h] [bp-58h]
  int v64; // [sp+Ch] [bp-54h]
  unsigned int v65; // [sp+10h] [bp-50h]
  int v66; // [sp+14h] [bp-4Ch]
  int v67; // [sp+18h] [bp-48h]
  int v68; // [sp+1Ch] [bp-44h]
  __int16 v69; // [sp+20h] [bp-40h]
  _BOOL4 v70; // [sp+24h] [bp-3Ch]

  v6 = a2;
  v7 = a1;
  if ( !a1 )
  {
    if ( a3 )
      *a3 = 0;
    if ( a5 )
      *a5 = 0;
    return -2;
  }
  a1[29] = a2;
  a1[31] = a3;
  a1[30] = a4;
  a1[32] = a5;
  a1[34] = a2;
  if ( a3 )
    v8 = *a3;
  else
    v8 = 0;
  a1[36] = 0;
  a1[35] = v8;
  a1[33] = a6;
  v9 = *a1 == 0;
  if ( a4 )
  {
    v10 = 1;
  }
  else
  {
    v10 = (signed int)a5;
    if ( a5 )
      v10 = 1;
  }
  if ( v9 != v10 )
    goto LABEL_146;
  if ( v7[28] )
    goto LABEL_146;
  v11 = v7[27];
  if ( v11 )
  {
    if ( a6 != 4 )
      goto LABEL_146;
  }
  if ( a3 && *a3 && !a2 )
    goto LABEL_25;
  if ( a5 && *a5 && !a4 )
  {
LABEL_146:
    if ( !a3 )
    {
LABEL_26:
      if ( a5 )
        *a5 = 0;
      result = -2;
      goto LABEL_137;
    }
LABEL_25:
    *a3 = 0;
    goto LABEL_26;
  }
  v70 = (unsigned int)(a6 - 4) <= 0;
  v13 = v7[24];
  v7[27] = v11 | v70;
  if ( v13 || v7[25] )
    goto LABEL_136;
  v14 = a2;
  while ( v8 || a6 && v7[9] )
  {
    v15 = v7[9];
    v16 = v7[10];
    if ( v16 + v15 <= 1 )
    {
      while ( v8 )
      {
        v29 = v7[9];
        if ( v29 > 0x101 )
          break;
        v30 = v7[8];
        --v8;
        v32 = *v14++;
        v31 = v32;
        v33 = v29 + v30;
        v34 = v29 + 1;
        v35 = v33 & 0x7FFF;
        *((_BYTE *)v7 + v35 + 148) = v32;
        if ( v35 <= 0x100 )
          *((_BYTE *)v7 + v35 + 32916) = v31;
        v7[9] = v34;
        if ( v34 + v16 > 2 )
        {
          v36 = v34 + v30;
          v37 = (int)v7
              + 2
              * ((v31 ^ (*((unsigned __int8 *)v7 + ((v36 - 3) & 0x7FFF) + 148) << 10) ^ 32
                                                                                      * *((unsigned __int8 *)v7
                                                                                        + (((_WORD)v36 - 2) & 0x7FFF)
                                                                                        + 148)) & 0x7FFF)
              + 167936;
          *((_WORD *)v7 + (((_WORD)v36 - 3) & 0x7FFF) + 51456 + 59) = *(_WORD *)(v37 + 630);
          *(_WORD *)(v37 + 630) = v36 - 3;
        }
      }
    }
    else
    {
      v17 = v7[8] + v15;
      v18 = v17 - 2;
      v19 = v17 & 0x7FFF;
      v20 = *((unsigned __int8 *)v7 + (((_WORD)v17 - 1) & 0x7FFF) + 148) ^ 32
                                                                         * *((unsigned __int8 *)v7
                                                                           + ((v17 - 2) & 0x7FFF)
                                                                           + 148);
      v21 = 258 - v15;
      if ( v8 < 258 - v15 )
        v21 = v8;
      v22 = (int)&v14[v21];
      v8 -= v21;
      v7[9] = v15 + v21;
      v23 = v14;
      while ( v23 != (unsigned __int8 *)v22 )
      {
        v25 = *v23++;
        v24 = v25;
        v26 = (int)v7 + v19;
        v27 = v19 >= 0x100;
        v28 = v19 == 256;
        v19 = ((_WORD)v19 + 1) & 0x7FFF;
        *(_BYTE *)(v26 + 148) = v25;
        v20 = (v25 ^ (unsigned __int16)(32 * v20)) & 0x7FFF;
        if ( v28 || !v27 )
          *(_BYTE *)(v26 + 32916) = v24;
        *((_WORD *)v7 + (v18 & 0x7FFF) + 51456 + 59) = *((_WORD *)v7 + v20 + 84283);
        *((_WORD *)v7 + v20 + 84283) = v18++;
      }
      v14 = v23;
    }
    v38 = v7[9];
    v39 = 0x8000 - v38;
    if ( 0x8000 - v38 >= v16 )
      v39 = v16;
    v63 = v39;
    v7[10] = v39;
    v65 = v38;
    if ( !a6 && v38 <= 0x101 )
      break;
    v40 = v7[2];
    v41 = v7[21];
    if ( v41 )
      i = v7[21];
    else
      i = 2;
    v43 = v40 & 0x120000;
    v44 = v7[8] & 0x7FFF;
    v64 = v7[2];
    if ( v40 & 0x120000 )
    {
      if ( !v63 )
      {
        v43 = 0;
        goto LABEL_141;
      }
      if ( v40 & 0x100000 )
      {
        v43 = 0;
        goto LABEL_141;
      }
      for ( i = 0;
            i != v65
         && *((unsigned __int8 *)v7 + v44 + i + 148) == *((unsigned __int8 *)v7 + (((_WORD)v44 - 1) & 0x7FFF) + 148);
            ++i )
      {
        ;
      }
      if ( i > 2 )
      {
        v43 = 1;
LABEL_141:
        v47 = i;
        goto LABEL_93;
      }
      v43 = 0;
      v47 = 0;
    }
    else
    {
      if ( i <= 0x1F )
        v45 = 2;
      else
        v45 = 3;
      v68 = v7[v45 + 1];
      v46 = (int)v7 + i + v44;
      v66 = *(unsigned __int8 *)(v46 + 148);
      v67 = *(unsigned __int8 *)(v46 + 147);
      if ( v65 <= i )
        goto LABEL_141;
      v47 = i;
      v69 = v7[8];
      v48 = v7[8] & 0x7FFF;
LABEL_69:
      while ( --v68 )
      {
        v49 = *((unsigned __int16 *)v7 + v48 + 51456 + 59);
        if ( !v49 )
          break;
        v62 = (unsigned __int16)(v69 - v49);
        if ( v62 > v63 )
          break;
        v48 = v49 & 0x7FFF;
        v50 = (int)v7 + v48 + i;
        if ( *(unsigned __int8 *)(v50 + 148) != v66 || *(unsigned __int8 *)(v50 + 147) != v67 )
        {
          v51 = *((unsigned __int16 *)v7 + v48 + 51456 + 59);
          if ( !v51 )
            break;
          v62 = (unsigned __int16)(v69 - v51);
          if ( v62 > v63 )
            break;
          v48 = v51 & 0x7FFF;
          v52 = (int)v7 + v48 + i;
          if ( *(unsigned __int8 *)(v52 + 148) != v66 || *(unsigned __int8 *)(v52 + 147) != v67 )
          {
            v53 = *((unsigned __int16 *)v7 + v48 + 51456 + 59);
            if ( !v53 )
              break;
            v62 = (unsigned __int16)(v69 - v53);
            if ( v62 > v63 )
              break;
            v48 = v53 & 0x7FFF;
            v54 = (int)v7 + v48 + i;
            if ( *(unsigned __int8 *)(v54 + 148) != v66 || *(unsigned __int8 *)(v54 + 147) != v67 )
              continue;
          }
        }
        if ( v62 )
        {
          for ( j = 0; j != v65; ++j )
          {
            if ( *((unsigned __int8 *)v7 + v44 + j + 148) != *((unsigned __int8 *)v7 + v48 + j + 148) )
            {
              if ( j > i )
              {
                v47 = j;
                v61 = (int)v7 + j + v44;
                v43 = v62;
                v66 = *(unsigned __int8 *)(v61 + 148);
                v67 = *(unsigned __int8 *)(v61 + 147);
                i = j;
              }
              goto LABEL_69;
            }
          }
          if ( j <= i )
            goto LABEL_69;
          v43 = v62;
          v47 = j;
        }
        break;
      }
      if ( v47 == 3 && v43 > 0x1FFF )
      {
LABEL_100:
        if ( !v41 )
          goto LABEL_104;
        goto LABEL_101;
      }
    }
LABEL_93:
    if ( v44 == v43 || v64 & 0x40000 && v47 <= 5 )
      goto LABEL_100;
    if ( v41 )
    {
      if ( v47 > v41 )
      {
        sub_4DB2C((int)v7, *((unsigned __int8 *)v7 + 88));
        if ( v47 <= 0x7F )
          goto LABEL_109;
        sub_4DB6C((int)v7, v47, v43);
        goto LABEL_102;
      }
LABEL_101:
      sub_4DB6C((int)v7, v41, v7[20]);
      v47 = v7[21] - 1;
LABEL_102:
      v7[21] = 0;
      goto LABEL_111;
    }
    if ( !v43 )
    {
LABEL_104:
      sub_4DB2C((int)v7, *((unsigned __int8 *)v7 + v44 + 148));
LABEL_110:
      v47 = 1;
      goto LABEL_111;
    }
    if ( !v7[5] && !(v64 & 0x20000) && v47 <= 0x7F )
    {
LABEL_109:
      v56 = *((unsigned __int8 *)v7 + v44 + 148);
      v7[20] = v43;
      v7[21] = v47;
      v7[22] = v56;
      goto LABEL_110;
    }
    sub_4DB6C((int)v7, v47, v43);
LABEL_111:
    v57 = v7[11];
    v7[8] += v47;
    v7[9] -= v47;
    v58 = v7[10] + v47;
    if ( v58 >= 0x8000 )
      v58 = 0x8000;
    v7[10] = v58;
    if ( (unsigned int)v7 + 103022 >= v57 )
    {
      v59 = v7[16];
      if ( v59 <= 0x7C00 || v59 > 115 * (v57 - ((unsigned int)v7 + 37494)) >> 7 && !(v7[2] & 0x100000) )
        continue;
    }
    v7[34] = v14;
    v7[35] = v8;
    v60 = sub_4E644((int)v7, 0);
    if ( v60 )
    {
      if ( v60 >= 0 )
        goto LABEL_123;
      return v7[28];
    }
  }
  v7[34] = v14;
  v7[35] = v8;
LABEL_123:
  if ( v7[2] & 0x3000 && v6 )
    v7[6] = mz_adler32(v7[6], v6, v7[34] - (_DWORD)v6);
  if ( v7[2] & 0x4000 )
    v7[7] = mz_crc32(v7[7], v6, v7[34] - (_DWORD)v6);
  if ( a6 && !v7[9] && !v7[35] && !v7[24] )
  {
    if ( sub_4E644((int)v7, a6) < 0 )
      return v7[28];
    v7[25] = v70;
    if ( a6 == 3 )
    {
      memset((char *)v7 + 168566, 0, 0x10000u);
      memset((char *)v7 + 103030, 0, 0x10000u);
      v7[10] = 0;
    }
  }
LABEL_136:
  result = sub_4E588(v7);
LABEL_137:
  v7[28] = result;
  return result;
}

//----- (00050A66) --------------------------------------------------------
int __fastcall tdefl_compress_buffer(_DWORD *a1, unsigned __int8 *a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-14h]

  v5 = a3;
  return tdefl_compress(a1, a2, (unsigned int *)&v5, 0, 0, a4);
}

//----- (00050A82) --------------------------------------------------------
int __fastcall tdefl_init(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  _DWORD *v4; // r4

  v4 = a1;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  a1[5] = (a4 >> 15) & 1;
  a1[3] = (signed int)((a4 & 0xFFF) + 2) / 3 + 1;
  a1[4] = (((signed int)(a4 & 0xFFF) >> 2) + 2) / 3 + 1;
  if ( !(a4 & 0x10000) )
    memset((char *)a1 + 168566, 0, 0x10000u);
  v4[12] = (char *)v4 + 37494;
  v4[15] = 8;
  v4[11] = (char *)v4 + 37495;
  v4[13] = (char *)v4 + 234102;
  v4[14] = (char *)v4 + 234102;
  v4[18] = 0;
  v4[6] = 1;
  v4[7] = 1;
  v4[17] = 0;
  v4[16] = 0;
  v4[10] = 0;
  v4[9] = 0;
  v4[8] = 0;
  v4[27] = 0;
  v4[19] = 0;
  v4[26] = 0;
  v4[25] = 0;
  v4[24] = 0;
  v4[23] = 0;
  v4[28] = 0;
  v4[22] = 0;
  v4[21] = 0;
  v4[20] = 0;
  v4[29] = 0;
  v4[30] = 0;
  v4[31] = 0;
  v4[32] = 0;
  v4[33] = 0;
  v4[34] = 0;
  v4[35] = 0;
  v4[36] = 0;
  memset((char *)v4 + 33174, 0, 0x240u);
  memset((char *)v4 + 33750, 0, 0x40u);
  return 0;
}

//----- (00050B4A) --------------------------------------------------------
signed int __fastcall mz_deflateReset(_DWORD *a1)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r0

  v1 = a1;
  if ( !a1 )
    return -2;
  v2 = (_DWORD *)a1[7];
  if ( !v2 || !v1[8] || !v1[9] )
    return -2;
  v1[5] = 0;
  v1[2] = 0;
  tdefl_init(v2, 0, 0, v2[2]);
  return 0;
}

//----- (00050B76) --------------------------------------------------------
int __fastcall tdefl_get_prev_return_status(int a1)
{
  return *(_DWORD *)(a1 + 112);
}

//----- (00050B7A) --------------------------------------------------------
int __fastcall tdefl_get_adler32(int a1)
{
  return *(_DWORD *)(a1 + 24);
}

//----- (00050B7E) --------------------------------------------------------
int __fastcall tdefl_get_crc32(int a1)
{
  return *(_DWORD *)(a1 + 28);
}

//----- (00050B82) --------------------------------------------------------
signed int __fastcall mz_deflate(unsigned __int8 **a1, unsigned int a2, int a3, int a4)
{
  int v4; // r5
  unsigned __int8 **v5; // r4
  unsigned __int8 *v7; // r3
  int v8; // r3
  unsigned __int8 *v9; // r7
  unsigned __int8 *v10; // r6
  int v11; // r0
  int v12; // r3
  int v13; // r10
  int v14; // r0
  int v15; // r1
  unsigned __int8 *v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // [sp+8h] [bp-28h]
  int v20; // [sp+Ch] [bp-24h]

  v19 = a3;
  v20 = a4;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return -2;
  v7 = a1[7];
  if ( !v7 || a2 > 4 || !a1[3] )
    return -2;
  if ( !a1[4] )
    return -5;
  v8 = *((_DWORD *)v7 + 28);
  if ( a2 == 1 )
    v4 = 2;
  if ( v8 != 1 )
  {
    v9 = a1[2];
    v10 = a1[5];
    while ( 1 )
    {
      v19 = (int)v5[1];
      v20 = (int)v5[4];
      v11 = tdefl_compress(v5[7], *v5, (unsigned int *)&v19, (int)v5[3], &v20, v4);
      v12 = v19;
      *v5 += v19;
      v5[1] -= v12;
      v5[2] += v12;
      v13 = v11;
      v5[12] = (unsigned __int8 *)tdefl_get_adler32((int)v5[7]);
      v14 = tdefl_get_crc32((int)v5[7]);
      v15 = v20;
      v16 = v5[5];
      v5[3] += v20;
      v17 = (int)&v5[4][-v15];
      v18 = (int)&v16[v15];
      v5[4] = (unsigned __int8 *)v17;
      v5[5] = (unsigned __int8 *)v18;
      v5[13] = (unsigned __int8 *)v14;
      if ( v13 < 0 )
        break;
      if ( v13 == 1 )
        return 1;
      if ( !v17 )
        return v17;
      v17 = (int)v5[1];
      if ( !v17 && v4 != 4 )
      {
        if ( v4 )
          return v17;
        if ( v5[2] != v9 || (unsigned __int8 *)v18 != v10 )
          return 0;
        return -5;
      }
    }
    return -2;
  }
  if ( v4 == 4 )
    return 1;
  return -5;
}

//----- (00050C54) --------------------------------------------------------
bool __fastcall tdefl_compress_mem_to_output(unsigned __int8 *a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned __int8 *v5; // r6
  int v6; // r7
  int v7; // r8
  int v8; // r5
  _DWORD *v10; // r0
  _DWORD *v11; // r4
  _BOOL4 v12; // r5

  v5 = a1;
  v6 = a3;
  v7 = a4;
  v8 = a2;
  if ( a2 && !a1 )
    return 0;
  if ( !a3 )
    return 0;
  v10 = malloc(0x4DF44u);
  v11 = v10;
  if ( !v10 )
    return 0;
  if ( tdefl_init(v10, v6, v7, a5) )
    v12 = 0;
  else
    v12 = (unsigned int)(tdefl_compress_buffer(v11, v5, v8, 4) - 1) <= 0;
  free(v11);
  return v12;
}

//----- (00050CAC) --------------------------------------------------------
int __fastcall tdefl_compress_mem_to_heap(unsigned __int8 *a1, int a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v4; // r4
  unsigned __int8 *v5; // r7
  int v6; // r6
  unsigned int v7; // r8
  int result; // r0
  int s; // [sp+8h] [bp-28h]
  int v10; // [sp+10h] [bp-20h]
  int v11; // [sp+14h] [bp-1Ch]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  memset(&s, 0, 0x10u);
  if ( !v4 )
    return 0;
  *v4 = 0;
  v11 = 1;
  if ( !tdefl_compress_mem_to_output(v5, v6, (int)sub_4E5F2, (int)&s, v7) )
    return 0;
  result = v10;
  *v4 = s;
  return result;
}

//----- (00050CFC) --------------------------------------------------------
int __fastcall tdefl_compress_mem_to_mem(int a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  int v5; // r4
  int v6; // r6
  unsigned __int8 *v7; // r7
  int v8; // r8
  int result; // r0
  int s; // [sp+8h] [bp-28h]
  int v11; // [sp+Ch] [bp-24h]
  int v12; // [sp+10h] [bp-20h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  memset(&s, 0, 0x10u);
  if ( v5 && (v12 = v5, v11 = v6, tdefl_compress_mem_to_output(v7, v8, (int)sub_4E5F2, (int)&s, a5)) )
    result = s;
  else
    result = 0;
  return result;
}

//----- (00050D44) --------------------------------------------------------
int __fastcall tdefl_create_comp_flags_from_zip_params(signed int a1, int a2, int a3)
{
  signed int v3; // r3
  _DWORD *v4; // r0
  signed int v5; // r4
  int result; // r0

  v3 = a1;
  if ( a1 < 0 )
  {
    a1 = 6;
  }
  else if ( a1 >= 10 )
  {
    a1 = 10;
  }
  v4 = &dword_E9BF4[a1];
  if ( v3 > 3 )
    v5 = 0;
  else
    v5 = 0x8000;
  result = v5 | v4[684];
  if ( a2 > 0 )
    result |= 0x1000u;
  if ( !v3 )
    return result | 0x100000;
  switch ( a3 )
  {
    case 1:
      return result | 0x40000;
    case 2:
      return result & 0xFFFFF000;
    case 4:
      return result | 0x80000;
    case 3:
      result |= 0x20000u;
      break;
  }
  return result;
}

//----- (00050DB0) --------------------------------------------------------
int __fastcall mz_deflateInit2(_DWORD *a1, signed int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // r4
  int v7; // r6
  int v8; // r5
  int v9; // r7
  int v10; // r2
  _DWORD *v11; // r0
  int result; // r0

  v6 = a1;
  v7 = a3;
  v8 = a4;
  v9 = tdefl_create_comp_flags_from_zip_params(a2, a4, a6) | 0x6000;
  if ( !v6 )
    return -2;
  if ( v7 != 8 || (unsigned int)(a5 - 1) > 8 || v8 != 15 && v8 != -15 )
    return -10000;
  v6[11] = 0;
  v6[13] = 0;
  v6[6] = 0;
  v6[14] = 0;
  v6[2] = 0;
  v6[5] = 0;
  v10 = v6[8];
  v6[12] = 1;
  if ( !v10 )
    v6[8] = sub_4DC02;
  if ( !v6[9] )
    v6[9] = sub_4DBFC;
  v11 = (_DWORD *)((int (__fastcall *)(_DWORD, signed int, signed int))v6[8])(v6[10], 1, 319300);
  if ( v11 )
  {
    v6[7] = v11;
    result = tdefl_init(v11, 0, 0, v9);
    if ( !result )
      return result;
    mz_deflateEnd((int)v6);
    return -10000;
  }
  return -4;
}
// 4DBFC: using guessed type int sub_4DBFC();
// 4DC02: using guessed type int sub_4DC02();

//----- (00050E48) --------------------------------------------------------
int __fastcall mz_deflateInit(_DWORD *a1, signed int a2)
{
  return mz_deflateInit2(a1, a2, 8, 15, 9, 0);
}

//----- (00050E60) --------------------------------------------------------
int __fastcall mz_compress2(int a1, int *a2, int a3, int a4, signed int a5)
{
  int v5; // r5
  int *v6; // r6
  int v7; // r7
  int v8; // r8
  int v9; // r3
  int result; // r0
  int v11; // r2
  int v12; // r3
  signed int v13; // r5
  int s; // [sp+4h] [bp-54h]
  int v15; // [sp+8h] [bp-50h]
  int v16; // [sp+10h] [bp-48h]
  int v17; // [sp+14h] [bp-44h]
  int v18; // [sp+18h] [bp-40h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  memset(&s, 0, 0x3Cu);
  v9 = *v6;
  s = v7;
  v15 = v8;
  v16 = v5;
  v17 = v9;
  result = mz_deflateInit(&s, a5);
  if ( !result )
  {
    v13 = mz_deflate((unsigned __int8 **)&s, 4u, v11, v12);
    if ( v13 == 1 )
    {
      *v6 = v18;
      result = mz_deflateEnd((int)&s);
    }
    else
    {
      mz_deflateEnd((int)&s);
      if ( v13 )
        result = v13;
      else
        result = -5;
    }
  }
  return result;
}

//----- (00050EC0) --------------------------------------------------------
int __fastcall mz_compress(int a1, int *a2, int a3, int a4)
{
  return mz_compress2(a1, a2, a3, a4, -1);
}

//----- (00050ED0) --------------------------------------------------------
void *__fastcall tdefl_write_image_to_png_file_in_memory(unsigned __int8 *a1, int a2, int a3, int a4, _DWORD *a5)
{
  unsigned __int8 *v5; // r11
  int v6; // r8
  int v7; // r7
  _DWORD *v8; // r0
  int v9; // r9
  _DWORD *v10; // r4
  int v11; // r0
  void *v12; // r10
  int *v13; // r3
  int v14; // r10
  int *v15; // ST04_4
  unsigned __int8 *v16; // r12
  unsigned __int8 *v17; // ST04_4
  int v18; // r3
  char v19; // r7
  int v20; // r0
  char *v21; // r2
  _BYTE *v22; // r3
  _BYTE *v23; // r7
  int v24; // r1
  bool v25; // zf
  unsigned __int64 v26; // r0
  int v27; // r3
  int v28; // r2
  int v30; // [sp+8h] [bp-78h]
  int v31; // [sp+14h] [bp-6Ch]
  int s; // [sp+18h] [bp-68h]
  int v33; // [sp+1Ch] [bp-64h]
  void *ptr; // [sp+20h] [bp-60h]
  int v35; // [sp+24h] [bp-5Ch]
  char v36; // [sp+28h] [bp-58h]
  char v37; // [sp+29h] [bp-57h]
  char v38; // [sp+2Ah] [bp-56h]
  char v39; // [sp+2Bh] [bp-55h]
  char v40; // [sp+2Ch] [bp-54h]
  char v41; // [sp+2Dh] [bp-53h]
  char v42; // [sp+2Eh] [bp-52h]
  char v43; // [sp+2Fh] [bp-51h]
  char v44; // [sp+30h] [bp-50h]
  char v45; // [sp+31h] [bp-4Fh]
  char v46; // [sp+32h] [bp-4Eh]
  char v47; // [sp+33h] [bp-4Dh]
  char v48; // [sp+34h] [bp-4Ch]
  char v49; // [sp+35h] [bp-4Bh]
  char v50; // [sp+36h] [bp-4Ah]
  char v51; // [sp+37h] [bp-49h]
  char v52; // [sp+38h] [bp-48h]
  char v53; // [sp+39h] [bp-47h]
  char v54; // [sp+3Ah] [bp-46h]
  char v55; // [sp+3Bh] [bp-45h]
  char v56; // [sp+3Ch] [bp-44h]
  char v57; // [sp+3Dh] [bp-43h]
  char v58; // [sp+3Eh] [bp-42h]
  char v59; // [sp+3Fh] [bp-41h]
  char v60; // [sp+40h] [bp-40h]
  char v61; // [sp+41h] [bp-3Fh]
  char v62; // [sp+42h] [bp-3Eh]
  char v63; // [sp+43h] [bp-3Dh]
  char v64; // [sp+44h] [bp-3Ch]
  char v65; // [sp+45h] [bp-3Bh]
  char v66; // [sp+46h] [bp-3Ah]
  char v67; // [sp+47h] [bp-39h]
  char v68; // [sp+48h] [bp-38h]
  char v69; // [sp+49h] [bp-37h]
  char v70; // [sp+4Ah] [bp-36h]
  char v71; // [sp+4Bh] [bp-35h]
  char v72; // [sp+4Ch] [bp-34h]
  char v73; // [sp+4Dh] [bp-33h]
  char v74; // [sp+4Eh] [bp-32h]
  char v75; // [sp+4Fh] [bp-31h]
  char v76; // [sp+50h] [bp-30h]

  v5 = a1;
  v30 = a4;
  v6 = a2;
  v7 = a3;
  v8 = malloc(0x4DF44u);
  v9 = v30 * v6;
  *a5 = 0;
  v10 = v8;
  if ( !v8 )
    return 0;
  memset(&s, 0, 0x10u);
  v35 = 1;
  v11 = (v9 + 1) * v7;
  if ( v11 < 64 )
    v11 = 64;
  v33 = v11 + 57;
  v12 = malloc(v11 + 57);
  ptr = v12;
  if ( v12 )
  {
    v31 = 41;
    v13 = &v31;
    while ( 1 )
    {
      v14 = v31;
      if ( !v31 )
        break;
      v15 = v13;
      sub_4E5F2(v13, 1u, (int)&s);
      v13 = v15;
      --v31;
    }
    tdefl_init(v10, (int)sub_4E5F2, (int)&s, 0x1080u);
    v16 = (unsigned __int8 *)&v31;
    while ( v14 < v7 )
    {
      v17 = v16;
      tdefl_compress_buffer(v10, v16, 1, 0);
      ++v14;
      tdefl_compress_buffer(v10, v5, v9, 0);
      v5 += v9;
      v16 = v17;
    }
    if ( tdefl_compress_buffer(v10, 0, 0, 4) == 1 )
    {
      v59 = v7;
      v51 = 82;
      v54 = BYTE1(v6);
      v60 = 8;
      v58 = BYTE1(v7);
      v36 = -119;
      v18 = s - 41;
      v19 = *((_BYTE *)&dword_E9BF4[695] + v30);
      *a5 = s - 41;
      v37 = 80;
      v41 = 10;
      v38 = 78;
      v42 = 26;
      v39 = 71;
      v43 = 10;
      v40 = 13;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 13;
      v48 = 73;
      v49 = 72;
      v52 = 0;
      v50 = 68;
      v53 = 0;
      v56 = 0;
      v57 = 0;
      v61 = v19;
      v62 = 0;
      v63 = 0;
      v64 = 0;
      v55 = v6;
      v65 = 0;
      v73 = 73;
      v74 = 68;
      v69 = HIBYTE(v18);
      v72 = v18;
      v70 = BYTE2(v18);
      v66 = 0;
      v71 = BYTE1(v18);
      v75 = 65;
      v67 = 0;
      v76 = 84;
      v68 = 0;
      v20 = mz_crc32(0, (unsigned __int8 *)&v48, 17);
      v21 = &v36;
      v65 = HIBYTE(v20);
      v66 = BYTE2(v20);
      v67 = BYTE1(v20);
      v22 = ptr;
      v68 = v20;
      do
      {
        v22 += 8;
        v24 = *((_DWORD *)v21 + 1);
        v23 = v21 + 8;
        v25 = v21 + 8 == &v76;
        *((_DWORD *)v22 - 2) = *(_DWORD *)v21;
        v21 += 8;
        *((_DWORD *)v22 - 1) = v24;
      }
      while ( !v25 );
      *v22 = *v23;
      if ( sub_4E5F2((char *)&dword_E9BF4[696] + 2, 0x10u, (int)&s) )
      {
        LODWORD(v26) = mz_crc32(0, (unsigned __int8 *)ptr + 37, *a5 + 4);
        v27 = 0;
        do
        {
          HIDWORD(v26) = (char *)ptr + v27++;
          v28 = s + HIDWORD(v26);
          v26 = (unsigned __int64)(unsigned int)v26 << 8;
          *(_BYTE *)(v28 - 16) = BYTE4(v26);
        }
        while ( v27 != 4 );
        *a5 += 57;
        free(v10);
        v12 = ptr;
      }
      else
      {
        *a5 = 0;
        free(v10);
        free(ptr);
        v12 = 0;
      }
    }
    else
    {
      v12 = 0;
      free(v10);
      free(ptr);
    }
  }
  else
  {
    free(v10);
  }
  return v12;
}

//----- (00051174) --------------------------------------------------------
void __fastcall sub_51174(void **a1, unsigned int a2)
{
  void **v2; // r4
  unsigned int v3; // r5
  void *v4; // t1

  v2 = a1;
  v3 = a2;
  while ( (unsigned int)v2 < v3 )
  {
    v4 = *v2;
    ++v2;
    operator delete(v4);
  }
}

//----- (0005118A) --------------------------------------------------------
int __fastcall Json::Features::Features(int result)
{
  *(_BYTE *)result = 1;
  *(_BYTE *)(result + 1) = 0;
  return result;
}

//----- (00051194) --------------------------------------------------------
int __fastcall Json::Features::all(Json::Features *this, int a2, int a3)
{
  Json::Features *v4; // [sp+0h] [bp-10h]
  int v5; // [sp+4h] [bp-Ch]
  int v6; // [sp+8h] [bp-8h]

  v4 = this;
  v5 = a2;
  v6 = a3;
  Json::Features::Features((int)&v4);
  return (unsigned __int8)v4 | ((((unsigned __int16)v4 >> 8) & 0xFF) << 8);
}

//----- (000511B6) --------------------------------------------------------
signed int __fastcall Json::Features::strictMode(Json::Features *this, int a2, int a3)
{
  Json::Features *v4; // [sp+0h] [bp-10h]
  int v5; // [sp+4h] [bp-Ch]
  int v6; // [sp+8h] [bp-8h]

  v4 = this;
  v5 = a2;
  v6 = a3;
  Json::Features::Features((int)&v4);
  return 256;
}

//----- (000511E2) --------------------------------------------------------
int __fastcall Json::Reader::skipSpaces(int result)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r3
  int v3; // r2

  v1 = *(unsigned __int8 **)(result + 88);
  while ( 1 )
  {
    v2 = *(unsigned __int8 **)(result + 92);
    if ( v2 == v1 )
      break;
    v3 = *v2;
    if ( v3 != 32 && (unsigned int)(v3 - 9) > 1 && v3 != 13 )
      break;
    *(_DWORD *)(result + 92) = v2 + 1;
  }
  return result;
}

//----- (00051206) --------------------------------------------------------
signed int __fastcall Json::Reader::match(Json::Reader *this, const char *a2, int a3)
{
  int v3; // r4
  int v4; // r3
  int v5; // r5

  v3 = *((_DWORD *)this + 23);
  if ( *((_DWORD *)this + 22) - v3 < a3 )
    return 0;
  v4 = a3 - 1;
  while ( v4 != -1 )
  {
    v5 = *(unsigned __int8 *)(v3 + v4--);
    if ( (unsigned __int8)a2[v4 + 1] != v5 )
      return 0;
  }
  *((_DWORD *)this + 23) = a3 + v3;
  return 1;
}

//----- (00051232) --------------------------------------------------------
int __fastcall Json::Reader::readNumber(int result)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  int v3; // r3

  v1 = *(unsigned __int8 **)(result + 88);
  while ( 1 )
  {
    v2 = *(unsigned __int8 **)(result + 92);
    if ( v2 == v1 )
      break;
    v3 = *v2;
    if ( (unsigned int)(v3 - 48) > 9 && (v3 & 0xDF) != 69 && v3 != 43 && (unsigned int)(v3 - 45) > 1 )
      break;
    *(_DWORD *)(result + 92) = v2 + 1;
  }
  return result;
}

//----- (00051264) --------------------------------------------------------
_DWORD *__fastcall Json::Reader::ErrorInfo::ErrorInfo(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  int v4; // r0
  int v5; // t0
  int v6; // r1
  int v7; // r2
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2;
  v4 = *a2;
  v5 = (int)(a2 + 1);
  v6 = a2[1];
  v7 = *(_DWORD *)(v5 + 4);
  *v2 = v4;
  v2[1] = v6;
  v2[2] = v7;
  sub_C16AC(v2 + 3, v3 + 3);
  result = v2;
  v2[4] = v3[4];
  return result;
}

//----- (00051284) --------------------------------------------------------
int __fastcall Json::Reader::getNextChar(Json::Reader *this)
{
  unsigned __int8 *v1; // r3

  v1 = (unsigned __int8 *)*((_DWORD *)this + 23);
  if ( v1 == *((unsigned __int8 **)this + 22) )
    return 0;
  *((_DWORD *)this + 23) = v1 + 1;
  return *v1;
}

//----- (00051296) --------------------------------------------------------
bool __fastcall Json::Reader::readCStyleComment(Json::Reader *this)
{
  Json::Reader *v1; // r4

  v1 = this;
  while ( *((_DWORD *)v1 + 23) != *((_DWORD *)v1 + 22)
       && (Json::Reader::getNextChar(v1) != 42 || **((_BYTE **)v1 + 23) != 47) )
    ;
  return (unsigned int)(Json::Reader::getNextChar(v1) - 47) <= 0;
}

//----- (000512C4) --------------------------------------------------------
signed int __fastcall Json::Reader::readCppStyleComment(Json::Reader *this)
{
  Json::Reader *v1; // r4
  int v2; // r0

  v1 = this;
  do
  {
    if ( *((_DWORD *)v1 + 23) == *((_DWORD *)v1 + 22) )
      break;
    v2 = Json::Reader::getNextChar(v1);
    if ( v2 == 13 )
      break;
  }
  while ( v2 != 10 );
  return 1;
}

//----- (000512E2) --------------------------------------------------------
bool __fastcall Json::Reader::readString(Json::Reader *this)
{
  Json::Reader *v1; // r5
  int v2; // r4
  int v3; // r0

  v1 = this;
  v2 = 0;
  while ( *((_DWORD *)v1 + 23) != *((_DWORD *)v1 + 22) )
  {
    v3 = Json::Reader::getNextChar(v1);
    v2 = v3;
    if ( v3 == 92 )
    {
      Json::Reader::getNextChar(v1);
    }
    else if ( v3 == 34 )
    {
      return (unsigned int)(v2 - 34) <= 0;
    }
  }
  return (unsigned int)(v2 - 34) <= 0;
}

//----- (00051312) --------------------------------------------------------
int __fastcall Json::Reader::getLocationLineAndColumn(int result, const char *a2, int *a3, int *a4)
{
  unsigned __int8 *v4; // r4
  int v5; // r6
  int v6; // r7
  int v7; // r5

  v4 = *(unsigned __int8 **)(result + 84);
  *a3 = 0;
  v5 = (int)v4;
  while ( v4 < (unsigned __int8 *)a2 && v4 != *(unsigned __int8 **)(result + 88) )
  {
    v6 = *v4;
    v7 = (int)(v4 + 1);
    if ( v6 == 13 )
    {
      if ( v4[1] == 10 )
        v7 = (int)(v4 + 2);
    }
    else if ( v6 != 10 )
    {
      goto LABEL_10;
    }
    v5 = v7;
    ++*a3;
LABEL_10:
    v4 = (unsigned __int8 *)v7;
  }
  *a4 = (int)&a2[-v5 + 1];
  ++*a3;
  return result;
}

//----- (00051358) --------------------------------------------------------
void **__fastcall Json::Reader::getLocationLineAndColumn(Json::Reader *this, const char *a2, const char *a3)
{
  void **v3; // r5
  int v5; // [sp+8h] [bp-50h]
  int v6; // [sp+Ch] [bp-4Ch]
  char v7; // [sp+10h] [bp-48h]

  v3 = (void **)this;
  Json::Reader::getLocationLineAndColumn((int)a2, a3, &v5, &v6);
  sprintf(&v7, "Line %d, Column %d", v5, v6);
  sub_C1C58(v3, &v7);
  return v3;
}

//----- (000513A8) --------------------------------------------------------
_DWORD *__fastcall sub_513A8(_DWORD *a1, _BYTE *a2, int a3)
{
  _DWORD *v3; // r7
  _BYTE *v4; // r5
  int v5; // r4
  void *v6; // r6
  int *v7; // r0
  int *v8; // r9

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( a2 == (_BYTE *)a3 )
  {
    v6 = &unk_2FEF48;
  }
  else
  {
    if ( !a2 && a3 )
      sub_BFA98((int)"basic_string::_S_construct null not valid");
    v7 = sub_C09E4(a3 - (_DWORD)a2, 0);
    v6 = v7 + 3;
    v8 = v7;
    sub_C0348((_BYTE *)v7 + 12, v4, v5);
    sub_C09C4(v8, v5 - (_DWORD)v4);
  }
  *v3 = v6;
  return v3;
}

//----- (00051404) --------------------------------------------------------
_DWORD *__fastcall Json::Reader::addComment(int a1, _BYTE *a2, int a3, int a4)
{
  _BYTE *v4; // r9
  int v5; // r8
  int v6; // r6
  int v7; // r5
  int v8; // r5
  _BYTE *v10; // [sp+4h] [bp-24h]
  int v11; // [sp+8h] [bp-20h]

  v10 = a2;
  v11 = a3;
  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( a4 == 1 )
  {
    v7 = *(_DWORD *)(a1 + 100);
    sub_513A8(&v10, a2, a3);
    Json::Value::setComment(v7, (const char **)&v10, v6);
  }
  else
  {
    v8 = a1 + 104;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 104) - 12) )
      sub_C14E4((unsigned int *)(a1 + 104), "\n");
    sub_513A8(&v10, v4, v5);
    sub_C135C(v8, &v10);
  }
  return sub_C0AD8(&v10);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00051470) --------------------------------------------------------
signed int __fastcall Json::Reader::readComment(Json::Reader *this)
{
  Json::Reader *v1; // r4
  int v2; // r7
  int v3; // r0
  int v4; // r6
  signed int v5; // r0
  int v6; // r5
  unsigned __int8 *v7; // r3
  unsigned __int8 *v8; // r1
  int v9; // r2
  int v10; // t1
  unsigned __int8 *v11; // r3
  int v12; // r2
  int v13; // t1

  v1 = this;
  v2 = *((_DWORD *)this + 23);
  v3 = Json::Reader::getNextChar(this);
  v4 = v3;
  if ( v3 == 42 )
  {
    v5 = Json::Reader::readCStyleComment(v1);
  }
  else
  {
    if ( v3 != 47 )
      return 0;
    v5 = Json::Reader::readCppStyleComment(v1);
  }
  if ( !v5 )
    return 0;
  v6 = *((unsigned __int8 *)v1 + 110);
  if ( !*((_BYTE *)v1 + 110) )
    return 1;
  v7 = (unsigned __int8 *)*((_DWORD *)v1 + 24);
  v8 = (unsigned __int8 *)(v2 - 1);
  if ( v7 )
  {
    while ( v7 < v8 )
    {
      v10 = *v7++;
      v9 = v10;
      if ( v10 == 10 || v9 == 13 )
      {
LABEL_17:
        v7 = 0;
        goto LABEL_19;
      }
    }
    if ( v4 == 42 )
    {
      v11 = (unsigned __int8 *)(v2 - 1);
      while ( *((_DWORD *)v1 + 23) > (unsigned int)v11 )
      {
        v13 = *v11++;
        v12 = v13;
        if ( v13 == 10 || v12 == 13 )
          goto LABEL_17;
      }
    }
    v7 = (_BYTE *)(&dword_0 + 1);
  }
LABEL_19:
  Json::Reader::addComment((int)v1, v8, *((_DWORD *)v1 + 23), (int)v7);
  return v6;
}
// 0: using guessed type int dword_0;

//----- (000514EC) --------------------------------------------------------
signed int __fastcall Json::Reader::readToken(int a1, signed int *a2)
{
  Json::Reader *v2; // r5
  signed int *v3; // r4
  unsigned int v4; // r0
  signed int v5; // r3
  Json::Reader *v6; // r0
  const char *v7; // r1
  signed int v8; // r0
  int v9; // r2
  signed int result; // r0

  v2 = (Json::Reader *)a1;
  v3 = a2;
  Json::Reader::skipSpaces(a1);
  v3[1] = *((_DWORD *)v2 + 23);
  v4 = Json::Reader::getNextChar(v2);
  if ( v4 == 58 )
  {
    v5 = 11;
    goto LABEL_36;
  }
  if ( v4 > 0x3A )
  {
    if ( v4 == 110 )
    {
      v6 = v2;
      *v3 = 9;
      v7 = "ull";
    }
    else
    {
      if ( v4 <= 0x6E )
      {
        if ( v4 == 93 )
        {
          v5 = 4;
          goto LABEL_36;
        }
        if ( v4 != 102 )
        {
          if ( v4 != 91 )
            goto LABEL_35;
          v5 = 3;
LABEL_36:
          *v3 = v5;
          goto LABEL_37;
        }
        v6 = v2;
        *v3 = 8;
        v7 = "alse";
        v9 = 4;
LABEL_31:
        v8 = Json::Reader::match(v6, v7, v9);
        goto LABEL_34;
      }
      if ( v4 == 123 )
      {
        v5 = 1;
        goto LABEL_36;
      }
      if ( v4 == 125 )
      {
        v5 = 2;
        goto LABEL_36;
      }
      if ( v4 != 116 )
        goto LABEL_35;
      v6 = v2;
      *v3 = 7;
      v7 = "rue";
    }
    v9 = 3;
    goto LABEL_31;
  }
  if ( v4 == 45 )
    goto LABEL_27;
  if ( v4 > 0x2D )
  {
    if ( v4 != 47 )
    {
      if ( v4 < 0x2F )
        goto LABEL_35;
LABEL_27:
      *v3 = 6;
      Json::Reader::readNumber((int)v2);
      goto LABEL_37;
    }
    *v3 = 12;
    v8 = Json::Reader::readComment(v2);
LABEL_34:
    if ( v8 )
      goto LABEL_37;
    goto LABEL_35;
  }
  if ( v4 == 34 )
  {
    *v3 = 5;
    v8 = Json::Reader::readString(v2);
    goto LABEL_34;
  }
  if ( v4 == 44 )
  {
    v5 = 10;
    goto LABEL_36;
  }
  if ( v4 )
  {
LABEL_35:
    v5 = 13;
    goto LABEL_36;
  }
  *v3 = 0;
LABEL_37:
  result = 1;
  v3[2] = *((_DWORD *)v2 + 23);
  return result;
}

//----- (000515C4) --------------------------------------------------------
signed int __fastcall Json::Reader::skipCommentTokens(int a1, signed int *a2)
{
  int v2; // r5
  signed int *v3; // r4
  signed int result; // r0

  v2 = a1;
  v3 = a2;
  if ( !*(_BYTE *)(a1 + 108) )
    return Json::Reader::readToken(a1, a2);
  do
    result = Json::Reader::readToken(v2, v3);
  while ( *v3 == 12 );
  return result;
}

//----- (000515E8) --------------------------------------------------------
unsigned int *__fastcall sub_515E8(unsigned int *a1, const char *a2, _BYTE **a3)
{
  unsigned int *v3; // r4
  unsigned int v4; // r7
  _BYTE **v5; // r5
  size_t v6; // r0
  size_t v7; // r6

  v3 = a1;
  v4 = (unsigned int)a2;
  v5 = a3;
  v6 = strlen(a2);
  *v3 = (unsigned int)&unk_2FEF48;
  v7 = v6;
  sub_C1264(v3, *((_DWORD *)*v5 - 3) + v6);
  sub_C13F8(v3, v4, v7);
  sub_C12E4((int *)v3, v5);
  return v3;
}

//----- (00051634) --------------------------------------------------------
unsigned int *__fastcall std::operator+<char,std::char_traits<char>,std::allocator<char>>(unsigned int *a1, int *a2, const char *a3)
{
  unsigned int *v3; // r4
  const char *v4; // r5

  v3 = a1;
  v4 = a3;
  sub_C16AC(a1, a2);
  sub_C14B4(v3, v4);
  return v3;
}

//----- (00051654) --------------------------------------------------------
Json::Reader *__fastcall Json::Reader::getFormatedErrorMessages(Json::Reader *this, const char *a2)
{
  int v2; // r4
  Json::Reader *v3; // r5
  int v4; // r11
  const char *v5; // r6
  const char *v6; // r2
  int v8; // [sp+4h] [bp-54h]
  char v9; // [sp+10h] [bp-48h]
  unsigned int v10; // [sp+14h] [bp-44h]
  unsigned int v11; // [sp+18h] [bp-40h]
  unsigned int v12; // [sp+1Ch] [bp-3Ch]
  unsigned int v13; // [sp+20h] [bp-38h]
  char v14; // [sp+24h] [bp-34h]
  unsigned int v15; // [sp+28h] [bp-30h]
  char v16; // [sp+2Ch] [bp-2Ch]

  *(_DWORD *)this = &unk_2FEF48;
  v2 = *((_DWORD *)a2 + 12);
  v3 = this;
  v4 = *((_DWORD *)a2 + 14);
  v5 = a2;
  v8 = *((_DWORD *)a2 + 15);
  while ( v2 != *((_DWORD *)v5 + 16) )
  {
    Json::Reader::getLocationLineAndColumn((Json::Reader *)&v9, v5, *(const char **)(v2 + 4));
    sub_515E8(&v10, "* ", (_BYTE **)&v9);
    std::operator+<char,std::char_traits<char>,std::allocator<char>>(&v11, (int *)&v10, "\n");
    sub_C135C(v3, &v11);
    sub_C0AD8(&v11);
    sub_C0AD8(&v10);
    sub_C0AD8(&v9);
    sub_515E8(&v12, "  ", (_BYTE **)(v2 + 12));
    std::operator+<char,std::char_traits<char>,std::allocator<char>>(&v13, (int *)&v12, "\n");
    sub_C135C(v3, &v13);
    sub_C0AD8(&v13);
    sub_C0AD8(&v12);
    v6 = *(const char **)(v2 + 16);
    if ( v6 )
    {
      Json::Reader::getLocationLineAndColumn((Json::Reader *)&v14, v5, v6);
      sub_515E8(&v15, "See ", (_BYTE **)&v14);
      std::operator+<char,std::char_traits<char>,std::allocator<char>>(
        (unsigned int *)&v16,
        (int *)&v15,
        " for detail.\n");
      sub_C135C(v3, &v16);
      sub_C0AD8(&v16);
      sub_C0AD8(&v15);
      sub_C0AD8(&v14);
    }
    v2 += 20;
    if ( v4 == v2 )
    {
      v2 = *(_DWORD *)(v8 + 4);
      v4 = v2 + 500;
      v8 += 4;
    }
  }
  return v3;
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (000517B0) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  return result;
}

//----- (000517C2) --------------------------------------------------------
int __fastcall Json::Reader::currentValue(Json::Reader *this, int a2, int a3, _DWORD *a4)
{
  Json::Reader *v5; // [sp+0h] [bp-18h]
  Json::Reader *v6; // [sp+4h] [bp-14h]
  int v7; // [sp+8h] [bp-10h]
  _DWORD *v8; // [sp+Ch] [bp-Ch]

  v5 = this;
  v6 = (Json::Reader *)a2;
  v7 = a3;
  v8 = a4;
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v5, (_DWORD *)this + 6);
  if ( v5 == v6 )
  {
    --v8;
    v5 = (Json::Reader *)(*v8 + 512);
  }
  return *((_DWORD *)v5 - 1);
}

//----- (000517F2) --------------------------------------------------------
int __fastcall std::deque<Json::Value *,std::allocator<Json::Value *>>::~deque(int a1)
{
  int v1; // r4
  void **v2; // r5
  unsigned int v3; // r6
  void *v4; // t1
  int v6; // [sp+0h] [bp-30h]
  char v7; // [sp+10h] [bp-20h]

  v1 = a1;
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v6, (_DWORD *)(a1 + 8));
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v7, (_DWORD *)(v1 + 24));
  if ( *(_DWORD *)v1 )
  {
    v2 = *(void ***)(v1 + 20);
    v3 = *(_DWORD *)(v1 + 36) + 4;
    while ( (unsigned int)v2 < v3 )
    {
      v4 = *v2;
      ++v2;
      operator delete(v4);
    }
    operator delete(*(void **)v1);
  }
  return v1;
}

//----- (00051830) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  return result;
}

//----- (00051842) --------------------------------------------------------
void __fastcall std::deque<Json::Value *,std::allocator<Json::Value *>>::pop_back(_DWORD *a1)
{
  _DWORD *v1; // r4
  char *v2; // r3
  char *v3; // r0
  int v4; // r3
  int v5; // r3

  v1 = a1;
  v2 = (char *)a1[7];
  v3 = (char *)a1[6];
  if ( v3 == v2 )
  {
    operator delete(v3);
    v4 = v1[9];
    v1[9] = v4 - 4;
    v5 = *(_DWORD *)(v4 - 4);
    v1[8] = v5 + 512;
    v1[7] = v5;
    v1[6] = v5 + 508;
  }
  else
  {
    v1[6] = v3 - 4;
  }
}

//----- (00051874) --------------------------------------------------------
int __fastcall std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(_DWORD *a1, _DWORD *a2)
{
  return -858993459 * ((*a1 - a1[1]) >> 2) + 25 * (((a1[3] - a2[3]) >> 2) - 1) - 858993459 * ((a2[2] - *a2) >> 2);
}

//----- (000518A4) --------------------------------------------------------
char *__fastcall std::_Deque_base<Json::Value *,std::allocator<Json::Value *>>::_M_initialize_map(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // r4
  char v3; // r9
  int v4; // r7
  unsigned int v5; // r0
  char *result; // r0
  unsigned int v7; // r10
  int v8; // r5
  char *v9; // r8
  unsigned int v10; // r7
  char *i; // r6
  int v12; // r2
  int v13; // r3

  v2 = a1;
  v3 = a2;
  v4 = (a2 >> 7) + 1;
  v5 = (a2 >> 7) + 3;
  if ( v5 < 8 )
    v5 = 8;
  v2[1] = v5;
  result = (char *)operator new(4 * v5);
  v7 = (unsigned int)(v2[1] - v4) >> 1;
  v8 = (int)&result[4 * v7];
  v9 = result;
  v10 = v8 + 4 * v4;
  *v2 = result;
  for ( i = &result[4 * v7]; (unsigned int)i < v10; i += 4 )
  {
    result = (char *)operator new(0x200u);
    *(_DWORD *)i = result;
  }
  v2[5] = v8;
  v12 = *(_DWORD *)&v9[4 * v7];
  v2[4] = v12 + 512;
  v2[3] = v12;
  v2[9] = v10 - 4;
  v13 = *(_DWORD *)(v10 - 4);
  v2[2] = v12;
  v2[8] = v13 + 512;
  v2[7] = v13;
  v2[6] = v13 + 4 * (v3 & 0x7F);
  return result;
}

//----- (00051950) --------------------------------------------------------
unsigned int __fastcall std::_Deque_base<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_initialize_map(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // r4
  unsigned int v3; // r9
  unsigned int v4; // r7
  unsigned int v5; // r0
  char *v6; // r0
  unsigned int v7; // r10
  int v8; // r5
  char *v9; // r8
  unsigned int v10; // r7
  void **i; // r6
  int v12; // r3
  int v13; // r5
  unsigned int result; // r0

  v2 = a1;
  v3 = a2;
  v4 = a2 / 0x19 + 1;
  v5 = a2 / 0x19 + 3;
  if ( v5 < 8 )
    v5 = 8;
  v2[1] = v5;
  v6 = (char *)operator new(4 * v5);
  v7 = (v2[1] - v4) >> 1;
  v8 = (int)&v6[4 * v7];
  v9 = v6;
  v10 = v8 + 4 * v4;
  *v2 = v6;
  for ( i = (void **)&v6[4 * v7]; (unsigned int)i < v10; ++i )
    *i = operator new(0x1F4u);
  v2[5] = v8;
  v12 = *(_DWORD *)&v9[4 * v7];
  v2[4] = v12 + 500;
  v2[3] = v12;
  v2[9] = v10 - 4;
  v13 = *(_DWORD *)(v10 - 4);
  v2[2] = v12;
  v2[8] = v13 + 500;
  v2[7] = v13;
  result = v3 / 0x19;
  v2[6] = v13 + 20 * (v3 % 0x19);
  return result;
}

//----- (00051A04) --------------------------------------------------------
int *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+=(int *a1, int a2)
{
  int *v2; // r4
  int v3; // r5
  unsigned int v4; // r0
  int v5; // r3
  int v6; // r3
  int v7; // r3

  v2 = a1;
  v3 = a2 - 858993459 * ((*a1 - a1[1]) >> 2);
  if ( (unsigned int)v3 <= 0x18 )
  {
    v7 = *a1 + 20 * a2;
  }
  else
  {
    if ( v3 <= 0 )
      v4 = ~(~v3 / 0x19u);
    else
      v4 = v3 / 25;
    v5 = v2[3];
    v2[3] = v5 + 4 * v4;
    v6 = *(_DWORD *)(v5 + 4 * v4);
    v2[2] = v6 + 500;
    v2[1] = v6;
    v7 = v6 + 20 * (v3 - 25 * v4);
  }
  *v2 = v7;
  return v2;
}

//----- (00051A64) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // r6
  _DWORD *v5; // r4
  int *v6; // r0
  int v8; // [sp+0h] [bp-20h]
  _DWORD *v9; // [sp+4h] [bp-1Ch]
  int v10; // [sp+8h] [bp-18h]
  int v11; // [sp+Ch] [bp-14h]

  v8 = a1;
  v9 = a2;
  v10 = a3;
  v11 = a4;
  v4 = a3;
  v5 = (_DWORD *)a1;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v8,
    a2);
  v6 = std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+=(
         &v8,
         v4);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    v5,
    v6);
  return v5;
}

//----- (00051A86) --------------------------------------------------------
_DWORD *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator-(int a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // r4
  int v5; // r6
  int *v6; // r0
  int v8; // [sp+0h] [bp-20h]
  _DWORD *v9; // [sp+4h] [bp-1Ch]
  int v10; // [sp+8h] [bp-18h]
  int v11; // [sp+Ch] [bp-14h]

  v8 = a1;
  v9 = a2;
  v10 = a3;
  v11 = a4;
  v4 = (_DWORD *)a1;
  v5 = a3;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v8,
    a2);
  v6 = std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+=(
         &v8,
         -v5);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    v4,
    v6);
  return v4;
}

//----- (00051AA8) --------------------------------------------------------
_DWORD *__fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_destroy_data_aux(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  _DWORD **v5; // r6
  unsigned int v6; // r3
  _DWORD *v7; // t1
  _DWORD *v8; // r0

  v3 = a2;
  v4 = a3;
  v5 = (_DWORD **)(*(_DWORD *)(a2 + 12) + 4);
  while ( 1 )
  {
    v6 = *(_DWORD *)(v4 + 12);
    if ( (unsigned int)v5 >= v6 )
      break;
    v7 = *v5;
    ++v5;
    std::_Destroy_aux<false>::__destroy<Json::Reader::ErrorInfo *>(v7, v7 + 125);
  }
  v8 = *(_DWORD **)v3;
  if ( *(_DWORD *)(v3 + 12) != v6 )
  {
    std::_Destroy_aux<false>::__destroy<Json::Reader::ErrorInfo *>(v8, *(_DWORD **)(v3 + 8));
    v8 = *(_DWORD **)(v4 + 4);
  }
  return std::_Destroy_aux<false>::__destroy<Json::Reader::ErrorInfo *>(v8, *(_DWORD **)v4);
}

//----- (00051AE0) --------------------------------------------------------
int __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_erase_at_end(int a1, int *a2)
{
  int v2; // r6
  int *v3; // r4
  int *v4; // r5
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // [sp+0h] [bp-10h]
  int v10; // [sp+10h] [bp+0h]
  char v11; // [sp+20h] [bp+10h]
  int v12; // [sp+30h] [bp+20h]

  v2 = a1;
  v3 = (int *)(a1 + 24);
  v4 = a2;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v10,
    a2);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v9,
    v3);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    &v10);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    &v9);
  std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_destroy_data_aux(
    v2,
    (int)&v11,
    (int)&v12);
  sub_51174((void **)(v4[3] + 4), *(_DWORD *)(v2 + 36) + 4);
  result = *v4;
  v6 = v4[1];
  v7 = v4[2];
  v8 = v4[3];
  *v3 = *v4;
  v3[1] = v6;
  v3[2] = v7;
  v3[3] = v8;
  return result;
}

//----- (00051B38) --------------------------------------------------------
int __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::~deque(int a1)
{
  int v1; // r4
  int v3; // [sp+0h] [bp-10h]
  int v4; // [sp+10h] [bp+0h]
  char v5; // [sp+20h] [bp+10h]
  char v6; // [sp+30h] [bp+20h]

  v1 = a1;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v3,
    (_DWORD *)(a1 + 8));
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v4,
    (_DWORD *)(v1 + 24));
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v5,
    &v3);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v6,
    &v4);
  std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_destroy_data_aux(
    v1,
    (int)&v5,
    (int)&v6);
  if ( *(_DWORD *)v1 )
  {
    sub_51174(*(void ***)(v1 + 20), *(_DWORD *)(v1 + 36) + 4);
    operator delete(*(void **)v1);
  }
  return v1;
}

//----- (00051B8C) --------------------------------------------------------
_DWORD *__fastcall std::__copy_move_a2<false,std::_Deque_iterator<Json::Value *,Json::Value * const&,Json::Value * const*>,std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>>(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, _DWORD *a10)
{
  _DWORD *v10; // r6
  int v11; // r2
  int *v12; // r3
  int v13; // r0
  int i; // r1
  int v15; // t1
  _DWORD *v16; // r4
  int v18; // [sp+0h] [bp-A0h]
  char v19; // [sp+10h] [bp-90h]
  int *v20; // [sp+20h] [bp-80h]
  int v21; // [sp+24h] [bp-7Ch]
  int v22; // [sp+28h] [bp-78h]
  int v23; // [sp+2Ch] [bp-74h]
  int v24; // [sp+30h] [bp-70h]
  int v25; // [sp+34h] [bp-6Ch]
  int v26; // [sp+38h] [bp-68h]
  int v27; // [sp+3Ch] [bp-64h]
  int v28; // [sp+40h] [bp-60h]
  int v29; // [sp+44h] [bp-5Ch]
  int v30; // [sp+48h] [bp-58h]
  int v31; // [sp+4Ch] [bp-54h]
  int v32; // [sp+50h] [bp-50h]
  int v33; // [sp+54h] [bp-4Ch]
  int v34; // [sp+58h] [bp-48h]
  int v35; // [sp+5Ch] [bp-44h]
  int v36; // [sp+60h] [bp-40h]
  int v37; // [sp+64h] [bp-3Ch]
  int v38; // [sp+68h] [bp-38h]
  int v39; // [sp+6Ch] [bp-34h]
  int v40; // [sp+70h] [bp-30h]
  int v41; // [sp+74h] [bp-2Ch]
  int v42; // [sp+78h] [bp-28h]
  int v43; // [sp+7Ch] [bp-24h]
  int *v44; // [sp+80h] [bp-20h]
  int v45; // [sp+84h] [bp-1Ch]
  int v46; // [sp+88h] [bp-18h]
  int v47; // [sp+8Ch] [bp-14h]
  int v48; // [sp+90h] [bp-10h]
  int v49; // [sp+94h] [bp-Ch]
  int v50; // [sp+98h] [bp-8h]
  int v51; // [sp+9Ch] [bp-4h]
  _DWORD *v52; // [sp+A0h] [bp+0h]
  _DWORD *v53; // [sp+A4h] [bp+4h]
  _DWORD *v54; // [sp+A8h] [bp+8h]
  _DWORD *v55; // [sp+ACh] [bp+Ch]
  int vars1C; // [sp+CCh] [bp+2Ch]
  int anonymous0; // [sp+D0h] [bp+30h]
  int anonymous1; // [sp+D4h] [bp+34h]

  v10 = a1;
  vars1C = a2;
  anonymous0 = a3;
  anonymous1 = a4;
  v28 = a2;
  v29 = a3;
  v30 = a4;
  v31 = a5;
  v20 = (int *)a2;
  v21 = a3;
  v22 = a4;
  v23 = a5;
  v32 = a2;
  v33 = a3;
  v34 = a4;
  v35 = a5;
  v36 = a6;
  v37 = a7;
  v38 = a8;
  v39 = a9;
  v40 = a6;
  v41 = a7;
  v42 = a8;
  v43 = a9;
  v24 = a6;
  v25 = a7;
  v26 = a8;
  v27 = a9;
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v18, a10);
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v52, &v18);
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v19, &v52);
  v44 = v20;
  v45 = v21;
  v46 = v22;
  v47 = v23;
  v48 = v24;
  v49 = v25;
  v50 = v26;
  v51 = v27;
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v52, &v19);
  v11 = v47;
  v12 = v44;
  v13 = v46;
  for ( i = ((v48 - v49) >> 2) + ((((v51 - v47) >> 2) - 1) << 7) + ((v46 - (signed int)v44) >> 2); i > 0; --i )
  {
    v15 = *v12;
    ++v12;
    *v52 = v15;
    if ( v12 == (int *)v13 )
    {
      v12 = *(int **)(v11 + 4);
      v11 += 4;
      v13 = (int)(v12 + 128);
    }
    ++v52;
    if ( v52 == v54 )
    {
      ++v55;
      v16 = (_DWORD *)*v55;
      v54 = (_DWORD *)(*v55 + 512);
      v53 = v16;
      v52 = v16;
    }
  }
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(v10, &v52);
  return v10;
}

//----- (00051C70) --------------------------------------------------------
_DWORD *__fastcall std::deque<Json::Value *,std::allocator<Json::Value *>>::deque(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  int v4; // r2
  int v5; // r1
  int v6; // r2
  int v7; // r11
  int v8; // ST24_4
  int v9; // r10
  int v10; // r9
  int v11; // r7
  int v12; // r6
  int v13; // ST1C_4
  int v14; // ST20_4
  char v16; // [sp+28h] [bp-A8h]
  char v17; // [sp+38h] [bp-98h]
  char v18; // [sp+48h] [bp-88h]
  char v19; // [sp+58h] [bp-78h]
  char v20; // [sp+68h] [bp-68h]
  char v21; // [sp+78h] [bp-58h]
  int v22; // [sp+88h] [bp-48h]
  int v23; // [sp+8Ch] [bp-44h]
  int v24; // [sp+90h] [bp-40h]
  int v25; // [sp+94h] [bp-3Ch]
  int v26; // [sp+98h] [bp-38h]
  int v27; // [sp+9Ch] [bp-34h]
  int v28; // [sp+A0h] [bp-30h]
  int v29; // [sp+A4h] [bp-2Ch]

  v2 = a2;
  v3 = a1;
  v4 = a2[4];
  v5 = ((v2[6] - v2[7]) >> 2) + ((((a2[9] - a2[5]) >> 2) - 1) << 7);
  v6 = v4 - v2[2];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  std::_Deque_base<Json::Value *,std::allocator<Json::Value *>>::_M_initialize_map(a1, v5 + (v6 >> 2));
  v7 = v2[3];
  v8 = v2[6];
  v9 = v2[4];
  v10 = v2[5];
  v11 = v2[7];
  v12 = v2[8];
  v13 = v2[9];
  v14 = v2[2];
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v16, v3 + 2);
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v18, &v16);
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v19, &v18);
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v20, &v19);
  v24 = v12;
  v26 = v14;
  v25 = v13;
  v27 = v7;
  v22 = v8;
  v28 = v9;
  v29 = v10;
  v23 = v11;
  std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>::_Deque_iterator(&v21, &v20);
  std::__copy_move_a2<false,std::_Deque_iterator<Json::Value *,Json::Value * const&,Json::Value * const*>,std::_Deque_iterator<Json::Value *,Json::Value *&,Json::Value **>>(
    &v17,
    v26,
    v27,
    v28,
    v29,
    v22,
    v23,
    v24,
    v25,
    &v21);
  return v3;
}

//----- (00051D48) --------------------------------------------------------
Json::Reader *__fastcall Json::Reader::Reader(Json::Reader *this)
{
  Json::Reader *v1; // r4
  Json::Features *v2; // r0
  int v3; // r1
  int v4; // r2
  int v6; // [sp+0h] [bp-38h]
  int v7; // [sp+4h] [bp-34h]
  int v8; // [sp+8h] [bp-30h]
  int v9; // [sp+Ch] [bp-2Ch]
  int v10; // [sp+10h] [bp-28h]
  int v11; // [sp+14h] [bp-24h]
  int v12; // [sp+18h] [bp-20h]
  int v13; // [sp+1Ch] [bp-1Ch]
  int v14; // [sp+20h] [bp-18h]
  int v15; // [sp+24h] [bp-14h]

  v1 = this;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  std::_Deque_base<Json::Value *,std::allocator<Json::Value *>>::_M_initialize_map(&v6, 0);
  std::deque<Json::Value *,std::allocator<Json::Value *>>::deque(v1, &v6);
  std::deque<Json::Value *,std::allocator<Json::Value *>>::~deque((int)&v6);
  *((_DWORD *)v1 + 10) = 0;
  *((_DWORD *)v1 + 11) = 0;
  *((_DWORD *)v1 + 12) = 0;
  *((_DWORD *)v1 + 13) = 0;
  *((_DWORD *)v1 + 14) = 0;
  *((_DWORD *)v1 + 15) = 0;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 17) = 0;
  *((_DWORD *)v1 + 18) = 0;
  *((_DWORD *)v1 + 19) = 0;
  v2 = (Json::Features *)std::_Deque_base<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_initialize_map(
                           (_DWORD *)v1 + 10,
                           0);
  *((_DWORD *)v1 + 20) = &unk_2FEF48;
  *((_DWORD *)v1 + 26) = &unk_2FEF48;
  *((_WORD *)v1 + 54) = Json::Features::all(v2, v3, v4);
  return v1;
}

//----- (00051DDC) --------------------------------------------------------
Json::Reader *__fastcall Json::Reader::Reader(Json::Reader *this, const Json::Features *a2)
{
  Json::Reader *v2; // r4
  const Json::Features *v3; // r7
  Json::Reader *result; // r0
  int v5; // [sp+0h] [bp-40h]
  int v6; // [sp+4h] [bp-3Ch]
  int v7; // [sp+8h] [bp-38h]
  int v8; // [sp+Ch] [bp-34h]
  int v9; // [sp+10h] [bp-30h]
  int v10; // [sp+14h] [bp-2Ch]
  int v11; // [sp+18h] [bp-28h]
  int v12; // [sp+1Ch] [bp-24h]
  int v13; // [sp+20h] [bp-20h]
  int v14; // [sp+24h] [bp-1Ch]

  v2 = this;
  v3 = a2;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  std::_Deque_base<Json::Value *,std::allocator<Json::Value *>>::_M_initialize_map(&v5, 0);
  std::deque<Json::Value *,std::allocator<Json::Value *>>::deque(v2, &v5);
  std::deque<Json::Value *,std::allocator<Json::Value *>>::~deque((int)&v5);
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 12) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 15) = 0;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 18) = 0;
  *((_DWORD *)v2 + 19) = 0;
  std::_Deque_base<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_initialize_map(
    (_DWORD *)v2 + 10,
    0);
  result = v2;
  *((_DWORD *)v2 + 20) = &unk_2FEF48;
  *((_DWORD *)v2 + 26) = &unk_2FEF48;
  *((_WORD *)v2 + 54) = *(_WORD *)v3;
  return result;
}

//----- (00051E58) --------------------------------------------------------
int *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator++(int *result)
{
  int v1; // r2
  int v2; // r3
  int v3; // r3
  int v4; // r3

  v1 = result[2];
  v2 = *result + 20;
  *result = v2;
  if ( v2 == v1 )
  {
    v3 = result[3];
    result[3] = v3 + 4;
    v4 = *(_DWORD *)(v3 + 4);
    result[2] = v4 + 500;
    result[1] = v4;
    *result = v4;
  }
  return result;
}

//----- (00051E78) --------------------------------------------------------
int __fastcall std::_Destroy<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>>(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  int result; // r0
  int v4; // [sp+0h] [bp-30h]
  int v5; // [sp+10h] [bp-20h]

  v2 = a2;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v4,
    a1);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v5,
    v2);
  while ( 1 )
  {
    result = v4;
    if ( v4 == v5 )
      break;
    sub_C0AD8((_DWORD *)(v4 + 12));
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator++(&v4);
  }
  return result;
}

//----- (00051EAA) --------------------------------------------------------
_DWORD *__fastcall std::__uninitialized_fill<false>::__uninit_fill<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r6
  _DWORD *v4; // r7
  _DWORD *result; // r0
  _DWORD *v6; // [sp+0h] [bp-48h]

  v3 = a2;
  v4 = a3;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v6,
    a1);
  while ( 1 )
  {
    result = v6;
    if ( v6 == (_DWORD *)*v3 )
      break;
    if ( v6 )
      Json::Reader::ErrorInfo::ErrorInfo(v6, v4);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator++((int *)&v6);
  }
  return result;
}

//----- (00051F04) --------------------------------------------------------
_DWORD *__fastcall sub_51F04(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r5
  _DWORD *v4; // r7
  int v6; // [sp+0h] [bp-58h]
  char v7; // [sp+10h] [bp-48h]
  char v8; // [sp+20h] [bp-38h]
  char v9; // [sp+30h] [bp-28h]

  v3 = a2;
  v4 = a3;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v7,
    a1);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v6,
    v3);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v9,
    &v7);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v8,
    &v6);
  return std::__uninitialized_fill<false>::__uninit_fill<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo>(
           &v9,
           &v8,
           v4);
}

//----- (00051F42) --------------------------------------------------------
int *__fastcall sub_51F42(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // r6
  int *v5; // r4
  _DWORD *v6; // r8
  int v8; // [sp+0h] [bp-10h]
  int v9; // [sp+10h] [bp+0h]
  char v10; // [sp+20h] [bp+10h]
  char v11; // [sp+30h] [bp+20h]
  char v12; // [sp+40h] [bp+30h]
  int v13; // [sp+50h] [bp+40h]
  char v14; // [sp+60h] [bp+50h]
  _DWORD *v15; // [sp+70h] [bp+60h]
  _DWORD *v16; // [sp+80h] [bp+70h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v10,
    a2);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v9,
    v4);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v8,
    v6);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    &v10);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    &v9);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v13,
    &v8);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v16,
    &v11);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v15,
    &v12);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v14,
    &v13);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    v5,
    &v14);
  while ( v16 != v15 )
  {
    if ( *v5 )
      Json::Reader::ErrorInfo::ErrorInfo((_DWORD *)*v5, v16);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator++((int *)&v16);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator++(v5);
  }
  return v5;
}

//----- (00051FFE) --------------------------------------------------------
int *__fastcall std::__uninitialized_fill_move<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo,std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,std::allocator<Json::Reader::ErrorInfo>>(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *v6; // r7
  int *v7; // r8
  _DWORD *v8; // r6
  char v10; // [sp+10h] [bp-50h]
  char v11; // [sp+20h] [bp-40h]
  char v12; // [sp+30h] [bp-30h]

  v6 = a3;
  v7 = a1;
  v8 = a4;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    a2);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    v6);
  sub_51F04(&v11, &v12, v8);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v10,
    a5);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    a6);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    v6);
  sub_51F42(v7, &v10, &v11, &v12);
  return v7;
}

//----- (0005208E) --------------------------------------------------------
_DWORD *__fastcall std::__uninitialized_move_fill<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5; // r4
  _DWORD *v6; // r8
  _DWORD *v7; // r9
  int v9; // [sp+0h] [bp-70h]
  char v10; // [sp+20h] [bp-50h]
  char v11; // [sp+30h] [bp-40h]
  char v12; // [sp+40h] [bp-30h]

  v5 = a2;
  v6 = a3;
  v7 = a4;
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v10,
    a1);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    v5);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    v6);
  sub_51F42(&v9, &v10, &v11, &v12);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v11,
    &v9);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v12,
    v7);
  return sub_51F04(&v11, &v12, a5);
}

//----- (00052124) --------------------------------------------------------
int __fastcall std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>(_DWORD *a1, _DWORD *a2)
{
  return -858993459 * ((*a1 - a1[1]) >> 2) + 25 * (((a1[3] - a2[3]) >> 2) - 1) - 858993459 * ((a2[2] - *a2) >> 2);
}

//----- (00052154) --------------------------------------------------------
int *__fastcall std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>::operator+=(int *a1, int a2)
{
  int *v2; // r4
  int v3; // r5
  unsigned int v4; // r0
  int v5; // r3
  int v6; // r3
  int v7; // r3

  v2 = a1;
  v3 = a2 - 858993459 * ((*a1 - a1[1]) >> 2);
  if ( (unsigned int)v3 <= 0x18 )
  {
    v7 = *a1 + 20 * a2;
  }
  else
  {
    if ( v3 <= 0 )
      v4 = ~(~v3 / 0x19u);
    else
      v4 = v3 / 25;
    v5 = v2[3];
    v2[3] = v5 + 4 * v4;
    v6 = *(_DWORD *)(v5 + 4 * v4);
    v2[2] = v6 + 500;
    v2[1] = v6;
    v7 = v6 + 20 * (v3 - 25 * v4);
  }
  *v2 = v7;
  return v2;
}

//----- (000521B4) --------------------------------------------------------
_DWORD *__fastcall Json::Reader::ErrorInfo::operator=(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  int v4; // r0
  int v5; // t0
  int v6; // r1
  int v7; // r2
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2;
  v4 = *a2;
  v5 = (int)(a2 + 1);
  v6 = a2[1];
  v7 = *(_DWORD *)(v5 + 4);
  *v2 = v4;
  v2[1] = v6;
  v2[2] = v7;
  sub_C1778(v2 + 3, v3 + 3);
  result = v2;
  v2[4] = v3[4];
  return result;
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);

//----- (000521D4) --------------------------------------------------------
_DWORD *__fastcall std::__fill_a<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo>(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r4
  _DWORD *v4; // r5
  _DWORD *v5; // r6

  v3 = result;
  v4 = a2;
  v5 = a3;
  while ( v3 != v4 )
  {
    result = Json::Reader::ErrorInfo::operator=(v3, v5);
    v3 += 5;
  }
  return result;
}

//----- (000521EE) --------------------------------------------------------
_DWORD *__fastcall std::fill<Json::Reader::ErrorInfo>(int a1, int a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r6
  _DWORD *v5; // r5
  _DWORD **v6; // r7
  unsigned int v7; // r3
  _DWORD *v8; // t1
  _DWORD *v9; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = (_DWORD **)(*(_DWORD *)(a1 + 12) + 4);
  while ( 1 )
  {
    v7 = *(_DWORD *)(v4 + 12);
    if ( (unsigned int)v6 >= v7 )
      break;
    v8 = *v6;
    ++v6;
    std::__fill_a<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo>(v8, v8 + 125, v5);
  }
  v9 = *(_DWORD **)v3;
  if ( *(_DWORD *)(v3 + 12) != v7 )
  {
    std::__fill_a<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo>(v9, *(_DWORD **)(v3 + 8), v5);
    v9 = *(_DWORD **)(v4 + 4);
  }
  return std::__fill_a<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo>(v9, *(_DWORD **)v4, v5);
}

//----- (0005222E) --------------------------------------------------------
char *__fastcall std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Reader::ErrorInfo *>(void *src, int a2, char *a3)
{
  int v3; // r1
  char *v4; // r3
  size_t v5; // r4

  v3 = a2 - (_DWORD)src;
  v4 = a3;
  v5 = 4 * (v3 >> 2);
  if ( v3 >> 2 )
    v4 = (char *)memmove(a3, src, v5);
  return &v4[v5];
}

//----- (0005224E) --------------------------------------------------------
void __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reallocate_map(void **a1, unsigned int a2, int a3)
{
  unsigned int v3; // r7
  char *v4; // r3
  int v5; // r5
  _BYTE *v6; // r1
  void **v7; // r4
  unsigned int v8; // r2
  int v9; // r8
  int v10; // r9
  char *v11; // r0
  unsigned int v12; // r2
  int v13; // r1
  char *v14; // r5
  int v15; // r1
  int v16; // r6
  unsigned int v17; // r6
  char *v18; // r0
  unsigned int v19; // r9
  char *v20; // r10
  char *v21; // r3
  int v22; // r3

  v3 = a2;
  v4 = (char *)a1[5];
  v5 = a3;
  v6 = a1[9];
  v7 = a1;
  v8 = (unsigned int)a1[1];
  v9 = ((v6 - v4) >> 2) + 1;
  v10 = v9 + v3;
  if ( v8 <= 2 * (v9 + v3) )
  {
    v16 = v8 + 2;
    if ( v3 < v8 )
      v17 = v16 + v8;
    else
      v17 = v16 + v3;
    if ( v17 >= 0x40000000 )
      sub_BFA08();
    v18 = (char *)operator new(4 * v17);
    v19 = 4 * ((v17 - v10) >> 1);
    v20 = v18;
    if ( v5 )
      v5 = 4 * v3;
    v14 = &v18[v5 + v19];
    std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Reader::ErrorInfo *>(
      v7[5],
      (int)v7[9] + 4,
      v14);
    operator delete(*v7);
    *v7 = v20;
    v7[1] = (void *)v17;
  }
  else
  {
    v11 = (char *)*a1;
    v12 = 4 * ((v8 - v10) >> 1);
    if ( v5 )
      v5 = 4 * v3;
    v13 = (int)(v6 + 4);
    v14 = &v11[v5 + v12];
    if ( v14 >= v4 )
    {
      v15 = (v13 - (signed int)v4) >> 2;
      if ( v15 )
        memmove(&v14[4 * v9 + -4 * v15], v4, 4 * v15);
    }
    else
    {
      std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Reader::ErrorInfo *>(v4, v13, v14);
    }
  }
  v7[5] = v14;
  v21 = *(char **)v14;
  v7[3] = *(void **)v14;
  v7[4] = v21 + 500;
  v7[9] = &v14[4 * (v9 + 0x3FFFFFFF)];
  v22 = *(_DWORD *)&v14[4 * (v9 + 0x3FFFFFFF)];
  v7[7] = (void *)v22;
  v7[8] = (void *)(v22 + 500);
}

//----- (0005231C) --------------------------------------------------------
void __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_map_at_back(int a1, unsigned int a2)
{
  if ( a2 + 1 > *(_DWORD *)(a1 + 4) - ((*(_DWORD *)(a1 + 36) - *(_DWORD *)a1) >> 2) )
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reallocate_map((void **)a1, a2, 0);
}

//----- (0005233C) --------------------------------------------------------
int __fastcall Json::Reader::addError(_DWORD *a1, int a2, int *a3, int a4)
{
  _DWORD *v4; // r4
  int v5; // r7
  int v6; // r6
  int v7; // r0
  int v8; // r1
  int v9; // r2
  _DWORD *v10; // r0
  int v11; // r3
  int v12; // r3
  int v13; // r6
  _DWORD *v14; // r0
  int v15; // r3
  int v17; // [sp+4h] [bp-2Ch]
  int v18; // [sp+8h] [bp-28h]
  int v19; // [sp+Ch] [bp-24h]
  void *v20; // [sp+10h] [bp-20h]
  int v21; // [sp+14h] [bp-1Ch]

  v4 = a1;
  v5 = a2;
  v6 = a4;
  v20 = &unk_2FEF48;
  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v17 = v7;
  v18 = v8;
  v19 = v9;
  sub_C1778(&v20, v5);
  v10 = (_DWORD *)v4[16];
  v11 = v4[18] - 20;
  v21 = v6;
  if ( v10 == (_DWORD *)v11 )
  {
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_map_at_back(
      (int)(v4 + 10),
      1u);
    v13 = v4[19];
    *(_DWORD *)(v13 + 4) = operator new(0x1F4u);
    v14 = (_DWORD *)v4[16];
    if ( v14 )
      Json::Reader::ErrorInfo::ErrorInfo(v14, &v17);
    v15 = v4[19];
    v4[19] = v15 + 4;
    v12 = *(_DWORD *)(v15 + 4);
    v4[18] = v12 + 500;
    v4[17] = v12;
  }
  else
  {
    if ( v10 )
      Json::Reader::ErrorInfo::ErrorInfo(v10, &v17);
    v12 = v4[16] + 20;
  }
  v4[16] = v12;
  sub_C0AD8(&v20);
  return 0;
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);

//----- (000523E8) --------------------------------------------------------
signed int __fastcall Json::Reader::expectToken(int a1, int a2, signed int *a3, char *a4)
{
  int v4; // r4
  int *v5; // r5
  _DWORD *v6; // r6
  char *v7; // r7
  int v8; // r5
  int v10; // [sp+4h] [bp-1Ch]
  signed int *v11; // [sp+8h] [bp-18h]

  v10 = a2;
  v11 = a3;
  v4 = a2;
  v5 = a3;
  v6 = (_DWORD *)a1;
  v7 = a4;
  Json::Reader::readToken(a1, a3);
  if ( *v5 == v4 )
    return 1;
  sub_C1C58((void **)&v10, v7);
  v8 = Json::Reader::addError(v6, (int)&v10, v5, 0);
  sub_C0AD8(&v10);
  return v8;
}

//----- (00052434) --------------------------------------------------------
int __fastcall Json::Reader::decodeDouble(Json::Reader *a1, int a2)
{
  int v2; // r6
  Json::Reader *v3; // r8
  int v4; // r2
  _BYTE *v5; // r1
  int v6; // r5
  const char *v7; // r0
  int v8; // r1
  int v9; // r2
  _DWORD *v10; // r3
  int v11; // r5
  int v12; // r6
  int v13; // r5
  int v14; // r1
  _BYTE *v16; // [sp+8h] [bp-48h]
  unsigned int v17; // [sp+Ch] [bp-44h]
  double v18; // [sp+10h] [bp-40h]
  char *s; // [sp+18h] [bp-38h]
  char dest; // [sp+2Ch] [bp-24h]
  char v21[4]; // [sp+50h] [bp+0h]

  v2 = a2;
  v18 = 0.0;
  v3 = a1;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_BYTE **)(a2 + 4);
  v6 = v4 - (_DWORD)v5;
  if ( v4 - (signed int)v5 > 32 )
  {
    sub_513A8(&s, v5, v4);
    v11 = sscanf(s, "%lf", &v18);
    sub_C0AD8(&s);
  }
  else
  {
    v7 = (const char *)memcpy(&dest, v5, v4 - (_DWORD)v5);
    v21[v6 - 36] = 0;
    v11 = sscanf(v7, "%lf", &v18);
  }
  if ( v11 == 1 )
  {
    v13 = Json::Reader::currentValue(v3, v8, v9, v10);
    Json::Value::Value((int)&s, v14, v18);
    Json::Value::operator=(v13, (const Json::Value *)&s);
    v12 = 1;
    Json::Value::~Value((Json::Value *)&s);
  }
  else
  {
    sub_513A8(&v16, *(_BYTE **)(v2 + 4), *(_DWORD *)(v2 + 8));
    sub_515E8(&v17, "'", &v16);
    std::operator+<char,std::char_traits<char>,std::allocator<char>>(
      (unsigned int *)&s,
      (int *)&v17,
      "' is not a number.");
    v12 = Json::Reader::addError(v3, (int)&s, (int *)v2, 0);
    sub_C0AD8(&s);
    sub_C0AD8(&v17);
    sub_C0AD8(&v16);
  }
  return v12;
}
// 52434: using guessed type char var_4[4];

//----- (0005255C) --------------------------------------------------------
int __fastcall Json::Reader::decodeNumber(Json::Reader *a1, int *a2)
{
  unsigned __int8 *v2; // r4
  Json::Reader *v3; // r6
  unsigned int v4; // r9
  int *v5; // r7
  int v6; // r3
  unsigned __int8 *i; // r0
  int v8; // r1
  int v9; // r4
  unsigned __int8 *v10; // r8
  int *v11; // r3
  unsigned int v12; // r0
  int v13; // r1
  unsigned int v14; // r5
  int *v15; // t1
  int v16; // r6
  int v17; // r6
  _BYTE *v19; // [sp+8h] [bp-38h]
  unsigned int v20; // [sp+Ch] [bp-34h]
  char v21; // [sp+10h] [bp-30h]

  v2 = (unsigned __int8 *)a2[1];
  v3 = a1;
  v4 = a2[2];
  v5 = a2;
  v6 = 0;
  for ( i = (unsigned __int8 *)a2[1]; i != (unsigned __int8 *)v4; ++i )
  {
    if ( !v6 )
    {
      v8 = *i;
      if ( v8 != 46 && (v8 & 0xDF) != 69 && v8 != 43 )
      {
        if ( v8 == 45 )
        {
          v6 = i - v2;
          if ( i != v2 )
            v6 = 1;
        }
      }
      else
      {
        v6 = 1;
      }
    }
  }
  if ( v6 )
    return Json::Reader::decodeDouble(v3, (int)v5);
  if ( (unsigned int)*v2 - 45 > 0 )
  {
    v10 = v2;
    v11 = &Json::Value::maxUInt;
    v12 = 429496729;
  }
  else
  {
    v10 = v2 + 1;
    v11 = &Json::Value::minInt;
    v12 = 214748364;
  }
  v14 = 0;
  while ( (unsigned int)v10 < v4 )
  {
    v15 = (int *)*v10++;
    v11 = v15;
    v13 = (int)(v15 - 12);
    if ( (unsigned int)(v15 - 12) > 9 )
    {
      sub_513A8(&v19, v2, v4);
      sub_515E8(&v20, "'", &v19);
      std::operator+<char,std::char_traits<char>,std::allocator<char>>(
        (unsigned int *)&v21,
        (int *)&v20,
        "' is not a number.");
      v9 = Json::Reader::addError(v3, (int)&v21, v5, 0);
      sub_C0AD8(&v21);
      sub_C0AD8(&v20);
      sub_C0AD8(&v19);
      return v9;
    }
    if ( v14 >= v12 )
      return Json::Reader::decodeDouble(v3, (int)v5);
    v14 = (unsigned int)v11 + 10 * v14 - 48;
  }
  if ( (unsigned int)*v2 - 45 <= 0 )
  {
    v16 = Json::Reader::currentValue(v3, v13, 10, v11);
    Json::Value::Value((int)&v21, -v14);
    Json::Value::operator=(v16, (const Json::Value *)&v21);
  }
  else
  {
    if ( v14 > 0x7FFFFFFF )
    {
      v17 = Json::Reader::currentValue(v3, v13, 10, (_DWORD *)0x7FFFFFFF);
      Json::Value::Value((int)&v21, v14);
    }
    else
    {
      v17 = Json::Reader::currentValue(v3, v13, 10, (_DWORD *)0x7FFFFFFF);
      Json::Value::Value((int)&v21, v14);
    }
    Json::Value::operator=(v17, (const Json::Value *)&v21);
  }
  v9 = 1;
  Json::Value::~Value((Json::Value *)&v21);
  return v9;
}
// EA708: using guessed type int Json::Value::maxUInt;
// EA710: using guessed type int Json::Value::minInt;

//----- (00052710) --------------------------------------------------------
signed int __fastcall Json::Reader::decodeUnicodeEscapeSequence(_DWORD *a1, int a2, int *a3, int a4, int *a5)
{
  int *v5; // r5
  _DWORD *v6; // r7
  int *v7; // r8
  int v8; // r0
  signed int v9; // r2
  unsigned __int8 *v10; // r3
  int v11; // r3
  int v12; // r6
  int v13; // r6
  int v14; // r5
  int v16; // [sp+4h] [bp-1Ch]

  v16 = a2;
  v5 = a3;
  v6 = a1;
  v7 = (int *)a2;
  if ( a4 - *a3 > 3 )
  {
    v9 = 4;
    *a5 = 0;
    while ( 1 )
    {
      v10 = (unsigned __int8 *)(*v5)++;
      v11 = *v10;
      v12 = 16 * *a5;
      *a5 = v12;
      if ( (unsigned int)(v11 - 48) > 9 )
      {
        if ( (unsigned int)(v11 - 97) > 5 )
        {
          if ( (unsigned int)(v11 - 65) > 5 )
          {
            sub_C1C58((void **)&v16, "Bad unicode escape sequence in string: hexadecimal digit expected.");
            v8 = Json::Reader::addError(v6, (int)&v16, v7, *v5);
            goto LABEL_13;
          }
          v13 = v12 - 55;
        }
        else
        {
          v13 = v12 - 87;
        }
      }
      else
      {
        v13 = v12 - 48;
      }
      --v9;
      *a5 = v11 + v13;
      if ( !v9 )
        return 1;
    }
  }
  sub_C1C58((void **)&v16, "Bad unicode escape sequence in string: four digits expected.");
  v8 = Json::Reader::addError(v6, (int)&v16, v7, *v5);
LABEL_13:
  v14 = v8;
  sub_C0AD8(&v16);
  return v14;
}

//----- (000527C4) --------------------------------------------------------
signed int __fastcall Json::Reader::decodeUnicodeCodePoint(_DWORD *a1, int a2, int *a3, int a4, int *a5)
{
  _DWORD *v5; // r9
  int *v6; // r8
  int *v7; // r5
  int v8; // r10
  signed int v9; // r6
  _BYTE *v10; // r6
  int v11; // r0
  int v13; // [sp+Ch] [bp-24h]

  v13 = a4;
  v5 = a1;
  v6 = (int *)a2;
  v7 = a3;
  v8 = a4;
  v9 = Json::Reader::decodeUnicodeEscapeSequence(a1, a2, a3, a4, a5);
  if ( v9 && (unsigned int)(*a5 - 55296) < 0x400 )
  {
    v10 = (_BYTE *)*v7;
    if ( v8 - *v7 <= 5 )
    {
      sub_C1C58((void **)&v13, "additional six characters expected to parse unicode surrogate pair.");
      v11 = Json::Reader::addError(v5, (int)&v13, v6, *v7);
LABEL_10:
      v9 = v11;
      sub_C0AD8(&v13);
      return v9;
    }
    *v7 = (int)(v10 + 1);
    if ( *v10 != 92 || (*v7 = (int)(v10 + 2), v10[1] != 117) )
    {
      sub_C1C58((void **)&v13, "expecting another \\u token to begin the second half of a unicode surrogate pair");
      v11 = Json::Reader::addError(v5, (int)&v13, v6, *v7);
      goto LABEL_10;
    }
    v9 = Json::Reader::decodeUnicodeEscapeSequence(v5, (int)v6, v7, v8, &v13);
    if ( v9 )
      *a5 = (v13 & 0x3FF) + 0x10000 + ((*a5 & 0x3FF) << 10);
  }
  return v9;
}

//----- (0005288C) --------------------------------------------------------
signed int __fastcall Json::Reader::decodeString(_DWORD *a1, int *a2, int *a3)
{
  int *v3; // r7
  _DWORD *v4; // r9
  int *v5; // r6
  int v6; // r8
  unsigned __int8 *v7; // r3
  int v8; // r2
  unsigned int v9; // r1
  signed int v10; // r5
  int v11; // r0
  int *v12; // r0
  unsigned int v13; // r5
  unsigned __int8 *v15; // [sp+Ch] [bp-4h]
  unsigned int v16; // [sp+10h] [bp+0h]
  _BYTE *v17; // [sp+14h] [bp+4h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_C1264(a3, a2[2] - a2[1] - 2);
  v15 = (unsigned __int8 *)(v3[1] + 1);
  v6 = v3[2] - 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = v15;
      if ( v15 == (unsigned __int8 *)v6 )
        return 1;
      v8 = (int)(v15++ + 1);
      v9 = *v7;
      if ( v9 == 34 )
        return 1;
      if ( v9 != 92 )
        goto LABEL_40;
      if ( v8 == v6 )
      {
        sub_C1C58((void **)&v17, "Empty escape sequence in string");
        v11 = Json::Reader::addError(v4, (int)&v17, v3, (int)v15);
        goto LABEL_39;
      }
      v15 = v7 + 2;
      v9 = v7[1];
      if ( v9 == 102 )
      {
        v12 = v5;
        LOBYTE(v9) = 12;
        goto LABEL_41;
      }
      if ( v9 > 0x66 )
        break;
      if ( v9 == 47 )
        goto LABEL_40;
      if ( v9 <= 0x2F )
      {
        if ( v9 != 34 )
          goto LABEL_38;
LABEL_40:
        v12 = v5;
        goto LABEL_41;
      }
      if ( v9 == 92 )
        goto LABEL_40;
      if ( v9 != 98 )
        goto LABEL_38;
      v12 = v5;
      LOBYTE(v9) = 8;
LABEL_41:
      sub_C15D0(v12, v9);
    }
    if ( v9 == 114 )
    {
      v12 = v5;
      LOBYTE(v9) = 13;
      goto LABEL_41;
    }
    if ( v9 <= 0x72 )
    {
      if ( v9 != 110 )
        break;
      v12 = v5;
      LOBYTE(v9) = 10;
      goto LABEL_41;
    }
    if ( v9 == 116 )
    {
      v12 = v5;
      LOBYTE(v9) = 9;
      goto LABEL_41;
    }
    if ( v9 != 117 )
      break;
    v10 = Json::Reader::decodeUnicodeCodePoint(v4, (int)v3, (int *)&v15, v6, (int *)&v16);
    if ( !v10 )
      return v10;
    v13 = v16;
    v17 = &unk_2FEF48;
    if ( v16 <= 0x7F )
    {
      sub_C15C8((int *)&v17, 1u);
      sub_C0C28((int *)&v17);
LABEL_32:
      *v17 = v13;
      goto LABEL_37;
    }
    if ( v16 < 0x800 )
    {
      sub_C15C8((int *)&v17, 2u);
      sub_C0C28((int *)&v17);
      v17[1] = v13 & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      LOBYTE(v13) = (v13 >> 6) | 0xC0;
      goto LABEL_32;
    }
    if ( v16 < 0x10000 )
    {
      sub_C15C8((int *)&v17, 3u);
      sub_C0C28((int *)&v17);
      v17[2] = v13 & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      v17[1] = (v13 >> 6) & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      LOBYTE(v13) = (v13 >> 12) | 0xE0;
      goto LABEL_32;
    }
    if ( v16 < 0x110000 )
    {
      sub_C15C8((int *)&v17, 4u);
      sub_C0C28((int *)&v17);
      v17[3] = v13 & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      v17[2] = (v13 >> 6) & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      v17[1] = (v13 >> 12) & 0x3F | 0x80;
      sub_C0C28((int *)&v17);
      LOBYTE(v13) = (v13 >> 18) | 0xF0;
      goto LABEL_32;
    }
LABEL_37:
    sub_C135C(v5, &v17);
    sub_C0AD8(&v17);
  }
LABEL_38:
  sub_C1C58((void **)&v17, "Bad escape sequence in string");
  v11 = Json::Reader::addError(v4, (int)&v17, v3, (int)v15);
LABEL_39:
  v10 = v11;
  sub_C0AD8(&v17);
  return v10;
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00052AB4) --------------------------------------------------------
signed int __fastcall Json::Reader::decodeString(Json::Reader *a1, int *a2)
{
  Json::Reader *v2; // r5
  int v3; // r1
  int v4; // r2
  _DWORD *v5; // r3
  signed int v6; // r6
  int v7; // r7
  void *v9; // [sp+4h] [bp-2Ch]
  char v10; // [sp+8h] [bp-28h]

  v2 = a1;
  v9 = &unk_2FEF48;
  v6 = Json::Reader::decodeString(a1, a2, (int *)&v9);
  if ( v6 )
  {
    v7 = Json::Reader::currentValue(v2, v3, v4, v5);
    Json::Value::Value((int)&v10, &v9);
    Json::Value::operator=(v7, (const Json::Value *)&v10);
    Json::Value::~Value((Json::Value *)&v10);
  }
  sub_C0AD8(&v9);
  return v6;
}

//----- (00052B18) --------------------------------------------------------
void __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_new_elements_at_back(int a1, unsigned int a2)
{
  int v2; // r5
  unsigned int v3; // r4
  unsigned int v4; // r0
  unsigned int v5; // r4
  unsigned int v6; // r6
  int v7; // r7

  v2 = a1;
  v3 = a2;
  if ( 214748364
     - std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(
         (_DWORD *)(a1 + 24),
         (_DWORD *)(a1 + 8)) < a2 )
    sub_BFBAC((int)"deque::_M_new_elements_at_back");
  v4 = (v3 + 24) / 0x19;
  v5 = 1;
  v6 = v4;
  std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_map_at_back(v2, v4);
  while ( v5 <= v6 )
  {
    v7 = *(_DWORD *)(v2 + 36);
    *(_DWORD *)(v7 + 4 * v5++) = operator new(0x1F4u);
  }
}

//----- (00052B94) --------------------------------------------------------
int __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_back(int a1, int a2, unsigned int a3)
{
  int v3; // r4
  int v4; // r6
  int v5; // r5
  int v6; // r3
  unsigned int v7; // r1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = -858993459;
  v7 = -858993459 * ((*(_DWORD *)(a2 + 32) - *(_DWORD *)(a2 + 24)) >> 2) - 1;
  if ( a3 > v7 )
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_new_elements_at_back(v3, a3 - v7);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
    v4,
    (_DWORD *)(v3 + 24),
    v5,
    v6);
  return v4;
}

//----- (00052BCC) --------------------------------------------------------
void __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_new_elements_at_front(int a1, unsigned int a2)
{
  int v2; // r4
  unsigned int v3; // r5
  unsigned int v4; // r6
  unsigned int i; // r5
  int v6; // r9

  v2 = a1;
  v3 = a2;
  if ( 214748364
     - std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(
         (_DWORD *)(a1 + 24),
         (_DWORD *)(a1 + 8)) < a2 )
    sub_BFBAC((int)"deque::_M_new_elements_at_front");
  v4 = (v3 + 24) / 0x19;
  if ( v4 > (*(_DWORD *)(v2 + 20) - *(_DWORD *)v2) >> 2 )
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reallocate_map((void **)v2, v4, 1);
  for ( i = 1; i <= v4; ++i )
  {
    v6 = *(_DWORD *)(v2 + 20);
    *(_DWORD *)(v6 - 4 * i) = operator new(0x1F4u);
  }
}

//----- (00052C68) --------------------------------------------------------
int __fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_front(int a1, int a2, unsigned int a3)
{
  int v3; // r4
  int v4; // r6
  int v5; // r5
  int v6; // r3
  unsigned int v7; // r1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = -858993459;
  v7 = -858993459 * ((*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 12)) >> 2);
  if ( a3 > v7 )
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_new_elements_at_front(v3, a3 - v7);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator-(
    v4,
    (_DWORD *)(v3 + 8),
    v5,
    v6);
  return v4;
}

//----- (00052C9C) --------------------------------------------------------
_DWORD *__fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_insert_aux(int a1, _DWORD *a2, signed int a3, _DWORD *a4)
{
  _DWORD *v4; // r7
  _DWORD *v5; // r4
  _DWORD *v6; // r6
  int v7; // r8
  unsigned int v8; // r9
  int v9; // r3
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r10
  int v17; // r8
  int v18; // r5
  int v19; // r9
  int v20; // r7
  int v21; // r6
  int v22; // r4
  int v23; // ST10_4
  int v24; // r5
  _DWORD *v25; // r7
  _DWORD *v26; // r4
  int v27; // r6
  int j; // r9
  int v29; // r3
  int *v30; // r0
  int v31; // r1
  int v32; // r2
  int v33; // r3
  int v34; // r8
  int v35; // r3
  int v36; // r3
  int v37; // r1
  int v38; // r2
  int v39; // r1
  int v40; // r2
  int v41; // r3
  int v42; // r7
  int v43; // r6
  int v44; // ST1C_4
  int v45; // ST2C_4
  int v46; // r9
  int v47; // r5
  int v48; // ST14_4
  int v49; // ST10_4
  int v50; // r7
  _DWORD *v51; // r6
  _DWORD *v52; // r5
  int v53; // r2
  int v54; // r3
  int v55; // r9
  int i; // r10
  int v57; // r3
  int v58; // r0
  int *v59; // r1
  int v60; // r3
  int v61; // r1
  int v62; // r2
  int v63; // r3
  _DWORD *v65; // [sp+18h] [bp-BCh]
  signed int v66; // [sp+20h] [bp-B4h]
  int v67; // [sp+28h] [bp-ACh]
  char v68; // [sp+30h] [bp-A4h]
  char v69; // [sp+44h] [bp-90h]
  int v70; // [sp+48h] [bp-8Ch]
  int v71; // [sp+4Ch] [bp-88h]
  int v72; // [sp+50h] [bp-84h]
  char v73; // [sp+54h] [bp-80h]
  char v74; // [sp+64h] [bp-70h]
  _DWORD *v75; // [sp+74h] [bp-60h]
  int v76; // [sp+78h] [bp-5Ch]
  int v77; // [sp+7Ch] [bp-58h]
  int v78; // [sp+80h] [bp-54h]
  _DWORD *v79; // [sp+84h] [bp-50h]
  int v80; // [sp+88h] [bp-4Ch]
  int v81; // [sp+8Ch] [bp-48h]
  int v82; // [sp+90h] [bp-44h]
  int v83; // [sp+94h] [bp-40h]
  int v84; // [sp+98h] [bp-3Ch]
  int v85; // [sp+9Ch] [bp-38h]
  int v86; // [sp+A0h] [bp-34h]
  char v87; // [sp+A4h] [bp-30h]
  _DWORD *v88; // [sp+B4h] [bp-20h]
  int v89; // [sp+B8h] [bp-1Ch]
  int v90; // [sp+BCh] [bp-18h]
  int v91; // [sp+C0h] [bp-14h]
  int v92; // [sp+C4h] [bp-10h]
  int v93; // [sp+C8h] [bp-Ch]
  int v94; // [sp+CCh] [bp-8h]
  int v95; // [sp+D0h] [bp-4h]
  _DWORD *v96; // [sp+D4h] [bp+0h]
  int v97; // [sp+D8h] [bp+4h]
  int v98; // [sp+DCh] [bp+8h]
  int v99; // [sp+E0h] [bp+Ch]
  char v100; // [sp+E4h] [bp+10h]
  char v101; // [sp+F0h] [bp+1Ch]

  v4 = (_DWORD *)(a1 + 8);
  v5 = a4;
  v67 = a1;
  v65 = a2;
  v66 = a3;
  v6 = (_DWORD *)(a1 + 24);
  v7 = std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(a2, (_DWORD *)(a1 + 8));
  v8 = std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(v6, v4);
  Json::Reader::ErrorInfo::ErrorInfo(&v100, v5);
  if ( v7 >= (signed int)(v8 >> 1) )
  {
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_back(
      (int)&v69,
      v67,
      v66);
    v34 = v8 - v7;
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v73,
      v6);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator-(
      (int)&v96,
      v6,
      v34,
      v35);
    v37 = v97;
    v38 = v98;
    v36 = v99;
    *v65 = v96;
    v65[1] = v37;
    v65[2] = v38;
    v65[3] = v36;
    if ( v34 <= v66 )
    {
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        v6);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
        (int)&v87,
        v65,
        v66,
        v60);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v92,
        v65);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v96,
        v6);
      std::__uninitialized_fill_move<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo,std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,std::allocator<Json::Reader::ErrorInfo>>(
        (int *)&v68,
        &v88,
        &v87,
        &v100,
        &v92,
        &v96);
      v61 = v70;
      v62 = v71;
      v63 = v72;
      *v6 = *(_DWORD *)&v69;
      v6[1] = v61;
      v6[2] = v62;
      v6[3] = v63;
      v59 = (int *)&v73;
      v58 = (int)v65;
    }
    else
    {
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator-(
        (int)&v74,
        v6,
        v66,
        v36);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        &v74);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v92,
        v6);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v96,
        v6);
      sub_51F42((int *)&v68, &v88, &v92, &v96);
      v39 = v70;
      v40 = v71;
      v41 = v72;
      *v6 = *(_DWORD *)&v69;
      v6[1] = v39;
      v6[2] = v40;
      v6[3] = v41;
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v75,
        v65);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v79,
        &v74);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v83,
        &v73);
      v42 = (int)v75;
      v43 = v76;
      v44 = v77;
      v45 = (int)v79;
      v46 = v78;
      v47 = v82;
      v48 = v81;
      v49 = v80;
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        &v83);
      v92 = v42;
      v93 = v43;
      v96 = (_DWORD *)v45;
      v95 = v46;
      v94 = v44;
      v97 = v49;
      v98 = v48;
      v99 = v47;
      v50 = std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>(
              &v96,
              &v92);
      while ( v50 > 0 )
      {
        v51 = v88;
        v52 = v96;
        v53 = -858993459 * (((signed int)v96 - v97) >> 2);
        v54 = -858993459 * (((signed int)v88 - v89) >> 2);
        if ( !(-858993459 * (((signed int)v96 - v97) >> 2)) )
        {
          v53 = 25;
          v52 = (_DWORD *)(*(_DWORD *)(v99 - 4) + 500);
        }
        if ( !v54 )
        {
          v54 = 25;
          v51 = (_DWORD *)(*(_DWORD *)(v91 - 4) + 500);
        }
        if ( v53 >= v50 )
          v55 = v50;
        else
          v55 = v53;
        if ( v55 >= v54 )
          v55 = v54;
        for ( i = -858993459 * (20 * v55 >> 2); i > 0; --i )
        {
          v51 -= 5;
          v52 -= 5;
          Json::Reader::ErrorInfo::operator=(v51, v52);
        }
        v50 -= v55;
        std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>::operator+=(
          (int *)&v96,
          -v55);
        std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+=(
          (int *)&v88,
          -v55);
      }
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v87,
        &v88);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
        (int)&v88,
        v65,
        v66,
        v57);
      v58 = (int)v65;
      v59 = (int *)&v88;
    }
    std::fill<Json::Reader::ErrorInfo>(v58, (int)v59, &v100);
  }
  else
  {
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_front(
      (int)&v69,
      v67,
      v66);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v73,
      v4);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
      (int)&v96,
      v4,
      v7,
      v9);
    v11 = v97;
    v12 = v98;
    v10 = v99;
    *v65 = v96;
    v65[1] = v11;
    v65[2] = v12;
    v65[3] = v10;
    if ( v7 < v66 )
    {
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v87,
        v4);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        v65);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v92,
        &v69);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v96,
        v4);
      std::__uninitialized_move_fill<std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>(
        &v87,
        &v88,
        &v92,
        &v96,
        &v100);
      v31 = v70;
      v32 = v71;
      v33 = v72;
      *v4 = *(_DWORD *)&v69;
      v4[1] = v31;
      v4[2] = v32;
      v4[3] = v33;
      v30 = (int *)&v73;
    }
    else
    {
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
        (int)&v87,
        v4,
        v66,
        v10);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        v4);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v92,
        &v87);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v96,
        &v69);
      sub_51F42((int *)&v68, &v88, &v92, &v96);
      v13 = v70;
      v14 = v71;
      v15 = v72;
      *v4 = *(_DWORD *)&v69;
      v4[1] = v13;
      v4[2] = v14;
      v4[3] = v15;
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v88,
        &v87);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v92,
        v65);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v96,
        &v73);
      v16 = (int)v88;
      v17 = v90;
      v18 = v93;
      v19 = v89;
      v20 = v91;
      v21 = v92;
      v22 = v94;
      v23 = v95;
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v75,
        &v96);
      v79 = (_DWORD *)v16;
      v81 = v17;
      v84 = v18;
      v80 = v19;
      v82 = v20;
      v83 = v21;
      v85 = v22;
      v86 = v23;
      v24 = std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>(
              &v83,
              &v79);
      while ( v24 > 0 )
      {
        v25 = v75;
        v26 = v79;
        v27 = -858993459 * ((v77 - (signed int)v75) >> 2);
        if ( v27 >= -858993459 * ((v81 - (signed int)v79) >> 2) )
          v27 = -858993459 * ((v81 - (signed int)v79) >> 2);
        if ( v27 >= v24 )
          v27 = v24;
        for ( j = -858993459 * (20 * v27 >> 2); j > 0; --j )
        {
          Json::Reader::ErrorInfo::operator=(v25, v26);
          v26 += 5;
          v25 += 5;
        }
        std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const&,Json::Reader::ErrorInfo const*>::operator+=(
          (int *)&v79,
          v27);
        v24 -= v27;
        std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+=(
          (int *)&v75,
          v27);
      }
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
        &v74,
        &v75);
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator-(
        (int)&v96,
        v65,
        v66,
        v29);
      v30 = (int *)&v96;
    }
    std::fill<Json::Reader::ErrorInfo>((int)v30, (int)v65, &v100);
  }
  return sub_C0AD8(&v101);
}

//----- (00053084) --------------------------------------------------------
_DWORD *__fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_fill_insert(int a1, _DWORD *a2, unsigned int a3, _DWORD *a4)
{
  int v4; // r4
  _DWORD *v5; // r8
  signed int v6; // r6
  _DWORD *v7; // r7
  _DWORD *result; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // [sp+0h] [bp-50h]
  int v13; // [sp+4h] [bp-4Ch]
  int v14; // [sp+8h] [bp-48h]
  int v15; // [sp+Ch] [bp-44h]
  char v16; // [sp+10h] [bp-40h]
  char v17; // [sp+20h] [bp-30h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  if ( *a2 == *(_DWORD *)(a1 + 8) )
  {
    v7 = (_DWORD *)(a1 + 8);
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_front(
      (int)&v12,
      a1,
      a3);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v16,
      &v12);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v17,
      (_DWORD *)(v4 + 8));
    sub_51F04(&v16, &v17, v5);
LABEL_5:
    result = v12;
    v9 = v13;
    v10 = v14;
    v11 = v15;
    *v7 = v12;
    v7[1] = v9;
    v7[2] = v10;
    v7[3] = v11;
    return result;
  }
  if ( *a2 == *(_DWORD *)(a1 + 24) )
  {
    v7 = (_DWORD *)(a1 + 24);
    std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_reserve_elements_at_back(
      (int)&v12,
      a1,
      a3);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v16,
      (_DWORD *)(v4 + 24));
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v17,
      &v12);
    sub_51F04(&v16, &v17, v5);
    goto LABEL_5;
  }
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v17,
    a2);
  return std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_insert_aux(v4, &v17, v6, v5);
}

//----- (00053150) --------------------------------------------------------
_DWORD *__fastcall std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::resize(int a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *v3; // r7
  _DWORD *v4; // r8
  unsigned int v5; // r5
  int v6; // r4
  _DWORD *v7; // r9
  _DWORD *result; // r0
  int v9; // r3
  unsigned int v10; // r5
  int v11; // [sp+0h] [bp-40h]
  char v12; // [sp+10h] [bp-30h]

  v3 = (_DWORD *)(a1 + 8);
  v4 = (_DWORD *)(a1 + 24);
  v5 = a2;
  v6 = a1;
  v7 = a3;
  result = (_DWORD *)std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(
                       (_DWORD *)(a1 + 24),
                       (_DWORD *)(a1 + 8));
  if ( v5 <= (unsigned int)result )
  {
    if ( v5 < (unsigned int)result )
    {
      std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::operator+(
        (int)&v12,
        v3,
        v5,
        v9);
      result = (_DWORD *)std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_erase_at_end(
                           v6,
                           (int *)&v12);
    }
  }
  else
  {
    v10 = v5 - (_DWORD)result;
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v11,
      v4);
    std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
      &v12,
      &v11);
    result = std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_fill_insert(
               v6,
               &v12,
               v10,
               v7);
  }
  return result;
}

//----- (000531B0) --------------------------------------------------------
int __fastcall Json::Reader::recoverFromError(int a1, int a2)
{
  int v2; // r5
  int v3; // r8
  int v4; // r7
  int v5; // r6
  int v7; // [sp+0h] [bp-40h]
  char s; // [sp+Ch] [bp-34h]
  void *v9; // [sp+18h] [bp-28h]

  v2 = a1;
  v3 = a2;
  v4 = a1 + 40;
  v5 = std::operator-<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>(
         (_DWORD *)(a1 + 64),
         (_DWORD *)(a1 + 48));
  do
  {
    if ( !Json::Reader::readToken(v2, &v7) )
    {
      memset(&s, 0, 0x14u);
      v9 = &unk_2FEF48;
      std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::resize(v4, v5, &s);
      sub_C0AD8(&v9);
    }
  }
  while ( v7 != v3 && v7 );
  memset(&s, 0, 0x14u);
  v9 = &unk_2FEF48;
  std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::resize(v4, v5, &s);
  sub_C0AD8(&v9);
  return 0;
}

//----- (00053250) --------------------------------------------------------
int __fastcall Json::Reader::addErrorAndRecover(_DWORD *a1, int a2, int *a3, int a4)
{
  int v4; // r5
  int v5; // r4

  v4 = (int)a1;
  v5 = a4;
  Json::Reader::addError(a1, a2, a3, 0);
  return Json::Reader::recoverFromError(v4, v5);
}

//----- (00053268) --------------------------------------------------------
char *__fastcall std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Value **>(void *src, int a2, char *a3)
{
  int v3; // r1
  char *v4; // r3
  size_t v5; // r4

  v3 = a2 - (_DWORD)src;
  v4 = a3;
  v5 = 4 * (v3 >> 2);
  if ( v3 >> 2 )
    v4 = (char *)memmove(a3, src, v5);
  return &v4[v5];
}

//----- (00053288) --------------------------------------------------------
unsigned int *__fastcall std::deque<Json::Value *,std::allocator<Json::Value *>>::push_back(unsigned int *result, _DWORD *a2)
{
  void **v2; // r4
  _DWORD *v3; // r8
  _DWORD *v4; // r3
  int v5; // r3
  unsigned int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r3
  unsigned int v9; // r6
  int v10; // r7
  int v11; // r9
  int v12; // r1
  char *v13; // r5
  int v14; // r1
  signed int v15; // r2
  unsigned int v16; // r6
  char *v17; // r0
  char *v18; // r10
  char *v19; // r3
  int v20; // r3
  _DWORD *v21; // r5
  _DWORD *v22; // r3
  _DWORD *v23; // r3

  v2 = (void **)result;
  v3 = a2;
  v4 = (_DWORD *)result[6];
  if ( v4 == (_DWORD *)(result[8] - 4) )
  {
    v6 = result[9];
    v7 = *result;
    v8 = result[1];
    if ( v8 - ((signed int)(v6 - *result) >> 2) <= 1 )
    {
      v9 = result[5];
      v10 = ((signed int)(v6 - v9) >> 2) + 1;
      v11 = ((signed int)(v6 - v9) >> 2) + 2;
      if ( v8 <= 2 * v11 )
      {
        if ( v8 )
          v15 = result[1];
        else
          v15 = 1;
        v16 = v8 + 2 + v15;
        if ( v16 >= 0x40000000 )
          sub_BFA08();
        v17 = (char *)operator new(4 * v16);
        v13 = &v17[4 * ((v16 - v11) >> 1)];
        v18 = v17;
        std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Value **>(
          v2[5],
          (int)v2[9] + 4,
          v13);
        operator delete(*v2);
        *v2 = v18;
        v2[1] = (void *)v16;
      }
      else
      {
        v12 = v6 + 4;
        v13 = (char *)(v7 + 4 * ((v8 - v11) >> 1));
        if ( (unsigned int)v13 >= v9 )
        {
          v14 = (signed int)(v12 - v9) >> 2;
          if ( v14 )
            memmove(&v13[4 * v10 + -4 * v14], (const void *)result[5], 4 * v14);
        }
        else
        {
          std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::Value **>(
            (void *)result[5],
            v12,
            (char *)(v7 + 4 * ((v8 - v11) >> 1)));
        }
      }
      v2[5] = v13;
      v19 = *(char **)v13;
      v2[3] = *(void **)v13;
      v2[4] = v19 + 512;
      v2[9] = &v13[4 * (v10 + 0x3FFFFFFF)];
      v20 = *(_DWORD *)&v13[4 * (v10 + 0x3FFFFFFF)];
      v2[7] = (void *)v20;
      v2[8] = (void *)(v20 + 512);
    }
    v21 = v2[9];
    result = (unsigned int *)operator new(0x200u);
    v21[1] = result;
    v22 = v2[6];
    if ( v22 )
      *v22 = *v3;
    v23 = v2[9];
    v2[9] = v23 + 1;
    v5 = v23[1];
    v2[8] = (void *)(v5 + 512);
    v2[7] = (void *)v5;
  }
  else
  {
    if ( v4 )
      *v4 = *a2;
    v5 = result[6] + 4;
  }
  v2[6] = (void *)v5;
  return result;
}

//----- (00053388) --------------------------------------------------------
signed int __fastcall Json::Reader::readObject(Json::Reader *a1, int a2, int a3)
{
  Json::Reader *v3; // r4
  int v4; // r6
  signed int v5; // r6
  signed int v6; // r0
  int *v7; // r0
  int v8; // r0
  int v9; // r1
  int v10; // r2
  Json::Value *v11; // r0
  int v12; // r7
  signed int v13; // r0
  char *v14; // r7
  int v15; // r0
  _DWORD *v17; // [sp+4h] [bp-54h]
  char v18; // [sp+8h] [bp-50h]
  char v19; // [sp+Ch] [bp-4Ch]
  int v20; // [sp+10h] [bp-48h]
  int v21; // [sp+1Ch] [bp-3Ch]
  int *v22; // [sp+28h] [bp-30h]

  v3 = a1;
  v17 = &unk_2FEF48;
  v4 = Json::Reader::currentValue(a1, a2, a3, &unk_2FEF48);
  Json::Value::Value((int)&v22, 7);
  Json::Value::operator=(v4, (const Json::Value *)&v22);
  Json::Value::~Value((Json::Value *)&v22);
  while ( 1 )
  {
LABEL_2:
    v5 = Json::Reader::readToken((int)v3, &v20);
    if ( !v5 )
      goto LABEL_12;
    v6 = 1;
    while ( v20 == 12 )
    {
      if ( !v6 )
        goto LABEL_12;
      v6 = Json::Reader::readToken((int)v3, &v20);
    }
    if ( !v6 )
      goto LABEL_12;
    if ( v20 == 2 )
    {
      if ( !*(v17 - 3) )
        goto LABEL_33;
LABEL_12:
      sub_C1C58((void **)&v21, "Missing '}' or object member name");
      v5 = Json::Reader::addErrorAndRecover(v3, (int)&v21, &v20, 2);
      v7 = &v21;
      goto LABEL_13;
    }
    if ( v20 != 5 )
      goto LABEL_12;
    sub_C1034((int *)&v17, &byte_E4496);
    if ( !Json::Reader::decodeString(v3, &v20, (int *)&v17) )
      break;
    if ( !Json::Reader::readToken((int)v3, &v21) || v21 != 11 )
    {
      v14 = &v18;
      sub_C1C58((void **)&v18, "Missing ':' after object member name");
      v15 = Json::Reader::addErrorAndRecover(v3, (int)&v18, &v21, 2);
      goto LABEL_32;
    }
    v11 = (Json::Value *)Json::Reader::currentValue(v3, v9, v10, &byte_9[2]);
    v22 = Json::Value::operator[](v11, (const char **)&v17);
    std::deque<Json::Value *,std::allocator<Json::Value *>>::push_back((unsigned int *)v3, &v22);
    v12 = Json::Reader::readValue(v3);
    std::deque<Json::Value *,std::allocator<Json::Value *>>::pop_back(v3);
    v8 = (int)v3;
    if ( !v12 )
      goto LABEL_19;
    if ( !Json::Reader::readToken((int)v3, (signed int *)&v22)
      || ((unsigned int)v22 & 0xFFFFFFF7) != 2 && v22 != (int *)&byte_9[3] )
    {
      v14 = &v19;
      sub_C1C58((void **)&v19, "Missing ',' or '}' in object declaration");
      v15 = Json::Reader::addErrorAndRecover(v3, (int)&v19, (int *)&v22, 2);
LABEL_32:
      v5 = v15;
      v7 = (int *)v14;
LABEL_13:
      sub_C0AD8(v7);
      goto LABEL_33;
    }
    v13 = 1;
    while ( v22 == (int *)&byte_9[3] )
    {
      if ( !v13 )
        goto LABEL_2;
      v13 = Json::Reader::readToken((int)v3, (signed int *)&v22);
    }
    if ( v22 == (int *)((char *)&dword_0 + 2) )
      goto LABEL_33;
  }
  v8 = (int)v3;
LABEL_19:
  v5 = Json::Reader::recoverFromError(v8, 2);
LABEL_33:
  sub_C0AD8(&v17);
  return v5;
}
// 0: using guessed type int dword_0;
// E4496: using guessed type char byte_E4496;

//----- (00053534) --------------------------------------------------------
int __fastcall Json::Reader::readValue(Json::Reader *this)
{
  Json::Reader *v1; // r4
  int v2; // r1
  int v3; // r2
  _DWORD *v4; // r3
  _DWORD *v5; // r3
  signed int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r5
  int v10; // r6
  int v11; // r6
  int v12; // r6
  _DWORD *v13; // r3
  int v14; // r0
  int v16; // [sp+4h] [bp-2Ch]
  char v17; // [sp+10h] [bp-20h]

  v1 = this;
  Json::Reader::skipCommentTokens((int)this, &v16);
  if ( *((_BYTE *)v1 + 110) )
  {
    v4 = *(_DWORD **)(*((_DWORD *)v1 + 26) - 12);
    if ( v4 )
    {
      v14 = Json::Reader::currentValue(v1, v2, v3, v4);
      Json::Value::setComment(v14, (const char **)v1 + 26, 0);
      sub_C1034((int *)v1 + 26, &byte_E4496);
    }
  }
  v5 = (_DWORD *)(v16 - 1);
  switch ( v16 )
  {
    case 1:
      v6 = Json::Reader::readObject(v1, (int)&v16, v3);
      goto LABEL_7;
    case 3:
      v6 = Json::Reader::readArray(v1, (int)&v16, v3, v5);
      goto LABEL_7;
    case 5:
      v6 = Json::Reader::decodeString(v1, &v16);
      goto LABEL_7;
    case 6:
      v6 = Json::Reader::decodeNumber(v1, &v16);
LABEL_7:
      v9 = v6;
      goto LABEL_15;
    case 7:
      v10 = Json::Reader::currentValue(v1, v2, v3, v5);
      Json::Value::Value((int)&v17, 1);
      Json::Value::operator=(v10, (const Json::Value *)&v17);
      goto LABEL_13;
    case 8:
      v11 = Json::Reader::currentValue(v1, v2, v3, v5);
      Json::Value::Value((int)&v17, 0);
      Json::Value::operator=(v11, (const Json::Value *)&v17);
      goto LABEL_13;
    case 9:
      v12 = Json::Reader::currentValue(v1, v2, v3, v5);
      Json::Value::Value((int)&v17, 0);
      Json::Value::operator=(v12, (const Json::Value *)&v17);
LABEL_13:
      v9 = 1;
      Json::Value::~Value((Json::Value *)&v17);
LABEL_15:
      if ( *((_BYTE *)v1 + 110) )
      {
        v13 = (_DWORD *)*((_DWORD *)v1 + 23);
        *((_DWORD *)v1 + 24) = v13;
        *((_DWORD *)v1 + 25) = Json::Reader::currentValue(v1, v7, v8, v13);
      }
      break;
    default:
      sub_C1C58((void **)&v17, "Syntax error: value, object or array expected.");
      v9 = Json::Reader::addError(v1, (int)&v17, &v16, 0);
      sub_C0AD8(&v17);
      break;
  }
  return v9;
}
// E4496: using guessed type char byte_E4496;

//----- (00053674) --------------------------------------------------------
int __fastcall Json::Reader::readArray(Json::Reader *a1, int a2, int a3, _DWORD *a4)
{
  unsigned __int8 **v4; // r4
  int v5; // r6
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r6
  int v10; // r0
  signed int v11; // r0
  int v12; // r0
  int v13; // r7
  int v14; // r4
  void *v16; // [sp+4h] [bp-2Ch]
  int *v17; // [sp+8h] [bp-28h]

  v4 = (unsigned __int8 **)a1;
  v5 = Json::Reader::currentValue(a1, a2, a3, a4);
  Json::Value::Value((int)&v17, 6);
  Json::Value::operator=(v5, (const Json::Value *)&v17);
  Json::Value::~Value((Json::Value *)&v17);
  Json::Reader::skipSpaces((int)v4);
  v8 = *v4[23];
  if ( v8 == 93 )
  {
    Json::Reader::readToken((int)v4, (signed int *)&v17);
LABEL_12:
    v14 = 1;
  }
  else
  {
    v9 = 0;
    while ( 1 )
    {
      v12 = Json::Reader::currentValue((Json::Reader *)v4, v6, v7, (_DWORD *)v8);
      v17 = Json::Value::operator[](v12, v9);
      std::deque<Json::Value *,std::allocator<Json::Value *>>::push_back((unsigned int *)v4, &v17);
      v13 = Json::Reader::readValue((Json::Reader *)v4);
      std::deque<Json::Value *,std::allocator<Json::Value *>>::pop_back(v4);
      v10 = (int)v4;
      if ( !v13 )
        break;
      while ( 1 )
      {
        v11 = Json::Reader::readToken(v10, (signed int *)&v17);
        v8 = (int)v17;
        if ( v17 != (int *)&byte_9[3] )
          break;
        if ( !v11 )
          goto LABEL_11;
        v10 = (int)v4;
      }
      if ( !v11 )
      {
LABEL_11:
        sub_C1C58(&v16, "Missing ',' or ']' in array declaration");
        v14 = Json::Reader::addErrorAndRecover(v4, (int)&v16, (int *)&v17, 4);
        sub_C0AD8(&v16);
        return v14;
      }
      ++v9;
      if ( v17 == (int *)byte_4 )
        goto LABEL_12;
    }
    v14 = Json::Reader::recoverFromError((int)v4, 4);
  }
  return v14;
}

//----- (00053748) --------------------------------------------------------
int __fastcall Json::Reader::parse(Json::Reader *this, const char *a2, const char *a3, Json::Value *a4, bool a5)
{
  const char *v5; // r9
  Json::Value *v6; // r5
  int v7; // r2
  Json::Reader *v8; // r4
  bool v9; // r3
  const char *v10; // r7
  const char **v11; // r10
  int v12; // r8
  _BOOL4 v13; // r5
  void *v15; // [sp+4h] [bp-34h]
  Json::Value *v16; // [sp+8h] [bp-30h]
  const char *v17; // [sp+Ch] [bp-2Ch]
  const char *v18; // [sp+10h] [bp-28h]

  v5 = a3;
  v6 = a4;
  v7 = *((unsigned __int8 *)this + 108);
  v8 = this;
  v9 = a5;
  v10 = a2;
  *((_DWORD *)this + 21) = a2;
  v11 = (const char **)((char *)this + 104);
  if ( !v7 )
    v9 = 0;
  *((_DWORD *)this + 22) = v5;
  *((_BYTE *)this + 110) = v9;
  *((_DWORD *)this + 23) = a2;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = 0;
  sub_C1034((int *)this + 26, &byte_E4496);
  std::_Deque_iterator<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo&,Json::Reader::ErrorInfo*>::_Deque_iterator(
    &v16,
    (_DWORD *)v8 + 12);
  std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>>::_M_erase_at_end(
    (int)v8 + 40,
    (int *)&v16);
  while ( *((_DWORD *)v8 + 6) != *((_DWORD *)v8 + 2) )
    std::deque<Json::Value *,std::allocator<Json::Value *>>::pop_back(v8);
  v16 = v6;
  std::deque<Json::Value *,std::allocator<Json::Value *>>::push_back((unsigned int *)v8, &v16);
  v12 = Json::Reader::readValue(v8);
  Json::Reader::skipCommentTokens((int)v8, (signed int *)&v16);
  if ( *((_BYTE *)v8 + 110) && *(_DWORD *)(*((_DWORD *)v8 + 26) - 12) )
    Json::Value::setComment((int)v6, v11, 2);
  if ( !*((_BYTE *)v8 + 109) )
    return v12;
  if ( Json::Value::isArray(v6) )
    return v12;
  v13 = Json::Value::isObject(v6);
  if ( v13 )
    return v12;
  v17 = v10;
  v16 = (Json::Value *)(byte_9 + 4);
  v18 = v5;
  sub_C1C58(&v15, "A valid JSON document must be either an array or an object value.");
  Json::Reader::addError(v8, (int)&v15, (int *)&v16, 0);
  sub_C0AD8(&v15);
  return v13;
}
// E4496: using guessed type char byte_E4496;

//----- (00053844) --------------------------------------------------------
int __fastcall Json::Reader::parse(const char **a1, int a2, Json::Value *a3, bool a4)
{
  const char **v4; // r4
  Json::Value *v5; // r5
  bool v6; // r6

  v4 = a1;
  v5 = a3;
  v6 = a4;
  sub_C1778(a1 + 20, a2);
  return Json::Reader::parse((Json::Reader *)v4, v4[20], &v4[20][*((_DWORD *)v4[20] - 3)], v5, v6);
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);

//----- (00053868) --------------------------------------------------------
int __fastcall Json::Reader::parse(const char **a1, _DWORD *a2, int a3, bool a4)
{
  bool v4; // r5
  const char **v5; // r7
  Json::Value *v6; // r6
  int v7; // r5
  void *v9; // [sp+4h] [bp-1Ch]
  int v10; // [sp+8h] [bp-18h]

  v10 = a3;
  v4 = a4;
  v5 = a1;
  v6 = (Json::Value *)a3;
  v9 = &unk_2FEF48;
  sub_AA0A8(a2, (int *)&v9, 255);
  v7 = Json::Reader::parse(v5, (int)&v9, v6, v4);
  sub_C0AD8(&v9);
  return v7;
}

//----- (000538B4) --------------------------------------------------------
_DWORD *__fastcall Json::operator>>(_DWORD *a1, int a2)
{
  int v2; // r6
  _DWORD *v3; // r5
  _DWORD *v4; // r6
  int v6; // [sp+4h] [bp-84h]
  char v7; // [sp+8h] [bp-80h]

  v2 = a2;
  v3 = a1;
  Json::Reader::Reader((Json::Reader *)&v7);
  if ( !Json::Reader::parse((const char **)&v7, v3, v2, 1) )
  {
    v4 = (_DWORD *)_cxa_allocate_exception(8);
    Json::Reader::getFormatedErrorMessages((Json::Reader *)&v6, &v7);
    sub_94FC4(v4, &v6);
    sub_C0AD8(&v6);
    _cxa_throw((int)v4, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
  }
  Json::Reader::~Reader((Json::Reader *)&v7);
  return v3;
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (00053934) --------------------------------------------------------
int __fastcall Json::ValueAllocator::~ValueAllocator(int result)
{
  *(_DWORD *)result = &off_F0280;
  return result;
}
// F0280: using guessed type void *;

//----- (00053944) --------------------------------------------------------
Json::DefaultValueAllocator *__fastcall Json::DefaultValueAllocator::~DefaultValueAllocator(Json::DefaultValueAllocator *this)
{
  Json::DefaultValueAllocator *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F0260;
  Json::ValueAllocator::~ValueAllocator((int)this);
  return v1;
}
// F0260: using guessed type void *off_F0260;

//----- (00053960) --------------------------------------------------------
int __fastcall Json::DefaultValueAllocator::makeMemberName(Json::DefaultValueAllocator *this, const char *a2)
{
  return (*(int (**)(void))(*(_DWORD *)this + 16))();
}

//----- (0005396E) --------------------------------------------------------
int __fastcall Json::DefaultValueAllocator::releaseMemberName(Json::DefaultValueAllocator *this, char *a2)
{
  return (*(int (**)(void))(*(_DWORD *)this + 20))();
}

//----- (00053978) --------------------------------------------------------
Json::ValueAllocator *__fastcall Json::ValueAllocator::~ValueAllocator(Json::ValueAllocator *this)
{
  Json::ValueAllocator *v1; // r4

  v1 = this;
  Json::ValueAllocator::~ValueAllocator((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005398A) --------------------------------------------------------
Json::DefaultValueAllocator *__fastcall Json::DefaultValueAllocator::~DefaultValueAllocator(Json::DefaultValueAllocator *this)
{
  Json::DefaultValueAllocator *v1; // r4

  v1 = this;
  Json::DefaultValueAllocator::~DefaultValueAllocator(this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005399C) --------------------------------------------------------
_BYTE *__fastcall Json::DefaultValueAllocator::duplicateStringValue(Json::DefaultValueAllocator *this, const char *a2, unsigned int a3)
{
  const char *v3; // r5
  unsigned int v4; // r4
  void *v5; // r0
  _BYTE *result; // r0

  v3 = a2;
  v4 = a3;
  if ( a3 == -1 )
    v4 = strlen(a2);
  v5 = malloc(v4 + 1);
  result = memcpy(v5, v3, v4);
  result[v4] = 0;
  return result;
}

//----- (000539C2) --------------------------------------------------------
void __fastcall Json::DefaultValueAllocator::releaseStringValue(Json::DefaultValueAllocator *this, char *a2)
{
  if ( a2 )
    j_free(a2);
}

//----- (000539CC) --------------------------------------------------------
int **sub_539CC()
{
  if ( !(dword_2F6068 & 1) && _cxa_guard_acquire((unsigned int *)&dword_2F6068) )
  {
    dword_2F606C = (int)&off_F0260;
    _cxa_guard_release((unsigned int *)&dword_2F6068);
    sub_936DC();
  }
  return &off_F3960;
}
// F0260: using guessed type void *off_F0260;
// F3960: using guessed type int *off_F3960;
// 2F6068: using guessed type int dword_2F6068;
// 2F606C: using guessed type int dword_2F606C;

//----- (00053A1C) --------------------------------------------------------
void __fastcall sub_53A1C(void *a1)
{
  if ( a1 )
    operator delete(a1);
}

//----- (00053A24) --------------------------------------------------------
void *__fastcall sub_53A24(unsigned int a1)
{
  if ( a1 >= 0x40000000 )
    sub_BFA08();
  return operator new(4 * a1);
}

//----- (00053A3A) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::ValueIteratorBase(int result)
{
  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 1;
  return result;
}

//----- (00053A44) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::ValueIteratorBase(int result, _DWORD *a2)
{
  *(_DWORD *)result = *a2;
  *(_BYTE *)(result + 4) = 0;
  return result;
}

//----- (00053A4E) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::deref(Json::ValueIteratorBase *this)
{
  return *(_DWORD *)this + 24;
}

//----- (00053A54) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::increment(Json::ValueIteratorBase *this)
{
  Json::ValueIteratorBase *v1; // r4
  int result; // r0

  v1 = this;
  result = sub_94888(*(_DWORD *)this);
  *(_DWORD *)v1 = result;
  return result;
}

//----- (00053A62) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::decrement(Json::ValueIteratorBase *this)
{
  Json::ValueIteratorBase *v1; // r4
  int result; // r0

  v1 = this;
  result = sub_948F8(*(_DWORD *)this);
  *(_DWORD *)v1 = result;
  return result;
}
// 948F8: using guessed type int __fastcall sub_948F8(_DWORD);

//----- (00053A70) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::computeDistance(Json::ValueIteratorBase *this, const Json::ValueIteratorBase *a2)
{
  int v2; // r0
  int v3; // r4
  int v4; // r5

  if ( *((_BYTE *)this + 4) && *((_BYTE *)a2 + 4) )
    return 0;
  v2 = *(_DWORD *)this;
  v3 = 0;
  v4 = *(_DWORD *)a2;
  while ( v2 != v4 )
  {
    ++v3;
    v2 = sub_94888(v2);
  }
  return v3;
}

//----- (00053A94) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::isEqual(Json::ValueIteratorBase *this, const Json::ValueIteratorBase *a2)
{
  int result; // r0

  if ( *((_BYTE *)this + 4) )
    result = *((unsigned __int8 *)a2 + 4);
  else
    result = *(_DWORD *)this
           - *(_DWORD *)a2
           + ((unsigned int)(*(_DWORD *)this - *(_DWORD *)a2) <= 0)
           + *(_DWORD *)a2
           - *(_DWORD *)this;
  return result;
}

//----- (00053AA8) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::copy(int result, const Json::ValueIteratorBase *a2)
{
  *(_DWORD *)result = *(_DWORD *)a2;
  return result;
}

//----- (00053AAE) --------------------------------------------------------
Json::ValueConstIterator *__fastcall Json::ValueConstIterator::ValueConstIterator(Json::ValueConstIterator *this)
{
  Json::ValueConstIterator *v1; // r4

  v1 = this;
  Json::ValueIteratorBase::ValueIteratorBase((int)this);
  return v1;
}

//----- (00053ABA) --------------------------------------------------------
int __fastcall Json::ValueConstIterator::ValueConstIterator(int a1, _DWORD *a2)
{
  int v2; // r4

  v2 = a1;
  Json::ValueIteratorBase::ValueIteratorBase(a1, a2);
  return v2;
}

//----- (00053AC6) --------------------------------------------------------
int __fastcall Json::ValueConstIterator::operator=(int a1, const Json::ValueIteratorBase *a2)
{
  int v2; // r4

  v2 = a1;
  Json::ValueIteratorBase::copy(a1, a2);
  return v2;
}

//----- (00053AD2) --------------------------------------------------------
Json::ValueIterator *__fastcall Json::ValueIterator::ValueIterator(Json::ValueIterator *this)
{
  Json::ValueIterator *v1; // r4

  v1 = this;
  Json::ValueIteratorBase::ValueIteratorBase((int)this);
  return v1;
}

//----- (00053ADE) --------------------------------------------------------
int __fastcall Json::ValueIterator::ValueIterator(int a1, _DWORD *a2)
{
  int v2; // r4

  v2 = a1;
  Json::ValueIteratorBase::ValueIteratorBase(a1, a2);
  return v2;
}

//----- (00053AEA) --------------------------------------------------------
int __fastcall Json::ValueIterator::ValueIterator(int result, const Json::ValueConstIterator *a2)
{
  char v2; // ST04_1

  v2 = *((_DWORD *)a2 + 1);
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_BYTE *)(result + 4) = v2;
  return result;
}

//----- (00053B08) --------------------------------------------------------
int __fastcall Json::ValueIterator::ValueIterator(int result, const Json::ValueIterator *a2)
{
  char v2; // ST04_1

  v2 = *((_DWORD *)a2 + 1);
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_BYTE *)(result + 4) = v2;
  return result;
}

//----- (00053B26) --------------------------------------------------------
int __fastcall Json::ValueIterator::operator=(int a1, const Json::ValueIteratorBase *a2)
{
  int v2; // r4

  v2 = a1;
  Json::ValueIteratorBase::copy(a1, a2);
  return v2;
}

//----- (00053B32) --------------------------------------------------------
int __fastcall Json::Value::CommentInfo::CommentInfo(int result)
{
  *(_DWORD *)result = 0;
  return result;
}

//----- (00053B38) --------------------------------------------------------
Json::Value::CommentInfo *__fastcall Json::Value::CommentInfo::~CommentInfo(Json::Value::CommentInfo *this)
{
  Json::Value::CommentInfo *v1; // r4
  int **v2; // r0
  int v3; // r1

  v1 = this;
  if ( *(_DWORD *)this )
  {
    v2 = sub_539CC();
    v3 = *(_DWORD *)v1;
    (*(void (**)(void))(**v2 + 20))();
  }
  return v1;
}

//----- (00053B54) --------------------------------------------------------
int __fastcall Json::Value::CommentInfo::setComment(Json::Value::CommentInfo *this, const char *a2, int a3)
{
  Json::Value::CommentInfo *v3; // r4
  const char *v4; // r5
  int **v5; // r0
  int v6; // r2
  _DWORD *v7; // r5
  int **v8; // r0
  int result; // r0
  const char *v10; // [sp+4h] [bp-14h]
  int v11; // [sp+8h] [bp-10h]

  v10 = a2;
  v11 = a3;
  v3 = this;
  v4 = a2;
  if ( *(_DWORD *)this )
  {
    v5 = sub_539CC();
    (*(void (__cdecl **)(int *, _DWORD, int))(**v5 + 20))(*v5, *(_DWORD *)v3, v6);
  }
  if ( *v4 && *v4 != 47 )
  {
    v7 = (_DWORD *)_cxa_allocate_exception(8);
    sub_C1C58((void **)&v10, "Comments must start with /");
    sub_94FC4(v7, (int *)&v10);
    sub_C0AD8(&v10);
    _cxa_throw((int)v7, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
  }
  v8 = sub_539CC();
  result = (*(int (__cdecl **)(int *, const char *, signed int))(**v8 + 16))(*v8, v4, -1);
  *(_DWORD *)v3 = result;
  return result;
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (00053BE0) --------------------------------------------------------
int __fastcall Json::Value::CZString::CZString(int result, int a2)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)result = 0;
  return result;
}

//----- (00053BE8) --------------------------------------------------------
int *__fastcall Json::Value::CZString::CZString(int *a1, int a2, int a3)
{
  int *v3; // r4
  int v4; // r5
  int **v5; // r0
  int v6; // r0

  v3 = a1;
  v4 = a3;
  if ( a3 == 1 )
  {
    v5 = sub_539CC();
    v6 = (*(int (**)(void))(**v5 + 8))();
  }
  else
  {
    v6 = a2;
  }
  *v3 = v6;
  v3[1] = v4;
  return v3;
}

//----- (00053C0E) --------------------------------------------------------
Json::Value::CZString *__fastcall Json::Value::CZString::CZString(Json::Value::CZString *this, const Json::Value::CZString *a2)
{
  Json::Value::CZString *v2; // r5
  int v3; // r0
  const Json::Value::CZString *v4; // r4
  int **v5; // r0
  int v6; // r1
  int v7; // r3

  v2 = this;
  v3 = *(_DWORD *)a2;
  v4 = a2;
  if ( *((_DWORD *)a2 + 1) && v3 )
  {
    v5 = sub_539CC();
    v6 = *(_DWORD *)v4;
    v3 = (*(int (**)(void))(**v5 + 8))();
  }
  *(_DWORD *)v2 = v3;
  v7 = *((_DWORD *)v4 + 1);
  if ( *(_DWORD *)v4 )
    v7 = v7 != 0;
  *((_DWORD *)v2 + 1) = v7;
  return v2;
}

//----- (00053C3E) --------------------------------------------------------
Json::Value::CZString *__fastcall Json::Value::CZString::~CZString(Json::Value::CZString *this)
{
  Json::Value::CZString *v1; // r4
  int **v2; // r0
  int v3; // r1

  v1 = this;
  if ( *(_DWORD *)this && *((_DWORD *)this + 1) == 1 )
  {
    v2 = sub_539CC();
    v3 = *(_DWORD *)v1;
    (*(void (**)(void))(**v2 + 12))();
  }
  return v1;
}

//----- (00053C5E) --------------------------------------------------------
int __fastcall Json::Value::CZString::swap(int result, Json::Value::CZString *a2)
{
  int v2; // r2
  int v3; // r2

  v2 = *(_DWORD *)result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)a2 = v2;
  v3 = *(_DWORD *)(result + 4);
  *(_DWORD *)(result + 4) = *((_DWORD *)a2 + 1);
  *((_DWORD *)a2 + 1) = v3;
  return result;
}

//----- (00053C70) --------------------------------------------------------
int __fastcall Json::Value::CZString::operator=(int a1, const Json::Value::CZString *a2, int a3)
{
  int v3; // r5
  int v5; // [sp+0h] [bp-18h]
  const Json::Value::CZString *v6; // [sp+4h] [bp-14h]
  int v7; // [sp+8h] [bp-10h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v3 = a1;
  Json::Value::CZString::CZString((Json::Value::CZString *)&v5, a2);
  Json::Value::CZString::swap(v3, (Json::Value::CZString *)&v5);
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v5);
  return v3;
}

//----- (00053C98) --------------------------------------------------------
unsigned int __fastcall Json::Value::CZString::operator<(const char **a1, int a2)
{
  const char **v2; // r3
  const char *v3; // r0
  unsigned int result; // r0

  v2 = a1;
  v3 = *a1;
  if ( v3 )
    result = (unsigned int)strcmp(v3, *(const char **)a2) >> 31;
  else
    result = (signed int)v2[1] < *(_DWORD *)(a2 + 4);
  return result;
}

//----- (00053CB8) --------------------------------------------------------
int __fastcall sub_53CB8(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  int v5; // r6

  v3 = a1;
  v4 = a2;
  v5 = a3;
  while ( v3 )
  {
    if ( Json::Value::CZString::operator<((const char **)(v3 + 16), v5) )
    {
      v3 = *(_DWORD *)(v3 + 12);
    }
    else
    {
      v4 = v3;
      v3 = *(_DWORD *)(v3 + 8);
    }
  }
  return v4;
}

//----- (00053CDC) --------------------------------------------------------
bool __fastcall Json::Value::CZString::operator==(const char **a1, int a2)
{
  const char **v2; // r3
  const char *v3; // r0
  _BOOL4 result; // r0

  v2 = a1;
  v3 = *a1;
  if ( v3 )
    result = strcmp(v3, *(const char **)a2) == 0;
  else
    result = (unsigned int)&v2[1][-*(_DWORD *)(a2 + 4)] <= 0;
  return result;
}

//----- (00053D00) --------------------------------------------------------
int __fastcall Json::Value::CZString::index(Json::Value::CZString *this)
{
  return *((_DWORD *)this + 1);
}

//----- (00053D04) --------------------------------------------------------
int __fastcall Json::Value::CZString::c_str(Json::Value::CZString *this)
{
  return *(_DWORD *)this;
}

//----- (00053D08) --------------------------------------------------------
int __fastcall Json::ValueIteratorBase::index(Json::ValueIteratorBase *this, int a2, int a3)
{
  int v3; // r5
  Json::ValueIteratorBase *v5; // [sp+0h] [bp-18h]
  int v6; // [sp+4h] [bp-14h]
  int v7; // [sp+8h] [bp-10h]

  v5 = this;
  v6 = a2;
  v7 = a3;
  Json::Value::CZString::CZString((Json::Value::CZString *)&v5, (const Json::Value::CZString *)(*(_DWORD *)this + 16));
  v3 = -1;
  if ( !Json::Value::CZString::c_str((Json::Value::CZString *)&v5) )
    v3 = Json::Value::CZString::index((Json::Value::CZString *)&v5);
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v5);
  return v3;
}

//----- (00053D40) --------------------------------------------------------
char *__fastcall Json::ValueIteratorBase::memberName(Json::ValueIteratorBase *this)
{
  char *result; // r0

  result = (char *)Json::Value::CZString::c_str((Json::Value::CZString *)(*(_DWORD *)this + 16));
  if ( !result )
    result = &byte_E4496;
  return result;
}
// E4496: using guessed type char byte_E4496;

//----- (00053D58) --------------------------------------------------------
bool __fastcall Json::Value::CZString::isStaticString(Json::Value::CZString *this)
{
  return *((_DWORD *)this + 1) == 0;
}

//----- (00053D64) --------------------------------------------------------
_DWORD *__fastcall Json::Value::Value(int a1, int a2)
{
  _DWORD *v2; // r4
  char v3; // r3
  _DWORD *v4; // r0
  int v5; // r6
  _DWORD *v6; // r5

  v2 = (_DWORD *)a1;
  v3 = *(_BYTE *)(a1 + 9);
  *(_BYTE *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 9) = v3 & 0xFE;
  *(_DWORD *)(a1 + 12) = 0;
  switch ( a2 )
  {
    case 1:
    case 2:
    case 4:
      *(_DWORD *)a1 = 0;
      break;
    case 3:
      *(_QWORD *)a1 = 0LL;
      break;
    case 5:
      *(_BYTE *)a1 = 0;
      break;
    case 6:
    case 7:
      v4 = operator new(0x18u);
      v5 = (int)(v4 + 1);
      v6 = v4;
      memset(v4 + 1, 0, 0x10u);
      v6[3] = v5;
      v6[5] = 0;
      v6[4] = v5;
      *v2 = v6;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (00053DBC) --------------------------------------------------------
int __fastcall Json::Value::Value(int result, int a2)
{
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 8) = 1;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (00053DC8) --------------------------------------------------------
int __fastcall Json::Value::Value(int result, unsigned int a2)
{
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 8) = 2;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (00053DD4) --------------------------------------------------------
int __fastcall Json::Value::Value(int result, int a2, double a3)
{
  *(double *)result = a3;
  *(_BYTE *)(result + 8) = 3;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (00053DE4) --------------------------------------------------------
Json::Value *__fastcall Json::Value::Value(Json::Value *this, const char *a2)
{
  Json::Value *v2; // r4
  int **v3; // r0

  *((_BYTE *)this + 8) = 4;
  v2 = this;
  *((_BYTE *)this + 9) |= 1u;
  *((_DWORD *)this + 3) = 0;
  v3 = sub_539CC();
  *(_DWORD *)v2 = (*(int (**)(void))(**v3 + 16))();
  return v2;
}

//----- (00053E12) --------------------------------------------------------
Json::Value *__fastcall Json::Value::Value(Json::Value *this, const char *a2, const char *a3)
{
  Json::Value *v3; // r4
  int **v4; // r0

  *((_BYTE *)this + 8) = 4;
  v3 = this;
  *((_BYTE *)this + 9) |= 1u;
  *((_DWORD *)this + 3) = 0;
  v4 = sub_539CC();
  *(_DWORD *)v3 = (*(int (**)(void))(**v4 + 16))();
  return v3;
}

//----- (00053E40) --------------------------------------------------------
_DWORD *__fastcall Json::Value::Value(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  int **v4; // r0
  int v5; // r2

  *(_BYTE *)(a1 + 8) = 4;
  v2 = (_DWORD *)a1;
  v3 = a2;
  *(_BYTE *)(a1 + 9) |= 1u;
  *(_DWORD *)(a1 + 12) = 0;
  v4 = sub_539CC();
  v5 = *(_DWORD *)(*v3 - 12);
  *v2 = (*(int (**)(void))(**v4 + 16))();
  return v2;
}

//----- (00053E6E) --------------------------------------------------------
int __fastcall Json::Value::Value(int result, _DWORD *a2)
{
  *(_BYTE *)(result + 8) = 4;
  *(_BYTE *)(result + 9) &= 0xFEu;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)result = *a2;
  return result;
}

//----- (00053E84) --------------------------------------------------------
Json::ValueIteratorBase *__fastcall Json::ValueIteratorBase::key(Json::ValueIteratorBase *this, int a2)
{
  Json::ValueIteratorBase *v2; // r5
  const char *v3; // r0
  int v4; // r0
  int v6; // [sp+4h] [bp-1Ch]
  char v7; // [sp+8h] [bp-18h]

  v2 = this;
  Json::Value::CZString::CZString((Json::Value::CZString *)&v7, (const Json::Value::CZString *)(*(_DWORD *)a2 + 16));
  if ( Json::Value::CZString::c_str((Json::Value::CZString *)&v7) )
  {
    if ( Json::Value::CZString::isStaticString((Json::Value::CZString *)&v7) )
    {
      v6 = Json::Value::CZString::c_str((Json::Value::CZString *)&v7);
      Json::Value::Value((int)v2, &v6);
    }
    else
    {
      v3 = (const char *)Json::Value::CZString::c_str((Json::Value::CZString *)&v7);
      Json::Value::Value(v2, v3);
    }
  }
  else
  {
    v4 = Json::Value::CZString::index((Json::Value::CZString *)&v7);
    Json::Value::Value((int)v2, v4);
  }
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v7);
  return v2;
}

//----- (00053EF0) --------------------------------------------------------
int __fastcall Json::Value::Value(int result, bool a2)
{
  *(_BYTE *)result = a2;
  *(_BYTE *)(result + 8) = 5;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (00053EFC) --------------------------------------------------------
int __fastcall Json::Value::swap(int result, Json::Value *a2)
{
  char v2; // r3
  __int64 v3; // r4
  int v4; // r3

  v2 = *(_BYTE *)(result + 8);
  *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
  *((_BYTE *)a2 + 8) = v2;
  v3 = *(_QWORD *)result;
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_QWORD *)a2 = v3;
  v4 = *(unsigned __int8 *)(result + 9);
  *(_BYTE *)(result + 9) = v4 & 0xFE | (*((unsigned __int8 *)a2 + 9) << 31 >> 31) & 1;
  *((_BYTE *)a2 + 9) = *((_BYTE *)a2 + 9) & 0xFE | (v4 << 31 >> 31) & 1;
  return result;
}

//----- (00053F36) --------------------------------------------------------
int __fastcall Json::Value::type(Json::Value *this)
{
  return *((unsigned __int8 *)this + 8);
}

//----- (00053F3A) --------------------------------------------------------
int __fastcall Json::Value::compare(Json::Value *this, const Json::Value *a2)
{
  return 0;
}

//----- (00053F3E) --------------------------------------------------------
int __fastcall Json::Value::asCString(Json::Value *this)
{
  return *(_DWORD *)this;
}

//----- (00053F44) --------------------------------------------------------
Json::Value *__fastcall Json::Value::asString(Json::Value *this, int a2, int a3)
{
  Json::Value *v3; // r5
  char *v4; // r1
  _DWORD *v5; // r5
  Json::Value *result; // r0
  int v7; // [sp+4h] [bp-14h]
  int v8; // [sp+8h] [bp-10h]

  v7 = a2;
  v8 = a3;
  v3 = this;
  switch ( *(unsigned __int8 *)(a2 + 8) )
  {
    case 0u:
      v4 = &byte_E4496;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 6u:
    case 7u:
      v5 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v7, "Type is not convertible to string");
      sub_94FC4(v5, &v7);
      sub_C0AD8(&v7);
      _cxa_throw((int)v5, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
      return result;
    case 4u:
      v4 = *(char **)a2;
      if ( !v4 )
        v4 = &byte_E4496;
      break;
    case 5u:
      if ( *(_BYTE *)a2 )
        v4 = "true";
      else
        v4 = "false";
      break;
    default:
      v4 = &byte_E4496;
      break;
  }
  sub_C1C58((void **)this, v4);
  return v3;
}
// E4496: using guessed type char byte_E4496;
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (00053FF8) --------------------------------------------------------
unsigned int __fastcall Json::Value::asInt(Json::Value *this, int a2)
{
  unsigned int result; // r0
  _DWORD *v3; // r6
  double v4; // d7
  int v5; // [sp+4h] [bp-14h]

  v5 = a2;
  switch ( *((unsigned __int8 *)this + 8) )
  {
    case 1u:
      return *(_DWORD *)this;
    case 2u:
      result = *(_DWORD *)this;
      if ( result <= 0x7FFFFFFE )
        return result;
      v3 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v5, "integer out of signed integer range");
      sub_94FC4(v3, &v5);
      goto LABEL_11;
    case 3u:
      v4 = *(double *)this;
      if ( *(double *)this < -2147483650.0 || v4 > 2147483650.0 )
      {
        v3 = (_DWORD *)_cxa_allocate_exception(8);
        sub_C1C58((void **)&v5, "Real out of signed integer range");
        sub_94FC4(v3, &v5);
LABEL_11:
        sub_C0AD8(&v5);
        _cxa_throw((int)v3, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
      }
      result = (signed int)v4;
      break;
    case 4u:
    case 6u:
    case 7u:
      v3 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v5, "Type is not convertible to int");
      sub_94FC4(v3, &v5);
      goto LABEL_11;
    case 5u:
      result = *(unsigned __int8 *)this;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (00054110) --------------------------------------------------------
signed int __fastcall Json::Value::asUInt(Json::Value *this, int a2)
{
  signed int result; // r0
  _DWORD *v3; // r6
  double v4; // d7
  int v5; // [sp+4h] [bp-14h]

  v5 = a2;
  switch ( *((unsigned __int8 *)this + 8) )
  {
    case 1u:
      result = *(_DWORD *)this;
      if ( result >= 0 )
        return result;
      v3 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v5, "Negative integer can not be converted to unsigned integer");
      sub_94FC4(v3, &v5);
      goto LABEL_11;
    case 2u:
      return *(_DWORD *)this;
    case 3u:
      v4 = *(double *)this;
      if ( *(double *)this < 0.0 || v4 > 4294967300.0 )
      {
        v3 = (_DWORD *)_cxa_allocate_exception(8);
        sub_C1C58((void **)&v5, "Real out of unsigned integer range");
        sub_94FC4(v3, &v5);
LABEL_11:
        sub_C0AD8(&v5);
        _cxa_throw((int)v3, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
      }
      result = (unsigned int)v4;
      break;
    case 4u:
    case 6u:
    case 7u:
      v3 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v5, "Type is not convertible to uint");
      sub_94FC4(v3, &v5);
      goto LABEL_11;
    case 5u:
      result = *(unsigned __int8 *)this;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (00054218) --------------------------------------------------------
__int64 __fastcall Json::Value::asDouble(Json::Value *this, int a2, int a3)
{
  double v3; // d7
  _DWORD *v4; // r5
  __int64 result; // r0
  int v6; // [sp+4h] [bp-14h]
  int v7; // [sp+8h] [bp-10h]

  v6 = a2;
  v7 = a3;
  switch ( *((unsigned __int8 *)this + 8) )
  {
    case 1u:
      v3 = (double)*(signed int *)this;
      break;
    case 2u:
      v3 = (double)*(unsigned int *)this;
      break;
    case 3u:
      v3 = *(double *)this;
      break;
    case 4u:
    case 6u:
    case 7u:
      v4 = (_DWORD *)_cxa_allocate_exception(8);
      sub_C1C58((void **)&v6, "Type is not convertible to double");
      sub_94FC4(v4, &v6);
      sub_C0AD8(&v6);
      _cxa_throw((int)v4, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
      return result;
    case 5u:
      v3 = 1.0;
      if ( !*(_BYTE *)this )
        v3 = 0.0;
      break;
    default:
      v3 = 0.0;
      break;
  }
  return *(_QWORD *)&v3;
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (000542D0) --------------------------------------------------------
int __fastcall Json::Value::asBool(Json::Value *this)
{
  int v1; // r0
  int result; // r0

  switch ( *((unsigned __int8 *)this + 8) )
  {
    case 1u:
    case 2u:
      v1 = *(_DWORD *)this;
      goto LABEL_8;
    case 3u:
      return *(double *)this != 0.0;
    case 4u:
      result = *(_DWORD *)this;
      if ( !result )
        return result;
      v1 = *(unsigned __int8 *)result;
      goto LABEL_8;
    case 5u:
      result = *(unsigned __int8 *)this;
      break;
    case 6u:
    case 7u:
      v1 = *(_DWORD *)(*(_DWORD *)this + 20);
LABEL_8:
      result = v1 != 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00054318) --------------------------------------------------------
bool __fastcall Json::Value::isConvertibleTo(unsigned __int8 *a1, int a2)
{
  int v2; // r3
  bool v4; // cf
  bool v5; // zf
  int v6; // r0
  bool v7; // zf

  switch ( a1[8] )
  {
    case 0u:
      return 1;
    case 1u:
      if ( !a2 )
      {
        v2 = *(_DWORD *)a1;
        goto LABEL_32;
      }
      if ( a2 == 1 )
        return a2;
      if ( a2 != 2 )
        goto LABEL_27;
      if ( *(_DWORD *)a1 < 0 )
        return (unsigned int)(a2 - 5) <= 0;
      return 1;
    case 2u:
      if ( !a2 )
      {
        if ( !*(_DWORD *)a1 )
          return 1;
LABEL_15:
        v4 = (unsigned int)(a2 - 3) >= 1;
        v5 = a2 == 4;
        goto LABEL_35;
      }
      if ( a2 != 1 )
      {
        if ( a2 == 2 )
          return 1;
        goto LABEL_15;
      }
      if ( *(_DWORD *)a1 >= 0 )
        return a2;
      return (unsigned int)(a2 - 5) <= 0;
    case 3u:
      if ( !a2 )
      {
        if ( *(double *)a1 != 0.0 )
          return (unsigned int)(a2 - 5) <= 0;
        return 1;
      }
      if ( a2 == 1 )
      {
        if ( *(double *)a1 >= -2147483650.0 && *(double *)a1 <= 2147483650.0 )
          return a2;
        return (unsigned int)(a2 - 5) <= 0;
      }
      if ( a2 != 2 )
      {
LABEL_27:
        if ( a2 == 3 || a2 == 4 )
          return 1;
        return (unsigned int)(a2 - 5) <= 0;
      }
      if ( *(double *)a1 < 0.0 || *(double *)a1 > 4294967300.0 )
        return (unsigned int)(a2 - 5) <= 0;
      return 1;
    case 4u:
      if ( a2 == 4 )
        return 1;
      if ( a2 )
        return 0;
      if ( !*(_DWORD *)a1 )
        return 1;
      v6 = **(unsigned __int8 **)a1;
      return v6 == 0;
    case 5u:
      if ( a2 )
      {
        v4 = (unsigned int)(a2 - 1) >= 3;
        v5 = a2 == 4;
LABEL_35:
        if ( v5 || !v4 )
          return 1;
      }
      else
      {
        v2 = *a1;
LABEL_32:
        if ( !v2 )
          return 1;
      }
      return (unsigned int)(a2 - 5) <= 0;
    case 6u:
      v7 = a2 == 6;
      goto LABEL_43;
    case 7u:
      v7 = a2 == 7;
LABEL_43:
      if ( v7 )
        return 1;
      if ( a2 )
        return 0;
      v6 = *(_DWORD *)(*(_DWORD *)a1 + 20);
      return v6 == 0;
    default:
      return 0;
  }
}

//----- (00054428) --------------------------------------------------------
int __fastcall Json::Value::size(Json::Value *this)
{
  int v1; // r3
  int result; // r0
  int v3; // r3
  int v4; // r0

  v1 = *((unsigned __int8 *)this + 8);
  if ( v1 == 6 )
  {
    v3 = *(_DWORD *)this;
    result = *(_DWORD *)(*(_DWORD *)this + 20);
    if ( result )
    {
      v4 = sub_948FC(v3 + 4);
      result = Json::Value::CZString::index((Json::Value::CZString *)(v4 + 16)) + 1;
    }
  }
  else if ( v1 == 7 )
  {
    result = *(_DWORD *)(*(_DWORD *)this + 20);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 948FC: using guessed type int __fastcall sub_948FC(_DWORD);

//----- (00054454) --------------------------------------------------------
bool __fastcall Json::Value::isValidIndex(Json::Value *this, unsigned int a2)
{
  return a2 < Json::Value::size(this);
}

//----- (00054466) --------------------------------------------------------
bool __fastcall Json::Value::isNull(Json::Value *this)
{
  return *((_BYTE *)this + 8) == 0;
}

//----- (00054476) --------------------------------------------------------
bool __fastcall Json::Value::isBool(Json::Value *this)
{
  return (unsigned int)*((unsigned __int8 *)this + 8) - 5 <= 0;
}

//----- (00054480) --------------------------------------------------------
bool __fastcall Json::Value::isInt(Json::Value *this)
{
  return (unsigned int)*((unsigned __int8 *)this + 8) - 1 <= 0;
}

//----- (0005448A) --------------------------------------------------------
bool __fastcall Json::Value::isUInt(Json::Value *this)
{
  return (unsigned int)*((unsigned __int8 *)this + 8) - 2 <= 0;
}

//----- (00054494) --------------------------------------------------------
bool __fastcall Json::Value::isIntegral(Json::Value *this)
{
  int v1; // r0
  _BOOL4 result; // r0

  v1 = *((unsigned __int8 *)this + 8);
  if ( (unsigned int)(v1 - 1) <= 1 )
    result = 1;
  else
    result = (unsigned int)(v1 - 5) <= 0;
  return result;
}

//----- (000544A8) --------------------------------------------------------
bool __fastcall Json::Value::isDouble(Json::Value *this)
{
  return (unsigned int)*((unsigned __int8 *)this + 8) - 3 <= 0;
}

//----- (000544B2) --------------------------------------------------------
bool __fastcall Json::Value::isNumeric(Json::Value *this)
{
  Json::Value *v1; // r4
  _BOOL4 result; // r0

  v1 = this;
  if ( Json::Value::isIntegral(this) )
    result = 1;
  else
    result = Json::Value::isDouble(v1);
  return result;
}

//----- (000544CA) --------------------------------------------------------
bool __fastcall Json::Value::isString(Json::Value *this)
{
  return (unsigned int)*((unsigned __int8 *)this + 8) - 4 <= 0;
}

//----- (000544D4) --------------------------------------------------------
bool __fastcall Json::Value::isArray(Json::Value *this)
{
  int v1; // r0
  _BOOL4 result; // r0

  v1 = *((unsigned __int8 *)this + 8);
  if ( v1 )
    result = (unsigned int)(v1 - 6) <= 0;
  else
    result = 1;
  return result;
}

//----- (000544E4) --------------------------------------------------------
bool __fastcall Json::Value::isObject(Json::Value *this)
{
  int v1; // r0
  _BOOL4 result; // r0

  v1 = *((unsigned __int8 *)this + 8);
  if ( v1 )
    result = (unsigned int)(v1 - 7) <= 0;
  else
    result = 1;
  return result;
}

//----- (000544F4) --------------------------------------------------------
bool __fastcall Json::Value::empty(Json::Value *this)
{
  Json::Value *v1; // r4
  _BOOL4 result; // r0

  v1 = this;
  if ( Json::Value::isNull(this) || Json::Value::isArray(v1) || (result = Json::Value::isObject(v1)) != 0 )
    result = Json::Value::size(v1) == 0;
  return result;
}

//----- (0005451E) --------------------------------------------------------
int __fastcall Json::Value::setComment(int a1, const char *a2, int a3)
{
  int v3; // r6
  const char *v4; // r7
  int v5; // r8
  _DWORD *v6; // r0
  int v7; // r5
  _DWORD *v8; // r4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !*(_DWORD *)(a1 + 12) )
  {
    v6 = operator new[](0x14u);
    v7 = (int)(v6 + 2);
    v8 = v6;
    *v6 = 4;
    v6[1] = 3;
    Json::Value::CommentInfo::CommentInfo((int)(v6 + 2));
    Json::Value::CommentInfo::CommentInfo((int)(v8 + 3));
    Json::Value::CommentInfo::CommentInfo((int)(v8 + 4));
    *(_DWORD *)(v3 + 12) = v7;
  }
  return Json::Value::CommentInfo::setComment((Json::Value::CommentInfo *)(*(_DWORD *)(v3 + 12) + 4 * v5), v4, a3);
}

//----- (00054598) --------------------------------------------------------
int __fastcall Json::Value::setComment(int a1, const char **a2, int a3)
{
  return Json::Value::setComment(a1, *a2, a3);
}

//----- (0005459E) --------------------------------------------------------
int __fastcall Json::Value::hasComment(int a1, int a2)
{
  int result; // r0

  result = *(_DWORD *)(a1 + 12);
  if ( result )
    result = *(_DWORD *)(result + 4 * a2) != 0;
  return result;
}

//----- (000545B0) --------------------------------------------------------
void **__fastcall Json::Value::getComment(void **a1, int a2, int a3)
{
  void **v3; // r4
  int v4; // r5
  int v5; // r6
  void **v6; // r0
  char *v7; // r1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( Json::Value::hasComment(a2, a3) )
  {
    v6 = v3;
    v7 = *(char **)(*(_DWORD *)(v4 + 12) + 4 * v5);
  }
  else
  {
    v6 = v3;
    v7 = &byte_E4496;
  }
  sub_C1C58(v6, v7);
  return v3;
}
// E4496: using guessed type char byte_E4496;

//----- (000545E4) --------------------------------------------------------
Json::Value *__fastcall Json::Value::begin(Json::Value *this, unsigned __int8 *a2)
{
  Json::Value *v2; // r4
  unsigned __int8 *v4; // [sp+4h] [bp-Ch]

  v4 = a2;
  v2 = this;
  if ( (unsigned int)a2[8] - 6 <= 1 && *(_DWORD *)a2 )
  {
    v4 = *(unsigned __int8 **)(*(_DWORD *)a2 + 12);
    Json::ValueConstIterator::ValueConstIterator((int)this, &v4);
  }
  else
  {
    Json::ValueConstIterator::ValueConstIterator(this);
  }
  return v2;
}

//----- (0005460E) --------------------------------------------------------
Json::Value *__fastcall Json::Value::end(Json::Value *this, int a2)
{
  Json::Value *v2; // r4
  int v4; // [sp+4h] [bp-Ch]

  v4 = a2;
  v2 = this;
  if ( (unsigned int)*(unsigned __int8 *)(a2 + 8) - 6 <= 1 && *(_DWORD *)a2 )
  {
    v4 = *(_DWORD *)a2 + 4;
    Json::ValueConstIterator::ValueConstIterator((int)this, &v4);
  }
  else
  {
    Json::ValueConstIterator::ValueConstIterator(this);
  }
  return v2;
}

//----- (00054638) --------------------------------------------------------
Json::Value *__fastcall Json::Value::begin(Json::Value *this, unsigned __int8 *a2)
{
  Json::Value *v2; // r4
  unsigned __int8 *v4; // [sp+4h] [bp-Ch]

  v4 = a2;
  v2 = this;
  if ( (unsigned int)a2[8] - 6 <= 1 && *(_DWORD *)a2 )
  {
    v4 = *(unsigned __int8 **)(*(_DWORD *)a2 + 12);
    Json::ValueIterator::ValueIterator((int)this, &v4);
  }
  else
  {
    Json::ValueIterator::ValueIterator(this);
  }
  return v2;
}

//----- (00054662) --------------------------------------------------------
Json::Value *__fastcall Json::Value::end(Json::Value *this, int a2)
{
  Json::Value *v2; // r4
  int v4; // [sp+4h] [bp-Ch]

  v4 = a2;
  v2 = this;
  if ( (unsigned int)*(unsigned __int8 *)(a2 + 8) - 6 <= 1 && *(_DWORD *)a2 )
  {
    v4 = *(_DWORD *)a2 + 4;
    Json::ValueIterator::ValueIterator((int)this, &v4);
  }
  else
  {
    Json::ValueIterator::ValueIterator(this);
  }
  return v2;
}

//----- (0005468C) --------------------------------------------------------
int __fastcall Json::PathArgument::PathArgument(int result)
{
  *(_DWORD *)result = &unk_2FEF48;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

//----- (000546A0) --------------------------------------------------------
int __fastcall Json::PathArgument::PathArgument(int result, unsigned int a2)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)result = &unk_2FEF48;
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (000546B8) --------------------------------------------------------
Json::PathArgument *__fastcall Json::PathArgument::PathArgument(Json::PathArgument *this, const char *a2)
{
  Json::PathArgument *v2; // r4
  Json::PathArgument *result; // r0

  v2 = this;
  sub_C1C58((void **)this, (char *)a2);
  result = v2;
  *((_DWORD *)v2 + 2) = 2;
  return result;
}

//----- (000546CC) --------------------------------------------------------
void **__fastcall Json::PathArgument::PathArgument(void **a1, char **a2)
{
  void **v2; // r4
  void **result; // r0

  v2 = a1;
  sub_C1C58(a1, *a2);
  result = v2;
  v2[2] = &dword_0 + 2;
  return result;
}
// 0: using guessed type int dword_0;

//----- (000546E4) --------------------------------------------------------
int *__fastcall std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++(int *a1)
{
  int *v1; // r4

  v1 = a1;
  *a1 = sub_948C0(*a1);
  return v1;
}

//----- (000546F4) --------------------------------------------------------
bool __fastcall Json::Value::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // r3
  const char *v3; // r0
  const char *v4; // r3
  const char *v6; // r0
  const char *v7; // r1
  const char *v8; // r3
  int v9; // r8
  int v10; // r3
  int v11; // r4
  int v12; // r5
  unsigned __int8 *v13; // [sp+0h] [bp-20h]
  unsigned __int8 *v14; // [sp+4h] [bp-1Ch]

  v13 = a1;
  v14 = a2;
  v2 = a2[8];
  if ( v2 != a1[8] )
    return 0;
  switch ( v2 )
  {
    case 0:
      return 1;
    case 1:
    case 2:
      v3 = *(const char **)a1;
      v4 = *(const char **)a2;
      return (unsigned int)(v3 - v4) <= 0;
    case 3:
      return *(double *)a1 == *(double *)a2;
    case 4:
      v6 = *(const char **)a1;
      v7 = *(const char **)a2;
      if ( v6 != v7 && (!v7 || !v6 || strcmp(v6, v7)) )
        return 0;
      return 1;
    case 5:
      v3 = (const char *)*a1;
      v4 = (const char *)*a2;
      return (unsigned int)(v3 - v4) <= 0;
    case 6:
    case 7:
      v8 = *(const char **)a1;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 20) != *(_DWORD *)(*(_DWORD *)a2 + 20) )
        return 0;
      v9 = (int)(v8 + 4);
      v10 = *((_DWORD *)v8 + 3);
      v14 = *(unsigned __int8 **)(*(_DWORD *)a2 + 12);
      v13 = (unsigned __int8 *)v10;
      break;
    default:
      return 0;
  }
  while ( 1 )
  {
    v11 = (int)v13;
    if ( v13 == (unsigned __int8 *)v9 )
      break;
    v12 = (int)v14;
    if ( !Json::Value::CZString::operator==((const char **)v13 + 4, (int)(v14 + 16))
      || !Json::Value::operator==(v11 + 24, v12 + 24) )
    {
      return 0;
    }
    std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++((int *)&v13);
    std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++((int *)&v14);
  }
  return 1;
}

//----- (000547A8) --------------------------------------------------------
bool __fastcall Json::Value::operator!=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return !Json::Value::operator==(a1, a2);
}

//----- (000547B6) --------------------------------------------------------
void __fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase(int a1, _DWORD *a2)
{
  int v2; // r5
  _DWORD *i; // r4
  _DWORD *v4; // r6

  v2 = a1;
  for ( i = a2; i; i = v4 )
  {
    std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase(
      v2,
      i[3]);
    v4 = (_DWORD *)i[2];
    std::pair<Json::Value::CZString const,Json::Value>::~pair((int)(i + 4));
    operator delete(i);
  }
}

//----- (000547DC) --------------------------------------------------------
void __fastcall Json::Value::clear(Json::Value *this)
{
  int v1; // r4

  if ( (unsigned int)*((unsigned __int8 *)this + 8) - 6 <= 1 )
  {
    v1 = *(_DWORD *)this;
    std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase(
      v1,
      *(_DWORD **)(v1 + 8));
    *(_DWORD *)(v1 + 12) = v1 + 4;
    *(_DWORD *)(v1 + 8) = 0;
    *(_DWORD *)(v1 + 16) = v1 + 4;
    *(_DWORD *)(v1 + 20) = 0;
  }
}

//----- (000547FE) --------------------------------------------------------
Json::Value *__fastcall Json::Value::~Value(Json::Value *this)
{
  Json::Value *v1; // r4
  unsigned int v2; // r3
  int **v3; // r0
  int v4; // r1
  _DWORD **v5; // r5
  int v6; // r3
  Json::Value::CommentInfo *i; // r5
  Json::Value::CommentInfo *v8; // r0

  v1 = this;
  v2 = *((unsigned __int8 *)this + 8);
  if ( v2 == 4 )
  {
    if ( *((_BYTE *)this + 9) & 1 )
    {
      v3 = sub_539CC();
      v4 = *(_DWORD *)v1;
      (*(void (**)(void))(**v3 + 20))();
    }
  }
  else if ( v2 >= 4 && v2 - 6 <= 1 )
  {
    v5 = *(_DWORD ***)this;
    if ( *(_DWORD *)this )
    {
      std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase(
        *(_DWORD *)this,
        v5[2]);
      operator delete(v5);
    }
  }
  v6 = *((_DWORD *)v1 + 3);
  if ( v6 )
  {
    for ( i = (Json::Value::CommentInfo *)(v6 + 4 * *(_DWORD *)(v6 - 4)); ; Json::Value::CommentInfo::~CommentInfo(i) )
    {
      v8 = i;
      i = (Json::Value::CommentInfo *)((char *)i - 4);
      if ( v8 == *((Json::Value::CommentInfo **)v1 + 3) )
        break;
    }
    operator delete[]((char *)v8 - 8);
  }
  return v1;
}

//----- (00054862) --------------------------------------------------------
Json::Value::CZString *__fastcall std::pair<Json::Value::CZString const,Json::Value>::~pair(int a1)
{
  Json::Value::CZString *v1; // r4

  v1 = (Json::Value::CZString *)a1;
  Json::Value::~Value((Json::Value *)(a1 + 8));
  Json::Value::CZString::~CZString(v1);
  return v1;
}

//----- (00054880) --------------------------------------------------------
int __fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::find(int a1, int a2)
{
  int v2; // r4
  const char **v3; // r6
  int v4; // r5
  int result; // r0

  v2 = a1 + 4;
  v3 = (const char **)a2;
  v4 = sub_53CB8(*(_DWORD *)(a1 + 8), a1 + 4, a2);
  if ( v4 == v2 || Json::Value::CZString::operator<(v3, v4 + 16) )
    result = v2;
  else
    result = v4;
  return result;
}

//----- (000548AC) --------------------------------------------------------
void *__fastcall Json::Value::operator[](int a1, int a2)
{
  int *v2; // r6
  int v3; // r0
  void *v4; // r4
  int v6; // [sp+0h] [bp-18h]
  int v7; // [sp+4h] [bp-14h]

  v6 = a1;
  v7 = a2;
  v2 = (int *)a1;
  if ( !*(_BYTE *)(a1 + 8) )
    return &Json::Value::null;
  Json::Value::CZString::CZString((int)&v6, a2);
  v3 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::find(
         *v2,
         (int)&v6);
  if ( v3 == *v2 + 4 )
    v4 = &Json::Value::null;
  else
    v4 = (void *)(v3 + 24);
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v6);
  return v4;
}

//----- (00054900) --------------------------------------------------------
void *__fastcall Json::Value::operator[](int a1, int a2)
{
  int *v2; // r6
  int v3; // r0
  void *v4; // r4
  int v6; // [sp+0h] [bp-18h]
  int v7; // [sp+4h] [bp-14h]

  v6 = a1;
  v7 = a2;
  v2 = (int *)a1;
  if ( !*(_BYTE *)(a1 + 8) )
    return &Json::Value::null;
  Json::Value::CZString::CZString(&v6, a2, 0);
  v3 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::find(
         *v2,
         (int)&v6);
  if ( v3 == *v2 + 4 )
    v4 = &Json::Value::null;
  else
    v4 = (void *)(v3 + 24);
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v6);
  return v4;
}

//----- (00054954) --------------------------------------------------------
void *__fastcall Json::Value::operator[](int a1, int *a2)
{
  return Json::Value::operator[](a1, *a2);
}

//----- (0005495A) --------------------------------------------------------
Json::Value *__fastcall Json::Path::resolve(Json::Path *this, const Json::Value *a2)
{
  Json::Path *v2; // r6
  int *v3; // r5
  Json::Value *v4; // r4
  int v5; // r3
  Json::Value *v6; // r0

  v2 = this;
  v3 = *(int **)this;
  v4 = a2;
  while ( v3 != *((int **)v2 + 1) )
  {
    v5 = v3[2];
    if ( v5 == 1 )
    {
      if ( Json::Value::isArray(v4) )
        Json::Value::isValidIndex(v4, v3[1]);
      v6 = (Json::Value *)Json::Value::operator[]((int)v4, v3[1]);
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_10;
      Json::Value::isObject(v4);
      v6 = (Json::Value *)Json::Value::operator[]((int)v4, v3);
    }
    v4 = v6;
LABEL_10:
    v3 += 3;
  }
  return v4;
}

//----- (000549A4) --------------------------------------------------------
bool __fastcall Json::Value::isMember(Json::Value *this, const char *a2)
{
  return &Json::Value::null != Json::Value::operator[]((int)this, (int)a2);
}

//----- (000549BC) --------------------------------------------------------
bool __fastcall Json::Value::isMember(Json::Value *a1, const char **a2)
{
  return Json::Value::isMember(a1, *a2);
}

//----- (000549C2) --------------------------------------------------------
char *__fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_copy(int a1, int *a2, int a3)
{
  int v3; // r7
  int *v4; // r5
  int v5; // r6
  char *v6; // r0
  int v7; // r3
  char *v8; // r4
  int *v9; // r6
  char *v10; // r8
  char *v11; // r0
  int v12; // r3
  char *v13; // r5

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = sub_54CA8((int)(a2 + 4));
  v7 = *v4;
  *((_DWORD *)v6 + 1) = v5;
  v8 = v6;
  *(_DWORD *)v6 = v7;
  *((_DWORD *)v6 + 2) = 0;
  *((_DWORD *)v6 + 3) = 0;
  if ( v4[3] )
    *((_DWORD *)v6 + 3) = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_copy(v3);
  v9 = (int *)v4[2];
  v10 = v8;
  while ( v9 )
  {
    v11 = sub_54CA8((int)(v9 + 4));
    v12 = *v9;
    v13 = v11;
    *((_DWORD *)v11 + 2) = 0;
    *((_DWORD *)v11 + 3) = 0;
    *(_DWORD *)v11 = v12;
    *((_DWORD *)v10 + 2) = v11;
    *((_DWORD *)v11 + 1) = v10;
    if ( v9[3] )
      *((_DWORD *)v11 + 3) = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_copy(v3);
    v9 = (int *)v9[2];
    v10 = v13;
  }
  return v8;
}

//----- (00054A4A) --------------------------------------------------------
Json::Value *__fastcall Json::Value::Value(Json::Value *this, const Json::Value *a2)
{
  unsigned int v2; // r3
  Json::Value *v3; // r4
  const Json::Value *v4; // r6
  signed int v5; // r3
  int **v6; // r0
  int v7; // r1
  int v8; // r0
  _DWORD *v9; // r0
  int v10; // r8
  int v11; // r7
  _DWORD *v12; // r5
  int *v13; // r1
  char *v14; // r0
  char *v15; // r3
  _DWORD *v16; // r0
  int v17; // r7
  _DWORD *v18; // r5
  int v19; // r2
  int v20; // r5
  const char *v21; // r1

  v2 = *((unsigned __int8 *)a2 + 8);
  v3 = this;
  v4 = a2;
  *((_DWORD *)this + 3) = 0;
  *((_BYTE *)this + 8) = v2;
  if ( v2 <= 7 )
  {
    v5 = 1 << v2;
    if ( v5 & 0x2F )
    {
      *(_QWORD *)this = *(_QWORD *)a2;
    }
    else if ( v5 & 0xC0 )
    {
      v9 = operator new(0x18u);
      v10 = *(_DWORD *)v4;
      v11 = (int)(v9 + 1);
      v12 = v9;
      memset(v9 + 1, 0, 0x10u);
      v12[5] = 0;
      v12[3] = v11;
      v12[4] = v11;
      v13 = *(int **)(v10 + 8);
      if ( v13 )
      {
        v14 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_copy(
                (int)v12,
                v13,
                v11);
        v15 = v14;
        v12[2] = v14;
        while ( *((_DWORD *)v15 + 2) )
          v15 = (char *)*((_DWORD *)v15 + 2);
        v12[3] = v15;
        while ( *((_DWORD *)v14 + 3) )
          v14 = (char *)*((_DWORD *)v14 + 3);
        v12[4] = v14;
        v12[5] = *(_DWORD *)(v10 + 20);
      }
      *(_DWORD *)v3 = v12;
    }
    else if ( v5 & 0x10 )
    {
      if ( *(_DWORD *)a2 )
      {
        v6 = sub_539CC();
        v7 = *(_DWORD *)v4;
        v8 = (*(int (**)(void))(**v6 + 16))();
        *((_BYTE *)v3 + 9) |= 1u;
        *(_DWORD *)v3 = v8;
      }
      else
      {
        *(_DWORD *)this = 0;
      }
    }
  }
  if ( *((_DWORD *)v4 + 3) )
  {
    v16 = operator new[](0x14u);
    v17 = (int)(v16 + 2);
    v18 = v16;
    *v16 = 4;
    v16[1] = 3;
    Json::Value::CommentInfo::CommentInfo((int)(v16 + 2));
    Json::Value::CommentInfo::CommentInfo((int)(v18 + 3));
    Json::Value::CommentInfo::CommentInfo((int)(v18 + 4));
    v20 = 0;
    *((_DWORD *)v3 + 3) = v17;
    do
    {
      v21 = *(const char **)(*((_DWORD *)v4 + 3) + v20);
      if ( v21 )
        Json::Value::CommentInfo::setComment((Json::Value::CommentInfo *)(*((_DWORD *)v3 + 3) + v20), v21, v19);
      v20 += 4;
    }
    while ( v20 != 12 );
  }
  return v3;
}

//----- (00054B7C) --------------------------------------------------------
int __fastcall Json::Value::operator=(int a1, const Json::Value *a2)
{
  int v2; // r5
  int v4; // [sp+0h] [bp-20h]

  v2 = a1;
  Json::Value::Value((Json::Value *)&v4, a2);
  Json::Value::swap(v2, (Json::Value *)&v4);
  Json::Value::~Value((Json::Value *)&v4);
  return v2;
}

//----- (00054BA6) --------------------------------------------------------
Json::Value::CZString *__fastcall std::pair<Json::Value::CZString const,Json::Value>::pair(Json::Value::CZString *a1, const Json::Value::CZString *a2, const Json::Value *a3)
{
  const Json::Value *v3; // r5
  Json::Value::CZString *v4; // r4

  v3 = a3;
  v4 = a1;
  Json::Value::CZString::CZString(a1, a2);
  Json::Value::Value((Json::Value::CZString *)((char *)v4 + 8), v3);
  return v4;
}

//----- (00054BC8) --------------------------------------------------------
Json::Value *__fastcall Json::Value::get(Json::Value *this, unsigned int a2, const Json::Value *a3, const Json::Value *a4)
{
  Json::Value *v4; // r4
  const Json::Value *v5; // r5
  const Json::Value *v6; // r0
  const Json::Value *v7; // r1

  v4 = this;
  v5 = a4;
  v6 = (const Json::Value *)Json::Value::operator[](a2, (int)a3);
  if ( &Json::Value::null == (_UNKNOWN *)v6 )
    v7 = v5;
  else
    v7 = v6;
  Json::Value::Value(v4, v7);
  return v4;
}

//----- (00054BF4) --------------------------------------------------------
Json::Value *__fastcall Json::Value::get(Json::Value *this, const char *a2, const Json::Value *a3, const Json::Value *a4)
{
  Json::Value *v4; // r4
  const Json::Value *v5; // r5
  const Json::Value *v6; // r0
  const Json::Value *v7; // r1

  v4 = this;
  v5 = a4;
  v6 = (const Json::Value *)Json::Value::operator[]((int)a2, (int)a3);
  if ( &Json::Value::null == (_UNKNOWN *)v6 )
    v7 = v5;
  else
    v7 = v6;
  Json::Value::Value(v4, v7);
  return v4;
}

//----- (00054C20) --------------------------------------------------------
Json::Value *__fastcall Json::Value::get(Json::Value *a1, const char *a2, const Json::Value **a3, const Json::Value *a4)
{
  Json::Value *v4; // r4

  v4 = a1;
  Json::Value::get(a1, a2, *a3, a4);
  return v4;
}

//----- (00054C30) --------------------------------------------------------
Json::Path *__fastcall Json::Path::resolve(Json::Path *this, const Json::Value *a2, const Json::Value *a3, const Json::Value *a4)
{
  Json::Path *v4; // r6
  int *v5; // r5
  const Json::Value *v6; // r7
  const Json::Value *v7; // r8
  Json::Value *v8; // r4
  int v9; // r2
  Json::Value *v10; // r0
  const Json::Value *v11; // r1

  v4 = this;
  v5 = *(int **)a2;
  v6 = a2;
  v7 = a4;
  v8 = a3;
  while ( v5 != *((int **)v6 + 1) )
  {
    v9 = v5[2];
    if ( v9 == 1 )
    {
      if ( !Json::Value::isArray(v8) || Json::Value::isValidIndex(v8, v5[1]) )
        goto LABEL_9;
      v8 = (Json::Value *)Json::Value::operator[]((int)v8, v5[1]);
    }
    else if ( v9 == 2 )
    {
      if ( !Json::Value::isObject(v8)
        || (v8 = (Json::Value *)Json::Value::operator[]((int)v8, v5), v8 == (Json::Value *)&Json::Value::null) )
      {
LABEL_9:
        v10 = v4;
        v11 = v7;
        goto LABEL_13;
      }
    }
    v5 += 3;
  }
  v10 = v4;
  v11 = v8;
LABEL_13:
  Json::Value::Value(v10, v11);
  return v4;
}

//----- (00054CA8) --------------------------------------------------------
char *__fastcall sub_54CA8(int a1)
{
  int v1; // r6
  char *v2; // r0
  char *v3; // r4

  v1 = a1;
  v2 = (char *)operator new(0x28u);
  v3 = v2;
  if ( v2 != (char *)-16 )
  {
    Json::Value::CZString::CZString((Json::Value::CZString *)(v2 + 16), (const Json::Value::CZString *)v1);
    Json::Value::Value((Json::Value *)(v3 + 24), (const Json::Value *)(v1 + 8));
  }
  return v3;
}

//----- (00054CF6) --------------------------------------------------------
void __fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase_aux(int a1, int *a2)
{
  int v2; // r4
  int *v3; // r5

  v2 = a1;
  v3 = sub_949D8(a2, (_DWORD *)(a1 + 4));
  std::pair<Json::Value::CZString const,Json::Value>::~pair((int)(v3 + 4));
  operator delete(v3);
  --*(_DWORD *)(v2 + 20);
}

//----- (00054D18) --------------------------------------------------------
Json::Value *__fastcall Json::Value::removeMember(Json::Value *this, const char *a2, int a3)
{
  Json::Value *v3; // r7
  int *v4; // r6
  int v5; // r0
  int *v6; // r8
  int v8; // [sp+0h] [bp-30h]
  char v9; // [sp+8h] [bp-28h]

  v3 = this;
  v4 = (int *)a2;
  if ( a2[8] )
  {
    Json::Value::CZString::CZString(&v8, a3, 0);
    v5 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::find(
           *v4,
           (int)&v8);
    v6 = (int *)v5;
    if ( v5 == *v4 + 4 )
    {
      Json::Value::Value(v3, (const Json::Value *)&Json::Value::null);
    }
    else
    {
      Json::Value::Value((Json::Value *)&v9, (const Json::Value *)(v5 + 24));
      std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase_aux(
        *v4,
        v6);
      Json::Value::Value(v3, (const Json::Value *)&v9);
      Json::Value::~Value((Json::Value *)&v9);
    }
    Json::Value::CZString::~CZString((Json::Value::CZString *)&v8);
  }
  else
  {
    Json::Value::Value(this, (const Json::Value *)&Json::Value::null);
  }
  return v3;
}

//----- (00054DA8) --------------------------------------------------------
Json::Value *__fastcall Json::Value::removeMember(Json::Value *a1, const char *a2, int *a3)
{
  Json::Value *v3; // r4

  v3 = a1;
  Json::Value::removeMember(a1, a2, *a3);
  return v3;
}

//----- (00054DB6) --------------------------------------------------------
_DWORD *__fastcall std::_Destroy_aux<false>::__destroy<std::string *>(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r0

  v2 = result;
  v3 = a2;
  while ( v2 != v3 )
  {
    v4 = v2;
    ++v2;
    result = sub_C0AD8(v4);
  }
  return result;
}

//----- (00054DCC) --------------------------------------------------------
void **__fastcall std::vector<std::string,std::allocator<std::string>>::~vector(void **a1)
{
  void **v1; // r4

  v1 = a1;
  std::_Destroy_aux<false>::__destroy<std::string *>(*a1, a1[1]);
  sub_53A1C(*v1);
  return v1;
}

//----- (00054DE0) --------------------------------------------------------
Json::StyledWriter *__fastcall Json::StyledWriter::~StyledWriter(Json::StyledWriter *this)
{
  Json::StyledWriter *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F02D0;
  sub_C0AD8((_DWORD *)this + 5);
  sub_C0AD8((_DWORD *)v1 + 4);
  std::vector<std::string,std::allocator<std::string>>::~vector((void **)v1 + 1);
  Json::Writer::~Writer((int)v1);
  return v1;
}
// F02D0: using guessed type void *off_F02D0;

//----- (00054E10) --------------------------------------------------------
Json::StyledWriter *__fastcall Json::StyledWriter::~StyledWriter(Json::StyledWriter *this)
{
  Json::StyledWriter *v1; // r4

  v1 = this;
  Json::StyledWriter::~StyledWriter(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00054E22) --------------------------------------------------------
Json::Value *__fastcall Json::Value::toStyledString(Json::Value *this, const Json::Value *a2)
{
  const Json::Value *v2; // r6
  Json::Value *v3; // r5
  char v5; // [sp+4h] [bp-34h]

  v2 = a2;
  v3 = this;
  Json::StyledWriter::StyledWriter((int)&v5);
  Json::StyledWriter::write(v3, (const Json::Value *)&v5, v2);
  Json::StyledWriter::~StyledWriter((Json::StyledWriter *)&v5);
  return v3;
}

//----- (00054E52) --------------------------------------------------------
_DWORD *__fastcall std::vector<std::string,std::allocator<std::string>>::vector(_DWORD *a1, int **a2)
{
  _DWORD *v2; // r4
  int **v3; // r5
  int v4; // r7
  unsigned int v5; // r7
  _DWORD *v6; // r6
  int *v7; // r7
  int *v8; // r8
  _DWORD *v9; // r5

  v2 = a1;
  v3 = a2;
  v4 = (char *)a2[1] - (char *)*a2;
  *a1 = 0;
  v5 = v4 >> 2;
  a1[1] = 0;
  a1[2] = 0;
  if ( v5 )
    v6 = sub_53A24(v5);
  else
    v6 = 0;
  *v2 = v6;
  v2[1] = v6;
  v2[2] = &v6[v5];
  v7 = *v3;
  v8 = v3[1];
  v9 = v6;
  while ( v7 != v8 )
  {
    if ( v9 )
      sub_C16AC(v9, v7);
    ++v9;
    ++v7;
  }
  v2[1] = v9;
  return v2;
}

//----- (00054EC2) --------------------------------------------------------
int *__fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_get_insert_unique_pos(int *a1, int a2, const char **a3)
{
  int v3; // r4
  int v4; // r6
  int *v5; // r5
  int v6; // r7
  const char **v7; // r8
  unsigned int v8; // r0
  int v9; // r3
  int v10; // r9

  v3 = a2 + 4;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = 1;
  while ( v4 )
  {
    v8 = Json::Value::CZString::operator<(v7, v4 + 16);
    if ( v8 )
      v9 = *(_DWORD *)(v4 + 8);
    else
      v9 = *(_DWORD *)(v4 + 12);
    v3 = v4;
    v4 = v9;
  }
  v10 = v3;
  if ( v8 )
  {
    if ( v3 == *(_DWORD *)(v6 + 12) )
    {
      *v5 = 0;
      v5[1] = v3;
      return v5;
    }
    v3 = sub_948F8(v3);
  }
  if ( Json::Value::CZString::operator<((const char **)(v3 + 16), (int)v7) )
  {
    *v5 = 0;
    v5[1] = v10;
  }
  else
  {
    *v5 = v3;
    v5[1] = 0;
  }
  return v5;
}
// 948F8: using guessed type int __fastcall sub_948F8(_DWORD);

//----- (00054F22) --------------------------------------------------------
int *__fastcall std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_insert_unique_(int a1, int a2, const char **a3)
{
  _DWORD *v3; // r9
  _DWORD *v4; // r6
  int v5; // r10
  const char **v6; // r7
  int *v7; // r4
  const char **v8; // r8
  int v9; // r5
  int v10; // r8
  int v11; // r8
  int *v13; // [sp+0h] [bp-28h]
  int *v14; // [sp+4h] [bp-24h]

  v13 = (int *)a1;
  v14 = (int *)a2;
  v3 = (_DWORD *)(a1 + 4);
  v4 = (_DWORD *)a1;
  v5 = a2;
  v6 = a3;
  v7 = (int *)a2;
  if ( a2 == a1 + 4 )
  {
    if ( *(_DWORD *)(a1 + 20) && Json::Value::CZString::operator<((const char **)(*(_DWORD *)(a1 + 16) + 16), (int)a3) )
    {
      v9 = v4[4];
      if ( !v9 )
        return 0;
LABEL_25:
      if ( (_DWORD *)v9 != v3 )
      {
        v11 = Json::Value::CZString::operator<(v6, v9 + 16);
LABEL_28:
        v7 = (int *)sub_54CA8((int)v6);
        sub_94908(v11, v7, (_DWORD *)v9, v3);
        ++v4[5];
        return v7;
      }
LABEL_27:
      v11 = 1;
      goto LABEL_28;
    }
LABEL_32:
    std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_get_insert_unique_pos(
      (int *)&v13,
      (int)v4,
      v6);
    v7 = v13;
    v9 = (int)v14;
    goto LABEL_23;
  }
  v8 = (const char **)(a2 + 16);
  if ( Json::Value::CZString::operator<(a3, a2 + 16) )
  {
    if ( v5 == v4[3] )
    {
      v9 = v5;
      goto LABEL_23;
    }
    v9 = sub_948F8(v5);
    if ( !Json::Value::CZString::operator<((const char **)(v9 + 16), (int)v6) )
      goto LABEL_32;
    if ( *(_DWORD *)(v9 + 12) )
      v9 = v5;
    else
      v7 = 0;
  }
  else
  {
    if ( !Json::Value::CZString::operator<(v8, (int)v6) )
      return v7;
    if ( v5 == v4[4] )
    {
      v10 = 0;
    }
    else
    {
      v10 = sub_94888(v5);
      if ( Json::Value::CZString::operator<(v6, v10 + 16) )
      {
        if ( v7[3] )
          v7 = (int *)v10;
        else
          v10 = 0;
      }
      else
      {
        std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_get_insert_unique_pos(
          (int *)&v13,
          (int)v4,
          v6);
        v10 = (int)v13;
        v7 = v14;
      }
    }
    v9 = (int)v7;
    v7 = (int *)v10;
  }
LABEL_23:
  if ( v9 )
  {
    if ( v7 )
      goto LABEL_27;
    goto LABEL_25;
  }
  return v7;
}
// 948F8: using guessed type int __fastcall sub_948F8(_DWORD);

//----- (0005502C) --------------------------------------------------------
int *__fastcall Json::Value::operator[](int a1, int a2)
{
  int *v2; // r5
  int v3; // r6
  int v4; // r0
  int v5; // r6
  int *v6; // r6
  int v8; // [sp+0h] [bp-38h]
  char v9; // [sp+8h] [bp-30h]

  v2 = (int *)a1;
  v3 = a2;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    Json::Value::Value((int)&v9, 6);
    Json::Value::operator=((int)v2, (const Json::Value *)&v9);
    Json::Value::~Value((Json::Value *)&v9);
  }
  Json::Value::CZString::CZString((int)&v8, v3);
  v4 = sub_53CB8(*(_DWORD *)(*v2 + 8), *v2 + 4, (int)&v8);
  v5 = v4;
  if ( v4 != *v2 + 4 && Json::Value::CZString::operator==((const char **)(v4 + 16), (int)&v8) )
  {
    v6 = (int *)(v5 + 24);
  }
  else
  {
    std::pair<Json::Value::CZString const,Json::Value>::pair(
      (Json::Value::CZString *)&v9,
      (const Json::Value::CZString *)&v8,
      (const Json::Value *)&Json::Value::null);
    v6 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_insert_unique_(
           *v2,
           v5,
           (const char **)&v9)
       + 6;
    std::pair<Json::Value::CZString const,Json::Value>::~pair((int)&v9);
  }
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v8);
  return v6;
}

//----- (000550CC) --------------------------------------------------------
void __fastcall Json::Value::resize(Json::Value *this, unsigned int a2)
{
  Json::Value *v2; // r10
  unsigned int v3; // r7
  unsigned int v4; // r0
  unsigned int v5; // r11
  int v6; // r9
  int *v7; // r5
  _DWORD *v8; // r4
  int v9; // r5
  int v10; // r6
  int v11; // r3
  int v12; // r3
  int v13; // r9
  char v14; // [sp+8h] [bp-38h]

  v2 = this;
  v3 = a2;
  if ( !*((_BYTE *)this + 8) )
  {
    Json::Value::Value((int)&v14, 6);
    Json::Value::operator=((int)v2, (const Json::Value *)&v14);
    Json::Value::~Value((Json::Value *)&v14);
  }
  v4 = Json::Value::size(v2);
  v5 = v4;
  if ( !v3 )
  {
    Json::Value::clear(v2);
    return;
  }
  if ( v3 <= v4 )
  {
LABEL_13:
    if ( v3 == v5 )
      return;
    v8 = *(_DWORD **)v2;
    Json::Value::CZString::CZString((int)&v14, v3);
    v9 = v8[2];
    v10 = (int)(v8 + 1);
    while ( 1 )
    {
      if ( !v9 )
      {
        v7 = (int *)v10;
        goto LABEL_9;
      }
      if ( Json::Value::CZString::operator<((const char **)(v9 + 16), (int)&v14) )
      {
        v11 = *(_DWORD *)(v9 + 12);
        v9 = v10;
      }
      else
      {
        if ( !Json::Value::CZString::operator<((const char **)&v14, v9 + 16) )
        {
          v6 = *(_DWORD *)(v9 + 12);
          v7 = (int *)sub_53CB8(*(_DWORD *)(v9 + 8), v9, (int)&v14);
          while ( v6 )
          {
            if ( Json::Value::CZString::operator<((const char **)&v14, v6 + 16) )
            {
              v12 = *(_DWORD *)(v6 + 8);
            }
            else
            {
              v12 = *(_DWORD *)(v6 + 12);
              v6 = v10;
            }
            v10 = v6;
            v6 = v12;
          }
LABEL_9:
          if ( v7 != (int *)v8[3] || (_DWORD *)v10 != v8 + 1 )
          {
            while ( v7 != (int *)v10 )
            {
              v13 = sub_948C0((int)v7);
              std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase_aux(
                (int)v8,
                v7);
              v7 = (int *)v13;
            }
          }
          else
          {
            std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_erase(
              (int)v8,
              (_DWORD *)v8[2]);
            v8[3] = v10;
            v8[2] = 0;
            v8[4] = v10;
            v8[5] = 0;
          }
          ++v3;
          Json::Value::CZString::~CZString((Json::Value::CZString *)&v14);
          goto LABEL_13;
        }
        v11 = *(_DWORD *)(v9 + 8);
      }
      v10 = v9;
      v9 = v11;
    }
  }
  Json::Value::operator[]((int)v2, v3 - 1);
}

//----- (000551EA) --------------------------------------------------------
int __fastcall Json::Value::append(Json::Value *this, const Json::Value *a2)
{
  const Json::Value *v2; // r4
  Json::Value *v3; // r5
  int v4; // r0
  int *v5; // r0

  v2 = a2;
  v3 = this;
  v4 = Json::Value::size(this);
  v5 = Json::Value::operator[]((int)v3, v4);
  return Json::Value::operator=((int)v5, v2);
}

//----- (00055208) --------------------------------------------------------
int *__fastcall Json::Value::resolveReference(Json::Value *this, const char *a2, int a3)
{
  int *v3; // r5
  const char *v4; // r7
  int v5; // r6
  int v6; // r2
  int v7; // r0
  int v8; // r6
  int *v9; // r6
  int v11; // [sp+0h] [bp-38h]
  char v12; // [sp+8h] [bp-30h]

  v3 = (int *)this;
  v4 = a2;
  v5 = a3;
  if ( !*((_BYTE *)this + 8) )
  {
    Json::Value::Value((int)&v12, 7);
    Json::Value::operator=((int)v3, (const Json::Value *)&v12);
    Json::Value::~Value((Json::Value *)&v12);
  }
  if ( v5 )
    v6 = 0;
  else
    v6 = 2;
  Json::Value::CZString::CZString(&v11, (int)v4, v6);
  v7 = sub_53CB8(*(_DWORD *)(*v3 + 8), *v3 + 4, (int)&v11);
  v8 = v7;
  if ( v7 != *v3 + 4 && Json::Value::CZString::operator==((const char **)(v7 + 16), (int)&v11) )
  {
    v9 = (int *)(v8 + 24);
  }
  else
  {
    std::pair<Json::Value::CZString const,Json::Value>::pair(
      (Json::Value::CZString *)&v12,
      (const Json::Value::CZString *)&v11,
      (const Json::Value *)&Json::Value::null);
    v9 = std::_Rb_tree<Json::Value::CZString,std::pair<Json::Value::CZString const,Json::Value>,std::_Select1st<std::pair<Json::Value::CZString const,Json::Value>>,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const,Json::Value>>>::_M_insert_unique_(
           *v3,
           v8,
           (const char **)&v12)
       + 6;
    std::pair<Json::Value::CZString const,Json::Value>::~pair((int)&v12);
  }
  Json::Value::CZString::~CZString((Json::Value::CZString *)&v11);
  return v9;
}

//----- (000552B4) --------------------------------------------------------
int *__fastcall Json::Value::operator[](Json::Value *a1, const char *a2)
{
  return Json::Value::resolveReference(a1, a2, 0);
}

//----- (000552BA) --------------------------------------------------------
int *__fastcall Json::Value::operator[](Json::Value *a1, const char **a2)
{
  return Json::Value::operator[](a1, *a2);
}

//----- (000552C0) --------------------------------------------------------
Json::Value *__fastcall Json::Path::make(Json::Path *this, Json::Value *a2)
{
  Json::Path *v2; // r6
  int v3; // r5
  Json::Value *v4; // r4
  int v5; // r3
  int *v6; // r0

  v2 = this;
  v3 = *(_DWORD *)this;
  v4 = a2;
  while ( v3 != *((_DWORD *)v2 + 1) )
  {
    v5 = *(_DWORD *)(v3 + 8);
    if ( v5 == 1 )
    {
      Json::Value::isArray(v4);
      v6 = Json::Value::operator[]((int)v4, *(_DWORD *)(v3 + 4));
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_8;
      Json::Value::isObject(v4);
      v6 = Json::Value::operator[](v4, (const char **)v3);
    }
    v4 = (Json::Value *)v6;
LABEL_8:
    v3 += 12;
  }
  return v4;
}

//----- (00055300) --------------------------------------------------------
int *__fastcall Json::Value::operator[](Json::Value *a1, const char **a2)
{
  return Json::Value::resolveReference(a1, *a2, 1);
}

//----- (00055308) --------------------------------------------------------
_DWORD *__fastcall std::_Destroy_aux<false>::__destroy<Json::PathArgument *>(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r0

  v2 = result;
  v3 = a2;
  while ( v2 != v3 )
  {
    v4 = v2;
    v2 += 3;
    result = sub_C0AD8(v4);
  }
  return result;
}

//----- (0005531E) --------------------------------------------------------
_DWORD *__fastcall std::__uninitialized_copy<false>::__uninit_copy<std::string *,std::string *>(int *a1, int *a2, _DWORD *a3)
{
  int *v3; // r5
  int *v4; // r7
  _DWORD *v5; // r4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  while ( v3 != v4 )
  {
    if ( v5 )
      sub_C16AC(v5, v3);
    ++v3;
    ++v5;
  }
  return v5;
}

//----- (00055358) --------------------------------------------------------
void __fastcall std::vector<std::string,std::allocator<std::string>>::_M_insert_aux(int a1, int a2, int a3)
{
  int **v3; // r4
  char *v4; // r3
  int *v5; // r8
  char *v6; // r0
  int *v7; // r6
  int v8; // r0
  int v9; // r4
  int v10; // r6
  int v11; // r0
  int v12; // r7
  signed int v13; // r3
  unsigned __int8 v14; // cf
  unsigned int v15; // r3
  unsigned int v16; // r7
  int v17; // r9
  int *v18; // r5
  int *v19; // r9
  _DWORD *v20; // r0
  int *v21; // r6
  int v22; // [sp+4h] [bp-24h]
  int v23; // [sp+8h] [bp-20h]

  v22 = a2;
  v23 = a3;
  v3 = (int **)a1;
  v4 = *(char **)(a1 + 8);
  v5 = (int *)a2;
  v6 = *(char **)(a1 + 4);
  v7 = (int *)a3;
  if ( v6 == v4 )
  {
    v11 = v6 - (char *)*v3;
    v12 = v11 >> 2;
    if ( v11 >> 2 )
      v13 = v11 >> 2;
    else
      v13 = 1;
    v14 = __CFADD__(v13, v12);
    v15 = v13 + v12;
    v16 = 0x3FFFFFFF;
    if ( !v14 && v15 < 0x3FFFFFFF )
      v16 = v15;
    v17 = (a2 - (signed int)*v3) >> 2;
    if ( v16 )
      v18 = (int *)sub_53A24(v16);
    else
      v18 = 0;
    v19 = &v18[v17];
    if ( v19 )
      sub_C16AC(v19, v7);
    v20 = std::__uninitialized_copy<false>::__uninit_copy<std::string *,std::string *>(*v3, v5, v18);
    v21 = std::__uninitialized_copy<false>::__uninit_copy<std::string *,std::string *>(v5, v3[1], v20 + 1);
    std::_Destroy_aux<false>::__destroy<std::string *>(*v3, v3[1]);
    sub_53A1C(*v3);
    *v3 = v18;
    v3[1] = v21;
    v3[2] = &v18[v16];
  }
  else
  {
    if ( v6 )
      sub_C16AC(v6, (int *)v6 - 1);
    ++v3[1];
    sub_C16AC(&v22, v7);
    v8 = (int)(v3[1] - 2);
    v9 = (v8 - (signed int)v5) >> 2;
    while ( v9 > 0 )
    {
      v10 = v8 - 4;
      sub_C1778(v8, v8 - 4);
      --v9;
      v8 = v10;
    }
    sub_C1778(v5, &v22);
    sub_C0AD8(&v22);
  }
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);

//----- (00055460) --------------------------------------------------------
Json::Value *__fastcall Json::Value::getMemberNames(Json::Value *this, unsigned __int8 *a2)
{
  Json::Value *v2; // r4
  int v3; // r3
  unsigned __int8 *v4; // r7
  unsigned int v5; // r6
  _DWORD *v6; // r5
  int v7; // r6
  char *v8; // r0
  int i; // [sp+4h] [bp-2Ch]
  void *v11; // [sp+8h] [bp-28h]
  _DWORD *v12; // [sp+Ch] [bp-24h]
  _DWORD *v13; // [sp+10h] [bp-20h]
  _DWORD *v14; // [sp+14h] [bp-1Ch]

  v2 = this;
  v3 = a2[8];
  v4 = a2;
  if ( a2[8] )
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v5 = *(_DWORD *)(*(_DWORD *)a2 + 20);
    if ( v5 >= 0x40000000 )
      sub_BFBAC((int)"vector::reserve");
    if ( v5 )
    {
      v6 = sub_53A24(*(_DWORD *)(*(_DWORD *)a2 + 20));
      std::__uninitialized_copy<false>::__uninit_copy<std::string *,std::string *>(0, 0, v6);
      std::_Destroy_aux<false>::__destroy<std::string *>(v12, v13);
      sub_53A1C(v12);
      v12 = v6;
      v13 = v6;
      v14 = &v6[v5];
    }
    v7 = *(_DWORD *)v4 + 4;
    for ( i = *(_DWORD *)(*(_DWORD *)v4 + 12);
          i != v7;
          std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++(&i) )
    {
      v8 = (char *)Json::Value::CZString::c_str((Json::Value::CZString *)(i + 16));
      sub_C1C58(&v11, v8);
      if ( v13 == v14 )
      {
        std::vector<std::string,std::allocator<std::string>>::_M_insert_aux((int)&v12, (int)v13, (int)&v11);
      }
      else
      {
        if ( v13 )
          sub_C16AC(v13, (int *)&v11);
        ++v13;
      }
      sub_C0AD8(&v11);
    }
    std::vector<std::string,std::allocator<std::string>>::vector(v2, &v12);
    std::vector<std::string,std::allocator<std::string>>::~vector((void **)&v12);
  }
  else
  {
    *(_DWORD *)this = v3;
    *((_DWORD *)this + 1) = v3;
    *((_DWORD *)this + 2) = v3;
  }
  return v2;
}

//----- (00055550) --------------------------------------------------------
unsigned int __fastcall std::operator<<Json::Value::CZString const,Json::Value>(const char **a1, int a2)
{
  const char **v2; // r5
  int v3; // r4

  v2 = a1;
  v3 = a2;
  if ( Json::Value::CZString::operator<(a1, a2) )
    return 1;
  if ( Json::Value::CZString::operator<((const char **)v3, (int)v2) )
    return 0;
  return Json::Value::operator<((unsigned __int8 *)v2 + 8, (unsigned __int8 *)(v3 + 8));
}

//----- (00055580) --------------------------------------------------------
unsigned int __fastcall Json::Value::operator<(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // r3
  unsigned int v3; // r4
  const char *v4; // r4
  const char *v5; // r3
  unsigned int v6; // r4
  const char *v7; // r0
  const char *v8; // r1
  const char *v9; // r3
  const char *v10; // r2
  int v11; // r1
  int v12; // r6
  unsigned __int8 *v13; // r3
  int v14; // r5
  unsigned __int8 *v16; // [sp+0h] [bp-20h]
  unsigned __int8 *v17; // [sp+4h] [bp-1Ch]

  v16 = a1;
  v17 = a2;
  v2 = a1[8];
  v3 = v2 - a2[8];
  if ( v2 != a2[8] )
    return v3 >> 31;
  switch ( v2 )
  {
    case 1:
      v4 = *(const char **)a1;
      v5 = *(const char **)a2;
      return (signed int)v4 < (signed int)v5;
    case 2:
      return *(_DWORD *)a1 < *(_DWORD *)a2;
    case 3:
      return *(double *)a1 < *(double *)a2;
    case 4:
      v7 = *(const char **)a1;
      v8 = *(const char **)a2;
      if ( !v7 )
      {
        if ( v8 )
          return 1;
        return 0;
      }
      if ( !v8 )
        return 0;
      return (unsigned int)strcmp(v7, v8) >> 31;
    case 5:
      v4 = (const char *)*a1;
      v5 = (const char *)*a2;
      return (signed int)v4 < (signed int)v5;
    case 6:
    case 7:
      v9 = *(const char **)a1;
      v10 = *(const char **)a2;
      v11 = *(_DWORD *)(*(_DWORD *)a2 + 20);
      v3 = *(_DWORD *)(*(_DWORD *)a1 + 20) - v11;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 20) != v11 )
        return v3 >> 31;
      v12 = (int)(v9 + 4);
      v13 = (unsigned __int8 *)*((_DWORD *)v9 + 3);
      v14 = (int)(v10 + 4);
      v17 = (unsigned __int8 *)*((_DWORD *)v10 + 3);
      v16 = v13;
      break;
    default:
      return 0;
  }
  while ( v16 != (unsigned __int8 *)v12 )
  {
    if ( v17 == (unsigned __int8 *)v14 )
      return 0;
    v6 = std::operator<<Json::Value::CZString const,Json::Value>((const char **)v16 + 4, (int)(v17 + 16));
    if ( v6 )
      return 1;
    if ( std::operator<<Json::Value::CZString const,Json::Value>((const char **)v17 + 4, (int)(v16 + 16)) )
      return v6;
    std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++((int *)&v16);
    std::_Rb_tree_const_iterator<std::pair<Json::Value::CZString const,Json::Value>>::operator++((int *)&v17);
  }
  if ( v17 != (unsigned __int8 *)v14 )
    return 1;
  return 0;
}

//----- (0005565A) --------------------------------------------------------
int __fastcall Json::Value::operator>=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return (unsigned __int8)(Json::Value::operator<(a1, a2) ^ 1);
}

//----- (00055668) --------------------------------------------------------
unsigned int __fastcall Json::Value::operator>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return Json::Value::operator<(a2, a1);
}

//----- (00055672) --------------------------------------------------------
int __fastcall Json::Value::operator<=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return (unsigned __int8)(Json::Value::operator>(a2, a1) ^ 1);
}

//----- (00055686) --------------------------------------------------------
_DWORD *__fastcall std::__uninitialized_copy<false>::__uninit_copy<Json::PathArgument *,Json::PathArgument *>(int *a1, int *a2, _DWORD *a3)
{
  int *v3; // r5
  int *v4; // r7
  _DWORD *v5; // r4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  while ( v3 != v4 )
  {
    if ( v5 )
    {
      sub_C16AC(v5, v3);
      v5[1] = v3[1];
      v5[2] = v3[2];
    }
    v3 += 3;
    v5 += 3;
  }
  return v5;
}

//----- (000556C8) --------------------------------------------------------
void __fastcall std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::_M_insert_aux(int **a1, int *a2, int *a3)
{
  int **v3; // r4
  int *v4; // r5
  int *v5; // r6
  int *v6; // r7
  int v7; // r3
  int *v8; // r7
  int v9; // r4
  int v10; // r7
  int v11; // r5
  signed int v12; // r3
  unsigned int v13; // r9
  int v14; // r8
  int *v15; // r5
  int *v16; // r8
  _DWORD *v17; // r0
  int *v18; // r6
  char v19; // [sp+4h] [bp-2Ch]
  int v20; // [sp+8h] [bp-28h]
  int v21; // [sp+Ch] [bp-24h]

  v3 = a1;
  v4 = a1[1];
  v5 = a2;
  v6 = a3;
  if ( v4 == a1[2] )
  {
    v11 = -1431655765 * (v4 - *a1);
    if ( v11 )
      v12 = v11;
    else
      v12 = 1;
    v13 = v12 + v11;
    if ( __CFADD__(v12, v11) )
    {
      v13 = 357913941;
    }
    else if ( v13 >= 0x15555555 )
    {
      v13 = 357913941;
    }
    v14 = -1431655765 * (a2 - *a1);
    if ( v13 )
      v15 = (int *)operator new(12 * v13);
    else
      v15 = 0;
    v16 = &v15[3 * v14];
    if ( v16 )
    {
      sub_C16AC(v16, v6);
      v16[1] = v6[1];
      v16[2] = v6[2];
    }
    v17 = std::__uninitialized_copy<false>::__uninit_copy<Json::PathArgument *,Json::PathArgument *>(*v3, v5, v15);
    v18 = std::__uninitialized_copy<false>::__uninit_copy<Json::PathArgument *,Json::PathArgument *>(v5, v3[1], v17 + 3);
    std::_Destroy_aux<false>::__destroy<Json::PathArgument *>(*v3, v3[1]);
    if ( *v3 )
      operator delete(*v3);
    *v3 = v15;
    v3[1] = v18;
    v3[2] = &v15[3 * v13];
  }
  else
  {
    if ( v4 )
    {
      sub_C16AC(a1[1], v4 - 3);
      v4[1] = *(v4 - 2);
      v4[2] = *(v4 - 1);
    }
    v3[1] += 3;
    sub_C16AC(&v19, v6);
    v20 = v6[1];
    v7 = v6[2];
    v8 = v3[1];
    v9 = (int)(v8 - 3);
    v21 = v7;
    v10 = -1431655765 * (v8 - 6 - v5);
    while ( v10 > 0 )
    {
      v9 -= 12;
      sub_C1778(v9, v9 - 12);
      --v10;
      *(_DWORD *)(v9 + 4) = *(_DWORD *)(v9 - 8);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v9 - 4);
    }
    sub_C1778(v5, &v19);
    v5[1] = v20;
    v5[2] = v21;
    sub_C0AD8(&v19);
  }
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);

//----- (00055838) --------------------------------------------------------
void __fastcall std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::push_back(int a1, int *a2)
{
  int v2; // r5
  int v3; // r4
  int *v4; // r6

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = a2;
  if ( v3 == *(_DWORD *)(a1 + 8) )
  {
    std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::_M_insert_aux((int **)a1, *(int **)(a1 + 4), a2);
  }
  else
  {
    if ( v3 )
    {
      sub_C16AC(*(_DWORD **)(a1 + 4), a2);
      *(_DWORD *)(v3 + 4) = v4[1];
      *(_DWORD *)(v3 + 8) = v4[2];
    }
    *(_DWORD *)(v2 + 4) += 12;
  }
}

//----- (00055868) --------------------------------------------------------
void __fastcall Json::Path::addPathInArg(int a1, int a2, int a3, int ***a4, int a5)
{
  int **v5; // r3

  v5 = *a4;
  if ( v5 != *(int ***)(a3 + 4) && (*v5)[2] == a5 )
    std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::push_back(a1, *v5);
}

//----- (00055888) --------------------------------------------------------
void __fastcall Json::Path::makePath(int a1, unsigned __int8 **a2, int *a3)
{
  unsigned __int8 *v3; // r4
  int v4; // r7
  unsigned __int8 **v5; // r8
  int v6; // r10
  int v7; // r9
  int v8; // r3
  unsigned __int8 *v9; // r6
  unsigned __int8 *v10; // r3
  unsigned int i; // r1
  int v12; // r2
  int v13; // t1
  int v14; // r5
  unsigned __int8 *v15; // r6
  int v16; // r1
  void *v17; // r6
  int *v18; // r0
  int *v19; // ST10_4
  int v20; // [sp+1Ch] [bp-3Ch]
  void *v21; // [sp+20h] [bp-38h]
  char v22; // [sp+24h] [bp-34h]

  v3 = *a2;
  v4 = a1;
  v5 = a2;
  v6 = (int)a3;
  v7 = (int)&(*a2)[*((_DWORD *)*a2 - 3)];
  v20 = *a3;
  while ( v3 != (unsigned __int8 *)v7 )
  {
    v8 = *v3;
    switch ( v8 )
    {
      case 91:
        v9 = v3 + 1;
        if ( v3[1] == 37 )
        {
          Json::Path::addPathInArg(v4, (int)v5, v6, (int ***)&v20, 1);
        }
        else
        {
          v10 = v3 + 1;
          for ( i = 0; ; i = v12 + 10 * i - 48 )
          {
            v9 = v10;
            if ( v10 == (unsigned __int8 *)v7 )
              break;
            v13 = *v10++;
            v12 = v13;
            if ( (unsigned int)(v13 - 48) > 9 )
              break;
          }
          Json::PathArgument::PathArgument((int)&v22, i);
          std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::push_back(v4, (int *)&v22);
          sub_C0AD8(&v22);
        }
        if ( v9 == (unsigned __int8 *)v7 )
          goto LABEL_26;
        v14 = (int)(v9 + 1);
        if ( *v9 != 93 )
        {
          ++v9;
LABEL_26:
          v14 = (int)v9;
          Json::Path::invalidPath(v4, v5, v9 - *v5);
          break;
        }
        break;
      case 37:
        Json::Path::addPathInArg(v4, (int)v5, v6, (int ***)&v20, 2);
LABEL_18:
        v14 = (int)(v3 + 1);
        break;
      case 46:
        goto LABEL_18;
      default:
        v15 = v3;
        do
        {
          v14 = (int)v15;
          v16 = *v15++;
          if ( strchr("[.", v16) )
            break;
          v14 = (int)v15;
        }
        while ( v15 != (unsigned __int8 *)v7 );
        if ( v3 == (unsigned __int8 *)v14 )
        {
          v17 = &unk_2FEF48;
        }
        else
        {
          v18 = sub_C09E4(v14 - (_DWORD)v3, 0);
          v17 = v18 + 3;
          v19 = v18;
          sub_C0348((_BYTE *)v18 + 12, v3, v14);
          sub_C09C4(v19, v14 - (_DWORD)v3);
        }
        v21 = v17;
        Json::PathArgument::PathArgument((void **)&v22, (char **)&v21);
        std::vector<Json::PathArgument,std::allocator<Json::PathArgument>>::push_back(v4, (int *)&v22);
        sub_C0AD8(&v22);
        sub_C0AD8(&v21);
        break;
    }
    v3 = (unsigned __int8 *)v14;
  }
}
// 546E2: using guessed type int __fastcall Json::Path::invalidPath(_DWORD, _DWORD, _DWORD);

//----- (000559EC) --------------------------------------------------------
char *__fastcall std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::PathArgument const*>(void *src, int a2, char *a3)
{
  int v3; // r1
  char *v4; // r3
  size_t v5; // r4

  v3 = a2 - (_DWORD)src;
  v4 = a3;
  v5 = 4 * (v3 >> 2);
  if ( v3 >> 2 )
    v4 = (char *)memmove(a3, src, v5);
  return &v4[v5];
}

//----- (00055A0C) --------------------------------------------------------
void __fastcall std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::_M_insert_aux(signed int *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r9
  _DWORD *v4; // r3
  signed int *v5; // r4
  _DWORD *v6; // r6
  int v7; // r0
  int v8; // r4
  int v9; // r2
  int v10; // r5
  int v11; // r1
  unsigned __int8 v12; // cf
  unsigned int v13; // r1
  signed int v14; // r5
  int v15; // r7
  int v16; // r8
  char *v17; // r0
  char *v18; // r6

  v3 = a3;
  v4 = (_DWORD *)a1[1];
  v5 = a1;
  v6 = a2;
  if ( v4 == (_DWORD *)a1[2] )
  {
    v10 = ((signed int)v4 - *a1) >> 2;
    if ( v10 )
      v11 = ((signed int)v4 - *a1) >> 2;
    else
      v11 = 1;
    v12 = __CFADD__(v11, v10);
    v13 = v11 + v10;
    v14 = 0x3FFFFFFF;
    if ( !v12 && v13 < 0x3FFFFFFF )
      v14 = v13;
    v15 = 4 * v14;
    v16 = ((signed int)v6 - *a1) >> 2;
    if ( v14 )
      v14 = (signed int)operator new(4 * v14);
    if ( v14 + 4 * v16 )
      *(_DWORD *)(v14 + 4 * v16) = *v3;
    v17 = std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::PathArgument const*>(
            (void *)*v5,
            (int)v6,
            (char *)v14);
    v18 = std::__copy_move<false,true,std::random_access_iterator_tag>::__copy_m<Json::PathArgument const*>(
            v6,
            v5[1],
            v17 + 4);
    if ( *v5 )
      operator delete((void *)*v5);
    *v5 = v14;
    v5[1] = (signed int)v18;
    v5[2] = v14 + v15;
  }
  else
  {
    if ( v4 )
      *v4 = *(v4 - 1);
    v7 = a1[1];
    v5[1] = v7 + 4;
    v8 = *a3;
    v9 = (v7 - 4 - (signed int)a2) >> 2;
    if ( v9 )
      memmove((void *)(v7 - 4 * v9), a2, 4 * v9);
    *v6 = v8;
  }
}

//----- (00055AAE) --------------------------------------------------------
void __fastcall std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back(signed int *a1, _DWORD *a2)
{
  _DWORD *v2; // r2
  _DWORD *v3; // r1

  v2 = a2;
  v3 = (_DWORD *)a1[1];
  if ( v3 == (_DWORD *)a1[2] )
  {
    std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::_M_insert_aux(a1, v3, v2);
  }
  else
  {
    if ( v3 )
      *v3 = *v2;
    a1[1] += 4;
  }
}

//----- (00055AD0) --------------------------------------------------------
int __fastcall Json::Path::Path(_DWORD *a1, unsigned __int8 **a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // r4
  unsigned __int8 **v8; // r7
  int v9; // r8
  int v11; // [sp+0h] [bp-28h]
  void *v12; // [sp+4h] [bp-24h]
  int v13; // [sp+8h] [bp-20h]
  int v14; // [sp+Ch] [bp-1Ch]

  v7 = (int)a1;
  v8 = a2;
  *a1 = 0;
  v9 = a4;
  a1[1] = 0;
  a1[2] = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v11 = a3;
  std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back((signed int *)&v12, &v11);
  v11 = v9;
  std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back((signed int *)&v12, &v11);
  v11 = a5;
  std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back((signed int *)&v12, &v11);
  v11 = a6;
  std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back((signed int *)&v12, &v11);
  v11 = a7;
  std::vector<Json::PathArgument const*,std::allocator<Json::PathArgument const*>>::push_back((signed int *)&v12, &v11);
  Json::Path::makePath(v7, v8, (int *)&v12);
  if ( v12 )
    operator delete(v12);
  return v7;
}

//----- (00055B5C) --------------------------------------------------------
int __fastcall std::uppercase(int result)
{
  *(_DWORD *)(result + 12) |= 0x4000u;
  return result;
}

//----- (00055B66) --------------------------------------------------------
int __fastcall std::hex(int result)
{
  *(_DWORD *)(result + 12) = *(_DWORD *)(result + 12) & 0xFFFFFFB5 | 8;
  return result;
}

//----- (00055B74) --------------------------------------------------------
int __fastcall Json::Writer::~Writer(int result)
{
  *(_DWORD *)result = &off_F02A0;
  return result;
}
// F02A0: using guessed type void *;

//----- (00055B84) --------------------------------------------------------
Json::FastWriter *__fastcall Json::FastWriter::~FastWriter(Json::FastWriter *this)
{
  Json::FastWriter *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F02B8;
  sub_C0AD8((_DWORD *)this + 1);
  Json::Writer::~Writer((int)v1);
  return v1;
}
// F02B8: using guessed type void *off_F02B8;

//----- (00055BA8) --------------------------------------------------------
Json::Writer *__fastcall Json::Writer::~Writer(Json::Writer *this)
{
  Json::Writer *v1; // r4

  v1 = this;
  Json::Writer::~Writer((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (00055BBA) --------------------------------------------------------
Json::FastWriter *__fastcall Json::FastWriter::~FastWriter(Json::FastWriter *this)
{
  Json::FastWriter *v1; // r4

  v1 = this;
  Json::FastWriter::~FastWriter(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00055BCC) --------------------------------------------------------
void __fastcall sub_55BCC(void *a1)
{
  if ( a1 )
    operator delete(a1);
}

//----- (00055BD4) --------------------------------------------------------
Json *__fastcall Json::valueToString(Json *this, int a2)
{
  unsigned int v2; // r10
  char *v3; // r8
  Json *v4; // r7
  unsigned int v5; // r5
  char *v6; // r4
  char *v7; // r6
  char v9; // [sp+23h] [bp-25h]

  v2 = (unsigned int)a2 >> 31;
  if ( a2 < 0 )
    a2 = -a2;
  v3 = &v9;
  v4 = this;
  v5 = a2;
  v9 = 0;
  do
  {
    v6 = v3 - 1;
    v7 = v3;
    v3 = v6;
    *v6 = v5 % 0xA + 48;
    v5 /= 0xAu;
  }
  while ( v5 );
  if ( v2 )
  {
    v6 = v7 - 2;
    *(v7 - 2) = 45;
  }
  sub_C1C58((void **)this, v6);
  return v4;
}

//----- (00055C50) --------------------------------------------------------
Json *__fastcall Json::valueToString(Json *this, unsigned int a2)
{
  Json *v2; // r6
  char *v3; // r5
  unsigned int v4; // r4
  char *v5; // r8
  char v7; // [sp+22h] [bp-1Eh]
  char v8; // [sp+23h] [bp-1Dh]

  v2 = this;
  v3 = &v7;
  v4 = a2;
  v8 = 0;
  do
  {
    v5 = v3;
    *v3-- = v4 % 0xA + 48;
    v4 /= 0xAu;
  }
  while ( v4 );
  sub_C1C58((void **)this, v5);
  return v2;
}

//----- (00055CB0) --------------------------------------------------------
void **__fastcall Json::valueToString(Json *this, int a2, double a3)
{
  void **v3; // r5
  char *v4; // r3
  char *v5; // r2
  int v6; // r1
  unsigned __int8 *v7; // r3
  unsigned int v8; // r1
  char s[32]; // [sp+4h] [bp-34h]

  v3 = (void **)this;
  sprintf(s, "%#.16g", a3);
  v4 = &s[strlen(s) - 1];
  if ( *v4 == 48 )
  {
    do
    {
      v5 = v4;
      if ( v4 <= s )
        break;
      v6 = (unsigned __int8)*v4--;
    }
    while ( v6 == 48 );
    v7 = (unsigned __int8 *)v5;
    while ( v7 >= (unsigned __int8 *)s )
    {
      v8 = *v7--;
      if ( v8 == 46 )
      {
        v5[2] = 0;
        break;
      }
      if ( v8 < 0x2E || v8 - 48 > 9 )
        break;
    }
  }
  sub_C1C58(v3, s);
  return v3;
}
// 55CB0: using guessed type char s[32];

//----- (00055D2C) --------------------------------------------------------
Json *__fastcall Json::valueToString(Json *this, int a2)
{
  Json *v2; // r4
  char *v3; // r1

  v2 = this;
  if ( a2 )
    v3 = "true";
  else
    v3 = "false";
  sub_C1C58((void **)this, v3);
  return v2;
}

//----- (00055D54) --------------------------------------------------------
int __fastcall Json::FastWriter::FastWriter(int result)
{
  *(_DWORD *)result = &off_F02B8;
  *(_DWORD *)(result + 4) = &unk_2FEF48;
  *(_BYTE *)(result + 8) = 0;
  return result;
}
// F02B8: using guessed type void *;

//----- (00055D78) --------------------------------------------------------
int __fastcall Json::FastWriter::enableYAMLCompatibility(int result)
{
  *(_BYTE *)(result + 8) = 1;
  return result;
}

//----- (00055D80) --------------------------------------------------------
int __fastcall Json::StyledWriter::StyledWriter(int result)
{
  *(_DWORD *)result = &off_F02D0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = &unk_2FEF48;
  *(_DWORD *)(result + 20) = &unk_2FEF48;
  *(_DWORD *)(result + 24) = 74;
  *(_DWORD *)(result + 28) = 3;
  return result;
}
// F02D0: using guessed type void *;

//----- (00055DB0) --------------------------------------------------------
void __fastcall Json::StyledWriter::writeIndent(Json::StyledWriter *this)
{
  int *v1; // r4
  Json::StyledWriter *v2; // r5
  int v3; // r6
  int v4; // r3

  v1 = (int *)((char *)this + 16);
  v2 = this;
  v3 = *(_DWORD *)(*((_DWORD *)this + 4) - 12);
  if ( v3 )
  {
    sub_C0C28((int *)this + 4);
    v4 = *(unsigned __int8 *)(v3 + *((_DWORD *)v2 + 4) - 1);
    if ( v4 == 32 )
      return;
    if ( v4 != 10 )
      sub_C15D0(v1, 10);
  }
  sub_C135C(v1, (char *)v2 + 20);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00055DEE) --------------------------------------------------------
int __fastcall Json::StyledWriter::writeWithIndent(Json::StyledWriter *a1, int a2)
{
  int v2; // r5
  Json::StyledWriter *v3; // r4

  v2 = a2;
  v3 = a1;
  Json::StyledWriter::writeIndent(a1);
  return sub_C135C((char *)v3 + 16, v2);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00055E06) --------------------------------------------------------
_DWORD *__fastcall Json::StyledWriter::indent(Json::StyledWriter *this, int a2, int a3)
{
  Json::StyledWriter *v3; // r5
  int v5; // [sp+4h] [bp-14h]
  int v6; // [sp+8h] [bp-10h]

  v5 = a2;
  v6 = a3;
  v3 = this;
  sub_C0AA8((void **)&v5, *((_DWORD *)this + 7), 32);
  sub_C135C((char *)v3 + 20, &v5);
  return sub_C0AD8(&v5);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00055E36) --------------------------------------------------------
void __fastcall Json::StyledWriter::unindent(Json::StyledWriter *this)
{
  sub_C15C8((int *)this + 5, *(_DWORD *)(*((_DWORD *)this + 5) - 12) - *((_DWORD *)this + 7));
}

//----- (00055E46) --------------------------------------------------------
int __fastcall Json::StyledWriter::hasCommentForValue(Json::StyledWriter *this, const Json::Value *a2)
{
  const Json::Value *v2; // r4
  int result; // r0

  v2 = a2;
  if ( Json::Value::hasComment((int)a2, 0) || Json::Value::hasComment((int)v2, 1) )
    result = 1;
  else
    result = Json::Value::hasComment((int)v2, 2);
  return result;
}

//----- (00055E70) --------------------------------------------------------
int *__fastcall Json::StyledWriter::normalizeEOL(int *a1, unsigned __int8 **a2)
{
  unsigned __int8 **v2; // r5
  int *v3; // r4
  unsigned __int8 *v4; // r3
  int v5; // r6
  int v6; // r1
  int v7; // r5
  int *v8; // r0

  *a1 = (int)&unk_2FEF48;
  v2 = a2;
  v3 = a1;
  sub_C1264(a1, *((_DWORD *)*a2 - 3));
  v4 = *v2;
  v5 = (int)&(*v2)[*((_DWORD *)*v2 - 3)];
  while ( v4 != (unsigned __int8 *)v5 )
  {
    v6 = *v4;
    v7 = (int)(v4 + 1);
    if ( v6 == 13 )
    {
      v8 = v3;
      LOBYTE(v6) = 10;
      if ( v4[1] == 10 )
        v7 = (int)(v4 + 2);
    }
    else
    {
      v8 = v3;
    }
    sub_C15D0(v8, v6);
    v4 = (unsigned __int8 *)v7;
  }
  return v3;
}

//----- (00055EC8) --------------------------------------------------------
unsigned int *__fastcall Json::StyledWriter::writeCommentBeforeValue(Json::StyledWriter *this, const Json::Value *a2)
{
  Json::StyledWriter *v2; // r6
  const Json::Value *v3; // r5
  unsigned int *result; // r0
  unsigned int *v5; // r6
  Json::StyledWriter *v6; // [sp+0h] [bp-18h]
  const Json::Value *v7; // [sp+4h] [bp-14h]

  v6 = this;
  v7 = a2;
  v2 = this;
  v3 = a2;
  result = (unsigned int *)Json::Value::hasComment((int)a2, 0);
  if ( result )
  {
    Json::Value::getComment((void **)&v6, (int)v3, 0);
    v5 = (unsigned int *)((char *)v2 + 16);
    Json::StyledWriter::normalizeEOL((int *)&v7, (unsigned __int8 **)&v6);
    sub_C135C(v5, &v7);
    sub_C0AD8(&v7);
    sub_C0AD8(&v6);
    result = sub_C14E4(v5, "\n");
  }
  return result;
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00055F28) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::writeIndent(Json::StyledStreamWriter *this)
{
  Json::StyledStreamWriter *v1; // r4
  int *v2; // r0

  v1 = this;
  v2 = sub_B70E8(*((int **)this + 3), 10);
  return sub_AAE2C(v2, (int *)v1 + 4);
}

//----- (00055F40) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::writeWithIndent(Json::StyledStreamWriter *a1, int *a2)
{
  Json::StyledStreamWriter *v2; // r4
  int *v3; // r5

  v2 = a1;
  v3 = a2;
  Json::StyledStreamWriter::writeIndent(a1);
  return sub_AAE2C(*((int **)v2 + 3), v3);
}

//----- (00055F56) --------------------------------------------------------
int __fastcall Json::StyledStreamWriter::indent(Json::StyledStreamWriter *this)
{
  return sub_C135C((char *)this + 16, (char *)this + 24);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00055F60) --------------------------------------------------------
void __fastcall Json::StyledStreamWriter::unindent(Json::StyledStreamWriter *this)
{
  sub_C15C8((int *)this + 4, *(_DWORD *)(*((_DWORD *)this + 4) - 12) - *(_DWORD *)(*((_DWORD *)this + 6) - 12));
}

//----- (00055F74) --------------------------------------------------------
int __fastcall Json::StyledStreamWriter::hasCommentForValue(Json::StyledStreamWriter *this, const Json::Value *a2)
{
  const Json::Value *v2; // r4
  int result; // r0

  v2 = a2;
  if ( Json::Value::hasComment((int)a2, 0) || Json::Value::hasComment((int)v2, 1) )
    result = 1;
  else
    result = Json::Value::hasComment((int)v2, 2);
  return result;
}

//----- (00055F9C) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::normalizeEOL(int *a1, unsigned __int8 **a2)
{
  unsigned __int8 **v2; // r5
  int *v3; // r4
  unsigned __int8 *v4; // r3
  int v5; // r6
  int v6; // r1
  int v7; // r5
  int *v8; // r0

  *a1 = (int)&unk_2FEF48;
  v2 = a2;
  v3 = a1;
  sub_C1264(a1, *((_DWORD *)*a2 - 3));
  v4 = *v2;
  v5 = (int)&(*v2)[*((_DWORD *)*v2 - 3)];
  while ( v4 != (unsigned __int8 *)v5 )
  {
    v6 = *v4;
    v7 = (int)(v4 + 1);
    if ( v6 == 13 )
    {
      v8 = v3;
      LOBYTE(v6) = 10;
      if ( v4[1] == 10 )
        v7 = (int)(v4 + 2);
    }
    else
    {
      v8 = v3;
    }
    sub_C15D0(v8, v6);
    v4 = (unsigned __int8 *)v7;
  }
  return v3;
}

//----- (00055FF4) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::writeCommentBeforeValue(Json::StyledStreamWriter *this, const Json::Value *a2, int a3)
{
  Json::StyledStreamWriter *v3; // r6
  const Json::Value *v4; // r5
  int *result; // r0
  int *v6; // r7
  Json::StyledStreamWriter *v7; // [sp+0h] [bp-20h]
  const Json::Value *v8; // [sp+4h] [bp-1Ch]
  int v9; // [sp+8h] [bp-18h]

  v7 = this;
  v8 = a2;
  v9 = a3;
  v3 = this;
  v4 = a2;
  result = (int *)Json::Value::hasComment((int)a2, 0);
  if ( result )
  {
    v6 = (int *)*((_DWORD *)v3 + 3);
    Json::Value::getComment((void **)&v7, (int)v4, 0);
    Json::StyledStreamWriter::normalizeEOL((int *)&v8, (unsigned __int8 **)&v7);
    sub_AAE2C(v6, (int *)&v8);
    sub_C0AD8(&v8);
    sub_C0AD8(&v7);
    result = sub_B7130(*((int **)v3 + 3), "\n");
  }
  return result;
}

//----- (00056054) --------------------------------------------------------
Json *__fastcall Json::valueToQuotedString(Json *this, const char *a2)
{
  const char *v2; // r5
  Json *v3; // r8
  char *v4; // r0
  int v5; // r2
  int v6; // r3
  int v7; // t1
  void **v8; // r4
  size_t v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // t1
  const char *v13; // r1
  int *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  int v18; // r1
  void *v19; // [sp+4h] [bp-DCh]
  void *v20; // [sp+8h] [bp-D8h]
  unsigned int v21[45]; // [sp+Ch] [bp-D4h]
  unsigned int v22[45]; // [sp+10h] [bp-D0h]

  v2 = a2;
  v3 = this;
  v4 = strpbrk(a2, (const char *)&unk_E4981);
  v5 = (int)(v2 - 1);
  if ( v4 )
  {
LABEL_6:
    v9 = strlen(v2);
    v19 = &unk_2FEF48;
    v8 = &v19;
    sub_C1264(&v19, 2 * v9 + 3);
    sub_C14E4((unsigned int *)&v19, "\"");
    while ( 1 )
    {
      while ( 1 )
      {
        v11 = *(unsigned __int8 *)v2++;
        v10 = v11;
        if ( !v11 )
        {
          sub_C14E4((unsigned int *)&v19, "\"");
          sub_C16AC(v3, (int *)&v19);
          goto LABEL_9;
        }
        if ( v10 == 12 )
        {
          v13 = (const char *)&unk_E4994;
          goto LABEL_25;
        }
        if ( v10 <= 0xC )
          break;
        switch ( v10 )
        {
          case 0x22u:
            v13 = (const char *)&unk_E498B;
            break;
          case 0x5Cu:
            v13 = (const char *)&unk_E498E;
            break;
          case 0xDu:
            v13 = (const char *)&unk_E499A;
            break;
          default:
            goto LABEL_26;
        }
LABEL_25:
        sub_C14E4((unsigned int *)&v19, v13);
      }
      switch ( v10 )
      {
        case 9u:
          v13 = (const char *)&unk_E499D;
          goto LABEL_25;
        case 0xAu:
          v13 = (const char *)&unk_E4997;
          goto LABEL_25;
        case 8u:
          v13 = (const char *)&unk_E4991;
          goto LABEL_25;
      }
LABEL_26:
      if ( v10 - 1 > 0x1E )
      {
        sub_C15D0((int *)&v19, v10);
      }
      else
      {
        sub_A5960((int)v21, 16);
        v14 = sub_B7130((int *)v21, (const char *)&unk_E49A0);
        v15 = sub_B6668(v14, (void (__fastcall *)(char *))std::hex);
        v16 = sub_B6668(v15, (void (__fastcall *)(char *))std::uppercase);
        v17 = sub_B6D9C(v16, 48);
        *(_DWORD *)((char *)v17 + *(_DWORD *)(*v17 - 12) + 8) = 4;
        v18 = *((unsigned __int8 *)v2 - 1);
        sub_B7364();
        sub_A4D80(&v20, (int)v22);
        sub_C135C(&v19, &v20);
        sub_C0AD8(&v20);
        sub_A4534((int)v21);
      }
    }
  }
  while ( 1 )
  {
    v7 = *(unsigned __int8 *)(v5++ + 1);
    v6 = v7;
    if ( !v7 )
      break;
    if ( (unsigned int)(v6 - 1) <= 0x1E )
      goto LABEL_6;
  }
  v8 = &v20;
  sub_C1C58(&v20, "\"");
  std::operator+<char,std::char_traits<char>,std::allocator<char>>(v21, (int *)&v20, v2);
  std::operator+<char,std::char_traits<char>,std::allocator<char>>((unsigned int *)v3, (int *)v21, "\"");
  sub_C0AD8(v21);
LABEL_9:
  sub_C0AD8(v8);
  return v3;
}
// B7364: using guessed type int sub_B7364(void);
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00056230) --------------------------------------------------------
unsigned int *__fastcall Json::StyledWriter::writeCommentAfterValueOnSameLine(Json::StyledWriter *this, const Json::Value *a2)
{
  Json::StyledWriter *v2; // r8
  const Json::Value *v3; // r7
  unsigned int *result; // r0
  unsigned __int8 *v5; // [sp+4h] [bp-2Ch]
  unsigned __int8 *v6; // [sp+8h] [bp-28h]
  char v7; // [sp+Ch] [bp-24h]

  v2 = this;
  v3 = a2;
  if ( Json::Value::hasComment((int)a2, 1) )
  {
    Json::Value::getComment((void **)&v5, (int)v3, 1);
    Json::StyledWriter::normalizeEOL((int *)&v6, &v5);
    sub_515E8((unsigned int *)&v7, (const char *)&unk_E49A3, &v6);
    sub_C135C((char *)v2 + 16, &v7);
    sub_C0AD8(&v7);
    sub_C0AD8(&v6);
    sub_C0AD8(&v5);
  }
  result = (unsigned int *)Json::Value::hasComment((int)v3, 2);
  if ( result )
  {
    sub_C14E4((unsigned int *)v2 + 4, "\n");
    Json::Value::getComment((void **)&v6, (int)v3, 2);
    Json::StyledWriter::normalizeEOL((int *)&v7, &v6);
    sub_C135C((char *)v2 + 16, &v7);
    sub_C0AD8(&v7);
    sub_C0AD8(&v6);
    result = sub_C14E4((unsigned int *)v2 + 4, "\n");
  }
  return result;
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00056308) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::writeCommentAfterValueOnSameLine(Json::StyledStreamWriter *this, const Json::Value *a2)
{
  Json::StyledStreamWriter *v2; // r7
  const Json::Value *v3; // r8
  int *v4; // r9
  int *result; // r0
  int *v6; // r6
  unsigned __int8 *v7; // [sp+4h] [bp-2Ch]
  unsigned __int8 *v8; // [sp+8h] [bp-28h]
  char v9; // [sp+Ch] [bp-24h]

  v2 = this;
  v3 = a2;
  if ( Json::Value::hasComment((int)a2, 1) )
  {
    v4 = (int *)*((_DWORD *)v2 + 3);
    Json::Value::getComment((void **)&v7, (int)v3, 1);
    Json::StyledStreamWriter::normalizeEOL((int *)&v8, &v7);
    sub_515E8((unsigned int *)&v9, (const char *)&unk_E49A3, &v8);
    sub_AAE2C(v4, (int *)&v9);
    sub_C0AD8(&v9);
    sub_C0AD8(&v8);
    sub_C0AD8(&v7);
  }
  result = (int *)Json::Value::hasComment((int)v3, 2);
  if ( result )
  {
    sub_B7130(*((int **)v2 + 3), "\n");
    v6 = (int *)*((_DWORD *)v2 + 3);
    Json::Value::getComment((void **)&v8, (int)v3, 2);
    Json::StyledStreamWriter::normalizeEOL((int *)&v9, &v8);
    sub_AAE2C(v6, (int *)&v9);
    sub_C0AD8(&v9);
    sub_C0AD8(&v8);
    result = sub_B7130(*((int **)v2 + 3), "\n");
  }
  return result;
}

//----- (000563DC) --------------------------------------------------------
Json::StyledStreamWriter *__fastcall Json::StyledStreamWriter::~StyledStreamWriter(Json::StyledStreamWriter *this)
{
  Json::StyledStreamWriter *v1; // r4

  v1 = this;
  sub_C0AD8((_DWORD *)this + 6);
  sub_C0AD8((_DWORD *)v1 + 4);
  std::vector<std::string,std::allocator<std::string>>::~vector((void **)v1);
  return v1;
}

//----- (000563F8) --------------------------------------------------------
_DWORD *__fastcall Json::StyledStreamWriter::StyledStreamWriter(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r0

  *a1 = 0;
  v2 = a1;
  a1[1] = 0;
  v3 = a1 + 6;
  *(v3 - 4) = 0;
  *(v3 - 3) = 0;
  *(v3 - 2) = &unk_2FEF48;
  *(v3 - 1) = 74;
  sub_C16AC(v3, a2);
  return v2;
}

//----- (0005643C) --------------------------------------------------------
void *__fastcall Json::FastWriter::writeValue(Json::FastWriter *this, const Json::Value *a2)
{
  Json::FastWriter *v2; // r4
  Json::Value *v3; // r5
  void *result; // r0
  int v5; // r1
  int v6; // r2
  unsigned int *v7; // r0
  const char *v8; // r1
  int v9; // r0
  signed int v10; // r0
  __int64 v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r6
  int v15; // r8
  const Json::Value *v16; // r0
  const char **v17; // r7
  int *v18; // r10
  const char *v19; // r1
  const char *v20; // r1
  const Json::Value *v21; // r0
  char v22; // [sp+8h] [bp-38h]
  const char **v23; // [sp+Ch] [bp-34h]
  const char **v24; // [sp+10h] [bp-30h]

  v2 = this;
  v3 = a2;
  result = (void *)Json::Value::type(a2);
  switch ( (unsigned int)result )
  {
    case 0u:
      v7 = (unsigned int *)((char *)v2 + 4);
      v8 = "null";
      goto LABEL_15;
    case 1u:
      v9 = Json::Value::asInt(v3, v5);
      Json::valueToString((Json *)&v23, v9);
      sub_C135C((char *)v2 + 4, &v23);
      goto LABEL_8;
    case 2u:
      v10 = Json::Value::asUInt(v3, v5);
      Json::valueToString((Json *)&v23, v10);
      sub_C135C((char *)v2 + 4, &v23);
      goto LABEL_8;
    case 3u:
      v11 = Json::Value::asDouble(v3, v5, v6);
      Json::valueToString((Json *)&v23, SHIDWORD(v11), *(double *)&v11);
      sub_C135C((char *)v2 + 4, &v23);
      goto LABEL_8;
    case 4u:
      v12 = (const char *)Json::Value::asCString(v3);
      Json::valueToQuotedString((Json *)&v23, v12);
      sub_C135C((char *)v2 + 4, &v23);
      goto LABEL_8;
    case 5u:
      v13 = Json::Value::asBool(v3);
      Json::valueToString((Json *)&v23, v13);
      sub_C135C((char *)v2 + 4, &v23);
LABEL_8:
      result = sub_C0AD8(&v23);
      break;
    case 6u:
      v14 = 0;
      sub_C14E4((unsigned int *)v2 + 1, "[");
      v15 = Json::Value::size(v3);
      while ( v14 < v15 )
      {
        if ( v14 > 0 )
          sub_C14E4((unsigned int *)v2 + 1, ",");
        v16 = (const Json::Value *)Json::Value::operator[]((int)v3, v14++);
        Json::FastWriter::writeValue(v2, v16);
      }
      v7 = (unsigned int *)((char *)v2 + 4);
      v8 = "]";
LABEL_15:
      result = sub_C14E4(v7, v8);
      break;
    case 7u:
      Json::Value::getMemberNames((Json::Value *)&v23, (unsigned __int8 *)v3);
      sub_C14E4((unsigned int *)v2 + 1, "{");
      v17 = v23;
      while ( 1 )
      {
        v18 = (int *)v17;
        if ( v17 == v24 )
          break;
        if ( v17 != v23 )
          sub_C14E4((unsigned int *)v2 + 1, ",");
        v19 = *v17;
        ++v17;
        Json::valueToQuotedString((Json *)&v22, v19);
        sub_C135C((char *)v2 + 4, &v22);
        sub_C0AD8(&v22);
        v20 = (const char *)&unk_E49A8;
        if ( *((_BYTE *)v2 + 8) )
          v20 = (const char *)&unk_E49A5;
        sub_C14E4((unsigned int *)v2 + 1, v20);
        v21 = (const Json::Value *)Json::Value::operator[]((int)v3, v18);
        Json::FastWriter::writeValue(v2, v21);
      }
      sub_C14E4((unsigned int *)v2 + 1, "}");
      result = std::vector<std::string,std::allocator<std::string>>::~vector((void **)&v23);
      break;
    default:
      return result;
  }
  return result;
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00056620) --------------------------------------------------------
Json::FastWriter *__fastcall Json::FastWriter::write(Json::FastWriter *this, const Json::Value *a2, const Json::Value *a3)
{
  unsigned int *v3; // r4
  Json::FastWriter *v4; // r6
  const Json::Value *v5; // r7
  Json::FastWriter *v6; // r5

  v3 = (unsigned int *)((char *)a2 + 4);
  v4 = a2;
  v5 = a3;
  v6 = this;
  sub_C1034((int *)a2 + 1, &byte_E4496);
  Json::FastWriter::writeValue(v4, v5);
  sub_C14E4(v3, "\n");
  sub_C16AC(v6, (int *)v3);
  return v6;
}
// E4496: using guessed type char byte_E4496;

//----- (0005665C) --------------------------------------------------------
void __fastcall std::vector<std::string,std::allocator<std::string>>::reserve(int a1, unsigned int a2)
{
  void **v2; // r4
  int *v3; // r6
  int *v4; // r8
  int v5; // r7
  _DWORD *v6; // r5

  v2 = (void **)a1;
  if ( a2 >= 0x40000000 )
    sub_BFBAC((int)"vector::reserve");
  v3 = *(int **)a1;
  if ( a2 > (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) >> 2 )
  {
    v4 = *(int **)(a1 + 4);
    v5 = a2;
    if ( a2 )
      v6 = operator new(4 * a2);
    else
      v6 = 0;
    std::__uninitialized_copy<false>::__uninit_copy<std::string *,std::string *>(v3, v4, v6);
    std::_Destroy_aux<false>::__destroy<std::string *>(*v2, v2[1]);
    sub_55BCC(*v2);
    *v2 = v6;
    v2[1] = &v6[v4 - v3];
    v2[2] = &v6[v5];
  }
}

//----- (000566E0) --------------------------------------------------------
void __fastcall std::vector<std::string,std::allocator<std::string>>::push_back(int a1, int *a2)
{
  int v2; // r3
  int v3; // r4

  v2 = *(_DWORD *)(a1 + 4);
  v3 = a1;
  if ( v2 == *(_DWORD *)(a1 + 8) )
  {
    std::vector<std::string,std::allocator<std::string>>::_M_insert_aux(a1, *(_DWORD *)(a1 + 4), (int)a2);
  }
  else
  {
    if ( v2 )
      sub_C16AC(*(_DWORD **)(a1 + 4), a2);
    *(_DWORD *)(v3 + 4) += 4;
  }
}

//----- (00056706) --------------------------------------------------------
void __fastcall Json::StyledWriter::pushValue(int a1, int *a2)
{
  if ( *(_BYTE *)(a1 + 32) )
    std::vector<std::string,std::allocator<std::string>>::push_back(a1 + 4, a2);
  else
    sub_C135C(a1 + 16, a2);
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00056718) --------------------------------------------------------
unsigned int *__fastcall Json::StyledWriter::writeArrayValue(Json::StyledWriter *this, const Json::Value *a2)
{
  Json::StyledWriter *v2; // r4
  const Json::Value *v3; // r8
  int v4; // r10
  int v5; // r5
  int v6; // r1
  int v7; // r2
  int v8; // r6
  const Json::Value *v9; // r11
  int v11; // r1
  int v12; // [sp+4h] [bp-3Ch]
  int v13; // [sp+8h] [bp-38h]
  char v14; // [sp+14h] [bp-2Ch]

  v2 = this;
  v3 = a2;
  v4 = Json::Value::size(a2);
  if ( !v4 )
  {
    sub_C1C58((void **)&v14, "[]");
    Json::StyledWriter::pushValue((int)v2, (int *)&v14);
    return sub_C0AD8(&v14);
  }
  v5 = Json::StyledWriter::isMultineArray(v2, v3);
  if ( v5 )
  {
    sub_C1C58((void **)&v14, "[");
    Json::StyledWriter::writeWithIndent(v2, (int)&v14);
    sub_C0AD8(&v14);
    Json::StyledWriter::indent(v2, v6, v7);
    v8 = 0;
    v12 = *((_DWORD *)v2 + 1);
    v13 = *((_DWORD *)v2 + 2);
    while ( 1 )
    {
      v9 = (const Json::Value *)Json::Value::operator[]((int)v3, v8);
      Json::StyledWriter::writeCommentBeforeValue(v2, v9);
      if ( v12 == v13 )
      {
        Json::StyledWriter::writeIndent(v2);
        Json::StyledWriter::writeValue(v2, v9);
      }
      else
      {
        Json::StyledWriter::writeWithIndent(v2, *((_DWORD *)v2 + 1) + 4 * v8);
      }
      if ( ++v8 == v4 )
        break;
      sub_C14E4((unsigned int *)v2 + 4, ",");
      Json::StyledWriter::writeCommentAfterValueOnSameLine(v2, v9);
    }
    Json::StyledWriter::writeCommentAfterValueOnSameLine(v2, v9);
    Json::StyledWriter::unindent(v2);
    sub_C1C58((void **)&v14, "]");
    Json::StyledWriter::writeWithIndent(v2, (int)&v14);
    return sub_C0AD8(&v14);
  }
  sub_C14E4((unsigned int *)v2 + 4, "[ ");
  while ( 1 )
  {
    v11 = *((_DWORD *)v2 + 1) + 4 * v5++;
    sub_C135C((char *)v2 + 16, v11);
    if ( v5 == v4 )
      break;
    if ( v5 )
      sub_C14E4((unsigned int *)v2 + 4, ", ");
  }
  return sub_C14E4((unsigned int *)v2 + 4, " ]");
}
// C135C: using guessed type int __fastcall sub_C135C(_DWORD, _DWORD);

//----- (00056874) --------------------------------------------------------
void *__fastcall Json::StyledWriter::writeValue(Json::StyledWriter *this, const Json::Value *a2)
{
  unsigned int *v2; // r4
  Json::Value *v3; // r5
  void *result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r0
  signed int v8; // r0
  __int64 v9; // r0
  const char *v10; // r0
  int v11; // r0
  char *v12; // r0
  int v13; // r1
  int v14; // r2
  int *v15; // r8
  const Json::Value *v16; // r9
  const char *v17; // r1
  void *v18; // [sp+Ch] [bp-44h]
  void *v19; // [sp+10h] [bp-40h]
  char v20; // [sp+14h] [bp-3Ch]
  char v21; // [sp+18h] [bp-38h]
  int *v22; // [sp+1Ch] [bp-34h]
  int *v23; // [sp+20h] [bp-30h]

  v2 = (unsigned int *)this;
  v3 = a2;
  result = (void *)Json::Value::type(a2);
  switch ( (unsigned int)result )
  {
    case 0u:
      sub_C1C58((void **)&v22, "null");
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
      goto LABEL_8;
    case 1u:
      v7 = Json::Value::asInt(v3, v5);
      Json::valueToString((Json *)&v22, v7);
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
      goto LABEL_8;
    case 2u:
      v8 = Json::Value::asUInt(v3, v5);
      Json::valueToString((Json *)&v22, v8);
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
      goto LABEL_8;
    case 3u:
      v9 = Json::Value::asDouble(v3, v5, v6);
      Json::valueToString((Json *)&v22, SHIDWORD(v9), *(double *)&v9);
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
      goto LABEL_8;
    case 4u:
      v10 = (const char *)Json::Value::asCString(v3);
      Json::valueToQuotedString((Json *)&v22, v10);
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
      goto LABEL_8;
    case 5u:
      v11 = Json::Value::asBool(v3);
      Json::valueToString((Json *)&v22, v11);
      Json::StyledWriter::pushValue((int)v2, (int *)&v22);
LABEL_8:
      result = sub_C0AD8(&v22);
      break;
    case 6u:
      result = Json::StyledWriter::writeArrayValue((Json::StyledWriter *)v2, v3);
      break;
    case 7u:
      Json::Value::getMemberNames((Json::Value *)&v22, (unsigned __int8 *)v3);
      if ( v22 == v23 )
      {
        sub_C1C58(&v18, "{}");
        Json::StyledWriter::pushValue((int)v2, (int *)&v18);
        v12 = (char *)&v18;
      }
      else
      {
        sub_C1C58(&v19, "{");
        Json::StyledWriter::writeWithIndent((Json::StyledWriter *)v2, (int)&v19);
        sub_C0AD8(&v19);
        Json::StyledWriter::indent((Json::StyledWriter *)v2, v13, v14);
        v15 = v22;
        while ( 1 )
        {
          v16 = (const Json::Value *)Json::Value::operator[]((int)v3, v15);
          Json::StyledWriter::writeCommentBeforeValue((Json::StyledWriter *)v2, v16);
          v17 = (const char *)*v15;
          ++v15;
          Json::valueToQuotedString((Json *)&v20, v17);
          Json::StyledWriter::writeWithIndent((Json::StyledWriter *)v2, (int)&v20);
          sub_C0AD8(&v20);
          sub_C14E4(v2 + 4, " : ");
          Json::StyledWriter::writeValue((Json::StyledWriter *)v2, v16);
          if ( v23 == v15 )
            break;
          sub_C14E4(v2 + 4, ",");
          Json::StyledWriter::writeCommentAfterValueOnSameLine((Json::StyledWriter *)v2, v16);
        }
        Json::StyledWriter::writeCommentAfterValueOnSameLine((Json::StyledWriter *)v2, v16);
        Json::StyledWriter::unindent((Json::StyledWriter *)v2);
        sub_C1C58((void **)&v21, "}");
        Json::StyledWriter::writeWithIndent((Json::StyledWriter *)v2, (int)&v21);
        v12 = &v21;
      }
      sub_C0AD8(v12);
      result = std::vector<std::string,std::allocator<std::string>>::~vector((void **)&v22);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00056A80) --------------------------------------------------------
Json::StyledWriter *__fastcall Json::StyledWriter::write(Json::StyledWriter *this, const Json::Value *a2, const Json::Value *a3)
{
  unsigned int *v3; // r6
  const Json::Value *v4; // r4
  Json::StyledWriter *v5; // r7
  const Json::Value *v6; // r5

  v3 = (unsigned int *)((char *)a2 + 16);
  v4 = a2;
  v5 = this;
  v6 = a3;
  sub_C1034((int *)a2 + 4, &byte_E4496);
  *((_BYTE *)v4 + 32) = 0;
  sub_C1034((int *)v4 + 5, &byte_E4496);
  Json::StyledWriter::writeCommentBeforeValue(v4, v6);
  Json::StyledWriter::writeValue(v4, v6);
  Json::StyledWriter::writeCommentAfterValueOnSameLine(v4, v6);
  sub_C14E4(v3, "\n");
  sub_C16AC(v5, (int *)v3);
  return v5;
}
// E4496: using guessed type char byte_E4496;

//----- (00056AE4) --------------------------------------------------------
int __fastcall Json::StyledWriter::isMultineArray(Json::StyledWriter *this, const Json::Value *a2)
{
  Json::StyledWriter *v2; // r4
  const Json::Value *v3; // r8
  int v4; // r0
  int v5; // r7
  signed int v6; // r6
  int v7; // r5
  int i; // r7
  Json::Value *v9; // r9
  int v10; // r7
  const Json::Value *v11; // r0
  int v12; // r3
  int v13; // r5

  v2 = this;
  v3 = a2;
  v4 = Json::Value::size(a2);
  v5 = *((_DWORD *)v2 + 1);
  v6 = v4;
  v7 = 3 * v4 >= *((_DWORD *)v2 + 6);
  std::_Destroy_aux<false>::__destroy<std::string *>(*((_DWORD **)v2 + 1), *((_DWORD **)v2 + 2));
  *((_DWORD *)v2 + 2) = v5;
  for ( i = 0; i < v6; ++i )
  {
    if ( v7 )
      return v7;
    v9 = (Json::Value *)Json::Value::operator[]((int)v3, i);
    if ( Json::Value::isArray(v9) || Json::Value::isObject(v9) )
      v7 = Json::Value::size(v9) != 0;
  }
  if ( !v7 )
  {
    std::vector<std::string,std::allocator<std::string>>::reserve((int)v2 + 4, v6);
    *((_BYTE *)v2 + 32) = 1;
    v10 = 2 * (v6 + 1);
    while ( v7 < v6 )
    {
      v11 = (const Json::Value *)Json::Value::operator[]((int)v3, v7);
      Json::StyledWriter::writeValue(v2, v11);
      v12 = *(_DWORD *)(*((_DWORD *)v2 + 1) + 4 * v7++);
      v10 += *(_DWORD *)(v12 - 12);
    }
    v13 = *((_DWORD *)v2 + 6);
    *((_BYTE *)v2 + 32) = 0;
    v7 = v10 >= v13;
  }
  return v7;
}

//----- (00056B92) --------------------------------------------------------
void __fastcall Json::StyledStreamWriter::pushValue(int a1, int *a2)
{
  if ( *(_BYTE *)(a1 + 28) )
    std::vector<std::string,std::allocator<std::string>>::push_back(a1, a2);
  else
    sub_AAE2C(*(int **)(a1 + 12), a2);
}

//----- (00056BA0) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::writeArrayValue(Json::StyledStreamWriter *this, const Json::Value *a2)
{
  Json::StyledStreamWriter *v2; // r4
  const Json::Value *v3; // r11
  int v4; // r10
  int v5; // r5
  int v6; // r6
  const Json::Value *v7; // r7
  int v8; // r2
  int *v10; // r1
  int v11; // [sp+0h] [bp-38h]
  int v12; // [sp+4h] [bp-34h]
  char v13; // [sp+Ch] [bp-2Ch]

  v2 = this;
  v3 = a2;
  v4 = Json::Value::size(a2);
  if ( !v4 )
  {
    sub_C1C58((void **)&v13, "[]");
    Json::StyledStreamWriter::pushValue((int)v2, (int *)&v13);
    return sub_C0AD8(&v13);
  }
  v5 = Json::StyledStreamWriter::isMultineArray(v2, v3);
  if ( v5 )
  {
    sub_C1C58((void **)&v13, "[");
    Json::StyledStreamWriter::writeWithIndent(v2, (int *)&v13);
    sub_C0AD8(&v13);
    Json::StyledStreamWriter::indent(v2);
    v6 = 0;
    v11 = *(_DWORD *)v2;
    v12 = *((_DWORD *)v2 + 1);
    while ( 1 )
    {
      v7 = (const Json::Value *)Json::Value::operator[]((int)v3, v6);
      Json::StyledStreamWriter::writeCommentBeforeValue(v2, v7, v8);
      if ( v11 == v12 )
      {
        Json::StyledStreamWriter::writeIndent(v2);
        Json::StyledStreamWriter::writeValue(v2, v7);
      }
      else
      {
        Json::StyledStreamWriter::writeWithIndent(v2, (int *)(*(_DWORD *)v2 + 4 * v6));
      }
      if ( ++v6 == v4 )
        break;
      sub_B7130(*((int **)v2 + 3), ",");
      Json::StyledStreamWriter::writeCommentAfterValueOnSameLine(v2, v7);
    }
    Json::StyledStreamWriter::writeCommentAfterValueOnSameLine(v2, v7);
    Json::StyledStreamWriter::unindent(v2);
    sub_C1C58((void **)&v13, "]");
    Json::StyledStreamWriter::writeWithIndent(v2, (int *)&v13);
    return sub_C0AD8(&v13);
  }
  sub_B7130(*((int **)v2 + 3), "[ ");
  while ( 1 )
  {
    v10 = (int *)(*(_DWORD *)v2 + 4 * v5++);
    sub_AAE2C(*((int **)v2 + 3), v10);
    if ( v5 == v4 )
      break;
    if ( v5 )
      sub_B7130(*((int **)v2 + 3), ", ");
  }
  return sub_B7130(*((int **)v2 + 3), " ]");
}

//----- (00056CF4) --------------------------------------------------------
void *__fastcall Json::StyledStreamWriter::writeValue(Json::StyledStreamWriter *this, const Json::Value *a2)
{
  int **v2; // r4
  Json::Value *v3; // r5
  void *result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r0
  signed int v8; // r0
  __int64 v9; // r0
  const char *v10; // r0
  int v11; // r0
  char *v12; // r0
  int *v13; // r8
  const char **v14; // ST00_4
  const Json::Value *v15; // r9
  int v16; // r2
  void *v17; // [sp+Ch] [bp-44h]
  void *v18; // [sp+10h] [bp-40h]
  int v19; // [sp+14h] [bp-3Ch]
  void *v20; // [sp+18h] [bp-38h]
  int *v21; // [sp+1Ch] [bp-34h]
  int *v22; // [sp+20h] [bp-30h]

  v2 = (int **)this;
  v3 = a2;
  result = (void *)Json::Value::type(a2);
  switch ( (unsigned int)result )
  {
    case 0u:
      sub_C1C58((void **)&v21, "null");
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
      goto LABEL_8;
    case 1u:
      v7 = Json::Value::asInt(v3, v5);
      Json::valueToString((Json *)&v21, v7);
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
      goto LABEL_8;
    case 2u:
      v8 = Json::Value::asUInt(v3, v5);
      Json::valueToString((Json *)&v21, v8);
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
      goto LABEL_8;
    case 3u:
      v9 = Json::Value::asDouble(v3, v5, v6);
      Json::valueToString((Json *)&v21, SHIDWORD(v9), *(double *)&v9);
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
      goto LABEL_8;
    case 4u:
      v10 = (const char *)Json::Value::asCString(v3);
      Json::valueToQuotedString((Json *)&v21, v10);
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
      goto LABEL_8;
    case 5u:
      v11 = Json::Value::asBool(v3);
      Json::valueToString((Json *)&v21, v11);
      Json::StyledStreamWriter::pushValue((int)v2, (int *)&v21);
LABEL_8:
      result = sub_C0AD8(&v21);
      break;
    case 6u:
      result = Json::StyledStreamWriter::writeArrayValue((Json::StyledStreamWriter *)v2, v3);
      break;
    case 7u:
      Json::Value::getMemberNames((Json::Value *)&v21, (unsigned __int8 *)v3);
      if ( v21 == v22 )
      {
        sub_C1C58(&v17, "{}");
        Json::StyledStreamWriter::pushValue((int)v2, (int *)&v17);
        v12 = (char *)&v17;
      }
      else
      {
        sub_C1C58(&v18, "{");
        Json::StyledStreamWriter::writeWithIndent((Json::StyledStreamWriter *)v2, (int *)&v18);
        sub_C0AD8(&v18);
        Json::StyledStreamWriter::indent((Json::StyledStreamWriter *)v2);
        v13 = v21;
        while ( 1 )
        {
          v14 = (const char **)v13;
          v15 = (const Json::Value *)Json::Value::operator[]((int)v3, v13);
          Json::StyledStreamWriter::writeCommentBeforeValue((Json::StyledStreamWriter *)v2, v15, v16);
          ++v13;
          Json::valueToQuotedString((Json *)&v19, *v14);
          Json::StyledStreamWriter::writeWithIndent((Json::StyledStreamWriter *)v2, &v19);
          sub_C0AD8(&v19);
          sub_B7130(v2[3], " : ");
          Json::StyledStreamWriter::writeValue((Json::StyledStreamWriter *)v2, v15);
          if ( v22 == v13 )
            break;
          sub_B7130(v2[3], ",");
          Json::StyledStreamWriter::writeCommentAfterValueOnSameLine((Json::StyledStreamWriter *)v2, v15);
        }
        Json::StyledStreamWriter::writeCommentAfterValueOnSameLine((Json::StyledStreamWriter *)v2, v15);
        Json::StyledStreamWriter::unindent((Json::StyledStreamWriter *)v2);
        sub_C1C58(&v20, "}");
        Json::StyledStreamWriter::writeWithIndent((Json::StyledStreamWriter *)v2, (int *)&v20);
        v12 = (char *)&v20;
      }
      sub_C0AD8(v12);
      result = std::vector<std::string,std::allocator<std::string>>::~vector((void **)&v21);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00056F00) --------------------------------------------------------
int *__fastcall Json::StyledStreamWriter::write(int a1, int a2, const Json::Value *a3)
{
  const Json::Value *v3; // r5
  int **v4; // r4
  int v5; // r0
  int v6; // r2
  int *result; // r0

  v3 = a3;
  *(_DWORD *)(a1 + 12) = a2;
  v4 = (int **)a1;
  v5 = a1 + 16;
  *(_BYTE *)(v5 + 12) = 0;
  sub_C1034((int *)v5, &byte_E4496);
  Json::StyledStreamWriter::writeCommentBeforeValue((Json::StyledStreamWriter *)v4, v3, v6);
  Json::StyledStreamWriter::writeValue((Json::StyledStreamWriter *)v4, v3);
  Json::StyledStreamWriter::writeCommentAfterValueOnSameLine((Json::StyledStreamWriter *)v4, v3);
  result = sub_B7130(v4[3], "\n");
  v4[3] = 0;
  return result;
}
// E4496: using guessed type char byte_E4496;

//----- (00056F44) --------------------------------------------------------
int __fastcall Json::operator<<(int a1, const Json::Value *a2)
{
  const Json::Value *v2; // r7
  int v3; // r6
  void *v5; // [sp+4h] [bp-3Ch]
  char v6; // [sp+8h] [bp-38h]

  v2 = a2;
  v3 = a1;
  sub_C1C58(&v5, "\t");
  Json::StyledStreamWriter::StyledStreamWriter(&v6, (int *)&v5);
  sub_C0AD8(&v5);
  Json::StyledStreamWriter::write((int)&v6, v3, v2);
  Json::StyledStreamWriter::~StyledStreamWriter((Json::StyledStreamWriter *)&v6);
  return v3;
}

//----- (00056F98) --------------------------------------------------------
int __fastcall Json::StyledStreamWriter::isMultineArray(Json::StyledStreamWriter *this, const Json::Value *a2)
{
  Json::StyledStreamWriter *v2; // r4
  const Json::Value *v3; // r8
  int v4; // r0
  _DWORD *v5; // r7
  signed int v6; // r6
  int v7; // r5
  int i; // r7
  Json::Value *v9; // r9
  int v10; // r7
  const Json::Value *v11; // r0
  int v12; // r3
  int v13; // r5

  v2 = this;
  v3 = a2;
  v4 = Json::Value::size(a2);
  v5 = *(_DWORD **)v2;
  v6 = v4;
  v7 = 3 * v4 >= *((_DWORD *)v2 + 5);
  std::_Destroy_aux<false>::__destroy<std::string *>(*(_DWORD **)v2, *((_DWORD **)v2 + 1));
  *((_DWORD *)v2 + 1) = v5;
  for ( i = 0; i < v6; ++i )
  {
    if ( v7 )
      return v7;
    v9 = (Json::Value *)Json::Value::operator[]((int)v3, i);
    if ( Json::Value::isArray(v9) || Json::Value::isObject(v9) )
      v7 = Json::Value::size(v9) != 0;
  }
  if ( !v7 )
  {
    std::vector<std::string,std::allocator<std::string>>::reserve((int)v2, v6);
    *((_BYTE *)v2 + 28) = 1;
    v10 = 2 * (v6 + 1);
    while ( v7 < v6 )
    {
      v11 = (const Json::Value *)Json::Value::operator[]((int)v3, v7);
      Json::StyledStreamWriter::writeValue(v2, v11);
      v12 = *(_DWORD *)(*(_DWORD *)v2 + 4 * v7++);
      v10 += *(_DWORD *)(v12 - 12);
    }
    v13 = *((_DWORD *)v2 + 5);
    *((_BYTE *)v2 + 28) = 0;
    v7 = v10 >= v13;
  }
  return v7;
}

//----- (00057042) --------------------------------------------------------
size_t __fastcall RegularInfo::clone(int a1, int a2)
{
  const void *v2; // r6
  int v3; // r5
  int v4; // r4
  size_t v5; // r0
  size_t result; // r0

  v2 = (const void *)(a1 + 192);
  v3 = a1;
  v4 = a2;
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a2 + 176) = *(_QWORD *)(a1 + 176);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 184) = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a2 + 188) = *(_DWORD *)(a1 + 188);
  *(_QWORD *)(a2 + 152) = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(a2 + 168) = *(_QWORD *)(a1 + 168);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a2 + 96) = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a2 + 112) = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a2 + 120) = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a2 + 128) = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a2 + 136) = *(_QWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 144);
  *(_QWORD *)(a2 + 160) = *(_QWORD *)(a1 + 160);
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(a2 + 216) = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(a2 + 220) = *(_DWORD *)(a1 + 220);
  v5 = strlen((const char *)(a1 + 192));
  memmove((void *)(v4 + 192), v2, v5);
  result = strlen((const char *)v2) + v4;
  *(_BYTE *)(result + 192) = 0;
  *(_DWORD *)(v4 + 232) = *(_DWORD *)(v3 + 232);
  *(_DWORD *)(v4 + 236) = *(_DWORD *)(v3 + 236);
  *(_DWORD *)(v4 + 240) = *(_DWORD *)(v3 + 240);
  *(_DWORD *)(v4 + 244) = *(_DWORD *)(v3 + 244);
  *(_DWORD *)(v4 + 336) = *(_DWORD *)(v3 + 336);
  *(_DWORD *)(v4 + 340) = *(_DWORD *)(v3 + 340);
  *(_DWORD *)(v4 + 344) = *(_DWORD *)(v3 + 344);
  *(_DWORD *)(v4 + 348) = *(_DWORD *)(v3 + 348);
  *(_DWORD *)(v4 + 248) = *(_DWORD *)(v3 + 248);
  *(_DWORD *)(v4 + 252) = *(_DWORD *)(v3 + 252);
  *(_DWORD *)(v4 + 256) = *(_DWORD *)(v3 + 256);
  *(_DWORD *)(v4 + 260) = *(_DWORD *)(v3 + 260);
  *(_DWORD *)(v4 + 264) = *(_DWORD *)(v3 + 264);
  *(_DWORD *)(v4 + 268) = *(_DWORD *)(v3 + 268);
  *(_DWORD *)(v4 + 272) = *(_DWORD *)(v3 + 272);
  *(_DWORD *)(v4 + 276) = *(_DWORD *)(v3 + 276);
  *(_DWORD *)(v4 + 280) = *(_DWORD *)(v3 + 280);
  *(_DWORD *)(v4 + 284) = *(_DWORD *)(v3 + 284);
  *(_DWORD *)(v4 + 288) = *(_DWORD *)(v3 + 288);
  *(_DWORD *)(v4 + 292) = *(_DWORD *)(v3 + 292);
  *(_DWORD *)(v4 + 296) = *(_DWORD *)(v3 + 296);
  *(_DWORD *)(v4 + 300) = *(_DWORD *)(v3 + 300);
  *(_DWORD *)(v4 + 304) = *(_DWORD *)(v3 + 304);
  *(_DWORD *)(v4 + 308) = *(_DWORD *)(v3 + 308);
  *(_DWORD *)(v4 + 312) = *(_DWORD *)(v3 + 312);
  *(_DWORD *)(v4 + 316) = *(_DWORD *)(v3 + 316);
  *(_DWORD *)(v4 + 320) = *(_DWORD *)(v3 + 320);
  *(_DWORD *)(v4 + 324) = *(_DWORD *)(v3 + 324);
  *(_DWORD *)(v4 + 328) = *(_DWORD *)(v3 + 328);
  *(_DWORD *)(v4 + 332) = *(_DWORD *)(v3 + 332);
  *(_DWORD *)(v4 + 352) = *(_DWORD *)(v3 + 352);
  *(_DWORD *)(v4 + 356) = *(_DWORD *)(v3 + 356);
  *(_DWORD *)(v4 + 360) = *(_DWORD *)(v3 + 360);
  *(_DWORD *)(v4 + 364) = *(_DWORD *)(v3 + 364);
  *(_DWORD *)(v4 + 368) = *(_DWORD *)(v3 + 368);
  *(_DWORD *)(v4 + 372) = *(_DWORD *)(v3 + 372);
  *(_DWORD *)(v4 + 376) = *(_DWORD *)(v3 + 376);
  *(_DWORD *)(v4 + 380) = *(_DWORD *)(v3 + 380);
  *(_DWORD *)(v4 + 384) = *(_DWORD *)(v3 + 384);
  *(_DWORD *)(v4 + 388) = *(_DWORD *)(v3 + 388);
  *(_DWORD *)(v4 + 392) = *(_DWORD *)(v3 + 392);
  *(_DWORD *)(v4 + 396) = *(_DWORD *)(v3 + 396);
  *(_DWORD *)(v4 + 400) = *(_DWORD *)(v3 + 400);
  *(_DWORD *)(v4 + 404) = *(_DWORD *)(v3 + 404);
  *(_DWORD *)(v4 + 408) = *(_DWORD *)(v3 + 408);
  *(_DWORD *)(v4 + 412) = *(_DWORD *)(v3 + 412);
  *(_DWORD *)(v4 + 416) = *(_DWORD *)(v3 + 416);
  *(_DWORD *)(v4 + 420) = *(_DWORD *)(v3 + 420);
  *(_DWORD *)(v4 + 424) = *(_DWORD *)(v3 + 424);
  *(_DWORD *)(v4 + 428) = *(_DWORD *)(v3 + 428);
  *(_DWORD *)(v4 + 432) = *(_DWORD *)(v3 + 432);
  *(_DWORD *)(v4 + 436) = *(_DWORD *)(v3 + 436);
  *(_DWORD *)(v4 + 440) = *(_DWORD *)(v3 + 440);
  *(_DWORD *)(v4 + 444) = *(_DWORD *)(v3 + 444);
  *(_DWORD *)(v4 + 448) = *(_DWORD *)(v3 + 448);
  *(_DWORD *)(v4 + 452) = *(_DWORD *)(v3 + 452);
  *(_DWORD *)(v4 + 456) = *(_DWORD *)(v3 + 456);
  *(_DWORD *)(v4 + 460) = *(_DWORD *)(v3 + 460);
  *(_DWORD *)(v4 + 464) = *(_DWORD *)(v3 + 464);
  *(_DWORD *)(v4 + 468) = *(_DWORD *)(v3 + 468);
  *(_DWORD *)(v4 + 472) = *(_DWORD *)(v3 + 472);
  *(_DWORD *)(v4 + 476) = *(_DWORD *)(v3 + 476);
  *(_DWORD *)(v4 + 480) = *(_DWORD *)(v3 + 480);
  *(_DWORD *)(v4 + 484) = *(_DWORD *)(v3 + 484);
  *(_DWORD *)(v4 + 488) = *(_DWORD *)(v3 + 488);
  *(_DWORD *)(v4 + 492) = *(_DWORD *)(v3 + 492);
  *(_DWORD *)(v4 + 496) = *(_DWORD *)(v3 + 496);
  *(_DWORD *)(v4 + 500) = *(_DWORD *)(v3 + 500);
  *(_DWORD *)(v4 + 504) = *(_DWORD *)(v3 + 504);
  *(_DWORD *)(v4 + 508) = *(_DWORD *)(v3 + 508);
  *(_DWORD *)(v4 + 512) = *(_DWORD *)(v3 + 512);
  *(_DWORD *)(v4 + 516) = *(_DWORD *)(v3 + 516);
  *(_DWORD *)(v4 + 520) = *(_DWORD *)(v3 + 520);
  *(_DWORD *)(v4 + 524) = *(_DWORD *)(v3 + 524);
  *(_DWORD *)(v4 + 528) = *(_DWORD *)(v3 + 528);
  *(_DWORD *)(v4 + 532) = *(_DWORD *)(v3 + 532);
  *(_DWORD *)(v4 + 536) = *(_DWORD *)(v3 + 536);
  *(_DWORD *)(v4 + 540) = *(_DWORD *)(v3 + 540);
  *(_DWORD *)(v4 + 544) = *(_DWORD *)(v3 + 544);
  *(_DWORD *)(v4 + 548) = *(_DWORD *)(v3 + 548);
  *(_DWORD *)(v4 + 552) = *(_DWORD *)(v3 + 552);
  *(_DWORD *)(v4 + 556) = *(_DWORD *)(v3 + 556);
  *(_DWORD *)(v4 + 560) = *(_DWORD *)(v3 + 560);
  *(_DWORD *)(v4 + 564) = *(_DWORD *)(v3 + 564);
  *(_DWORD *)(v4 + 568) = *(_DWORD *)(v3 + 568);
  *(_DWORD *)(v4 + 572) = *(_DWORD *)(v3 + 572);
  *(_DWORD *)(v4 + 576) = *(_DWORD *)(v3 + 576);
  *(_DWORD *)(v4 + 580) = *(_DWORD *)(v3 + 580);
  *(_DWORD *)(v4 + 584) = *(_DWORD *)(v3 + 584);
  *(_DWORD *)(v4 + 588) = *(_DWORD *)(v3 + 588);
  *(_DWORD *)(v4 + 592) = *(_DWORD *)(v3 + 592);
  *(_QWORD *)(v4 + 600) = *(_QWORD *)(v3 + 600);
  *(_QWORD *)(v4 + 608) = *(_QWORD *)(v3 + 608);
  *(_QWORD *)(v4 + 616) = *(_QWORD *)(v3 + 616);
  *(_QWORD *)(v4 + 624) = *(_QWORD *)(v3 + 624);
  *(_QWORD *)(v4 + 632) = *(_QWORD *)(v3 + 632);
  *(_QWORD *)(v4 + 640) = *(_QWORD *)(v3 + 640);
  *(_QWORD *)(v4 + 648) = *(_QWORD *)(v3 + 648);
  *(_QWORD *)(v4 + 656) = *(_QWORD *)(v3 + 656);
  *(_QWORD *)(v4 + 664) = *(_QWORD *)(v3 + 664);
  *(_QWORD *)(v4 + 672) = *(_QWORD *)(v3 + 672);
  *(_QWORD *)(v4 + 680) = *(_QWORD *)(v3 + 680);
  *(_QWORD *)(v4 + 688) = *(_QWORD *)(v3 + 688);
  *(_QWORD *)(v4 + 696) = *(_QWORD *)(v3 + 696);
  *(_QWORD *)(v4 + 704) = *(_QWORD *)(v3 + 704);
  *(_QWORD *)(v4 + 712) = *(_QWORD *)(v3 + 712);
  *(_QWORD *)(v4 + 720) = *(_QWORD *)(v3 + 712);
  *(_DWORD *)(v4 + 728) = *(_DWORD *)(v3 + 728);
  *(_DWORD *)(v4 + 732) = *(_DWORD *)(v3 + 732);
  return result;
}

//----- (000574B8) --------------------------------------------------------
int generateDataRate(void)
{
  pthread_t v0; // r0
  int v1; // r6
  int result; // r0

  v0 = pthread_self();
  v1 = 0;
  result = pthread_detach(v0);
  while ( dword_2F6194 == 1 )
  {
    if ( v1 % 10 == 9 )
    {
      cdnDownloadRate = (signed int)(currentSecondInfo - lastSecondInfo);
      tdnDownloadRate = (signed int)(unk_2F60B8 - unk_2F6398);
      p2pDownloadRate = (signed int)((double)(signed int)(unk_2F60E8 - unk_2F63C8)
                                   + (double)tdnDownloadRate
                                   + unk_2F6158
                                   - unk_2F6438
                                   - (unk_2F6100
                                    - unk_2F63E0)
                                   - (unk_2F6118
                                    - unk_2F63F8)
                                   - (unk_2F60F0
                                    - unk_2F63D0)
                                   - (unk_2F60F8
                                    - unk_2F63D8));
      p2pUploadRate = (signed int)(unk_2F60C8 - unk_2F63A8);
      RegularInfo::clone((int)&currentSecondInfo, (int)&lastSecondInfo);
    }
    ++v1;
    result = usleep((__useconds_t)"");
  }
  return result;
}
// 2F609C: using guessed type int tdnDownloadRate;
// 2F60A0: using guessed type int p2pUploadRate;
// 2F60A4: using guessed type int cdnDownloadRate;
// 2F60A8: using guessed type int p2pDownloadRate;
// 2F6194: using guessed type int dword_2F6194;

//----- (000575D8) --------------------------------------------------------
__int64 __fastcall RegularInfo::reset(RegularInfo *this)
{
  RegularInfo *v1; // r4
  __int64 result; // r0

  v1 = this;
  RegularInfo::resetRegularStatistic(this);
  *((_QWORD *)v1 + 5) = getTime();
  result = getTime();
  *((_QWORD *)v1 + 4) = result;
  return result;
}

//----- (000575F2) --------------------------------------------------------
int __fastcall ThreadManager::removeThreadInfo(ThreadManager *this, int a2)
{
  pthread_mutex_t *v2; // r4
  int v3; // r5
  _DWORD *v4; // r2
  _DWORD *i; // r0

  v2 = (pthread_mutex_t *)this;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)this);
  v4 = (_DWORD *)v2->__count;
  for ( i = (_DWORD *)v4[2]; i; i = (_DWORD *)i[2] )
  {
    if ( *i == v3 )
    {
      v4[2] = i[2];
      operator delete(i);
      return j_pthread_mutex_unlock(v2);
    }
    v4 = i;
  }
  return j_pthread_mutex_unlock(v2);
}

//----- (00057620) --------------------------------------------------------
int __fastcall ThreadManager::saveThreadInfo(pthread_mutex_t *a1, int a2, int a3)
{
  pthread_mutex_t *v3; // r4
  int v4; // r5
  int v5; // r6
  _DWORD *v6; // r3
  _DWORD *v8; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  pthread_mutex_lock(a1);
  v6 = (_DWORD *)v3->__count;
  while ( 1 )
  {
    v6 = (_DWORD *)v6[2];
    if ( !v6 )
      break;
    if ( *v6 == v4 )
    {
      *v6 = v4;
      v6[1] = v5;
      return j_pthread_mutex_unlock(v3);
    }
  }
  v8 = operator new(0xCu);
  *v8 = v4;
  v8[1] = v5;
  v8[2] = *(_DWORD *)(v3->__count + 8);
  *(_DWORD *)(v3->__count + 8) = v8;
  return j_pthread_mutex_unlock(v3);
}

//----- (0005765C) --------------------------------------------------------
char *__fastcall resetReportUrl(char *a1)
{
  return j_strcpy(reportURL, a1);
}

//----- (0005766C) --------------------------------------------------------
int __fastcall addXcdbBytes(int result)
{
  dbl_F4280[1] = dbl_F4280[1] + (double)result;
  dbl_F4280[0] = dbl_F4280[0] + (double)result;
  unk_2F6158 = unk_2F6158 + (double)result;
  return result;
}

//----- (000576B0) --------------------------------------------------------
int __fastcall consumeXBytes(int result)
{
  dbl_F4280[0] = dbl_F4280[0] - (double)result;
  return result;
}

//----- (000576D0) --------------------------------------------------------
int __fastcall addXWriteFifoBytes(int result)
{
  dbl_F4280[2] = dbl_F4280[2] + (double)result;
  return result;
}

//----- (000576F0) --------------------------------------------------------
int __fastcall addCurrentPeerNum(int result)
{
  unk_F4278 = unk_F4278 + (double)result;
  return result;
}

//----- (00057710) --------------------------------------------------------
int __fastcall addCurrentPieceLength(int result)
{
  unk_F4268 = unk_F4268 + (double)result;
  return result;
}

//----- (00057730) --------------------------------------------------------
int __fastcall addCurrentPieceNum(int a1)
{
  int result; // r0

  result = a1 + dword_F4270;
  dword_F4270 = result;
  return result;
}
// F4270: using guessed type int dword_F4270;

//----- (00057748) --------------------------------------------------------
int __fastcall addWriteFifoBytes(int result)
{
  unk_F4210 = unk_F4210 + (double)result;
  return result;
}

//----- (00057768) --------------------------------------------------------
int __fastcall addCdnDownloadBytes(int result)
{
  currentChannelInfo = currentChannelInfo + (double)result;
  currentSecondInfo = currentSecondInfo + (double)result;
  return result;
}

//----- (000577A0) --------------------------------------------------------
int __fastcall addTdnDownloadBytes(int result)
{
  unk_F41E8 = unk_F41E8 + (double)result;
  unk_2F60B8 = unk_2F60B8 + (double)result;
  return result;
}

//----- (000577D8) --------------------------------------------------------
int __fastcall addP2pDownloadBytes(int result)
{
  unk_F41F0 = unk_F41F0 + (double)result;
  unk_2F60C0 = unk_2F60C0 + (double)result;
  return result;
}

//----- (00057810) --------------------------------------------------------
int __fastcall addP2pUploadBytes(int result)
{
  unk_F41F8 = unk_F41F8 + (double)result;
  unk_2F60C8 = unk_2F60C8 + (double)result;
  return result;
}

//----- (00057848) --------------------------------------------------------
int __fastcall addP2pDownloadAvailableBytes(int result)
{
  unk_F4218 = unk_F4218 + (double)result;
  unk_2F60E8 = unk_2F60E8 + (double)result;
  return result;
}

//----- (00057880) --------------------------------------------------------
int __fastcall consumeBytes(int result)
{
  --dword_F4270;
  unk_F4268 = unk_F4268 - (double)result;
  return result;
}
// F4270: using guessed type int dword_F4270;

//----- (000578AC) --------------------------------------------------------
int __fastcall addCdnAndP2PDuplicateBytes(int result)
{
  unk_F4220 = unk_F4220 + (double)result;
  unk_2F60F0 = unk_2F60F0 + (double)result;
  return result;
}

//----- (000578E4) --------------------------------------------------------
int __fastcall addCdnAndThirdDuplicateBytes(int result)
{
  unk_F4228 = unk_F4228 + (double)result;
  unk_2F60F8 = unk_2F60F8 + (double)result;
  return result;
}

//----- (0005791C) --------------------------------------------------------
int __fastcall addThirdAndCDNDuplicateBytes(int result)
{
  unk_F4238 = unk_F4238 + (double)result;
  unk_2F6108 = unk_2F6108 + (double)result;
  return result;
}

//----- (00057954) --------------------------------------------------------
int __fastcall addThirdAndP2PDuplicateBytes(int result)
{
  unk_F4230 = unk_F4230 + (double)result;
  unk_2F6100 = unk_2F6100 + (double)result;
  return result;
}

//----- (0005798C) --------------------------------------------------------
int __fastcall addP2PAndCDNDuplicateBytes(int result)
{
  unk_F4240 = unk_F4240 + (double)result;
  unk_2F6110 = unk_2F6110 + (double)result;
  return result;
}

//----- (000579C4) --------------------------------------------------------
int __fastcall addP2PAndThirdDuplicateBytes(int result)
{
  unk_F4248 = unk_F4248 + (double)result;
  unk_2F6118 = unk_2F6118 + (double)result;
  return result;
}

//----- (000579FC) --------------------------------------------------------
int __fastcall addIncompleteP2PBytes(int result)
{
  unk_F4250 = unk_F4250 + (double)result;
  return result;
}

//----- (00057A1C) --------------------------------------------------------
int __fastcall addIncompleteP2PBeginContinuousBytes(int result)
{
  unk_F4258 = unk_F4258 + (double)result;
  return result;
}

//----- (00057A3C) --------------------------------------------------------
int __fastcall addRtmpDownloadBytes(int result)
{
  unk_F4260 = unk_F4260 + (double)result;
  return result;
}

//----- (00057A5C) --------------------------------------------------------
void addConnection(void)
{
  ++dword_F42B4;
}
// F42B4: using guessed type int dword_F42B4;

//----- (00057A74) --------------------------------------------------------
void deleteConnection(void)
{
  --dword_F42B4;
}
// F42B4: using guessed type int dword_F42B4;

//----- (00057A8C) --------------------------------------------------------
int __fastcall addFlvCDNRecveiveTime(unsigned __int64 a1)
{
  int result; // r0

  result = a1 + dword_F42C0;
  dword_F42C0 = result;
  return result;
}
// F42C0: using guessed type int dword_F42C0;

//----- (00057AA4) --------------------------------------------------------
__int64 getPlayerStartTime(void)
{
  return unk_F4200;
}

//----- (00057AB4) --------------------------------------------------------
int fsdReportLock(void)
{
  return j_pthread_mutex_lock((pthread_mutex_t *)&fsd_report_lock);
}

//----- (00057AC4) --------------------------------------------------------
int fsdReportUnlock(void)
{
  return j_pthread_mutex_unlock((pthread_mutex_t *)&fsd_report_lock);
}

//----- (00057AD4) --------------------------------------------------------
void setFsdCount(void)
{
  ++fsdCount;
}
// 2F8100: using guessed type int fsdCount;

//----- (00057AE8) --------------------------------------------------------
int getFsdCount(void)
{
  return fsdCount;
}
// 2F8100: using guessed type int fsdCount;

//----- (00057AF8) --------------------------------------------------------
int initAppStatistic(void)
{
  pthread_mutex_t *v0; // r4
  _DWORD *v1; // r0

  v0 = (pthread_mutex_t *)operator new(8u);
  v1 = operator new(0xCu);
  v0->__count = (unsigned int)v1;
  v1[2] = 0;
  pthread_mutex_init(v0, 0);
  threadManager = (int)v0;
  return j_pthread_mutex_init((pthread_mutex_t *)&stat_lock, 0);
}
// 2F6094: using guessed type int threadManager;

//----- (00057B40) --------------------------------------------------------
int finishSingleChannelStatistic(void)
{
  ioAllow = 0;
  dword_F42C4 = 5;
  dword_2F6194 = 5;
  pthread_mutex_destroy((pthread_mutex_t *)&fsd_report_lock);
  return ThreadManager::saveThreadInfo((pthread_mutex_t *)threadManager, channelReqularReportThread, 5);
}
// F41C4: using guessed type int ioAllow;
// F42C4: using guessed type int dword_F42C4;
// 2F6094: using guessed type int threadManager;
// 2F6194: using guessed type int dword_2F6194;
// 2F810C: using guessed type int channelReqularReportThread;

//----- (00057BA0) --------------------------------------------------------
int __fastcall generateRegularInfo(Json::Value *a1, RegularInfo *a2, RegularInfo *a3, int *a4, int *a5)
{
  RegularInfo *v5; // r6
  RegularInfo *v6; // r5
  Json::Value *v7; // r4
  int v8; // r9
  int v9; // s16
  int v10; // s17
  int v11; // r11
  int v12; // s18
  int v13; // s19
  int v14; // s20
  int v15; // s21
  int v16; // s22
  int v17; // s23
  int v18; // s24
  int v19; // s25
  int v20; // s26
  int v21; // s27
  int v22; // s28
  int v23; // s29
  int v24; // s30
  int v25; // s31
  int *v26; // r7
  int *v27; // r11
  int *v28; // r7
  int *v29; // r9
  int *v30; // r9
  int *v31; // r7
  int *v32; // r7
  int *v33; // r7
  int *v34; // r7
  int *v35; // r7
  int *v36; // r7
  int *v37; // r7
  int *v38; // r7
  int *v39; // r7
  int *v40; // r7
  int *v41; // r7
  int *v42; // r7
  int *v43; // r7
  int *v44; // r7
  int *v45; // r7
  int *v46; // r7
  int *v47; // r7
  int *v48; // r7
  int v49; // r2
  int *v50; // r7
  int *v51; // r8
  int *v52; // r7
  int *v53; // r7
  int *v54; // r8
  int *v55; // r7
  int *v56; // r7
  int *v57; // r5
  int *v58; // r5
  int *v59; // r5
  int *v60; // r6
  int *v61; // r6
  int *v62; // r6
  int *v63; // r6
  int *v64; // r6
  int *v65; // r6
  int *v66; // r6
  int *v67; // r6
  int *v68; // r6
  int *v69; // r6
  int *v70; // r6
  int *v71; // r6
  int *v72; // r6
  int *v73; // r6
  int *v74; // r6
  int *v75; // r6
  int *v76; // r6
  int *v77; // r6
  int *v78; // r6
  int *v79; // r6
  int v80; // r2
  int *v81; // r6
  int *v82; // r6
  int *v83; // r6
  int v84; // r2
  int *v85; // r6
  int *v86; // r6
  int v87; // r2
  int *v88; // r6
  int *v89; // r6
  int v90; // r2
  int *v91; // r6
  int *v92; // r6
  int *v93; // r6
  int *v94; // r6
  int *v95; // r6
  int *v96; // r6
  int *v97; // r6
  int *v98; // r6
  int *v99; // r6
  int *v100; // r6
  int *v101; // r6
  int *v102; // r6
  int *v103; // r6
  int *v104; // r6
  int *v105; // r6
  int *v106; // r6
  int *v107; // r6
  int *v108; // r6
  int *v109; // r6
  int *v110; // r6
  int *v111; // r6
  int *v112; // r6
  int *v113; // r6
  int *v114; // r6
  int *v115; // r6
  int *v116; // r6
  int *v117; // r6
  int *v118; // r6
  int *v119; // r6
  int *v120; // r6
  int *v121; // r6
  int *v122; // r6
  int *v123; // r6
  int *v124; // r6
  int *v125; // r6
  int *v126; // r6
  int *v127; // r6
  int *v128; // r6
  int *v129; // r6
  int *v130; // r6
  int *v131; // r6
  int *v132; // r6
  int *v133; // r6
  int *v134; // r6
  int *v135; // r6
  int *v136; // r6
  int *v137; // r6
  int *v138; // r6
  int *v139; // r6
  int *v140; // r6
  int *v141; // r6
  int *v142; // r6
  int *v143; // r6
  int *v144; // r6
  int *v145; // r6
  int *v146; // r6
  int *v147; // r6
  int *v148; // r6
  int *v149; // r6
  int *v150; // r6
  int *v151; // r6
  int *v152; // r6
  int *v153; // r6
  int *v154; // r6
  int *v155; // r6
  int *v156; // r6
  int *v157; // r6
  int *v158; // r6
  int *v159; // r6
  int *v160; // r6
  int *v161; // r6
  int *v162; // r6
  int *v163; // r6
  int *v164; // r6
  int *v165; // r6
  int *v166; // r6
  int *v167; // r6
  int *v168; // r6
  int *v169; // r6
  int *v170; // r6
  int *v171; // r6
  int *v172; // r5
  signed int v174; // [sp+4h] [bp-28Ch]
  signed int v175; // [sp+8h] [bp-288h]
  signed int v176; // [sp+Ch] [bp-284h]
  signed int v177; // [sp+10h] [bp-280h]
  int v178; // [sp+14h] [bp-27Ch]
  int v179; // [sp+18h] [bp-278h]
  int v180; // [sp+1Ch] [bp-274h]
  int v181; // [sp+20h] [bp-270h]
  int v182; // [sp+24h] [bp-26Ch]
  int v183; // [sp+28h] [bp-268h]
  int v184; // [sp+2Ch] [bp-264h]
  int v185; // [sp+30h] [bp-260h]
  int v186; // [sp+34h] [bp-25Ch]
  int v187; // [sp+38h] [bp-258h]
  int v188; // [sp+3Ch] [bp-254h]
  int v189; // [sp+40h] [bp-250h]
  int v190; // [sp+44h] [bp-24Ch]
  int v191; // [sp+48h] [bp-248h]
  int v192; // [sp+4Ch] [bp-244h]
  int v193; // [sp+50h] [bp-240h]
  int v194; // [sp+54h] [bp-23Ch]
  int v195; // [sp+58h] [bp-238h]
  int v196; // [sp+5Ch] [bp-234h]
  int v197; // [sp+60h] [bp-230h]
  int v198; // [sp+64h] [bp-22Ch]
  int v199; // [sp+68h] [bp-228h]
  int v200; // [sp+6Ch] [bp-224h]
  int v201; // [sp+70h] [bp-220h]
  int v202; // [sp+74h] [bp-21Ch]
  int v203; // [sp+78h] [bp-218h]
  int v204; // [sp+7Ch] [bp-214h]
  int v205; // [sp+80h] [bp-210h]
  int v206; // [sp+84h] [bp-20Ch]
  int v207; // [sp+88h] [bp-208h]
  int v208; // [sp+8Ch] [bp-204h]
  int v209; // [sp+90h] [bp-200h]
  int v210; // [sp+94h] [bp-1FCh]
  int v211; // [sp+98h] [bp-1F8h]
  int v212; // [sp+9Ch] [bp-1F4h]
  int v213; // [sp+A0h] [bp-1F0h]
  int v214; // [sp+A4h] [bp-1ECh]
  int v215; // [sp+A8h] [bp-1E8h]
  int v216; // [sp+ACh] [bp-1E4h]
  int v217; // [sp+B0h] [bp-1E0h]
  int v218; // [sp+B4h] [bp-1DCh]
  int v219; // [sp+B8h] [bp-1D8h]
  int v220; // [sp+BCh] [bp-1D4h]
  int v221; // [sp+C0h] [bp-1D0h]
  int v222; // [sp+C4h] [bp-1CCh]
  int v223; // [sp+C8h] [bp-1C8h]
  int v224; // [sp+CCh] [bp-1C4h]
  int v225; // [sp+D0h] [bp-1C0h]
  int v226; // [sp+D4h] [bp-1BCh]
  int v227; // [sp+D8h] [bp-1B8h]
  int v228; // [sp+DCh] [bp-1B4h]
  int v229; // [sp+E0h] [bp-1B0h]
  int v230; // [sp+E4h] [bp-1ACh]
  int v231; // [sp+E8h] [bp-1A8h]
  int v232; // [sp+ECh] [bp-1A4h]
  int v233; // [sp+F0h] [bp-1A0h]
  int v234; // [sp+F4h] [bp-19Ch]
  int v235; // [sp+F8h] [bp-198h]
  int v236; // [sp+FCh] [bp-194h]
  int v237; // [sp+100h] [bp-190h]
  int v238; // [sp+104h] [bp-18Ch]
  int v239; // [sp+108h] [bp-188h]
  int v240; // [sp+10Ch] [bp-184h]
  int v241; // [sp+110h] [bp-180h]
  int v242; // [sp+114h] [bp-17Ch]
  int v243; // [sp+118h] [bp-178h]
  int v244; // [sp+11Ch] [bp-174h]
  int v245; // [sp+120h] [bp-170h]
  int v246; // [sp+124h] [bp-16Ch]
  int v247; // [sp+128h] [bp-168h]
  int v248; // [sp+12Ch] [bp-164h]
  int v249; // [sp+130h] [bp-160h]
  int v250; // [sp+134h] [bp-15Ch]
  int v251; // [sp+138h] [bp-158h]
  int v252; // [sp+13Ch] [bp-154h]
  int v253; // [sp+140h] [bp-150h]
  int v254; // [sp+144h] [bp-14Ch]
  int v255; // [sp+148h] [bp-148h]
  int v256; // [sp+14Ch] [bp-144h]
  int v257; // [sp+150h] [bp-140h]
  int v258; // [sp+154h] [bp-13Ch]
  int v259; // [sp+158h] [bp-138h]
  int v260; // [sp+15Ch] [bp-134h]
  int v261; // [sp+160h] [bp-130h]
  int v262; // [sp+164h] [bp-12Ch]
  int v263; // [sp+168h] [bp-128h]
  int v264; // [sp+16Ch] [bp-124h]
  int v265; // [sp+170h] [bp-120h]
  int v266; // [sp+174h] [bp-11Ch]
  int v267; // [sp+178h] [bp-118h]
  int v268; // [sp+17Ch] [bp-114h]
  int v269; // [sp+180h] [bp-110h]
  signed int v270; // [sp+184h] [bp-10Ch]
  signed int v271; // [sp+188h] [bp-108h]
  signed int v272; // [sp+18Ch] [bp-104h]
  signed int v273; // [sp+190h] [bp-100h]
  signed int v274; // [sp+194h] [bp-FCh]
  signed int v275; // [sp+198h] [bp-F8h]
  signed int v276; // [sp+19Ch] [bp-F4h]
  signed int v277; // [sp+1A0h] [bp-F0h]
  signed int v278; // [sp+1A4h] [bp-ECh]
  signed int v279; // [sp+1A8h] [bp-E8h]
  signed int v280; // [sp+1ACh] [bp-E4h]
  signed int v281; // [sp+1B0h] [bp-E0h]
  int v282; // [sp+1B4h] [bp-DCh]
  int v283; // [sp+1B8h] [bp-D8h]
  int v284; // [sp+1BCh] [bp-D4h]
  int v285; // [sp+1C0h] [bp-D0h]
  int v286; // [sp+1C4h] [bp-CCh]
  char v287; // [sp+1C8h] [bp-C8h]
  char s; // [sp+1DCh] [bp-B4h]
  char v289; // [sp+1F0h] [bp-A0h]

  v5 = a2;
  v6 = a3;
  v7 = a1;
  v178 = *((_DWORD *)a3 + 53);
  v8 = (signed int)(*((double *)a3 + 6) - *((double *)a2 + 6));
  v179 = *((_DWORD *)a3 + 56);
  v174 = (signed int)(*(double *)a3 - *(double *)a2);
  v175 = (signed int)(*((double *)a3 + 1) - *((double *)a2 + 1));
  v176 = (signed int)(*((double *)a3 + 2) - *((double *)a2 + 2));
  v9 = (signed int)(*((double *)a3 + 3) - *((double *)a2 + 3));
  v10 = (signed int)(*((double *)a3 + 7) - *((double *)a2 + 7));
  v11 = (signed int)(*((double *)a3 + 21) - *((double *)a2 + 21));
  v177 = (signed int)(*((double *)a3 + 22) - *((double *)a2 + 22));
  v12 = (signed int)((*((double *)a3 + 5) - *((double *)a2 + 5)) * 1000.0);
  v13 = (signed int)*((double *)a3 + 19);
  v14 = (signed int)(*((double *)a3 + 8) - *((double *)a2 + 8));
  v15 = (signed int)(*((double *)a3 + 9) - *((double *)a2 + 9));
  v16 = (signed int)(*((double *)a3 + 10) - *((double *)a2 + 10));
  v17 = (signed int)(*((double *)a3 + 11) - *((double *)a2 + 11));
  v18 = (signed int)(*((double *)a3 + 12) - *((double *)a2 + 12));
  v19 = (signed int)(*((double *)a3 + 13) - *((double *)a2 + 13));
  v20 = (signed int)(*((double *)a3 + 14) - *((double *)a2 + 14));
  v21 = (signed int)(*((double *)a3 + 15) - *((double *)a2 + 15));
  v180 = *((_DWORD *)a3 + 54);
  v181 = *((_DWORD *)a3 + 55);
  v22 = (signed int)(*((double *)a3 + 16) - *((double *)a2 + 16));
  memset(&s, 0, 0x14u);
  memset(&v289, 0, 0x32u);
  v182 = *((_DWORD *)v6 + 58) - *((_DWORD *)v5 + 58);
  v183 = *((_DWORD *)v6 + 59) - *((_DWORD *)v5 + 59);
  v184 = *((_DWORD *)v6 + 60) - *((_DWORD *)v5 + 60);
  v185 = *((_DWORD *)v6 + 61) - *((_DWORD *)v5 + 61);
  v186 = *((_DWORD *)v6 + 84) - *((_DWORD *)v5 + 84);
  v187 = *((_DWORD *)v6 + 85) - *((_DWORD *)v5 + 85);
  v188 = *((_DWORD *)v6 + 86) - *((_DWORD *)v5 + 86);
  v189 = *((_DWORD *)v6 + 87) - *((_DWORD *)v5 + 87);
  v190 = *((_DWORD *)v6 + 62) - *((_DWORD *)v5 + 62);
  v191 = *((_DWORD *)v6 + 63) - *((_DWORD *)v5 + 63);
  v192 = *((_DWORD *)v6 + 64) - *((_DWORD *)v5 + 64);
  v193 = *((_DWORD *)v6 + 65) - *((_DWORD *)v5 + 65);
  v194 = *((_DWORD *)v6 + 66) - *((_DWORD *)v5 + 66);
  v195 = *((_DWORD *)v6 + 67) - *((_DWORD *)v5 + 67);
  v196 = *((_DWORD *)v6 + 68) - *((_DWORD *)v5 + 68);
  v197 = *((_DWORD *)v6 + 69) - *((_DWORD *)v5 + 69);
  v198 = *((_DWORD *)v6 + 70) - *((_DWORD *)v5 + 70);
  v199 = *((_DWORD *)v6 + 71) - *((_DWORD *)v5 + 71);
  v286 = *((_DWORD *)v6 + 72) - *((_DWORD *)v5 + 72);
  v200 = *((_DWORD *)v6 + 73) - *((_DWORD *)v5 + 73);
  v201 = *((_DWORD *)v6 + 74) - *((_DWORD *)v5 + 74);
  v202 = *((_DWORD *)v6 + 75) - *((_DWORD *)v5 + 75);
  v203 = *((_DWORD *)v6 + 76) - *((_DWORD *)v5 + 76);
  v204 = *((_DWORD *)v6 + 77) - *((_DWORD *)v5 + 77);
  v205 = *((_DWORD *)v6 + 78) - *((_DWORD *)v5 + 78);
  v206 = *((_DWORD *)v6 + 79) - *((_DWORD *)v5 + 79);
  v207 = *((_DWORD *)v6 + 80) - *((_DWORD *)v5 + 80);
  v208 = *((_DWORD *)v6 + 83) - *((_DWORD *)v5 + 83);
  v209 = *((_DWORD *)v6 + 88) - *((_DWORD *)v5 + 88);
  v210 = *((_DWORD *)v6 + 89) - *((_DWORD *)v5 + 89);
  v211 = *((_DWORD *)v6 + 90) - *((_DWORD *)v5 + 90);
  v212 = *((_DWORD *)v6 + 91) - *((_DWORD *)v5 + 91);
  v213 = *((_DWORD *)v6 + 92) - *((_DWORD *)v5 + 92);
  v214 = *((_DWORD *)v6 + 93) - *((_DWORD *)v5 + 93);
  v215 = *((_DWORD *)v6 + 94) - *((_DWORD *)v5 + 94);
  v216 = *((_DWORD *)v6 + 95) - *((_DWORD *)v5 + 95);
  v217 = *((_DWORD *)v6 + 96) - *((_DWORD *)v5 + 96);
  v218 = *((_DWORD *)v6 + 97) - *((_DWORD *)v5 + 97);
  v219 = *((_DWORD *)v6 + 98) - *((_DWORD *)v5 + 98);
  v220 = *((_DWORD *)v6 + 99) - *((_DWORD *)v5 + 99);
  v221 = *((_DWORD *)v6 + 100) - *((_DWORD *)v5 + 100);
  v222 = *((_DWORD *)v6 + 101) - *((_DWORD *)v5 + 101);
  v223 = *((_DWORD *)v6 + 102) - *((_DWORD *)v5 + 102);
  v224 = *((_DWORD *)v6 + 103) - *((_DWORD *)v5 + 103);
  v225 = *((_DWORD *)v6 + 104) - *((_DWORD *)v5 + 104);
  v226 = *((_DWORD *)v6 + 105) - *((_DWORD *)v5 + 105);
  v227 = *((_DWORD *)v6 + 106) - *((_DWORD *)v5 + 106);
  v228 = *((_DWORD *)v6 + 107) - *((_DWORD *)v5 + 107);
  v229 = *((_DWORD *)v6 + 108) - *((_DWORD *)v5 + 108);
  v230 = *((_DWORD *)v6 + 109) - *((_DWORD *)v5 + 109);
  v231 = *((_DWORD *)v6 + 110) - *((_DWORD *)v5 + 110);
  v232 = *((_DWORD *)v6 + 111) - *((_DWORD *)v5 + 111);
  v233 = *((_DWORD *)v6 + 112) - *((_DWORD *)v5 + 112);
  v234 = *((_DWORD *)v6 + 113) - *((_DWORD *)v5 + 113);
  v235 = *((_DWORD *)v6 + 114) - *((_DWORD *)v5 + 114);
  v236 = *((_DWORD *)v6 + 115) - *((_DWORD *)v5 + 115);
  v237 = *((_DWORD *)v6 + 116) - *((_DWORD *)v5 + 116);
  v238 = *((_DWORD *)v6 + 117) - *((_DWORD *)v5 + 117);
  v239 = *((_DWORD *)v6 + 118) - *((_DWORD *)v5 + 118);
  v240 = *((_DWORD *)v6 + 119) - *((_DWORD *)v5 + 119);
  v241 = *((_DWORD *)v6 + 120) - *((_DWORD *)v5 + 120);
  v242 = *((_DWORD *)v6 + 121) - *((_DWORD *)v5 + 121);
  v243 = *((_DWORD *)v6 + 122) - *((_DWORD *)v5 + 122);
  v244 = *((_DWORD *)v6 + 123) - *((_DWORD *)v5 + 123);
  v245 = *((_DWORD *)v6 + 124) - *((_DWORD *)v5 + 124);
  v246 = *((_DWORD *)v6 + 125) - *((_DWORD *)v5 + 125);
  v247 = *((_DWORD *)v6 + 126) - *((_DWORD *)v5 + 126);
  v248 = *((_DWORD *)v6 + 127) - *((_DWORD *)v5 + 127);
  v249 = *((_DWORD *)v6 + 128) - *((_DWORD *)v5 + 128);
  v250 = *((_DWORD *)v6 + 129) - *((_DWORD *)v5 + 129);
  v251 = *((_DWORD *)v6 + 130) - *((_DWORD *)v5 + 130);
  v252 = *((_DWORD *)v6 + 131) - *((_DWORD *)v5 + 131);
  v253 = *((_DWORD *)v6 + 132) - *((_DWORD *)v5 + 132);
  v254 = *((_DWORD *)v6 + 133) - *((_DWORD *)v5 + 133);
  v255 = *((_DWORD *)v6 + 134) - *((_DWORD *)v5 + 134);
  v256 = *((_DWORD *)v6 + 135) - *((_DWORD *)v5 + 135);
  v257 = *((_DWORD *)v6 + 136) - *((_DWORD *)v5 + 136);
  v258 = *((_DWORD *)v6 + 137) - *((_DWORD *)v5 + 137);
  v259 = *((_DWORD *)v6 + 138) - *((_DWORD *)v5 + 138);
  v260 = *((_DWORD *)v6 + 139) - *((_DWORD *)v5 + 139);
  v261 = *((_DWORD *)v6 + 140) - *((_DWORD *)v5 + 140);
  v262 = *((_DWORD *)v6 + 141) - *((_DWORD *)v5 + 141);
  v263 = *((_DWORD *)v6 + 142) - *((_DWORD *)v5 + 142);
  v264 = *((_DWORD *)v6 + 143) - *((_DWORD *)v5 + 143);
  v265 = *((_DWORD *)v6 + 144) - *((_DWORD *)v5 + 144);
  v266 = *((_DWORD *)v6 + 145) - *((_DWORD *)v5 + 145);
  v23 = (signed int)(*((double *)v6 + 75) - *((double *)v5 + 75));
  v267 = *((_DWORD *)v6 + 146) - *((_DWORD *)v5 + 146);
  v268 = *((_DWORD *)v6 + 147) - *((_DWORD *)v5 + 147);
  v269 = *((_DWORD *)v6 + 148) - *((_DWORD *)v5 + 148);
  v24 = (signed int)(*((double *)v6 + 76) - *((double *)v5 + 76));
  v25 = (signed int)(*((double *)v6 + 77) - *((double *)v5 + 77));
  v270 = (signed int)(*((double *)v6 + 78) - *((double *)v5 + 78));
  v271 = (signed int)(*((double *)v6 + 79) - *((double *)v5 + 79));
  v272 = (signed int)(*((double *)v6 + 80) - *((double *)v5 + 80));
  v273 = (signed int)(*((double *)v6 + 81) - *((double *)v5 + 81));
  v274 = (signed int)(*((double *)v6 + 82) - *((double *)v5 + 82));
  v282 = *((_DWORD *)v6 + 182) - *((_DWORD *)v5 + 182);
  v283 = *((_DWORD *)v6 + 183) - *((_DWORD *)v5 + 183);
  v284 = *((_DWORD *)v6 + 81) - *((_DWORD *)v5 + 81);
  v275 = (signed int)(*((double *)v6 + 83) - *((double *)v5 + 83));
  v285 = *((_DWORD *)v6 + 82) - *((_DWORD *)v5 + 82);
  v276 = (signed int)(*((double *)v6 + 84) - *((double *)v5 + 84));
  v277 = (signed int)(*((double *)v6 + 85) - *((double *)v5 + 85));
  v278 = (signed int)(*((double *)v6 + 87) - *((double *)v5 + 87));
  v279 = (signed int)(*((double *)v6 + 88) - *((double *)v5 + 88));
  v280 = (signed int)(*((double *)v6 + 89) - *((double *)v5 + 89));
  v281 = (signed int)(*((double *)v6 + 90) - *((double *)v5 + 90));
  strcpy(&s, (const char *)v6 + 192);
  pthread_mutex_lock((pthread_mutex_t *)&stat_lock);
  if ( v11 > 0 )
  {
    v26 = Json::Value::operator[](v7, "xcdb");
    Json::Value::Value((int)&v287, v11);
    Json::Value::operator=((int)v26, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v177 > 0 )
  {
    v27 = Json::Value::operator[](v7, "xfifo");
    Json::Value::Value((int)&v287, v177);
    Json::Value::operator=((int)v27, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v8 > 0 )
  {
    v28 = Json::Value::operator[](v7, "fifo");
    Json::Value::Value((int)&v287, v8);
    Json::Value::operator=((int)v28, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v174 > 0 )
  {
    v29 = Json::Value::operator[](v7, "cdb");
    Json::Value::Value((int)&v287, v174);
    Json::Value::operator=((int)v29, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v175 > 0 )
  {
    v30 = Json::Value::operator[](v7, "tdb");
    Json::Value::Value((int)&v287, v175);
    Json::Value::operator=((int)v30, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v176 > 0 )
  {
    v31 = Json::Value::operator[](v7, "pdb");
    Json::Value::Value((int)&v287, v176);
    Json::Value::operator=((int)v31, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v9 > 0 )
  {
    v32 = Json::Value::operator[](v7, "ub");
    Json::Value::Value((int)&v287, v9);
    Json::Value::operator=((int)v32, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v10 > 0 )
  {
    v33 = Json::Value::operator[](v7, "pvb");
    Json::Value::Value((int)&v287, v10);
    Json::Value::operator=((int)v33, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v12 > 0 )
  {
    v34 = Json::Value::operator[](v7, "dl");
    Json::Value::Value((int)&v287, v12);
    Json::Value::operator=((int)v34, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v178 > 0 )
  {
    v35 = Json::Value::operator[](v7, "conn");
    Json::Value::Value((int)&v287, v178);
    Json::Value::operator=((int)v35, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v179 > 0 )
  {
    v36 = Json::Value::operator[](v7, "flvCDNRecveiveTime");
    Json::Value::Value((int)&v287, v179);
    Json::Value::operator=((int)v36, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v13 > 0 )
  {
    v37 = Json::Value::operator[](v7, "peerNum");
    Json::Value::Value((int)&v287, v13);
    Json::Value::operator=((int)v37, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v14 > 0 )
  {
    v38 = Json::Value::operator[](v7, "cdnP2pDup");
    Json::Value::Value((int)&v287, v14);
    Json::Value::operator=((int)v38, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v15 > 0 )
  {
    v39 = Json::Value::operator[](v7, "cdn3rdDup");
    Json::Value::Value((int)&v287, v15);
    Json::Value::operator=((int)v39, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v16 > 0 )
  {
    v40 = Json::Value::operator[](v7, "3rdP2pDup");
    Json::Value::Value((int)&v287, v16);
    Json::Value::operator=((int)v40, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v17 > 0 )
  {
    v41 = Json::Value::operator[](v7, "3rdCdnDup");
    Json::Value::Value((int)&v287, v17);
    Json::Value::operator=((int)v41, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v18 > 0 )
  {
    v42 = Json::Value::operator[](v7, "p2pCdnDup");
    Json::Value::Value((int)&v287, v18);
    Json::Value::operator=((int)v42, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v19 > 0 )
  {
    v43 = Json::Value::operator[](v7, "p2p3rdDup");
    Json::Value::Value((int)&v287, v19);
    Json::Value::operator=((int)v43, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v20 > 0 )
  {
    v44 = Json::Value::operator[](v7, "incompleteP2P");
    Json::Value::Value((int)&v287, v20);
    Json::Value::operator=((int)v44, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v21 > 0 )
  {
    v45 = Json::Value::operator[](v7, "incompleteP2PBeginContinuous");
    Json::Value::Value((int)&v287, v21);
    Json::Value::operator=((int)v45, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v22 > 0 )
  {
    v46 = Json::Value::operator[](v7, "rtmpdb");
    Json::Value::Value((int)&v287, v22);
    Json::Value::operator=((int)v46, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v174 > 0 )
  {
    v47 = Json::Value::operator[](v7, &s);
    Json::Value::Value((int)&v287, v174);
    Json::Value::operator=((int)v47, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  v48 = Json::Value::operator[](v7, "onlineSession");
  Json::Value::Value((int)&v287, 1);
  Json::Value::operator=((int)v48, (const Json::Value *)&v287);
  Json::Value::~Value((Json::Value *)&v287);
  v49 = *((_DWORD *)v6 + 57);
  if ( v49 == 4 || firstVout && v49 == 5 )
  {
    if ( currentPlayMode )
    {
      if ( currentPlayMode != 1 )
        goto LABEL_58;
      v54 = Json::Value::operator[](v7, "playerSession2");
      Json::Value::Value((int)&v287, 1);
      Json::Value::operator=((int)v54, (const Json::Value *)&v287);
    }
    else
    {
      v50 = Json::Value::operator[](v7, "playerSession");
      Json::Value::Value((int)&v287, 1);
      Json::Value::operator=((int)v50, (const Json::Value *)&v287);
      Json::Value::~Value((Json::Value *)&v287);
      switch ( currentStreamType )
      {
        case 2:
          v52 = Json::Value::operator[](v7, "nTsSession");
          Json::Value::Value((int)&v287, 1);
          Json::Value::operator=((int)v52, (const Json::Value *)&v287);
          break;
        case 3:
          v53 = Json::Value::operator[](v7, "nDirectSession");
          Json::Value::Value((int)&v287, 1);
          Json::Value::operator=((int)v53, (const Json::Value *)&v287);
          break;
        case 1:
          v51 = Json::Value::operator[](v7, "nFlvSession");
          Json::Value::Value((int)&v287, 1);
          Json::Value::operator=((int)v51, (const Json::Value *)&v287);
          break;
        default:
          goto LABEL_58;
      }
    }
    Json::Value::~Value((Json::Value *)&v287);
LABEL_58:
    if ( *((_DWORD *)v6 + 57) == 5 )
      *((_DWORD *)v6 + 57) = 0;
  }
  if ( v180 == 1 )
  {
    v55 = Json::Value::operator[](v7, "stunSession");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v55, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v181 == 1 )
  {
    v56 = Json::Value::operator[](v7, "trackerSession");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v56, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( *((double *)v6 + 19) > 0.0 )
    *((_QWORD *)v6 + 19) = 0LL;
  if ( v182 > 0 )
  {
    v57 = Json::Value::operator[](v7, "fifo_cr");
    Json::Value::Value((int)&v287, v182);
    Json::Value::operator=((int)v57, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v183 > 0 )
  {
    v58 = Json::Value::operator[](v7, "fifo_cr2");
    Json::Value::Value((int)&v287, v183);
    Json::Value::operator=((int)v58, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v184 > 0 )
  {
    v59 = Json::Value::operator[](v7, "play_cp");
    Json::Value::Value((int)&v287, v184);
    Json::Value::operator=((int)v59, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v185 > 0 )
  {
    v60 = Json::Value::operator[](v7, "play_cp2");
    Json::Value::Value((int)&v287, v185);
    Json::Value::operator=((int)v60, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v186 > 0 )
  {
    v61 = Json::Value::operator[](v7, "play_cpnull");
    Json::Value::Value((int)&v287, v186);
    Json::Value::operator=((int)v61, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v187 > 0 )
  {
    v62 = Json::Value::operator[](v7, "play_cpFail");
    Json::Value::Value((int)&v287, v187);
    Json::Value::operator=((int)v62, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v188 > 0 )
  {
    v63 = Json::Value::operator[](v7, "rtmpToFifo");
    Json::Value::Value((int)&v287, v188);
    Json::Value::operator=((int)v63, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v189 > 0 )
  {
    v64 = Json::Value::operator[](v7, "rtmpToData_delayTime");
    Json::Value::Value((int)&v287, v189);
    Json::Value::operator=((int)v64, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v190 > 0 )
  {
    v65 = Json::Value::operator[](v7, "play_fh");
    Json::Value::Value((int)&v287, v190);
    Json::Value::operator=((int)v65, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v191 > 0 )
  {
    v66 = Json::Value::operator[](v7, "play_fd");
    Json::Value::Value((int)&v287, v191);
    Json::Value::operator=((int)v66, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v192 > 0 )
  {
    v67 = Json::Value::operator[](v7, "play_sd");
    Json::Value::Value((int)&v287, v192);
    Json::Value::operator=((int)v67, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v193 > 0 )
  {
    v68 = Json::Value::operator[](v7, "play_fsd");
    Json::Value::Value((int)&v287, v193);
    Json::Value::operator=((int)v68, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v194 > 0 )
  {
    v69 = Json::Value::operator[](v7, "play_vo");
    Json::Value::Value((int)&v287, v194);
    Json::Value::operator=((int)v69, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v195 > 0 )
  {
    v70 = Json::Value::operator[](v7, "play_vo2");
    Json::Value::Value((int)&v287, v195);
    Json::Value::operator=((int)v70, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v196 > 0 )
  {
    v71 = Json::Value::operator[](v7, "flvVon");
    Json::Value::Value((int)&v287, v196);
    Json::Value::operator=((int)v71, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v197 > 0 )
  {
    v72 = Json::Value::operator[](v7, "tsVon");
    Json::Value::Value((int)&v287, v197);
    Json::Value::operator=((int)v72, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v198 > 0 )
  {
    v73 = Json::Value::operator[](v7, "directVon");
    Json::Value::Value((int)&v287, v198);
    Json::Value::operator=((int)v73, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v203 > 0 )
  {
    v74 = Json::Value::operator[](v7, "play_pc");
    Json::Value::Value((int)&v287, v203);
    Json::Value::operator=((int)v74, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v204 > 0 )
  {
    v75 = Json::Value::operator[](v7, "play_pc2");
    Json::Value::Value((int)&v287, v204);
    Json::Value::operator=((int)v75, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v205 > 0 )
  {
    v76 = Json::Value::operator[](v7, "flvCard");
    Json::Value::Value((int)&v287, v205);
    Json::Value::operator=((int)v76, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v206 > 0 )
  {
    v77 = Json::Value::operator[](v7, "tsCard");
    Json::Value::Value((int)&v287, v206);
    Json::Value::operator=((int)v77, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v207 > 0 )
  {
    v78 = Json::Value::operator[](v7, "directCard");
    Json::Value::Value((int)&v287, v207);
    Json::Value::operator=((int)v78, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v199 > 0 )
  {
    v79 = Json::Value::operator[](v7, "cardCounts");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v79, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
    v80 = 2 * (v199 >> 2);
    if ( v80 >= 16 )
      v80 = 16;
    sprintf(&v289, "freeze_%d", v80);
    v81 = Json::Value::operator[](v7, &v289);
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v81, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v286 > 0 )
  {
    v82 = Json::Value::operator[](v7, "cardCounts2");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v82, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v200 > 0 )
  {
    v83 = Json::Value::operator[](v7, "nFlvCard");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v83, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
    v84 = 2 * (v200 >> 2);
    if ( v84 >= 16 )
      v84 = 16;
    sprintf(&v289, "flvFreeze_%d", v84);
    v85 = Json::Value::operator[](v7, &v289);
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v85, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v201 > 0 )
  {
    v86 = Json::Value::operator[](v7, "nTsCard");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v86, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
    v87 = 2 * (v201 >> 2);
    if ( v87 >= 16 )
      v87 = 16;
    sprintf(&v289, "tsFreeze_%d", v87);
    v88 = Json::Value::operator[](v7, &v289);
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v88, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v202 > 0 )
  {
    v89 = Json::Value::operator[](v7, "nDirectCard");
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v89, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
    v90 = 2 * (v202 >> 2);
    if ( v90 >= 16 )
      v90 = 16;
    sprintf(&v289, "directFreeze_%d", v90);
    v91 = Json::Value::operator[](v7, &v289);
    Json::Value::Value((int)&v287, 1);
    Json::Value::operator=((int)v91, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v208 > 0 )
  {
    v92 = Json::Value::operator[](v7, "timeoutSwitch2");
    Json::Value::Value((int)&v287, v208);
    Json::Value::operator=((int)v92, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v209 > 0 )
  {
    v93 = Json::Value::operator[](v7, "play_blk");
    Json::Value::Value((int)&v287, v209);
    Json::Value::operator=((int)v93, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v210 > 0 )
  {
    v94 = Json::Value::operator[](v7, "noVoutCh");
    Json::Value::Value((int)&v287, v210);
    Json::Value::operator=((int)v94, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v211 > 0 )
  {
    v95 = Json::Value::operator[](v7, "conf");
    Json::Value::Value((int)&v287, v211);
    Json::Value::operator=((int)v95, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v212 > 0 )
  {
    v96 = Json::Value::operator[](v7, "confSuc");
    Json::Value::Value((int)&v287, v212);
    Json::Value::operator=((int)v96, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v213 > 0 )
  {
    v97 = Json::Value::operator[](v7, "confErr");
    Json::Value::Value((int)&v287, v213);
    Json::Value::operator=((int)v97, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v214 > 0 )
  {
    v98 = Json::Value::operator[](v7, "confFail");
    Json::Value::Value((int)&v287, v214);
    Json::Value::operator=((int)v98, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v215 > 0 )
  {
    v99 = Json::Value::operator[](v7, "stun");
    Json::Value::Value((int)&v287, v215);
    Json::Value::operator=((int)v99, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v216 > 0 )
  {
    v100 = Json::Value::operator[](v7, "stunConn");
    Json::Value::Value((int)&v287, v216);
    Json::Value::operator=((int)v100, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v217 > 0 )
  {
    v101 = Json::Value::operator[](v7, "rock");
    Json::Value::Value((int)&v287, v217);
    Json::Value::operator=((int)v101, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v218 > 0 )
  {
    v102 = Json::Value::operator[](v7, "selfInvalid");
    Json::Value::Value((int)&v287, v218);
    Json::Value::operator=((int)v102, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v219 > 0 )
  {
    v103 = Json::Value::operator[](v7, "join");
    Json::Value::Value((int)&v287, v219);
    Json::Value::operator=((int)v103, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v220 > 0 )
  {
    v104 = Json::Value::operator[](v7, "joinSuc");
    Json::Value::Value((int)&v287, v220);
    Json::Value::operator=((int)v104, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v221 > 0 )
  {
    v105 = Json::Value::operator[](v7, "getPeer");
    Json::Value::Value((int)&v287, v221);
    Json::Value::operator=((int)v105, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v222 > 0 )
  {
    v106 = Json::Value::operator[](v7, "peerInvalid");
    Json::Value::Value((int)&v287, v222);
    Json::Value::operator=((int)v106, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v223 > 0 )
  {
    v107 = Json::Value::operator[](v7, "recvAnnoun");
    Json::Value::Value((int)&v287, v223);
    Json::Value::operator=((int)v107, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v224 > 0 )
  {
    v108 = Json::Value::operator[](v7, "wifi");
    Json::Value::Value((int)&v287, v224);
    Json::Value::operator=((int)v108, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v225 > 0 )
  {
    v109 = Json::Value::operator[](v7, "3g");
    Json::Value::Value((int)&v287, v225);
    Json::Value::operator=((int)v109, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v226 > 0 )
  {
    v110 = Json::Value::operator[](v7, "uncertain");
    Json::Value::Value((int)&v287, v226);
    Json::Value::operator=((int)v110, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v227 > 0 )
  {
    v111 = Json::Value::operator[](v7, "flv");
    Json::Value::Value((int)&v287, v227);
    Json::Value::operator=((int)v111, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v228 > 0 )
  {
    v112 = Json::Value::operator[](v7, "m3u8");
    Json::Value::Value((int)&v287, v228);
    Json::Value::operator=((int)v112, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v229 > 0 )
  {
    v113 = Json::Value::operator[](v7, "direct");
    Json::Value::Value((int)&v287, v229);
    Json::Value::operator=((int)v113, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v230 > 0 )
  {
    v114 = Json::Value::operator[](v7, "change");
    Json::Value::Value((int)&v287, v230);
    Json::Value::operator=((int)v114, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v231 > 0 )
  {
    v115 = Json::Value::operator[](v7, "chcdn");
    Json::Value::Value((int)&v287, v231);
    Json::Value::operator=((int)v115, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v232 > 0 )
  {
    v116 = Json::Value::operator[](v7, "chcdnonce");
    Json::Value::Value((int)&v287, v232);
    Json::Value::operator=((int)v116, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v233 > 0 )
  {
    v117 = Json::Value::operator[](v7, "fhchcdn");
    Json::Value::Value((int)&v287, v233);
    Json::Value::operator=((int)v117, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v234 > 0 )
  {
    v118 = Json::Value::operator[](v7, "chcdnlast");
    Json::Value::Value((int)&v287, v234);
    Json::Value::operator=((int)v118, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v235 > 0 )
  {
    v119 = Json::Value::operator[](v7, "chcdnmid");
    Json::Value::Value((int)&v287, v235);
    Json::Value::operator=((int)v119, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v236 > 0 )
  {
    v120 = Json::Value::operator[](v7, "cpFailedSwitch");
    Json::Value::Value((int)&v287, v236);
    Json::Value::operator=((int)v120, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v237 > 0 )
  {
    v121 = Json::Value::operator[](v7, "cpFailedSwitchRtmp");
    Json::Value::Value((int)&v287, v237);
    Json::Value::operator=((int)v121, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v238 > 0 )
  {
    v122 = Json::Value::operator[](v7, "timeoutSwitch");
    Json::Value::Value((int)&v287, v238);
    Json::Value::operator=((int)v122, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v239 > 0 )
  {
    v123 = Json::Value::operator[](v7, "cardLongSwitch");
    Json::Value::Value((int)&v287, v239);
    Json::Value::operator=((int)v123, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v240 > 0 )
  {
    v124 = Json::Value::operator[](v7, "cardLongSwitchRtmp");
    Json::Value::Value((int)&v287, v240);
    Json::Value::operator=((int)v124, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v241 > 0 )
  {
    v125 = Json::Value::operator[](v7, "m3u8FailedSwitch");
    Json::Value::Value((int)&v287, v241);
    Json::Value::operator=((int)v125, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v242 > 0 )
  {
    v126 = Json::Value::operator[](v7, "m3u8FailedSwitchAtStart");
    Json::Value::Value((int)&v287, v242);
    Json::Value::operator=((int)v126, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v243 > 0 )
  {
    v127 = Json::Value::operator[](v7, "m3u8NotUpdateSwitch");
    Json::Value::Value((int)&v287, v243);
    Json::Value::operator=((int)v127, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v244 > 0 )
  {
    v128 = Json::Value::operator[](v7, "m3u8ExcepSwitch");
    Json::Value::Value((int)&v287, v244);
    Json::Value::operator=((int)v128, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v245 > 0 )
  {
    v129 = Json::Value::operator[](v7, "tsFailedSwitch");
    Json::Value::Value((int)&v287, v245);
    Json::Value::operator=((int)v129, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v246 > 0 )
  {
    v130 = Json::Value::operator[](v7, "startFailedSwitch");
    Json::Value::Value((int)&v287, v246);
    Json::Value::operator=((int)v130, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v247 > 0 )
  {
    v131 = Json::Value::operator[](v7, "FlvCDNRequestCount");
    Json::Value::Value((int)&v287, v247);
    Json::Value::operator=((int)v131, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v248 > 0 )
  {
    v132 = Json::Value::operator[](v7, "FlvCDNReceiveCount");
    Json::Value::Value((int)&v287, v248);
    Json::Value::operator=((int)v132, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v249 > 0 )
  {
    v133 = Json::Value::operator[](v7, "FlvCDNDataVerifySucCount");
    Json::Value::Value((int)&v287, v249);
    Json::Value::operator=((int)v133, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v250 > 0 )
  {
    v134 = Json::Value::operator[](v7, "FlvCDNLenVerifyFailCount");
    Json::Value::Value((int)&v287, v250);
    Json::Value::operator=((int)v134, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v251 > 0 )
  {
    v135 = Json::Value::operator[](v7, "FlvCDNDataVerifyFailCount");
    Json::Value::Value((int)&v287, v251);
    Json::Value::operator=((int)v135, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v252 > 0 )
  {
    v136 = Json::Value::operator[](v7, "FlvCDNEmptyDataCount");
    Json::Value::Value((int)&v287, v252);
    Json::Value::operator=((int)v136, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v253 > 0 )
  {
    v137 = Json::Value::operator[](v7, "FlvCDNEndDataCount");
    Json::Value::Value((int)&v287, v253);
    Json::Value::operator=((int)v137, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v254 > 0 )
  {
    v138 = Json::Value::operator[](v7, "FlvP2pCDNCount");
    Json::Value::Value((int)&v287, v254);
    Json::Value::operator=((int)v138, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v255 > 0 )
  {
    v139 = Json::Value::operator[](v7, "FlvP2pCDNLenVerifySucCount");
    Json::Value::Value((int)&v287, v255);
    Json::Value::operator=((int)v139, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v256 > 0 )
  {
    v140 = Json::Value::operator[](v7, "FlvP2pCDNLenVerifyFailCount");
    Json::Value::Value((int)&v287, v256);
    Json::Value::operator=((int)v140, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v257 > 0 )
  {
    v141 = Json::Value::operator[](v7, "FlvP2pReceiveCount");
    Json::Value::Value((int)&v287, v257);
    Json::Value::operator=((int)v141, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v258 > 0 )
  {
    v142 = Json::Value::operator[](v7, "FlvP2pLenVerifyFailCount");
    Json::Value::Value((int)&v287, v258);
    Json::Value::operator=((int)v142, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v259 > 0 )
  {
    v143 = Json::Value::operator[](v7, "FlvP2pDataVerifyFailCount");
    Json::Value::Value((int)&v287, v259);
    Json::Value::operator=((int)v143, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v260 > 0 )
  {
    v144 = Json::Value::operator[](v7, "FlvCDNErrorCount");
    Json::Value::Value((int)&v287, v260);
    Json::Value::operator=((int)v144, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v261 > 0 )
  {
    v145 = Json::Value::operator[](v7, "FlvP2pToRangeCDNToCDNCount");
    Json::Value::Value((int)&v287, v261);
    Json::Value::operator=((int)v145, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v262 > 0 )
  {
    v146 = Json::Value::operator[](v7, "FlvCDNError0Count");
    Json::Value::Value((int)&v287, v262);
    Json::Value::operator=((int)v146, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v263 > 0 )
  {
    v147 = Json::Value::operator[](v7, "FlvCDNError1Count");
    Json::Value::Value((int)&v287, v263);
    Json::Value::operator=((int)v147, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v264 > 0 )
  {
    v148 = Json::Value::operator[](v7, "FlvCDNError2Count");
    Json::Value::Value((int)&v287, v264);
    Json::Value::operator=((int)v148, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v265 > 0 )
  {
    v149 = Json::Value::operator[](v7, "FlvCDNError3Count");
    Json::Value::Value((int)&v287, v265);
    Json::Value::operator=((int)v149, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v266 > 0 )
  {
    v150 = Json::Value::operator[](v7, "FlvCDNError4Count");
    Json::Value::Value((int)&v287, v266);
    Json::Value::operator=((int)v150, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v267 > 0 )
  {
    v151 = Json::Value::operator[](v7, "FlvCDNError5Count");
    Json::Value::Value((int)&v287, v267);
    Json::Value::operator=((int)v151, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v268 > 0 )
  {
    v152 = Json::Value::operator[](v7, "FlvCDNError6Count");
    Json::Value::Value((int)&v287, v268);
    Json::Value::operator=((int)v152, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v269 > 0 )
  {
    v153 = Json::Value::operator[](v7, "FlvCDNErrorxCount");
    Json::Value::Value((int)&v287, v269);
    Json::Value::operator=((int)v153, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v23 > 0 )
  {
    v154 = Json::Value::operator[](v7, "cpt");
    Json::Value::Value((int)&v287, v23);
    Json::Value::operator=((int)v154, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v24 > 0 )
  {
    v155 = Json::Value::operator[](v7, "cpt2");
    Json::Value::Value((int)&v287, v24);
    Json::Value::operator=((int)v155, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v25 > 0 )
  {
    v156 = Json::Value::operator[](v7, "fht");
    Json::Value::Value((int)&v287, v25);
    Json::Value::operator=((int)v156, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v270 > 0 )
  {
    v157 = Json::Value::operator[](v7, "fdt");
    Json::Value::Value((int)&v287, v270);
    Json::Value::operator=((int)v157, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v271 > 0 )
  {
    v158 = Json::Value::operator[](v7, "sdt");
    Json::Value::Value((int)&v287, v271);
    Json::Value::operator=((int)v158, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v272 > 0 )
  {
    v159 = Json::Value::operator[](v7, "vot");
    Json::Value::Value((int)&v287, v272);
    Json::Value::operator=((int)v159, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v273 > 0 )
  {
    v160 = Json::Value::operator[](v7, "vot2");
    Json::Value::Value((int)&v287, v273);
    Json::Value::operator=((int)v160, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v274 > 0 )
  {
    v161 = Json::Value::operator[](v7, "conft");
    Json::Value::Value((int)&v287, v274);
    Json::Value::operator=((int)v161, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v275 > 0 )
  {
    v162 = Json::Value::operator[](v7, "rockt");
    Json::Value::Value((int)&v287, v275);
    Json::Value::operator=((int)v162, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v276 > 0 )
  {
    v163 = Json::Value::operator[](v7, "clt");
    Json::Value::Value((int)&v287, v276);
    Json::Value::operator=((int)v163, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v277 > 0 )
  {
    v164 = Json::Value::operator[](v7, "clt2");
    Json::Value::Value((int)&v287, v277);
    Json::Value::operator=((int)v164, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v278 > 0 )
  {
    v165 = Json::Value::operator[](v7, "real_vot");
    Json::Value::Value((int)&v287, v278);
    Json::Value::operator=((int)v165, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v279 > 0 )
  {
    v166 = Json::Value::operator[](v7, "real_vot2");
    Json::Value::Value((int)&v287, v279);
    Json::Value::operator=((int)v166, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v280 > 0 )
  {
    v167 = Json::Value::operator[](v7, "real_clt");
    Json::Value::Value((int)&v287, v280);
    Json::Value::operator=((int)v167, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v281 > 0 )
  {
    v168 = Json::Value::operator[](v7, "real_clt2");
    Json::Value::Value((int)&v287, v281);
    Json::Value::operator=((int)v168, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v282 > 0 )
  {
    v169 = Json::Value::operator[](v7, "real_cl");
    Json::Value::Value((int)&v287, v282);
    Json::Value::operator=((int)v169, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v283 > 0 )
  {
    v170 = Json::Value::operator[](v7, "real_cl2");
    Json::Value::Value((int)&v287, v283);
    Json::Value::operator=((int)v170, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v284 > 0 )
  {
    v171 = Json::Value::operator[](v7, "play_cl");
    Json::Value::Value((int)&v287, v284);
    Json::Value::operator=((int)v171, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  if ( v285 > 0 )
  {
    v172 = Json::Value::operator[](v7, "play_cl2");
    Json::Value::Value((int)&v287, v285);
    Json::Value::operator=((int)v172, (const Json::Value *)&v287);
    Json::Value::~Value((Json::Value *)&v287);
  }
  return pthread_mutex_unlock((pthread_mutex_t *)&stat_lock);
}
// F30E8: using guessed type int currentPlayMode;
// F41C0: using guessed type char firstVout;
// F41D4: using guessed type int currentStreamType;

//----- (0005A368) --------------------------------------------------------
int __fastcall rtrim(char *a1, int a2)
{
  char *v2; // r0

  v2 = &a1[a2];
  while ( 1 )
  {
    if ( a2 <= 0 )
      return 0;
    if ( !(*(_BYTE *)(ctype_ + (unsigned __int8)*(v2 - 1) + 1) & 8) )
      break;
    *(v2-- - 1) = 0;
    --a2;
  }
  return a2;
}

//----- (0005A39C) --------------------------------------------------------
int __fastcall getRegularContent(char *a1, RegularInfo *a2, RegularInfo *a3, int *a4, int *a5)
{
  char *v5; // r11
  RegularInfo *v6; // r4
  RegularInfo *v7; // r8
  int *v8; // r8
  int *v9; // r8
  int *v10; // r0
  int *v11; // r7
  int *v12; // r7
  int *v13; // r7
  int v14; // r0
  int v15; // r0
  int v16; // r6
  int *v17; // r7
  int *v18; // r5
  char *v19; // r7
  size_t v20; // r0
  int v21; // r0
  int v22; // r7
  int *v23; // ST14_4
  int *v24; // ST14_4
  int v25; // r7
  char *v26; // r6
  size_t v27; // r0
  int *v29; // [sp+14h] [bp-234h]
  char *src; // [sp+24h] [bp-224h]
  char v31; // [sp+28h] [bp-220h]
  char v32; // [sp+2Ch] [bp-21Ch]
  char v33; // [sp+30h] [bp-218h]
  char v34; // [sp+34h] [bp-214h]
  char v35; // [sp+40h] [bp-208h]
  char v36; // [sp+50h] [bp-1F8h]
  char v37; // [sp+60h] [bp-1E8h]
  char v38; // [sp+70h] [bp-1D8h]
  char v39; // [sp+80h] [bp-1C8h]
  char v40; // [sp+90h] [bp-1B8h]
  char v41; // [sp+A0h] [bp-1A8h]
  char v42; // [sp+B0h] [bp-198h]
  char v43; // [sp+C0h] [bp-188h]
  char v44; // [sp+D0h] [bp-178h]
  char v45; // [sp+E0h] [bp-168h]
  char s; // [sp+F0h] [bp-158h]
  char v47; // [sp+154h] [bp-F4h]
  char v48; // [sp+1B8h] [bp-90h]

  v5 = a1;
  v29 = a4;
  v6 = a2;
  v7 = a3;
  Json::Value::Value((int)&v35, 0);
  Json::Value::Value((int)&v36, 0);
  Json::FastWriter::FastWriter((int)&v34);
  src = (char *)&unk_2FEF48;
  memset(&s, 0, 0x64u);
  memset(&v47, 0, 0x64u);
  memset(&v48, 0, 0x64u);
  sprintf(&s, "%sApp_%s", reportPartnerId, version);
  sprintf(&v47, "%sChannel_%s_%s", reportPartnerId, version, &currentChannelId);
  if ( currentPlayMode == 1 )
  {
    sprintf(&v48, "%sSource_%s_%s_%s", reportPartnerId, version, &currentChannelId, bitrate);
  }
  else if ( !currentPlayMode )
  {
    sprintf(&v48, "%sSource_%s_%s", reportPartnerId, version, &currentSourceId);
  }
  generateRegularInfo((Json::Value *)&v35, v6, v7, v29, a5);
  v8 = Json::Value::operator[]((Json::Value *)&v36, "id");
  Json::Value::Value((Json::Value *)&v37, clientId);
  Json::Value::operator=((int)v8, (const Json::Value *)&v37);
  Json::Value::~Value((Json::Value *)&v37);
  v9 = Json::Value::operator[]((Json::Value *)&v36, "code");
  Json::Value::Value((Json::Value *)&v38, "000");
  Json::Value::operator=((int)v9, (const Json::Value *)&v38);
  Json::Value::~Value((Json::Value *)&v38);
  v10 = Json::Value::operator[]((Json::Value *)&v36, "i");
  Json::Value::operator=((int)v10, (const Json::Value *)&v35);
  v11 = Json::Value::operator[]((Json::Value *)&v36, "bz");
  Json::Value::Value((Json::Value *)&v39, &s);
  Json::Value::operator=((int)v11, (const Json::Value *)&v39);
  Json::Value::~Value((Json::Value *)&v39);
  v12 = Json::Value::operator[]((Json::Value *)&v36, "sysinfo");
  Json::Value::Value((Json::Value *)&v40, (const char *)&sysinfo);
  Json::Value::operator=((int)v12, (const Json::Value *)&v40);
  Json::Value::~Value((Json::Value *)&v40);
  v13 = Json::Value::operator[]((Json::Value *)&v36, "c");
  Json::Value::Value((Json::Value *)&v41, &s);
  Json::Value::operator=((int)v13, (const Json::Value *)&v41);
  Json::Value::~Value((Json::Value *)&v41);
  Json::FastWriter::write((Json::FastWriter *)&v31, (const Json::Value *)&v34, (const Json::Value *)&v36);
  sub_C1778(&src, &v31);
  sub_C0AD8(&v31);
  strcpy(v5, src);
  v14 = strlen(v5);
  v15 = rtrim(v5, v14);
  v16 = v15;
  v5[v15] = 0;
  v17 = Json::Value::operator[]((Json::Value *)&v36, "bz");
  Json::Value::Value((Json::Value *)&v42, &v47);
  Json::Value::operator=((int)v17, (const Json::Value *)&v42);
  Json::Value::~Value((Json::Value *)&v42);
  v18 = Json::Value::operator[]((Json::Value *)&v36, "c");
  Json::Value::Value((Json::Value *)&v43, &v47);
  Json::Value::operator=((int)v18, (const Json::Value *)&v43);
  Json::Value::~Value((Json::Value *)&v43);
  Json::FastWriter::write((Json::FastWriter *)&v32, (const Json::Value *)&v34, (const Json::Value *)&v36);
  sub_C1778(&src, &v32);
  ++v16;
  sub_C0AD8(&v32);
  v19 = src;
  strcpy(&v5[v16], src);
  v20 = strlen(v19);
  v21 = rtrim(v5, v20 + v16);
  v22 = v21;
  if ( v48 )
  {
    v5[v21] = 0;
    v23 = Json::Value::operator[]((Json::Value *)&v36, "bz");
    Json::Value::Value((Json::Value *)&v44, &v48);
    Json::Value::operator=((int)v23, (const Json::Value *)&v44);
    Json::Value::~Value((Json::Value *)&v44);
    v24 = Json::Value::operator[]((Json::Value *)&v36, "c");
    Json::Value::Value((Json::Value *)&v45, &v48);
    Json::Value::operator=((int)v24, (const Json::Value *)&v45);
    Json::Value::~Value((Json::Value *)&v45);
    Json::FastWriter::write((Json::FastWriter *)&v33, (const Json::Value *)&v34, (const Json::Value *)&v36);
    sub_C1778(&src, &v33);
    v25 = v22 + 1;
    sub_C0AD8(&v33);
    v26 = src;
    strcpy(&v5[v25], src);
    v27 = strlen(v26);
    v22 = rtrim(v5, v27 + v25);
  }
  sub_C0AD8(&src);
  Json::FastWriter::~FastWriter((Json::FastWriter *)&v34);
  Json::Value::~Value((Json::Value *)&v36);
  Json::Value::~Value((Json::Value *)&v35);
  return v22;
}
// C1778: using guessed type int __fastcall sub_C1778(_DWORD, _DWORD);
// F30E8: using guessed type int currentPlayMode;
// F3948: using guessed type char *bitrate;
// F4988: using guessed type char currentSourceId;
// F5650: using guessed type char currentChannelId;

//----- (0005A7D4) --------------------------------------------------------
signed int __fastcall sendReportContent(char *a1, int a2)
{
  return downloadPath(0, reportURL, 0, 0, 7.0, 0, a1, a2);
}

//----- (0005A804) --------------------------------------------------------
signed int channelRegularReporterProcess(void)
{
  int *v0; // r4
  int v1; // r6
  int v2; // r8
  pthread_t v3; // r0
  _BYTE *v4; // r5
  int v5; // r3
  __int64 v6; // r0
  RegularInfo *v7; // r5
  pthread_mutex_t *v8; // r10
  _DWORD *i; // r5
  int v10; // r0
  signed int result; // r0
  __int64 v12; // r0
  RegularInfo *v13; // r5
  pthread_t v14; // [sp+8h] [bp-5038h]
  char v15; // [sp+14h] [bp-502Ch]
  int v16; // [sp+5014h] [bp-2Ch]

  v0 = &GLOBAL_OFFSET_TABLE_;
  v1 = 0;
  v2 = 0;
  v3 = pthread_self();
  pthread_detach(v3);
  unk_2F8140 = getTime();
  while ( 1 )
  {
    if ( !strcmp(*(const char **)((char *)v0 + 0xFFFFF9D4), "air.fyzb3") )
    {
      v4 = *(_BYTE **)((char *)v0 + 0xFFFFFBB8);
      *v4 = 0;
      if ( !**(_BYTE **)((char *)v0 + 0xFFFFFBA8)
        && COERCE_DOUBLE(getTime()) - *(double *)(*(int *)((char *)v0 + 0xFFFFFAD4) + 32) > (double)**(signed int **)((char *)v0 + 0xFFFFFC80) )
      {
        v5 = **(_DWORD **)((char *)v0 + 0xFFFFFA58);
        if ( v5 && **(_DWORD **)((char *)v0 + 0xFFFFFA50) )
        {
          if ( v5 > 0 )
            notifyPlayerToChangeSource(1);
        }
        else
        {
          notifyPlayerToRestart();
        }
      }
      if ( *(double *)*(int *)((char *)v0 + 0xFFFFF9F8) > (double)**(signed int **)((char *)v0 + 0xFFFFFC84) )
      {
        **(_BYTE **)((char *)v0 + 0xFFFFFA18) = 1;
        notifyPlayerToChangeSource(2);
      }
      if ( *v4 )
      {
        v6 = getTime();
        v7 = *(RegularInfo **)((char *)v0 + 0xFFFFFAD4);
        *((_QWORD *)v7 + 5) = v6;
        v1 = getRegularContent(
               &v15,
               (RegularInfo *)&lastChannelInfo,
               v7,
               *(int **)((char *)v0 + 0xFFFFFC8C),
               *(int **)((char *)v0 + 0xFFFFFC88));
        RegularInfo::clone((int)v7, (int)&lastChannelInfo);
        *(int *)((char *)&dword_D8 + (_DWORD)v7) = 0;
        *(int *)((char *)&dword_DC + (_DWORD)v7) = 0;
        *(int *)((char *)&dword_D4 + (_DWORD)v7) = 0;
        *(int *)((char *)&dword_E0 + (_DWORD)v7) = 0;
      }
    }
    if ( **(_DWORD **)((char *)v0 + 0xFFFFF9F4) || **(_BYTE **)((char *)v0 + 0xFFFFFBB8) )
      goto LABEL_30;
    if ( **(_BYTE **)((char *)v0 + 0xFFFFFBA4) )
    {
      v8 = **(pthread_mutex_t ***)((char *)v0 + 0xFFFFFC6C);
      v14 = pthread_self();
      pthread_mutex_lock(v8);
      for ( i = *(_DWORD **)(v8->__count + 8); i && *i != v14; i = (_DWORD *)i[2] )
        ;
      pthread_mutex_unlock(v8);
      if ( i )
      {
        if ( i[1] == 5 )
        {
LABEL_30:
          v0 = **(int ***)((char *)v0 + 0xFFFFFC6C);
          v10 = pthread_self();
          ThreadManager::removeThreadInfo((ThreadManager *)v0, v10);
          result = sendReportContent(&v15, v1);
          if ( v16 == _stack_chk_guard )
            return result;
        }
      }
    }
    if ( v2 % 300 == 299 )
    {
      v12 = getTime();
      v13 = *(RegularInfo **)((char *)v0 + 0xFFFFFAD4);
      *((_QWORD *)v13 + 5) = v12;
      v1 = getRegularContent(
             &v15,
             (RegularInfo *)&lastChannelInfo,
             v13,
             *(int **)((char *)v0 + 0xFFFFFC8C),
             *(int **)((char *)v0 + 0xFFFFFC88));
      RegularInfo::clone((int)v13, (int)&lastChannelInfo);
      sendReportContent(&v15, v1);
    }
    ++v2;
    usleep((__useconds_t)"");
  }
}
// D4: using guessed type int;
// D8: using guessed type int;
// DC: using guessed type int;
// E0: using guessed type int;
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (0005AA44) --------------------------------------------------------
signed int cloneChannelInfo(void)
{
  int v0; // r9
  char v2; // [sp+Ch] [bp-5024h]

  unk_F4208 = getTime();
  v0 = getRegularContent(
         &v2,
         (RegularInfo *)&lastChannelInfo,
         (RegularInfo *)&currentChannelInfo,
         (int *)&channelEventCount,
         (int *)&channelEventDelay);
  RegularInfo::clone((int)&currentChannelInfo, (int)&lastChannelInfo);
  dword_F42B8 = 0;
  dword_F42BC = 0;
  dword_F42B4 = 0;
  dword_F42C0 = 0;
  ThreadManager::removeThreadInfo((ThreadManager *)threadManager, channelReqularReportThread);
  return sendReportContent(&v2, v0);
}
// F42B4: using guessed type int dword_F42B4;
// F42B8: using guessed type int dword_F42B8;
// F42BC: using guessed type int dword_F42BC;
// F42C0: using guessed type int dword_F42C0;
// 2F6094: using guessed type int threadManager;
// 2F810C: using guessed type int channelReqularReportThread;

//----- (0005AAF8) --------------------------------------------------------
int getP2PDownloadRate(void)
{
  return p2pDownloadRate & ~(p2pDownloadRate >> 31);
}
// 2F60A8: using guessed type int p2pDownloadRate;

//----- (0005AB0C) --------------------------------------------------------
int getP2PUploadRate(void)
{
  return p2pUploadRate;
}
// 2F60A0: using guessed type int p2pUploadRate;

//----- (0005AB1C) --------------------------------------------------------
int getCDNDownloadRate(void)
{
  return cdnDownloadRate;
}
// 2F60A4: using guessed type int cdnDownloadRate;

//----- (0005AB2C) --------------------------------------------------------
int getTDNDownloadRate(void)
{
  return tdnDownloadRate;
}
// 2F609C: using guessed type int tdnDownloadRate;

//----- (0005AB3C) --------------------------------------------------------
void add_fifo_cr(void)
{
  ++dword_F42C8;
}
// F42C8: using guessed type int dword_F42C8;

//----- (0005AB54) --------------------------------------------------------
void add_fifo_cr2(void)
{
  ++dword_F42CC;
}
// F42CC: using guessed type int dword_F42CC;

//----- (0005AB70) --------------------------------------------------------
double add_play_cp(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F42D0;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4438 = unk_F4438 + (v0 - result) * 1000.0;
  return result;
}
// F42D0: using guessed type int dword_F42D0;

//----- (0005ABC0) --------------------------------------------------------
double add_play_cp2(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F42D4;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4440 = unk_F4440 + (v0 - result) * 1000.0;
  return result;
}
// F42D4: using guessed type int dword_F42D4;

//----- (0005AC10) --------------------------------------------------------
void add_play_cpnull(void)
{
  ++dword_F4330;
}
// F4330: using guessed type int dword_F4330;

//----- (0005AC28) --------------------------------------------------------
void add_play_cpFail(void)
{
  ++dword_F4334;
}
// F4334: using guessed type int dword_F4334;

//----- (0005AC40) --------------------------------------------------------
void add_play_rtmpToFifo(void)
{
  ++dword_F4338;
}
// F4338: using guessed type int dword_F4338;

//----- (0005AC58) --------------------------------------------------------
int __fastcall add_rtmpToData_delayTime(int a1)
{
  int result; // r0

  result = dword_F433C + 1000 * a1;
  dword_F433C = result;
  return result;
}
// F433C: using guessed type int dword_F433C;

//----- (0005AC78) --------------------------------------------------------
double add_play_fh(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F42D8;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4448 = unk_F4448 + (v0 - result) * 1000.0;
  return result;
}
// F42D8: using guessed type int dword_F42D8;

//----- (0005ACC8) --------------------------------------------------------
double add_play_fd(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F42DC;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4450 = unk_F4450 + (v0 - result) * 1000.0;
  return result;
}
// F42DC: using guessed type int dword_F42DC;

//----- (0005AD18) --------------------------------------------------------
double add_play_sd(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F42E0;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4458 = unk_F4458 + (v0 - result) * 1000.0;
  return result;
}
// F42E0: using guessed type int dword_F42E0;

//----- (0005AD68) --------------------------------------------------------
void add_play_fsd(void)
{
  ++dword_F42E4;
}
// F42E4: using guessed type int dword_F42E4;

//----- (0005AD80) --------------------------------------------------------
double add_play_vo(void)
{
  double v0; // r0
  double result; // r0

  ++dword_F42E8;
  dword_F42C4 = 4;
  v0 = COERCE_DOUBLE(getTime());
  unk_F4460 = unk_F4460 + (v0 - COERCE_DOUBLE(getPlayerStartTime())) * 1000.0;
  result = COERCE_DOUBLE(getTime());
  unk_F4498 = unk_F4498 + (result - unk_F4490) * 1000.0;
  return result;
}
// F42C4: using guessed type int dword_F42C4;
// F42E8: using guessed type int dword_F42E8;

//----- (0005ADF8) --------------------------------------------------------
double add_play_vo2(void)
{
  double v0; // r0
  double result; // r0

  ++dword_F42EC;
  dword_F42C4 = 4;
  v0 = COERCE_DOUBLE(getTime());
  unk_F4468 = unk_F4468 + (v0 - COERCE_DOUBLE(getPlayerStartTime())) * 1000.0;
  result = COERCE_DOUBLE(getTime());
  unk_F44A0 = unk_F44A0 + (result - unk_F4490) * 1000.0;
  return result;
}
// F42C4: using guessed type int dword_F42C4;
// F42EC: using guessed type int dword_F42EC;

//----- (0005AE70) --------------------------------------------------------
void add_flv_vo(void)
{
  ++dword_F42F0;
}
// F42F0: using guessed type int dword_F42F0;

//----- (0005AE88) --------------------------------------------------------
void add_ts_vo(void)
{
  ++dword_F42F4;
}
// F42F4: using guessed type int dword_F42F4;

//----- (0005AEA0) --------------------------------------------------------
void add_direct_vo(void)
{
  ++dword_F42F8;
}
// F42F8: using guessed type int dword_F42F8;

//----- (0005AEB8) --------------------------------------------------------
void add_ses_play_pc(void)
{
  ++dword_F42FC;
}
// F42FC: using guessed type int dword_F42FC;

//----- (0005AED0) --------------------------------------------------------
void add_ses_play_pc2(void)
{
  ++dword_F4300;
}
// F4300: using guessed type int dword_F4300;

//----- (0005AEE8) --------------------------------------------------------
void add_ses_flv_pc(void)
{
  ++dword_F4304;
}
// F4304: using guessed type int dword_F4304;

//----- (0005AF00) --------------------------------------------------------
void add_ses_ts_pc(void)
{
  ++dword_F4308;
}
// F4308: using guessed type int dword_F4308;

//----- (0005AF18) --------------------------------------------------------
void add_ses_direct_pc(void)
{
  ++dword_F430C;
}
// F430C: using guessed type int dword_F430C;

//----- (0005AF30) --------------------------------------------------------
void add_play_pc(void)
{
  ++dword_F4310;
}
// F4310: using guessed type int dword_F4310;

//----- (0005AF48) --------------------------------------------------------
void add_play_pc2(void)
{
  ++dword_F4314;
}
// F4314: using guessed type int dword_F4314;

//----- (0005AF60) --------------------------------------------------------
void add_flv_pc(void)
{
  ++dword_F4318;
}
// F4318: using guessed type int dword_F4318;

//----- (0005AF78) --------------------------------------------------------
void add_ts_pc(void)
{
  ++dword_F431C;
}
// F431C: using guessed type int dword_F431C;

//----- (0005AF90) --------------------------------------------------------
void add_direct_pc(void)
{
  ++dword_F4320;
}
// F4320: using guessed type int dword_F4320;

//----- (0005AFA8) --------------------------------------------------------
double add_play_cl(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F4324;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4480 = unk_F4480 + (v0 - result) * 1000.0;
  if ( !isSwitchEntry )
  {
    ++dword_F44B8;
    result = COERCE_DOUBLE(getTime());
    unk_F44A8 = unk_F44A8 + (result - unk_F4490) * 1000.0;
  }
  return result;
}
// F41BB: using guessed type char isSwitchEntry;
// F4324: using guessed type int dword_F4324;
// F44B8: using guessed type int dword_F44B8;

//----- (0005B028) --------------------------------------------------------
double add_play_cl2(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F4328;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4488 = unk_F4488 + (v0 - result) * 1000.0;
  if ( !isSwitchEntry )
  {
    ++dword_F44BC;
    result = COERCE_DOUBLE(getTime());
    unk_F44B0 = unk_F44B0 + (result - unk_F4490) * 1000.0;
  }
  return result;
}
// 2D8: using guessed type Elf32_Sym;
// F41BB: using guessed type char isSwitchEntry;
// F4328: using guessed type int dword_F4328;
// F44BC: using guessed type int dword_F44BC;

//----- (0005B0A8) --------------------------------------------------------
void add_timeout_switch2(void)
{
  ++dword_F432C;
}
// F432C: using guessed type int dword_F432C;

//----- (0005B0C0) --------------------------------------------------------
void add_play_blk(void)
{
  ++dword_F4340;
}
// F4340: using guessed type int dword_F4340;

//----- (0005B0D8) --------------------------------------------------------
void add_noVoutCh(void)
{
  ++dword_F4344;
}
// F4344: using guessed type int dword_F4344;

//----- (0005B0F0) --------------------------------------------------------
double add_conf(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F4348;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4470 = unk_F4470 + (v0 - result) * 1000.0;
  return result;
}
// F4348: using guessed type int dword_F4348;

//----- (0005B140) --------------------------------------------------------
void add_confSuc(void)
{
  ++dword_F434C;
}
// F434C: using guessed type int dword_F434C;

//----- (0005B158) --------------------------------------------------------
void add_confErr(void)
{
  ++dword_F4350;
}
// F4350: using guessed type int dword_F4350;

//----- (0005B170) --------------------------------------------------------
void add_confFail(void)
{
  ++dword_F4354;
}
// F4354: using guessed type int dword_F4354;

//----- (0005B188) --------------------------------------------------------
void add_stun(void)
{
  ++dword_F4358;
}
// F4358: using guessed type int dword_F4358;

//----- (0005B1A0) --------------------------------------------------------
void add_stunConn(void)
{
  ++dword_F435C;
}
// F435C: using guessed type int dword_F435C;

//----- (0005B1B8) --------------------------------------------------------
double add_rock(void)
{
  double v0; // d8
  double result; // r0

  ++dword_F4360;
  v0 = COERCE_DOUBLE(getTime());
  result = COERCE_DOUBLE(getPlayerStartTime());
  unk_F4478 = unk_F4478 + (v0 - result) * 1000.0;
  return result;
}
// F4360: using guessed type int dword_F4360;

//----- (0005B208) --------------------------------------------------------
void add_selfInvalid(void)
{
  ++dword_F4364;
}
// F4364: using guessed type int dword_F4364;

//----- (0005B220) --------------------------------------------------------
void add_join(void)
{
  ++dword_F4368;
}
// F4368: using guessed type int dword_F4368;

//----- (0005B238) --------------------------------------------------------
void add_joinSuc(void)
{
  ++dword_F436C;
}
// F436C: using guessed type int dword_F436C;

//----- (0005B250) --------------------------------------------------------
void add_getPeer(void)
{
  ++dword_F4370;
}
// F4370: using guessed type int dword_F4370;

//----- (0005B268) --------------------------------------------------------
void add_peerInvalid(void)
{
  ++dword_F4374;
}
// F4374: using guessed type int dword_F4374;

//----- (0005B280) --------------------------------------------------------
void add_recvAnnoun(void)
{
  ++dword_F4378;
}
// F4378: using guessed type int dword_F4378;

//----- (0005B298) --------------------------------------------------------
void add_wifi(void)
{
  ++dword_F437C;
}
// F437C: using guessed type int dword_F437C;

//----- (0005B2B0) --------------------------------------------------------
void add_3g(void)
{
  ++dword_F4380;
}
// F4380: using guessed type int dword_F4380;

//----- (0005B2C8) --------------------------------------------------------
void add_uncertain(void)
{
  ++dword_F4384;
}
// F4384: using guessed type int dword_F4384;

//----- (0005B2E0) --------------------------------------------------------
void add_flv(void)
{
  ++dword_F4388;
}
// F4388: using guessed type int dword_F4388;

//----- (0005B2F8) --------------------------------------------------------
void add_m3u8(void)
{
  ++dword_F438C;
}
// F438C: using guessed type int dword_F438C;

//----- (0005B310) --------------------------------------------------------
void add_direct(void)
{
  ++dword_F4390;
}
// F4390: using guessed type int dword_F4390;

//----- (0005B328) --------------------------------------------------------
void add_change(void)
{
  ++dword_F4394;
}
// F4394: using guessed type int dword_F4394;

//----- (0005B340) --------------------------------------------------------
void add_chcdn(void)
{
  ++dword_F4398;
}
// F4398: using guessed type int dword_F4398;

//----- (0005B358) --------------------------------------------------------
void add_chcdnonce(void)
{
  ++dword_F439C;
}
// F439C: using guessed type int dword_F439C;

//----- (0005B370) --------------------------------------------------------
void add_fhchcdn(void)
{
  ++dword_F43A0;
}
// F43A0: using guessed type int dword_F43A0;

//----- (0005B388) --------------------------------------------------------
void add_chcdnlast(void)
{
  ++dword_F43A4;
}
// F43A4: using guessed type int dword_F43A4;

//----- (0005B3A0) --------------------------------------------------------
void add_chcdnmid(void)
{
  ++dword_F43A8;
}
// F43A8: using guessed type int dword_F43A8;

//----- (0005B3B8) --------------------------------------------------------
void add_cpFailedSwitch(void)
{
  ++dword_F43AC;
}
// F43AC: using guessed type int dword_F43AC;

//----- (0005B3D0) --------------------------------------------------------
void add_cpFailedSwitchRtmp(void)
{
  ++dword_F43B0;
}
// F43B0: using guessed type int dword_F43B0;

//----- (0005B3E8) --------------------------------------------------------
void add_timeoutSwitch(void)
{
  ++dword_F43B4;
}
// F43B4: using guessed type int dword_F43B4;

//----- (0005B400) --------------------------------------------------------
void add_cardLongSwitch(void)
{
  ++dword_F43B8;
}
// F43B8: using guessed type int dword_F43B8;

//----- (0005B418) --------------------------------------------------------
void add_cardLongSwitchRtmp(void)
{
  ++dword_F43BC;
}
// F43BC: using guessed type int dword_F43BC;

//----- (0005B430) --------------------------------------------------------
void add_m3u8FailedSwitch(void)
{
  ++dword_F43C0;
  if ( !firstVout )
    ++dword_F43C4;
}
// 1D8: using guessed type Elf32_Sym;
// F41C0: using guessed type char firstVout;
// F43C0: using guessed type int dword_F43C0;
// F43C4: using guessed type int dword_F43C4;

//----- (0005B460) --------------------------------------------------------
void add_m3u8NotUpdateSwitch(void)
{
  ++dword_F43C8;
}
// F43C8: using guessed type int dword_F43C8;

//----- (0005B478) --------------------------------------------------------
void add_m3u8ExcepSwitch(void)
{
  ++dword_F43CC;
}
// F43CC: using guessed type int dword_F43CC;

//----- (0005B490) --------------------------------------------------------
void add_tsFailedSwitch(void)
{
  ++dword_F43D0;
}
// F43D0: using guessed type int dword_F43D0;

//----- (0005B4A8) --------------------------------------------------------
void add_startFailedSwitch(void)
{
  ++dword_F43D4;
}
// F43D4: using guessed type int dword_F43D4;

//----- (0005B4C0) --------------------------------------------------------
void add_FlvCDNRequestCount(void)
{
  ++dword_F43D8;
}
// F43D8: using guessed type int dword_F43D8;

//----- (0005B4D8) --------------------------------------------------------
void add_FlvCDNReceiveCount(void)
{
  ++dword_F43DC;
}
// F43DC: using guessed type int dword_F43DC;

//----- (0005B4F0) --------------------------------------------------------
void add_FlvCDNDataVerifySucCount(void)
{
  ++dword_F43E0;
}
// F43E0: using guessed type int dword_F43E0;

//----- (0005B508) --------------------------------------------------------
void add_FlvCDNLenVerifyFailCount(void)
{
  ++dword_F43E4;
}
// F43E4: using guessed type int dword_F43E4;

//----- (0005B520) --------------------------------------------------------
void add_FlvCDNDataVerifyFailCount(void)
{
  ++dword_F43E8;
}
// F43E8: using guessed type int dword_F43E8;

//----- (0005B538) --------------------------------------------------------
void add_FlvCDNEmptyDataCount(void)
{
  ++dword_F43EC;
}
// F43EC: using guessed type int dword_F43EC;

//----- (0005B550) --------------------------------------------------------
void add_FlvCDNEndDataCount(void)
{
  ++dword_F43F0;
}
// F43F0: using guessed type int dword_F43F0;

//----- (0005B568) --------------------------------------------------------
void add_FlvP2pCDNCount(void)
{
  ++dword_F43F4;
}
// F43F4: using guessed type int dword_F43F4;

//----- (0005B580) --------------------------------------------------------
void add_FlvP2pCDNLenVerifySucCount(void)
{
  ++dword_F43F8;
}
// F43F8: using guessed type int dword_F43F8;

//----- (0005B598) --------------------------------------------------------
void add_FlvP2pCDNLenVerifyFailCount(void)
{
  ++dword_F43FC;
}
// F43FC: using guessed type int dword_F43FC;

//----- (0005B5B0) --------------------------------------------------------
void add_FlvP2pReceiveCount(void)
{
  ++dword_F4400;
}
// F4400: using guessed type int dword_F4400;

//----- (0005B5C8) --------------------------------------------------------
void add_FlvP2pLenVerifyFailCount(void)
{
  ++dword_F4404;
}
// F4404: using guessed type int dword_F4404;

//----- (0005B5E0) --------------------------------------------------------
void add_FlvP2pDataVerifyFailCount(void)
{
  ++dword_F4408;
}
// F4408: using guessed type int dword_F4408;

//----- (0005B5F8) --------------------------------------------------------
void add_FlvCDNErrorCount(void)
{
  ++dword_F440C;
}
// F440C: using guessed type int dword_F440C;

//----- (0005B610) --------------------------------------------------------
void add_FlvP2pToRangeCDNToCDNCount(void)
{
  ++dword_F4410;
}
// F4410: using guessed type int dword_F4410;

//----- (0005B628) --------------------------------------------------------
void add_FlvCDNError0Count(void)
{
  ++dword_F4414;
}
// F4414: using guessed type int dword_F4414;

//----- (0005B640) --------------------------------------------------------
void add_FlvCDNError1Count(void)
{
  ++dword_F4418;
}
// F4418: using guessed type int dword_F4418;

//----- (0005B658) --------------------------------------------------------
void add_FlvCDNError2Count(void)
{
  ++dword_F441C;
}
// F441C: using guessed type int dword_F441C;

//----- (0005B670) --------------------------------------------------------
void add_FlvCDNError3Count(void)
{
  ++dword_F4420;
}
// F4420: using guessed type int dword_F4420;

//----- (0005B688) --------------------------------------------------------
void add_FlvCDNError4Count(void)
{
  ++dword_F4424;
}
// F4424: using guessed type int dword_F4424;

//----- (0005B6A0) --------------------------------------------------------
void add_FlvCDNError5Count(void)
{
  ++dword_F4428;
}
// F4428: using guessed type int dword_F4428;

//----- (0005B6B8) --------------------------------------------------------
void add_FlvCDNError6Count(void)
{
  ++dword_F442C;
}
// F442C: using guessed type int dword_F442C;

//----- (0005B6D0) --------------------------------------------------------
void add_FlvCDNErrorxCount(void)
{
  ++dword_F4430;
}
// F4430: using guessed type int dword_F4430;

//----- (0005B6E8) --------------------------------------------------------
__int64 set_real_start_time(void)
{
  __int64 result; // r0

  result = getTime();
  unk_F4490 = result;
  return result;
}

//----- (0005B700) --------------------------------------------------------
int initSingleChannelStatistic(void)
{
  int result; // r0

  firstRecvData = 1;
  firstCard = 0;
  ioAllow = 1;
  fsdCount = 0;
  RegularInfo::reset((RegularInfo *)&lastChannelInfo);
  RegularInfo::reset((RegularInfo *)&currentChannelInfo);
  RegularInfo::reset((RegularInfo *)&lastSecondInfo);
  RegularInfo::reset((RegularInfo *)&currentSecondInfo);
  dword_2F6194 = 1;
  pthread_mutex_init((pthread_mutex_t *)&fsd_report_lock, 0);
  pthread_create((pthread_t *)&channelReqularReportThread, 0, (void *(*)(void *))channelRegularReporterProcess, 0);
  pthread_create((pthread_t *)&dataRateThread, 0, (void *(*)(void *))generateDataRate, 0);
  result = ThreadManager::saveThreadInfo((pthread_mutex_t *)threadManager, channelReqularReportThread, 1);
  if ( isSwitchEntry )
  {
    if ( continueSwitchCount == 1 && firstVout )
      unk_F4490 = noDataStartTime;
  }
  else
  {
    result = set_real_start_time();
  }
  firstVout = 0;
  isSwitchEntry = 0;
  return result;
}
// F3958: using guessed type int firstRecvData;
// F41B0: using guessed type int continueSwitchCount;
// F41BB: using guessed type char isSwitchEntry;
// F41C0: using guessed type char firstVout;
// F41C1: using guessed type char firstCard;
// F41C4: using guessed type int ioAllow;
// 2F6094: using guessed type int threadManager;
// 2F6194: using guessed type int dword_2F6194;
// 2F8100: using guessed type int fsdCount;
// 2F810C: using guessed type int channelReqularReportThread;

//----- (0005B810) --------------------------------------------------------
signed int __fastcall Base64Encode(int *a1, int *a2)
{
  int *v2; // r6
  int *v3; // r8
  unsigned int v4; // r1
  _BYTE *v5; // r0
  int v6; // r1
  int v7; // r7
  int v8; // r1
  signed int v9; // r4
  char *v10; // r0
  unsigned int *v12; // r3
  signed int v13; // r2
  _BYTE *v14; // [sp+4h] [bp-1Ch]

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(*a1 - 12) + 2;
  v14 = &unk_2FEF48;
  sub_C1588((int *)&v14, 4 * (v4 / 3) + 1, 0);
  v5 = v14;
  v6 = *v2;
  v7 = *(_DWORD *)(*v2 - 12);
  if ( *((_DWORD *)v14 - 1) >= 0 )
  {
    sub_C0BF4((int *)&v14);
    v6 = *v2;
    v5 = v14;
  }
  v8 = modp_b64_encode(v5, v6, v7);
  if ( v8 < 0 )
  {
    v9 = 0;
  }
  else
  {
    sub_C1588((int *)&v14, v8, 0);
    sub_C0480(v3, (int *)&v14);
    v9 = 1;
  }
  v10 = v14 - 12;
  if ( v14 - 12 != (_BYTE *)&dword_2FEF3C )
  {
    v12 = (unsigned int *)(v14 - 4);
    __dmb(0xFu);
    do
      v13 = __ldrex(v12);
    while ( __strex(v13 - 1, v12) );
    __dmb(0xFu);
    if ( v13 <= 0 )
      operator delete(v10);
  }
  return v9;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0005B928) --------------------------------------------------------
signed int __fastcall Base64Decode(_DWORD *a1, int *a2)
{
  int *v2; // r8
  _DWORD **v3; // r6
  int v4; // r3
  int v5; // r0
  _DWORD *v6; // r1
  signed int v7; // r7
  int v8; // r1
  signed int v9; // r4
  char *v10; // r0
  unsigned int *v12; // r3
  signed int v13; // r2
  _DWORD *v14; // [sp+4h] [bp-1Ch]

  v2 = a2;
  v3 = (_DWORD **)a1;
  v4 = *(_DWORD *)(*a1 - 12) >> 2;
  v14 = &unk_2FEF48;
  sub_C1588((int *)&v14, 3 * v4 + 2, 0);
  v5 = (int)v14;
  v6 = *v3;
  v7 = *(*v3 - 3);
  if ( *(v14 - 1) >= 0 )
  {
    sub_C0BF4((int *)&v14);
    v6 = *v3;
    v5 = (int)v14;
  }
  v8 = modp_b64_decode(v5, v6, v7);
  if ( v8 < 0 )
  {
    v9 = 0;
  }
  else
  {
    sub_C1588((int *)&v14, v8, 0);
    sub_C0480(v2, (int *)&v14);
    v9 = 1;
  }
  v10 = (char *)(v14 - 3);
  if ( v14 - 3 != &dword_2FEF3C )
  {
    v12 = v14 - 1;
    __dmb(0xFu);
    do
      v13 = __ldrex(v12);
    while ( __strex(v13 - 1, v12) );
    __dmb(0xFu);
    if ( v13 <= 0 )
      operator delete(v10);
  }
  return v9;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0005BA30) --------------------------------------------------------
int __fastcall modp_b64_encode(_BYTE *a1, int a2, int a3)
{
  int v3; // r11
  int v4; // r4
  _BYTE *v5; // r3
  int v6; // r12
  int v7; // r2
  int v8; // r8
  unsigned int v9; // r7
  unsigned int v10; // r6
  char *v11; // r9
  _BYTE *v12; // r10
  int v13; // r3
  char v14; // r2
  int result; // r0
  int v16; // t1
  unsigned int v17; // r2
  char v18; // r3
  int v19; // [sp+4h] [bp-24h]

  v3 = a3 - 2;
  v19 = a3;
  if ( a3 - 2 <= 0 )
  {
    v12 = a1;
    v7 = 0;
  }
  else
  {
    v4 = (int)(a1 + 4);
    v5 = a1;
    v6 = a2;
    v7 = 0;
    do
    {
      v8 = *(unsigned __int8 *)(a2 + v7);
      v7 += 3;
      v9 = *(unsigned __int8 *)(v6 + 1);
      v10 = *(unsigned __int8 *)(v6 + 2);
      v6 += 3;
      v11 = &byte_EA714[(v10 >> 6) | 4 * (v9 & 0xF)];
      LOBYTE(v9) = byte_EA714[((v9 >> 4) | 16 * (v8 & 3)) + 256];
      v5 += 4;
      LOBYTE(v11) = v11[256];
      v12 = (_BYTE *)v4;
      LOBYTE(v10) = byte_EA714[v10 + 512];
      v4 += 4;
      *(_BYTE *)(v4 - 8) = byte_EA714[v8];
      *(v5 - 3) = v9;
      *(v5 - 2) = (_BYTE)v11;
      *(v5 - 1) = v10;
    }
    while ( v7 < v3 );
  }
  if ( v19 != v7 )
  {
    if ( v19 - v7 == 1 )
    {
      v13 = *(unsigned __int8 *)(a2 + v7);
      v12 += 4;
      *(v12 - 2) = 61;
      *(v12 - 1) = 61;
      v14 = byte_EA714[v13];
      LOBYTE(v13) = byte_EA714[16 * (v13 & 3) + 256];
      *(v12 - 4) = v14;
      *(v12 - 3) = v13;
    }
    else
    {
      v16 = *(unsigned __int8 *)(a2 + v7);
      v12 += 4;
      v17 = *(unsigned __int8 *)(a2 + v7 + 1);
      *(v12 - 1) = 61;
      *(v12 - 4) = byte_EA714[v16];
      v18 = byte_EA714[4 * (v17 & 0xF) + 512];
      *(v12 - 3) = byte_EA714[(16 * (v16 & 3) | (v17 >> 4)) + 256];
      *(v12 - 2) = v18;
    }
  }
  result = v12 - a1;
  *v12 = 0;
  return result;
}

//----- (0005BB94) --------------------------------------------------------
int __fastcall modp_b64_decode(int result, _DWORD *a2, signed int a3)
{
  int v3; // r12
  int v4; // r8
  int v5; // r7
  unsigned int v6; // r3
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // t1
  unsigned int v10; // r2
  unsigned int v11; // [sp+4h] [bp-1Ch]

  v3 = result;
  if ( !a3 )
    result = 0;
  if ( !a3 )
    return result;
  if ( a3 <= 3 )
    return -1;
  v4 = a3 & 3;
  if ( a3 & 3 )
    return -1;
  if ( *((_BYTE *)a2 + a3 - 1) == 61 && (*((_BYTE *)a2 + a3 - 2) != 61 ? --a3 : (a3 -= 2), (v4 = a3 & 3) != 0) )
    v5 = a3 >> 2;
  else
    v5 = (a3 >> 2) - 1;
  v6 = *a2;
  if ( v5 > 0 )
  {
    v7 = *(_DWORD *)&byte_EA714[4 * (v6 >> 24) + 768] | *(_DWORD *)&byte_EA714[4 * (unsigned __int8)v6 + 1792] | *(_DWORD *)&byte_EA714[4 * ((v6 >> 16) & 0xFF) + 2816] | *(_DWORD *)&byte_EA714[4 * ((unsigned __int16)v6 >> 8) + 3840];
    if ( v7 > 0x1FFFFFE )
      return -1;
    v8 = v3 + 3 * v5;
    while ( 1 )
    {
      *(_DWORD *)v3 = v7;
      v3 += 3;
      v9 = a2[1];
      ++a2;
      v6 = v9;
      if ( v3 == v8 )
        break;
      v7 = *(_DWORD *)&byte_EA714[4 * (v6 >> 24) + 768] | *(_DWORD *)&byte_EA714[4 * (unsigned __int8)v6 + 1792] | *(_DWORD *)&byte_EA714[4 * ((unsigned __int16)v6 >> 8) + 3840] | *(_DWORD *)&byte_EA714[4 * ((v6 >> 16) & 0xFF) + 2816];
      if ( v7 > 0x1FFFFFE )
        return -1;
    }
  }
  if ( v4 == 1 )
  {
    v10 = *(_DWORD *)&byte_EA714[4 * (unsigned __int8)v6 + 1792];
    *(_BYTE *)v3 = v10;
LABEL_17:
    if ( v10 <= 0x1FFFFFE )
      return 3 * v5 + (3 * v4 >> 2);
    return -1;
  }
  if ( v4 == 2 )
  {
    v10 = *(_DWORD *)&byte_EA714[4 * ((unsigned __int16)v6 >> 8) + 3840] | *(_DWORD *)&byte_EA714[4
                                                                                                * (unsigned __int8)v6
                                                                                                + 1792];
    *(_BYTE *)v3 = v10;
    goto LABEL_17;
  }
  if ( v4 )
  {
    v10 = *(_DWORD *)&byte_EA714[4 * ((unsigned __int16)v6 >> 8) + 3840] | *(_DWORD *)&byte_EA714[4
                                                                                                * ((v6 >> 16) & 0xFF)
                                                                                                + 2816] | *(_DWORD *)&byte_EA714[4 * (unsigned __int8)v6 + 1792];
    *(_WORD *)v3 = v10;
    goto LABEL_17;
  }
  v11 = *(_DWORD *)&byte_EA714[4 * (v6 >> 24) + 768] | *(_DWORD *)&byte_EA714[4 * (unsigned __int8)v6 + 1792] | *(_DWORD *)&byte_EA714[4 * ((unsigned __int16)v6 >> 8) + 3840] | *(_DWORD *)&byte_EA714[4 * ((v6 >> 16) & 0xFF) + 2816];
  if ( v11 > 0x1FFFFFE )
    return -1;
  result = 3 * (v5 + 1);
  *(_WORD *)v3 = v11;
  *(_BYTE *)(v3 + 2) = BYTE2(v11);
  return result;
}

//----- (0005BE38) --------------------------------------------------------
unsigned int __fastcall null_cb(char *a1, unsigned int a2, unsigned int a3, void *a4)
{
  return a2 * a3;
}

//----- (0005BE40) --------------------------------------------------------
int __fastcall header_cb(char *a1, unsigned int a2, unsigned int a3, void *a4)
{
  int *v4; // r5
  unsigned int v5; // r7
  unsigned int v6; // r6
  int v8; // [sp+4h] [bp-1Ch]

  v4 = (int *)a4;
  v5 = a2;
  v6 = a3;
  v8 = 0;
  curl_easy_getinfo(*(_DWORD *)a4, 0x200002u, &v8);
  if ( v8 > 312 )
    curl_easy_setopt(*v4, 0x4E2Bu, null_cb);
  curl_easy_setopt(*v4, 0x4E6Fu, null_cb);
  return v5 * v6;
}

//----- (0005BEC8) --------------------------------------------------------
unsigned int __fastcall write_cb(char *a1, unsigned int a2, unsigned int a3, void *a4)
{
  unsigned int v4; // r4

  v4 = a3 * a2;
  sub_8149C(*((_DWORD *)a4 + 1), a1, a3 * a2);
  return v4;
}

//----- (0005BEE8) --------------------------------------------------------
CurlWrapper *__fastcall CurlWrapper::~CurlWrapper(CurlWrapper *this)
{
  CurlWrapper *v1; // r7
  int *v2; // r4
  int v3; // r6
  int v4; // r1
  int v5; // r1
  int v6; // r5
  int v7; // r0
  int v8; // r0
  void *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r4

  v1 = this;
  sub_88C24(*((_DWORD *)this + 7));
  free(*((void **)v1 + 7));
  v3 = (int)v1 + 4;
  v2 = (int *)*((_DWORD *)v1 + 1);
  if ( v2 != (int *)((char *)v1 + 4) )
  {
    while ( 1 )
    {
      v4 = v2[2];
      if ( v4 )
      {
        curl_multi_remove_handle(*((_DWORD **)v1 + 3), v4);
        curl_easy_cleanup(v2[2], v5);
      }
      v6 = *v2;
      sub_94CCC(v2);
      operator delete(v2);
      if ( v6 == v3 )
        break;
      v2 = (int *)v6;
    }
  }
  v7 = *((_DWORD *)v1 + 3);
  if ( v7 )
    curl_multi_cleanup(v7);
  curl_global_cleanup();
  v8 = *((_DWORD *)v1 + 4);
  if ( v8 )
    curl_slist_free_all(v8);
  v9 = (void *)*((_DWORD *)v1 + 10);
  if ( v9 )
    operator delete(v9);
  v10 = (_DWORD *)*((_DWORD *)v1 + 1);
  if ( v10 != (_DWORD *)v3 )
  {
    while ( 1 )
    {
      v11 = (_DWORD *)*v10;
      operator delete(v10);
      if ( v11 == (_DWORD *)v3 )
        break;
      v10 = v11;
    }
  }
  return v1;
}

//----- (0005BFF0) --------------------------------------------------------
int __fastcall CurlWrapper::http_init(CurlWrapper *this)
{
  int *v1; // r5
  int *v2; // r0
  int v3; // r4
  int v4; // r3
  int *v5; // r0
  int v6; // r3
  void *v7; // r0
  int v8; // r3
  int v9; // r3
  int v10; // r3
  int v11; // r3

  v1 = (int *)this;
  curl_global_init(3);
  v2 = curl_multi_init();
  v3 = v1[10];
  v4 = v1[11];
  v1[3] = (int)v2;
  if ( v3 != v4 )
  {
    v5 = (int *)v1[4];
    do
    {
      v5 = curl_slist_append((int)v5, v3);
      v6 = v1[11];
      v3 += 2052;
      v1[4] = (int)v5;
    }
    while ( v3 != v6 );
  }
  v7 = malloc(0x48u);
  v1[7] = (int)v7;
  sub_8B958((unsigned int)v7, -1, 0, (int)timer_cb, (int)v1);
  curl_multi_setopt(v1[3], 0x4E21u, (int)sock_cb, v8);
  curl_multi_setopt(v1[3], 0x2712u, (int)v1, v9);
  curl_multi_setopt(v1[3], 0x4E24u, (int)multi_timer_cb, v10);
  curl_multi_setopt(v1[3], 0x2715u, (int)v1, v11);
  return 0;
}

//----- (0005C0C4) --------------------------------------------------------
CurlWrapper *__fastcall CurlWrapper::CurlWrapper(CurlWrapper *this, int a2, int a3)
{
  CurlWrapper *v3; // r4
  const void *v4; // r7
  int v5; // r2
  int v6; // r2
  unsigned int v7; // r6
  int v9; // r8
  char *v10; // r0
  char *v11; // r9
  void *v12; // r0

  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  v3 = this;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 1) = (char *)this + 4;
  *((_DWORD *)this + 2) = (char *)this + 4;
  v4 = *(const void **)a3;
  v5 = *(_DWORD *)(a3 + 4);
  *((_DWORD *)this + 5) = 0;
  v6 = v5 - (_DWORD)v4;
  *((_DWORD *)this + 6) = 0;
  v7 = -133956095 * (v6 >> 2);
  if ( v7 )
  {
    if ( v7 > 0x1FF007 )
      sub_BFA08();
    v9 = 4 * (v6 >> 2);
    v10 = (char *)operator new(4 * (v6 >> 2));
    v11 = v10;
    if ( v7 )
      memmove(v10, v4, 2052 * v7);
    v12 = (void *)*((_DWORD *)v3 + 10);
    if ( v12 )
      operator delete(v12);
    *((_DWORD *)v3 + 10) = v11;
    *((_DWORD *)v3 + 11) = &v11[v9];
    *((_DWORD *)v3 + 12) = &v11[v9];
  }
  CurlWrapper::http_init(v3);
  return v3;
}

//----- (0005C1C4) --------------------------------------------------------
CurlWrapper *__fastcall CurlWrapper::createNew(int a1, int a2)
{
  int v2; // r4
  int v3; // r12
  const void *v4; // r1
  int v5; // r5
  unsigned int v6; // r12
  size_t v7; // r4
  int v8; // r6
  char *v9; // r3
  CurlWrapper *v10; // r4
  char *v12; // r0
  void *v13; // [sp+4h] [bp-1Ch]
  char *v14; // [sp+8h] [bp-18h]
  char *v15; // [sp+Ch] [bp-14h]

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(const void **)a2;
  v5 = a1;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v6 = -133956095 * ((v3 - (signed int)v4) >> 2);
  if ( v6 )
  {
    if ( v6 > 0x1FF007 )
      sub_BFA08();
    v8 = 2052 * v6;
    v12 = (char *)operator new(2052 * v6);
    v4 = *(const void **)v2;
    v6 = -133956095 * ((*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 2);
    v7 = 4 * ((*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 2);
    v9 = v12;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
  }
  v13 = v9;
  v15 = &v9[v8];
  v14 = v9;
  if ( v6 )
    v9 = (char *)memmove(v9, v4, v7);
  v14 = &v9[v7];
  v10 = (CurlWrapper *)operator new(0x34u);
  CurlWrapper::CurlWrapper(v10, v5, (int)&v13);
  if ( v13 )
    operator delete(v13);
  return v10;
}

//----- (0005C2E4) --------------------------------------------------------
void __fastcall CurlWrapper::stopDownload(CurlWrapper *this, char *a2, char *a3)
{
  int v3; // r4
  char *v4; // r5
  char *v5; // r6
  char *v6; // r7
  signed int v7; // r9
  int v8; // r8

  v4 = (char *)this + 4;
  v3 = *((_DWORD *)this + 1);
  v5 = a2;
  v6 = a3;
  if ( (CurlWrapper *)((char *)this + 4) != (CurlWrapper *)v3 )
  {
    v7 = 0;
    do
    {
      if ( !strcmp((const char *)(v3 + 12), v5) && !strcmp((const char *)(v3 + 1036), v6) )
      {
        if ( !v7 )
          curl_easy_pause(*(_DWORD **)(v3 + 8), 5);
        v8 = *(_DWORD *)v3;
        sub_94CCC((int *)v3);
        operator delete((void *)v3);
        v7 = 1;
        v3 = v8;
      }
      v3 = *(_DWORD *)v3;
    }
    while ( v4 != (char *)v3 );
  }
}

//----- (0005C374) --------------------------------------------------------
void __fastcall CurlWrapper::removeEasyItem(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  const char *v4; // r7
  const char *v5; // r6

  v3 = a1 + 4;
  v2 = *(_DWORD *)(a1 + 4);
  if ( a1 + 4 != v2 )
  {
    v4 = (const char *)(a2 + 12);
    v5 = (const char *)(a2 + 2329);
    while ( strcmp((const char *)(v2 + 12), v4) || strcmp((const char *)(v2 + 1036), v5) )
    {
      v2 = *(_DWORD *)v2;
      if ( v3 == v2 )
        return;
    }
    sub_94CCC((int *)v2);
    operator delete((void *)v2);
  }
}

//----- (0005C3EC) --------------------------------------------------------
signed int __fastcall CurlWrapper::setsock(int a1, int *a2, int a3, int a4)
{
  int *v4; // r4
  int v5; // r12
  int v6; // r1
  signed __int16 v7; // r2
  signed __int16 v8; // r6
  int v9; // r7
  __int16 v10; // r6

  v4 = a2;
  v5 = a2[21];
  v6 = a3;
  if ( a4 & 1 )
    v7 = 18;
  else
    v7 = 16;
  *v4 = v6;
  v4[1] = a4;
  if ( a4 & 2 )
    v8 = 4;
  else
    v8 = 0;
  v9 = a1;
  v10 = v8 | v7;
  if ( v5 )
  {
    sub_88C24((unsigned int)(v4 + 3));
    v6 = *v4;
  }
  sub_8B958((unsigned int)(v4 + 3), v6, v10, (int)event_cb, v9);
  v4[21] = 1;
  return sub_8AD50((int)(v4 + 3), 0);
}

//----- (0005C474) --------------------------------------------------------
signed int __fastcall CurlWrapper::addsock(CurlWrapper *this, int a2, int a3)
{
  CurlWrapper *v3; // r5
  int v4; // r4
  int v5; // r7
  int *v6; // r6

  v3 = this;
  v4 = a2;
  v5 = a3;
  v6 = (int *)calloc(0x58u, 1u);
  CurlWrapper::setsock((int)v3, v6, v4, v5);
  return j_curl_multi_assign(*((_DWORD *)v3 + 3), v4, (int)v6);
}

//----- (0005C4BC) --------------------------------------------------------
void __fastcall CurlWrapper::remsock(int a1, _DWORD *a2)
{
  void *v2; // r4

  v2 = a2;
  if ( a2 )
  {
    if ( a2[21] )
    {
      sub_88C24((unsigned int)(a2 + 3));
      free(v2);
    }
    else
    {
      free(a2);
    }
  }
}

//----- (0005C4F8) --------------------------------------------------------
int __fastcall CurlWrapper::check_run_count(int result)
{
  int v1; // r3
  int v2; // r4
  int v3; // r6
  int v4; // r9
  bool v5; // zf
  int v6; // r9
  int v7; // r1
  char *src; // [sp+4h] [bp-2Ch]
  char v9; // [sp+8h] [bp-28h]
  int v10; // [sp+Ch] [bp-24h]

  v1 = *(_DWORD *)(result + 20);
  v2 = result;
  if ( *(_DWORD *)(result + 24) > v1 )
  {
    src = 0;
    v10 = 0;
    while ( 1 )
    {
      result = (int)curl_multi_info_read(*(_DWORD **)(v2 + 12), (int *)&v9);
      if ( !result )
        break;
      if ( *(_DWORD *)result == 1 )
      {
        v3 = *(_DWORD *)(result + 4);
        v4 = *(_DWORD *)(result + 8);
        if ( !v3 )
          break;
        curl_easy_getinfo(*(_DWORD *)(result + 4), 0x100015u, &v10);
        curl_easy_getinfo(v3, 0x100001u, &src);
        curl_easy_getinfo(v3, 0x30000Fu, v10 + 2320);
        curl_easy_getinfo(v3, 0x200002u, v10 + 2060);
        if ( src )
          strcpy((char *)(v10 + 12), src);
        CurlWrapper::removeEasyItem(v2, v10);
        v5 = v4 == 0;
        v6 = *(_DWORD *)(v10 + 4);
        if ( v5 && *(_DWORD *)(v10 + 2060) < 308 )
          (*(void (**)(void))(v10 + 2432))();
        else
          (*(void (**)(void))(v10 + 2436))();
        curl_multi_remove_handle(*(_DWORD **)(v2 + 12), v3);
        curl_easy_cleanup(v3, v7);
        if ( v6 )
          sub_800C4(v6);
      }
    }
    v1 = *(_DWORD *)(v2 + 20);
  }
  *(_DWORD *)(v2 + 24) = v1;
  return result;
}

//----- (0005C644) --------------------------------------------------------
int __fastcall CurlWrapper::new_session(int *a1, const char *a2, int a3, int a4, int a5, int a6)
{
  int v6; // r6
  int v7; // r8
  const char *v8; // r9
  int *v9; // r4
  int v10; // ST04_4
  void *v11; // r0
  int v12; // r1
  int v13; // r2
  const char *v14; // r8
  int v15; // r5
  _DWORD *v16; // r0
  _DWORD *v17; // r6
  void *v18; // r0
  signed int v19; // r0
  signed int v20; // r0
  int result; // r0
  int v22; // [sp+14h] [bp+0h]
  int v23; // [sp+18h] [bp+4h]
  int v24; // [sp+418h] [bp+404h]
  int v25; // [sp+47Ch] [bp+468h]

  v6 = a3;
  v7 = a3 + 2320;
  v8 = a2;
  v9 = a1;
  v10 = a4;
  v11 = memset(&v22, 0, 0x468u);
  v14 = (const char *)(v7 + 9);
  v15 = curl_easy_init((int)v11, v12, v13);
  v22 = v15;
  strcpy((char *)&v23, v8);
  strcpy((char *)&v24, v14);
  *(_DWORD *)v6 = v15;
  *(_DWORD *)(v6 + 2432) = a5;
  *(_DWORD *)(v6 + 2436) = a6;
  curl_easy_setopt(v15, 0x2712u, v8);
  curl_easy_setopt(v15, 0x4E2Bu, v10);
  curl_easy_setopt(v15, 0x2711u, v6);
  curl_easy_setopt(v15, 0x4E6Fu, header_cb);
  curl_easy_setopt(v15, 0x272Du, v6);
  curl_easy_setopt(v15, 0x29u, 0);
  curl_easy_setopt(v15, 0x271Au, v6 + 2064);
  curl_easy_setopt(v15, 0x2777u, v6);
  curl_easy_setopt(v15, 0x2Bu, 1);
  curl_easy_setopt(v15, 0xDu, 16);
  curl_easy_setopt(v15, 0x34u, 1);
  if ( v9[4] )
    curl_easy_setopt(v15, 0x2727u);
  if ( *(_BYTE *)(v6 + 2328) )
    curl_easy_setopt(v15, 0x2717u, v14);
  v16 = operator new(0x470u);
  v17 = v16;
  v18 = v16 + 2;
  if ( v18 )
    memcpy(v18, &v22, 0x468u);
  sub_94CBC(v17, (int)(v9 + 1));
  v19 = curl_multi_add_handle((_DWORD *)v9[3], v15);
  CurlWrapper::mcode_or_die(v9, "new_conn: curl_multi_add_handle", v19);
  do
    v20 = curl_multi_socket_all(v9[3], v9 + 5);
  while ( v20 == -1 );
  result = CurlWrapper::mcode_or_die(v9, "new_conn: curl_multi_socket_all", v20);
  if ( v25 == _stack_chk_guard )
    result = CurlWrapper::check_run_count((int)v9);
  return result;
}
// 5C4F4: using guessed type int __fastcall CurlWrapper::mcode_or_die(_DWORD, _DWORD, _DWORD);

//----- (0005C87C) --------------------------------------------------------
int __fastcall CurlWrapper::new_conn(int *a1, const char *a2, int a3, int a4, int a5)
{
  int v5; // r4
  int *v6; // r5
  const char *v7; // r6
  int v8; // r7
  _DWORD *v9; // r0

  v5 = a3;
  v6 = a1;
  v7 = a2;
  v8 = a4;
  v9 = sub_7FA70();
  *(_DWORD *)(v5 + 4) = v9;
  if ( !v9 )
    exit(1);
  return CurlWrapper::new_session(v6, v7, v5, (int)write_cb, v8, a5);
}

//----- (0005C8DC) --------------------------------------------------------
int *__fastcall CurlWrapper::processEvent(CurlWrapper *this, int a2, __int16 a3)
{
  int v3; // r5
  _DWORD *v4; // r6
  CurlWrapper *v5; // r4
  int v6; // r7
  signed int v7; // r0
  int *result; // r0

  v3 = ((unsigned int)(unsigned __int16)a3 >> 1) & 1;
  v4 = (_DWORD *)((char *)this + 20);
  if ( a3 & 4 )
    v3 |= 2u;
  v5 = this;
  v6 = a2;
  do
    v7 = curl_multi_socket_action(*((_DWORD *)v5 + 3), v6, v3, v4);
  while ( v7 == -1 );
  CurlWrapper::mcode_or_die(v5, "event_cb: curl_multi_socket", v7);
  result = (int *)CurlWrapper::check_run_count((int)v5);
  if ( *((_DWORD *)v5 + 5) <= 0 )
  {
    result = (int *)sub_88310(*((_DWORD *)v5 + 7), 1, 0);
    if ( result )
      result = sub_88C24(*((_DWORD *)v5 + 7));
  }
  return result;
}
// 5C4F4: using guessed type int __fastcall CurlWrapper::mcode_or_die(_DWORD, _DWORD, _DWORD);

//----- (0005C968) --------------------------------------------------------
int *__fastcall event_cb(int a1, __int16 a2, CurlWrapper *this)
{
  return CurlWrapper::processEvent(this, a1, a2);
}

//----- (0005C980) --------------------------------------------------------
int __fastcall CurlWrapper::processSock(CurlWrapper *this, void *a2, int a3, int a4, void *a5)
{
  if ( a4 == 4 )
  {
    CurlWrapper::remsock((int)this, a5);
  }
  else if ( a5 )
  {
    CurlWrapper::setsock((int)this, (int *)a5, a3, a4);
  }
  else
  {
    CurlWrapper::addsock(this, a3, a4);
  }
  return 0;
}

//----- (0005C9BC) --------------------------------------------------------
int __fastcall sock_cb(void *a1, int a2, int a3, CurlWrapper *this, void *a5)
{
  return CurlWrapper::processSock(this, a1, a2, a3, a5);
}

//----- (0005C9E0) --------------------------------------------------------
int __fastcall CurlWrapper::processTimer(CurlWrapper *this, int a2, __int16 a3)
{
  _DWORD *v3; // r5
  CurlWrapper *v4; // r4
  signed int v5; // r0

  v3 = (_DWORD *)((char *)this + 20);
  v4 = this;
  do
    v5 = curl_multi_socket_action(*((_DWORD *)v4 + 3), -1, 0, v3);
  while ( v5 == -1 );
  CurlWrapper::mcode_or_die(v4, "timer_cb: curl_multi_socket", v5);
  return CurlWrapper::check_run_count((int)v4);
}
// 5C4F4: using guessed type int __fastcall CurlWrapper::mcode_or_die(_DWORD, _DWORD, _DWORD);

//----- (0005CA2C) --------------------------------------------------------
int __fastcall timer_cb(int a1, __int16 a2, CurlWrapper *this)
{
  return CurlWrapper::processTimer(this, a1, a2);
}

//----- (0005CA44) --------------------------------------------------------
int __fastcall CurlWrapper::processMultiTimer(CurlWrapper *this, void *a2, int a3)
{
  int v3; // r0
  int v5; // [sp+0h] [bp-10h]
  int v6; // [sp+4h] [bp-Ch]

  v3 = *((_DWORD *)this + 7);
  v5 = a3 / 1000;
  v6 = 1000 * (a3 % 1000);
  sub_8AD50(v3, &v5);
  return 0;
}

//----- (0005CA8C) --------------------------------------------------------
int __fastcall multi_timer_cb(void *a1, int a2, CurlWrapper *this)
{
  return CurlWrapper::processMultiTimer(this, a1, a2);
}

//----- (0005CAA4) --------------------------------------------------------
_DWORD *__fastcall CurlWrapper::getUrlFromHttpInfo(_DWORD *result)
{
  _DWORD *v1; // [sp+4h] [bp-Ch]

  if ( result )
  {
    result = (_DWORD *)*result;
    if ( result )
    {
      v1 = 0;
      curl_easy_getinfo((int)result, 0x100001u, &v1);
      result = v1;
    }
  }
  return result;
}

//----- (0005CAE4) --------------------------------------------------------
int __fastcall sub_5CAE4(int a1, int a2, int a3)
{
  return (*(int (__fastcall **)(_DWORD, signed int))(a3 + 4))(*(_DWORD *)(a3 + 8), 2);
}

//----- (0005CAFC) --------------------------------------------------------
bool __fastcall LibEventTaskScheduler::isActive(LibEventTaskScheduler *this)
{
  _DWORD *v1; // r3
  _BOOL4 result; // r0

  v1 = (_DWORD *)*((_DWORD *)this + 4);
  if ( v1 )
    result = *v1 == 0;
  else
    result = 1;
  return result;
}

//----- (0005CB20) --------------------------------------------------------
signed int __fastcall LibEventTaskScheduler::exitLoop(LibEventTaskScheduler *this)
{
  char *v1; // r4
  int v3; // [sp+8h] [bp-10h]
  int v4; // [sp+Ch] [bp-Ch]

  v1 = (char *)this + 20;
  v3 = 0;
  v4 = 0;
  sub_8B958((unsigned int)this + 20, -1, 0, (int)sub_5CEF8, (int)this);
  return sub_8AD50((int)v1, &v3);
}
// 5CEF8: using guessed type int sub_5CEF8();

//----- (0005CB6C) --------------------------------------------------------
signed int sub_5CB6C()
{
  int v1; // [sp+0h] [bp-10h]
  int v2; // [sp+4h] [bp-Ch]

  v1 = 5;
  v2 = 0;
  return sub_8BD94(&v1);
}

//----- (0005CB90) --------------------------------------------------------
LibEventTaskScheduler *__fastcall LibEventTaskScheduler::~LibEventTaskScheduler(LibEventTaskScheduler *this, HashTable *a2)
{
  LibEventTaskScheduler *v2; // r5
  int v3; // r0
  HashTable *v4; // r1
  void *v5; // r4
  int v6; // r0
  _DWORD *v7; // r0
  _DWORD *v8; // r4
  int v9; // r0
  void *v10; // r4
  int v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r4

  v2 = this;
  *(_DWORD *)this = off_F02E8;
  while ( 1 )
  {
    v3 = HashTable::RemoveNext(*((HashTable **)v2 + 23), a2);
    v5 = (void *)v3;
    if ( !v3 )
      break;
    sub_88C24(v3 + 12);
    free(v5);
  }
  v6 = *((_DWORD *)v2 + 23);
  if ( v6 )
    (*(void (**)(void))(*(_DWORD *)v6 + 4))();
  v7 = (_DWORD *)*((_DWORD *)v2 + 24);
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = (_DWORD *)*v7;
      free(v7);
      if ( !v8 )
        break;
      v7 = v8;
    }
  }
  while ( 1 )
  {
    v9 = HashTable::RemoveNext(*((HashTable **)v2 + 26), v4);
    v10 = (void *)v9;
    if ( !v9 )
      break;
    sub_88C24(v9 + 16);
    free(v10);
  }
  v11 = *((_DWORD *)v2 + 26);
  if ( v11 )
    (*(void (**)(void))(*(_DWORD *)v11 + 4))();
  v12 = (_DWORD *)*((_DWORD *)v2 + 27);
  if ( v12 )
  {
    while ( 1 )
    {
      v13 = (_DWORD *)*v12;
      free(v12);
      if ( !v13 )
        break;
      v12 = v13;
    }
  }
  sub_88C24(*((_DWORD *)v2 + 2));
  sub_88C24(*((_DWORD *)v2 + 1));
  sub_88C24((unsigned int)v2 + 20);
  free(*((void **)v2 + 1));
  free(*((void **)v2 + 2));
  sub_8C2B8(*((char **)v2 + 3));
  TaskScheduler::~TaskScheduler((int)v2);
  return v2;
}
// F02E8: using guessed type _DWORD (__fastcall *off_F02E8[2])(LibEventTaskScheduler *__hidden this);

//----- (0005CCB8) --------------------------------------------------------
LibEventTaskScheduler *__fastcall LibEventTaskScheduler::~LibEventTaskScheduler(LibEventTaskScheduler *this, HashTable *a2)
{
  LibEventTaskScheduler *v2; // r4

  v2 = this;
  LibEventTaskScheduler::~LibEventTaskScheduler(this, a2);
  operator delete((void *)v2);
  return v2;
}

//----- (0005CCD4) --------------------------------------------------------
void __fastcall LibEventTaskScheduler::registerEvent(LibEventTaskScheduler *this, int a2, __int16 a3, void (__cdecl *a4)(int, __int16, void *))
{
  int v4; // r7
  __int16 v5; // r6
  void (__cdecl *v6)(int, __int16, void *); // r5
  void *v7; // r4

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( a2 >= 0 )
  {
    v7 = malloc(0x48u);
    sub_8B958((unsigned int)v7, v4, v5, (int)v6, (int)v7);
    sub_8AD50((int)v7, 0);
  }
}

//----- (0005CD28) --------------------------------------------------------
LibEventTaskScheduler *__fastcall LibEventTaskScheduler::LibEventTaskScheduler(LibEventTaskScheduler *this, volatile int *a2)
{
  LibEventTaskScheduler *v2; // r4
  volatile int *v3; // r5
  int v4; // r1
  int v5; // r1
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  void *v10; // r0
  void *v11; // r0
  int v13; // [sp+8h] [bp-18h]
  int v14; // [sp+Ch] [bp-14h]

  v2 = this;
  v3 = a2;
  TaskScheduler::TaskScheduler((int)this);
  *((_DWORD *)v2 + 4) = v3;
  *(_DWORD *)v2 = off_F02E8;
  *((_DWORD *)v2 + 23) = HashTable::create((HashTable *)((char *)&dword_0 + 1), v4);
  *((_DWORD *)v2 + 24) = 0;
  *((_DWORD *)v2 + 25) = 0;
  *((_DWORD *)v2 + 26) = HashTable::create((HashTable *)((char *)&dword_0 + 1), v5);
  *((_DWORD *)v2 + 27) = 0;
  *((_DWORD *)v2 + 28) = 0;
  v6 = bsd_signal(13, 1);
  *((_DWORD *)v2 + 3) = sub_8CAF4(v6, v7, v8, v9);
  v10 = malloc(0x48u);
  *((_DWORD *)v2 + 1) = v10;
  sub_8B958((unsigned int)v10, 2, 24, (int)sub_5CB6C, 0);
  sub_88084(*((_DWORD *)v2 + 3), *((_DWORD *)v2 + 1));
  sub_8AD50(*((_DWORD *)v2 + 1), 0);
  v11 = malloc(0x48u);
  *((_DWORD *)v2 + 2) = v11;
  sub_8B958((unsigned int)v11, 15, 24, (int)sub_5CB6C, 0);
  sub_88084(*((_DWORD *)v2 + 3), *((_DWORD *)v2 + 2));
  sub_8AD50(*((_DWORD *)v2 + 2), 0);
  v14 = 0;
  v13 = 1;
  sub_8B958((unsigned int)v2 + 20, -1, 0, (int)sub_5CEF8, (int)v2);
  sub_8AD50((int)v2 + 20, &v13);
  return v2;
}
// 0: using guessed type int dword_0;
// 2582C: using guessed type int __fastcall bsd_signal(_DWORD, _DWORD);
// 5CEF8: using guessed type int sub_5CEF8();
// F02E8: using guessed type _DWORD (__fastcall *[2])(LibEventTaskScheduler *__hidden this);

//----- (0005CE78) --------------------------------------------------------
LibEventTaskScheduler *__fastcall LibEventTaskScheduler::createNew(LibEventTaskScheduler *this, volatile int *a2)
{
  LibEventTaskScheduler *v2; // r5
  LibEventTaskScheduler *v3; // r4

  v2 = this;
  v3 = (LibEventTaskScheduler *)operator new(0x74u);
  LibEventTaskScheduler::LibEventTaskScheduler(v3, (volatile int *)v2);
  return v3;
}

//----- (0005CEA8) --------------------------------------------------------
signed int __fastcall LibEventTaskScheduler::wakeUp(LibEventTaskScheduler *this)
{
  char *v1; // r4
  int v3; // [sp+8h] [bp-10h]
  int v4; // [sp+Ch] [bp-Ch]

  v1 = (char *)this + 20;
  v4 = 0;
  v3 = 1;
  sub_8B958((unsigned int)this + 20, -1, 0, (int)sub_5CEF8, (int)this);
  return sub_8AD50((int)v1, &v3);
}
// 5CEF8: using guessed type int sub_5CEF8();

//----- (0005CF00) --------------------------------------------------------
signed int __fastcall LibEventTaskScheduler::SingleStep(LibEventTaskScheduler *this)
{
  return sub_8A33C(*((int **)this + 3), 1);
}

//----- (0005CF0C) --------------------------------------------------------
LibEventTaskScheduler *__fastcall LibEventTaskScheduler::doEventLoop(LibEventTaskScheduler *this, volatile int *a2)
{
  volatile int *v2; // r5
  LibEventTaskScheduler *v3; // r4
  LibEventTaskScheduler *result; // r0

  v2 = a2;
  v3 = this;
  if ( !a2 )
  {
    while ( 1 )
    {
      LibEventTaskScheduler::SingleStep(v3);
      LibEventTaskScheduler::SingleStep(v3);
    }
  }
  while ( 1 )
  {
    result = v3;
    if ( *v2 )
      break;
    LibEventTaskScheduler::SingleStep(v3);
  }
  return result;
}

//----- (0005CF48) --------------------------------------------------------
_DWORD *__fastcall LibEventTaskScheduler::getDelayedHandler(LibEventTaskScheduler *this)
{
  LibEventTaskScheduler *v1; // r5
  _DWORD *v2; // r4
  int v3; // r0

  v1 = this;
  v2 = (_DWORD *)*((_DWORD *)this + 27);
  if ( v2 )
    *((_DWORD *)this + 27) = *v2;
  else
    v2 = malloc(0x58u);
  v3 = *((_DWORD *)v1 + 26);
  *v2 = 0;
  (*(void (**)(void))(*(_DWORD *)v3 + 8))();
  return v2;
}

//----- (0005CF9C) --------------------------------------------------------
_DWORD *__fastcall LibEventTaskScheduler::scheduleDelayedTask(LibEventTaskScheduler *this, int a2, __int64 a3, void (__cdecl *a4)(void *), void *a5)
{
  __int64 v5; // r4
  LibEventTaskScheduler *v6; // r6
  _DWORD *v7; // r0
  int v8; // r5
  _DWORD *v9; // r4
  int v11; // [sp+8h] [bp-20h]
  int v12; // [sp+Ch] [bp-1Ch]

  v5 = a3;
  v6 = this;
  if ( a3 < 0 )
    v5 = 0LL;
  v11 = v5 / 1000000;
  v12 = v5 % 1000000;
  v7 = LibEventTaskScheduler::getDelayedHandler(this);
  v8 = (int)(v7 + 4);
  v9 = v7;
  v7[1] = a4;
  v7[2] = a5;
  v7[3] = v6;
  sub_8B958((unsigned int)(v7 + 4), -1, 0, (int)sub_5D098, (int)v7);
  sub_8AD50(v8, &v11);
  return v9;
}

//----- (0005D054) --------------------------------------------------------
int __fastcall LibEventTaskScheduler::recycleDelayedHandler(int a1, _DWORD *a2)
{
  int v2; // r4
  _DWORD *v3; // r5
  int result; // r0

  v2 = a1;
  v3 = a2;
  result = (*(int (**)(void))(**(_DWORD **)(a1 + 104) + 12))();
  if ( *(_DWORD *)(v2 + 108) )
  {
    **(_DWORD **)(v2 + 112) = v3;
    *(_DWORD *)(v2 + 112) = v3;
    *v3 = 0;
  }
  else
  {
    *(_DWORD *)(v2 + 112) = v3;
    *(_DWORD *)(v2 + 108) = v3;
  }
  return result;
}

//----- (0005D098) --------------------------------------------------------
int __fastcall sub_5D098(int a1, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r5

  v3 = (_DWORD *)a3;
  v4 = *(_DWORD *)(a3 + 12);
  (*(void (__fastcall **)(_DWORD))(a3 + 4))(*(_DWORD *)(a3 + 8));
  return LibEventTaskScheduler::recycleDelayedHandler(v4, v3);
}

//----- (0005D0C0) --------------------------------------------------------
int __fastcall LibEventTaskScheduler::unscheduleDelayedTask(int result, void **a2)
{
  void **v2; // r4
  int v3; // r5
  _DWORD *v4; // r6

  v2 = a2;
  v3 = result;
  if ( *a2 )
  {
    result = (*(int (**)(void))(**(_DWORD **)(result + 104) + 16))();
    v4 = (_DWORD *)result;
    if ( result )
    {
      sub_88C24(result + 16);
      result = LibEventTaskScheduler::recycleDelayedHandler(v3, v4);
      *v2 = 0;
    }
    else
    {
      *v2 = (void *)result;
    }
  }
  return result;
}

//----- (0005D114) --------------------------------------------------------
_DWORD *__fastcall LibEventTaskScheduler::getSocksHandler(LibEventTaskScheduler *this, int a2)
{
  LibEventTaskScheduler *v2; // r5
  _DWORD *v3; // r4
  int v4; // r0

  v2 = this;
  v3 = (_DWORD *)*((_DWORD *)this + 24);
  if ( v3 )
    *((_DWORD *)this + 24) = *v3;
  else
    v3 = malloc(0x54u);
  v4 = *((_DWORD *)v2 + 23);
  *v3 = 0;
  (*(void (**)(void))(*(_DWORD *)v4 + 8))();
  return v3;
}

//----- (0005D174) --------------------------------------------------------
int __fastcall LibEventTaskScheduler::turnOnBackgroundReadHandling(int result, int a2, void (__cdecl *a3)(void *, int), void *a4)
{
  int v4; // r8
  LibEventTaskScheduler *v5; // r5
  void (__cdecl *v6)(void *, int); // r6
  void *v7; // r7
  _DWORD *v8; // r4
  _DWORD *v9; // r0
  int v10; // r5

  v4 = a2;
  v5 = (LibEventTaskScheduler *)result;
  v6 = a3;
  v7 = a4;
  if ( a2 >= 0 )
  {
    result = (*(int (**)(void))(**(_DWORD **)(result + 92) + 16))();
    v8 = (_DWORD *)result;
    if ( result )
    {
      *(_DWORD *)(result + 4) = v6;
      *(_DWORD *)(result + 8) = v7;
    }
    else
    {
      v9 = LibEventTaskScheduler::getSocksHandler(v5, v4);
      v10 = (int)(v9 + 3);
      v9[1] = v6;
      v9[2] = v7;
      sub_8B958((unsigned int)(v9 + 3), v4, 18, (int)sub_5CAE4, (int)v9);
      result = sub_8AD50(v10, v8);
    }
  }
  return result;
}

//----- (0005D1FC) --------------------------------------------------------
int __fastcall LibEventTaskScheduler::recycleSocksHandler(int a1, _DWORD *a2)
{
  int v2; // r4
  _DWORD *v3; // r5
  int result; // r0

  v2 = a1;
  v3 = a2;
  result = (*(int (**)(void))(**(_DWORD **)(a1 + 92) + 12))();
  if ( *(_DWORD *)(v2 + 96) )
  {
    **(_DWORD **)(v2 + 100) = v3;
    *(_DWORD *)(v2 + 100) = v3;
    *v3 = 0;
  }
  else
  {
    *(_DWORD *)(v2 + 100) = v3;
    *(_DWORD *)(v2 + 96) = v3;
  }
  return result;
}

//----- (0005D244) --------------------------------------------------------
int __fastcall LibEventTaskScheduler::turnOffBackgroundReadHandling(int result, int a2)
{
  int v2; // r4
  _DWORD *v3; // r5

  v2 = result;
  if ( a2 >= 0 )
  {
    result = (*(int (**)(void))(**(_DWORD **)(result + 92) + 16))();
    v3 = (_DWORD *)result;
    if ( result )
    {
      sub_88C24(result + 12);
      result = LibEventTaskScheduler::recycleSocksHandler(v2, v3);
    }
  }
  return result;
}

//----- (0005D288) --------------------------------------------------------
int __fastcall BasicHashTable::numEntries(BasicHashTable *this)
{
  return *((_DWORD *)this + 7);
}

//----- (0005D290) --------------------------------------------------------
int __fastcall BasicHashTable::Iterator::next(BasicHashTable::Iterator *this, const char **a2)
{
  _DWORD *v2; // r3
  int v3; // r3
  unsigned int v4; // r2
  unsigned int v5; // r4
  int v6; // r12
  _DWORD *v7; // t1
  const char *v8; // r2
  int result; // r0

  v2 = (_DWORD *)*((_DWORD *)this + 3);
  if ( v2 )
  {
LABEL_7:
    v8 = (const char *)v2[1];
    *((_DWORD *)this + 3) = *v2;
    *a2 = v8;
    result = v2[2];
  }
  else
  {
    v3 = *((_DWORD *)this + 1);
    v4 = *((_DWORD *)this + 2);
    v5 = *(_DWORD *)(v3 + 24);
    if ( v4 < v5 )
    {
      v6 = *(_DWORD *)(v3 + 4) + 4 * (v4 + 0x3FFFFFFF);
      do
      {
        v7 = *(_DWORD **)(v6 + 4);
        v6 += 4;
        v2 = v7;
        ++v4;
        *((_DWORD *)this + 3) = v7;
        if ( v7 )
        {
          *((_DWORD *)this + 2) = v4;
          goto LABEL_7;
        }
      }
      while ( v4 < v5 );
      *((_DWORD *)this + 2) = v4;
    }
    result = 0;
  }
  return result;
}

//----- (0005D310) --------------------------------------------------------
BasicHashTable::Iterator *__fastcall BasicHashTable::Iterator::~Iterator(BasicHashTable::Iterator *this)
{
  BasicHashTable::Iterator *v1; // r4

  v1 = this;
  *(_DWORD *)this = off_F0320;
  HashTable::Iterator::~Iterator((int)this);
  return v1;
}
// F0320: using guessed type _DWORD (__fastcall *off_F0320[2])(BasicHashTable::Iterator *__hidden this);

//----- (0005D338) --------------------------------------------------------
BasicHashTable::Iterator *__fastcall BasicHashTable::Iterator::~Iterator(BasicHashTable::Iterator *this)
{
  BasicHashTable::Iterator *v1; // r4

  v1 = this;
  *(_DWORD *)this = off_F0320;
  HashTable::Iterator::~Iterator((int)this);
  operator delete((void *)v1);
  return v1;
}
// F0320: using guessed type _DWORD (__fastcall *off_F0320[2])(BasicHashTable::Iterator *__hidden this);

//----- (0005D368) --------------------------------------------------------
BasicHashTable *__fastcall BasicHashTable::BasicHashTable(BasicHashTable *this, int a2)
{
  BasicHashTable *v2; // r4
  int v3; // r8
  BasicHashTable *result; // r0

  v2 = this;
  v3 = a2;
  HashTable::HashTable((int)this);
  *(_DWORD *)v2 = off_F0338;
  result = v2;
  *((_DWORD *)v2 + 11) = v3;
  *((_DWORD *)v2 + 1) = (char *)v2 + 8;
  *((_DWORD *)v2 + 6) = 4;
  *((_DWORD *)v2 + 8) = 12;
  *((_DWORD *)v2 + 9) = 28;
  *((_DWORD *)v2 + 10) = 3;
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 2) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 0;
  return result;
}
// F0338: using guessed type _DWORD (__fastcall *[2])(BasicHashTable *this);

//----- (0005D3D8) --------------------------------------------------------
BasicHashTable::Iterator *__fastcall BasicHashTable::Iterator::Iterator(BasicHashTable::Iterator *this, BasicHashTable *a2)
{
  BasicHashTable::Iterator *v2; // r4
  BasicHashTable *v3; // r5
  BasicHashTable::Iterator *result; // r0

  v2 = this;
  v3 = a2;
  HashTable::Iterator::Iterator((int)this);
  *((_DWORD *)v2 + 1) = v3;
  result = v2;
  *((_DWORD *)v2 + 2) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *(_DWORD *)v2 = off_F0320;
  return result;
}
// F0320: using guessed type _DWORD (__fastcall *[2])(BasicHashTable::Iterator *__hidden this);

//----- (0005D414) --------------------------------------------------------
BasicHashTable *__fastcall HashTable::create(HashTable *this, int a2)
{
  HashTable *v2; // r5
  BasicHashTable *v3; // r4

  v2 = this;
  v3 = (BasicHashTable *)operator new(0x30u);
  BasicHashTable::BasicHashTable(v3, (int)v2);
  return v3;
}

//----- (0005D444) --------------------------------------------------------
BasicHashTable::Iterator *__fastcall HashTable::Iterator::create(HashTable::Iterator *this, HashTable *a2)
{
  BasicHashTable *v2; // r5
  BasicHashTable::Iterator *v3; // r4

  v2 = this;
  v3 = (BasicHashTable::Iterator *)operator new(0x10u);
  BasicHashTable::Iterator::Iterator(v3, v2);
  return v3;
}

//----- (0005D474) --------------------------------------------------------
bool __fastcall BasicHashTable::keyMatches(BasicHashTable *this, const char *a2, const char *a3)
{
  int v3; // r4
  const char *v4; // r0
  int v5; // r3
  int v6; // r12
  int v7; // t1
  int v8; // t1

  v3 = *((_DWORD *)this + 11);
  if ( !v3 )
    return strcmp(a2, a3) == 0;
  if ( v3 == 1 )
    return (unsigned int)(a2 - a3) <= 0;
  if ( v3 <= 0 )
    return 1;
  if ( *(_DWORD *)a2 == *(_DWORD *)a3 )
  {
    v4 = a2;
    v5 = 0;
    while ( ++v5 != v3 )
    {
      v7 = *((_DWORD *)v4 + 1);
      v4 += 4;
      v6 = v7;
      v8 = *((_DWORD *)a3 + 1);
      a3 += 4;
      if ( v6 != v8 )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (0005D504) --------------------------------------------------------
unsigned int __fastcall BasicHashTable::assignKey(int a1, int a2, int a3)
{
  int v3; // r5
  unsigned int result; // r0
  int v5; // r7
  int v6; // r6
  unsigned int v7; // r0
  int v8; // r3
  int v9; // r12

  v3 = a1;
  result = *(_DWORD *)(a1 + 44);
  v5 = a2;
  v6 = a3;
  if ( result )
  {
    if ( result == 1 )
    {
      *(_DWORD *)(a2 + 4) = a3;
    }
    else if ( (signed int)result > 0 )
    {
      if ( result > 0x1FC00000 )
        v7 = -1;
      else
        v7 = 4 * result;
      result = (unsigned int)operator new[](v7);
      if ( *(_DWORD *)(v3 + 44) > 0 )
      {
        v8 = 0;
        v9 = 0;
        do
        {
          ++v9;
          *(_DWORD *)(result + v8) = *(_DWORD *)(v6 + v8);
          v8 += 4;
        }
        while ( *(_DWORD *)(v3 + 44) > v9 );
      }
      *(_DWORD *)(v5 + 4) = result;
    }
  }
  else
  {
    result = strDup(a3);
    *(_DWORD *)(v5 + 4) = result;
  }
  return result;
}

//----- (0005D58C) --------------------------------------------------------
_DWORD *__fastcall BasicHashTable::insertNewEntry(BasicHashTable *this, unsigned int a2, const char *a3)
{
  BasicHashTable *v3; // r5
  unsigned int v4; // r6
  const char *v5; // r7
  _DWORD *v6; // r0
  int v7; // r12
  _DWORD *v8; // r4
  int v9; // r3

  v3 = this;
  v4 = a2;
  v5 = a3;
  v6 = operator new(0xCu);
  v7 = *((_DWORD *)v3 + 1);
  v8 = v6;
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  v9 = *((_DWORD *)v3 + 7);
  *v6 = *(_DWORD *)(v7 + 4 * v4);
  *(_DWORD *)(v7 + 4 * v4) = v6;
  *((_DWORD *)v3 + 7) = v9 + 1;
  BasicHashTable::assignKey((int)v3, (int)v6, (int)v5);
  return v8;
}

//----- (0005D5EC) --------------------------------------------------------
void __fastcall BasicHashTable::deleteKey(int a1, int a2)
{
  int v2; // r4
  void *v3; // r0

  v2 = a2;
  if ( *(_DWORD *)(a1 + 44) != 1 )
  {
    v3 = *(void **)(a2 + 4);
    if ( v3 )
      operator delete[](v3);
  }
  *(_DWORD *)(v2 + 4) = 0;
}

//----- (0005D61C) --------------------------------------------------------
void __fastcall BasicHashTable::deleteEntry(int a1, int a2, _DWORD *a3)
{
  int v3; // r3
  _DWORD *v4; // r4
  _DWORD *v5; // r12
  _DWORD *v6; // r2

  v3 = *(_DWORD *)(a1 + 4);
  v4 = a3;
  v5 = *(_DWORD **)(v3 + 4 * a2);
  v6 = (_DWORD *)(v3 + 4 * a2);
  if ( v5 )
  {
    if ( v5 == v4 )
    {
LABEL_9:
      *v6 = *v4;
    }
    else
    {
      while ( *v5 )
      {
        if ( (_DWORD *)*v5 == v4 )
        {
          v6 = v5;
          goto LABEL_9;
        }
        v5 = (_DWORD *)*v5;
      }
    }
  }
  --*(_DWORD *)(a1 + 28);
  BasicHashTable::deleteKey(a1, (int)v4);
  operator delete(v4);
}

//----- (0005D694) --------------------------------------------------------
BasicHashTable *__fastcall BasicHashTable::~BasicHashTable(BasicHashTable *this)
{
  int v1; // r2
  BasicHashTable *v2; // r4
  _DWORD *v3; // r0
  unsigned int v4; // r5
  _DWORD *v5; // r2

  v1 = *((_DWORD *)this + 6);
  v2 = this;
  *(_DWORD *)this = off_F0338;
  v3 = (_DWORD *)*((_DWORD *)this + 1);
  if ( v1 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        v5 = (_DWORD *)v3[v4];
        if ( !v5 )
          break;
        BasicHashTable::deleteEntry((int)v2, v4, v5);
        v3 = (_DWORD *)*((_DWORD *)v2 + 1);
      }
      ++v4;
    }
    while ( *((_DWORD *)v2 + 6) > v4 );
  }
  if ( v3 != (_DWORD *)((char *)v2 + 8) && v3 )
    operator delete[](v3);
  HashTable::~HashTable((int)v2);
  return v2;
}
// F0338: using guessed type _DWORD (__fastcall *off_F0338[2])(BasicHashTable *this);

//----- (0005D72C) --------------------------------------------------------
BasicHashTable *__fastcall BasicHashTable::~BasicHashTable(BasicHashTable *this)
{
  BasicHashTable *v1; // r4

  v1 = this;
  BasicHashTable::~BasicHashTable(this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005D748) --------------------------------------------------------
unsigned int __fastcall BasicHashTable::hashIndexFromKey(BasicHashTable *this, const char *a2)
{
  int v2; // r2
  int v3; // r3
  int v4; // r12
  int v5; // t1
  unsigned int result; // r0
  unsigned int v7; // r2
  const char *v8; // r2
  int v9; // r3
  int v10; // t1

  v2 = *((_DWORD *)this + 11);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      result = *((_DWORD *)this + 10) & ((unsigned int)(1103515245 * (_DWORD)a2) >> *((_DWORD *)this + 9));
    }
    else
    {
      if ( v2 > 0 )
      {
        v8 = &a2[4 * v2];
        v9 = 0;
        do
        {
          v10 = *(_DWORD *)a2;
          a2 += 4;
          v9 += v10;
        }
        while ( a2 != v8 );
        v7 = 1103515245 * v9;
      }
      else
      {
        v7 = 0;
      }
      result = *((_DWORD *)this + 10) & (v7 >> *((_DWORD *)this + 9));
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)a2;
    if ( *a2 )
    {
      do
      {
        v4 = v3 + 8 * v2;
        v5 = *((unsigned __int8 *)a2++ + 1);
        v3 = v5;
        v2 += v4;
      }
      while ( v5 );
    }
    else
    {
      v2 = *(unsigned __int8 *)a2;
    }
    result = v2 & *((_DWORD *)this + 10);
  }
  return result;
}

//----- (0005D7EC) --------------------------------------------------------
int **__fastcall BasicHashTable::lookupKey(BasicHashTable *this, const char *a2, unsigned int *a3)
{
  unsigned int *v3; // r4
  BasicHashTable *v4; // r5
  const char *v5; // r6
  unsigned int v6; // r0
  int v7; // r3
  int **v8; // r4

  v3 = a3;
  v4 = this;
  v5 = a2;
  v6 = BasicHashTable::hashIndexFromKey(this, a2);
  v7 = *((_DWORD *)v4 + 1);
  *v3 = v6;
  v8 = *(int ***)(v7 + 4 * v6);
  if ( !v8 )
    return 0;
  while ( !BasicHashTable::keyMatches(v4, v5, (const char *)v8[1]) )
  {
    v8 = (int **)*v8;
    if ( !v8 )
      return 0;
  }
  return v8;
}

//----- (0005D850) --------------------------------------------------------
int **__fastcall BasicHashTable::Remove(BasicHashTable *this, const char *a2)
{
  BasicHashTable *v2; // r4
  int **result; // r0
  unsigned int v4; // [sp+4h] [bp-Ch]

  v2 = this;
  result = BasicHashTable::lookupKey(this, a2, &v4);
  if ( result )
  {
    BasicHashTable::deleteEntry((int)v2, v4, result);
    result = (int **)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0005D888) --------------------------------------------------------
int **__fastcall BasicHashTable::Lookup(BasicHashTable *this, const char *a2)
{
  int **result; // r0
  unsigned int v3; // [sp+4h] [bp-Ch]

  result = BasicHashTable::lookupKey(this, a2, &v3);
  if ( result )
    result = (int **)result[2];
  return result;
}

//----- (0005D8A8) --------------------------------------------------------
void __fastcall BasicHashTable::rebuild(BasicHashTable *this)
{
  int *v1; // r5
  BasicHashTable *v2; // r6
  int v3; // r7
  int *v4; // r8
  unsigned int v5; // r0
  _DWORD *v6; // r0
  int v7; // r3
  int v8; // r2
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int i; // r4
  int v13; // t1
  unsigned int v14; // r0
  int v15; // r3

  v2 = this;
  v3 = *((_DWORD *)this + 6);
  v4 = (int *)*((_DWORD *)this + 1);
  *((_DWORD *)this + 6) = 4 * v3;
  if ( (unsigned int)(4 * v3) > 0x1FC00000 )
    v5 = -1;
  else
    v5 = 16 * v3;
  v6 = operator new[](v5);
  v8 = *((_DWORD *)v2 + 6);
  if ( v8 )
    v7 = 0;
  *((_DWORD *)v2 + 1) = v6;
  if ( v8 )
  {
    v9 = v7;
    while ( 1 )
    {
      v6[v7++] = v9;
      if ( v7 == v8 )
        break;
      v6 = (_DWORD *)*((_DWORD *)v2 + 1);
    }
  }
  if ( v3 )
    v1 = v4;
  v10 = 4 * *((_DWORD *)v2 + 8);
  v11 = *((_DWORD *)v2 + 9) - 2;
  *((_DWORD *)v2 + 10) = 4 * *((_DWORD *)v2 + 10) | 3;
  *((_DWORD *)v2 + 8) = v10;
  for ( *((_DWORD *)v2 + 9) = v11; v3; --v3 )
  {
    v13 = *v1;
    ++v1;
    for ( i = v13; i; i = *(v1 - 1) )
    {
      *(v1 - 1) = *(_DWORD *)i;
      v14 = BasicHashTable::hashIndexFromKey(v2, *(const char **)(i + 4));
      v15 = *((_DWORD *)v2 + 1);
      *(_DWORD *)i = *(_DWORD *)(v15 + 4 * v14);
      *(_DWORD *)(v15 + 4 * v14) = i;
    }
  }
  if ( v4 != (int *)((char *)v2 + 8) )
  {
    if ( v4 )
      operator delete[](v4);
  }
}

//----- (0005D998) --------------------------------------------------------
int __fastcall BasicHashTable::Add(BasicHashTable *this, const char *a2, void *a3)
{
  void *v3; // r5
  BasicHashTable *v4; // r4
  const char *v5; // r6
  _DWORD *v6; // r0
  int v7; // r6
  unsigned int v8; // r1
  unsigned int v9; // r2
  const char *v11; // r2
  unsigned int v12; // [sp+4h] [bp-14h]

  v3 = a3;
  v4 = this;
  v5 = a2;
  v6 = BasicHashTable::lookupKey(this, a2, &v12);
  if ( v6 )
  {
    v7 = v6[2];
  }
  else
  {
    v11 = v5;
    v7 = 0;
    v6 = BasicHashTable::insertNewEntry(v4, v12, v11);
  }
  v8 = *((_DWORD *)v4 + 7);
  v9 = *((_DWORD *)v4 + 8);
  v6[2] = v3;
  if ( v8 >= v9 )
    BasicHashTable::rebuild(v4);
  return v7;
}

//----- (0005DA00) --------------------------------------------------------
int __fastcall strDup(int result)
{
  const void *v1; // r6
  size_t v2; // r0
  size_t v3; // r4
  int v4; // r5

  v1 = (const void *)result;
  if ( result )
  {
    v2 = strlen((const char *)result);
    v3 = v2 + 1;
    result = (int)operator new[](v2 + 1);
    v4 = result;
    if ( result )
    {
      memcpy((void *)result, v1, v3);
      result = v4;
    }
  }
  return result;
}

//----- (0005DA48) --------------------------------------------------------
int __fastcall strDupSize(int result)
{
  size_t v1; // r0

  if ( result )
  {
    v1 = strlen((const char *)result);
    result = (int)operator new[](v1 + 1);
  }
  return result;
}

//----- (0005DA64) --------------------------------------------------------
int __fastcall TaskScheduler::~TaskScheduler(int result)
{
  *(_DWORD *)result = off_F0358;
  return result;
}
// F0358: using guessed type _DWORD (__fastcall *[2])(TaskScheduler *__hidden this);

//----- (0005DA7C) --------------------------------------------------------
int __fastcall TaskScheduler::rescheduleDelayedTask(TaskScheduler *this, void **a2, __int64 a3, void (__cdecl *a4)(void *), void *a5)
{
  TaskScheduler *v5; // r6
  void **v6; // r9
  __int64 v7; // r4
  int result; // r0

  v5 = this;
  v6 = a2;
  v7 = a3;
  (*(void (**)(void))(*(_DWORD *)this + 12))();
  result = (*(int (__fastcall **)(TaskScheduler *, _DWORD, _DWORD, _DWORD, void (__cdecl *)(void *), void *))(*(_DWORD *)v5 + 8))(
             v5,
             *(_DWORD *)(*(_DWORD *)v5 + 8),
             v7,
             HIDWORD(v7),
             a4,
             a5);
  *v6 = (void *)result;
  return result;
}

//----- (0005DAD4) --------------------------------------------------------
TaskScheduler *__fastcall TaskScheduler::~TaskScheduler(TaskScheduler *this)
{
  TaskScheduler *v1; // r4

  v1 = this;
  TaskScheduler::~TaskScheduler((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005DAF0) --------------------------------------------------------
int __fastcall TaskScheduler::TaskScheduler(int result)
{
  *(_DWORD *)result = off_F0358;
  return result;
}
// F0358: using guessed type _DWORD (__fastcall *off_F0358[2])(TaskScheduler *__hidden this);

//----- (0005DB08) --------------------------------------------------------
int __fastcall HashTable::~HashTable(int result)
{
  *(_DWORD *)result = off_F03A8;
  return result;
}
// F03A8: using guessed type _DWORD (__fastcall *[2])(HashTable *__hidden this);

//----- (0005DB20) --------------------------------------------------------
int __fastcall HashTable::Iterator::~Iterator(int result)
{
  *(_DWORD *)result = off_F0390;
  return result;
}
// F0390: using guessed type _DWORD (__fastcall *[2])(HashTable::Iterator *__hidden this);

//----- (0005DB38) --------------------------------------------------------
HashTable *__fastcall HashTable::~HashTable(HashTable *this)
{
  HashTable *v1; // r4

  v1 = this;
  HashTable::~HashTable((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005DB54) --------------------------------------------------------
HashTable::Iterator *__fastcall HashTable::Iterator::~Iterator(HashTable::Iterator *this)
{
  HashTable::Iterator *v1; // r4

  v1 = this;
  HashTable::Iterator::~Iterator((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (0005DB70) --------------------------------------------------------
int __fastcall HashTable::HashTable(int result)
{
  *(_DWORD *)result = off_F03A8;
  return result;
}
// F03A8: using guessed type _DWORD (__fastcall *off_F03A8[2])(HashTable *__hidden this);

//----- (0005DB88) --------------------------------------------------------
int __fastcall HashTable::Iterator::Iterator(int result)
{
  *(_DWORD *)result = off_F0390;
  return result;
}
// F0390: using guessed type _DWORD (__fastcall *off_F0390[2])(HashTable::Iterator *__hidden this);

//----- (0005DBA0) --------------------------------------------------------
int __fastcall HashTable::RemoveNext(HashTable *this, HashTable *a2)
{
  HashTable *v2; // r5
  BasicHashTable::Iterator *v3; // r4
  int v4; // r6
  int v6; // [sp+4h] [bp-14h]

  v2 = this;
  v3 = HashTable::Iterator::create(this, a2);
  v4 = (*(int (**)(void))(*(_DWORD *)v3 + 8))();
  if ( v4 )
    (*(void (__fastcall **)(HashTable *, int))(*(_DWORD *)v2 + 12))(v2, v6);
  (*(void (__fastcall **)(BasicHashTable::Iterator *))(*(_DWORD *)v3 + 4))(v3);
  return v4;
}

//----- (0005DBFC) --------------------------------------------------------
int __fastcall CBuffer::CBuffer(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (0005DC14) --------------------------------------------------------
void __fastcall CBuffer::Reset(CBuffer *this)
{
  CBuffer *v1; // r4
  void *v2; // r0

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 3);
  *((_DWORD *)v1 + 3) = 0;
  if ( v2 )
    operator delete[](v2);
  *(_DWORD *)v1 = 0;
  *((_DWORD *)v1 + 1) = 0;
  *((_DWORD *)v1 + 2) = 0;
}

//----- (0005DC48) --------------------------------------------------------
signed int __fastcall CBuffer::InitWithAllocation(CBuffer *this, unsigned int a2)
{
  CBuffer *v2; // r4
  unsigned int v3; // r5
  _BYTE *v4; // r0
  void *v5; // r2
  _BYTE *v6; // r3
  signed int result; // r0

  v2 = this;
  v3 = a2;
  CBuffer::Reset(this);
  v4 = operator new[](v3 + 2);
  v5 = (void *)*((_DWORD *)v2 + 3);
  *((_DWORD *)v2 + 3) = v4;
  if ( v5 )
  {
    operator delete[](v5);
    v6 = (_BYTE *)*((_DWORD *)v2 + 3);
  }
  else
  {
    v6 = v4;
  }
  *(_DWORD *)v2 = v6;
  if ( v6 && (result = 0, v6[v3] = 0, *(_BYTE *)(*(_DWORD *)v2 + v3 + 1) = 0, *(_DWORD *)v2) )
  {
    *((_DWORD *)v2 + 1) = v3;
    *((_DWORD *)v2 + 2) = v3;
  }
  else
  {
    result = -2147467259;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}

//----- (0005DCD0) --------------------------------------------------------
CBuffer *__fastcall CBuffer::CBuffer(CBuffer *this, unsigned int a2)
{
  CBuffer *v2; // r4

  *((_DWORD *)this + 3) = 0;
  v2 = this;
  CBuffer::InitWithAllocation(this, a2);
  return v2;
}

//----- (0005DD00) --------------------------------------------------------
int __fastcall CBuffer::InitNoAlloc(CBuffer *this, unsigned __int8 *a2, unsigned int a3)
{
  CBuffer *v3; // r5
  unsigned int v4; // r4
  unsigned __int8 *v5; // r6
  int result; // r0

  v3 = this;
  v4 = a3;
  v5 = a2;
  CBuffer::Reset(this);
  *(_DWORD *)v3 = v5;
  result = 0;
  if ( !v5 )
    v4 = 0;
  *((_DWORD *)v3 + 1) = v4;
  *((_DWORD *)v3 + 2) = v4;
  return result;
}

//----- (0005DD30) --------------------------------------------------------
signed int __fastcall CBuffer::InitWithAllocAndCopy(CBuffer *this, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // r5
  unsigned int v4; // r6
  size_t *v5; // r4
  unsigned int v6; // r1
  signed int v7; // r6

  v3 = a2;
  v4 = a3;
  v5 = (size_t *)this;
  CBuffer::Reset(this);
  if ( v3 )
    v6 = v4;
  else
    v6 = 0;
  v7 = CBuffer::InitWithAllocation((CBuffer *)v5, v6);
  if ( v7 >= 0 )
    memcpy((void *)*v5, v3, v5[1]);
  return v7;
}

//----- (0005DD74) --------------------------------------------------------
CBuffer *__fastcall CBuffer::CBuffer(CBuffer *this, unsigned __int8 *a2, unsigned int a3, int a4)
{
  CBuffer *v4; // r4

  v4 = this;
  *((_DWORD *)this + 3) = 0;
  if ( a4 )
    CBuffer::InitWithAllocAndCopy(this, a2, a3);
  else
    CBuffer::InitNoAlloc(this, a2, a3);
  return v4;
}

//----- (0005DDB8) --------------------------------------------------------
bool __fastcall CBuffer::SetSize(CBuffer *this, unsigned int a2)
{
  unsigned int v2; // r3

  v2 = *((_DWORD *)this + 2);
  *((_DWORD *)this + 1) = a2;
  return v2 >= a2;
}

//----- (0005DDD0) --------------------------------------------------------
bool __fastcall CBuffer::IsValid(CBuffer *this)
{
  return *(_DWORD *)this != 0;
}

//----- (0005DDE0) --------------------------------------------------------
int __fastcall CSocketAddress::CSocketAddress(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_WORD *)result = 2;
  return result;
}

//----- (0005DE14) --------------------------------------------------------
int __fastcall CSocketAddress::CommonConstructor(CSocketAddress *this, const sockaddr *a2)
{
  int v2; // r2
  const sockaddr *v3; // r3
  CSocketAddress *v4; // r12
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  char *v9; // t0
  const sockaddr *v10; // r4
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  _DWORD *v15; // r12
  int v16; // r1
  int v17; // r2

  v2 = a2->sa_family;
  v3 = a2;
  v4 = this;
  if ( v2 == 10 )
  {
    v10 = a2;
    v11 = *(_DWORD *)&a2->sa_family;
    v12 = *(_DWORD *)&a2->sa_data[2];
    v13 = *(_DWORD *)&v10->sa_data[6];
    v14 = *(_DWORD *)&v10->sa_data[10];
    ++v10;
    *(_DWORD *)v4 = v11;
    *((_DWORD *)v4 + 1) = v12;
    *((_DWORD *)v4 + 2) = v13;
    *((_DWORD *)v4 + 3) = v14;
    v15 = (_DWORD *)((char *)v4 + 16);
    result = *(_DWORD *)&v10->sa_family;
    v16 = *(_DWORD *)&v10->sa_data[2];
    v17 = *(_DWORD *)&v10->sa_data[6];
    *v15 = *(_DWORD *)&v10->sa_family;
    v15[1] = v16;
    v15[2] = v17;
  }
  else
  {
    if ( v2 == 2 )
    {
      result = *(_DWORD *)&a2->sa_family;
      v9 = &a2->sa_data[2];
      v6 = *(_DWORD *)&a2->sa_data[2];
      v9 += 4;
      v7 = *(_DWORD *)v9;
      v8 = *((_DWORD *)v9 + 1);
    }
    else
    {
      result = *(_DWORD *)&a2->sa_family;
      v6 = *(_DWORD *)&a2->sa_data[2];
      v7 = *(_DWORD *)&v3->sa_data[6];
      v8 = *(_DWORD *)&v3->sa_data[10];
    }
    *(_DWORD *)v4 = result;
    *((_DWORD *)v4 + 1) = v6;
    *((_DWORD *)v4 + 2) = v7;
    *((_DWORD *)v4 + 3) = v8;
  }
  return result;
}

//----- (0005DE70) --------------------------------------------------------
CSocketAddress *__fastcall CSocketAddress::CSocketAddress(CSocketAddress *this, const sockaddr *a2)
{
  CSocketAddress *v2; // r4

  v2 = this;
  CSocketAddress::CommonConstructor(this, a2);
  return v2;
}

//----- (0005DE84) --------------------------------------------------------
CSocketAddress *__fastcall CSocketAddress::CSocketAddress(CSocketAddress *this, const __kernel_sockaddr_storage *a2)
{
  CSocketAddress *v2; // r4

  v2 = this;
  CSocketAddress::CommonConstructor(this, (const sockaddr *)a2);
  return v2;
}

//----- (0005DE98) --------------------------------------------------------
CSocketAddress *__fastcall CSocketAddress::CSocketAddress(CSocketAddress *this, const sockaddr_in6 *a2)
{
  const sockaddr_in6 *v2; // r4
  CSocketAddress *v3; // r5
  int v4; // r0
  uint32_t v5; // r1
  uint32_t v6; // r2
  uint32_t v7; // r3
  _DWORD *v8; // r12
  uint32_t v9; // r1
  uint32_t v10; // r2

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)&a2->sin6_family;
  v5 = a2->sin6_flowinfo;
  v6 = v2->sin6_addr.in6_u.u6_addr32[0];
  v7 = v2->sin6_addr.in6_u.u6_addr32[1];
  v2 = (const sockaddr_in6 *)((char *)v2 + 16);
  *(_DWORD *)v3 = v4;
  *((_DWORD *)v3 + 1) = v5;
  *((_DWORD *)v3 + 2) = v6;
  *((_DWORD *)v3 + 3) = v7;
  v8 = (_DWORD *)((char *)v3 + 16);
  v9 = v2->sin6_flowinfo;
  v10 = v2->sin6_addr.in6_u.u6_addr32[0];
  *v8 = *(_DWORD *)&v2->sin6_family;
  v8[1] = v9;
  v8[2] = v10;
  return v3;
}

//----- (0005DEC4) --------------------------------------------------------
CSocketAddress *__fastcall CSocketAddress::CSocketAddress(CSocketAddress *this, const sockaddr_in *a2)
{
  CSocketAddress *v2; // r12
  int v3; // r0
  in_addr *v4; // t0
  in_addr_t v5; // r1
  in_addr_t v6; // r2
  in_addr_t v7; // r3

  v2 = this;
  v3 = *(_DWORD *)&a2->sin_family;
  v4 = &a2->sin_addr;
  v5 = a2->sin_addr.s_addr;
  ++v4;
  v6 = v4->s_addr;
  v7 = v4[1].s_addr;
  *(_DWORD *)v2 = v3;
  *((_DWORD *)v2 + 1) = v5;
  *((_DWORD *)v2 + 2) = v6;
  *((_DWORD *)v2 + 3) = v7;
  return v2;
}

//----- (0005DED8) --------------------------------------------------------
int __fastcall CSocketAddress::CSocketAddress(int result, unsigned int a2, int a3)
{
  int v3; // ST04_4

  LOWORD(v3) = 2;
  HIWORD(v3) = __rev16(a3);
  *(_DWORD *)result = v3;
  *(_DWORD *)(result + 4) = bswap32(a2);
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

//----- (0005DF48) --------------------------------------------------------
int __fastcall CSocketAddress::SetPort(int result, int a2)
{
  *(_WORD *)(result + 2) = __rev16(a2);
  return result;
}

//----- (0005DF54) --------------------------------------------------------
int __fastcall CSocketAddress::GetPort_NBO(CSocketAddress *this)
{
  return *((unsigned __int16 *)this + 1);
}

//----- (0005DF5C) --------------------------------------------------------
int __fastcall CSocketAddress::GetPort(CSocketAddress *this)
{
  return (unsigned __int16)__rev16(CSocketAddress::GetPort_NBO(this));
}

//----- (0005DF70) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetIPLength(CSocketAddress *this)
{
  signed int result; // r0

  if ( *(_WORD *)this == 2 )
    result = 4;
  else
    result = 16;
  return result;
}

//----- (0005DF84) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetIPImpl(CSocketAddress *this, void *a2, unsigned int a3, int a4)
{
  _DWORD *v4; // r5
  int v5; // r7
  CSocketAddress *v6; // r6
  signed int result; // r0
  _DWORD *v8; // r6
  int v9; // t1
  int v10; // r1
  int v11; // r2
  unsigned int v12; // r3

  v4 = a2;
  v5 = a4;
  v6 = this;
  if ( !a2 || !a3 || a3 < CSocketAddress::GetIPLength(this) )
    return 0;
  if ( *(_WORD *)v6 == 2 )
  {
    v12 = *((_DWORD *)v6 + 1);
    if ( !v5 )
      v12 = bswap32(v12);
    *v4 = v12;
    result = 4;
  }
  else
  {
    v9 = *((_DWORD *)v6 + 2);
    v8 = (_DWORD *)((char *)v6 + 8);
    v10 = v8[2];
    v11 = v8[3];
    v4[1] = v8[1];
    result = 16;
    *v4 = v9;
    v4[2] = v10;
    v4[3] = v11;
  }
  return result;
}

//----- (0005E02C) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetIP(CSocketAddress *this, void *a2, unsigned int a3)
{
  return CSocketAddress::GetIPImpl(this, a2, a3, 0);
}

//----- (0005E034) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetIP_NBO(CSocketAddress *this, void *a2, unsigned int a3)
{
  return CSocketAddress::GetIPImpl(this, a2, a3, 1);
}

//----- (0005E03C) --------------------------------------------------------
int __fastcall CSocketAddress::GetFamily(CSocketAddress *this)
{
  return *(unsigned __int16 *)this;
}

//----- (0005E044) --------------------------------------------------------
int __fastcall CSocketAddress::ApplyStunXorMap(_WORD *a1, _BYTE *a2)
{
  _BYTE *v2; // r2
  int result; // r0
  unsigned int v4; // r4
  unsigned int v5; // r3
  char v6; // r5

  if ( *a1 == 2 )
  {
    v2 = a1 + 1;
    v4 = 4;
    result = (int)(a1 + 2);
  }
  else
  {
    v2 = a1 + 1;
    result = (int)(a1 + 4);
    v4 = 16;
  }
  v5 = 0;
  v6 = v2[1];
  *v2 ^= *a2;
  v2[1] = v6 ^ a2[1];
  do
  {
    *(_BYTE *)(result + v5) ^= a2[v5];
    ++v5;
  }
  while ( v5 < v4 );
  return result;
}

//----- (0005E0BC) --------------------------------------------------------
CSocketAddress *__fastcall CSocketAddress::GetSockAddr4(CSocketAddress *this, int *a2)
{
  CSocketAddress *v2; // r12
  int v3; // r0
  int *v4; // t0
  int v5; // r1
  int v6; // r2
  int v7; // r3

  v2 = this;
  v3 = *a2;
  v4 = a2 + 1;
  v5 = a2[1];
  ++v4;
  v6 = *v4;
  v7 = v4[1];
  *(_DWORD *)v2 = v3;
  *((_DWORD *)v2 + 1) = v5;
  *((_DWORD *)v2 + 2) = v6;
  *((_DWORD *)v2 + 3) = v7;
  return v2;
}

//----- (0005E0D0) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetSockAddrLength(CSocketAddress *this)
{
  signed int result; // r0

  if ( *(_WORD *)this == 2 )
    result = 16;
  else
    result = 28;
  return result;
}

//----- (0005E0E4) --------------------------------------------------------
bool __fastcall CSocketAddress::IsSameIP(CSocketAddress *this, const CSocketAddress *a2)
{
  int v2; // r3
  char *v4; // r0
  char *v5; // r1
  size_t v6; // r2

  v2 = *(unsigned __int16 *)a2;
  if ( v2 != *(unsigned __int16 *)this )
    return 0;
  if ( v2 == 2 )
    return memcmp((char *)this + 4, (char *)a2 + 4, 4u) == 0;
  if ( v2 == 10 )
  {
    v4 = (char *)this + 8;
    v5 = (char *)a2 + 8;
    v6 = 16;
  }
  else
  {
    v4 = (char *)this + 2;
    v5 = (char *)a2 + 2;
    v6 = 14;
  }
  return memcmp(v4, v5, v6) == 0;
}

//----- (0005E150) --------------------------------------------------------
bool __fastcall CSocketAddress::IsSameIP_and_Port(CSocketAddress *this, const CSocketAddress *a2)
{
  CSocketAddress *v2; // r5
  CSocketAddress *v3; // r4
  _BOOL4 result; // r0
  int v5; // r5

  v2 = this;
  v3 = a2;
  result = CSocketAddress::IsSameIP(this, a2);
  if ( result )
  {
    v5 = CSocketAddress::GetPort(v2);
    result = (unsigned int)(v5 - CSocketAddress::GetPort(v3)) <= 0;
  }
  return result;
}

//----- (0005E18C) --------------------------------------------------------
bool __fastcall CSocketAddress::IsIPAddressZero(CSocketAddress *this)
{
  int v1; // r3

  v1 = *(unsigned __int16 *)this;
  if ( v1 == 2 )
    return memcmp((char *)this + 4, &unk_EBA14, 4u) == 0;
  if ( v1 == 10 )
    return memcmp((char *)this + 8, &unk_EBA14, 0x10u) == 0;
  return memcmp((char *)this + 2, &unk_EBA14, 0xEu) == 0;
}

//----- (0005E210) --------------------------------------------------------
unsigned int __fastcall CSocketAddress::ToStringBuffer(CSocketAddress *this, char *a2, unsigned int a3)
{
  char *v3; // r4
  unsigned int v4; // r5
  CSocketAddress *v5; // r6
  int v6; // r0
  const void *v7; // r1
  int v8; // r1
  int v9; // r2
  int v10; // r0
  int v12; // [sp+0h] [bp-18h]

  v3 = a2;
  v4 = a3;
  v5 = this;
  v6 = CSocketAddress::GetFamily(this);
  if ( !v3 || !v4 )
    return -2147024809;
  *v3 = 0;
  if ( v6 == 2 )
  {
    v7 = (char *)v5 + 4;
    if ( v4 > 0x15 )
      goto LABEL_6;
    return -2147024809;
  }
  if ( v6 != 10 )
    return -2147467259;
  v7 = (char *)v5 + 8;
  if ( v4 <= 0x33 )
    return -2147024809;
LABEL_6:
  if ( !inet_ntop(v6, v7, v3, v4) )
    return *(_DWORD *)_errno(0, v8, v9) | 0x88000000;
  v10 = CSocketAddress::GetPort(v5);
  sprintf((char *)&v12, ":%d", v10);
  strcat(v3, (const char *)&v12);
  return 0;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0005E2DC) --------------------------------------------------------
int *__fastcall CSocketAddress::ToString(CSocketAddress *a1, int *a2)
{
  int *v2; // r6
  size_t v3; // r0
  int v5; // [sp+0h] [bp-48h]

  v2 = a2;
  CSocketAddress::ToStringBuffer(a1, (char *)&v5, 0x34u);
  v3 = strlen((const char *)&v5);
  return sub_C0F20(v2, &v5, v3);
}

//----- (0005E33C) --------------------------------------------------------
signed int __fastcall CSocketAddress::GetLocalHost(CSocketAddress *this, int a2, CSocketAddress *a3)
{
  _DWORD *v3; // r7
  int v4; // r5
  int v5; // r1
  int v6; // r2
  int v7; // r3
  _DWORD *v8; // r12
  int v9; // r1
  int v10; // r2
  int v12; // r1
  int v13; // r2
  int v14; // r3
  _DWORD *v15; // r7
  int v16; // r1
  int v17; // r2
  __int64 v18; // [sp+10h] [bp-58h]
  int v19; // [sp+18h] [bp-50h]
  __int64 v20; // [sp+1Ch] [bp-4Ch]
  __int64 v21; // [sp+24h] [bp-44h]
  int v22; // [sp+2Ch] [bp-3Ch]
  char v23; // [sp+30h] [bp-38h]
  int v24; // [sp+34h] [bp-34h]
  int v25; // [sp+38h] [bp-30h]
  int v26; // [sp+3Ch] [bp-2Ch]
  int v27; // [sp+40h] [bp-28h]
  int v28; // [sp+44h] [bp-24h]
  int v29; // [sp+48h] [bp-20h]

  v3 = (_DWORD *)a2;
  if ( ((unsigned __int16)this & 0xFFF7) != 2 || !a2 )
    return -2147467259;
  if ( this == (CSocketAddress *)((char *)&dword_0 + 2) )
  {
    v4 = 0;
    CSocketAddress::CSocketAddress((int)&v23, 0x7F000001u, 0);
    v12 = v24;
    v13 = v25;
    v14 = v26;
    *v3 = *(_DWORD *)&v23;
    v3[1] = v12;
    v3[2] = v13;
    v3[3] = v14;
    v15 = v3 + 4;
    v16 = v28;
    v17 = v29;
    *v15 = v27;
    v15[1] = v16;
    v15[2] = v17;
  }
  else
  {
    v4 = 0;
    v18 = 0LL;
    BYTE3(v18) = 1;
    v19 = 0;
    v22 = 0;
    v20 = 0LL;
    v21 = __PAIR__(v18, 0);
    WORD2(v18) = 10;
    CSocketAddress::CSocketAddress((CSocketAddress *)&v23, (const sockaddr_in6 *)((char *)&v18 + 4));
    v5 = v24;
    v6 = v25;
    v7 = v26;
    *v3 = *(_DWORD *)&v23;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v8 = v3 + 4;
    v9 = v28;
    v10 = v29;
    *v8 = v27;
    v8[1] = v9;
    v8[2] = v10;
  }
  return v4;
}
// 0: using guessed type int dword_0;

//----- (0005E440) --------------------------------------------------------
int __fastcall StunClientResults::Init(StunClientResults *this)
{
  StunClientResults *v1; // r4
  _DWORD *v2; // r7
  _DWORD *v3; // r5
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  _DWORD *v10; // r8
  _DWORD *v11; // r7
  int v12; // r1
  int v13; // r2
  int v14; // r3
  _DWORD *v15; // r5
  int v16; // r1
  int v17; // r2
  _DWORD *v18; // r11
  _DWORD *v19; // r5
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r6
  int v24; // r1
  int v25; // r2
  _DWORD *v26; // ST08_4
  int v27; // r1
  int v28; // r2
  int v29; // r3
  _DWORD *v30; // r8
  int v31; // r1
  int v32; // r2
  int v33; // r1
  int v34; // r2
  int v35; // r3
  _DWORD *v36; // r7
  int v37; // r1
  int v38; // r2
  int v39; // r1
  int v40; // r2
  int v41; // r3
  _DWORD *v42; // r6
  int v43; // r1
  int v44; // r2
  int v45; // r1
  int v46; // r2
  int v47; // r3
  _DWORD *v48; // r5
  int result; // r0
  int v50; // r1
  int v51; // r2
  char v52; // [sp+18h] [bp-48h]
  int v53; // [sp+1Ch] [bp-44h]
  int v54; // [sp+20h] [bp-40h]
  int v55; // [sp+24h] [bp-3Ch]
  int v56; // [sp+28h] [bp-38h]
  int v57; // [sp+2Ch] [bp-34h]
  int v58; // [sp+30h] [bp-30h]

  v1 = this;
  v2 = (_DWORD *)((char *)this + 4);
  v3 = (_DWORD *)((char *)this + 32);
  CSocketAddress::CSocketAddress((int)&v52);
  *(_BYTE *)v1 = 0;
  v4 = *(_DWORD *)&v52;
  v5 = v53;
  v6 = v54;
  v7 = v55;
  *((_BYTE *)v1 + 1) = 0;
  *((_BYTE *)v1 + 60) = 0;
  *((_BYTE *)v1 + 148) = 0;
  *((_DWORD *)v1 + 38) = 0;
  *v2 = v4;
  v2[1] = v5;
  v2[2] = v6;
  v2[3] = v7;
  v2 += 4;
  v8 = v57;
  v9 = v58;
  v10 = (_DWORD *)((char *)v1 + 92);
  *v2 = v56;
  v2[1] = v8;
  v2[2] = v9;
  v11 = (_DWORD *)((char *)v1 + 120);
  v12 = v53;
  v13 = v54;
  v14 = v55;
  *v3 = *(_DWORD *)&v52;
  *((_DWORD *)v1 + 9) = v12;
  *((_DWORD *)v1 + 10) = v13;
  *((_DWORD *)v1 + 11) = v14;
  v15 = (_DWORD *)((char *)v1 + 48);
  v16 = v57;
  v17 = v58;
  v18 = (_DWORD *)((char *)v1 + 64);
  *v15 = v56;
  v15[1] = v16;
  v15[2] = v17;
  v19 = (_DWORD *)((char *)v1 + 184);
  v20 = v53;
  v21 = v54;
  v22 = v55;
  v23 = (_DWORD *)((char *)v1 + 156);
  *v18 = *(_DWORD *)&v52;
  v18[1] = v20;
  v18[2] = v21;
  v18[3] = v22;
  v24 = v57;
  v25 = v58;
  v26 = (_DWORD *)((char *)v1 + 80);
  *v26 = v56;
  v26[1] = v24;
  v26[2] = v25;
  v27 = v53;
  v28 = v54;
  v29 = v55;
  *v10 = *(_DWORD *)&v52;
  v10[1] = v27;
  v10[2] = v28;
  v10[3] = v29;
  v30 = (_DWORD *)((char *)v1 + 108);
  v31 = v57;
  v32 = v58;
  *v30 = v56;
  v30[1] = v31;
  v30[2] = v32;
  v33 = v53;
  v34 = v54;
  v35 = v55;
  *v11 = *(_DWORD *)&v52;
  v11[1] = v33;
  v11[2] = v34;
  v11[3] = v35;
  v36 = (_DWORD *)((char *)v1 + 136);
  v37 = v57;
  v38 = v58;
  *v36 = v56;
  v36[1] = v37;
  v36[2] = v38;
  v39 = v53;
  v40 = v54;
  v41 = v55;
  *v23 = *(_DWORD *)&v52;
  v23[1] = v39;
  v23[2] = v40;
  v23[3] = v41;
  v42 = (_DWORD *)((char *)v1 + 172);
  v43 = v57;
  v44 = v58;
  *v42 = v56;
  v42[1] = v43;
  v42[2] = v44;
  v45 = v53;
  v46 = v54;
  v47 = v55;
  *v19 = *(_DWORD *)&v52;
  v19[1] = v45;
  v19[2] = v46;
  v19[3] = v47;
  v48 = (_DWORD *)((char *)v1 + 200);
  result = v56;
  v50 = v57;
  v51 = v58;
  *v48 = v56;
  v48[1] = v50;
  v48[2] = v51;
  *((_DWORD *)v1 + 53) = 0;
  return result;
}

//----- (0005E568) --------------------------------------------------------
StunClientResults *__fastcall StunClientResults::StunClientResults(StunClientResults *this)
{
  StunClientResults *v1; // r4

  v1 = this;
  CSocketAddress::CSocketAddress((int)this + 4);
  CSocketAddress::CSocketAddress((int)v1 + 32);
  CSocketAddress::CSocketAddress((int)v1 + 64);
  CSocketAddress::CSocketAddress((int)v1 + 92);
  CSocketAddress::CSocketAddress((int)v1 + 120);
  CSocketAddress::CSocketAddress((int)v1 + 156);
  CSocketAddress::CSocketAddress((int)v1 + 184);
  StunClientResults::Init(v1);
  return v1;
}

//----- (0005E5B8) --------------------------------------------------------
CStunClientLogic *__fastcall CStunClientLogic::CStunClientLogic(CStunClientLogic *this)
{
  CStunClientLogic *v1; // r4
  CStunClientLogic *result; // r0

  v1 = this;
  CSocketAddress::CSocketAddress((int)this);
  StunClientResults::StunClientResults((CStunClientLogic *)((char *)v1 + 44));
  *((_BYTE *)v1 + 260) = 0;
  *((_DWORD *)v1 + 66) = 0;
  *((_DWORD *)v1 + 67) = 0;
  CStunClientTestBase::CStunClientTestBase((CStunClientLogic *)((char *)v1 + 276));
  *((_DWORD *)v1 + 69) = &off_F0418;
  CBehaviorTest::CBehaviorTest((CStunClientLogic *)((char *)v1 + 312));
  CBehaviorTest::CBehaviorTest((CStunClientLogic *)((char *)v1 + 348));
  *((_DWORD *)v1 + 96) = 0;
  *((_DWORD *)v1 + 97) = 0;
  result = v1;
  *((_DWORD *)v1 + 98) = 0;
  *((_DWORD *)v1 + 99) = 0;
  return result;
}
// F0418: using guessed type int (*)();

//----- (0005E620) --------------------------------------------------------
int __fastcall CStunClientLogic::GetNextMessage(int a1, int a2, int a3, int a4)
{
  int v4; // r8
  int v5; // r4
  int v6; // r9
  int v7; // r7
  unsigned int i; // r3
  int v9; // r3
  int v10; // r2
  int *v11; // r5
  unsigned int v12; // r2
  unsigned int v13; // r3
  bool v14; // cf
  bool v15; // zf
  int v16; // r3
  int result; // r0

  v4 = a2;
  v5 = a1;
  v6 = a3;
  v7 = a4;
  if ( !*(_BYTE *)(a1 + 260) )
    return -2147467259;
  if ( *(_DWORD *)(*(_DWORD *)a2 + 8) < 0x320u || !a3 )
    return -2147024809;
  for ( i = *(_DWORD *)(a1 + 396); ; i = *(_DWORD *)(v5 + 396) )
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(v5 + 384);
      if ( i >= (*(_DWORD *)(v5 + 388) - v10) >> 2 )
        return -2130640894;
      v11 = *(int **)(v10 + 4 * i);
      if ( !*(_BYTE *)(v5 + 272) )
      {
        (*(void (__fastcall **)(_DWORD))(*v11 + 4))(*(_DWORD *)(v10 + 4 * i));
        *(_BYTE *)(v5 + 272) = 1;
      }
      if ( !(*(int (__fastcall **)(int *))(*v11 + 24))(v11) && (*(int (__fastcall **)(int *))(*v11 + 8))(v11) )
        break;
      v9 = *(_DWORD *)(v5 + 396);
      *(_DWORD *)(v5 + 268) = 0;
      i = v9 + 1;
      *(_BYTE *)(v5 + 272) = 0;
      *(_DWORD *)(v5 + 396) = i;
    }
    v12 = *(_DWORD *)(v5 + 268);
    if ( *(_DWORD *)(v5 + 32) > (v7 - *(_DWORD *)(v5 + 264)) / 0x3E8u && v12 )
      return -2130640895;
    v13 = *(_DWORD *)(v5 + 36);
    v14 = v13 >= v12;
    v15 = v13 == v12;
    v16 = *v11;
    if ( !v15 && v14 )
      break;
    (*(void (__fastcall **)(int *, int))(v16 + 20))(v11, 274877907 * (v7 - *(_DWORD *)(v5 + 264)));
  }
  result = (*(int (__fastcall **)(int *, int, int))(v16 + 12))(v11, v4, v6);
  if ( result >= 0 )
  {
    *(_DWORD *)(v5 + 264) = v7;
    result = 0;
    ++*(_DWORD *)(v5 + 268);
  }
  return result;
}

//----- (0005E798) --------------------------------------------------------
int __fastcall CStunClientLogic::ProcessResponse(int a1, int a2, int a3, int a4)
{
  int v4; // r5
  int v5; // r7
  int v6; // r6
  int v7; // r1
  int v8; // r3
  unsigned int v9; // r0
  int v10; // r4
  int result; // r0

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( !*(_BYTE *)(a1 + 260) )
    return -2147467259;
  if ( !*(_DWORD *)(*(_DWORD *)a2 + 4) )
    return -2147024809;
  v7 = *(_DWORD *)(a1 + 384);
  v8 = *(_DWORD *)(a1 + 388);
  v9 = *(_DWORD *)(a1 + 396);
  if ( v9 >= (v8 - v7) >> 2 || (v10 = *(_DWORD *)(v7 + 4 * v9), (*(int (**)(void))(*(_DWORD *)v10 + 24))()) )
    result = -2147418113;
  else
    result = (*(int (__fastcall **)(int, int, int, int))(*(_DWORD *)v10 + 16))(v10, v4, v5, v6);
  return result;
}

//----- (0005E83C) --------------------------------------------------------
signed int __fastcall CStunClientLogic::GetResults(int a1, void *a2)
{
  if ( !a2 )
    return -2147024809;
  memcpy(a2, (const void *)(a1 + 44), 0xD8u);
  return 0;
}

//----- (0005E870) --------------------------------------------------------
void __fastcall std::vector<IStunClientTest *,std::allocator<IStunClientTest *>>::_M_insert_aux(const void **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r5
  char *v4; // r3
  const void **v5; // r4
  int v6; // r4
  int v7; // r1
  _BYTE *v8; // r1
  unsigned int v9; // r3
  _DWORD *v10; // r6
  int v11; // r1
  int v12; // r7
  unsigned int v13; // r8
  _DWORD *v14; // ST04_4
  _DWORD *v15; // r0
  int v16; // r7
  char *v17; // r12
  int v18; // r7
  int v19; // r7

  v3 = a2;
  v4 = (char *)a1[1];
  v5 = a1;
  if ( v4 != a1[2] )
  {
    if ( v4 )
    {
      *(_DWORD *)v4 = *((_DWORD *)v4 - 1);
      v4 = (char *)a1[1];
    }
    a1[1] = v4 + 4;
    v6 = *a3;
    v7 = (v4 - 4 - (char *)a2) >> 2;
    if ( v7 )
      memmove(&v4[-4 * v7], v3, 4 * v7);
    *v3 = v6;
    return;
  }
  v8 = *a1;
  v9 = (v4 - (_BYTE *)*a1) >> 2;
  if ( v9 )
  {
    v10 = (_DWORD *)(2 * v9);
    v11 = (char *)v3 - v8;
    if ( v9 > 2 * v9 || (unsigned int)v10 > 0x3FFFFFFF )
    {
      v12 = v11 >> 2;
      v13 = -1;
    }
    else
    {
      v13 = 2 * v9;
      v12 = v11 >> 2;
      if ( !v10 )
        goto LABEL_12;
    }
  }
  else
  {
    v13 = 1;
    v12 = ((char *)v3 - v8) >> 2;
  }
  v14 = a3;
  v15 = operator new(v13 * 4);
  a3 = v14;
  v10 = v15;
LABEL_12:
  if ( &v10[v12] )
    v10[v12] = *a3;
  v16 = ((char *)v3 - (_BYTE *)*v5) >> 2;
  if ( v16 )
  {
    v16 *= 4;
    memmove(v10, *v5, v16);
  }
  v17 = (char *)v10 + v16 + 4;
  v18 = ((_BYTE *)v5[1] - (_BYTE *)v3) >> 2;
  if ( v18 )
  {
    v18 *= 4;
    v17 = (char *)memmove(v17, v3, v18);
  }
  v19 = (int)&v17[v18];
  if ( *v5 )
    operator delete((void *)*v5);
  *v5 = v10;
  v5[1] = (const void *)v19;
  v5[2] = &v10[v13];
}

//----- (0005E9C0) --------------------------------------------------------
signed int __fastcall CStunClientLogic::Initialize(int a1, CSocketAddress *a2)
{
  int v2; // r4
  CSocketAddress *v3; // r5
  int v4; // r2
  CSocketAddress *v5; // r1
  int v6; // r3
  int v7; // r5
  int v8; // lr
  int v9; // r12
  int v10; // r0
  int v11; // r0
  int v12; // r3
  int v13; // r3
  _DWORD *v14; // r1
  _DWORD *v15; // r3
  signed int result; // r0
  _DWORD *v17; // r1
  _DWORD *v18; // r3
  _DWORD *v19; // r1
  _DWORD *v20; // r3
  int v21; // [sp+4h] [bp-1Ch]

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)(a1 + 260) )
    return -2147418113;
  if ( CSocketAddress::IsIPAddressZero(a2) || !CSocketAddress::GetPort(v3) )
    return -2147024809;
  v4 = (int)v3 + 32;
  v5 = v3;
  v6 = v2;
  do
  {
    v7 = *(_DWORD *)v5;
    v5 = (CSocketAddress *)((char *)v5 + 16);
    v8 = *((_DWORD *)v5 - 3);
    v6 += 16;
    v9 = *((_DWORD *)v5 - 2);
    v10 = *((_DWORD *)v5 - 1);
    *(_DWORD *)(v6 - 16) = v7;
    *(_DWORD *)(v6 - 12) = v8;
    *(_DWORD *)(v6 - 8) = v9;
    *(_DWORD *)(v6 - 4) = v10;
  }
  while ( v5 != (CSocketAddress *)v4 );
  v11 = *((_DWORD *)v5 + 1);
  *(_DWORD *)v6 = *(_DWORD *)v5;
  *(_DWORD *)(v6 + 4) = v11;
  *(_BYTE *)(v6 + 8) = *((_BYTE *)v5 + 8);
  v12 = *(unsigned __int8 *)(v2 + 28);
  *(_BYTE *)(v2 + 260) = 1;
  if ( v12 )
  {
    *(_DWORD *)(v2 + 32) = 0;
  }
  else if ( !*(_DWORD *)(v2 + 32) )
  {
    *(_DWORD *)(v2 + 32) = 1;
  }
  v13 = *(_DWORD *)(v2 + 36);
  *(_DWORD *)(v2 + 396) = 0;
  if ( !v13 )
    *(_DWORD *)(v2 + 36) = 6;
  *(_DWORD *)(v2 + 388) = *(_DWORD *)(v2 + 384);
  CStunClientTestBase::Init(v2 + 276, v2, v2 + 44);
  v14 = *(_DWORD **)(v2 + 388);
  v15 = *(_DWORD **)(v2 + 392);
  v21 = v2 + 276;
  if ( v14 == v15 )
  {
    std::vector<IStunClientTest *,std::allocator<IStunClientTest *>>::_M_insert_aux(
      (const void **)(v2 + 384),
      v14,
      &v21);
  }
  else
  {
    if ( v14 )
    {
      *v14 = v2 + 276;
      v14 = *(_DWORD **)(v2 + 388);
    }
    *(_DWORD *)(v2 + 388) = v14 + 1;
  }
  if ( *(_BYTE *)(v2 + 40) )
  {
    CStunClientTestBase::Init(v2 + 312, v2, v2 + 44);
    v17 = *(_DWORD **)(v2 + 388);
    v18 = *(_DWORD **)(v2 + 392);
    v21 = v2 + 312;
    if ( v17 == v18 )
    {
      std::vector<IStunClientTest *,std::allocator<IStunClientTest *>>::_M_insert_aux(
        (const void **)(v2 + 384),
        v17,
        &v21);
    }
    else
    {
      if ( v17 )
      {
        *v17 = v2 + 312;
        v17 = *(_DWORD **)(v2 + 388);
      }
      *(_DWORD *)(v2 + 388) = v17 + 1;
    }
    CStunClientTestBase::Init(v2 + 348, v2, v2 + 44);
    CBehaviorTest::RunAsTest3(v2 + 348, 1);
    v19 = *(_DWORD **)(v2 + 388);
    v20 = *(_DWORD **)(v2 + 392);
    v21 = v2 + 348;
    if ( v19 == v20 )
    {
      std::vector<IStunClientTest *,std::allocator<IStunClientTest *>>::_M_insert_aux(
        (const void **)(v2 + 384),
        v19,
        &v21);
    }
    else
    {
      if ( v19 )
      {
        *v19 = v2 + 348;
        v19 = *(_DWORD **)(v2 + 388);
      }
      *(_DWORD *)(v2 + 388) = v19 + 1;
    }
  }
  result = 0;
  *(_BYTE *)(v2 + 272) = 0;
  *(_DWORD *)(v2 + 264) = 0;
  return result;
}

//----- (0005EBD4) --------------------------------------------------------
int __fastcall CStunClientTestBase::IsCompleted(CStunClientTestBase *this)
{
  return *((unsigned __int8 *)this + 16);
}

//----- (0005EBE0) --------------------------------------------------------
int __fastcall CBasicBindingTest::IsReadyToRun(CBasicBindingTest *this)
{
  return *((unsigned __int8 *)this + 16) ^ 1;
}

//----- (0005EBEC) --------------------------------------------------------
int __fastcall CBasicBindingTest::NotifyTimeout(int result)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(result + 12);
  *(_BYTE *)(result + 16) = 1;
  *v1 = 0;
  return result;
}

//----- (0005EC04) --------------------------------------------------------
int __fastcall CBehaviorTest::NotifyTimeout(int result)
{
  int v1; // r3

  v1 = *(_DWORD *)(result + 12);
  *(_BYTE *)(result + 16) = 1;
  *(_BYTE *)(v1 + 148) = 0;
  return result;
}

//----- (0005EC1C) --------------------------------------------------------
signed int __fastcall CStunClientTestBase::Init(int a1, int a2, int a3)
{
  if ( !a2 || !a3 )
    return -2147024809;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 4) = 1;
  memset((void *)(a1 + 17), 0, 0x10u);
  return 0;
}

//----- (0005EC70) --------------------------------------------------------
signed int __fastcall CBehaviorTest::IsReadyToRun(CBehaviorTest *this)
{
  unsigned __int8 *v1; // r2
  int v2; // r1

  if ( *((_BYTE *)this + 16) )
    return 0;
  v1 = (unsigned __int8 *)*((_DWORD *)this + 3);
  v2 = *v1;
  if ( !*v1 )
    return v2;
  v2 = v1[60];
  if ( !v1[60] )
    return v2;
  if ( v1[148] )
    return *((unsigned __int8 *)this + 16);
  if ( *((_BYTE *)this + 33) )
    return !CSocketAddress::IsIPAddressZero((CSocketAddress *)(v1 + 156));
  return 1;
}

//----- (0005ECE8) --------------------------------------------------------
int __fastcall CBehaviorTest::PreRunCheck(int result)
{
  int v1; // r3

  if ( !*(_BYTE *)(result + 33) )
  {
    v1 = *(_DWORD *)(result + 12);
    if ( *(_BYTE *)v1 )
    {
      if ( *(_BYTE *)(v1 + 1) )
      {
        *(_BYTE *)(result + 16) = 1;
        *(_DWORD *)(v1 + 152) = 1;
        *(_BYTE *)(v1 + 148) = 1;
      }
    }
  }
  return result;
}

//----- (0005ED20) --------------------------------------------------------
CStunClientTestBase *__fastcall CStunClientTestBase::CStunClientTestBase(CStunClientTestBase *this)
{
  CStunClientTestBase *v1; // r4

  v1 = this;
  *((_BYTE *)this + 4) = 0;
  *(_DWORD *)this = &off_F03F0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_BYTE *)this + 16) = 0;
  memset((char *)this + 17, 0, 0x10u);
  return v1;
}
// F03F0: using guessed type int (*)();

//----- (0005ED68) --------------------------------------------------------
int __fastcall CStunClientTestBase::StartBindingRequest(CStunClientTestBase *this, CStunMessageBuilder *a2)
{
  char *v2; // r4
  CDataStream *v3; // r5

  v2 = (char *)this + 17;
  v3 = a2;
  CStunMessageBuilder::AddBindingRequestHeader(a2);
  if ( IsTransactionIdValid(v2) )
    CStunMessageBuilder::AddTransactionId(v3, v2);
  else
    CStunMessageBuilder::AddRandomTransactionId(v3, v2);
  return 0;
}

//----- (0005EDAC) --------------------------------------------------------
int __fastcall CBasicBindingTest::GetMessage(CStunClientTestBase *a1, int a2, _DWORD *a3)
{
  CStunClientTestBase *v3; // r6
  int v4; // r7
  _DWORD *v5; // r8
  int v6; // r0
  int v7; // r7
  int *v8; // r4
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // r12
  int v14; // r1
  int v15; // r2
  int v16; // r4
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int *v20; // r3
  unsigned int v21; // r2
  __int16 v22; // [sp+0h] [bp-48h]
  char v23; // [sp+4h] [bp-44h]
  int v24; // [sp+8h] [bp-40h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v22 = 0;
  CStunMessageBuilder::CStunMessageBuilder((CStunMessageBuilder *)&v23);
  v6 = CStunMessageBuilder::GetStream((CStunMessageBuilder *)&v23);
  CDataStream::Attach(v6, v4, 1);
  v7 = CStunClientTestBase::StartBindingRequest(v3, (CStunMessageBuilder *)&v23);
  if ( v7 >= 0 )
  {
    CStunMessageBuilder::AddChangeRequest((CStunMessageBuilder *)&v23, (unsigned __int8 *)&v22);
    CStunMessageBuilder::FixLengthField((CStunMessageBuilder *)&v23);
    v8 = (int *)*((_DWORD *)v3 + 2);
    v9 = *v8;
    v10 = v8[1];
    v11 = v8[2];
    v12 = v8[3];
    v8 += 4;
    *v5 = v9;
    v5[1] = v10;
    v5[2] = v11;
    v5[3] = v12;
    v13 = v5 + 4;
    v14 = v8[1];
    v15 = v8[2];
    *v13 = *v8;
    v13[1] = v14;
    v13[2] = v15;
  }
  v16 = v24;
  if ( v24 )
  {
    v17 = (unsigned int *)(v24 + 4);
    __dmb(0xFu);
    do
      v18 = __ldrex(v17);
    while ( __strex(v18 - 1, v17) );
    __dmb(0xFu);
    if ( v18 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v16 + 8))(v16);
      v20 = (unsigned int *)(v16 + 8);
      __dmb(0xFu);
      do
        v21 = __ldrex(v20);
      while ( __strex(v21 - 1, v20) );
      __dmb(0xFu);
      if ( v21 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v16 + 12))(v16);
    }
  }
  return v7;
}

//----- (0005EEF0) --------------------------------------------------------
int __fastcall CBehaviorTest::GetMessage(int a1, int a2, _DWORD *a3)
{
  int v3; // r6
  int v4; // r8
  _DWORD *v5; // r7
  int v6; // r0
  int v7; // r4
  int *v8; // r4
  int v9; // r0
  int *v10; // r4
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r4
  bool v19; // zf
  unsigned int *v20; // r3
  unsigned int v21; // r2
  unsigned int *v23; // r3
  unsigned int v24; // r2
  __int16 v25; // [sp+0h] [bp-48h]
  char v26; // [sp+4h] [bp-44h]
  int v27; // [sp+8h] [bp-40h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v25 = 0;
  CStunMessageBuilder::CStunMessageBuilder((CStunMessageBuilder *)&v26);
  v6 = CStunMessageBuilder::GetStream((CStunMessageBuilder *)&v26);
  CDataStream::Attach(v6, v4, 1);
  CStunClientTestBase::StartBindingRequest((CStunClientTestBase *)v3, (CStunMessageBuilder *)&v26);
  CStunMessageBuilder::AddChangeRequest((CStunMessageBuilder *)&v26, (unsigned __int8 *)&v25);
  CStunMessageBuilder::FixLengthField((CStunMessageBuilder *)&v26);
  v7 = *(_DWORD *)(v3 + 12);
  if ( *(_BYTE *)(v3 + 33) )
    v8 = (int *)(v7 + 120);
  else
    v8 = (int *)(v7 + 92);
  v9 = *v8;
  v11 = v8[1];
  v12 = v8[2];
  v13 = v8[3];
  v10 = v8 + 4;
  *v5 = v9;
  v5[1] = v11;
  v5[2] = v12;
  v5[3] = v13;
  v14 = v5 + 4;
  v15 = *v10;
  v16 = v10[1];
  v17 = v10[2];
  v18 = v27;
  v19 = v27 == 0;
  *v14 = v15;
  v14[1] = v16;
  v14[2] = v17;
  if ( !v19 )
  {
    v20 = (unsigned int *)(v18 + 4);
    __dmb(0xFu);
    do
      v21 = __ldrex(v20);
    while ( __strex(v21 - 1, v20) );
    __dmb(0xFu);
    if ( v21 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 8))(v18);
      v23 = (unsigned int *)(v18 + 8);
      __dmb(0xFu);
      do
        v24 = __ldrex(v23);
      while ( __strex(v24 - 1, v23) );
      __dmb(0xFu);
      if ( v24 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 12))(v18);
    }
  }
  return 0;
}

//----- (0005F03C) --------------------------------------------------------
signed int __fastcall CStunClientTestBase::BasicReaderValidation(int a1, const unsigned __int8 ***a2, CStunMessageReader *a3)
{
  int v3; // r5
  int v4; // r6
  signed int result; // r0
  char v6; // [sp+4h] [bp-24h]

  v3 = (int)a3;
  v4 = a1;
  if ( CStunMessageReader::AddBytes(a3, **a2, (unsigned int)(*a2)[1]) != 2 )
    return -2147467259;
  CStunMessageReader::GetTransactionId(v3, &v6);
  if ( !memcmp(&v6, (const void *)(v4 + 17), 0x10u) )
    result = 0;
  else
    result = -2147467259;
  return result;
}

//----- (0005F0D4) --------------------------------------------------------
signed int __fastcall CBasicBindingTest::ProcessResponse(int a1, const unsigned __int8 ***a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r10
  int v5; // r6
  const unsigned __int8 ***v6; // r8
  signed int v7; // r8
  signed int v8; // r0
  _BYTE *v9; // r11
  _BOOL4 v10; // r5
  int v11; // r0
  _DWORD *v12; // r10
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // r12
  int v17; // r1
  int v18; // r2
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // r12
  int v23; // r1
  int v24; // r2
  int v25; // r12
  int v26; // r5
  unsigned int *v27; // r3
  unsigned int v28; // r2
  _DWORD *v30; // r12
  int v31; // r1
  int v32; // r2
  int v33; // r3
  int v34; // r1
  int v35; // r2
  int *v36; // lr
  int v37; // r0
  int v38; // r1
  int v39; // r2
  int v40; // r3
  int *v41; // r12
  int v42; // r1
  int v43; // r2
  int v44; // r5
  int v45; // r0
  int v46; // r1
  int v47; // r2
  int v48; // r3
  _DWORD *v49; // r12
  int v50; // r1
  int v51; // r2
  int v52; // r5
  int v53; // r0
  unsigned int *v54; // r3
  unsigned int v55; // r2
  int v56; // [sp+0h] [bp-460h]
  int v57; // [sp+4h] [bp-45Ch]
  int v58; // [sp+8h] [bp-458h]
  int v59; // [sp+Ch] [bp-454h]
  int v60; // [sp+10h] [bp-450h]
  int v61; // [sp+14h] [bp-44Ch]
  int v62; // [sp+18h] [bp-448h]
  char v63; // [sp+1Ch] [bp-444h]
  int v64; // [sp+20h] [bp-440h]
  int v65; // [sp+24h] [bp-43Ch]
  int v66; // [sp+28h] [bp-438h]
  int v67; // [sp+2Ch] [bp-434h]
  int v68; // [sp+30h] [bp-430h]
  int v69; // [sp+34h] [bp-42Ch]
  char v70; // [sp+38h] [bp-428h]
  char v71; // [sp+9Ch] [bp-3C4h]
  int v72; // [sp+A0h] [bp-3C0h]

  v4 = a4;
  v5 = a1;
  v6 = a2;
  CStunMessageReader::CStunMessageReader((CStunMessageReader *)&v71);
  CSocketAddress::CSocketAddress((int)&v56);
  CSocketAddress::CSocketAddress((int)&v63);
  v7 = CStunClientTestBase::BasicReaderValidation(v5, v6, (CStunMessageReader *)&v71);
  if ( v7 >= 0 )
  {
    v7 = CStunMessageReader::GetXorMappedAddress((CStunMessageReader *)&v71, (CSocketAddress *)&v56);
    if ( v7 >= 0
      || (v7 = CStunMessageReader::GetMappedAddress((CStunMessageReader *)&v71, (CSocketAddress *)&v56), v7 >= 0) )
    {
      v8 = CStunMessageReader::GetOtherAddress((CStunMessageReader *)&v71, (CSocketAddress *)&v63);
      v9 = *(_BYTE **)(v5 + 12);
      *(_BYTE *)(v5 + 16) = 1;
      *v9 = 1;
      v10 = v8 >= 0;
      v9[1] = CSocketAddress::IsSameIP_and_Port((CSocketAddress *)v4, (const CSocketAddress *)&v56);
      v11 = *v4;
      v13 = v4[1];
      v14 = v4[2];
      v15 = v4[3];
      v12 = v4 + 4;
      v16 = (_DWORD *)(*(_DWORD *)(v5 + 12) + 4);
      *v16 = v11;
      v16[1] = v13;
      v16[2] = v14;
      v16[3] = v15;
      v16 += 4;
      v17 = v12[1];
      v18 = v12[2];
      *v16 = *v12;
      v16[1] = v17;
      v16[2] = v18;
      v19 = v57;
      v20 = v58;
      v21 = v59;
      v22 = (_DWORD *)(*(_DWORD *)(v5 + 12) + 32);
      *v22 = v56;
      v22[1] = v19;
      v22[2] = v20;
      v22[3] = v21;
      v22 += 4;
      v23 = v61;
      v24 = v62;
      *v22 = v60;
      v22[1] = v23;
      v22[2] = v24;
      v25 = *(_DWORD *)(v5 + 12);
      *(_BYTE *)(v25 + 60) = v10;
      if ( v10 )
      {
        v30 = (_DWORD *)(v25 + 120);
        v31 = v64;
        v32 = v65;
        v33 = v66;
        *v30 = *(_DWORD *)&v63;
        v30[1] = v31;
        v30[2] = v32;
        v30[3] = v33;
        v30 += 4;
        v34 = v68;
        v35 = v69;
        *v30 = v67;
        v30[1] = v34;
        v30[2] = v35;
        v36 = *(int **)(v5 + 8);
        v37 = *v36;
        v38 = v36[1];
        v39 = v36[2];
        v40 = v36[3];
        v36 += 4;
        v41 = (int *)(*(_DWORD *)(v5 + 12) + 64);
        *v41 = v37;
        v41[1] = v38;
        v41[2] = v39;
        v41[3] = v40;
        v41 += 4;
        v42 = v36[1];
        v43 = v36[2];
        *v41 = *v36;
        v41[1] = v42;
        v41[2] = v43;
        v44 = *(_DWORD *)(v5 + 12) + 64;
        v45 = CSocketAddress::GetPort((CSocketAddress *)&v63);
        CSocketAddress::SetPort(v44, v45);
        v46 = v64;
        v47 = v65;
        v48 = v66;
        v49 = (_DWORD *)(*(_DWORD *)(v5 + 12) + 92);
        *v49 = *(_DWORD *)&v63;
        v49[1] = v46;
        v49[2] = v47;
        v49[3] = v48;
        v49 += 4;
        v50 = v68;
        v51 = v69;
        *v49 = v67;
        v49[1] = v50;
        v49[2] = v51;
        v52 = *(_DWORD *)(v5 + 12) + 92;
        v53 = CSocketAddress::GetPort(*(CSocketAddress **)(v5 + 8));
        CSocketAddress::SetPort(v52, v53);
        CSocketAddress::ToStringBuffer((CSocketAddress *)&v63, &v70, 0x64u);
        printf("Other address is %s\n", &v70);
      }
    }
  }
  v26 = v72;
  if ( v72 )
  {
    v27 = (unsigned int *)(v72 + 4);
    __dmb(0xFu);
    do
      v28 = __ldrex(v27);
    while ( __strex(v28 - 1, v27) );
    __dmb(0xFu);
    if ( v28 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v26 + 8))(v26);
      v54 = (unsigned int *)(v26 + 8);
      __dmb(0xFu);
      do
        v55 = __ldrex(v54);
      while ( __strex(v55 - 1, v54) );
      __dmb(0xFu);
      if ( v55 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v26 + 12))(v26);
    }
  }
  return v7;
}

//----- (0005F348) --------------------------------------------------------
signed int __fastcall CBehaviorTest::ProcessResponse(int a1, const unsigned __int8 ***a2)
{
  int v2; // r5
  const unsigned __int8 ***v3; // r8
  signed int v4; // r8
  int v5; // r12
  bool v6; // zf
  int v7; // r1
  int v8; // r2
  int v9; // r3
  _DWORD *v10; // r12
  int v11; // r1
  int v12; // r2
  int v13; // r3
  signed int v14; // r2
  int v15; // r5
  unsigned int *v16; // r3
  unsigned int v17; // r2
  _DWORD *v19; // r12
  int v20; // r1
  int v21; // r2
  int v22; // r3
  unsigned int *v23; // r3
  unsigned int v24; // r2
  int v25; // [sp+0h] [bp-3D0h]
  int v26; // [sp+4h] [bp-3CCh]
  int v27; // [sp+8h] [bp-3C8h]
  int v28; // [sp+Ch] [bp-3C4h]
  int v29; // [sp+10h] [bp-3C0h]
  int v30; // [sp+14h] [bp-3BCh]
  int v31; // [sp+18h] [bp-3B8h]
  char v32; // [sp+1Ch] [bp-3B4h]
  int v33; // [sp+20h] [bp-3B0h]

  v2 = a1;
  v3 = a2;
  CStunMessageReader::CStunMessageReader((CStunMessageReader *)&v32);
  CSocketAddress::CSocketAddress((int)&v25);
  v4 = CStunClientTestBase::BasicReaderValidation(v2, v3, (CStunMessageReader *)&v32);
  if ( v4 >= 0 )
  {
    v4 = CStunMessageReader::GetXorMappedAddress((CStunMessageReader *)&v32, (CSocketAddress *)&v25);
    if ( v4 >= 0
      || (v4 = CStunMessageReader::GetMappedAddress((CStunMessageReader *)&v32, (CSocketAddress *)&v25), v4 >= 0) )
    {
      v5 = *(_DWORD *)(v2 + 12);
      v6 = *(_BYTE *)(v2 + 33) == 0;
      *(_BYTE *)(v2 + 16) = 1;
      v7 = v26;
      v8 = v27;
      v9 = v28;
      if ( v6 )
      {
        v19 = (_DWORD *)(v5 + 156);
        *v19 = v25;
        v19[1] = v7;
        v19[2] = v8;
        v19[3] = v9;
        v19 += 4;
        v20 = v30;
        v21 = v31;
        *v19 = v29;
        v19[1] = v20;
        v19[2] = v21;
        if ( CSocketAddress::IsSameIP_and_Port(
               (CSocketAddress *)&v25,
               (const CSocketAddress *)(*(_DWORD *)(v2 + 12) + 32)) )
        {
          v22 = *(_DWORD *)(v2 + 12);
          *(_BYTE *)(v22 + 148) = 1;
          *(_DWORD *)(v22 + 152) = 2;
        }
      }
      else
      {
        v10 = (_DWORD *)(v5 + 184);
        *v10 = v25;
        v10[1] = v7;
        v10[2] = v8;
        v10[3] = v9;
        v10 += 4;
        v11 = v30;
        v12 = v31;
        *v10 = v29;
        v10[1] = v11;
        v10[2] = v12;
        v13 = *(_DWORD *)(v2 + 12);
        *(_BYTE *)(v13 + 148) = 1;
        if ( CSocketAddress::IsSameIP_and_Port((CSocketAddress *)&v25, (const CSocketAddress *)(v13 + 156)) )
          v14 = 3;
        else
          v14 = 4;
        *(_DWORD *)(*(_DWORD *)(v2 + 12) + 152) = v14;
      }
    }
  }
  v15 = v33;
  if ( v33 )
  {
    v16 = (unsigned int *)(v33 + 4);
    __dmb(0xFu);
    do
      v17 = __ldrex(v16);
    while ( __strex(v17 - 1, v16) );
    __dmb(0xFu);
    if ( v17 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v15 + 8))(v15);
      v23 = (unsigned int *)(v15 + 8);
      __dmb(0xFu);
      do
        v24 = __ldrex(v23);
      while ( __strex(v24 - 1, v23) );
      __dmb(0xFu);
      if ( v24 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v15 + 12))(v15);
    }
  }
  return v4;
}

//----- (0005F50C) --------------------------------------------------------
CBehaviorTest *__fastcall CBehaviorTest::CBehaviorTest(CBehaviorTest *this)
{
  CBehaviorTest *v1; // r4
  CBehaviorTest *result; // r0

  v1 = this;
  CStunClientTestBase::CStunClientTestBase(this);
  result = v1;
  *((_BYTE *)v1 + 33) = 0;
  *(_DWORD *)v1 = &off_F0440;
  return result;
}
// F0440: using guessed type int (*)();

//----- (0005F53C) --------------------------------------------------------
int __fastcall CBehaviorTest::RunAsTest3(int result, bool a2)
{
  *(_BYTE *)(result + 33) = a2;
  return result;
}

//----- (0005F544) --------------------------------------------------------
int __fastcall CStunMessageReader::Reset(CStunMessageReader *this)
{
  CStunMessageReader *v1; // r4
  void *v2; // r0
  int v3; // r1
  int v4; // r0
  int v5; // r3
  int v6; // r2
  int v7; // r3

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 12);
  *((_BYTE *)v1 + 21) = 0;
  *((_BYTE *)v1 + 20) = 1;
  *((_DWORD *)v1 + 6) = 0;
  if ( v2 )
    memset(v2, 0, 4 * *((_DWORD *)v1 + 8));
  v3 = *((_DWORD *)v1 + 7);
  v4 = *((_DWORD *)v1 + 10);
  if ( v3 && v4 )
  {
    v5 = v4 + 8;
    v6 = 0;
    do
    {
      *(_DWORD *)(v5 - 8) = v6++;
      *(_DWORD *)(v5 - 4) = v5;
      v5 += 8;
    }
    while ( v6 != v3 );
    *(_DWORD *)(v4 + 8 * (v6 + 0x1FFFFFFF) + 4) = 0;
  }
  v7 = *((_DWORD *)v1 + 13);
  *((_DWORD *)v1 + 11) = v4;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 15) = 0;
  *((_BYTE *)v1 + 56) = v7 != 0;
  *((_DWORD *)v1 + 222) = 0;
  *((_DWORD *)v1 + 220) = -1;
  *((_DWORD *)v1 + 221) = -1;
  memset((char *)v1 + 892, 0, 0x10u);
  *((_WORD *)v1 + 454) = -1;
  *((_WORD *)v1 + 458) = 0;
  *((_DWORD *)v1 + 228) = 255;
  return CDataStream::Reset((int)v1);
}

//----- (0005F624) --------------------------------------------------------
CStunMessageReader *__fastcall CStunMessageReader::CStunMessageReader(CStunMessageReader *this)
{
  CStunMessageReader *v1; // r4
  void *v2; // r0
  char v3; // r12
  signed int v4; // r1
  signed int v5; // r0
  int v7; // r3
  int v8; // r2

  v1 = this;
  CDataStream::CDataStream((int)this);
  v2 = (char *)v1 + 308;
  v3 = (_BYTE)v1 - 8;
  *((_DWORD *)v1 + 8) = 53;
  if ( v1 != (CStunMessageReader *)-760 )
    v3 = 1;
  *((_DWORD *)v1 + 9) = (char *)v1 + 68;
  *((_DWORD *)v1 + 13) = (char *)v1 + 760;
  *((_BYTE *)v1 + 56) = v3;
  *((_DWORD *)v1 + 12) = v2;
  *((_DWORD *)v1 + 10) = (char *)v1 + 520;
  *((_DWORD *)v1 + 7) = 30;
  *((_DWORD *)v1 + 11) = 0;
  *((_DWORD *)v1 + 15) = 0;
  if ( v1 == (CStunMessageReader *)-308 )
  {
    v5 = 212;
    v4 = 30;
  }
  else
  {
    memset(v2, 0, 0xD4u);
    v4 = *((_DWORD *)v1 + 7);
    v5 = *((_DWORD *)v1 + 10);
    v3 = *((_DWORD *)v1 + 13) != 0;
    if ( !v4 )
      goto LABEL_5;
  }
  if ( v5 )
  {
    v7 = v5 + 8;
    v8 = 0;
    do
    {
      *(_DWORD *)(v7 - 8) = v8++;
      *(_DWORD *)(v7 - 4) = v7;
      v7 += 8;
    }
    while ( v8 != v4 );
    *(_DWORD *)(v5 + 8 * (v8 + 0x1FFFFFFF) + 4) = 0;
  }
LABEL_5:
  *((_DWORD *)v1 + 11) = v5;
  *((_BYTE *)v1 + 56) = v3;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 15) = 0;
  CStunMessageReader::Reset(v1);
  return v1;
}

//----- (0005F720) --------------------------------------------------------
int __fastcall CStunMessageReader::SetAllowLegacyFormat(int result, bool a2)
{
  *(_BYTE *)(result + 20) = a2;
  return result;
}

//----- (0005F728) --------------------------------------------------------
int __fastcall CStunMessageReader::IsMessageLegacyFormat(CStunMessageReader *this)
{
  return *((unsigned __int8 *)this + 21);
}

//----- (0005F730) --------------------------------------------------------
int __fastcall CStunMessageReader::HowManyBytesNeeded(CStunMessageReader *this)
{
  CStunMessageReader *v1; // r4
  __int16 v2; // r0
  int v3; // r3

  v1 = this;
  v2 = CDataStream::GetSize(this);
  v3 = *((_DWORD *)v1 + 6);
  if ( !v3 )
    return (unsigned __int16)(20 - v2);
  if ( v3 == 1 )
    return (unsigned __int16)(*((_WORD *)v1 + 458) + 20 - v2);
  return 0;
}

//----- (0005F77C) --------------------------------------------------------
signed int __fastcall CStunMessageReader::HasFingerprintAttribute(CStunMessageReader *this)
{
  _DWORD *v1; // r3
  int v2; // r1

  v1 = *(_DWORD **)(*((_DWORD *)this + 12) + 4 * (0x8028u % *((_DWORD *)this + 8)));
  if ( !v1 )
    return (signed int)v1;
  v2 = *((_DWORD *)this + 9);
  if ( *(unsigned __int16 *)(v2 + 8 * *v1) != 32808 )
  {
    while ( 1 )
    {
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        break;
      if ( *(unsigned __int16 *)(v2 + 8 * *v1) == 32808 )
        return 1;
    }
    return (signed int)v1;
  }
  return 1;
}

//----- (0005F7F4) --------------------------------------------------------
signed int __fastcall CStunMessageReader::HasMessageIntegrityAttribute(CStunMessageReader *this)
{
  _DWORD *v1; // r3
  int v2; // r1

  v1 = *(_DWORD **)(*((_DWORD *)this + 12) + 4 * (8u % *((_DWORD *)this + 8)));
  if ( !v1 )
    return (signed int)v1;
  v2 = *((_DWORD *)this + 9);
  if ( *(_WORD *)(v2 + 8 * *v1) != 8 )
  {
    while ( 1 )
    {
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        break;
      if ( *(_WORD *)(v2 + 8 * *v1) == 8 )
        return 1;
    }
    return (signed int)v1;
  }
  return 1;
}

//----- (0005F864) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetAttributeByIndex(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // r3
  int v4; // r5
  int v5; // r8
  int v6; // r7
  int v7; // r12
  int v8; // r0
  int v9; // r2
  int v10; // r3
  int v11; // t1
  signed int result; // r0
  unsigned int v13; // lr
  unsigned int v14; // r6
  int v15; // r2
  int *v16; // r3
  int *v17; // t1
  int v18; // lr
  int v19; // r4

  v3 = *(_DWORD *)(a1 + 64);
  v4 = a1;
  v5 = a3;
  if ( a2 >= v3 )
    return -2147467259;
  v6 = *(_DWORD *)(a1 + 52);
  if ( !v6 )
    return -2147467259;
  v7 = *(unsigned __int8 *)(a1 + 56);
  if ( *(_BYTE *)(a1 + 56) )
  {
    v8 = *(_DWORD *)(a1 + 60);
  }
  else
  {
    if ( !v3 )
      return -2147467259;
    v13 = *(_DWORD *)(a1 + 32);
    if ( v13 )
    {
      v14 = *(unsigned __int8 *)(a1 + 56);
      v15 = *(_DWORD *)(a1 + 48) - 4;
      do
      {
        v17 = *(int **)(v15 + 4);
        v15 += 4;
        v16 = v17;
        if ( v17 )
        {
          v18 = v6 + 4 * (v7 + 0x3FFFFFFF);
          do
          {
            v19 = *v16;
            ++v7;
            v16 = (int *)v16[1];
            *(_DWORD *)(v18 + 4) = v19;
            v18 += 4;
          }
          while ( v16 );
          v13 = *(_DWORD *)(a1 + 32);
        }
        ++v14;
      }
      while ( v14 < v13 );
    }
    v8 = 0;
    *(_DWORD *)(v4 + 60) = 0;
    *(_BYTE *)(v4 + 56) = 1;
  }
  v9 = *(_DWORD *)(v6 + 4 * ((v8 + a2) % *(_DWORD *)(v4 + 28)));
  v10 = *(_DWORD *)(v4 + 36) + 8 * v9;
  if ( !v10 )
    return -2147467259;
  if ( v5 )
  {
    v11 = *(_DWORD *)(v10 + 2);
    v10 += 2;
    v9 = v11;
  }
  result = 0;
  if ( v5 )
  {
    *(_DWORD *)v5 = v9;
    *(_WORD *)(v5 + 4) = *(_WORD *)(v10 + 4);
  }
  return result;
}

//----- (0005F950) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetAttributeByType(_DWORD *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r5
  _DWORD *v4; // r3
  int v5; // r4
  unsigned __int16 *i; // r1
  signed int result; // r0

  v3 = a2;
  v4 = *(_DWORD **)(a1[12] + 4 * (a2 % a1[8]));
  if ( !v4 )
    return -2147467259;
  v5 = a1[9];
  for ( i = (unsigned __int16 *)(v5 + 8 * *v4); *i != v3; i = (unsigned __int16 *)(v5 + 8 * *v4) )
  {
    v4 = (_DWORD *)v4[1];
    if ( !v4 )
      return -2147467259;
  }
  if ( !a3 )
    return 0;
  result = 0;
  *(_DWORD *)a3 = *(_DWORD *)(i + 1);
  *(_WORD *)(a3 + 4) = i[3];
  return result;
}

//----- (0005F9F4) --------------------------------------------------------
int __fastcall CStunMessageReader::GetAttributeCount(CStunMessageReader *this)
{
  return *((_DWORD *)this + 16);
}

//----- (0005F9FC) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetResponsePort(CStunMessageReader *this, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // r6
  int *v3; // r3
  int i; // r2
  _WORD *v5; // r4
  _DWORD *v6; // r0
  unsigned __int16 v7; // r3
  signed int result; // r0

  v2 = a2;
  if ( !a2 )
    return -2147024809;
  v3 = *(int **)(*((_DWORD *)this + 12) + 4 * (0x27u % *((_DWORD *)this + 8)));
  if ( !v3 )
    return -2147467259;
  for ( i = *v3; ; i = *v3 )
  {
    v5 = (_WORD *)(*((_DWORD *)this + 9) + 8 * i);
    if ( *v5 == 39 )
      break;
    v3 = (int *)v3[1];
    if ( !v3 )
      return -2147467259;
  }
  if ( v5[2] != 2 )
    return -2147418113;
  v6 = CDataStream::GetDataPointerUnsafe(this);
  if ( !v6 )
    return -2147418113;
  v7 = __rev16(*(unsigned __int16 *)((char *)v6 + (unsigned __int16)v5[3]));
  result = 0;
  *v2 = v7;
  return result;
}

//----- (0005FAC8) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetChangeRequest(CDataStream *a1, _BYTE *a2)
{
  _BYTE *v2; // r6
  int *v3; // r3
  int i; // r2
  _WORD *v5; // r4
  _DWORD *v6; // r0
  unsigned int v7; // r3
  signed int result; // r0

  v2 = a2;
  if ( !a2 )
    return -2147024809;
  v3 = *(int **)(*((_DWORD *)a1 + 12) + 4 * (3u % *((_DWORD *)a1 + 8)));
  if ( v3 )
  {
    for ( i = *v3; ; i = *v3 )
    {
      v5 = (_WORD *)(*((_DWORD *)a1 + 9) + 8 * i);
      if ( *v5 == 3 )
        break;
      v3 = (int *)v3[1];
      if ( !v3 )
        goto LABEL_10;
    }
    if ( v5[2] == 4 )
    {
      v6 = CDataStream::GetDataPointerUnsafe(a1);
      if ( v6 )
      {
        v7 = bswap32(*(_DWORD *)((char *)v6 + (unsigned __int16)v5[3]));
        result = 0;
        *v2 = (v7 >> 2) & 1;
        v2[1] = (v7 >> 1) & 1;
        return result;
      }
    }
    result = -2147418113;
  }
  else
  {
LABEL_10:
    result = -2147467259;
  }
  *v2 = 0;
  v2[1] = 0;
  return result;
}

//----- (0005FBB0) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetPaddingAttributeSize(CStunMessageReader *this, unsigned __int16 *a2)
{
  int *v2; // r3
  int v3; // r2
  int v4; // r0
  _WORD *v5; // r12
  signed int result; // r0

  if ( !a2 )
    return -2147024809;
  *a2 = 0;
  v2 = *(int **)(*((_DWORD *)this + 12) + 4 * (0x26u % *((_DWORD *)this + 8)));
  if ( !v2 )
    return -2147467259;
  v3 = *v2;
  v4 = *((_DWORD *)this + 9);
  while ( 1 )
  {
    v5 = (_WORD *)(v4 + 8 * v3);
    if ( *v5 == 38 )
      break;
    v2 = (int *)v2[1];
    if ( !v2 )
      return -2147467259;
    v3 = *v2;
  }
  result = 0;
  *a2 = v5[2];
  return result;
}

//----- (0005FC3C) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetErrorCode(CStunMessageReader *this, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // r6
  int *v3; // r3
  int i; // r2
  _WORD *v5; // r4
  char *v6; // r1
  signed int result; // r0

  v2 = a2;
  if ( !a2 )
    return -2147024809;
  v3 = *(int **)(*((_DWORD *)this + 12) + 4 * (9u % *((_DWORD *)this + 8)));
  if ( !v3 )
    return -2147467259;
  for ( i = *v3; ; i = *v3 )
  {
    v5 = (_WORD *)(*((_DWORD *)this + 9) + 8 * i);
    if ( *v5 == 9 )
      break;
    v3 = (int *)v3[1];
    if ( !v3 )
      return -2147467259;
  }
  v6 = (char *)CDataStream::GetDataPointerUnsafe(this) + (unsigned __int16)v5[3] + 2;
  result = 0;
  *v2 = (unsigned __int8)v6[1] + 100 * (*v6 & 7);
  return result;
}

//----- (0005FCEC) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetAddressHelper(CStunMessageReader *this, int a2, CSocketAddress *a3)
{
  CSocketAddress *v3; // r7
  _DWORD *v4; // r3
  int v5; // r4
  unsigned __int16 *i; // r6
  signed int v7; // r4
  unsigned __int8 *v9; // r0
  int v10; // [sp+0h] [bp-88h]

  v3 = a3;
  v4 = *(_DWORD **)(*((_DWORD *)this + 12) + 4 * ((unsigned int)a2 % *((_DWORD *)this + 8)));
  if ( !v4 )
    return -2147467259;
  v5 = *((_DWORD *)this + 9);
  for ( i = (unsigned __int16 *)(v5 + 8 * *v4); *i != a2; i = (unsigned __int16 *)(v5 + 8 * *v4) )
  {
    v4 = (_DWORD *)v4[1];
    if ( !v4 )
      return -2147467259;
  }
  v9 = (unsigned __int8 *)CDataStream::GetDataPointerUnsafe(this);
  v7 = GetMappedAddress(&v9[i[3]], i[2], v3);
  if ( v7 >= 0 )
  {
    CSocketAddress::ToStringBuffer(v3, (char *)&v10, 0x64u);
    printf("origin ip %s \n", &v10);
  }
  return v7;
}

//----- (0005FDE8) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetMappedAddress(CStunMessageReader *this, CSocketAddress *a2)
{
  return CStunMessageReader::GetAddressHelper(this, 1, a2);
}

//----- (0005FDF4) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetOtherAddress(CStunMessageReader *this, CSocketAddress *a2)
{
  CSocketAddress *v2; // r4
  CStunMessageReader *v3; // r5
  signed int result; // r0

  v2 = a2;
  v3 = this;
  result = CStunMessageReader::GetAddressHelper(this, 32812, a2);
  if ( result < 0 )
    result = CStunMessageReader::GetAddressHelper(v3, 5, v2);
  return result;
}

//----- (0005FE28) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetXorMappedAddress(CStunMessageReader *this, CSocketAddress *a2)
{
  CSocketAddress *v2; // r4
  CStunMessageReader *v3; // r6
  signed int v4; // r5
  signed int result; // r0

  v2 = a2;
  v3 = this;
  v4 = CStunMessageReader::GetAddressHelper(this, 32, a2);
  if ( v4 >= 0 || (result = CStunMessageReader::GetAddressHelper(v3, 32800, v2), v4 = result, result >= 0) )
  {
    CSocketAddress::ApplyStunXorMap(v2, (_BYTE *)v3 + 892);
    result = v4;
  }
  return result;
}

//----- (0005FE7C) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetResponseOriginAddress(CStunMessageReader *this, CSocketAddress *a2)
{
  CSocketAddress *v2; // r4
  CStunMessageReader *v3; // r5
  signed int result; // r0

  v2 = a2;
  v3 = this;
  result = CStunMessageReader::GetAddressHelper(this, 32811, a2);
  if ( result < 0 )
    result = CStunMessageReader::GetAddressHelper(v3, 4, v2);
  return result;
}

//----- (0005FEB0) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetStringAttributeByType(CStunMessageReader *this, int a2, char *a3, unsigned int a4)
{
  char *v4; // r8
  _DWORD *v5; // r12
  int v6; // r5
  unsigned __int16 *i; // r10
  signed int result; // r0
  _DWORD *v9; // r0

  v4 = a3;
  v5 = *(_DWORD **)(*((_DWORD *)this + 12) + 4 * ((unsigned int)a2 % *((_DWORD *)this + 8)));
  if ( !v5 )
    return -2147024809;
  v6 = *((_DWORD *)this + 9);
  for ( i = (unsigned __int16 *)(v6 + 8 * *v5); *i != a2; i = (unsigned __int16 *)(v6 + 8 * *v5) )
  {
    v5 = (_DWORD *)v5[1];
    if ( !v5 )
      return -2147024809;
  }
  if ( !a3 )
    return -2147024809;
  if ( i[2] >= a4 )
    return -2147024809;
  v9 = CDataStream::GetDataPointerUnsafe(this);
  memcpy(v4, (char *)v9 + i[3], i[2]);
  result = 0;
  v4[i[2]] = 0;
  return result;
}

//----- (0005FF74) --------------------------------------------------------
signed int __fastcall CStunMessageReader::ReadHeader(CStunMessageReader *this)
{
  CStunMessageReader *v1; // r5
  signed int v2; // r12
  unsigned __int16 v3; // r10
  unsigned __int16 v4; // r7
  _BOOL4 v5; // r3
  unsigned int v6; // r0
  signed int v7; // r3
  int v8; // r1
  int v9; // r2
  bool v10; // cf
  bool v11; // zf
  unsigned int *v12; // r7
  int v13; // r6
  unsigned __int16 v15; // [sp+0h] [bp-40h]
  unsigned __int16 v16; // [sp+2h] [bp-3Eh]
  unsigned int v17; // [sp+4h] [bp-3Ch]
  int v18; // [sp+8h] [bp-38h]
  int v19; // [sp+Ch] [bp-34h]
  int v20; // [sp+10h] [bp-30h]

  v1 = this;
  v2 = CDataStream::SeekDirect(this, 0);
  if ( v2 >= 0 )
  {
    v2 = CDataStream::Read(v1, &v15, 2u);
    if ( v2 >= 0 )
    {
      v2 = CDataStream::Read(v1, &v16, 2u);
      if ( v2 >= 0 )
      {
        v2 = CDataStream::Read(v1, &v17, 0x10u);
        if ( v2 >= 0 )
        {
          v3 = __rev16(v15);
          v15 = v3;
          v4 = __rev16(v16);
          v16 = v4;
          v5 = bswap32(v17) != 554869826;
          *((_BYTE *)v1 + 21) = v5;
          if ( v3 & 0xC000 || v4 & 3 || !*((_BYTE *)v1 + 20) && v5 )
          {
            v2 = -2147467259;
          }
          else
          {
            v6 = v17;
            v8 = v18;
            v9 = v19;
            v7 = v20;
            v10 = v4 >= 0x320u;
            v11 = v4 == 800;
            *((_WORD *)v1 + 458) = v4;
            v12 = (unsigned int *)((char *)v1 + 892);
            *((_WORD *)v1 + 454) = ((v3 & 0x3E00) >> 2) | ((v3 & 0xE0u) >> 1) | v3 & 0xF;
            *v12 = v6;
            v12[1] = v8;
            v12[2] = v9;
            v12[3] = v7;
            if ( !v11 && v10 )
            {
              v2 = -2147418113;
            }
            else
            {
              v13 = v3 & 0x110;
              if ( v3 & 0x110 )
              {
                if ( v13 == 16 )
                {
                  *((_DWORD *)v1 + 228) = 1;
                }
                else if ( v13 == 256 )
                {
                  *((_DWORD *)v1 + 228) = 2;
                }
                else
                {
                  if ( v13 == 272 )
                    v7 = 3;
                  else
                    v2 = -2147467259;
                  if ( v13 == 272 )
                    *((_DWORD *)v1 + 228) = v7;
                  else
                    v7 = 255;
                  if ( v13 != 272 )
                    *((_DWORD *)v1 + 228) = v7;
                }
              }
              else
              {
                *((_DWORD *)v1 + 228) = 0;
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

//----- (00060114) --------------------------------------------------------
signed int __fastcall CStunMessageReader::ReadBody(CStunMessageReader *this)
{
  CStunMessageReader *v1; // r4
  unsigned int v2; // r10
  signed int result; // r0
  unsigned int v4; // r11
  unsigned __int16 v5; // r5
  int v6; // r7
  int v7; // r6
  unsigned int v8; // r1
  int v9; // r12
  int *v10; // r3
  int v11; // r8
  int v12; // ST00_4
  _WORD *v13; // r2
  unsigned int v14; // r3
  unsigned int v15; // r1
  int v16; // r5
  int v17; // r3
  __int16 v18; // [sp+4h] [bp-3Ch]
  int v19; // [sp+8h] [bp-38h]
  unsigned __int16 v20; // [sp+14h] [bp-2Ch]
  int v21; // [sp+16h] [bp-2Ah]

  v1 = this;
  v2 = CDataStream::GetSize(this);
  result = CDataStream::SeekDirect(v1, 0x14u);
  if ( result >= 0 )
  {
    if ( v2 <= 0x14 )
    {
      v4 = 20;
    }
    else
    {
      v4 = 20;
      do
      {
        if ( CDataStream::Read(v1, &v20, 2u) < 0 || CDataStream::Read(v1, &v21, 2u) < 0 )
          break;
        v18 = CDataStream::GetPos(v1);
        v20 = __rev16(v20);
        v5 = __rev16((unsigned __int16)v21);
        LOWORD(v21) = v5;
        v6 = v5 & 3;
        if ( v5 & 3 )
          v6 = 4 - v6;
        if ( v5 > 0x30Cu )
          break;
        v7 = v20;
        v8 = (unsigned int)v20 % *((_DWORD *)v1 + 8);
        v9 = *((_DWORD *)v1 + 12);
        v10 = (int *)*((_DWORD *)v1 + 11);
        v19 = *(_DWORD *)(v9 + 4 * v8);
        if ( !v10 )
          break;
        v11 = *v10;
        v12 = *((unsigned __int8 *)v1 + 56);
        v13 = (_WORD *)(*((_DWORD *)v1 + 9) + 8 * *v10);
        *((_DWORD *)v1 + 11) = v10[1];
        *(_WORD *)(*((_DWORD *)v1 + 9) + 8 * v11) = v7;
        v13[2] = v5;
        v13[1] = v7;
        v13[3] = v18;
        v10[1] = v19;
        *(_DWORD *)(v9 + 4 * v8) = v10;
        v14 = *((_DWORD *)v1 + 16);
        if ( v12 )
        {
          v15 = *((_DWORD *)v1 + 7);
          if ( v14 < v15 )
          {
            v16 = *((_DWORD *)v1 + 13);
            if ( v16 )
            {
              *(_DWORD *)(v16 + 4 * ((v14 + *((_DWORD *)v1 + 15)) % v15)) = v11;
              v14 = *((_DWORD *)v1 + 16);
            }
          }
        }
        *((_DWORD *)v1 + 16) = v14 + 1;
        v17 = *((_DWORD *)v1 + 222);
        if ( v7 == 32808 )
        {
          *((_DWORD *)v1 + 220) = v17;
        }
        else if ( v7 == 8 )
        {
          *((_DWORD *)v1 + 221) = v17;
        }
        *((_DWORD *)v1 + 222) = v17 + 1;
        if ( CDataStream::SeekRelative(v1, (unsigned __int16)v21) < 0 || v6 && CDataStream::SeekRelative(v1, v6) < 0 )
          break;
        v4 += (unsigned __int16)v21 + 4 + v6;
      }
      while ( v2 > v4 );
    }
    result = -2147467259;
    if ( v4 == v2 )
      result = 0;
  }
  return result;
}

//----- (00060304) --------------------------------------------------------
signed int __fastcall CStunMessageReader::AddBytes(CStunMessageReader *this, const unsigned __int8 *a2, unsigned int a3)
{
  signed int v3; // r3
  CStunMessageReader *v4; // r4
  const unsigned __int8 *v5; // r5
  unsigned int v7; // ST04_4
  int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r5
  int v11; // r3
  unsigned int v12; // r3
  signed int v13; // r0

  v3 = *((_DWORD *)this + 6);
  v4 = this;
  v5 = a2;
  if ( v3 != 3 )
  {
    if ( !a3 )
      return v3;
    v7 = a3;
    v8 = CDataStream::GetSize(this);
    CDataStream::SeekDirect(v4, v8);
    if ( CDataStream::Write(v4, v5, v7) >= 0 )
    {
      v9 = CDataStream::GetSize(v4);
      v3 = *((_DWORD *)v4 + 6);
      v10 = v9;
      if ( v3 )
      {
        if ( v3 != 1 )
        {
LABEL_14:
          if ( v3 != 2 )
            return v3;
LABEL_11:
          if ( v10 <= (unsigned int)*((unsigned __int16 *)v4 + 458) + 20 )
            return v3;
          goto LABEL_12;
        }
        v11 = *((unsigned __int16 *)v4 + 458);
      }
      else
      {
        if ( v9 <= 0x13 )
          return v3;
        if ( CStunMessageReader::ReadHeader(v4) < 0 )
        {
LABEL_12:
          v3 = 3;
          *((_DWORD *)v4 + 6) = 3;
          return v3;
        }
        v11 = *((unsigned __int16 *)v4 + 458);
        *((_DWORD *)v4 + 6) = 1;
        if ( !v11 )
        {
          v3 = 2;
          *((_DWORD *)v4 + 6) = 2;
          goto LABEL_11;
        }
      }
      v12 = v11 + 20;
      if ( v10 < v12 )
        return *((_DWORD *)v4 + 6);
      if ( v10 != v12 )
        goto LABEL_12;
      if ( CStunMessageReader::ReadBody(v4) >= 0 )
        v13 = 2;
      else
        v13 = 3;
      v3 = v13;
      *((_DWORD *)v4 + 6) = v13;
      goto LABEL_14;
    }
  }
  return 3;
}

//----- (00060434) --------------------------------------------------------
int __fastcall CStunMessageReader::GetState(CStunMessageReader *this)
{
  return *((_DWORD *)this + 6);
}

//----- (0006043C) --------------------------------------------------------
int __fastcall CStunMessageReader::GetTransactionId(int result, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r12
  int v4; // r1
  int v5; // r2
  int v6; // r3

  v2 = a2;
  if ( a2 )
  {
    v3 = (_DWORD *)(result + 892);
    result = *(_DWORD *)(result + 892);
    v4 = v3[1];
    v5 = v3[2];
    v6 = v3[3];
    *v2 = result;
    v2[1] = v4;
    v2[2] = v5;
    v2[3] = v6;
  }
  return result;
}

//----- (00060468) --------------------------------------------------------
int __fastcall CStunMessageReader::GetMessageClass(CStunMessageReader *this)
{
  return *((_DWORD *)this + 228);
}

//----- (00060470) --------------------------------------------------------
int __fastcall CStunMessageReader::GetMessageType(CStunMessageReader *this)
{
  return *((unsigned __int16 *)this + 454);
}

//----- (0006047C) --------------------------------------------------------
signed int __fastcall CStunMessageReader::GetBuffer(_DWORD *a1, _DWORD *a2)
{
  signed int result; // r0

  if ( a2 )
    result = CDataStream::GetBuffer(a1, a2);
  else
    result = -2147024809;
  return result;
}

//----- (00060494) --------------------------------------------------------
signed int __fastcall CStunMessageReader::ValidateMessageIntegrity(CStunMessageReader *this, unsigned __int8 *a2, unsigned int a3)
{
  CStunMessageReader *v3; // r9
  unsigned __int8 *v4; // r11
  unsigned int v5; // r10
  int v6; // r8
  int v7; // r3
  int v8; // r7
  int *v9; // r3
  int i; // r2
  _WORD *v11; // r4
  int v12; // r3
  int v13; // r8
  signed int v14; // r9
  int v15; // r4
  unsigned int *v16; // r3
  unsigned int v17; // r2
  int v19; // r3
  unsigned int v20; // r10
  int v21; // r7
  unsigned int *v22; // r3
  unsigned int v23; // r2
  int v24; // r4
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int *v27; // r3
  unsigned int v28; // r2
  unsigned __int16 v29; // [sp+6h] [bp-62h]
  char v30; // [sp+8h] [bp-60h]
  _DWORD *v31; // [sp+Ch] [bp-5Ch]
  int v32; // [sp+10h] [bp-58h]
  char v33; // [sp+14h] [bp-54h]
  int v34; // [sp+18h] [bp-50h]
  int s1; // [sp+28h] [bp-40h]
  int v36; // [sp+2Ch] [bp-3Ch]
  int v37; // [sp+30h] [bp-38h]
  int v38; // [sp+34h] [bp-34h]
  int v39; // [sp+38h] [bp-30h]

  v3 = this;
  v4 = a2;
  v5 = a3;
  v6 = *((_DWORD *)this + 222);
  s1 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  CDataStream::CDataStream((int)&v33);
  v7 = *((_DWORD *)v3 + 6);
  v31 = 0;
  v32 = 0;
  if ( v7 != 2 )
    goto LABEL_14;
  if ( !*((_DWORD *)v3 + 222) )
    goto LABEL_14;
  v8 = *((_DWORD *)v3 + 221);
  if ( v8 == -1 )
    goto LABEL_14;
  if ( !v4 || !v5 )
  {
    v14 = -2147024809;
    goto LABEL_15;
  }
  v9 = *(int **)(*((_DWORD *)v3 + 12) + 4 * (8u % *((_DWORD *)v3 + 8)));
  if ( !v9 )
    goto LABEL_14;
  for ( i = *v9; ; i = *v9 )
  {
    v11 = (_WORD *)(*((_DWORD *)v3 + 9) + 8 * i);
    if ( *v11 == 8 )
      break;
    v9 = (int *)v9[1];
    if ( !v9 )
      goto LABEL_14;
  }
  if ( v11[2] != 20 )
    goto LABEL_14;
  v12 = v6 - 1;
  v13 = v6 - 2;
  if ( v12 == v8 )
    goto LABEL_22;
  if ( v8 != v13 || *((_DWORD *)v3 + 220) != v12 )
  {
LABEL_14:
    v14 = -2147467259;
    goto LABEL_15;
  }
  v13 = *((_DWORD *)v3 + 221);
LABEL_22:
  v14 = CStunMessageReader::GetBuffer(v3, &v31);
  if ( v14 >= 0 )
  {
    CDataStream::Attach((int)&v33, (int)&v31, 0);
    v14 = CDataStream::Read((CDataStream *)&v33, &v29, 2u);
    if ( v14 >= 0 )
    {
      v14 = CDataStream::Read((CDataStream *)&v33, &v29, 2u);
      if ( v14 >= 0 )
      {
        if ( v8 == v13 )
          v29 = __rev16(__rev16(v29) - 8);
        v19 = (unsigned __int16)v11[3];
        v20 = (unsigned int)(v19 - 8) >> 2;
        if ( v20 )
        {
          v21 = 0;
          while ( 1 )
          {
            v14 = CDataStream::Read((CDataStream *)&v33, &v30, 4u);
            if ( v14 < 0 )
              break;
            if ( ++v21 == v20 )
            {
              v19 = (unsigned __int16)v11[3];
              goto LABEL_38;
            }
          }
        }
        else
        {
LABEL_38:
          v14 = -2147467259;
          if ( !memcmp(&s1, (const void *)(*v31 + v19), 0x14u) )
            v14 = 0;
        }
      }
    }
  }
  v24 = v32;
  if ( v32 )
  {
    v25 = (unsigned int *)(v32 + 4);
    __dmb(0xFu);
    do
      v26 = __ldrex(v25);
    while ( __strex(v26 - 1, v25) );
    __dmb(0xFu);
    if ( v26 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v24 + 8))(v24);
      v27 = (unsigned int *)(v24 + 8);
      __dmb(0xFu);
      do
        v28 = __ldrex(v27);
      while ( __strex(v28 - 1, v27) );
      __dmb(0xFu);
      if ( v28 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v24 + 12))(v24);
    }
  }
LABEL_15:
  v15 = v34;
  if ( v34 )
  {
    v16 = (unsigned int *)(v34 + 4);
    __dmb(0xFu);
    do
      v17 = __ldrex(v16);
    while ( __strex(v17 - 1, v16) );
    __dmb(0xFu);
    if ( v17 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v15 + 8))(v15);
      v22 = (unsigned int *)(v15 + 8);
      __dmb(0xFu);
      do
        v23 = __ldrex(v22);
      while ( __strex(v23 - 1, v22) );
      __dmb(0xFu);
      if ( v23 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v15 + 12))(v15);
    }
  }
  return v14;
}

//----- (000607E8) --------------------------------------------------------
signed int __fastcall CStunMessageReader::ValidateMessageIntegrityShort(CStunMessageReader *this, const char *a2)
{
  CStunMessageReader *v2; // r5
  unsigned __int8 *v3; // r4
  unsigned int v4; // r0

  v2 = this;
  v3 = (unsigned __int8 *)a2;
  v4 = strlen(a2);
  return CStunMessageReader::ValidateMessageIntegrity(v2, v3, v4);
}

//----- (00060814) --------------------------------------------------------
signed int __fastcall CStunMessageReader::ValidateMessageIntegrityLong(CStunMessageReader *this, const char *s, const char *a3, const char *a4)
{
  const char *v4; // r9
  const char *v5; // r10
  CStunMessageReader *v6; // r8
  const char *v7; // r7
  const char *v8; // r6
  size_t v9; // r5
  size_t v10; // r11
  CDataStream *v11; // r0
  _BYTE *v12; // r5
  _BYTE *v14; // r5
  void *v15; // r0
  char v16; // [sp+0h] [bp-F0h]
  _BYTE v17[3]; // [sp+1h] [bp-EFh]

  v5 = a4;
  v6 = this;
  v7 = s;
  v8 = a3;
  if ( !a4 )
    v4 = a4;
  if ( a4 )
    v4 = (const char *)strlen(a4);
  if ( v7 )
    v9 = strlen(v7);
  else
    v9 = 0;
  if ( v8 )
    v10 = strlen(v8);
  else
    v10 = 0;
  if ( *((_DWORD *)v6 + 6) != 2 )
    return -2147467259;
  v11 = (CDataStream *)CStunMessageReader::GetStream(v6);
  if ( !CDataStream::GetDataPointerUnsafe(v11) )
    return -2147467259;
  if ( v9 )
  {
    v14 = (char *)memcpy(&v16, v7, v9) + v9;
    *v14 = 58;
    v12 = v14 + 1;
    if ( !v10 )
      goto LABEL_15;
LABEL_20:
    v15 = v12;
    v12 += v10;
    memcpy(v15, v8, v10);
    goto LABEL_15;
  }
  v16 = 58;
  v12 = v17;
  if ( v10 )
    goto LABEL_20;
LABEL_15:
  *v12 = 58;
  if ( v4 )
    memcpy(v12 + 1, v5, (size_t)v4);
  return 0;
}

//----- (00060950) --------------------------------------------------------
CStunSocket *__fastcall CStunSocket::CStunSocket(CStunSocket *this)
{
  CStunSocket *v1; // r4
  CStunSocket *result; // r0

  v1 = this;
  *(_DWORD *)this = -1;
  CSocketAddress::CSocketAddress((int)this + 4);
  CSocketAddress::CSocketAddress((int)v1 + 32);
  result = v1;
  *((_DWORD *)v1 + 15) = 0;
  return result;
}

//----- (0006097C) --------------------------------------------------------
int __fastcall CStunSocket::Reset(CStunSocket *this)
{
  CStunSocket *v1; // r8
  int v2; // r3
  _DWORD *v3; // r5
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // r12
  _DWORD *v13; // r12
  int result; // r0
  int v15; // r1
  int v16; // r2
  int v17; // [sp+0h] [bp-38h]
  int v18; // [sp+4h] [bp-34h]
  int v19; // [sp+8h] [bp-30h]
  int v20; // [sp+Ch] [bp-2Ch]
  int v21; // [sp+10h] [bp-28h]
  int v22; // [sp+14h] [bp-24h]
  int v23; // [sp+18h] [bp-20h]
  int v24; // [sp+1Ch] [bp-1Ch]

  v1 = this;
  v2 = _stack_chk_guard;
  *(_DWORD *)this = -1;
  v3 = (_DWORD *)((char *)this + 4);
  v24 = v2;
  CSocketAddress::CSocketAddress((int)&v17, 0, 0);
  v4 = v18;
  v5 = v19;
  v6 = v20;
  *v3 = v17;
  v3[1] = v4;
  v3[2] = v5;
  v3[3] = v6;
  v3 += 4;
  v7 = v22;
  v8 = v23;
  *v3 = v21;
  v3[1] = v7;
  v3[2] = v8;
  CSocketAddress::CSocketAddress((int)&v17, 0, 0);
  v9 = v18;
  v10 = v19;
  v11 = v20;
  v12 = (_DWORD *)((char *)v1 + 32);
  *v12 = v17;
  v12[1] = v9;
  v12[2] = v10;
  v12[3] = v11;
  v13 = (_DWORD *)((char *)v1 + 48);
  result = v21;
  v15 = v22;
  v16 = v23;
  *v13 = v21;
  v13[1] = v15;
  v13[2] = v16;
  *((_DWORD *)v1 + 15) = 0;
  return result;
}

//----- (00060A18) --------------------------------------------------------
int __fastcall CStunSocket::Close(CStunSocket *this)
{
  CStunSocket *v1; // r4
  int v2; // r0

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( v2 != -1 )
  {
    close(v2);
    *(_DWORD *)v1 = -1;
  }
  return CStunSocket::Reset(v1);
}

//----- (00060A44) --------------------------------------------------------
CStunSocket *__fastcall CStunSocket::~CStunSocket(CStunSocket *this)
{
  CStunSocket *v1; // r4

  v1 = this;
  CStunSocket::Close(this);
  return v1;
}

//----- (00060A58) --------------------------------------------------------
bool __fastcall CStunSocket::IsValid(CStunSocket *this)
{
  return *(_DWORD *)this != -1;
}

//----- (00060A68) --------------------------------------------------------
int __fastcall CStunSocket::Detach(CStunSocket *this)
{
  int v1; // r4

  v1 = *(_DWORD *)this;
  CStunSocket::Reset(this);
  return v1;
}

//----- (00060A7C) --------------------------------------------------------
int __fastcall CStunSocket::GetSocketHandle(CStunSocket *this)
{
  return *(_DWORD *)this;
}

//----- (00060A84) --------------------------------------------------------
char *__fastcall CStunSocket::GetLocalAddress(CStunSocket *this)
{
  return (char *)this + 4;
}

//----- (00060A8C) --------------------------------------------------------
char *__fastcall CStunSocket::GetRemoteAddress(CStunSocket *this)
{
  return (char *)this + 32;
}

//----- (00060A94) --------------------------------------------------------
int __fastcall CStunSocket::GetRole(CStunSocket *this)
{
  return *((_DWORD *)this + 15);
}

//----- (00060A9C) --------------------------------------------------------
int __fastcall CStunSocket::SetRole(int result, int a2)
{
  *(_DWORD *)(result + 60) = a2;
  return result;
}

//----- (00060AA4) --------------------------------------------------------
signed int __fastcall CStunSocket::EnablePktInfoImpl(CStunSocket *this, int level, int a3, int optname, bool a5)
{
  int v5; // r4
  bool v6; // zf
  int v7; // r3
  CStunSocket *v8; // r6
  int v9; // r7
  signed int v10; // r0
  _BOOL4 v11; // r2
  int v13; // r0
  _BOOL4 optval; // [sp+Ch] [bp-1Ch]

  v5 = optname;
  v6 = optname == -1;
  if ( optname == -1 )
    v6 = a3 == -1;
  v7 = a3;
  v8 = this;
  v9 = level;
  optval = a5;
  if ( v6 )
    return -2147467259;
  if ( a3 == -1 )
  {
    v10 = 1;
  }
  else
  {
    v7 = setsockopt(*(_DWORD *)this, level, a3, &optval, 4u);
    v10 = (unsigned int)v7 >> 31;
  }
  v11 = v5 != -1;
  if ( !(v10 & v11) )
  {
    if ( v7 >= 0 )
      return 0;
    return *(_DWORD *)_errno(v10, level, v11) | 0x88000000;
  }
  v13 = *(_DWORD *)v8;
  optval = a5;
  v10 = setsockopt(v13, v9, v5, &optval, 4u);
  if ( v10 < 0 )
    return *(_DWORD *)_errno(v10, level, v11) | 0x88000000;
  return 0;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00060B6C) --------------------------------------------------------
signed int __fastcall CStunSocket::EnablePktInfo_IPV4(CStunSocket *this, bool a2)
{
  return CStunSocket::EnablePktInfoImpl(this, 0, 8, -1, a2);
}

//----- (00060B90) --------------------------------------------------------
signed int __fastcall CStunSocket::EnablePktInfo_IPV6(CStunSocket *this, bool a2)
{
  return CStunSocket::EnablePktInfoImpl(this, 41, 49, 50, a2);
}

//----- (00060BB4) --------------------------------------------------------
signed int __fastcall CStunSocket::EnablePktInfoOption(CStunSocket *this, bool a2)
{
  CStunSocket *v2; // r4
  bool v3; // r5
  signed int result; // r0

  v2 = this;
  v3 = a2;
  if ( CSocketAddress::GetFamily((CStunSocket *)((char *)this + 4)) == 2 )
    result = CStunSocket::EnablePktInfo_IPV4(v2, v3);
  else
    result = CStunSocket::EnablePktInfo_IPV6(v2, v3);
  return result;
}

//----- (00060BE8) --------------------------------------------------------
unsigned int __fastcall CStunSocket::SetV6Only(CStunSocket *this, int a2)
{
  unsigned int result; // r0
  int v3; // r1
  int v4; // r2
  int v5; // [sp+Ch] [bp-Ch]

  v5 = 1;
  result = setsockopt(a2, 41, 26, &v5, 4u);
  if ( result )
    result = *(_DWORD *)_errno(result, v3, v4) | 0x88000000;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00060C30) --------------------------------------------------------
unsigned int __fastcall CStunSocket::SetNonBlocking(CStunSocket *this, int a2)
{
  int *v2; // r4
  int v3; // r5
  int v4; // r0
  int v5; // r1
  int v6; // r2
  unsigned int v7; // r2
  unsigned int result; // r0

  v2 = (int *)this;
  v3 = a2;
  v4 = fcntl(*(_DWORD *)this, 3, 0);
  if ( v4 == -1 || (!v3 ? (v7 = v4 & 0xFFFFF7FF) : (v7 = v4 | 0x800), v4 = fcntl(*v2, 4, v7), v4 == -1) )
    result = *(_DWORD *)_errno(v4, v5, v6) | 0x88000000;
  else
    result = 0;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00060C8C) --------------------------------------------------------
int __fastcall CStunSocket::UpdateAddresses(CStunSocket *this)
{
  CStunSocket *v1; // r6
  int result; // r0
  int v3; // r1
  int v4; // r2
  int v5; // r3
  _DWORD *v6; // r12
  _DWORD *v7; // r12
  int v8; // r1
  int v9; // r2
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r12
  _DWORD *v15; // r12
  int v16; // r1
  int v17; // r2
  int v18; // [sp+4h] [bp-A0h]
  char v19; // [sp+8h] [bp-9Ch]
  int v20; // [sp+Ch] [bp-98h]
  int v21; // [sp+10h] [bp-94h]
  int v22; // [sp+14h] [bp-90h]
  int v23; // [sp+18h] [bp-8Ch]
  int v24; // [sp+1Ch] [bp-88h]
  int v25; // [sp+20h] [bp-84h]
  char s; // [sp+24h] [bp-80h]
  int v27; // [sp+A4h] [bp+0h]

  v1 = this;
  memset(&s, 0, 0x80u);
  memset(&v27, 0, 0x80u);
  result = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 != -1 )
  {
    v18 = 128;
    if ( getsockname(result, (struct sockaddr *)&s, (socklen_t *)&v18) != -1 )
    {
      CSocketAddress::CSocketAddress((CSocketAddress *)&v19, (const __kernel_sockaddr_storage *)&s);
      v3 = v20;
      v4 = v21;
      v5 = v22;
      v6 = (_DWORD *)((char *)v1 + 4);
      *v6 = *(_DWORD *)&v19;
      v6[1] = v3;
      v6[2] = v4;
      v6[3] = v5;
      v7 = (_DWORD *)((char *)v1 + 20);
      v8 = v24;
      v9 = v25;
      *v7 = v23;
      v7[1] = v8;
      v7[2] = v9;
    }
    v10 = *(_DWORD *)v1;
    v18 = 128;
    result = getpeername(v10, (struct sockaddr *)&v27, (socklen_t *)&v18);
    if ( result != -1 )
    {
      CSocketAddress::CSocketAddress((CSocketAddress *)&v19, (const __kernel_sockaddr_storage *)&v27);
      v11 = v20;
      v12 = v21;
      v13 = v22;
      v14 = (_DWORD *)((char *)v1 + 32);
      *v14 = *(_DWORD *)&v19;
      v14[1] = v11;
      v14[2] = v12;
      v14[3] = v13;
      v15 = (_DWORD *)((char *)v1 + 48);
      result = v23;
      v16 = v24;
      v17 = v25;
      *v15 = v23;
      v15[1] = v16;
      v15[2] = v17;
    }
  }
  return result;
}

//----- (00060D88) --------------------------------------------------------
signed int __fastcall CStunSocket::Attach(CStunSocket *this, int a2)
{
  int v2; // r4
  CStunSocket *v3; // r5

  v2 = a2;
  v3 = this;
  if ( a2 == -1 )
    return -2147024809;
  if ( *(_DWORD *)this != a2 )
  {
    CStunSocket::Close(this);
    *(_DWORD *)v3 = v2;
  }
  CStunSocket::UpdateAddresses(v3);
  return 0;
}

//----- (00060DCC) --------------------------------------------------------
unsigned int __fastcall CStunSocket::InitCommon(int a1, int a2, CSocketAddress *this, int a4, char a5)
{
  int v5; // r5
  CStunSocket *v6; // r6
  CSocketAddress *v7; // r4
  int v8; // r8
  int v9; // r0
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r5
  int v14; // r0
  int v15; // r1
  int v16; // r2
  const struct sockaddr *v17; // r7
  signed int v18; // r0
  int v19; // r4
  unsigned int v20; // r4
  int v22; // [sp+Ch] [bp-1Ch]

  v5 = a2;
  v6 = (CStunSocket *)a1;
  v7 = this;
  v8 = a4;
  v9 = CSocketAddress::GetFamily(this);
  v10 = socket(v9, v5, 0);
  v13 = v10;
  if ( v10 < 0 )
  {
    v20 = *(_DWORD *)_errno(v10, v11, v12) | 0x88000000;
    if ( v13 == -1 )
      return v20;
  }
  else
  {
    if ( CSocketAddress::GetFamily(v7) == 10 )
      CStunSocket::SetV6Only(v6, v13);
    if ( !a5 || (v22 = 1, v14 = setsockopt(v13, 1, 2, &v22, 4u), v14 != -1) )
    {
      v17 = (const struct sockaddr *)CSocketAddress::GetSockAddr(v7);
      v18 = CSocketAddress::GetSockAddrLength(v7);
      v19 = bind(v13, v17, v18);
      v14 = puts("after bind");
      if ( v19 != -1 )
      {
        CStunSocket::Attach(v6, v13);
        v20 = 0;
        CStunSocket::SetRole((int)v6, v8);
        return v20;
      }
    }
    v20 = *(_DWORD *)_errno(v14, v15, v16) | 0x88000000;
  }
  close(v13);
  return v20;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00060EF4) --------------------------------------------------------
unsigned int __fastcall CStunSocket::UDPInit(int a1, CSocketAddress *a2, int a3)
{
  return CStunSocket::InitCommon(a1, 2, a2, a3, 0);
}

//----- (00060F1C) --------------------------------------------------------
unsigned int __fastcall CStunSocket::TCPInit(int a1, CSocketAddress *a2, int a3, char a4)
{
  return CStunSocket::InitCommon(a1, 1, a2, a3, a4);
}

//----- (00060F44) --------------------------------------------------------
bool __fastcall IsTransactionIdValid(const void *a1)
{
  int s2; // [sp+4h] [bp-1Ch]
  int v3; // [sp+8h] [bp-18h]
  int v4; // [sp+Ch] [bp-14h]
  int v5; // [sp+10h] [bp-10h]

  s2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  return memcmp(a1, &s2, 0x10u) != 0;
}

//----- (00060FA4) --------------------------------------------------------
signed int __fastcall GetMappedAddress(unsigned __int8 *a1, unsigned int a2, CSocketAddress *a3)
{
  unsigned __int8 *v3; // r8
  unsigned int v4; // r5
  CSocketAddress *v5; // r7
  CBuffer *v6; // r6
  _DWORD *v7; // r0
  signed int v10; // r6
  sockaddr_in6 *v11; // r5
  uint32_t v12; // r1
  uint32_t v13; // r2
  uint32_t v14; // r3
  _DWORD *v15; // r7
  uint32_t v16; // r1
  uint32_t v17; // r2
  int v18; // r5
  unsigned int *v19; // r3
  unsigned int v20; // r2
  int v21; // r5
  unsigned int *v22; // r3
  unsigned int v23; // r2
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int *v31; // r3
  unsigned int v32; // r2
  char v33; // [sp+1h] [bp-87h]
  unsigned __int16 v34; // [sp+2h] [bp-86h]
  unsigned int v35; // [sp+4h] [bp-84h]
  CBuffer *v36; // [sp+8h] [bp-80h]
  _DWORD *v37; // [sp+Ch] [bp-7Ch]
  char v38; // [sp+10h] [bp-78h]
  int v39; // [sp+14h] [bp-74h]
  char v40; // [sp+24h] [bp-64h]
  __int64 v41; // [sp+2Ch] [bp-5Ch]
  sockaddr_in6 v42; // [sp+34h] [bp-54h]
  char v43; // [sp+50h] [bp-38h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = (CBuffer *)operator new(0x10u);
  CBuffer::CBuffer(v6, v3, v4, 0);
  v36 = v6;
  v7 = operator new(0x10u);
  v7[1] = 1;
  v7[3] = v6;
  v7[2] = 1;
  *v7 = off_F0228;
  v37 = v7;
  CDataStream::CDataStream(&v38, &v36);
  if ( !v5 )
  {
    v10 = -2147024809;
    goto LABEL_12;
  }
  v10 = CDataStream::SeekDirect((CDataStream *)&v38, 1u);
  if ( v10 >= 0 )
  {
    v10 = CDataStream::Read((CDataStream *)&v38, &v33, 1u);
    if ( v10 >= 0 )
    {
      v10 = CDataStream::Read((CDataStream *)&v38, &v34, 2u);
      if ( v10 >= 0 )
      {
        v34 = __rev16(v34);
        if ( v33 == 1 )
        {
          v10 = CDataStream::Read((CDataStream *)&v38, &v35, 4u);
          if ( v10 < 0 )
            goto LABEL_12;
          v11 = &v42;
          v35 = bswap32(v35);
          CSocketAddress::CSocketAddress((int)&v42, v35, v34);
          goto LABEL_11;
        }
        *(_DWORD *)&v42.sin6_family = 0;
        v42.sin6_flowinfo = 0;
        *(_QWORD *)v42.sin6_addr.in6_u.u6_addr8 = 0LL;
        *(_QWORD *)&v42.sin6_addr.in6_u.u6_addr32[2] = 0LL;
        v42.sin6_scope_id = 0;
        v10 = CDataStream::Read((CDataStream *)&v38, &v40, 0x10u);
        if ( v10 >= 0 )
        {
          v42.sin6_family = 10;
          v11 = (sockaddr_in6 *)&v43;
          v42.sin6_port = __rev16(v34);
          *(_QWORD *)v42.sin6_addr.in6_u.u6_addr8 = *(_QWORD *)&v40;
          *(_QWORD *)&v42.sin6_addr.in6_u.u6_addr32[2] = v41;
          CSocketAddress::CSocketAddress((CSocketAddress *)&v43, &v42);
LABEL_11:
          v12 = v11->sin6_flowinfo;
          v13 = v11->sin6_addr.in6_u.u6_addr32[0];
          v14 = v11->sin6_addr.in6_u.u6_addr32[1];
          *(_DWORD *)v5 = *(_DWORD *)&v11->sin6_family;
          *((_DWORD *)v5 + 1) = v12;
          *((_DWORD *)v5 + 2) = v13;
          *((_DWORD *)v5 + 3) = v14;
          v15 = (_DWORD *)((char *)v5 + 16);
          v16 = v11->sin6_addr.in6_u.u6_addr32[3];
          v17 = v11->sin6_scope_id;
          *v15 = v11->sin6_addr.in6_u.u6_addr32[2];
          v15[1] = v16;
          v15[2] = v17;
          goto LABEL_12;
        }
      }
    }
  }
LABEL_12:
  v18 = v39;
  if ( v39 )
  {
    v19 = (unsigned int *)(v39 + 4);
    __dmb(0xFu);
    do
      v20 = __ldrex(v19);
    while ( __strex(v20 - 1, v19) );
    __dmb(0xFu);
    if ( v20 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 8))(v18);
      v31 = (unsigned int *)(v18 + 8);
      __dmb(0xFu);
      do
        v32 = __ldrex(v31);
      while ( __strex(v32 - 1, v31) );
      __dmb(0xFu);
      if ( v32 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 12))(v18);
    }
  }
  v21 = (int)v37;
  if ( v37 )
  {
    v22 = v37 + 1;
    __dmb(0xFu);
    do
      v23 = __ldrex(v22);
    while ( __strex(v23 - 1, v22) );
    __dmb(0xFu);
    if ( v23 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v21 + 8))(v21);
      v25 = (unsigned int *)(v21 + 8);
      __dmb(0xFu);
      do
        v26 = __ldrex(v25);
      while ( __strex(v26 - 1, v25) );
      __dmb(0xFu);
      if ( v26 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v21 + 12))(v21);
    }
  }
  return v10;
}
// F0228: using guessed type int (*off_F0228[3])();

//----- (00061378) --------------------------------------------------------
signed int __fastcall GetXorMappedAddress(unsigned __int8 *a1, unsigned int a2, _BYTE *a3, CSocketAddress *a4)
{
  _BYTE *v4; // r6
  CSocketAddress *v5; // r4
  signed int v6; // r5

  v4 = a3;
  v5 = a4;
  v6 = GetMappedAddress(a1, a2, a4);
  if ( v6 >= 0 )
    CSocketAddress::ApplyStunXorMap(v5, v4);
  return v6;
}

//----- (000613A8) --------------------------------------------------------
int __fastcall CDataStream::CDataStream(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_BYTE *)(result + 16) = 0;
  return result;
}

//----- (000613C4) --------------------------------------------------------
_DWORD *__fastcall CDataStream::CDataStream(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r3
  int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // r0
  int v6; // r1
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if ( v3 )
  {
    v4 = (unsigned int *)(v3 + 4);
    __dmb(0xFu);
    do
      v5 = __ldrex(v4);
    while ( __strex(v5 + 1, v4) );
    __dmb(0xFu);
  }
  v6 = *a2;
  result = v2;
  v2[3] = 0;
  *((_BYTE *)v2 + 16) = 0;
  v2[2] = v6;
  return result;
}

//----- (00061414) --------------------------------------------------------
int __fastcall CDataStream::Reset(int result)
{
  unsigned int *v1; // r5
  int v2; // r4
  unsigned int *v3; // r3
  unsigned int v4; // r2
  unsigned int *v5; // r3
  unsigned int v6; // r2

  v1 = *(unsigned int **)(result + 4);
  v2 = result;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  if ( v1 )
  {
    v3 = v1 + 1;
    __dmb(0xFu);
    do
    {
      v4 = __ldrex(v3);
      result = v4 - 1;
    }
    while ( __strex(v4 - 1, v3) );
    __dmb(0xFu);
    if ( v4 == 1 )
    {
      (*(void (__fastcall **)(unsigned int *))(*v1 + 8))(v1);
      v5 = v1 + 2;
      __dmb(0xFu);
      do
      {
        v6 = __ldrex(v5);
        result = v6 - 1;
      }
      while ( __strex(v6 - 1, v5) );
      __dmb(0xFu);
      if ( v6 == 1 )
        result = (*(int (__fastcall **)(unsigned int *))(*v1 + 12))(v1);
    }
  }
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_BYTE *)(v2 + 16) = 0;
  return result;
}

//----- (000614BC) --------------------------------------------------------
CBuffer *__fastcall CDataStream::Attach(int a1, int a2, int a3)
{
  int v3; // r5
  CBuffer **v4; // r4
  int v5; // r6
  CBuffer *result; // r0
  unsigned int *v7; // r3
  unsigned int *v8; // r2
  unsigned int v9; // r1
  unsigned int *v10; // r5
  unsigned int *v11; // r3
  unsigned int v12; // r2
  unsigned int *v13; // r3
  unsigned int v14; // r2

  v3 = a2;
  v4 = (CBuffer **)a1;
  v5 = a3;
  CDataStream::Reset(a1);
  result = *(CBuffer **)v3;
  v7 = *(unsigned int **)(v3 + 4);
  if ( v7 )
  {
    v8 = v7 + 1;
    __dmb(0xFu);
    do
      v9 = __ldrex(v8);
    while ( __strex(v9 + 1, v8) );
    __dmb(0xFu);
  }
  v10 = (unsigned int *)v4[1];
  *v4 = result;
  v4[1] = (CBuffer *)v7;
  if ( v10 )
  {
    v11 = v10 + 1;
    __dmb(0xFu);
    do
      v12 = __ldrex(v11);
    while ( __strex(v12 - 1, v11) );
    __dmb(0xFu);
    if ( v12 == 1 )
    {
      (*(void (__fastcall **)(unsigned int *))(*v10 + 8))(v10);
      v13 = v10 + 2;
      __dmb(0xFu);
      do
        v14 = __ldrex(v13);
      while ( __strex(v14 - 1, v13) );
      __dmb(0xFu);
      if ( v14 == 1 )
        (*(void (__fastcall **)(unsigned int *))(*v10 + 12))(v10);
    }
    result = *v4;
  }
  v4[2] = result;
  if ( result )
  {
    if ( v5 )
      result = (CBuffer *)CBuffer::SetSize(result, 0);
  }
  return result;
}

//----- (000615A8) --------------------------------------------------------
int __fastcall CDataStream::SetNoGrow(int result, bool a2)
{
  *(_BYTE *)(result + 16) = a2;
  return result;
}

//----- (000615B0) --------------------------------------------------------
int __fastcall CDataStream::GetPos(CDataStream *this)
{
  return *((_DWORD *)this + 3);
}

//----- (000615B8) --------------------------------------------------------
int __fastcall CDataStream::GetSize(CDataStream *this)
{
  int result; // r0

  result = *((_DWORD *)this + 2);
  if ( result )
    result = *(_DWORD *)(result + 4);
  return result;
}

//----- (000615C8) --------------------------------------------------------
signed int __fastcall CDataStream::Read(CDataStream *this, void *a2, unsigned int a3)
{
  CDataStream *v3; // r4
  unsigned int v4; // r6
  void *v5; // r7
  unsigned int v6; // r5

  v3 = this;
  v4 = a3;
  v5 = a2;
  v6 = a3 + *((_DWORD *)this + 3);
  if ( v6 > CDataStream::GetSize(this) )
    return -2147024809;
  memcpy(v5, (const void *)(**((_DWORD **)v3 + 2) + *((_DWORD *)v3 + 3)), v4);
  *((_DWORD *)v3 + 3) = v6;
  return 0;
}

//----- (00061620) --------------------------------------------------------
bool __fastcall CDataStream::IsEOF(CDataStream *this)
{
  return (unsigned int)CDataStream::GetSize(this) <= *((_DWORD *)this + 3);
}

//----- (00061640) --------------------------------------------------------
signed int __fastcall CDataStream::Grow(CDataStream *this, unsigned int a2)
{
  int v2; // r3
  unsigned int v3; // r5
  CDataStream *v4; // r4
  unsigned int v5; // r6
  int v6; // r8
  unsigned int v7; // r6
  CBuffer *v8; // r0
  CBuffer *v9; // r7
  unsigned int *v10; // r5
  unsigned int *v11; // r6
  signed int v12; // r4
  unsigned int v13; // r3
  const void **v15; // r3
  unsigned int v16; // r0
  unsigned int *v17; // r8
  unsigned int *v18; // r3
  unsigned int v19; // r2
  unsigned int *v20; // r3
  unsigned int v21; // r2
  unsigned int *v22; // r3
  unsigned int v23; // r2

  v2 = *((_DWORD *)this + 2);
  v3 = a2;
  v4 = this;
  if ( v2 )
    v5 = *(_DWORD *)(v2 + 8);
  else
    v5 = 0;
  v6 = CDataStream::GetSize(this);
  if ( v5 >= v3 )
    return 0;
  if ( *((_BYTE *)v4 + 16) )
    return -2147467259;
  v7 = 2 * v5;
  v8 = (CBuffer *)operator new(0x10u);
  if ( v7 >= v3 )
    v3 = v7;
  v9 = v8;
  CBuffer::CBuffer(v8, v3);
  v10 = (unsigned int *)operator new(0x10u);
  v10[3] = (unsigned int)v9;
  v10[1] = 1;
  v10[2] = 1;
  *v10 = (unsigned int)off_F0228;
  if ( CBuffer::IsValid(v9) )
  {
    CBuffer::SetSize(v9, v6);
    v15 = (const void **)*((_DWORD *)v4 + 2);
    if ( v15 && v6 )
      memcpy(*(void **)v9, *v15, v6);
    v11 = v10 + 1;
    __dmb(0xFu);
    do
      v16 = __ldrex(v11);
    while ( __strex(v16 + 1, v11) );
    __dmb(0xFu);
    *(_DWORD *)v4 = v9;
    v17 = (unsigned int *)*((_DWORD *)v4 + 1);
    *((_DWORD *)v4 + 1) = v10;
    if ( v17 )
    {
      v18 = v17 + 1;
      __dmb(0xFu);
      do
        v19 = __ldrex(v18);
      while ( __strex(v19 - 1, v18) );
      __dmb(0xFu);
      if ( v19 == 1 )
      {
        (*(void (__fastcall **)(unsigned int *))(*v17 + 8))(v17);
        v22 = v17 + 2;
        __dmb(0xFu);
        do
          v23 = __ldrex(v22);
        while ( __strex(v23 - 1, v22) );
        __dmb(0xFu);
        if ( v23 == 1 )
          (*(void (__fastcall **)(unsigned int *))(*v17 + 12))(v17);
      }
      v9 = *(CBuffer **)v4;
    }
    *((_DWORD *)v4 + 2) = v9;
    v12 = 0;
  }
  else
  {
    v11 = v10 + 1;
    v12 = -2147024882;
  }
  __dmb(0xFu);
  do
    v13 = __ldrex(v11);
  while ( __strex(v13 - 1, v11) );
  __dmb(0xFu);
  if ( v13 == 1 )
  {
    (*(void (__fastcall **)(unsigned int *))(*v10 + 8))(v10);
    v20 = v10 + 2;
    __dmb(0xFu);
    do
      v21 = __ldrex(v20);
    while ( __strex(v21 - 1, v20) );
    __dmb(0xFu);
    if ( v21 == 1 )
      (*(void (__fastcall **)(unsigned int *))(*v10 + 12))(v10);
  }
  return v12;
}
// F0228: using guessed type int (*off_F0228[3])();

//----- (000618AC) --------------------------------------------------------
signed int __fastcall CDataStream::Write(CDataStream *this, const void *a2, unsigned int a3)
{
  unsigned int v3; // r5
  const void *v4; // r7
  CDataStream *v5; // r4
  unsigned int v6; // r6
  int v7; // r0
  bool v8; // zf
  unsigned int v9; // r9
  signed int v10; // r8
  signed int result; // r0

  v3 = a3;
  v4 = a2;
  v5 = this;
  v6 = a3 + *((_DWORD *)this + 3);
  v7 = CDataStream::GetSize(this);
  v8 = v4 == 0;
  if ( v4 )
    v8 = v3 == 0;
  v9 = v7;
  if ( v8 )
    return -2147467259;
  v10 = CDataStream::Grow(v5, v6);
  if ( v10 >= 0
    && (memcpy((void *)(**((_DWORD **)v5 + 2) + *((_DWORD *)v5 + 3)), v4, v3), *((_DWORD *)v5 + 3) = v6, v6 > v9) )
  {
    result = CBuffer::SetSize(*((CBuffer **)v5 + 2), v6);
  }
  else
  {
    result = v10;
  }
  return result;
}

//----- (00061938) --------------------------------------------------------
signed int __fastcall CDataStream::SeekDirect(CDataStream *this, unsigned int a2)
{
  unsigned int v2; // r3

  v2 = *((_DWORD *)this + 2);
  if ( v2 )
    v2 = *(_DWORD *)(v2 + 4);
  if ( v2 < a2 )
    return -2147467259;
  *((_DWORD *)this + 3) = a2;
  return 0;
}

//----- (0006195C) --------------------------------------------------------
signed int __fastcall CDataStream::SeekRelative(CDataStream *this, int a2)
{
  return CDataStream::SeekDirect(this, a2 + *((_DWORD *)this + 3));
}

//----- (00061968) --------------------------------------------------------
signed int __fastcall CDataStream::GetBuffer(_DWORD *a1, _DWORD *a2)
{
  int v2; // r0
  int v3; // r3
  _DWORD *v4; // t0
  unsigned int *v5; // r2
  unsigned int v6; // r4
  unsigned int *v7; // r4
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int *v11; // r3
  unsigned int v12; // r2

  if ( !a2 )
    return -2147467259;
  v4 = a1;
  v2 = *a1;
  v3 = v4[1];
  if ( v3 )
  {
    v5 = (unsigned int *)(v3 + 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 + 1, v5) );
    __dmb(0xFu);
  }
  v7 = (unsigned int *)a2[1];
  *a2 = v2;
  a2[1] = v3;
  if ( v7 )
  {
    v8 = v7 + 1;
    __dmb(0xFu);
    do
      v9 = __ldrex(v8);
    while ( __strex(v9 - 1, v8) );
    __dmb(0xFu);
    if ( v9 == 1 )
    {
      (*(void (__fastcall **)(unsigned int *))(*v7 + 8))(v7);
      v11 = v7 + 2;
      __dmb(0xFu);
      do
        v12 = __ldrex(v11);
      while ( __strex(v12 - 1, v11) );
      __dmb(0xFu);
      if ( v12 == 1 )
        (*(void (__fastcall **)(unsigned int *))(*v7 + 12))(v7);
    }
  }
  return 0;
}

//----- (00061A3C) --------------------------------------------------------
_DWORD *__fastcall CDataStream::GetDataPointerUnsafe(CDataStream *this)
{
  _DWORD *result; // r0

  result = (_DWORD *)*((_DWORD *)this + 2);
  if ( result )
    result = (_DWORD *)*result;
  return result;
}

//----- (00061A4C) --------------------------------------------------------
CStunMessageBuilder *__fastcall CStunMessageBuilder::CStunMessageBuilder(CStunMessageBuilder *this)
{
  CStunMessageBuilder *v1; // r4
  CStunMessageBuilder *result; // r0

  v1 = this;
  CDataStream::CDataStream((int)this);
  result = v1;
  *((_DWORD *)v1 + 5) = 0;
  *((_DWORD *)v1 + 6) = 0;
  *((_DWORD *)v1 + 7) = 0;
  *((_DWORD *)v1 + 8) = 0;
  *((_BYTE *)v1 + 36) = 0;
  return result;
}

//----- (00061A78) --------------------------------------------------------
int __fastcall CStunMessageBuilder::SetLegacyMode(int result, bool a2)
{
  *(_BYTE *)(result + 36) = a2;
  return result;
}

//----- (00061A80) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddHeader(CDataStream *a1, int a2, char a3)
{
  int v3; // r4
  char v4; // r5
  CDataStream *v5; // r6
  signed int result; // r0
  __int16 v7; // [sp+4h] [bp-14h]
  __int16 v8; // [sp+6h] [bp-12h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  result = CDataStream::SetSizeHint(a1, 0xC8u);
  if ( result >= 0 )
  {
    printf("msgType is %d\n", v3);
    v7 = __rev16(16 * (v4 & 1) | ((v4 & 2) << 7) | v3 & 0xF | 2 * (v3 & 0x70) | 4 * (v3 & 0xF80));
    result = CDataStream::Write(v5, &v7, 2u);
    if ( result >= 0 )
    {
      v8 = 0;
      result = CDataStream::Write(v5, &v8, 2u);
    }
  }
  return result;
}

//----- (00061B24) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddBindingRequestHeader(CStunMessageBuilder *this)
{
  return CStunMessageBuilder::AddHeader(this, 1, 0);
}

//----- (00061B30) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddBindingResponseHeader(CStunMessageBuilder *this, int a2)
{
  char v2; // r2

  if ( a2 )
    v2 = 2;
  else
    v2 = 3;
  return CStunMessageBuilder::AddHeader(this, 1, v2);
}

//----- (00061B44) --------------------------------------------------------
int __fastcall CStunMessageBuilder::AddTransactionId(CDataStream *this, void *a2)
{
  _DWORD *v2; // r4
  int v3; // r2
  int v4; // r1
  _DWORD *v5; // r12
  int v6; // r3

  v2 = a2;
  v3 = *((_DWORD *)a2 + 2);
  v4 = *((_DWORD *)a2 + 1);
  v5 = (_DWORD *)((char *)this + 20);
  v6 = v2[3];
  *v5 = *v2;
  v5[1] = v4;
  v5[2] = v3;
  v5[3] = v6;
  return CDataStream::Write(this, v2, 0x10u);
}

//----- (00061B7C) --------------------------------------------------------
int __fastcall CStunMessageBuilder::AddRandomTransactionId(CDataStream *a1, _DWORD *a2)
{
  CDataStream *v2; // r9
  _DWORD *v3; // r6
  int v4; // r0
  int v5; // r4
  time_t *v6; // r4
  int v7; // r0
  int *v8; // r4
  int v9; // r1
  int v10; // r2
  int v11; // r3
  time_t v13; // r0
  unsigned int v14; // r0
  int seedval; // [sp+0h] [bp-38h]
  int v16; // [sp+4h] [bp-34h]
  int v17; // [sp+8h] [bp-30h]
  int v18; // [sp+Ch] [bp-2Ch]
  int v19; // [sp+10h] [bp-28h]

  v2 = a1;
  v3 = a2;
  seedval = 0;
  v4 = open("/dev/urandom", 0);
  v5 = v4;
  if ( v4 >= 0 )
  {
    read(v4, &seedval, 4u);
    close(v5);
  }
  v6 = (time_t *)seedval;
  if ( seedval )
  {
    v7 = seedval;
  }
  else
  {
    seedval = (unsigned int)v2 ^ getpid();
    v13 = time(v6);
    seedval ^= v13;
    v14 = AtomicIncrement((int *)&unk_F3BE4);
    v7 = v14 ^ seedval;
    seedval = v7;
  }
  v8 = (int *)((char *)&v16 + 3);
  srand48(v7);
  v16 = 1118048801;
  do
  {
    *((_BYTE *)v8 + 1) = lrand48();
    v8 = (int *)((char *)v8 + 1);
  }
  while ( v8 != (int *)((char *)&v18 + 3) );
  if ( v3 )
  {
    v9 = v17;
    v10 = v18;
    v11 = v19;
    *v3 = v16;
  }
  if ( v3 )
    v3[1] = v9;
  if ( v3 )
  {
    v3[2] = v10;
    v3[3] = v11;
  }
  return CStunMessageBuilder::AddTransactionId(v2, &v16);
}

//----- (00061CA0) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddAttributeHeader(CStunMessageBuilder *this, int a2, int a3)
{
  unsigned int v3; // r5
  CDataStream *v4; // r4
  signed int result; // r0
  __int16 v6; // [sp+4h] [bp-14h]
  __int16 v7; // [sp+6h] [bp-12h]

  v3 = a3;
  v4 = this;
  v6 = __rev16(a2);
  result = CDataStream::Write(this, &v6, 2u);
  if ( result >= 0 )
  {
    v7 = __rev16(v3);
    result = CDataStream::Write(v4, &v7, 2u);
  }
  return result;
}

//----- (00061CF4) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddAttribute(CStunMessageBuilder *this, int a2, const void *a3, int a4)
{
  const void *v4; // r7
  CDataStream *v5; // r4
  const void *v6; // r5
  const void *v7; // r6
  signed int result; // r0
  int v9; // [sp+4h] [bp-1Ch]

  v4 = a3;
  v5 = this;
  v9 = 0;
  if ( a3 )
  {
    v6 = (const void *)(a4 & 3);
    if ( a4 & 3 )
      v6 = (const void *)(4 - (_DWORD)v6);
    v7 = (const void *)a4;
  }
  else
  {
    v7 = a3;
    v6 = a3;
  }
  if ( *((_BYTE *)this + 36) )
    a4 = (unsigned __int16)(a4 + (_WORD)v6);
  result = CStunMessageBuilder::AddAttributeHeader(this, a2, a4);
  if ( result >= 0 )
  {
    if ( !v7 || (result = CDataStream::Write(v5, v4, (unsigned int)v7), result >= 0) )
    {
      if ( v6 )
        result = CDataStream::Write(v5, &v9, (unsigned int)v6);
    }
  }
  return result;
}

//----- (00061D9C) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddStringAttribute(CStunMessageBuilder *this, int a2, const char *a3)
{
  const char *v3; // r4
  CStunMessageBuilder *v4; // r5
  int v5; // r6
  int v6; // r3

  v3 = a3;
  v4 = this;
  v5 = a2;
  if ( a3 )
    v6 = (unsigned __int16)strlen(a3);
  else
    v6 = (int)a3;
  return CStunMessageBuilder::AddAttribute(v4, v5, v3, v6);
}

//----- (00061DD8) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddErrorCode(CStunMessageBuilder *this, int a2, const char *a3)
{
  const char *v3; // r8
  CStunMessageBuilder *v4; // r4
  unsigned int v5; // r7
  unsigned int v6; // r6
  unsigned __int16 v7; // r3
  int v8; // r9
  signed int v9; // r5
  char v11; // [sp+0h] [bp-28h]
  char v12; // [sp+1h] [bp-27h]
  __int16 v13; // [sp+2h] [bp-26h]
  int v14; // [sp+4h] [bp-24h]

  v3 = a3;
  v4 = this;
  v5 = a2;
  v14 = 0;
  if ( a3 )
  {
    v6 = strlen(a3);
    v7 = v6 + 4;
    if ( v6 > 0x7F )
      return -2147024809;
  }
  else
  {
    v7 = 4;
    v6 = (unsigned int)a3;
  }
  if ( v5 - 300 > 0x12C )
    return -2147024809;
  v8 = v7 & 3;
  if ( !(v7 & 3) )
  {
    if ( !*((_BYTE *)v4 + 36) )
    {
      v8 = 0;
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  v8 = 4 - v8;
  if ( *((_BYTE *)v4 + 36) )
LABEL_6:
    v7 += v8;
LABEL_7:
  v9 = CStunMessageBuilder::AddAttributeHeader(v4, 9, v7);
  if ( v9 >= 0 )
  {
    v13 = 0;
    v9 = CDataStream::Write(v4, &v13, 2u);
    if ( v9 >= 0 )
    {
      v11 = v5 / 0x64;
      v9 = CDataStream::Write(v4, &v11, 1u);
      if ( v9 >= 0 )
      {
        v12 = v5 % 0x64;
        v9 = CDataStream::Write(v4, &v12, 1u);
        if ( v9 >= 0 )
        {
          if ( v6 )
            CDataStream::Write(v4, v3, v6);
          if ( v8 )
            v9 = CDataStream::Write(v4, &v14, v8);
        }
      }
    }
  }
  return v9;
}

//----- (00061F30) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddUnknownAttributes(CStunMessageBuilder *this, const unsigned __int16 *a2, unsigned int a3)
{
  const unsigned __int16 *v3; // r8
  unsigned int v4; // r4
  CDataStream *v5; // r5
  unsigned int v6; // r7
  unsigned int v7; // r9
  int v8; // r2
  signed int v9; // r6

  v3 = a2;
  v4 = a3;
  v5 = this;
  v6 = (unsigned __int16)(2 * a3);
  if ( !a2 || !a3 )
    return -2147024809;
  if ( *((_BYTE *)this + 36) )
  {
    v7 = a3 & 1;
    if ( a3 & 1 )
    {
      v7 = 1;
      v8 = (unsigned __int16)(v6 + 2);
      goto LABEL_6;
    }
  }
  else
  {
    v7 = *((unsigned __int8 *)this + 36);
  }
  v8 = (unsigned __int16)(2 * a3);
LABEL_6:
  v9 = CStunMessageBuilder::AddAttributeHeader(this, 10, v8);
  if ( v9 >= 0 )
  {
    v9 = CDataStream::Write(v5, v3, v6);
    if ( v9 >= 0 )
    {
      if ( v7 )
        CDataStream::Write(v5, &v3[v4 + 0x7FFFFFFF], 2u);
    }
  }
  return v9;
}

//----- (00061FDC) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddResponsePort(CStunMessageBuilder *this, int a2)
{
  __int16 v3; // [sp+6h] [bp-Ah]

  v3 = __rev16(a2);
  return CStunMessageBuilder::AddAttribute(this, 39, &v3, 2);
}

//----- (00062008) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddPaddingAttribute(CStunMessageBuilder *this, int a2, int a3, unsigned __int16 a4)
{
  unsigned int v4; // r4
  CDataStream *v5; // r6
  signed int result; // r0
  unsigned int v7; // r5

  if ( a2 & 3 )
    a4 = a2 & 0xFFFC;
  v4 = a2;
  if ( a2 & 3 )
    a4 += 4;
  v5 = this;
  if ( a2 & 3 )
    v4 = a4;
  for ( result = CStunMessageBuilder::AddAttributeHeader(this, 38, v4); result >= 0 && v4; v4 = (unsigned __int16)(v4 - v7) )
  {
    if ( v4 >= 0x80 )
      v7 = 128;
    else
      v7 = v4;
    result = CDataStream::Write(v5, &unk_2F83FC, v7);
  }
  return result;
}

//----- (00062088) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddMappedAddressImpl(CStunMessageBuilder *this, int a2, const CSocketAddress *a3)
{
  CStunMessageBuilder *v3; // r5
  CSocketAddress *v4; // r6
  int v5; // r7
  bool v6; // zf
  int v7; // r2
  char v8; // r8
  signed int result; // r0
  __int16 v10; // r9
  signed int v11; // r6
  char v12; // [sp+0h] [bp-38h]
  char v13; // [sp+1h] [bp-37h]
  __int16 v14; // [sp+2h] [bp-36h]
  char v15; // [sp+4h] [bp-34h]

  v3 = this;
  v4 = a3;
  v5 = a2;
  v6 = CSocketAddress::GetFamily(a3) == 2;
  if ( v6 )
    v7 = 8;
  else
    v7 = 20;
  if ( v6 )
    v8 = 1;
  else
    v8 = 2;
  result = CStunMessageBuilder::AddAttributeHeader(v3, v5, v7);
  if ( result >= 0 )
  {
    v10 = CSocketAddress::GetPort_NBO(v4);
    v12 = 0;
    v11 = CSocketAddress::GetIP_NBO(v4, &v15, 0x10u);
    result = CDataStream::Write(v3, &v12, 1u);
    if ( result >= 0 )
    {
      v13 = v8;
      result = CDataStream::Write(v3, &v13, 1u);
      if ( result >= 0 )
      {
        v14 = v10;
        result = CDataStream::Write(v3, &v14, 2u);
        if ( result >= 0 )
          result = CDataStream::Write(v3, &v15, v11);
      }
    }
  }
  return result;
}

//----- (0006218C) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddXorMappedAddress(CStunMessageBuilder *this, const CSocketAddress *a2)
{
  _DWORD *v2; // r12
  const CSocketAddress *v3; // lr
  CStunMessageBuilder *v4; // r6
  int v5; // r0
  _DWORD *v6; // lr
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r7
  int v11; // r8
  _DWORD *v12; // r12
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v17; // [sp+0h] [bp-38h]
  int v18; // [sp+1Ch] [bp-1Ch]

  v3 = a2;
  v4 = this;
  v5 = *(_DWORD *)a2;
  v7 = *((_DWORD *)a2 + 1);
  v8 = *((_DWORD *)v3 + 2);
  v9 = *((_DWORD *)v3 + 3);
  v6 = (_DWORD *)((char *)v3 + 16);
  v10 = 32800;
  v11 = *((unsigned __int8 *)v4 + 36);
  *v2 = v5;
  v2[1] = v7;
  v2[2] = v8;
  v2[3] = v9;
  v12 = v2 + 4;
  v13 = v6[1];
  v14 = v6[2];
  if ( !v11 )
    v10 = 32;
  v15 = _stack_chk_guard;
  *v12 = *v6;
  v12[1] = v13;
  v12[2] = v14;
  v18 = v15;
  CSocketAddress::ApplyStunXorMap(&v17, (_BYTE *)v4 + 20);
  return CStunMessageBuilder::AddMappedAddressImpl(v4, v10, (const CSocketAddress *)&v17);
}

//----- (0006220C) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddMappedAddress(CStunMessageBuilder *this, const CSocketAddress *a2)
{
  return CStunMessageBuilder::AddMappedAddressImpl(this, 1, a2);
}

//----- (00062218) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddResponseOriginAddress(CStunMessageBuilder *this, const CSocketAddress *a2)
{
  const CSocketAddress *v2; // r2
  int v3; // r1

  v2 = a2;
  v3 = 32811;
  if ( *((_BYTE *)this + 36) )
    v3 = 4;
  return CStunMessageBuilder::AddMappedAddressImpl(this, v3, v2);
}

//----- (00062230) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddOtherAddress(CStunMessageBuilder *this, const CSocketAddress *a2)
{
  const CSocketAddress *v2; // r2
  int v3; // r1

  v2 = a2;
  v3 = 32812;
  if ( *((_BYTE *)this + 36) )
    v3 = 5;
  return CStunMessageBuilder::AddMappedAddressImpl(this, v3, v2);
}

//----- (00062248) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddChangeRequest(CStunMessageBuilder *a1, unsigned __int8 *a2)
{
  unsigned int v2; // r3
  unsigned int v4; // [sp+4h] [bp-Ch]

  v2 = *a2;
  if ( *a2 )
    v2 = 4;
  if ( a2[1] )
    v2 |= 2u;
  v4 = bswap32(v2);
  return CStunMessageBuilder::AddAttribute(a1, 3, &v4, 4);
}

//----- (00062288) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddUserName(CStunMessageBuilder *this, const char *a2)
{
  return CStunMessageBuilder::AddStringAttribute(this, 6, a2);
}

//----- (00062294) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddNonce(CStunMessageBuilder *this, const char *a2)
{
  return CStunMessageBuilder::AddStringAttribute(this, 21, a2);
}

//----- (000622A0) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddRealm(CStunMessageBuilder *this, const char *a2)
{
  return CStunMessageBuilder::AddStringAttribute(this, 20, a2);
}

//----- (000622AC) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddMessageIntegrityLongTerm(CStunMessageBuilder *this, const char *a2, const char *a3, const char *a4)
{
  const char *v4; // r7
  const char *v5; // r9
  const char *v6; // r8
  size_t v7; // r0
  int v8; // r11
  const char *v9; // r6
  size_t v10; // r5
  size_t v11; // r10
  void *v12; // r0
  _BYTE *v13; // r0
  int v15; // [sp+0h] [bp-F0h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  if ( a2 )
  {
    v7 = strlen(a2);
    v8 = v7 + 2;
    v9 = (const char *)v7;
  }
  else
  {
    v8 = 2;
    v9 = a2;
  }
  if ( v6 )
    v10 = strlen(v6);
  else
    v10 = 0;
  if ( v4 )
    v11 = strlen(v4);
  else
    v11 = 0;
  if ( v10 + v8 + v11 > 0xC2 )
    return -2147024809;
  v12 = memcpy(&v15, v5, (size_t)v9);
  v9[(_DWORD)v12] = 58;
  v13 = memcpy((void *)&v9[(_DWORD)v12 + 1], v6, v10);
  v13[v10] = 58;
  memcpy(&v13[v10 + 1], v4, v11);
  return 0;
}

//----- (000623AC) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::FixLengthField(CStunMessageBuilder *this)
{
  CDataStream *v1; // r4
  unsigned int v2; // r5
  int v3; // r6
  signed int result; // r0
  __int16 v5; // [sp+6h] [bp-12h]

  v1 = this;
  v2 = CDataStream::GetSize(this);
  v3 = CDataStream::GetPos(v1);
  if ( v2 <= 0x13 )
    return -2147418113;
  result = CDataStream::SeekDirect(v1, 2u);
  if ( result >= 0 )
  {
    v5 = __rev16(v2 - 20);
    result = CDataStream::Write(v1, &v5, 2u);
    if ( result >= 0 )
      result = CDataStream::SeekDirect(v1, v3);
  }
  return result;
}

//----- (0006242C) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddMessageIntegrityImpl(CStunMessageBuilder *this, unsigned __int8 *a2, unsigned int a3)
{
  bool v3; // zf
  CStunMessageBuilder *v4; // r5
  signed int v5; // r6
  int v6; // r5
  unsigned int *v7; // r3
  unsigned int v8; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2
  int v12; // [sp+0h] [bp-30h]
  int v13; // [sp+4h] [bp-2Ch]
  int v14; // [sp+8h] [bp-28h]
  int v15; // [sp+Ch] [bp-24h]
  int v16; // [sp+10h] [bp-20h]
  int v17; // [sp+14h] [bp-1Ch]
  int v18; // [sp+18h] [bp-18h]

  v3 = a3 == 0;
  if ( a3 )
    v3 = a2 == 0;
  v4 = this;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v12 = 0;
  v13 = 0;
  if ( v3 )
    return -2147024809;
  v5 = CStunMessageBuilder::AddAttribute(this, 8, &v14, 20);
  if ( v5 >= 0 )
  {
    v5 = CStunMessageBuilder::FixLengthField(v4);
    if ( v5 >= 0 )
      v5 = CDataStream::GetBuffer(v4, &v12);
  }
  v6 = v13;
  if ( v13 )
  {
    v7 = (unsigned int *)(v13 + 4);
    __dmb(0xFu);
    do
      v8 = __ldrex(v7);
    while ( __strex(v8 - 1, v7) );
    __dmb(0xFu);
    if ( v8 == 1 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v6 + 8))(v6);
      v10 = (unsigned int *)(v6 + 8);
      __dmb(0xFu);
      do
        v11 = __ldrex(v10);
      while ( __strex(v11 - 1, v10) );
      __dmb(0xFu);
      if ( v11 == 1 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v6 + 12))(v6);
    }
  }
  return v5;
}

//----- (000625E0) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::AddMessageIntegrityShortTerm(CStunMessageBuilder *this, const char *a2)
{
  CStunMessageBuilder *v2; // r5
  unsigned __int8 *v3; // r4
  unsigned int v4; // r0

  v2 = this;
  v3 = (unsigned __int8 *)a2;
  v4 = strlen(a2);
  return CStunMessageBuilder::AddMessageIntegrityImpl(v2, v3, v4);
}

//----- (00062608) --------------------------------------------------------
signed int __fastcall CStunMessageBuilder::GetResult(CStunMessageBuilder *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  CStunMessageBuilder *v3; // r4
  signed int result; // r0

  v2 = a2;
  v3 = a1;
  result = CStunMessageBuilder::FixLengthField(a1);
  if ( result >= 0 )
    result = CDataStream::GetBuffer(v3, v2);
  return result;
}

//----- (00062634) --------------------------------------------------------
unsigned int __fastcall AtomicIncrement(int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r3

  __dmb(0xFu);
  do
  {
    v1 = __ldrex((unsigned int *)a1);
    v2 = v1 + 1;
  }
  while ( __strex(v2, (unsigned int *)a1) );
  __dmb(0xFu);
  return v2;
}

//----- (00062658) --------------------------------------------------------
unsigned int __fastcall AtomicDecrement(int *a1)
{
  int *v1; // r3
  unsigned int v2; // r0
  unsigned int result; // r0

  __dmb(0xFu);
  v1 = a1;
  do
  {
    v2 = __ldrex((unsigned int *)v1);
    result = v2 - 1;
  }
  while ( __strex(result, (unsigned int *)v1) );
  __dmb(0xFu);
  return result;
}

//----- (0006267C) --------------------------------------------------------
char *__fastcall sub_6267C(char *s, const char *a2, size_t a3)
{
  const char *v3; // r4
  int v4; // r5
  char *v5; // r7
  signed int v6; // r6
  char *result; // r0
  char *v8; // r3

  v3 = a2;
  v4 = *(unsigned __int8 *)a2;
  v5 = s;
  v6 = a3;
  if ( v4 == 104 )
  {
    if ( a2[1] == 116 && a2[2] == 116 && a2[3] == 112 && a2[4] == 58 && a2[5] == 47 && a2[6] == 47 )
      return strncpy(s, a2, a3);
    result = (char *)strlen(s);
    goto LABEL_3;
  }
  result = (char *)strlen(s);
  v8 = result;
  if ( v4 != 47 )
  {
LABEL_3:
    v8 = result + 1;
    result[(_DWORD)v5] = 47;
  }
  if ( (signed int)v8 > v6 )
    return result;
  s = &v8[(_DWORD)v5];
  a3 = v6 - (_DWORD)v8;
  a2 = v3;
  return strncpy(s, a2, a3);
}

//----- (00062728) --------------------------------------------------------
unsigned int __fastcall parserootdesc(int a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-2Ch]
  int v5; // [sp+10h] [bp-20h]
  int v6; // [sp+14h] [bp-1Ch]
  void *(__fastcall *v7)(_DWORD *, const void *, size_t); // [sp+18h] [bp-18h]
  const char *(__fastcall *v8)(const char *, const void *, int); // [sp+1Ch] [bp-14h]
  _BYTE *(__fastcall *v9)(const char *, const void *, signed int); // [sp+20h] [bp-10h]
  int v10; // [sp+24h] [bp-Ch]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = IGDstartelt;
  v8 = IGDendelt;
  v9 = IGDdata;
  v10 = 0;
  return parsexml((unsigned int)&v4);
}

//----- (00062784) --------------------------------------------------------
void *__fastcall simpleUPnPcommand2(int a1, const char *a2, int a3, unsigned __int8 *a4, _BYTE **a5, signed int *a6, int a7)
{
  int v7; // r7
  int v8; // r9
  int v9; // r2
  unsigned __int8 *v10; // r8
  _BYTE **v11; // r4
  int v12; // r0
  _BYTE *v13; // r12
  char *v14; // r1
  _BYTE *v15; // r1
  char v16; // r2
  _BYTE *v17; // r0
  int v18; // t1
  char *v19; // r0
  _BYTE *v20; // r2
  char v21; // r1
  int v22; // t1
  _BYTE *v23; // r0
  char v24; // r2
  int v25; // t1
  int v27; // r3
  char *v28; // r0
  int v29; // t1
  void *v30; // r4
  const char *v31; // [sp+20h] [bp-9C0h]
  unsigned __int16 v32; // [sp+2Ah] [bp-9B6h]
  char *v33; // [sp+2Ch] [bp-9B4h]
  char s; // [sp+30h] [bp-9B0h]
  char v35; // [sp+B0h] [bp-930h]
  char v36[2044]; // [sp+1B4h] [bp-82Ch]
  int v37; // [sp+9B4h] [bp-2Ch]

  v7 = a1;
  v8 = a3;
  v9 = _stack_chk_guard;
  *a6 = 0;
  v37 = v9;
  v10 = a4;
  v32 = 0;
  v11 = a5;
  v31 = a2;
  snprintf(&s, 0x80u, "%s#%s", v8, a4);
  if ( a5 )
  {
    v12 = snprintf(
            v36,
            0x800u,
            "<?xml version=\"1.0\"?>\r\n"
            "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.o"
            "rg/soap/encoding/\"><s:Body><u:%s xmlns:u=\"%s\">",
            v10,
            v8);
    v13 = *a5;
    v14 = &v36[v12];
    if ( *a5 )
    {
      if ( &v37 <= (int *)v14 + 25 )
        return 0;
      while ( 1 )
      {
        *v14 = 60;
        v15 = v14 + 1;
        v16 = *v13;
        if ( *v13 )
        {
          v17 = v13;
          do
          {
            *v15++ = v16;
            v18 = (unsigned __int8)(v17++)[1];
            v16 = v18;
          }
          while ( v18 );
        }
        v19 = v11[1];
        v20 = v15 + 1;
        *v15 = 62;
        if ( v19 )
        {
          v21 = *v19;
          if ( *v19 )
          {
            do
            {
              *v20++ = v21;
              v22 = (unsigned __int8)(v19++)[1];
              v21 = v22;
            }
            while ( v22 );
          }
        }
        *v20 = 60;
        v23 = v20 + 2;
        v20[1] = 47;
        v24 = *v13;
        if ( *v13 )
        {
          do
          {
            *v23++ = v24;
            v25 = (unsigned __int8)(v13++)[1];
            v24 = v25;
          }
          while ( v25 );
        }
        v13 = v11[2];
        v14 = v23 + 1;
        *v23 = 62;
        if ( !v13 )
          break;
        v11 += 2;
        if ( &v37 <= (int *)(v23 + 101) )
          return 0;
      }
    }
    v27 = *v10;
    *v14 = 60;
    v14[1] = 47;
    v14[2] = 117;
    v28 = v14 + 4;
    v14[3] = 58;
    if ( v27 )
    {
      do
      {
        *v28++ = v27;
        v29 = (v10++)[1];
        LOBYTE(v27) = v29;
      }
      while ( v29 );
    }
    strncpy(v28, "></s:Body></s:Envelope>\r\n", (char *)&v37 - v28);
  }
  else
  {
    snprintf(
      v36,
      0x800u,
      "<?xml version=\"1.0\"?>\r\n"
      "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soa"
      "p/encoding/\"><s:Body><u:%s xmlns:u=\"%s\"></u:%s></s:Body></s:Envelope>\r\n",
      v10,
      v8,
      v10);
  }
  if ( !parseURL(v31, &v35, &v32, &v33, 0) )
    return 0;
  if ( v7 < 0 )
  {
    v7 = connecthostport(&v35, v32, 0);
    if ( v7 < 0 )
      return 0;
  }
  if ( (signed int)soapPostSubmit(v7, v33, (int)&v35, v32, (int)&s, v36, a7) <= 0 )
  {
    close(v7);
    return 0;
  }
  v30 = getHTTPResponse(v7, a6);
  close(v7);
  return v30;
}
// 62784: using guessed type char var_82C[2044];

//----- (00062A7C) --------------------------------------------------------
void *__fastcall simpleUPnPcommand(int a1, const char *a2, int a3, unsigned __int8 *a4, _BYTE **a5, signed int *a6)
{
  return simpleUPnPcommand2(a1, a2, a3, a4, a5, a6, (int)"1.1");
}

//----- (00062AAC) --------------------------------------------------------
const char *__fastcall upnpDiscover(unsigned int a1, const char *a2, const char *a3, int a4, int a5, signed int *a6)
{
  int v6; // r11
  int v7; // r6
  const char *v8; // r5
  const char *v9; // r4
  int v10; // r9
  signed int *v11; // r12
  char **v12; // r8
  const char *v13; // r7
  const char *v14; // t1
  const char *v15; // r0
  int v16; // r0
  socklen_t v17; // r2
  signed int v18; // r3
  char *v19; // r8
  const char *v20; // r3
  int v21; // r0
  int v22; // r4
  const char *v23; // r0
  int v24; // r0
  struct addrinfo *v25; // r6
  signed int v26; // r2
  signed int v27; // ST08_4
  struct addrinfo *v28; // r0
  int v29; // r0
  const char *result; // r0
  int v31; // r0
  int v32; // r5
  int v33; // r4
  int v34; // r9
  char *v35; // r7
  int v36; // r12
  int v37; // r8
  int v38; // r2
  int v39; // r2
  int v40; // r2
  size_t v41; // r6
  const char *v42; // r8
  int v43; // r9
  int v44; // r9
  _DWORD *v45; // r0
  _DWORD *v46; // r5
  int v47; // r2
  char *v48; // r6
  int v49; // r3
  const char *v50; // r11
  int v51; // r0
  struct addrinfo *v52; // r12
  const char *v53; // r0
  int v54; // [sp+Ch] [bp-724h]
  const char *v55; // [sp+14h] [bp-71Ch]
  char *src; // [sp+18h] [bp-718h]
  signed int v57; // [sp+1Ch] [bp-714h]
  unsigned int v58; // [sp+24h] [bp-70Ch]
  char *s2; // [sp+28h] [bp-708h]
  int v60; // [sp+2Ch] [bp-704h]
  unsigned int v61; // [sp+3Ch] [bp-6F4h]
  int n; // [sp+44h] [bp-6ECh]
  int v63; // [sp+4Ch] [bp-6E4h]
  int v64; // [sp+58h] [bp-6D8h]
  int optval; // [sp+5Ch] [bp-6D4h]
  struct addrinfo *pai; // [sp+60h] [bp-6D0h]
  struct addrinfo req; // [sp+64h] [bp-6CCh]
  char s; // [sp+84h] [bp-6ACh]
  __int16 v69; // [sp+86h] [bp-6AAh]
  struct addrinfo *v70; // [sp+88h] [bp-6A8h]
  int v71; // [sp+8Ch] [bp-6A4h]
  int v72; // [sp+90h] [bp-6A0h]
  int v73; // [sp+94h] [bp-69Ch]
  int v74; // [sp+98h] [bp-698h]
  char v75[1532]; // [sp+104h] [bp-62Ch]
  int v76; // [sp+704h] [bp-2Ch]

  v7 = a4;
  v8 = a3;
  v9 = a2;
  v58 = a1;
  v64 = 0;
  optval = 1;
  v10 = a5;
  v11 = (signed int *)&_stack_chk_guard;
  if ( a6 )
    v11 = a6;
  if ( a6 )
    *v11 = -1;
  if ( !a3 )
    v8 = "/var/run/minissdpd.sock";
  v12 = off_EF5EC;
  do
  {
    v14 = v12[1];
    ++v12;
    v13 = v14;
    if ( !v14 )
    {
      v55 = v13;
      goto LABEL_11;
    }
    v15 = (const char *)getDevicesFromMiniSSDPD(v13, v8);
  }
  while ( !v15 );
  v55 = v15;
  if ( !strstr(v13, "rootdevice") )
  {
    if ( a6 )
      *a6 = 0;
    result = v55;
    goto LABEL_50;
  }
LABEL_11:
  if ( a5 )
    v16 = 10;
  else
    v16 = 2;
  v6 = socket(v16, 2, 0);
  if ( v6 < 0 )
  {
    if ( a6 )
      *a6 = -101;
    perror("socket");
    result = 0;
    goto LABEL_50;
  }
  memset(&s, 0, 0x80u);
  if ( a5 )
  {
    *(_WORD *)&s = 10;
    if ( v7 )
      v69 = 27655;
    v71 = 0;
    v72 = 0;
    v73 = 0;
    v74 = 0;
  }
  else
  {
    *(_WORD *)&s = 2;
    if ( v7 )
      v69 = 27655;
  }
  if ( setsockopt(v6, 1, 2, &optval, 4u) < 0 )
  {
    if ( a6 )
      *a6 = -101;
    perror("setsockopt");
    result = 0;
    goto LABEL_50;
  }
  if ( v9 )
  {
    if ( a5 )
    {
      req.ai_flags = if_nametoindex(v9);
      if ( setsockopt(v6, 41, 17, &req, 4u) < 0 )
        perror("setsockopt");
      goto LABEL_23;
    }
    v52 = (struct addrinfo *)inet_addr(v9);
    pai = v52;
    if ( v52 == (struct addrinfo *)-1 )
    {
      req.ai_flags = 0;
      req.ai_family = 0;
      req.ai_socktype = 0;
      req.ai_socktype = if_nametoindex(v9);
      if ( setsockopt(v6, 0, 32, &req, 0xCu) < 0 )
        perror("setsockopt");
    }
    else
    {
      v70 = v52;
      if ( setsockopt(v6, 0, 32, &pai, 4u) < 0 )
        perror("setsockopt");
    }
LABEL_98:
    v17 = 16;
    goto LABEL_24;
  }
  if ( !a5 )
    goto LABEL_98;
LABEL_23:
  v17 = 28;
LABEL_24:
  if ( bind(v6, (const struct sockaddr *)&s, v17) )
  {
    if ( a6 )
      v18 = -101;
    if ( a6 )
      *a6 = v18;
    perror("bind");
    close(v6);
    result = 0;
    goto LABEL_50;
  }
  if ( a6 )
    *a6 = 0;
  v19 = 0;
  v54 = 0;
  v20 = "urn:schemas-upnp-org:device:InternetGatewayDevice:1";
  v57 = 1;
  v61 = v58 / 0x3E8;
  while ( 1 )
  {
    if ( !v19 )
    {
      if ( v10 )
      {
        if ( v57 )
        {
          v21 = snprintf(
                  v75,
                  0x600u,
                  "M-SEARCH * HTTP/1.1\r\nHOST: %s:1900\r\nST: %s\r\nMAN: \"ssdp:discover\"\r\nMX: %u\r\n\r\n",
                  "[FF02::C]",
                  v20,
                  v61);
          req.ai_flags = 0;
          req.ai_family = 0;
          req.ai_protocol = 0;
          req.ai_addrlen = 0;
          req.ai_addr = 0;
          req.ai_canonname = 0;
          req.ai_next = 0;
          req.ai_socktype = 2;
          v22 = v21;
          v23 = "FF02::C";
        }
        else
        {
          v51 = snprintf(
                  v75,
                  0x600u,
                  "M-SEARCH * HTTP/1.1\r\nHOST: %s:1900\r\nST: %s\r\nMAN: \"ssdp:discover\"\r\nMX: %u\r\n\r\n",
                  "[FF05::C]",
                  v20,
                  v61);
          req.ai_flags = 0;
          req.ai_family = 0;
          v22 = v51;
          req.ai_protocol = 0;
          req.ai_addrlen = 0;
          req.ai_addr = 0;
          req.ai_canonname = 0;
          req.ai_next = 0;
          req.ai_socktype = 2;
          v23 = "FF05::C";
        }
      }
      else
      {
        v31 = snprintf(
                v75,
                0x600u,
                "M-SEARCH * HTTP/1.1\r\nHOST: %s:1900\r\nST: %s\r\nMAN: \"ssdp:discover\"\r\nMX: %u\r\n\r\n",
                "239.255.255.250",
                v20,
                v61);
        req.ai_flags = 0;
        req.ai_family = 0;
        req.ai_protocol = 0;
        req.ai_addrlen = 0;
        req.ai_addr = 0;
        req.ai_canonname = 0;
        req.ai_next = 0;
        req.ai_socktype = 2;
        v22 = v31;
        v23 = "239.255.255.250";
      }
      v24 = getaddrinfo(v23, "1900", &req, &pai);
      if ( v24 )
      {
        if ( a6 )
          *a6 = -101;
        v53 = gai_strerror(v24);
        fprintf((FILE *)((char *)&_sF + 168), "getaddrinfo: %s\n", v53);
        goto LABEL_49;
      }
      v25 = pai;
      if ( pai )
      {
        v26 = v22;
        do
        {
          while ( 1 )
          {
            v26 = sendto(v6, v75, v26, 0, (const struct sockaddr *)v25->ai_canonname, v25->ai_addrlen);
            if ( v26 < 0 )
              break;
            v25 = v25->ai_next;
            if ( !v25 )
              goto LABEL_38;
          }
          v27 = v26;
          perror("sendto");
          v25 = v25->ai_next;
          v26 = v27;
        }
        while ( v25 );
LABEL_38:
        v28 = pai;
        v22 = v26;
      }
      else
      {
        v28 = pai;
      }
      freeaddrinfo(v28);
      if ( v22 < 0 )
        goto LABEL_127;
    }
    v29 = receivedata(v6, v75, 0x600u, v58);
    v19 = (char *)v29;
    if ( v29 < 0 )
    {
LABEL_127:
      if ( a6 )
        *a6 = -101;
      goto LABEL_49;
    }
    if ( !v29 )
      break;
    v32 = 0;
    v33 = 0;
    v63 = v10;
    v34 = v29;
    v35 = 0;
    v36 = 0;
    src = 0;
    v37 = 0;
    n = 0;
    v60 = v6;
    do
    {
      while ( 1 )
      {
        v39 = (unsigned __int8)v75[v32];
        if ( v39 == 13 )
        {
LABEL_80:
          if ( v33 )
          {
            v48 = &v75[v33];
            do
            {
              v49 = (unsigned __int8)v48[1];
              ++v33;
              ++v48;
            }
            while ( v49 == 32 );
            v50 = &v75[v36];
            if ( !strncasecmp(&v75[v36], "location", 8u) )
            {
              v37 = v32 - v33;
              v35 = v48;
            }
            else if ( !strncasecmp(v50, "st", 2u) )
            {
              src = v48;
              n = v32 - v33;
            }
          }
          v38 = v32 + 1;
          v33 = 0;
          v36 = v32 + 1;
          goto LABEL_62;
        }
        if ( v39 == 58 )
          break;
        if ( v39 == 10 )
          goto LABEL_80;
        v38 = v32 + 1;
LABEL_62:
        v32 = v38;
        if ( v34 <= v38 )
          goto LABEL_68;
      }
      v40 = v32 + 1;
      if ( !v33 )
        v33 = v32;
      ++v32;
    }
    while ( v34 > v40 );
LABEL_68:
    v41 = v37;
    v6 = v60;
    v19 = (char *)v34;
    v10 = v63;
    if ( src && v35 )
    {
      if ( v55 )
      {
        s2 = v19;
        v42 = v55;
        while ( 1 )
        {
          v43 = *((_DWORD *)v42 + 1);
          if ( !memcmp(*((const void **)v42 + 1), v35, v41) && !*(_BYTE *)(v43 + v41) )
          {
            v44 = *((_DWORD *)v42 + 2);
            if ( !memcmp(*((const void **)v42 + 2), src, n) && !*(_BYTE *)(v44 + n) )
              break;
          }
          v42 = *(const char **)v42;
          if ( !v42 )
          {
            v19 = s2;
            v10 = v63;
            goto LABEL_78;
          }
        }
        v19 = s2;
        v10 = v63;
      }
      else
      {
LABEL_78:
        v45 = malloc(n + v41 + 20);
        v46 = v45;
        if ( !v45 )
          goto LABEL_122;
        *v45 = v55;
        v45[1] = v45 + 4;
        v45[2] = (char *)v45 + v41 + 17;
        memcpy(v45 + 4, v35, v41);
        *((_BYTE *)v46 + v41 + 16) = 0;
        memcpy((char *)v46 + v41 + 17, src, n);
        v47 = v64;
        v55 = (const char *)v46;
        *((_BYTE *)v46 + n + v41 + 17) = 0;
        v46[3] = v47;
      }
    }
LABEL_48:
    v20 = off_EF5F0[++v54];
    if ( !v20 )
      goto LABEL_49;
  }
  if ( !v55 )
  {
    if ( v10 )
    {
      if ( v57 )
      {
        --v54;
        v57 = 0;
      }
      else
      {
        v57 = 1;
      }
    }
    goto LABEL_48;
  }
  if ( a6 )
    *a6 = 0;
LABEL_49:
  while ( 1 )
  {
    close(v6);
    result = v55;
LABEL_50:
    if ( v76 == _stack_chk_guard )
      break;
LABEL_122:
    if ( a6 )
      *a6 = -102;
  }
  return result;
}
// 25850: using guessed type int __fastcall if_nametoindex(_DWORD);
// EF5EC: using guessed type char *[5];
// EF5F0: using guessed type char *off_EF5F0[4];
// 62AAC: using guessed type char var_62C[1532];

//----- (00063420) --------------------------------------------------------
_DWORD *__fastcall freeUPNPDevlist(_DWORD *result)
{
  _DWORD *v1; // r4

  if ( result )
  {
    do
    {
      v1 = (_DWORD *)*result;
      free(result);
      result = v1;
    }
    while ( v1 );
  }
  return result;
}

//----- (00063444) --------------------------------------------------------
char *__fastcall GetUPNPUrls(int a1, int a2, char *a3, char *a4)
{
  int v4; // r11
  int v5; // r4
  size_t v6; // r8
  const char *v7; // r7
  int v8; // r8
  const char *v9; // r6
  size_t v10; // r10
  size_t v11; // r9
  size_t v12; // r8
  char *v13; // r0
  const char *v14; // r1
  const char *v15; // r11
  char *v16; // r0
  char *v17; // ST04_4
  size_t v18; // r0
  size_t v19; // r0
  char *dest; // [sp+4h] [bp-5Ch]
  char *v22; // [sp+8h] [bp-58h]
  char *v23; // [sp+8h] [bp-58h]
  size_t size; // [sp+Ch] [bp-54h]
  char *v25; // [sp+10h] [bp-50h]
  char *v26; // [sp+14h] [bp-4Ch]
  char *s; // [sp+18h] [bp-48h]
  int v28; // [sp+1Ch] [bp-44h]
  char v29; // [sp+24h] [bp-3Ch]

  v4 = a2;
  v22 = a4;
  v5 = a1;
  v28 = a2 + 128;
  s = a3;
  v6 = strlen((const char *)(a2 + 128));
  if ( !v6 )
    v6 = strlen(s);
  if ( v22 && if_indextoname(v22, &v29) )
    v6 += 3 + strlen(&v29);
  v7 = (const char *)(v4 + 1156);
  v25 = (char *)(v4 + 900);
  v26 = (char *)(v4 + 388);
  v8 = v6 + 2;
  v9 = (const char *)(v4 + 1924);
  v10 = v8 + strlen((const char *)(v4 + 1156));
  size = v8 + strlen((const char *)(v4 + 900));
  v11 = v8 + strlen((const char *)(v4 + 388));
  v12 = v8 + strlen((const char *)(v4 + 1924));
  v13 = (char *)malloc(v10);
  *(_DWORD *)(v5 + 4) = v13;
  dest = v13;
  *(_DWORD *)v5 = malloc(size);
  *(_DWORD *)(v5 + 8) = malloc(v11);
  *(_DWORD *)(v5 + 12) = malloc(v12);
  *(_DWORD *)(v5 + 16) = strdup(s);
  if ( *(_BYTE *)(v4 + 128) )
    v14 = (const char *)v28;
  else
    v14 = s;
  strncpy(dest, v14, v10);
  v15 = *(const char **)(v5 + 4);
  v16 = strchr(v15 + 7, 47);
  if ( v16 )
    *v16 = 0;
  if ( v16 )
    v15 = *(const char **)(v5 + 4);
  if ( v22 )
  {
    if ( !memcmp(v15, "http://[fe80:", 0xDu) )
    {
      v23 = strchr(v15, 93);
      if ( v23 )
      {
        v17 = (char *)strlen(&v29);
        v18 = strlen(v23);
        memmove(&v17[(_DWORD)v23 + 3], v23, v18 + 1);
        qmemcpy(v23, "%25", 3);
        v19 = strlen(&v29);
        memcpy(v23 + 3, &v29, v19);
        v15 = *(const char **)(v5 + 4);
      }
    }
  }
  strncpy(*(char **)v5, v15, size);
  strncpy(*(char **)(v5 + 8), *(const char **)(v5 + 4), v11);
  strncpy(*(char **)(v5 + 12), *(const char **)(v5 + 4), v12);
  sub_6267C(*(char **)(v5 + 4), v7, v10);
  sub_6267C(*(char **)v5, v25, size);
  sub_6267C(*(char **)(v5 + 8), v26, v11);
  return sub_6267C(*(char **)(v5 + 12), v9, v12);
}
// 25868: using guessed type int __fastcall if_indextoname(_DWORD, _DWORD);

//----- (000636EC) --------------------------------------------------------
void __fastcall FreeUPNPUrls(void **a1)
{
  void **v1; // r4
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0

  v1 = a1;
  if ( a1 )
  {
    free(*a1);
    v2 = v1[1];
    *v1 = 0;
    free(v2);
    v3 = v1[2];
    v1[1] = 0;
    free(v3);
    v4 = v1[3];
    v1[2] = 0;
    free(v4);
    v1[3] = 0;
    free(v1[4]);
    v1[4] = 0;
  }
}

//----- (0006373C) --------------------------------------------------------
bool __fastcall UPNPIGD_IsConnected(const char **a1, int a2)
{
  char v3; // [sp+8h] [bp-58h]
  char v4; // [sp+Ch] [bp-54h]

  v4 = 0;
  UPNP_GetStatusInfo(*a1, a2 + 1284, &v4, (int)&v3, 0);
  return strcmp("Connected", &v4) == 0;
}

//----- (000637B8) --------------------------------------------------------
signed int __fastcall UPNP_GetValidIGD(signed int result, const char **a2, int a3, char *a4, socklen_t a5)
{
  char *v5; // r8
  const char **v6; // r7
  int v7; // r6
  _DWORD *v8; // r3
  size_t v9; // r5
  signed int *v10; // r0
  signed int *v11; // r4
  signed int v12; // r10
  void *v13; // r0
  char *v14; // r10
  signed int v15; // r8
  _DWORD *v16; // r11
  signed int v17; // r4
  int v18; // r4
  int v19; // r6
  void *v20; // r0
  void *dest; // [sp+10h] [bp-50h]
  void *src; // [sp+14h] [bp-4Ch]
  signed int v23; // [sp+18h] [bp-48h]
  signed int *ptr; // [sp+1Ch] [bp-44h]
  _DWORD *ptra; // [sp+1Ch] [bp-44h]
  char v26; // [sp+24h] [bp-3Ch]

  v5 = a4;
  v6 = a2;
  v23 = result;
  v7 = a3;
  if ( result )
  {
    v8 = (_DWORD *)result;
    v9 = 0;
    do
    {
      v8 = (_DWORD *)*v8;
      ++v9;
    }
    while ( v8 );
    v10 = (signed int *)calloc(v9, 0xCu);
    if ( v10 )
    {
      v11 = v10 + 1;
      ptr = v10;
      v12 = v23;
      do
      {
        v13 = miniwget_getaddr(*(const char **)(v12 + 4), v11, v5, a5, *(_DWORD *)(v12 + 12));
        *(v11 - 1) = (signed int)v13;
        if ( v13 )
        {
          memset((void *)v7, 0, 0xB84u);
          memset(v6, 0, 0x14u);
          parserootdesc(*(v11 - 1), *v11, v7);
          if ( !strcmp((const char *)(v7 + 772), "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1") )
            v11[1] = 1;
        }
        v12 = *(_DWORD *)v12;
        v11 += 3;
      }
      while ( v12 );
      v14 = (char *)ptr;
      v15 = 1;
      dest = (void *)(v7 + 2436);
      src = (void *)(v7 + 1412);
      ptra = ptr + 2;
      while ( 2 )
      {
        v16 = ptra;
        v17 = v23;
        do
        {
          if ( *(v16 - 2) )
          {
            memset((void *)v7, 0, 0xB84u);
            memset(v6, 0, 0x14u);
            parserootdesc(*(v16 - 2), *(v16 - 1), v7);
            if ( *v16 )
            {
              GetUPNPUrls((int)v6, v7, *(char **)(v17 + 4), *(char **)(v17 + 12));
              if ( v15 != 1 || UPNPIGD_IsConnected(v6, v7) && !UPNP_GetExternalIPAddress(*v6, v7 + 1284, &v26) )
                goto LABEL_19;
              FreeUPNPUrls((void **)v6);
              if ( *(_BYTE *)(v7 + 1796) )
              {
                memcpy(dest, (const void *)(v7 + 900), 0x200u);
                memcpy((void *)(v7 + 900), src, 0x200u);
                memcpy(src, dest, 0x200u);
                GetUPNPUrls((int)v6, v7, *(char **)(v17 + 4), *(char **)(v17 + 12));
                if ( UPNPIGD_IsConnected(v6, v7) && !UPNP_GetExternalIPAddress(*v6, v7 + 1284, &v26) )
                  goto LABEL_19;
                FreeUPNPUrls((void **)v6);
              }
            }
            else if ( v15 == 3 )
            {
              GetUPNPUrls((int)v6, v7, *(char **)(v17 + 4), *(char **)(v17 + 12));
              goto LABEL_19;
            }
            memset((void *)v7, 0, 0xB84u);
          }
          v17 = *(_DWORD *)v17;
          v16 += 3;
        }
        while ( v17 );
        if ( ++v15 != 4 )
          continue;
        break;
      }
      v15 = 0;
LABEL_19:
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = *(void **)&v14[v18];
        if ( v20 )
          free(v20);
        ++v19;
        v18 += 12;
      }
      while ( v19 != v9 );
      free(v14);
      result = v15;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}

//----- (00063AF4) --------------------------------------------------------
void *__fastcall UPNP_GetIGDFromUrl(const char *a1, void *a2, void *a3, char *a4, socklen_t a5)
{
  void *v5; // r5
  void *v6; // r7
  char *v7; // r8
  void *result; // r0
  void *v9; // r6
  int v10; // [sp+Ch] [bp-1Ch]

  v5 = a3;
  v6 = a2;
  v10 = 0;
  v7 = (char *)a1;
  result = miniwget_getaddr(a1, &v10, a4, a5, 0);
  v9 = result;
  if ( result )
  {
    memset(v5, 0, 0xB84u);
    memset(v6, 0, 0x14u);
    parserootdesc((int)v9, v10, (int)v5);
    free(v9);
    GetUPNPUrls((int)v6, (int)v5, v7, 0);
    result = &dword_0 + 1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00063B8C) --------------------------------------------------------
void *__fastcall getHTTPResponse(int a1, signed int *a2)
{
  char *v2; // r8
  void *v3; // r0
  int v4; // r4
  int v5; // r9
  int v6; // r11
  int v7; // r10
  int v8; // r6
  signed int v9; // r5
  int v10; // r3
  int v11; // r4
  size_t v12; // r10
  size_t v13; // r2
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // r2
  int v18; // r0
  int v19; // r5
  int v20; // r11
  int v21; // r3
  int v22; // r12
  int v23; // r4
  int v24; // r2
  char *v25; // r10
  bool v26; // zf
  bool v27; // zf
  bool v28; // nf
  unsigned __int8 v29; // vf
  size_t v30; // r9
  int v31; // r0
  signed int v32; // r1
  int v33; // r11
  bool v34; // zf
  int v35; // r11
  int v36; // t1
  bool v37; // zf
  int v38; // r4
  int v39; // r4
  int v40; // r6
  unsigned int v41; // r8
  char *v42; // lr
  int v43; // r3
  int v44; // r12
  int v45; // r2
  unsigned int v46; // r3
  int v47; // r11
  int v48; // r5
  int v49; // r8
  char *v50; // r1
  int v51; // t1
  _BOOL4 v52; // r3
  void *v53; // r1
  char *v55; // r3
  int v56; // r8
  int v57; // r2
  int v58; // t1
  int v59; // r1
  unsigned int v60; // r0
  size_t v61; // r11
  size_t v62; // r1
  char *v63; // r2
  int v64; // r3
  int v65; // t1
  int v66; // r3
  int v67; // r11
  bool v68; // zf
  int v69; // r3
  bool v70; // zf
  char *v71; // r0
  void *v72; // r0
  char *s1; // [sp+Ch] [bp-8A4h]
  char *v74; // [sp+10h] [bp-8A0h]
  char *v75; // [sp+14h] [bp-89Ch]
  size_t size; // [sp+18h] [bp-898h]
  void *ptr; // [sp+1Ch] [bp-894h]
  int v78; // [sp+20h] [bp-890h]
  char *v79; // [sp+24h] [bp-88Ch]
  int v80; // [sp+28h] [bp-888h]
  unsigned int v81; // [sp+2Ch] [bp-884h]
  int v82; // [sp+30h] [bp-880h]
  char *v83; // [sp+34h] [bp-87Ch]
  int v84; // [sp+38h] [bp-878h]
  int v85; // [sp+3Ch] [bp-874h]
  unsigned int v86; // [sp+40h] [bp-870h]
  char *s2; // [sp+44h] [bp-86Ch]
  char *v88; // [sp+48h] [bp-868h]
  char *v89; // [sp+4Ch] [bp-864h]
  void *v90; // [sp+50h] [bp-860h]
  char *v91; // [sp+54h] [bp-85Ch]
  char *v92; // [sp+58h] [bp-858h]
  signed int *v93; // [sp+5Ch] [bp-854h]
  char v94; // [sp+63h] [bp-84Dh]
  char v95; // [sp+64h] [bp-84Ch]
  char v96; // [sp+68h] [bp-848h]
  char src[2044]; // [sp+84h] [bp-82Ch]
  int v98; // [sp+888h] [bp-28h]

  v93 = a2;
  v90 = &_stack_chk_guard;
  v91 = &v96;
  v78 = -1;
  v82 = a1;
  v88 = &v94;
  s2 = "content-length";
  v74 = src;
  size = 2048;
  v86 = 2048;
  v2 = (char *)malloc(0x800u);
  v3 = malloc(0x800u);
  v4 = 0;
  v81 = 0;
  v5 = 0;
  v95 = 0;
  v6 = 0;
  v75 = 0;
  v85 = 0;
  v89 = "transfer-encoding";
  v92 = "chunked";
  ptr = v3;
  do
  {
LABEL_2:
    v7 = receivedata(v82, src, 0x800u, 5000);
    if ( v7 <= 0 )
    {
      v9 = (signed int)v75;
      break;
    }
    if ( v6 )
    {
      v8 = v4;
      v80 = v6;
      if ( v85 )
      {
LABEL_63:
        v84 = v8;
        v39 = 0;
        v83 = v2;
        v40 = (int)v75;
        v41 = v81;
        v79 = &v95;
        while ( 1 )
        {
          if ( !v5 )
          {
            v42 = v79;
            while ( 1 )
            {
              if ( !v41 )
              {
                v43 = *((unsigned __int8 *)&v98 + v39 - 2052);
                if ( v43 == 13 )
                {
                  if ( v7 <= ++v39 )
                  {
LABEL_139:
                    v46 = v41;
LABEL_77:
                    v41 = v46;
                    goto LABEL_78;
                  }
                  v43 = *((unsigned __int8 *)&v98 + v39 - 2052);
                }
                if ( v43 == 10 )
                  ++v39;
              }
              if ( v7 <= v39 )
                goto LABEL_139;
              v44 = ctype_;
              v45 = *((unsigned __int8 *)&v98 + v39 - 2052);
              if ( *(_BYTE *)(ctype_ + v45 + 1) & 0x44 && v41 <= 0x1E )
              {
                v46 = v41;
                v47 = v41 + v7 - v39;
                v48 = (int)&v42[v41 - v39];
                v49 = (int)&v42[v41];
                v50 = &src[v39];
                while ( 1 )
                {
                  ++v46;
                  *(_BYTE *)(v48 + v39) = v45;
                  *(_BYTE *)(v49++ + 1) = 0;
                  ++v39;
                  if ( v46 == v47 )
                    goto LABEL_77;
                  v51 = (unsigned __int8)(v50++)[1];
                  v45 = v51;
                  if ( !(*(_BYTE *)(v44 + v51 + 1) & 0x44) || v46 == 31 )
                  {
                    v41 = v46;
                    break;
                  }
                }
              }
              if ( v45 != 13 )
                break;
LABEL_87:
              if ( v7 <= ++v39 )
                goto LABEL_79;
              if ( *((_BYTE *)&v98 + v39 - 2052) == 10 )
                goto LABEL_89;
            }
            if ( v45 != 10 )
            {
              v63 = &src[v39];
              while ( v7 > ++v39 )
              {
                v65 = (unsigned __int8)(v63++)[1];
                v64 = v65;
                if ( v65 == 13 )
                  goto LABEL_87;
                if ( v64 == 10 )
                  goto LABEL_89;
              }
LABEL_79:
              v75 = (char *)v40;
              v81 = v41;
              v8 = v84;
              v2 = v83;
              goto LABEL_80;
            }
LABEL_89:
            if ( !v41 )
              goto LABEL_154;
            v55 = v88;
            v56 = (int)&v88[v41];
            do
            {
              v58 = (unsigned __int8)(v55++)[1];
              v57 = v58;
              v59 = v58 - 48;
              v60 = (unsigned __int8)(v58 - 48);
              if ( v60 <= 9 )
                v5 = v59 + 16 * v5;
              else
                v57 |= 0x20u;
              if ( v60 > 9 )
                v5 = v57 - 87 + 16 * v5;
            }
            while ( v55 != (char *)v56 );
            v95 = 0;
            ++v39;
            if ( !v5 )
            {
LABEL_154:
              v75 = (char *)v40;
              v9 = v40;
              v2 = v83;
              goto LABEL_84;
            }
            v41 = 0;
          }
          v61 = v7 - v39;
          if ( v7 - v39 >= v5 )
            v61 = v5;
          if ( v61 + v40 > size )
          {
            v62 = v78;
            if ( v78 < (signed int)(v61 + v40) )
              v62 = v61 + v40;
            size = v62;
            ptr = realloc(ptr, v62);
          }
          v5 -= v61;
          memcpy((char *)ptr + v40, &src[v39], v61);
          v39 += v61;
          v40 += v61;
LABEL_78:
          if ( v7 <= v39 )
            goto LABEL_79;
        }
      }
LABEL_5:
      if ( v78 <= 0 )
      {
        v11 = v7;
        v9 = (signed int)&v75[v7];
        v12 = (size_t)&v75[v7];
      }
      else
      {
        v9 = (signed int)&v75[v7];
        v10 = (int)&v75[v7];
        if ( v78 >= (signed int)&v75[v7] )
        {
          v11 = v7;
          if ( size >= v9 )
          {
            v12 = (size_t)&v75[v7];
LABEL_10:
            v13 = v11;
            v4 = v8;
            memcpy(&v75[(_DWORD)ptr], src, v13);
            v6 = v80;
            v75 = (char *)v12;
            goto LABEL_81;
          }
          goto LABEL_145;
        }
        v11 = v78 - (_DWORD)v75;
        v9 = v78;
        v12 = v78;
      }
      if ( size >= v12 )
        goto LABEL_10;
      if ( v78 < v9 )
      {
        size = v12;
        v10 = v12;
LABEL_146:
        v12 = v10;
        ptr = realloc(ptr, size);
        goto LABEL_10;
      }
      v10 = v12;
LABEL_145:
      size = v78;
      goto LABEL_146;
    }
    v8 = v7 + v4;
    if ( v86 < v7 + v4 )
    {
      v71 = (char *)realloc(v2, v7 + v4);
      v86 = v7 + v4;
      v2 = v71;
    }
    memcpy(&v2[v4], src, v7);
    v14 = v8 - 1;
    if ( v8 - 1 <= 0 )
    {
LABEL_18:
      v4 += v7;
      goto LABEL_2;
    }
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v16 = (unsigned __int8)v2[v15];
        if ( v16 == 13 )
          break;
        if ( v16 == 10 )
        {
          v17 = v15 + 1;
          if ( v2[v15 + 1] != 10 )
            goto LABEL_20;
          v18 = v15 + 2;
          v15 += 2;
          if ( v17 + 1 >= v14 )
            goto LABEL_123;
          goto LABEL_23;
        }
LABEL_17:
        if ( ++v15 >= v14 )
          goto LABEL_18;
      }
      v17 = v15 + 1;
      if ( v2[v15 + 1] != 10
        || (v17 = v15 + 2, v15 + 2 >= v8)
        || v2[v17] != 13
        || (v17 = v15 + 3, v15 + 3 >= v8)
        || v2[v17] != 10 )
      {
LABEL_20:
        v15 = v17;
        goto LABEL_17;
      }
      v18 = v15 + 4;
      v15 += 4;
      if ( v17 + 1 >= v14 )
        break;
LABEL_23:
      if ( v18 )
      {
        v80 = v18;
        goto LABEL_25;
      }
    }
LABEL_123:
    v80 = v18;
    if ( !v18 )
    {
      v4 += v7;
      v6 = v80;
      goto LABEL_2;
    }
LABEL_25:
    v19 = v80 - 1;
    if ( v80 - 1 <= 0 )
      goto LABEL_61;
    v20 = 0;
    v79 = (char *)v5;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    while ( 2 )
    {
      v24 = (unsigned __int8)v2[v23];
      v25 = &v2[v23];
      if ( v21 <= v22 && v24 == 58 )
      {
        if ( v19 <= v23 )
        {
          v20 = v23 + 1;
          v21 = v23++;
        }
        else
        {
          v66 = (unsigned __int8)v25[1];
          v67 = v23;
          v68 = v66 == 32;
          if ( v66 != 32 )
            v68 = v66 == 9;
          if ( v68 )
          {
            do
            {
              if ( ++v67 == v19 )
                break;
              v69 = (unsigned __int8)(v25++)[2];
              v70 = v69 == 32;
              if ( v69 != 32 )
                v70 = v69 == 9;
            }
            while ( v70 );
          }
          v20 = v67 + 1;
          v21 = v23;
          v23 = v20;
        }
      }
      else
      {
        v26 = v24 == 13;
        if ( v24 != 13 )
          v26 = v24 == 10;
        if ( v26 )
        {
          v29 = __OFSUB__(v20, v21);
          v27 = v20 == v21;
          v28 = v20 - v21 < 0;
          if ( v20 > v21 )
          {
            v29 = __OFSUB__(v21, v22);
            v27 = v21 == v22;
            v28 = v21 - v22 < 0;
          }
          if ( !((unsigned __int8)(v28 ^ v29) | v27) )
          {
            v30 = v21 - v22;
            s1 = &v2[v22];
            if ( !strncasecmp(&v2[v22], s2, v21 - v22) )
            {
              v78 = atoi(&v2[v20]);
            }
            else if ( !strncasecmp(s1, v89, v30) )
            {
              v31 = strncasecmp(&v2[v20], v92, 7u);
              v32 = v85;
              if ( !v31 )
                v32 = 1;
              v85 = v32;
            }
          }
          if ( v8 <= v23 )
          {
            v21 = v23;
            v22 = v23;
            v20 = 0;
            goto LABEL_107;
          }
          v33 = (unsigned __int8)*v25;
          v34 = v33 == 10;
          if ( v33 != 10 )
            v34 = v33 == 13;
          if ( v34 )
          {
            v20 = 1;
          }
          else
          {
            v21 = v23;
            v22 = v23;
            v20 = 0;
          }
          if ( v34 )
          {
            v22 = v23;
            while ( ++v22 != v8 )
            {
              v36 = (unsigned __int8)(v25++)[1];
              v35 = v36;
              v37 = v36 == 13;
              if ( v36 != 13 )
                v37 = v35 == 10;
              v20 = v37 != 0;
              if ( !v37 )
              {
                v23 = v22 + 1;
                v21 = v22;
                goto LABEL_59;
              }
            }
            v23 = v22 + 1;
            v21 = v22;
            v20 = 0;
          }
          else
          {
            ++v23;
          }
        }
        else
        {
LABEL_107:
          ++v23;
        }
      }
LABEL_59:
      if ( v19 > v23 )
        continue;
      break;
    }
    v5 = (int)v79;
LABEL_61:
    v38 = v8 - v80;
    v7 = v8 - v80;
    memcpy(src, &v2[v80], v8 - v80);
    if ( !v85 )
      goto LABEL_5;
    if ( v38 > 0 )
      goto LABEL_63;
LABEL_80:
    v6 = v80;
    v4 = v8;
    v9 = (signed int)v75;
LABEL_81:
    v52 = v78 <= v9;
    if ( v78 <= 0 )
      v52 = 0;
  }
  while ( !v52 );
LABEL_84:
  free(v2);
  v53 = v75;
  v26 = v75 == 0;
  *v93 = v9;
  if ( v26 )
  {
    v72 = ptr;
    ptr = v53;
    free(v72);
  }
  return ptr;
}
// 63B8C: using guessed type char src[2044];

//----- (00064314) --------------------------------------------------------
void *__fastcall sub_64314(int a1, socklen_t hostlen, int a3, signed int *a4, char *a5, socklen_t hostlena, int a7)
{
  signed int *v7; // r8
  int v8; // r11
  int v9; // r10
  int v10; // r3
  int v11; // r0
  int v12; // r5
  int v13; // r0
  int v14; // r9
  int v15; // r7
  ssize_t v16; // r0
  void *result; // r0
  void *v18; // r7
  const char *v19; // r0
  socklen_t v20; // [sp+14h] [bp-834h]
  socklen_t len; // [sp+18h] [bp-830h]
  struct sockaddr addr; // [sp+1Ch] [bp-82Ch]
  int v23; // [sp+81Ch] [bp-2Ch]

  v7 = a4;
  v8 = a3;
  v9 = a1;
  v10 = _stack_chk_guard;
  *v7 = 0;
  v20 = hostlen;
  v23 = v10;
  v11 = connecthostport((const char *)a1, hostlen, a7);
  v12 = v11;
  if ( v11 < 0 )
    return 0;
  if ( a5 )
  {
    len = 128;
    if ( getsockname(v11, &addr, &len) < 0 )
    {
      perror("getsockname");
    }
    else
    {
      v13 = getnameinfo(&addr, len, a5, hostlena, 0, 0, 0xAu);
      if ( v13 )
      {
        v19 = gai_strerror(v13);
        fprintf((FILE *)((char *)&_sF + 168), "getnameinfo() failed : %s\n", v19);
      }
    }
  }
  v14 = snprintf(
          (char *)&addr,
          0x800u,
          "GET %s HTTP/%s\r\nHost: %s:%d\r\nConnection: Close\r\n\r\n",
          v8,
          "1.1",
          v9,
          v20);
  if ( v14 <= 0 )
  {
LABEL_13:
    v18 = getHTTPResponse(v12, v7);
    close(v12);
    result = v18;
  }
  else
  {
    v15 = 0;
    while ( 1 )
    {
      v16 = send(v12, (char *)&addr + v15, v14 - v15, 0);
      if ( v16 < 0 )
        break;
      v15 += v16;
      if ( v14 <= v15 )
        goto LABEL_13;
    }
    perror("send");
    close(v12);
    result = 0;
  }
  return result;
}

//----- (000644CC) --------------------------------------------------------
signed int __fastcall parseURL(const char *a1, void *a2, _WORD *a3, char **a4, char *a5)
{
  char *v5; // r10
  char *v6; // r5
  void *v7; // r7
  _WORD *v8; // r6
  char **v9; // r8
  char *v10; // r9
  signed int result; // r0
  const char *v12; // r11
  const char *v13; // r0
  char *v14; // r0
  size_t v15; // r2
  size_t v16; // r2
  char *v17; // r2
  __int16 v18; // r3
  __int16 v19; // t1
  char *v20; // r0
  char v21; // r5
  bool v22; // zf
  bool v23; // cf
  _BYTE *v24; // r1
  size_t v25; // r12
  char *v26; // ST04_4
  char *v27; // r0
  int v28; // r0
  char *v29; // r0
  int v30; // r5
  signed int v31; // r2
  __int16 v32; // r3
  char *v33; // r2
  __int16 v34; // r3
  __int16 v35; // t1
  char *nptr; // [sp+4h] [bp-44h]
  char *nptra; // [sp+4h] [bp-44h]
  char dest; // [sp+Ch] [bp-3Ch]
  int v39; // [sp+1Ch] [bp-2Ch]
  char v40[40]; // [sp+20h] [bp-28h]

  v6 = (char *)a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  if ( !a1 )
    goto LABEL_58;
  v5 = strstr(a1, "://");
  if ( !v5 || *v6 != 104 || v6[1] != 116 || v6[2] != 116 || v6[3] != 112 )
    goto LABEL_58;
  v12 = v5 + 3;
  memset(v7, 0, 0x101u);
  v13 = v5 + 3;
  if ( v5[3] == 91 )
  {
    nptr = strchr(v13, 37);
    v20 = strchr(v5 + 3, 93);
    v21 = (char)v20;
    v5 = v20;
    if ( v20 )
      v21 = 1;
    v22 = nptr == 0;
    if ( nptr )
      v22 = v20 == 0;
    if ( !v22 )
    {
      v23 = 1;
      if ( a5 )
        v23 = nptr >= v20;
      if ( !v23 )
      {
        v24 = nptr + 1;
        if ( nptr[1] == 50 && nptr[2] == 53 )
          v24 = nptr + 3;
        v25 = v20 - v24;
        if ( v20 - v24 >= 15 )
          v25 = 15;
        v26 = (char *)v25;
        v27 = (char *)memcpy(&dest, v24, v25);
        v40[(_DWORD)v26 - 20] = 0;
        nptra = v27;
        v28 = if_nametoindex(v27);
        *(_DWORD *)a5 = v28;
        if ( !v28 )
          *(_DWORD *)a5 = strtoul(nptra, 0, 10);
      }
    }
    v29 = strchr(v12, 47);
    if ( v29 )
      v30 = v21 & 1;
    else
      v30 = 0;
    v10 = v29;
    if ( v30 )
    {
      v6 = v5 + 1;
      v31 = v5 + 1 - v12;
      if ( v31 >= 256 )
        v31 = 256;
      strncpy((char *)v7, v12, v31);
      if ( v5[1] == 58 )
        goto LABEL_52;
      *v8 = 80;
      goto LABEL_51;
    }
    v6 = v29;
  }
  else
  {
    v6 = strchr(v13, 47);
  }
  v14 = strchr(v12, 58);
  v10 = v14;
  if ( v6 )
  {
    v5 = (char *)(v14 == 0);
    if ( v14 > v6 )
      v5 = (_BYTE *)(&dword_0 + 1);
    if ( v5 )
    {
      v15 = v6 - v12;
      if ( v6 - v12 >= 256 )
        v15 = 256;
      strncpy((char *)v7, v12, v15);
      *v8 = 80;
    }
    else
    {
      v16 = v14 - v12;
      if ( v14 - v12 >= 256 )
        v16 = 256;
      strncpy((char *)v7, v12, v16);
      *v8 = 0;
      if ( (unsigned int)(unsigned __int8)v10[1] - 48 <= 9 )
      {
        v17 = v10;
        v18 = 0;
        do
        {
          *v8 = 10 * v18;
          v19 = (unsigned __int8)(v17++)[1];
          v18 = v19 + 10 * v18 - 48;
          *v8 = v18;
        }
        while ( (unsigned int)(unsigned __int8)v17[1] - 48 <= 9 );
      }
    }
    result = 1;
    *v9 = v6;
  }
  else
  {
LABEL_58:
    result = 0;
  }
  while ( v39 != _stack_chk_guard )
  {
LABEL_52:
    v32 = 0;
    *v8 = 0;
    if ( (unsigned int)(unsigned __int8)v5[2] - 48 <= 9 )
    {
      v33 = v6;
      do
      {
        v34 = 10 * v32;
        *v8 = v34;
        v35 = (unsigned __int8)(v33++)[1];
        v32 = v35 + v34 - 48;
        *v8 = v32;
      }
      while ( (unsigned int)(unsigned __int8)v33[1] - 48 <= 9 );
    }
LABEL_51:
    *v9 = v10;
    result = 1;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 25850: using guessed type int __fastcall if_nametoindex(_DWORD);
// 644CC: using guessed type char var_28[40];

//----- (000647DC) --------------------------------------------------------
void *__fastcall miniwget(const char *a1, signed int *a2, int a3)
{
  signed int *v3; // r6
  int v4; // r12
  void *result; // r0
  int v6; // [sp+14h] [bp-Ch]
  unsigned __int16 v7; // [sp+1Ah] [bp-6h]
  int v8; // [sp+1Ch] [bp-4h]
  int v9; // [sp+20h] [bp+0h]
  int v10; // [sp+124h] [bp+104h]

  v3 = a2;
  v6 = a3;
  v4 = _stack_chk_guard;
  *a2 = 0;
  v10 = v4;
  result = (void *)parseURL(a1, &v9, &v7, (char **)&v8, (char *)&v6);
  if ( result )
    result = sub_64314((int)&v9, v7, v8, v3, 0, 0, v6);
  return result;
}

//----- (00064874) --------------------------------------------------------
void *__fastcall miniwget_getaddr(const char *a1, signed int *a2, char *a3, socklen_t a4, int a5)
{
  socklen_t v5; // r8
  char *v6; // r7
  signed int *v7; // r5
  int v8; // r3
  void *result; // r0
  unsigned __int16 v10; // [sp+12h] [bp-126h]
  int v11; // [sp+14h] [bp-124h]
  char v12; // [sp+18h] [bp-120h]
  int v13; // [sp+11Ch] [bp-1Ch]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = _stack_chk_guard;
  *a2 = 0;
  if ( a3 )
    *a3 = 0;
  v13 = v8;
  result = (void *)parseURL(a1, &v12, &v10, (char **)&v11, (char *)&a5);
  if ( result )
    result = sub_64314((int)&v12, v10, v11, v7, v6, v5, a5);
  return result;
}

//----- (00064910) --------------------------------------------------------
unsigned int __fastcall parsexml(unsigned int result)
{
  char *v1; // r12
  _DWORD *v2; // r4
  unsigned int v3; // r5
  unsigned int v4; // r8
  char *v5; // r1
  int v6; // r3
  int v7; // r2
  bool v8; // zf
  int (__fastcall *v9)(_DWORD); // r3
  unsigned int v10; // r3
  bool v11; // zf
  unsigned int v12; // r2
  bool v13; // cf
  bool v14; // zf
  unsigned __int8 *v15; // r3
  bool v16; // cf
  bool v17; // zf
  unsigned __int8 *v18; // r1
  unsigned int v19; // t1
  unsigned int v20; // r8
  unsigned __int8 *v21; // r3
  unsigned int v22; // r8
  bool v23; // cf
  bool v24; // zf
  int v25; // r8
  bool v26; // zf
  signed int v27; // r9
  signed int v28; // r1
  unsigned __int8 *v29; // r9
  int v30; // t1
  int (__fastcall *v31)(_DWORD, char *); // r5
  int v32; // r10
  bool v33; // zf
  unsigned int v34; // r8
  int v35; // r10
  bool v36; // cf
  bool v37; // zf
  int v38; // r3
  int v39; // r2
  void (__fastcall *v40)(_DWORD); // r3
  unsigned int v41; // r10
  unsigned __int8 *v42; // r3
  int v43; // r9
  char *v44; // r11
  unsigned int v45; // r8
  unsigned int v46; // t1
  unsigned int v47; // r2
  bool v48; // cf
  bool v49; // zf
  char *v50; // r3
  unsigned int v51; // r11
  int v52; // r9
  unsigned int v53; // t1
  int (__fastcall *v54)(_DWORD, unsigned int); // r3
  int v55; // r9
  char *v56; // r8
  int (__fastcall *v57)(_DWORD, char *, char *); // r3

  v1 = *(char **)result;
  v2 = (_DWORD *)result;
  v3 = *(_DWORD *)result + *(_DWORD *)(result + 12);
  v4 = v3 - 1;
  *(_DWORD *)(result + 4) = v3;
  *(_DWORD *)(result + 8) = v1;
LABEL_2:
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (unsigned int)v1 >= v4 )
        return result;
      while ( *v1 != 60 || v1[1] == 63 )
      {
        v2[2] = ++v1;
        if ( (unsigned int)v1 >= v4 )
          return result;
      }
      v5 = v1 + 1;
      v2[2] = v1 + 1;
LABEL_8:
      v6 = (unsigned __int8)*v5;
      v1 = v5;
      v7 = 0;
      while ( 1 )
      {
        v8 = v6 == 9;
        if ( v6 != 9 )
          v8 = v6 == 32;
        result = (unsigned int)(v1 + 1);
        if ( v8 )
        {
          if ( v7 )
            goto LABEL_21;
          if ( v6 != 47 )
            goto LABEL_2;
LABEL_83:
          v2[2] = v1 + 1;
          if ( (unsigned int)(v1 + 1) >= v3 )
            return result;
          v38 = (int)(v1 + 1);
          v39 = 0;
          while ( 1 )
          {
            result = v38++;
            if ( *(_BYTE *)result == 62 )
              break;
            ++v39;
            v2[2] = v38;
            if ( v38 == v3 )
              return result;
          }
          v40 = (void (__fastcall *)(_DWORD))v2[6];
          if ( v40 )
          {
            v40(v2[4]);
            v3 = v2[1];
            result = v2[2];
            v4 = v3 - 1;
          }
          v1 = (char *)(result + 1);
          v2[2] = result + 1;
          goto LABEL_2;
        }
        if ( v6 == 13 || v6 == 10 || v6 == 62 )
          break;
        if ( v6 == 47 )
        {
          if ( v7 )
            goto LABEL_21;
          goto LABEL_83;
        }
        ++v7;
        v2[2] = result;
        if ( result >= v3 )
          return result;
        v6 = (unsigned __int8)v5[v7];
        if ( v6 == 58 )
        {
          v5 = v1 + 2;
          v2[2] = v1 + 2;
          goto LABEL_8;
        }
        ++v1;
      }
      if ( !v7 )
        continue;
      break;
    }
LABEL_21:
    v9 = (int (__fastcall *)(_DWORD))v2[5];
    if ( v9 )
    {
      result = v9(v2[4]);
      v3 = v2[1];
      v1 = (char *)v2[2];
    }
    if ( v3 > (unsigned int)v1 )
    {
      v10 = (unsigned __int8)*v1;
      v11 = v10 == 62;
      if ( v10 != 62 )
        v11 = v10 == 47;
      if ( v11 )
      {
        v32 = (int)v1;
LABEL_94:
        if ( v10 == 47 )
        {
          v3 = v2[1];
          v1 = (char *)v32;
          v4 = v3 - 1;
          continue;
        }
        v41 = v32 + 1;
        v2[2] = v41;
        if ( v41 >= v3 )
          return result;
        v42 = (unsigned __int8 *)v41;
        v43 = 0;
        while ( 1 )
        {
          v44 = (char *)v42;
          v46 = *v42++;
          v45 = v46;
          v47 = v46 - 9;
          v48 = v46 >= 0x20;
          v49 = v46 == 32;
          if ( v46 != 32 )
          {
            v48 = v47 >= 1;
            v49 = v47 == 1;
          }
          if ( !v49 && v48 && v45 != 13 )
            break;
          ++v43;
          v2[2] = v42;
          if ( v42 == (unsigned __int8 *)v3 )
            return result;
        }
        result = memcmp(v44, "<![CDATA[", 9u);
        if ( result )
        {
          v50 = v44;
          v51 = (unsigned int)(v44 + 1);
          v52 = v43 - (_DWORD)v50;
          while ( 1 )
          {
            v1 = v50;
            if ( v45 == 60 )
              break;
            v2[2] = v51++;
            if ( v3 <= v51 )
              return result;
            v53 = (unsigned __int8)(v50++)[1];
            v45 = v53;
          }
          if ( &v50[v52] )
          {
            v54 = (int (__fastcall *)(_DWORD, unsigned int))v2[7];
            if ( v54 )
            {
              if ( v1[1] == 47 )
              {
                result = v54(v2[4], v41);
                v3 = v2[1];
                v1 = (char *)v2[2];
                v4 = v3 - 1;
                continue;
              }
            }
          }
          v3 = v2[1];
        }
        else
        {
          v2[2] = v44 + 9;
          v55 = -9 - (_DWORD)v44;
          v56 = v44 + 9;
          while ( 1 )
          {
            result = memcmp(v56, "]]>", 3u);
            if ( !result )
              break;
            v2[2] = ++v56;
            if ( v3 <= (unsigned int)(v56 + 3) )
              return result;
          }
          if ( &v56[v55] )
          {
            v57 = (int (__fastcall *)(_DWORD, char *, char *))v2[7];
            if ( v57 )
            {
              result = v57(v2[4], v44 + 9, &v56[v55]);
              v56 = (char *)v2[2];
            }
          }
          v3 = v2[1];
          while ( 1 )
          {
            v1 = v56++;
            if ( *v1 == 60 )
              break;
            v2[2] = v56;
            if ( (unsigned int)v56 >= v3 )
              return result;
          }
        }
        v4 = v3 - 1;
        continue;
      }
      while ( 1 )
      {
        v12 = v10 - 9;
        v13 = v10 >= 0x20;
        v14 = v10 == 32;
        if ( v10 != 32 )
        {
          v13 = v12 >= 1;
          v14 = v12 == 1;
        }
        if ( !v14 && v13 && v10 != 13 )
        {
          v15 = (unsigned __int8 *)v1;
          while ( 1 )
          {
            v18 = v15;
            v19 = *v15++;
            result = v19;
            v20 = v19 - 9;
            if ( v19 == 61 )
              break;
            v16 = result >= 0x20;
            v17 = result == 32;
            if ( result != 32 )
            {
              v16 = v20 >= 1;
              v17 = v20 == 1;
            }
            if ( v17 || !v16 || result == 13 )
              break;
            v2[2] = v15;
            if ( (unsigned int)v15 >= v3 )
              return result;
          }
          while ( 1 )
          {
            v2[2] = ++v18;
            if ( *(v18 - 1) == 61 )
              break;
            if ( (unsigned int)v18 >= v3 )
              return result;
          }
          while ( 1 )
          {
            v21 = v18++;
            result = *v21;
            v22 = result - 9;
            v23 = result >= 0x20;
            v24 = result == 32;
            if ( result != 32 )
            {
              v23 = v22 >= 1;
              v24 = v22 == 1;
            }
            if ( !v24 && v23 )
            {
              v25 = 0;
              if ( result != 13 )
                break;
            }
            v2[2] = v18;
            if ( (unsigned int)v18 >= v3 )
              return result;
          }
          v26 = result == 39;
          if ( result != 39 )
            v26 = result == 34;
          v27 = v26 != 0;
          if ( v26 )
          {
            v2[2] = v18;
            if ( (unsigned int)v18 >= v3 )
              return result;
            while ( 1 )
            {
              v30 = *v18++;
              if ( result == v30 )
                break;
              ++v25;
              v2[2] = v18;
              if ( v18 == (unsigned __int8 *)v3 )
                return result;
            }
          }
          else
          {
            v28 = v27;
            v29 = v21;
            while ( 1 )
            {
              v34 = result - 9;
              v35 = (int)&v21[v28];
              v36 = result >= 0x20;
              v37 = result == 32;
              if ( result != 32 )
              {
                v36 = v34 >= 1;
                v37 = v34 == 1;
              }
              ++v29;
              ++v28;
              if ( v37 || !v36 || result == 13 || result == 62 || result == 47 )
                break;
              v2[2] = v29;
              if ( (unsigned int)v29 >= v3 )
                return result;
              result = *(unsigned __int8 *)(v35 + 1);
            }
          }
          v31 = (int (__fastcall *)(_DWORD, char *))v2[8];
          if ( v31 )
            result = v31(v2[4], v1);
          v1 = (char *)v2[2];
        }
        v3 = v2[1];
        v32 = (int)(v1 + 1);
        v2[2] = v1 + 1;
        if ( v3 <= (unsigned int)(v1 + 1) )
          break;
        v10 = (unsigned __int8)v1[1];
        v33 = v10 == 47;
        if ( v10 != 47 )
          v33 = v10 == 62;
        if ( v33 )
          goto LABEL_94;
        ++v1;
      }
    }
    return result;
  }
}

//----- (00064DF0) --------------------------------------------------------
int __fastcall receivedata(int a1, void *a2, size_t a3, int a4)
{
  int v4; // r4
  void *v5; // r8
  size_t v6; // r9
  int v7; // r6
  int result; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r4
  int v12; // [sp+0h] [bp-28h]
  __int16 v13; // [sp+4h] [bp-24h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  while ( 1 )
  {
    v12 = v4;
    v13 = 1;
    result = poll((struct pollfd *)&v12, 1u, v7);
    if ( result >= 0 )
      break;
    if ( *(_DWORD *)_errno(result, v9, v10) != 4 )
    {
      perror("poll");
      return -1;
    }
  }
  if ( result )
  {
    result = recv(v4, v5, v6, 0);
    v11 = result;
    if ( result < 0 )
    {
      perror("recv");
      result = v11;
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00064EA0) --------------------------------------------------------
signed int __fastcall UPNP_GetTotalBytesSent(const char *a1, int a2)
{
  void *v2; // r0
  void *v3; // r7
  const char *v5; // r0
  unsigned int v6; // r5
  int v7; // [sp+8h] [bp-78h]
  const char *v8[22]; // [sp+Ch] [bp-74h]

  v2 = simpleUPnPcommand(-1, a1, a2, "GetTotalBytesSent", 0, &v7);
  v3 = v2;
  if ( !v2 )
    return -3;
  ParseNameValue((int)v2, v7, v8);
  free(v3);
  v5 = (const char *)GetValueFromNameValueList(v8, "NewTotalBytesSent");
  if ( v5 )
    v6 = strtoul(v5, 0, 0);
  else
    v6 = 0;
  ClearNameValueList((int)v8);
  return v6;
}

//----- (00064F64) --------------------------------------------------------
signed int __fastcall UPNP_GetTotalBytesReceived(const char *a1, int a2)
{
  void *v2; // r0
  void *v3; // r7
  const char *v5; // r0
  unsigned int v6; // r5
  int v7; // [sp+8h] [bp-78h]
  const char *v8[22]; // [sp+Ch] [bp-74h]

  v2 = simpleUPnPcommand(-1, a1, a2, "GetTotalBytesReceived", 0, &v7);
  v3 = v2;
  if ( !v2 )
    return -3;
  ParseNameValue((int)v2, v7, v8);
  free(v3);
  v5 = (const char *)GetValueFromNameValueList(v8, "NewTotalBytesReceived");
  if ( v5 )
    v6 = strtoul(v5, 0, 0);
  else
    v6 = 0;
  ClearNameValueList((int)v8);
  return v6;
}

//----- (00065028) --------------------------------------------------------
signed int __fastcall UPNP_GetTotalPacketsSent(const char *a1, int a2)
{
  void *v2; // r0
  void *v3; // r7
  const char *v5; // r0
  unsigned int v6; // r5
  int v7; // [sp+8h] [bp-78h]
  const char *v8[22]; // [sp+Ch] [bp-74h]

  v2 = simpleUPnPcommand(-1, a1, a2, "GetTotalPacketsSent", 0, &v7);
  v3 = v2;
  if ( !v2 )
    return -3;
  ParseNameValue((int)v2, v7, v8);
  free(v3);
  v5 = (const char *)GetValueFromNameValueList(v8, "NewTotalPacketsSent");
  if ( v5 )
    v6 = strtoul(v5, 0, 0);
  else
    v6 = 0;
  ClearNameValueList((int)v8);
  return v6;
}

//----- (000650EC) --------------------------------------------------------
signed int __fastcall UPNP_GetTotalPacketsReceived(const char *a1, int a2)
{
  void *v2; // r0
  void *v3; // r7
  const char *v5; // r0
  unsigned int v6; // r5
  int v7; // [sp+8h] [bp-78h]
  const char *v8[22]; // [sp+Ch] [bp-74h]

  v2 = simpleUPnPcommand(-1, a1, a2, "GetTotalPacketsReceived", 0, &v7);
  v3 = v2;
  if ( !v2 )
    return -3;
  ParseNameValue((int)v2, v7, v8);
  free(v3);
  v5 = (const char *)GetValueFromNameValueList(v8, "NewTotalPacketsReceived");
  if ( v5 )
    v6 = strtoul(v5, 0, 0);
  else
    v6 = 0;
  ClearNameValueList((int)v8);
  return v6;
}

//----- (000651B0) --------------------------------------------------------
signed int __fastcall UPNP_GetStatusInfo(const char *a1, int a2, char *a3, int a4, char *a5)
{
  bool v5; // zf
  char *v6; // r5
  int v7; // r7
  _BOOL4 v8; // r10
  void *v9; // r0
  void *v10; // r9
  const char *v11; // r11
  signed int v12; // r9
  int v13; // r0
  signed int v14; // r3
  const char *v15; // r12
  const char *v16; // r1
  char *v17; // ST0C_4
  char *v18; // ST0C_4
  const char *v19; // r0
  char *src; // [sp+Ch] [bp-94h]
  int v22; // [sp+14h] [bp-8Ch]
  _BYTE **v23; // [sp+18h] [bp-88h]
  const char *v24[22]; // [sp+1Ch] [bp-84h]

  v5 = a3 == 0;
  if ( !a3 )
    v5 = a4 == 0;
  v6 = a3;
  v7 = a4;
  v8 = v5 != 0;
  v23 = (_BYTE **)-1;
  if ( v5 )
    return -2;
  v9 = simpleUPnPcommand(-1, a1, a2, "GetStatusInfo", (_BYTE **)v8, &v22);
  v10 = v9;
  if ( !v9 )
    return -3;
  ParseNameValue((int)v9, v22, v24);
  free(v10);
  v11 = (const char *)GetValueFromNameValueList(v24, "NewUptime");
  v12 = (signed int)v11;
  if ( v11 )
    v12 = 1;
  src = (char *)GetValueFromNameValueList(v24, "NewConnectionStatus");
  v13 = GetValueFromNameValueList(v24, "NewLastConnectionError");
  v14 = (signed int)src;
  if ( src )
    v14 = 1;
  if ( v12 & v14 )
    v23 = (_BYTE **)v8;
  v15 = (const char *)v13;
  if ( v6 )
  {
    if ( v14 )
    {
      v16 = src;
      v17 = (char *)v13;
      strncpy(v6, v16, 0x40u);
      v6[63] = 0;
      v15 = v17;
    }
    else
    {
      *v6 = 0;
    }
  }
  if ( v7 && v12 )
  {
    v18 = (char *)v15;
    sscanf(v11, "%u", v7);
    v15 = v18;
  }
  if ( a5 )
  {
    if ( v15 )
    {
      strncpy(a5, v15, 0x40u);
      a5[63] = 0;
    }
    else
    {
      *a5 = 0;
    }
  }
  v19 = (const char *)GetValueFromNameValueList(v24, "errorCode");
  if ( v19 )
  {
    v23 = (_BYTE **)-1;
    sscanf(v19, "%d", &v23);
  }
  ClearNameValueList((int)v24);
  return (signed int)v23;
}

//----- (000653A4) --------------------------------------------------------
signed int __fastcall UPNP_GetConnectionTypeInfo(const char *a1, int a2, char *a3)
{
  char *v3; // r7
  void *v4; // r0
  void *v5; // r8
  const char *v6; // r1
  const char *v7; // r0
  int v9; // [sp+Ch] [bp-7Ch]
  int v10; // [sp+10h] [bp-78h]
  const char *v11[22]; // [sp+14h] [bp-74h]

  v3 = a3;
  v10 = -1;
  if ( !a3 )
    return -2;
  v4 = simpleUPnPcommand(-1, a1, a2, "GetConnectionTypeInfo", 0, &v9);
  v5 = v4;
  if ( !v4 )
    return -3;
  ParseNameValue((int)v4, v9, v11);
  free(v5);
  v6 = (const char *)GetValueFromNameValueList(v11, "NewConnectionType");
  if ( v6 )
  {
    strncpy(v3, v6, 0x40u);
    v3[63] = 0;
    v10 = 0;
  }
  else
  {
    *v3 = 0;
  }
  v7 = (const char *)GetValueFromNameValueList(v11, "errorCode");
  if ( v7 )
  {
    v10 = -1;
    sscanf(v7, "%d", &v10);
  }
  ClearNameValueList((int)v11);
  return v10;
}

//----- (000654C0) --------------------------------------------------------
signed int __fastcall UPNP_GetLinkLayerMaxBitRates(const char *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r7
  _DWORD *v6; // r6
  _BOOL4 v7; // r9
  void *v8; // r0
  void *v9; // r8
  const char *v10; // r11
  int v11; // r0
  signed int v12; // r3
  signed int v13; // r8
  const char *v14; // r10
  const char *v15; // r0
  int v17; // [sp+Ch] [bp-8Ch]
  _BYTE **v18; // [sp+10h] [bp-88h]
  const char *v19[22]; // [sp+14h] [bp-84h]

  v4 = a3 == 0;
  if ( !a3 )
    v4 = a4 == 0;
  v5 = a3;
  v6 = a4;
  v7 = v4 != 0;
  v18 = (_BYTE **)-1;
  if ( v4 )
    return -2;
  v8 = simpleUPnPcommand(-1, a1, a2, "GetCommonLinkProperties", (_BYTE **)v7, &v17);
  v9 = v8;
  if ( !v8 )
    return -3;
  ParseNameValue((int)v8, v17, v19);
  free(v9);
  v10 = (const char *)GetValueFromNameValueList(v19, "NewLayer1DownstreamMaxBitRate");
  v11 = GetValueFromNameValueList(v19, "NewLayer1UpstreamMaxBitRate");
  v12 = (signed int)v10;
  if ( v10 )
    v12 = 1;
  v13 = v11;
  v14 = (const char *)v11;
  if ( v11 )
    v13 = 1;
  if ( v13 & v12 )
    v18 = (_BYTE **)v7;
  if ( v5 )
  {
    if ( v12 )
      sscanf(v10, "%u", v5);
    else
      *v5 = 0;
  }
  if ( v6 )
  {
    if ( v13 )
      sscanf(v14, "%u", v6);
    else
      *v6 = 0;
  }
  v15 = (const char *)GetValueFromNameValueList(v19, "errorCode");
  if ( v15 )
  {
    v18 = (_BYTE **)-1;
    sscanf(v15, "%d", &v18);
  }
  ClearNameValueList((int)v19);
  return (signed int)v18;
}

//----- (00065658) --------------------------------------------------------
signed int __fastcall UPNP_GetExternalIPAddress(const char *a1, int a2, char *a3)
{
  bool v3; // zf
  char *v4; // r6
  _BOOL4 v5; // r7
  void *v6; // r0
  void *v7; // r8
  const char *v8; // r1
  const char *v9; // r0
  int v11; // [sp+Ch] [bp-7Ch]
  int v12; // [sp+10h] [bp-78h]
  const char *v13[22]; // [sp+14h] [bp-74h]

  v3 = a1 == 0;
  if ( a1 )
    v3 = a3 == 0;
  v4 = a3;
  v5 = v3 != 0;
  v12 = -1;
  if ( v3 || !a2 )
    return -2;
  v6 = simpleUPnPcommand(-1, a1, a2, "GetExternalIPAddress", (_BYTE **)v5, &v11);
  v7 = v6;
  if ( !v6 )
    return -3;
  ParseNameValue((int)v6, v11, v13);
  free(v7);
  v8 = (const char *)GetValueFromNameValueList(v13, "NewExternalIPAddress");
  if ( v8 )
  {
    strncpy(v4, v8, 0x10u);
    v4[15] = v5;
    v12 = v5;
  }
  else
  {
    *v4 = 0;
  }
  v9 = (const char *)GetValueFromNameValueList(v13, "errorCode");
  if ( v9 )
  {
    v12 = -1;
    sscanf(v9, "%d", &v12);
  }
  ClearNameValueList((int)v13);
  return v12;
}

//----- (00065788) --------------------------------------------------------
signed int __fastcall UPNP_AddPortMapping(const char *a1, int a2, int a3, int a4, int a5, const char *a6, int a7, int a8, const char *a9)
{
  int v9; // r9
  int v10; // r7
  bool v11; // zf
  const char *v12; // r11
  const char *v13; // r10
  bool v14; // zf
  _DWORD *v15; // r0
  void *v16; // r4
  void *v17; // r0
  void *v18; // r7
  const char *v19; // r0
  signed int result; // r0
  const char *v21; // [sp+10h] [bp-98h]
  int v22; // [sp+14h] [bp-94h]
  int v23; // [sp+1Ch] [bp-8Ch]
  int v24; // [sp+20h] [bp-88h]
  const char *v25[22]; // [sp+24h] [bp-84h]

  v9 = a3;
  v10 = a4;
  v11 = a5 == 0;
  if ( a5 )
    v11 = a4 == 0;
  v22 = a2;
  v12 = a6;
  v13 = a9;
  if ( v11 )
    return -2;
  v14 = a3 == 0;
  if ( a3 )
    v14 = a7 == 0;
  if ( v14 )
    return -2;
  v21 = a1;
  v15 = calloc(9u, 8u);
  v16 = v15;
  v15[1] = a8;
  v15[3] = v9;
  v15[5] = a7;
  v15[7] = v10;
  v15[9] = a5;
  *v15 = "NewRemoteHost";
  v15[2] = "NewExternalPort";
  v15[4] = "NewProtocol";
  v15[6] = "NewInternalPort";
  v15[8] = "NewInternalClient";
  v15[10] = "NewEnabled";
  v15[11] = "1";
  v15[12] = "NewPortMappingDescription";
  if ( !a6 )
    v12 = "libminiupnpc";
  v15[13] = v12;
  v15[14] = "NewLeaseDuration";
  if ( !a9 )
    v13 = "0";
  v15[15] = v13;
  v17 = simpleUPnPcommand(-1, v21, v22, "AddPortMapping", (_BYTE **)v15, &v23);
  v18 = v17;
  if ( v17 )
  {
    ParseNameValue((int)v17, v23, v25);
    free(v18);
    v19 = (const char *)GetValueFromNameValueList(v25, "errorCode");
    if ( v19 )
    {
      v24 = -1;
      sscanf(v19, "%d", &v24);
    }
    else
    {
      v24 = 0;
    }
    ClearNameValueList((int)v25);
    free(v16);
    result = v24;
  }
  else
  {
    free(v16);
    result = -3;
  }
  return result;
}

//----- (000659A8) --------------------------------------------------------
signed int __fastcall UPNP_DeletePortMapping(const char *a1, int a2, int a3, int a4, int a5)
{
  bool v5; // zf
  int v6; // r6
  int v7; // r7
  const char *v8; // r10
  int v9; // r9
  _DWORD *v10; // r0
  void *v11; // r4
  void *v12; // r0
  void *v13; // r7
  const char *v14; // r0
  signed int result; // r0
  int v16; // [sp+Ch] [bp-8Ch]
  int v17; // [sp+10h] [bp-88h]
  const char *v18[22]; // [sp+14h] [bp-84h]

  v5 = a4 == 0;
  if ( a4 )
    v5 = a3 == 0;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( v5 )
    return -2;
  v10 = calloc(4u, 8u);
  v11 = v10;
  v10[3] = v7;
  v10[1] = a5;
  v10[5] = v6;
  *v10 = "NewRemoteHost";
  v10[2] = "NewExternalPort";
  v10[4] = "NewProtocol";
  v12 = simpleUPnPcommand(-1, v8, v9, "DeletePortMapping", (_BYTE **)v10, &v16);
  v13 = v12;
  if ( v12 )
  {
    ParseNameValue((int)v12, v16, v18);
    free(v13);
    v14 = (const char *)GetValueFromNameValueList(v18, "errorCode");
    if ( v14 )
    {
      v17 = -1;
      sscanf(v14, "%d", &v17);
    }
    else
    {
      v17 = 0;
    }
    ClearNameValueList((int)v18);
    free(v11);
    result = v17;
  }
  else
  {
    free(v11);
    result = -3;
  }
  return result;
}

//----- (00065AFC) --------------------------------------------------------
signed int __fastcall UPNP_GetGenericPortMappingEntry(const char *a1, int a2, int a3, char *a4, char *a5, char *a6, char *a7, char *a8, char *a9, char *a10, char *a11)
{
  int v11; // r4
  char *v12; // r10
  int v13; // ST10_4
  const char *v14; // ST14_4
  _DWORD *v15; // r0
  void *v16; // r6
  void *v17; // r0
  void *ptr; // ST0C_4
  const char *v19; // r0
  bool v20; // zf
  const char *v21; // r0
  bool v22; // zf
  const char *v23; // r0
  bool v24; // zf
  const char *v25; // r1
  const char *v26; // r1
  const char *v27; // r0
  bool v28; // zf
  const char *v29; // r0
  bool v30; // zf
  const char *v31; // r0
  bool v32; // zf
  const char *v33; // r0
  signed int result; // r0
  int v35; // [sp+2Ch] [bp-8Ch]
  int v36; // [sp+30h] [bp-88h]
  const char *v37[22]; // [sp+34h] [bp-84h]

  v11 = a3;
  v12 = a4;
  v36 = -1;
  if ( !a3 )
    return -2;
  *a5 = 0;
  *a6 = 0;
  v13 = a2;
  v14 = a1;
  v15 = calloc(2u, 8u);
  v16 = v15;
  v15[1] = v11;
  *v15 = "NewPortMappingIndex";
  v17 = simpleUPnPcommand(-1, v14, v13, "GetGenericPortMappingEntry", (_BYTE **)v15, &v35);
  if ( v17 )
  {
    ptr = v17;
    ParseNameValue((int)v17, v35, v37);
    free(ptr);
    v19 = (const char *)GetValueFromNameValueList(v37, "NewRemoteHost");
    v20 = v19 == 0;
    if ( v19 )
      v20 = a10 == 0;
    if ( !v20 )
    {
      strncpy(a10, v19, 0x40u);
      a10[63] = 0;
    }
    v21 = (const char *)GetValueFromNameValueList(v37, "NewExternalPort");
    v22 = v21 == 0;
    if ( v21 )
      v22 = v12 == 0;
    if ( !v22 )
    {
      strncpy(v12, v21, 6u);
      v12[5] = 0;
      v36 = 0;
    }
    v23 = (const char *)GetValueFromNameValueList(v37, "NewProtocol");
    v24 = v23 == 0;
    if ( v23 )
      v24 = a7 == 0;
    if ( !v24 )
    {
      strncpy(a7, v23, 4u);
      a7[3] = 0;
    }
    v25 = (const char *)GetValueFromNameValueList(v37, "NewInternalClient");
    if ( v25 )
    {
      strncpy(a5, v25, 0x10u);
      a5[15] = 0;
      v36 = 0;
    }
    v26 = (const char *)GetValueFromNameValueList(v37, "NewInternalPort");
    if ( v26 )
    {
      strncpy(a6, v26, 6u);
      a6[5] = 0;
    }
    v27 = (const char *)GetValueFromNameValueList(v37, "NewEnabled");
    v28 = v27 == 0;
    if ( v27 )
      v28 = a9 == 0;
    if ( !v28 )
    {
      strncpy(a9, v27, 4u);
      a9[3] = 0;
    }
    v29 = (const char *)GetValueFromNameValueList(v37, "NewPortMappingDescription");
    v30 = v29 == 0;
    if ( v29 )
      v30 = a8 == 0;
    if ( !v30 )
    {
      strncpy(a8, v29, 0x50u);
      a8[79] = 0;
    }
    v31 = (const char *)GetValueFromNameValueList(v37, "NewLeaseDuration");
    v32 = v31 == 0;
    if ( v31 )
      v32 = a11 == 0;
    if ( !v32 )
    {
      strncpy(a11, v31, 0x10u);
      a11[15] = 0;
    }
    v33 = (const char *)GetValueFromNameValueList(v37, "errorCode");
    if ( v33 )
    {
      v36 = -1;
      sscanf(v33, "%d", &v36);
    }
    ClearNameValueList((int)v37);
    free(v16);
    result = v36;
  }
  else
  {
    free(v16);
    result = -3;
  }
  return result;
}

//----- (00065E68) --------------------------------------------------------
signed int __fastcall UPNP_GetPortMappingNumberOfEntries(const char *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r7
  void *v4; // r0
  void *v5; // r8
  const char *v6; // r0
  bool v7; // zf
  const char *v8; // r0
  int v10; // [sp+Ch] [bp-7Ch]
  int v11; // [sp+10h] [bp-78h]
  const char *v12[22]; // [sp+14h] [bp-74h]

  v3 = a3;
  v11 = -1;
  v4 = simpleUPnPcommand(-1, a1, a2, "GetPortMappingNumberOfEntries", 0, &v10);
  v5 = v4;
  if ( !v4 )
    return -3;
  ParseNameValue((int)v4, v10, v12);
  free(v5);
  v6 = (const char *)GetValueFromNameValueList(v12, "NewPortMappingNumberOfEntries");
  v7 = v6 == 0;
  if ( v6 )
    v7 = v3 == 0;
  if ( !v7 )
  {
    *v3 = 0;
    sscanf(v6, "%u", v3);
    v11 = 0;
  }
  v8 = (const char *)GetValueFromNameValueList(v12, "errorCode");
  if ( v8 )
  {
    v11 = -1;
    sscanf(v8, "%d", &v11);
  }
  ClearNameValueList((int)v12);
  return v11;
}

//----- (00065F88) --------------------------------------------------------
signed int __fastcall UPNP_GetSpecificPortMappingEntry(const char *a1, int a2, int a3, int a4, char *a5, char *a6, char *a7, char *a8, char *a9)
{
  int v9; // r11
  int v10; // r6
  bool v11; // zf
  bool v12; // zf
  signed int v13; // r1
  int v14; // ST10_4
  const char *v15; // ST14_4
  _DWORD *v16; // r0
  void *v17; // r4
  void *v18; // r0
  void *v19; // r11
  const char *v20; // r1
  const char *v21; // r1
  const char *v22; // r0
  bool v23; // zf
  const char *v24; // r0
  bool v25; // zf
  const char *v26; // r0
  bool v27; // zf
  const char *v28; // r0
  signed int result; // r0
  int v30; // [sp+1Ch] [bp-94h]
  int v31; // [sp+24h] [bp-8Ch]
  int v32; // [sp+28h] [bp-88h]
  const char *v33[22]; // [sp+2Ch] [bp-84h]

  v9 = a2;
  v10 = a3;
  v11 = a5 == 0;
  if ( a5 )
    v11 = a6 == 0;
  v32 = -1;
  if ( v11 )
    return -2;
  v12 = a4 == 0;
  if ( a4 )
    v12 = a3 == 0;
  v13 = v12 ? 1 : 0;
  v30 = v13;
  if ( v12 )
    return -2;
  v14 = a4;
  v15 = a1;
  v16 = calloc(4u, 8u);
  v17 = v16;
  v16[5] = v14;
  *v16 = "NewRemoteHost";
  v16[3] = v10;
  v16[2] = "NewExternalPort";
  v16[4] = "NewProtocol";
  v18 = simpleUPnPcommand(-1, v15, v9, "GetSpecificPortMappingEntry", (_BYTE **)v16, &v31);
  v19 = v18;
  if ( v18 )
  {
    ParseNameValue((int)v18, v31, v33);
    free(v19);
    v20 = (const char *)GetValueFromNameValueList(v33, "NewInternalClient");
    if ( v20 )
    {
      strncpy(a5, v20, 0x10u);
      a5[15] = v30;
      v32 = v30;
    }
    else
    {
      *a5 = 0;
    }
    v21 = (const char *)GetValueFromNameValueList(v33, "NewInternalPort");
    if ( v21 )
    {
      strncpy(a6, v21, 6u);
      a6[5] = 0;
    }
    else
    {
      *a6 = 0;
    }
    v22 = (const char *)GetValueFromNameValueList(v33, "NewEnabled");
    v23 = v22 == 0;
    if ( v22 )
      v23 = a8 == 0;
    if ( !v23 )
    {
      strncpy(a8, v22, 4u);
      a8[3] = 0;
    }
    v24 = (const char *)GetValueFromNameValueList(v33, "NewPortMappingDescription");
    v25 = v24 == 0;
    if ( v24 )
      v25 = a7 == 0;
    if ( !v25 )
    {
      strncpy(a7, v24, 0x50u);
      a7[79] = 0;
    }
    v26 = (const char *)GetValueFromNameValueList(v33, "NewLeaseDuration");
    v27 = v26 == 0;
    if ( v26 )
      v27 = a9 == 0;
    if ( !v27 )
    {
      strncpy(a9, v26, 0x10u);
      a9[15] = 0;
    }
    v28 = (const char *)GetValueFromNameValueList(v33, "errorCode");
    if ( v28 )
    {
      v32 = -1;
      sscanf(v28, "%d", &v32);
    }
    ClearNameValueList((int)v33);
    free(v17);
    result = v32;
  }
  else
  {
    free(v17);
    result = -3;
  }
  return result;
}

//----- (00066244) --------------------------------------------------------
signed int __fastcall UPNP_GetListOfPortMappings(const char *a1, int a2, int a3, int a4, int a5, const char *a6, int a7)
{
  bool v7; // zf
  int v8; // r6
  int v9; // r7
  int v10; // r10
  const char *v11; // r11
  const char *v12; // r9
  _DWORD *v13; // r4
  void *v14; // r7
  const char *v15; // r0
  signed int result; // r0
  int v17; // [sp+14h] [bp-8Ch]
  int v18; // [sp+18h] [bp-88h]
  const char *v19[17]; // [sp+1Ch] [bp-84h]
  int v20; // [sp+60h] [bp-40h]
  int v21; // [sp+64h] [bp-3Ch]

  v7 = a4 == 0;
  if ( a4 )
    v7 = a3 == 0;
  v8 = a3;
  v9 = a4;
  v10 = a2;
  v11 = a1;
  v18 = -1;
  v12 = a6;
  if ( v7 || !a5 )
    return -2;
  v13 = calloc(6u, 8u);
  v13[1] = v8;
  v13[3] = v9;
  v13[5] = a5;
  *v13 = "NewStartPort";
  v13[2] = "NewEndPort";
  v13[4] = "NewProtocol";
  v13[6] = "NewManage";
  v13[7] = "1";
  v13[8] = "NewNumberOfPorts";
  if ( !a6 )
    v12 = "1000";
  v13[9] = v12;
  v14 = simpleUPnPcommand(-1, v11, v10, "GetListOfPortMappings", (_BYTE **)v13, &v17);
  if ( v14 )
  {
    free(v13);
    ParseNameValue((int)v14, v17, v19);
    free(v14);
    if ( v20 )
    {
      ParsePortListing(v20, v21, a7);
      v18 = 0;
    }
    v15 = (const char *)GetValueFromNameValueList(v19, "errorCode");
    if ( v15 )
    {
      v18 = -1;
      sscanf(v15, "%d", &v18);
    }
    ClearNameValueList((int)v19);
    result = v18;
  }
  else
  {
    free(v13);
    result = -3;
  }
  return result;
}

//----- (00066420) --------------------------------------------------------
signed int __fastcall UPNP_GetFirewallStatus(const char *a1, int a2, unsigned int *a3, unsigned int *a4)
{
  bool v4; // zf
  unsigned int *v5; // r7
  unsigned int *v6; // r6
  _BOOL4 v7; // r9
  void *v8; // r0
  void *v9; // r8
  const char *v10; // r11
  int v11; // r0
  signed int v12; // r3
  signed int v13; // r8
  const char *v14; // r10
  const char *v15; // r0
  int v17; // [sp+Ch] [bp-8Ch]
  _BYTE **v18; // [sp+10h] [bp-88h]
  const char *v19[22]; // [sp+14h] [bp-84h]

  v4 = a4 == 0;
  if ( a4 )
    v4 = a3 == 0;
  v5 = a3;
  v6 = a4;
  v7 = v4 != 0;
  v18 = (_BYTE **)-1;
  if ( v4 )
    return -2;
  v8 = simpleUPnPcommand(-1, a1, a2, "GetFirewallStatus", (_BYTE **)v7, &v17);
  v9 = v8;
  if ( !v8 )
    return -3;
  ParseNameValue((int)v8, v17, v19);
  free(v9);
  v10 = (const char *)GetValueFromNameValueList(v19, "FirewallEnabled");
  v11 = GetValueFromNameValueList(v19, "InboundPinholeAllowed");
  v12 = (signed int)v10;
  if ( v10 )
    v12 = 1;
  v13 = v11;
  v14 = (const char *)v11;
  if ( v11 )
    v13 = 1;
  if ( v12 & v13 )
  {
    v18 = (_BYTE **)v7;
  }
  else if ( !v12 )
  {
    goto LABEL_16;
  }
  *v5 = strtoul(v10, 0, 0);
LABEL_16:
  if ( v13 )
    *v6 = strtoul(v14, 0, 0);
  v15 = (const char *)GetValueFromNameValueList(v19, "errorCode");
  if ( v15 )
  {
    v18 = (_BYTE **)-1;
    sscanf(v15, "%d", &v18);
  }
  ClearNameValueList((int)v19);
  return (signed int)v18;
}

//----- (000665A0) --------------------------------------------------------
signed int __fastcall UPNP_GetOutboundPinholeTimeout(const char *a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int *a8)
{
  int v8; // r10
  int v9; // r9
  bool v10; // zf
  int v11; // r11
  bool v12; // zf
  const char *v13; // ST08_4
  _DWORD *v14; // r0
  void *v15; // r4
  void *v16; // r0
  void *v17; // r7
  const char *v18; // r0
  char **v19; // r7
  const char *v21; // r0
  int v22; // [sp+14h] [bp-8Ch]
  int v23; // [sp+18h] [bp-88h]
  const char *v24[22]; // [sp+1Ch] [bp-84h]

  v8 = a3;
  v9 = a4;
  v10 = a5 == 0;
  if ( a5 )
    v10 = a6 == 0;
  v11 = a2;
  if ( v10 )
    return -2;
  v12 = a4 == 0;
  if ( a4 )
    v12 = a7 == 0;
  if ( v12 || !a3 )
    return -2;
  v13 = a1;
  v14 = calloc(6u, 8u);
  v15 = v14;
  v14[1] = v8;
  v14[2] = "RemotePort";
  v14[7] = a6;
  v14[3] = v9;
  v14[5] = a7;
  v14[9] = a5;
  *v14 = "RemoteHost";
  v14[4] = "Protocol";
  v14[6] = "InternalPort";
  v14[8] = "InternalClient";
  v16 = simpleUPnPcommand(-1, v13, v11, "GetOutboundPinholeTimeout", (_BYTE **)v14, &v22);
  v17 = v16;
  if ( !v16 )
    return -3;
  ParseNameValue((int)v16, v22, v24);
  free(v17);
  v18 = (const char *)GetValueFromNameValueList(v24, "errorCode");
  v19 = (char **)v18;
  if ( v18 )
  {
    v23 = -1;
    sscanf(v18, "%d", &v23);
  }
  else
  {
    v23 = 0;
    v21 = (const char *)GetValueFromNameValueList(v24, "OutboundPinholeTimeout");
    if ( v21 )
      *a8 = strtoul(v21, v19, (int)v19);
  }
  ClearNameValueList((int)v24);
  free(v15);
  return v23;
}

//----- (00066774) --------------------------------------------------------
signed int __fastcall UPNP_AddPinhole(const char *a1, int a2, const char *a3, int a4, const char *a5, int a6, int a7, int a8, char *a9)
{
  const char *v9; // r7
  bool v10; // zf
  bool v11; // zf
  bool v12; // zf
  _DWORD *v13; // r4
  void *v14; // r0
  void *v15; // r7
  const char *v16; // r1
  const char *v17; // r0
  int v19; // [sp+Ch] [bp-9Ch]
  const char *v20; // [sp+10h] [bp-98h]
  int v21; // [sp+14h] [bp-94h]
  int v22; // [sp+1Ch] [bp-8Ch]
  int v23; // [sp+20h] [bp-88h]
  const char *v24[22]; // [sp+24h] [bp-84h]

  v9 = a3;
  v20 = a1;
  v10 = a5 == 0;
  if ( a5 )
    v10 = a6 == 0;
  v21 = a2;
  if ( v10 )
    return -2;
  v11 = a3 == 0;
  if ( a3 )
    v11 = a7 == 0;
  if ( v11 )
    return -2;
  v12 = a8 == 0;
  if ( a8 )
    v12 = a4 == 0;
  if ( v12 )
    return -2;
  v19 = a4;
  v13 = calloc(7u, 8u);
  if ( !strncmp(v9, "empty", 5u) )
  {
    *v13 = "RemoteHost";
    v13[1] = &unk_E00F2;
  }
  else
  {
    *v13 = "RemoteHost";
    v13[1] = v9;
  }
  v13[3] = v19;
  v13[5] = a7;
  v13[7] = a6;
  v13[2] = "RemotePort";
  v13[4] = "Protocol";
  v13[6] = "InternalPort";
  if ( !strncmp(a5, "empty", 5u) )
  {
    v13[8] = "InternalClient";
    v13[9] = &unk_E00F2;
  }
  else
  {
    v13[9] = a5;
    v13[8] = "InternalClient";
  }
  v13[11] = a8;
  v13[10] = "LeaseTime";
  v14 = simpleUPnPcommand(-1, v20, v21, "AddPinhole", (_BYTE **)v13, &v22);
  v15 = v14;
  if ( !v14 )
    return -3;
  ParseNameValue((int)v14, v22, v24);
  free(v15);
  v16 = (const char *)GetValueFromNameValueList(v24, "UniqueID");
  if ( v16 )
  {
    strncpy(a9, v16, 8u);
    a9[7] = 0;
  }
  v17 = (const char *)GetValueFromNameValueList(v24, "errorCode");
  if ( v17 )
  {
    v23 = -1;
    sscanf(v17, "%d", &v23);
  }
  else
  {
    v23 = 0;
  }
  ClearNameValueList((int)v24);
  free(v13);
  return v23;
}

//----- (000669D8) --------------------------------------------------------
signed int __fastcall UPNP_UpdatePinhole(const char *a1, int a2, int a3, int a4)
{
  bool v4; // zf
  int v5; // r6
  int v6; // r7
  const char *v7; // r9
  int v8; // r8
  _DWORD *v9; // r0
  void *v10; // r4
  void *v11; // r0
  void *v12; // r7
  const char *v13; // r0
  int v15; // [sp+Ch] [bp-84h]
  int v16; // [sp+10h] [bp-80h]
  const char *v17[22]; // [sp+14h] [bp-7Ch]

  v4 = a4 == 0;
  if ( a4 )
    v4 = a3 == 0;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( v4 )
    return -2;
  v9 = calloc(3u, 8u);
  v10 = v9;
  v9[1] = v6;
  v9[3] = v5;
  *v9 = "UniqueID";
  v9[2] = "NewLeaseTime";
  v11 = simpleUPnPcommand(-1, v7, v8, "UpdatePinhole", (_BYTE **)v9, &v15);
  v12 = v11;
  if ( !v11 )
    return -3;
  ParseNameValue((int)v11, v15, v17);
  free(v12);
  v13 = (const char *)GetValueFromNameValueList(v17, "errorCode");
  if ( v13 )
  {
    v16 = -1;
    sscanf(v13, "%d", &v16);
  }
  else
  {
    v16 = 0;
  }
  ClearNameValueList((int)v17);
  free(v10);
  return v16;
}

//----- (00066B0C) --------------------------------------------------------
signed int __fastcall UPNP_DeletePinhole(const char *a1, int a2, int a3)
{
  int v3; // r6
  const char *v4; // r8
  int v5; // r7
  _DWORD *v6; // r0
  void *v7; // r5
  void *v8; // r0
  void *v9; // r7
  const char *v10; // r0
  int v12; // [sp+Ch] [bp-7Ch]
  int v13; // [sp+10h] [bp-78h]
  const char *v14[22]; // [sp+14h] [bp-74h]

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( !a3 )
    return -2;
  v6 = calloc(2u, 8u);
  v7 = v6;
  v6[1] = v3;
  *v6 = "UniqueID";
  v8 = simpleUPnPcommand(-1, v4, v5, "DeletePinhole", (_BYTE **)v6, &v12);
  v9 = v8;
  if ( !v8 )
    return -3;
  ParseNameValue((int)v8, v12, v14);
  free(v9);
  v10 = (const char *)GetValueFromNameValueList(v14, "errorCode");
  if ( v10 )
  {
    v13 = -1;
    sscanf(v10, "%d", &v13);
  }
  else
  {
    v13 = 0;
  }
  ClearNameValueList((int)v14);
  free(v7);
  return v13;
}

//----- (00066C20) --------------------------------------------------------
signed int __fastcall UPNP_CheckPinholeWorking(const char *a1, int a2, int a3, unsigned int *a4)
{
  int v4; // r7
  const char *v5; // r10
  int v6; // r8
  unsigned int *v7; // r9
  _DWORD *v8; // r0
  void *v9; // r5
  void *v10; // r0
  void *v11; // r7
  const char *v12; // r0
  unsigned int v13; // r0
  const char *v14; // r0
  int v16; // [sp+Ch] [bp-84h]
  int v17; // [sp+10h] [bp-80h]
  const char *v18[22]; // [sp+14h] [bp-7Ch]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  v17 = -1;
  if ( !a3 )
    return -2;
  v8 = calloc(4u, 8u);
  v9 = v8;
  v8[1] = v4;
  *v8 = "UniqueID";
  v10 = simpleUPnPcommand(-1, v5, v6, "CheckPinholeWorking", (_BYTE **)v8, &v16);
  v11 = v10;
  if ( !v10 )
    return -3;
  ParseNameValue((int)v10, v16, v18);
  free(v11);
  v12 = (const char *)GetValueFromNameValueList(v18, "IsWorking");
  if ( v12 )
  {
    v13 = strtoul(v12, 0, 0);
    v17 = 0;
    *v7 = v13;
  }
  else
  {
    *v7 = 0;
  }
  v14 = (const char *)GetValueFromNameValueList(v18, "errorCode");
  if ( v14 )
  {
    v17 = -1;
    sscanf(v14, "%d", &v17);
  }
  ClearNameValueList((int)v18);
  free(v9);
  return v17;
}

//----- (00066D74) --------------------------------------------------------
signed int __fastcall UPNP_GetPinholePackets(const char *a1, int a2, int a3, unsigned int *a4)
{
  int v4; // r7
  const char *v5; // r10
  int v6; // r8
  unsigned int *v7; // r9
  _DWORD *v8; // r0
  void *v9; // r5
  void *v10; // r0
  void *v11; // r7
  const char *v12; // r0
  unsigned int v13; // r0
  const char *v14; // r0
  int v16; // [sp+Ch] [bp-84h]
  int v17; // [sp+10h] [bp-80h]
  const char *v18[22]; // [sp+14h] [bp-7Ch]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a4;
  v17 = -1;
  if ( !a3 )
    return -2;
  v8 = calloc(4u, 8u);
  v9 = v8;
  v8[1] = v4;
  *v8 = "UniqueID";
  v10 = simpleUPnPcommand(-1, v5, v6, "GetPinholePackets", (_BYTE **)v8, &v16);
  v11 = v10;
  if ( !v10 )
    return -3;
  ParseNameValue((int)v10, v16, v18);
  free(v11);
  v12 = (const char *)GetValueFromNameValueList(v18, "PinholePackets");
  if ( v12 )
  {
    v13 = strtoul(v12, 0, 0);
    v17 = 0;
    *v7 = v13;
  }
  v14 = (const char *)GetValueFromNameValueList(v18, "errorCode");
  if ( v14 )
  {
    v17 = -1;
    sscanf(v14, "%d", &v17);
  }
  ClearNameValueList((int)v18);
  free(v9);
  return v17;
}

//----- (00066EC4) --------------------------------------------------------
const char *__fastcall strupnperror(signed int a1)
{
  if ( a1 == 705 )
    return "ProtocolNotSupported";
  if ( a1 > 705 )
  {
    if ( a1 == 715 )
      return "WildCardNotPermittedInSrcIP";
    if ( a1 >= 716 )
    {
      if ( a1 == 724 )
        return "SamePortValuesRequired";
      if ( a1 <= 724 )
      {
        if ( a1 == 716 )
          return "WildCardNotPermittedInExtPort";
        if ( a1 == 718 )
          return "ConflictInMappingEntry";
      }
      else
      {
        if ( a1 == 726 )
          return "RemoteHostOnlySupportsWildcard";
        if ( a1 < 726 )
          return "OnlyPermanentLeasesSupported";
        if ( a1 == 727 )
          return "ExternalPortOnlySupportsWildcard";
      }
    }
    else
    {
      if ( a1 == 708 )
        return "WildcardNotPermittedInSrcIP";
      if ( a1 <= 708 )
      {
        if ( a1 == 706 )
          return "InternalPortWildcardingNotAllowed";
        if ( a1 == 707 )
          return "ProtocolWildcardingNotAllowed";
      }
      else
      {
        if ( a1 == 713 )
          return "SpecifiedArrayIndexInvalid";
        if ( a1 > 713 )
          return "NoSuchEntryInArray";
        if ( a1 == 709 )
          return "NoPacketSent";
      }
    }
    return "UnknownError";
  }
  if ( a1 == 402 )
    return "Invalid Args";
  if ( a1 <= 402 )
  {
    if ( a1 == -2 )
      return "Miniupnpc Invalid Arguments";
    if ( (unsigned __int8)((a1 + 2 < 0) ^ __OFADD__(a1, 2)) | (a1 == -2) )
    {
      if ( a1 == -102 )
        return "Miniupnpc Memory allocation error";
      if ( a1 == -101 )
        return "Miniupnpc Socket error";
    }
    else
    {
      if ( !a1 )
        return "Success";
      if ( a1 < 0 )
        return "Miniupnpc Unknown Error";
      if ( a1 == 401 )
        return "Invalid Action";
    }
    return "UnknownError";
  }
  if ( a1 == 701 )
    return "PinholeSpaceExhausted";
  if ( a1 <= 701 )
  {
    if ( a1 == 501 )
      return "Action Failed";
    if ( a1 == 606 )
      return "Action not authorized";
    return "UnknownError";
  }
  if ( a1 == 703 )
    return "InboundPinholeNotAllowed";
  if ( a1 >= 704 )
    return "NoSuchEntry";
  return "FirewallDisabled";
}

//----- (000671A4) --------------------------------------------------------
void *__fastcall sub_671A4(int a1, const void *a2, signed int a3)
{
  signed int v3; // r5
  int v4; // r4
  size_t v5; // r2
  int v6; // r5
  void *result; // r0

  if ( a3 >= 63 )
    v3 = 63;
  else
    v3 = a3;
  v4 = a1;
  v5 = v3;
  v6 = a1 + v3;
  *(_DWORD *)(a1 + 76) = 1;
  result = memcpy((void *)(a1 + 4), a2, v5);
  *(_BYTE *)(v6 + 4) = 0;
  *(_DWORD *)(v4 + 80) = 0;
  *(_DWORD *)(v4 + 84) = 0;
  return result;
}

//----- (000671E4) --------------------------------------------------------
void *__fastcall sub_671E4(int a1, const void *a2, size_t a3)
{
  const void *v3; // r6
  _DWORD *v4; // r4
  size_t v5; // r5
  void *result; // r0
  char v7; // r7

  v3 = a2;
  v4 = (_DWORD *)a1;
  v5 = a3;
  result = (void *)strcmp((const char *)(a1 + 4), "NewPortListing");
  v7 = (char)result;
  if ( result )
  {
    v4[20] = v3;
    v4[21] = v5;
  }
  else
  {
    result = malloc(v5 + 1);
    v4[17] = result;
    if ( result )
    {
      result = memcpy(result, v3, v5);
      *(_BYTE *)(v4[17] + v5) = v7;
      v4[18] = v5;
    }
  }
  return result;
}

//----- (00067248) --------------------------------------------------------
char *__fastcall sub_67248(char *result)
{
  char **v1; // r4
  const char *v2; // r6
  signed int v3; // r7
  char *v4; // r5
  char *v5; // r1
  char *v6; // r3
  bool v7; // zf

  v1 = (char **)result;
  if ( *((_DWORD *)result + 19) )
  {
    v2 = result + 4;
    result = (char *)strcmp(result + 4, "NewPortListing");
    if ( result )
    {
      v3 = (signed int)v1[21];
      v4 = (char *)malloc(0xC8u);
      result = strncpy(v4 + 8, v2, 0x40u);
      v5 = v1[20];
      v4[71] = 0;
      if ( v5 )
      {
        if ( v3 >= 127 )
          v3 = 127;
        result = (char *)memcpy(v4 + 72, v5, v3);
        v4[v3 + 72] = 0;
      }
      else
      {
        v4[72] = 0;
      }
      v6 = *v1;
      v7 = *v1 == 0;
      *(_DWORD *)v4 = *v1;
      if ( !v7 )
        *((_DWORD *)v6 + 1) = v4;
      *v1 = v4;
      *((_DWORD *)v4 + 1) = v1;
    }
    v1[20] = 0;
    v1[21] = 0;
    v1[19] = 0;
  }
  return result;
}

//----- (00067300) --------------------------------------------------------
unsigned int __fastcall ParseNameValue(int a1, int a2, _DWORD *a3)
{
  int v4; // [sp+4h] [bp-2Ch]
  int v5; // [sp+10h] [bp-20h]
  _DWORD *v6; // [sp+14h] [bp-1Ch]
  void *(__fastcall *v7)(int, const void *, signed int); // [sp+18h] [bp-18h]
  char *(__fastcall *v8)(char *); // [sp+1Ch] [bp-14h]
  void *(__fastcall *v9)(int, const void *, size_t); // [sp+20h] [bp-10h]
  int v10; // [sp+24h] [bp-Ch]

  v4 = a1;
  *a3 = 0;
  a3[17] = 0;
  a3[18] = 0;
  v6 = a3;
  v5 = a2;
  v10 = 0;
  v7 = sub_671A4;
  v8 = sub_67248;
  v9 = sub_671E4;
  return parsexml((unsigned int)&v4);
}

//----- (00067368) --------------------------------------------------------
void __fastcall ClearNameValueList(int a1)
{
  int v1; // r4
  void *v2; // r0
  int *i; // r3
  int v4; // r2

  v1 = a1;
  v2 = *(void **)(a1 + 68);
  if ( v2 )
  {
    free(v2);
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 72) = 0;
  }
  for ( i = *(int **)v1; *(_DWORD *)v1; i = *(int **)v1 )
  {
    v4 = *i;
    if ( *i )
      *(_DWORD *)(v4 + 4) = i[1];
    *(_DWORD *)i[1] = v4;
    free(i);
  }
}

//----- (000673C8) --------------------------------------------------------
int __fastcall GetValueFromNameValueList(const char **a1, const char *a2)
{
  const char *v2; // r5
  const char *v3; // r4
  int v4; // r0
  int v5; // r2
  bool v6; // r3
  int v7; // r3

  v2 = a2;
  v3 = *a1;
  if ( !*a1 )
    return 0;
  do
  {
    v4 = strcmp(v3 + 8, v2);
    v5 = (int)(v3 + 72);
    v6 = 1;
    if ( v4 )
      v5 = 0;
    else
      v6 = v3 == (const char *)-72;
    v3 = *(const char **)v3;
    if ( v3 )
      v7 = v6;
    else
      v7 = 0;
  }
  while ( v7 );
  return v5;
}

//----- (00067430) --------------------------------------------------------
signed int __fastcall connecthostport(const char *a1, int a2, int a3)
{
  const char *v3; // r9
  signed int v4; // r5
  signed int v5; // r4
  int v6; // r0
  int v7; // r4
  int v8; // r0
  int v9; // r6
  char *v10; // r1
  _DWORD *v11; // r0
  signed int v12; // r1
  char *v13; // r2
  int v14; // r1
  int v15; // r2
  _DWORD *v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  const char *v21; // r0
  bool v22; // zf
  signed int v23; // r2
  bool v24; // zf
  const char *v25; // r0
  struct addrinfo *v26; // [sp+Ch] [bp-1F4h]
  int v27; // [sp+14h] [bp-1ECh]
  struct addrinfo *pai; // [sp+1Ch] [bp-1E4h]
  int v29; // [sp+20h] [bp-1E0h]
  int v30; // [sp+24h] [bp-1DCh]
  struct addrinfo req; // [sp+28h] [bp-1D8h]
  char v32; // [sp+48h] [bp-1B8h]
  char s; // [sp+C8h] [bp-138h]
  char dest[256]; // [sp+D0h] [bp-130h]
  char v35; // [sp+1D0h] [bp-30h]
  char v36; // [sp+1D8h] [bp-28h]

  v3 = a1;
  v27 = a3;
  v4 = 0;
  v5 = 1;
  req.ai_flags = 8;
  req.ai_family = 0;
  req.ai_protocol = 0;
  req.ai_addrlen = 0;
  req.ai_addr = 0;
  req.ai_canonname = 0;
  req.ai_next = 0;
  req.ai_socktype = 1;
  snprintf(&s, 8u, "%hu", a2);
  if ( *v3 == 91 )
  {
    v20 = *((unsigned __int8 *)v3 + 1);
    v21 = v3 + 1;
    v22 = v20 == 0;
    if ( v3[1] )
      v22 = v20 == 93;
    v23 = !v22;
    if ( v22 )
    {
      v4 = v23;
    }
    else
    {
      do
      {
        dest[v4++] = v20;
        if ( !memcmp(v21, "%25", 3u) )
          v5 += 2;
        v21 = &v3[++v5];
        v20 = (unsigned __int8)v3[v5];
        v24 = v20 == 93;
        if ( v20 != 93 )
          v24 = v20 == 0;
      }
      while ( !v24 && v4 != 256 );
    }
    *(&v36 + v4 - 264) = 0;
  }
  else
  {
    strncpy(dest, v3, 0x100u);
  }
  v35 = 0;
  v6 = getaddrinfo(dest, &s, &req, &pai);
  v7 = v6;
  if ( v6 )
  {
    v25 = gai_strerror(v6);
    fprintf((FILE *)((char *)&_sF + 168), "getaddrinfo() error : %s\n", v25);
    return -1;
  }
  v26 = pai;
  if ( !pai )
  {
    freeaddrinfo(0);
LABEL_45:
    perror("socket");
    return -1;
  }
  do
  {
    v8 = socket(v26->ai_family, v26->ai_socktype, v26->ai_protocol);
    v9 = v8;
    if ( v8 >= 0 )
    {
      v10 = v26->ai_canonname;
      if ( *(_WORD *)v10 == 10 && v27 )
        *((_DWORD *)v10 + 6) = v27;
      v11 = (_DWORD *)connect(v8, (const struct sockaddr *)v10, v26->ai_addrlen);
      v7 = (int)v11;
      if ( (signed int)v11 >= 0 )
      {
LABEL_14:
        freeaddrinfo(pai);
        return v9;
      }
      v12 = 1;
      v13 = &v36;
LABEL_9:
      while ( *(_DWORD *)_errno(v11, v12, v13) == 4 )
      {
        while ( 1 )
        {
          memset(&v32, 0, 0x80u);
          *((_DWORD *)&v36 + (v9 >> 5) - 100) = 1 << (v9 & 0x1F);
          v7 = select(v9 + 1, 0, (fd_set *)&v32, 0, 0);
          if ( v7 == -1 )
          {
            v11 = (_DWORD *)_errno(-1, v14, v15);
            if ( *v11 == 4 )
              break;
          }
          v29 = 4;
          v11 = (_DWORD *)getsockopt(v9, 1, 4, &v30, (socklen_t *)&v29);
          if ( (signed int)v11 < 0 )
          {
            perror("getsockopt");
            close(v9);
            freeaddrinfo(pai);
            return -1;
          }
          if ( !v30 )
          {
            if ( v7 < 0 )
              goto LABEL_9;
            goto LABEL_14;
          }
          v17 = (_DWORD *)_errno(v11, v12, v13);
          v7 = -1;
          *v17 = v30;
          if ( *(_DWORD *)_errno(v17, v18, v19) != 4 )
            goto LABEL_19;
        }
      }
LABEL_19:
      close(v9);
    }
    v26 = v26->ai_next;
  }
  while ( v26 );
  freeaddrinfo(pai);
  if ( v9 < 0 )
    goto LABEL_45;
  if ( v7 >= 0 )
    return v9;
  perror("connect");
  return -1;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 67430: using guessed type char dest[256];

//----- (000677B8) --------------------------------------------------------
void *__fastcall IGDstartelt(_DWORD *a1, const void *a2, size_t a3)
{
  _DWORD *v3; // r4
  size_t v4; // r5
  const void *v5; // r6
  void *result; // r0
  int v7; // r3

  v3 = a1;
  v4 = a3;
  v5 = a2;
  result = memcpy(a1, a2, a3);
  v7 = v3[96] + 1;
  *((_BYTE *)v3 + v4) = 0;
  v3[96] = v7;
  if ( v4 == 7 )
  {
    result = (void *)memcmp(v5, "service", 7u);
    if ( !result )
    {
      *((_BYTE *)v3 + 2436) = 0;
      *((_BYTE *)v3 + 2564) = 0;
      *((_BYTE *)v3 + 2692) = 0;
      *((_BYTE *)v3 + 2820) = 0;
    }
  }
  return result;
}

//----- (00067818) --------------------------------------------------------
const char *__fastcall IGDendelt(const char *result, const void *a2, int a3)
{
  const char *v3; // r4
  int v4; // r0

  v3 = result;
  --*((_DWORD *)result + 96);
  if ( a3 == 7 )
  {
    result = (const char *)memcmp(a2, "service", 7u);
    if ( !result )
    {
      if ( !strcmp(v3 + 2820, "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1") )
      {
        result = (const char *)memcpy((void *)(v3 + 388), v3 + 2436, 0x200u);
      }
      else
      {
        if ( !strcmp(v3 + 2820, "urn:schemas-upnp-org:service:WANIPv6FirewallControl:1") )
        {
          v4 = (int)(v3 + 1920);
          return (const char *)memcpy((void *)(v4 + 4), v3 + 2436, 0x200u);
        }
        if ( !strcmp(v3 + 2820, "urn:schemas-upnp-org:service:WANIPConnection:1")
          || (result = (const char *)strcmp(v3 + 2820, "urn:schemas-upnp-org:service:WANPPPConnection:1")) == 0 )
        {
          if ( !v3[1284] )
            return (const char *)memcpy((void *)(v3 + 900), v3 + 2436, 0x200u);
          v4 = (int)(v3 + 1408);
          return (const char *)memcpy((void *)(v4 + 4), v3 + 2436, 0x200u);
        }
      }
    }
  }
  return result;
}

//----- (00067924) --------------------------------------------------------
_BYTE *__fastcall IGDdata(const char *a1, const void *a2, signed int a3)
{
  const void *v3; // r5
  const char *v4; // r4
  signed int v5; // r6
  _BYTE *result; // r0
  void *v7; // r3
  size_t v8; // r4

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = (_BYTE *)strcmp(a1, "URLBase");
  if ( result )
  {
    result = (_BYTE *)strcmp(v4, "presentationURL");
    if ( result )
    {
      result = (_BYTE *)strcmp(v4, "serviceType");
      if ( result )
      {
        result = (_BYTE *)strcmp(v4, "controlURL");
        if ( result )
        {
          result = (_BYTE *)strcmp(v4, "eventSubURL");
          if ( result )
          {
            result = (_BYTE *)strcmp(v4, "SCPDURL");
            if ( result )
              return result;
            v7 = (void *)(v4 + 2692);
          }
          else
          {
            v7 = (void *)(v4 + 2564);
          }
        }
        else
        {
          v7 = (void *)(v4 + 2436);
        }
      }
      else
      {
        v7 = (void *)(v4 + 2820);
      }
    }
    else
    {
      v7 = (void *)(v4 + 256);
    }
  }
  else
  {
    v7 = (void *)(v4 + 128);
  }
  if ( v7 )
  {
    if ( v5 >= 127 )
      v8 = 127;
    else
      v8 = v5;
    result = memcpy(v7, v3, v8);
    result[v8] = 0;
  }
  return result;
}

//----- (00067A34) --------------------------------------------------------
int __fastcall printIGD(int a1)
{
  int v1; // r4

  v1 = a1;
  printf("urlbase = '%s'\n", a1 + 128);
  puts("WAN Device (Common interface config) :");
  printf(" serviceType = '%s'\n", v1 + 772);
  printf(" controlURL = '%s'\n", v1 + 388);
  printf(" eventSubURL = '%s'\n", v1 + 516);
  printf(" SCPDURL = '%s'\n", v1 + 644);
  puts("primary WAN Connection Device (IP or PPP Connection):");
  printf(" servicetype = '%s'\n", v1 + 1284);
  printf(" controlURL = '%s'\n", v1 + 900);
  printf(" eventSubURL = '%s'\n", v1 + 1028);
  printf(" SCPDURL = '%s'\n", v1 + 1156);
  puts("secondary WAN Connection Device (IP or PPP Connection):");
  printf(" servicetype = '%s'\n", v1 + 1796);
  printf(" controlURL = '%s'\n", v1 + 1412);
  printf(" eventSubURL = '%s'\n", v1 + 1540);
  printf(" SCPDURL = '%s'\n", v1 + 1668);
  puts("WAN IPv6 Firewall Control :");
  printf(" servicetype = '%s'\n", v1 + 2308);
  printf(" controlURL = '%s'\n", v1 + 1924);
  printf(" eventSubURL = '%s'\n", v1 + 2052);
  return printf(" SCPDURL = '%s'\n", v1 + 2180);
}

//----- (00067BB8) --------------------------------------------------------
char *__fastcall soapPostSubmit(int a1, char *s, int a3, int a4, int a5, char *sa, int a7)
{
  int v7; // r7
  char *v8; // r8
  int v9; // r9
  size_t v10; // r5
  int v11; // r0
  size_t v12; // r10
  size_t v13; // r8
  char *result; // r0
  char *v15; // r9
  char *v16; // r5
  int fd; // [sp+1Ch] [bp-23Ch]
  char v18; // [sp+24h] [bp-234h]
  char v19; // [sp+2Ch] [bp-22Ch]

  v7 = a4;
  v8 = s;
  fd = a1;
  v9 = a3;
  v18 = 0;
  v10 = strlen(sa);
  if ( v7 != 80 )
    snprintf(&v18, 8u, ":%hu", v7);
  v11 = snprintf(
          &v19,
          0x200u,
          "POST %s HTTP/%s\r\n"
          "Host: %s%s\r\n"
          "Content-Length: %d\r\n"
          "Content-Type: text/xml\r\n"
          "SOAPAction: \"%s\"\r\n"
          "Connection: Close\r\n"
          "Cache-Control: no-cache\r\n"
          "Pragma: no-cache\r\n"
          "\r\n",
          v8,
          a7,
          v9,
          &v18,
          v10,
          a5);
  v12 = v10 + v11;
  v13 = v11;
  result = (char *)malloc(v10 + v11);
  v15 = result;
  if ( result )
  {
    memcpy(result, &v19, v13);
    memcpy(&v15[v13], sa, v10);
    v16 = (char *)send(fd, v15, v12, 0);
    if ( (signed int)v16 < 0 )
      perror("send");
    free(v15);
    result = v16;
  }
  return result;
}

//----- (00067CF8) --------------------------------------------------------
_DWORD *__fastcall getDevicesFromMiniSSDPD(const char *a1, const char *a2)
{
  unsigned int v2; // r5
  char *v3; // r6
  const char *v4; // r4
  size_t v5; // r0
  size_t v6; // r2
  char *v7; // r3
  unsigned int v8; // r7
  char *v9; // r1
  int v10; // r11
  _DWORD *v11; // r8
  unsigned int v12; // r9
  unsigned int v13; // r4
  char v14; // t1
  char v15; // t1
  char *src; // ST08_4
  int v17; // ST04_4
  _DWORD *v18; // r7
  size_t v19; // r2
  unsigned int v20; // r3
  char v21; // t1
  size_t v22; // r3
  char *v23; // r0
  char *v24; // r1
  _BYTE *v25; // r0
  _DWORD *result; // r0
  unsigned int v27; // [sp+Ch] [bp-8ACh]
  int fd; // [sp+14h] [bp-8A4h]
  char v29; // [sp+1Ch] [bp-89Ch]
  char dest; // [sp+1Eh] [bp-89Ah]
  unsigned __int8 v31; // [sp+8Ch] [bp-82Ch]
  char v32; // [sp+8Dh] [bp-82Bh]
  __int16 v33; // [sp+8Eh] [bp-82Ah]
  char v34; // [sp+90h] [bp-828h]
  size_t v35; // [sp+88Ch] [bp-2Ch]

  v3 = (char *)a1;
  v4 = a2;
  fd = socket(1, 1, 0);
  if ( fd < 0 )
  {
    perror("socket(unix)");
    result = 0;
    goto LABEL_35;
  }
  v2 = (unsigned int)&v29;
  *(_WORD *)&v29 = 1;
  strncpy(&dest, v4, 0x6Cu);
  if ( connect(fd, (const struct sockaddr *)&v29, 0x6Eu) < 0 )
    goto LABEL_38;
  v5 = strlen(v3);
  v31 = 1;
  v6 = v5;
  if ( v5 > 0xFFFFFFF )
  {
    v22 = v5 >> 28;
    v2 = (unsigned int)&v34;
    v23 = (char *)&v33;
    v32 = ~(~(v22 << 25) >> 25);
LABEL_30:
    v24 = v23 + 1;
    *v23 = ~(~(v6 >> 21 << 25) >> 25);
LABEL_31:
    v25 = v24 + 1;
    *v24 = ~(~(v6 >> 14 << 25) >> 25);
    goto LABEL_32;
  }
  v2 = (unsigned int)&v34;
  if ( v5 >= 0x200000 )
  {
    v23 = &v32;
    goto LABEL_30;
  }
  if ( v5 >= 0x4000 )
  {
    v24 = &v32;
    goto LABEL_31;
  }
  if ( v5 > 0x7F )
    goto LABEL_43;
  v7 = &v32;
  while ( 1 )
  {
    v8 = (unsigned int)&v7[v6 + 1];
    *v7 = v6 & 0x7F;
    if ( v8 > v2 + 2044 )
      goto LABEL_38;
    memcpy(v7 + 1, v3, v6);
    if ( write(fd, (const void *)(v2 - 4), v8 - (v2 - 4)) < 0 )
    {
      perror("minissdpc.c: write()");
      close(fd);
      result = 0;
    }
    else
    {
      if ( read(fd, (void *)(v2 - 4), 0x800u) <= 0 )
      {
        perror("minissdpc.c: read()");
LABEL_38:
        close(fd);
        result = 0;
        goto LABEL_35;
      }
      v27 = v31;
      if ( v31 )
      {
        v9 = (char *)(v2 - 3);
        v10 = 0;
        v11 = 0;
        v12 = v2 + 2044;
        while ( 1 )
        {
          v13 = 0;
          do
          {
            v14 = *v9++;
            v13 = v14 & 0x7F | (v13 << 7);
          }
          while ( v14 & 0x80 && v13 < 0x2000000 );
          if ( v12 <= (unsigned int)&v9[v13 + 2] )
            break;
          v3 = &v9[v13];
          v2 = 0;
          do
          {
            v15 = *v3++;
            v2 = v15 & 0x7F | (v2 << 7);
          }
          while ( v15 & 0x80 && v2 < 0x2000000 );
          if ( v12 <= (unsigned int)&v3[v2 + 2] )
            break;
          src = v9;
          v17 = v2 + v13;
          v18 = malloc(v2 + v13 + 20);
          *v18 = v11;
          v18[1] = v18 + 4;
          v18[2] = (char *)v18 + v13 + 17;
          memcpy(v18 + 4, src, v13);
          v19 = v2;
          *((_BYTE *)v18 + v13 + 16) = 0;
          v2 += (unsigned int)v3;
          memcpy((char *)v18 + v13 + 17, v3, v19);
          v20 = 0;
          *((_BYTE *)v18 + v17 + 17) = 0;
          do
          {
            v21 = *(_BYTE *)v2++;
            v20 = v21 & 0x7F | (v20 << 7);
          }
          while ( v21 & 0x80 && v20 < 0x2000000 );
          v9 = (char *)(v2 + v20);
          if ( v2 + v20 > v12 )
            goto LABEL_34;
          if ( v27 <= ++v10 || v12 <= (unsigned int)(v9 + 2) )
            goto LABEL_34;
          v11 = v18;
        }
        v18 = v11;
      }
      else
      {
        v18 = (_DWORD *)v31;
      }
LABEL_34:
      close(fd);
      result = v18;
    }
LABEL_35:
    v6 = v35;
    if ( v35 == _stack_chk_guard )
      return result;
LABEL_43:
    v25 = (_BYTE *)(v2 - 3);
LABEL_32:
    v7 = v25 + 1;
    *v25 = ~(~(v6 >> 7 << 25) >> 25);
  }
}

//----- (00068068) --------------------------------------------------------
int *__fastcall sub_68068(int *result, unsigned __int8 *a2, signed int a3)
{
  int v3; // r4
  signed int v4; // r5
  int v5; // r3
  int v6; // r5
  int *v7; // t1
  int v8; // r5
  int v9; // r3
  int *v10; // t1
  int v11; // r5
  int v12; // r3
  int *v13; // t1
  int v14; // r5
  int v15; // r3
  int *v16; // t1

  v3 = *result;
  if ( *result )
  {
    if ( a3 >= 63 )
      v4 = 63;
    else
      v4 = a3;
    switch ( result[1] )
    {
      case 2:
        result = (int *)memcpy((void *)(v3 + 16), a2, v4);
        *(_BYTE *)(v3 + v4 + 16) = 0;
        break;
      case 3:
        if ( v4 <= 0 || (result = (int *)*a2, (unsigned int)(result - 12) > 9) )
        {
          LOWORD(v9) = 0;
        }
        else
        {
          v8 = (int)&a2[v4 - 1];
          v9 = 0;
          do
          {
            v9 = (int)result + 10 * v9 - 48;
            if ( a2 == (unsigned __int8 *)v8 )
              break;
            v10 = (int *)(a2++)[1];
            result = v10;
          }
          while ( (unsigned int)(v10 - 12) <= 9 );
        }
        *(_WORD *)(v3 + 12) = v9;
        break;
      case 4:
        if ( v4 >= 3 )
          v4 = 3;
        result = (int *)memcpy((void *)(v3 + 208), a2, v4);
        *(_BYTE *)(v3 + v4 + 208) = 0;
        break;
      case 5:
        if ( v4 <= 0 || (result = (int *)*a2, (unsigned int)(result - 12) > 9) )
        {
          LOWORD(v12) = 0;
        }
        else
        {
          v11 = (int)&a2[v4 - 1];
          v12 = 0;
          do
          {
            v12 = (int)result + 10 * v12 - 48;
            if ( a2 == (unsigned __int8 *)v11 )
              break;
            v13 = (int *)(a2++)[1];
            result = v13;
          }
          while ( (unsigned int)(v13 - 12) <= 9 );
        }
        *(_WORD *)(v3 + 14) = v12;
        break;
      case 6:
        result = (int *)memcpy((void *)(v3 + 80), a2, v4);
        *(_BYTE *)(v3 + v4 + 80) = 0;
        break;
      case 7:
        if ( v4 <= 0 || (result = (int *)*a2, (unsigned int)(result - 12) > 9) )
        {
          LOBYTE(v15) = 0;
        }
        else
        {
          v14 = (int)&a2[v4 - 1];
          v15 = 0;
          do
          {
            v15 = (int)result + 10 * v15 - 48;
            if ( a2 == (unsigned __int8 *)v14 )
              break;
            v16 = (int *)(a2++)[1];
            result = v16;
          }
          while ( (unsigned int)(v16 - 12) <= 9 );
        }
        *(_BYTE *)(v3 + 212) = v15;
        break;
      case 8:
        result = (int *)memcpy((void *)(v3 + 144), a2, v4);
        *(_BYTE *)(v3 + v4 + 144) = 0;
        break;
      case 9:
        if ( v4 <= 0 || (result = (int *)*a2, (unsigned int)(result - 12) > 9) )
        {
          v5 = 0;
        }
        else
        {
          v6 = (int)&a2[v4 - 1];
          v5 = 0;
          do
          {
            v5 = (int)result + 10 * v5 - 48;
            if ( a2 == (unsigned __int8 *)v6 )
              break;
            v7 = (int *)(a2++)[1];
            result = v7;
          }
          while ( (unsigned int)(v7 - 12) <= 9 );
        }
        *(_DWORD *)(v3 + 8) = v5;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (000682AC) --------------------------------------------------------
_DWORD *__fastcall sub_682AC(int *a1, const void *a2, size_t a3)
{
  int *v3; // r8
  const void *v4; // r6
  const char *v5; // r3
  size_t v6; // r5
  int v7; // r4
  _DWORD *result; // r0
  int v9; // r3
  bool v10; // zf

  v3 = a1;
  v4 = a2;
  v5 = "PortMappingEntry";
  v6 = a3;
  v7 = 0;
  a1[1] = 0;
  while ( 1 )
  {
    result = (_DWORD *)memcmp(v4, v5, v6);
    if ( !result )
      break;
    v5 = (const char *)*((_DWORD *)&unk_EF604 + 2 * ++v7 + 1);
    if ( !v5 )
      return result;
  }
  result = (_DWORD *)*((_DWORD *)&unk_EF604 + 2 * v7);
  v3[1] = (int)result;
  if ( result == (int *)((char *)&dword_0 + 1) )
  {
    result = calloc(1u, 0xD8u);
    v9 = *v3;
    v10 = *v3 == 0;
    *result = *v3;
    if ( !v10 )
      *(_DWORD *)(v9 + 4) = result;
    *v3 = (int)result;
    result[1] = v3;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00068354) --------------------------------------------------------
unsigned int __fastcall ParsePortListing(int a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-34h]
  int v5; // [sp+10h] [bp-28h]
  int v6; // [sp+14h] [bp-24h]
  _DWORD *(__fastcall *v7)(int *, const void *, size_t); // [sp+18h] [bp-20h]
  int (*v8)(); // [sp+1Ch] [bp-1Ch]
  int *(__fastcall *v9)(int *, unsigned __int8 *, signed int); // [sp+20h] [bp-18h]
  int v10; // [sp+24h] [bp-14h]

  *(_BYTE *)(a3 + 3) = 0;
  *(_BYTE *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 5) = 0;
  v4 = a1;
  *(_BYTE *)(a3 + 6) = 0;
  *(_BYTE *)(a3 + 7) = 0;
  *(_DWORD *)a3 = 0;
  v6 = a3;
  v5 = a2;
  v10 = 0;
  v7 = sub_682AC;
  v8 = sub_6805C;
  v9 = sub_68068;
  return parsexml((unsigned int)&v4);
}
// 6805C: using guessed type int sub_6805C();

//----- (000683CC) --------------------------------------------------------
void __fastcall FreePortListing(int **a1)
{
  int *v1; // r3
  int **i; // r4
  int v3; // r2

  v1 = *a1;
  for ( i = a1; *i; v1 = *i )
  {
    v3 = *v1;
    if ( *v1 )
      *(_DWORD *)(v3 + 4) = v1[1];
    *(_DWORD *)v1[1] = v3;
    free(v1);
  }
}

//----- (00068410) --------------------------------------------------------
int __fastcall sub_68410(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r4
  int v4; // r5
  int result; // r0
  int v6; // [sp+4h] [bp-14h]
  _DWORD *v7; // [sp+8h] [bp-10h]

  v6 = a2;
  v7 = a3;
  v3 = (_DWORD *)a2;
  v4 = a1;
  result = Curl_getconnectinfo(a1, &v6, a3);
  if ( !result )
  {
    if ( v6 == -1 )
    {
      Curl_failf(v4, "Failed to get recent socket", v6 + 1);
      result = 1;
    }
    else
    {
      *v3 = v6;
    }
  }
  return result;
}

//----- (0006843C) --------------------------------------------------------
signed int __fastcall curl_global_init(int a1)
{
  int v1; // r6
  int v2; // r2

  v1 = a1;
  v2 = dword_2F847C++;
  if ( !v2 )
  {
    Curl_cmalloc = (int (__fastcall *)(_DWORD))&malloc;
    Curl_cfree = (int (__fastcall *)(_DWORD))&free;
    Curl_crealloc = (int (__fastcall *)(_DWORD, _DWORD))&realloc;
    Curl_cstrdup = (int (__fastcall *)(_DWORD))&strdup;
    Curl_ccalloc = (int (__fastcall *)(_DWORD, _DWORD))&calloc;
    if ( ares_library_init(1) )
      return 2;
    dword_2F8480 = v1;
    Curl_srand();
  }
  return 0;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);
// 2F847C: using guessed type int dword_2F847C;
// 2F8480: using guessed type int dword_2F8480;

//----- (000684CC) --------------------------------------------------------
signed int __fastcall curl_global_init_mem(int a1, int (__fastcall *a2)(_DWORD), int (__fastcall *a3)(_DWORD), int (__fastcall *a4)(_DWORD, _DWORD), int (__fastcall *a5)(_DWORD), int (__fastcall *a6)(_DWORD, _DWORD))
{
  int (__fastcall *v6)(_DWORD); // r7
  int (__fastcall *v7)(_DWORD, _DWORD); // r8
  int (__fastcall *v8)(_DWORD); // r9
  signed int result; // r0

  v6 = a3;
  v7 = a4;
  v8 = a2;
  if ( !a2 || !a3 || !a4 || !a5 || !a6 )
    return 2;
  if ( dword_2F847C )
    return 0;
  result = curl_global_init(a1);
  if ( !result )
  {
    Curl_cmalloc = v8;
    Curl_cfree = v6;
    Curl_cstrdup = a5;
    Curl_crealloc = v7;
    Curl_ccalloc = a6;
  }
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);
// 2F847C: using guessed type int dword_2F847C;

//----- (00068544) --------------------------------------------------------
void curl_global_cleanup()
{
  if ( dword_2F847C )
  {
    if ( !--dword_2F847C )
    {
      Curl_global_host_cache_dtor();
      ares_library_cleanup();
      dword_2F8480 = 0;
    }
  }
}
// 2F847C: using guessed type int dword_2F847C;
// 2F8480: using guessed type int dword_2F8480;

//----- (00068564) --------------------------------------------------------
int __fastcall curl_easy_init(int a1, int a2, int a3)
{
  int result; // r0
  int v4; // [sp+4h] [bp-Ch]
  int v5; // [sp+8h] [bp-8h]

  v4 = a2;
  v5 = a3;
  if ( !dword_2F847C && curl_global_init(3) || Curl_open(&v4) )
    result = 0;
  else
    result = v4;
  return result;
}
// 2F847C: using guessed type int dword_2F847C;

//----- (00068594) --------------------------------------------------------
signed int curl_easy_setopt(int a1, unsigned int a2, ...)
{
  signed int result; // r0
  va_list varg_r2; // [sp+10h] [bp-8h]

  va_start(varg_r2, a2);
  if ( a1 )
    result = Curl_setopt(a1, a2, (int *)varg_r2);
  else
    result = 43;
  return result;
}

//----- (000685B2) --------------------------------------------------------
signed int __fastcall curl_easy_perform(int **a1)
{
  int **v1; // r4
  int *v2; // r3
  int *v3; // r3
  int *v4; // r0
  int *v5; // r0
  signed int result; // r0
  int *v7; // r0

  v1 = a1;
  if ( !a1 )
    return 43;
  v2 = a1[4];
  if ( !v2 || !v2[5] )
  {
    if ( *((_BYTE *)a1 + 693) )
    {
      v3 = a1[1];
      if ( v3 != (int *)((char *)&dword_0 + 2) )
      {
        if ( v3 == (int *)((char *)&dword_0 + 1) )
        {
          Curl_hash_destroy(*a1);
          v1[1] = 0;
          *v1 = 0;
        }
        v4 = (int *)Curl_global_host_cache_init();
        if ( v4 )
        {
          *v1 = v4;
          v1[1] = &dword_0 + 2;
        }
      }
    }
    if ( !*v1 )
    {
      v1[1] = &dword_0 + 1;
      v5 = Curl_mk_dnscache();
      *v1 = v5;
      if ( !v5 )
        goto LABEL_20;
    }
  }
  if ( v1[287] || (v7 = Curl_mk_connc(0, -1), (v1[287] = v7) != 0) )
    result = Curl_perform(v1);
  else
LABEL_20:
    result = 27;
  return result;
}
// 0: using guessed type int dword_0;

//----- (00068628) --------------------------------------------------------
int __fastcall curl_easy_cleanup(int result, int a2)
{
  if ( result )
    result = Curl_close(result, a2);
  return result;
}

//----- (00068630) --------------------------------------------------------
int __fastcall Curl_easy_addmulti(int result, int a2)
{
  *(_DWORD *)(result + 8) = a2;
  if ( !a2 )
    *(_DWORD *)(result + 1144) = 0;
  return result;
}

//----- (0006863A) --------------------------------------------------------
void *__fastcall Curl_easy_initHandleData(int a1)
{
  int v1; // r4
  void *result; // r0

  v1 = a1;
  result = memset((void *)(a1 + 24), 0, 0x100u);
  *(_QWORD *)(v1 + 40) = -1LL;
  return result;
}

//----- (00068658) --------------------------------------------------------
signed int curl_easy_getinfo(int a1, unsigned int a2, ...)
{
  int varg_r2; // [sp+10h] [bp-8h]
  va_list varg_r2a; // [sp+10h] [bp-8h]
  va_list varg_r3; // [sp+14h] [bp-4h]

  va_start(varg_r3, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(varg_r3, _DWORD);
  return Curl_getinfo(a1, a2, varg_r2, (int)varg_r2a);
}

//----- (00068674) --------------------------------------------------------
int __fastcall curl_easy_duphandle(int a1)
{
  int v1; // r5
  int v2; // r4
  void *v3; // r0
  int v4; // r3
  int *v5; // r0
  _DWORD *v6; // r0
  int v7; // r0
  const char *v8; // r0
  char *v9; // r0
  const char *v10; // r0
  char *v11; // r0
  _DWORD *v13; // r0
  void *v14; // r0
  int v15; // r0
  void *v16; // r0
  void *v17; // r0

  v1 = a1;
  v2 = Curl_ccalloc(34320, 1);
  if ( !v2 )
    return v2;
  v3 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(0x100u);
  *(_DWORD *)(v2 + 1164) = v3;
  if ( v3 )
  {
    *(_DWORD *)(v2 + 1168) = 256;
    if ( !Curl_dupset(v2, v1) )
    {
      *(_DWORD *)(v2 + 1148) = 0;
      *(_DWORD *)(v2 + 1160) = -1;
      *(_DWORD *)(v2 + 944) = *(_DWORD *)(v1 + 944);
      *(_BYTE *)(v2 + 936) = *(_BYTE *)(v1 + 936);
      v4 = *(_DWORD *)(v1 + 884);
      if ( !v4
        || (v6 = Curl_cookie_init(v1, *(const char **)(v4 + 4), *(_DWORD **)(v2 + 884), *(_BYTE *)(v1 + 488)),
            (*(_DWORD *)(v2 + 884) = v6) != 0) )
      {
        v5 = *(int **)(v1 + 880);
        if ( !v5 || (v7 = Curl_slist_duplicate(v5), (*(_DWORD *)(v2 + 880) = v7) != 0) )
        {
          v8 = *(const char **)(v1 + 864);
          if ( v8 )
          {
            v9 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v8);
            *(_DWORD *)(v2 + 864) = v9;
            if ( !v9 )
              goto LABEL_19;
            *(_BYTE *)(v2 + 868) = 1;
          }
          v10 = *(const char **)(v1 + 872);
          if ( v10 )
          {
            v11 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v10);
            *(_DWORD *)(v2 + 872) = v11;
            if ( !v11 )
              goto LABEL_19;
            *(_BYTE *)(v2 + 876) = 1;
          }
          if ( !ares_init((_DWORD *)(v2 + 34104)) )
          {
            Curl_easy_initHandleData(v2);
            *(_DWORD *)(v2 + 34312) = -1059136595;
            return v2;
          }
        }
      }
    }
  }
LABEL_19:
  v13 = *(_DWORD **)(v2 + 1148);
  if ( v13 && !v13[2] )
    Curl_rm_connc(v13);
  v14 = *(void **)(v2 + 1164);
  if ( v14 )
    ((void (__cdecl *)(void *))Curl_cfree)(v14);
  v15 = *(_DWORD *)(v2 + 880);
  if ( v15 )
    curl_slist_free_all(v15);
  v16 = *(void **)(v2 + 864);
  if ( v16 )
    ((void (__cdecl *)(void *))Curl_cfree)(v16);
  v17 = *(void **)(v2 + 872);
  if ( v17 )
    ((void (__cdecl *)(void *))Curl_cfree)(v17);
  Curl_freeset(v2);
  ((void (__cdecl *)(void *))Curl_cfree)((void *)v2);
  return 0;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000687BC) --------------------------------------------------------
void *__fastcall curl_easy_reset(int a1)
{
  int v1; // r6
  int v2; // r4
  int v3; // r0
  void *result; // r0

  v1 = a1 + 34048;
  v2 = a1;
  Curl_safefree(*(_DWORD *)(a1 + 34176));
  v3 = *(_DWORD *)(v1 + 152);
  *(_DWORD *)(v1 + 128) = 0;
  Curl_safefree(v3);
  *(_DWORD *)(v1 + 152) = 0;
  Curl_freeset(v2);
  memset((void *)(v2 + 280), 0, 0x248u);
  Curl_init_userdefined((_DWORD *)(v2 + 280));
  memset((void *)(v2 + 888), 0, 0x100u);
  result = Curl_easy_initHandleData(v2);
  *(_DWORD *)(v2 + 944) |= 0x10u;
  *(_QWORD *)(v2 + 33944) = -1LL;
  return result;
}

//----- (0006882C) --------------------------------------------------------
signed int __fastcall curl_easy_pause(_DWORD *a1, char a2)
{
  signed int v2; // r4
  signed int v3; // r2
  unsigned int v4; // r3
  int v5; // r5
  int v6; // r8
  int v7; // r2
  const char *v8; // r10
  size_t v9; // r4
  int v10; // r7
  signed int v11; // r6
  int v12; // r0
  _DWORD *v13; // r11
  void *v14; // r0
  int v16; // [sp+0h] [bp-30h]
  int v17; // [sp+4h] [bp-2Ch]

  if ( a2 & 1 )
    v2 = 16;
  else
    v2 = 0;
  if ( a2 & 4 )
    v3 = 32;
  else
    v3 = 0;
  v4 = a1[61] & 0xFFFFFFCF | v2 | v3;
  a1[61] = v4;
  if ( v4 & 0x10 )
    return 0;
  v5 = (int)(a1 + 8448);
  v6 = a1[8492];
  if ( !v6 )
    return 0;
  v7 = a1[8494];
  v8 = (const char *)a1[8492];
  v9 = a1[8493];
  a1[8492] = 0;
  v16 = v7;
  v17 = (int)(a1 + 8512);
  do
  {
    v10 = v9 >= 0x4000 ? 0x4000 : v9;
    v11 = Curl_client_write(*(int **)(v17 + 156), v16, v8, v10);
    if ( v11 )
      break;
    v12 = *(_DWORD *)(v5 + 176);
    v13 = (_DWORD *)(v5 + 176);
    if ( v12 && v9 != v10 )
    {
      v14 = (void *)Curl_crealloc(v12, v9);
      if ( v14 )
      {
        *v13 = v14;
        memcpy(v14, v8, v9);
        *(_DWORD *)(v5 + 180) = v9;
      }
      else
      {
        Curl_cfree(*v13);
        *v13 = 0;
        v11 = 27;
      }
      break;
    }
    v9 -= v10;
    v8 += v10;
  }
  while ( v9 );
  Curl_cfree(v6);
  return v11;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00068918) --------------------------------------------------------
signed int __fastcall curl_easy_recv(int a1, void *a2, size_t a3, _DWORD *a4)
{
  void *v4; // r7
  size_t v5; // r6
  _DWORD *v6; // r5
  int v7; // r4
  int v8; // r0
  int v10; // [sp+Ch] [bp-24h]
  int v11; // [sp+10h] [bp-20h]
  int v12; // [sp+14h] [bp-1Ch]

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( !a1 )
    return 43;
  if ( *(_BYTE *)(a1 + 697) )
  {
    v7 = sub_68410(a1, (int)&v10, &v12);
    if ( !v7 )
    {
      *v6 = 0;
      v8 = Curl_read(v12, v10, v4, v5, (int)&v11);
      if ( v8 == -1 )
      {
        v7 = 81;
      }
      else if ( v8 )
      {
        v7 = v8;
      }
      else
      {
        *v6 = v11;
      }
    }
  }
  else
  {
    v7 = 1;
    Curl_failf(a1, "CONNECT_ONLY is required!");
  }
  return v7;
}

//----- (00068974) --------------------------------------------------------
int __fastcall curl_easy_send(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  _DWORD *v4; // r4
  const void *v5; // r6
  size_t v6; // r5
  int result; // r0
  int v8; // [sp+Ch] [bp-1Ch]
  int v9; // [sp+10h] [bp-18h]
  int *v10; // [sp+14h] [bp-14h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  v10 = 0;
  if ( !a1 )
    return 43;
  if ( *(_BYTE *)(a1 + 697) )
  {
    result = sub_68410(a1, (int)&v8, &v10);
    if ( !result )
    {
      *v4 = 0;
      result = Curl_write(v10, v8, v5, v6, &v9);
      if ( v9 == -1 )
      {
        result = 55;
      }
      else if ( result || v9 )
      {
        *v4 = v9;
      }
      else
      {
        result = 81;
      }
    }
  }
  else
  {
    Curl_failf(a1, "CONNECT_ONLY is required!");
    result = 1;
  }
  return result;
}

//----- (000689D4) --------------------------------------------------------
signed int __fastcall sub_689D4(int a1, signed int a2)
{
  signed int result; // r0

  result = Curl_socket_ready(-1, a1, a2);
  if ( result != -1 )
  {
    if ( result )
    {
      result &= 4u;
      if ( result )
        result = 2;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}

//----- (000689F8) --------------------------------------------------------
bool __fastcall sub_689F8(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  int v3; // r0
  int v4; // r1
  int v5; // r2
  _BOOL4 result; // r0
  int optval; // [sp+8h] [bp-10h]
  socklen_t optlen; // [sp+Ch] [bp-Ch]

  v2 = a2;
  optval = 0;
  optlen = 4;
  v3 = getsockopt(a1, 1, 4, &optval, &optlen);
  if ( v3 )
    optval = *(_DWORD *)_errno(v3, v4, v5);
  if ( optval )
    result = (unsigned int)(optval - 106) <= 0;
  else
    result = 1;
  if ( v2 )
    *v2 = optval;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00068A34) --------------------------------------------------------
signed int __fastcall sub_68A34(int *a1, _DWORD *a2, signed int a3, _BYTE *a4)
{
  unsigned int v4; // r10
  int *v5; // r4
  char *v6; // r9
  int *v7; // r7
  int v8; // r8
  int v9; // r5
  int v10; // r6
  socklen_t v11; // r2
  const void *v12; // r1
  int (__fastcall *v13)(_DWORD); // r3
  int v14; // r0
  int v15; // r5
  char *v16; // r0
  const char *v17; // r1
  int v18; // r8
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int *v22; // r0
  int v23; // r2
  int v24; // r3
  int v25; // r0
  int (__fastcall *v26)(_DWORD, int, _DWORD); // r3
  const char *v27; // r8
  signed int v28; // r3
  size_t v29; // r0
  int v30; // r0
  int v31; // r1
  int v32; // r2
  int *v33; // r0
  int v34; // r11
  int v35; // r2
  int v36; // r3
  int v37; // r0
  int v38; // r1
  int *v39; // r3
  socklen_t i; // r11
  int v41; // r0
  int v42; // r1
  int v43; // r2
  int v44; // r0
  int v45; // r1
  int v46; // r2
  int *v47; // r0
  int v48; // r2
  int v49; // r0
  char *v50; // r1
  int v51; // r3
  int v52; // r0
  int *v53; // r0
  int v54; // r2
  int v55; // r0
  int v56; // r1
  int v57; // r2
  int *v58; // r0
  int v59; // r2
  int v60; // r3
  int v61; // r1
  int v62; // r0
  _BOOL4 v63; // r0
  int v64; // r2
  int v65; // r1
  int v66; // r0
  signed int result; // r0
  int v68; // [sp+Ch] [bp-35Ch]
  int v69; // [sp+10h] [bp-358h]
  _BYTE *v70; // [sp+14h] [bp-354h]
  signed int v71; // [sp+18h] [bp-350h]
  int v72; // [sp+20h] [bp-348h]
  int *v73; // [sp+24h] [bp-344h]
  int optval; // [sp+28h] [bp-340h]
  char buf; // [sp+2Ch] [bp-33Ch]
  char s; // [sp+ACh] [bp-2BCh]
  __int16 v77; // [sp+AEh] [bp-2BAh]
  char v78; // [sp+B0h] [bp-2B8h]
  char v79; // [sp+12Ch] [bp-23Ch]
  int v80; // [sp+1ACh] [bp-1BCh]
  int v81; // [sp+1B0h] [bp-1B8h]
  int v82; // [sp+1B4h] [bp-1B4h]
  socklen_t len; // [sp+1B8h] [bp-1B0h]
  char dest; // [sp+1BCh] [bp-1ACh]
  char v85; // [sp+1BEh] [bp-1AAh]
  char cp; // [sp+1C0h] [bp-1A8h]
  int v87; // [sp+23Ch] [bp-12Ch]
  int v88; // [sp+240h] [bp-128h]
  int v89; // [sp+33Ch] [bp-2Ch]

  v5 = &v80;
  v6 = (char *)a2[1];
  v70 = a4;
  v7 = a1;
  v71 = a3;
  v8 = a1[32];
  v9 = a2[3];
  v10 = *a1;
  v11 = a2[4];
  v12 = (const void *)a2[6];
  v80 = (int)v6;
  if ( v11 > 0x80 )
    len = 128;
  else
    len = v11;
  v81 = v8;
  v82 = v9;
  memcpy(&dest, v12, len);
  *v70 = 0;
  v13 = *(int (__fastcall **)(_DWORD))(v10 + 392);
  if ( v13 )
    v14 = v13(*(_DWORD *)(v10 + 396));
  else
    v14 = socket((int)v6, v8, v9);
  v15 = v14;
  if ( v14 == -1 )
    goto LABEL_66;
  if ( v80 == 1 )
  {
    v6 = &v85;
    Curl_infof(v10, "  Trying %s... ", &v85);
    curl_msnprintf(v10 + 34256, 46, "%s", &v85);
    v16 = (char *)(v7 + 15);
    v17 = (const char *)(v10 + 34256);
  }
  else
  {
    if ( !inet_ntop(v80, &cp, &buf, 0x80u) )
      goto LABEL_13;
    v6 = (char *)(v10 + 34256);
    Curl_infof(v10, "  Trying %s... ", &buf);
    curl_msnprintf(v10 + 34256, 46, "%s", &buf);
    v16 = (char *)(v7 + 15);
    v17 = (const char *)(v10 + 34256);
  }
  strcpy(v16, v17);
LABEL_13:
  if ( *(_BYTE *)(v10 + 694) )
  {
    v18 = *v7;
    optval = *(unsigned __int8 *)(*v7 + 694);
    v19 = setsockopt(v15, 6, 1, &optval, 4u);
    if ( v19 >= 0 )
    {
      Curl_infof(v18, "TCP_NODELAY set\n");
    }
    else
    {
      v22 = (int *)_errno(v19, v20, v21);
      v25 = Curl_strerror((int)v7, *v22, v23, v24);
      Curl_infof(v18, "Could not set TCP_NODELAY: %s\n", v25);
    }
  }
  v26 = *(int (__fastcall **)(_DWORD, int, _DWORD))(v10 + 384);
  if ( v26 )
  {
    v72 = v26(*(_DWORD *)(v10 + 388), v15, 0);
    if ( v72 )
      goto LABEL_65;
  }
  v6 = (char *)v80;
  v5 = (int *)*v7;
  v87 = 0;
  v73 = 0;
  v27 = (const char *)v5[185];
  v4 = *((unsigned __int16 *)v5 + 176);
  v68 = v5[89];
  memset(&v88, 0, 0xFCu);
  if ( !v27 && !v4 )
  {
LABEL_49:
    curlx_nonblock(v15);
    if ( v7[32] == 1 )
    {
      v5 = (int *)connect(v15, (const struct sockaddr *)&dest, len);
      if ( v5 == (int *)-1 )
      {
        v58 = (int *)_errno(-1, v56, v57);
        v61 = *v58;
        v72 = *v58;
        if ( v72 != 11 && v61 != 115 )
        {
          v62 = Curl_strerror((int)v7, v61, v59, v60);
          Curl_failf(v10, "Failed to connect to %s: %s", &buf, v62);
          *(_DWORD *)(v10 + 33988) = v72;
          goto LABEL_59;
        }
        v5 = (int *)sub_689D4(v15, v71);
      }
      if ( v5 == (int *)((char *)&dword_0 + 1) && *(_DWORD *)(v10 + 1144) == 2 )
        goto LABEL_66;
    }
    else
    {
      v5 = 0;
    }
LABEL_59:
    v63 = sub_689F8(v15, &v72);
    if ( v5 )
    {
      if ( v5 == (int *)((char *)&dword_0 + 1) )
      {
        Curl_infof(v10, "Timeout\n");
        goto LABEL_65;
      }
    }
    else if ( v63 )
    {
      *v70 = 1;
      Curl_infof(v10, "connected\n");
LABEL_66:
      result = v15;
      goto LABEL_67;
    }
    v65 = v72;
    *(_DWORD *)(v10 + 33988) = v72;
    v66 = Curl_strerror((int)v7, v65, v64, v10 + 33792);
    Curl_infof(v10, "%s\n", v66);
    goto LABEL_65;
  }
  memset(&s, 0, 0x80u);
  if ( v27 && strlen(v27) <= 0xFE )
  {
    if ( Curl_if2ip((int)v6, v27, (char *)&v87, 0x100u) )
    {
      Curl_infof((int)v5, "Local Interface %s is ip %s using address family %i\n", v27, &v87, v6);
      v29 = strlen(v27);
      v30 = setsockopt(v15, 1, 25, v27, v29 + 1);
      if ( v30 )
      {
        v33 = (int *)_errno(v30, v31, v32);
        v34 = *v33;
        v37 = Curl_strerror((int)v7, *v33, v35, v36);
        Curl_infof((int)v5, "SO_BINDTODEVICE %s failed with errno %d: %s; will do regular bind\n", v27, v34, v37);
      }
    }
    else
    {
      v38 = v5[155];
      if ( v6 == (_BYTE *)&dword_0 + 2 )
        v28 = 1;
      if ( v6 == (_BYTE *)&dword_0 + 2 )
        v5[155] = v28;
      v69 = v38;
      if ( Curl_resolv(v7, v27, 0, (const char **)&v73) == 1 )
        Curl_wait_for_resolv(v7, &v73);
      v39 = v73;
      v5[155] = v69;
      if ( !v39 )
      {
        Curl_failf((int)v5, "Couldn't bind to '%s'", v27);
        goto LABEL_65;
      }
      Curl_printable_address(*v39, (char *)&v87, 0x100u);
      Curl_infof((int)v5, "Name '%s' family %i resolved to '%s' family %i\n", v27, v6, &v87, *(_DWORD *)(*v73 + 4));
      Curl_resolv_unlock((int)v5, (int)v73);
    }
    if ( v6 == (_BYTE *)&dword_0 + 2 )
      goto LABEL_68;
  }
  else if ( v6 == (_BYTE *)&dword_0 + 2 )
  {
    *(_WORD *)&s = 2;
    v77 = __rev16(v4);
    goto LABEL_36;
  }
LABEL_38:
  for ( i = 0; ; i = 16 )
  {
    v6 = &s;
    while ( 1 )
    {
      v41 = bind(v15, (const struct sockaddr *)&s, i);
      if ( v41 >= 0 )
        break;
      if ( --v68 <= 0 )
      {
        v53 = (int *)_errno(v41, v42, v43);
        v10 = *v53;
        v5[8497] = *v53;
        v55 = Curl_strerror((int)v7, v10, v54, (int)(v5 + 8448));
        v50 = "bind failed with errno %d: %s";
        v51 = v55;
        v52 = (int)v5;
        goto LABEL_48;
      }
      Curl_infof((int)v5, "Bind to local port %d failed, trying next\n", v4);
      v4 = (unsigned __int16)(v4 + 1);
      if ( *(unsigned __int16 *)&s == 2 )
        v77 = __rev16(v4);
    }
    v6 = &v79;
    optval = 128;
    memset(&v79, 0, 0x80u);
    v44 = getsockname(v15, (struct sockaddr *)&v79, (socklen_t *)&optval);
    if ( v44 >= 0 )
    {
      Curl_infof((int)v5, "Local port: %d\n", v4);
      *((_BYTE *)v7 + 319) = 1;
      goto LABEL_49;
    }
    v47 = (int *)_errno(v44, v45, v46);
    v10 = *v47;
    v5[8497] = *v47;
    v49 = Curl_strerror((int)v7, v10, v48, (int)(v5 + 8448));
    v50 = "getsockname() failed with errno %d: %s";
    v51 = v49;
    v52 = (int)v5;
LABEL_48:
    Curl_failf(v52, v50, v10, v51);
LABEL_65:
    close(v15);
    result = -1;
LABEL_67:
    if ( v89 == _stack_chk_guard )
      break;
LABEL_68:
    if ( inet_pton((int)v6, (const char *)&v87, &v78) <= 0 )
      goto LABEL_38;
    *(_WORD *)&s = (_WORD)v6;
    v77 = __rev16(v4);
LABEL_36:
    ;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00068EF0) --------------------------------------------------------
signed int __fastcall sub_68EF0(int *a1, int a2, _BYTE *a3)
{
  int v3; // r7
  _BYTE *v4; // r6
  int *v5; // r5
  int v6; // r4
  _DWORD *i; // r4
  signed int v8; // r0

  v3 = (int)&a1[a2];
  v4 = a3;
  v5 = a1;
  v6 = a2;
  close(*(_DWORD *)(v3 + 212));
  *(_DWORD *)(v3 + 212) = -1;
  *v4 = 0;
  if ( !v6 )
  {
    for ( i = *(_DWORD **)(v5[14] + 28); i; i = (_DWORD *)i[7] )
    {
      v8 = sub_68A34(v5, i, 0, v4);
      if ( v8 != -1 )
      {
        v5[53] = v8;
        v5[14] = (int)i;
        return 1;
      }
    }
  }
  return 1;
}

//----- (00068F38) --------------------------------------------------------
int __fastcall Curl_timeleft(int a1, int *a2, int a3)
{
  _DWORD *v3; // r4
  signed int v4; // r5
  signed int v5; // r6
  int v6; // r3
  int v8; // [sp+0h] [bp-18h]
  int *v9; // [sp+4h] [bp-14h]

  v8 = a1;
  v9 = a2;
  v3 = *(_DWORD **)a1;
  v4 = 300000;
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 424);
  if ( !a3 )
    v4 = 0;
  v6 = v5 > 0;
  if ( a3 && v3[107] > 0 )
    v6 |= 2u;
  switch ( v6 )
  {
    case 2:
      v4 = v3[107];
      break;
    case 3:
      v4 = v3[107];
      if ( v4 >= v5 )
        v4 = *(_DWORD *)(*(_DWORD *)a1 + 424);
      break;
    case 1:
      v4 = *(_DWORD *)(*(_DWORD *)a1 + 424);
      break;
    default:
      if ( !a3 )
        return 0;
      break;
  }
  if ( !a2 )
  {
    curlx_tvnow(&v8);
    a2 = &v8;
  }
  return v4 - curlx_tvdiff(*a2, a2[1], v3[258], v3[259]);
}

//----- (00068FAC) --------------------------------------------------------
signed int __fastcall Curl_is_connected(int a1, int a2, _BYTE *a3, int a4)
{
  int *v4; // r5
  signed int v5; // r8
  int v6; // r10
  int *v7; // r4
  int v8; // r9
  signed int v9; // r7
  _BYTE *v10; // r6
  int v11; // r1
  signed int result; // r0
  signed int v13; // r0
  int v14; // r2
  int v15; // r3
  int v16; // r7
  int v17; // r6
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r0
  int v22; // r1
  int v23; // r2
  int v24; // r1
  int v25; // r7
  int v26; // r6
  int v27; // r2
  int v28; // r0
  int v29; // [sp+4h] [bp-2Ch]
  _BYTE *v30; // [sp+8h] [bp-28h]
  int v31; // [sp+Ch] [bp-24h]

  v29 = a2;
  v30 = a3;
  v31 = a4;
  v4 = *(int **)a1;
  v5 = 0;
  v6 = *(_DWORD *)(a1 + 4 * a2 + 212);
  v7 = (int *)a1;
  *a3 = 0;
  v8 = a2;
  v9 = *(unsigned __int8 *)(a1 + 305);
  v10 = a3;
  if ( *(_BYTE *)(a1 + 305) )
  {
    Curl_expire(v4, v4[106]);
LABEL_8:
    result = v5;
    *v10 = 1;
    return result;
  }
  v11 = Curl_timeleft(a1, (int *)*(unsigned __int8 *)(a1 + 305), 1);
  if ( v11 < 0 )
  {
    Curl_failf((int)v4, "Connection time-out");
    return 28;
  }
  Curl_expire(v4, v11);
  v13 = sub_689D4(v6, v9);
  v5 = v13;
  if ( v13 )
  {
    if ( v13 == 1 )
    {
      result = v9;
    }
    else
    {
      v31 = v9;
      if ( v13 == 2 )
      {
        sub_689F8(v6, &v31);
        v19 = v31;
        v4[8497] = v31;
        v21 = Curl_strerror((int)v7, v19, v20, (int)(v4 + 8448));
        Curl_infof((int)v4, "%s\n", v21);
      }
      else
      {
        Curl_infof((int)v4, "Connection failed\n");
      }
      result = sub_68EF0(v7, v8, v10);
      if ( result )
      {
        v24 = *(_DWORD *)_errno(result, v22, v23);
        v31 = v24;
        v4[8497] = v24;
        v25 = v7[35];
        v26 = v7[41];
        v28 = Curl_strerror((int)v7, v24, v27, (int)(v4 + 8448));
        Curl_failf((int)v4, "Failed connect to %s:%d; %s", v25, v26, v28, v29, v30);
        return 7;
      }
    }
  }
  else
  {
    if ( sub_689F8(v6, &v31) )
      goto LABEL_8;
    v4[8497] = v31;
    Curl_infof((int)v4, "Connection failed\n");
    result = sub_68EF0(v7, v8, v10);
    if ( result )
    {
      v16 = v7[35];
      v17 = v7[41];
      v18 = Curl_strerror((int)v7, v31, v14, v15);
      Curl_failf((int)v4, "Failed connect to %s:%d; %s", v16, v17, v18, v29, v30);
      return 7;
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000690EC) --------------------------------------------------------
signed int __fastcall Curl_connecthost(int **a1, int *a2, signed int *a3, _DWORD *a4, _BYTE *a5)
{
  int *v5; // r4
  int *v6; // r9
  int *v7; // r6
  _DWORD *v8; // r10
  int v9; // r11
  int v10; // r0
  bool v11; // nf
  int v12; // r7
  int v13; // r0
  char *v14; // r1
  int v15; // r0
  _DWORD *v16; // r6
  signed int v17; // r0
  signed int result; // r0
  signed int *v19; // [sp+4h] [bp-3Ch]
  int v20; // [sp+8h] [bp-38h]
  int v21; // [sp+Ch] [bp-34h]
  __time_t v22; // [sp+10h] [bp-30h]
  int v23; // [sp+14h] [bp-2Ch]

  v5 = *a1;
  v6 = (int *)a1;
  v7 = a2;
  v19 = a3;
  v8 = a4;
  curlx_tvnow(&v22);
  v9 = 0;
  *a5 = 0;
  v10 = Curl_timeleft((int)v6, &v22, 1);
  v12 = v10;
  v11 = v10 < 0;
  v13 = (int)v5;
  if ( v11 )
  {
    v14 = "Connection time-out";
LABEL_12:
    Curl_failf(v13, v14);
    result = 28;
  }
  else
  {
    Curl_expire(v5, v12);
    v15 = Curl_num_addresses(*v7);
    v16 = (_DWORD *)*v7;
    if ( v5[286] != 2 )
      v9 = v12 / v15;
    while ( v16 )
    {
      v17 = sub_68A34(v6, v16, v9, a5);
      if ( v17 != -1 )
        goto LABEL_14;
      curlx_tvnow(&v20);
      v12 -= curlx_tvdiff(v20, v21, v22, v23);
      if ( v12 < 0 )
      {
        v13 = (int)v5;
        v14 = "connect() timed out!";
        goto LABEL_12;
      }
      v16 = (_DWORD *)v16[7];
      v22 = v20;
      v23 = v21;
    }
    v17 = -1;
LABEL_14:
    *v19 = v17;
    if ( v17 == -1 )
    {
      Curl_failf((int)v5, "couldn't connect to host");
      result = 7;
    }
    else
    {
      if ( v8 )
        *v8 = v16;
      result = 0;
      ++v5[8561];
    }
  }
  return result;
}

//----- (000691D0) --------------------------------------------------------
int __fastcall Curl_getconnectinfo(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3
  _DWORD *v7; // [sp+4h] [bp-Ch]

  v7 = a2;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 1160);
  if ( v4 == -1 )
    goto LABEL_11;
  v5 = *(_DWORD *)(**(_DWORD **)(a1 + 1148) + 4 * v4);
  if ( !v5 )
    goto LABEL_11;
  if ( a3 )
    *a3 = v5;
  *a2 = *(_DWORD *)(v5 + 212);
  if ( *(_BYTE *)(v5 + 220) || !recv(*(_DWORD *)(v5 + 212), (char *)&v7 + 3, 1u, 2) )
LABEL_11:
    *v3 = -1;
  return 0;
}

//----- (00069218) --------------------------------------------------------
int __fastcall sub_69218(int a1, _DWORD *a2)
{
  int v2; // r6
  _DWORD *v3; // r5

  v2 = a1;
  v3 = a2;
  if ( a2[1] )
    ((void (*)(void))Curl_cfree)();
  if ( *v3 )
    (*(void (**)(void))(v2 + 12))();
  return Curl_cfree(v3);
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00069240) --------------------------------------------------------
signed int __fastcall Curl_hash_init(int *a1, int a2, int a3, int a4, int a5)
{
  int *v5; // r4
  int v6; // r6
  int v7; // r5
  int v8; // r0
  int v10; // r7
  int v11; // r7
  int v12; // r6

  v5 = a1;
  v6 = a2;
  if ( a2 )
  {
    if ( a3 )
    {
      if ( a4 )
      {
        if ( a5 )
        {
          a1[2] = a4;
          v7 = 0;
          a1[3] = a5;
          a1[1] = a3;
          a1[5] = 0;
          a1[4] = a2;
          v8 = Curl_cmalloc(4 * a2);
          *v5 = v8;
          if ( v8 )
          {
            while ( 1 )
            {
              if ( v7 >= v6 )
                return 0;
              v10 = *v5;
              *(_DWORD *)(v10 + 4 * v7) = Curl_llist_alloc((int)sub_69218);
              if ( !*(_DWORD *)(*v5 + 4 * v7) )
                break;
              ++v7;
            }
            v11 = 4 * v7;
            v12 = 0;
            while ( 1 )
            {
              v11 -= 4;
              if ( v12 == v7 )
                break;
              ++v12;
              Curl_llist_destroy(*(_DWORD *)(*v5 + v11), 0);
            }
            Curl_cfree(*v5);
          }
        }
      }
    }
  }
  return 1;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000692D4) --------------------------------------------------------
int *__fastcall Curl_hash_alloc(int a1, int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r5
  int v6; // r8
  int v7; // r7
  int *v8; // r0
  int *v9; // r4

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = a1;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  if ( !a4 )
    return 0;
  v8 = (int *)Curl_cmalloc(24);
  v9 = v8;
  if ( !v8 )
    return 0;
  if ( Curl_hash_init(v8, v7, v4, v5, v6) )
  {
    Curl_cfree(v9);
    return 0;
  }
  return v9;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00069328) --------------------------------------------------------
int __fastcall Curl_hash_add(int *a1, const void *a2, size_t a3, int a4)
{
  int *v4; // r4
  int v5; // r5
  const void *v6; // r10
  size_t v7; // r6
  int v8; // r9
  _DWORD *i; // r5
  int v10; // r11
  int result; // r0
  _DWORD *v12; // r7
  void *v13; // r0
  void *v14; // r11
  _DWORD *v15; // [sp+4h] [bp-2Ch]

  v4 = a1;
  v5 = *a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v15 = *(_DWORD **)(v5 + 4 * ((int (__fastcall *)(const void *, size_t, int))a1[1])(a2, a3, a1[4]));
  for ( i = (_DWORD *)*v15; i; i = (_DWORD *)i[2] )
  {
    v10 = *i;
    if ( ((int (__fastcall *)(_DWORD, _DWORD, const void *, size_t))v4[2])(
           *(_DWORD *)(*i + 4),
           *(_DWORD *)(*i + 8),
           v6,
           v7) )
    {
      ((void (__fastcall *)(int))v4[3])(v8);
      return *(_DWORD *)v10;
    }
  }
  v12 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(0xCu);
  if ( !v12 )
    return 0;
  v13 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v7);
  v14 = v13;
  if ( !v13 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v12);
    return 0;
  }
  memcpy(v13, v6, v7);
  v12[1] = v14;
  v12[2] = v7;
  *v12 = v8;
  if ( Curl_llist_insert_next(v15, v15[1], (int)v12) )
  {
    result = v8;
    ++v4[5];
  }
  else
  {
    ((void (__cdecl *)(void *))Curl_cfree)((void *)v12[1]);
    ((void (__cdecl *)(void *))Curl_cfree)(v12);
    result = 0;
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000693F8) --------------------------------------------------------
signed int __fastcall Curl_hash_delete(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r4
  int v5; // r9
  int v6; // r8
  _DWORD *v7; // r7
  _DWORD *i; // r4

  v3 = a1;
  v4 = *(_DWORD *)a1;
  v5 = a2;
  v6 = a3;
  v7 = *(_DWORD **)(v4 + 4 * (*(int (__fastcall **)(int, int, _DWORD))(a1 + 4))(a2, a3, *(_DWORD *)(a1 + 16)));
  for ( i = (_DWORD *)*v7; i; i = (_DWORD *)i[2] )
  {
    if ( (*(int (__fastcall **)(_DWORD, _DWORD, int, int))(v3 + 8))(*(_DWORD *)(*i + 4), *(_DWORD *)(*i + 8), v5, v6) )
    {
      Curl_llist_remove((int)v7, i, v3);
      return 0;
    }
  }
  return 1;
}

//----- (00069440) --------------------------------------------------------
int __fastcall Curl_hash_pick(int *a1, int a2, int a3)
{
  int *v3; // r5
  int v4; // r4
  int v5; // r8
  int v6; // r9
  _DWORD *i; // r4
  int v8; // r6

  v3 = a1;
  v4 = *a1;
  v5 = a2;
  v6 = a3;
  for ( i = **(_DWORD ***)(v4 + 4 * ((int (__fastcall *)(int, int, int))a1[1])(a2, a3, a1[4])); i; i = (_DWORD *)i[2] )
  {
    v8 = *i;
    if ( ((int (__fastcall *)(_DWORD, _DWORD, int, int))v3[2])(*(_DWORD *)(*i + 4), *(_DWORD *)(*i + 8), v5, v6) )
      return *(_DWORD *)v8;
  }
  return 0;
}

//----- (00069480) --------------------------------------------------------
int __fastcall Curl_hash_clean(_DWORD *a1)
{
  int v1; // r4
  _DWORD *i; // r5

  v1 = 0;
  for ( i = a1; v1 < i[4]; *(_DWORD *)(*i + 4 * v1++) = 0 )
    Curl_llist_destroy(*(_DWORD *)(*i + 4 * v1), (int)i);
  return Curl_cfree(*i);
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000694B8) --------------------------------------------------------
signed int __fastcall Curl_hash_clean_with_criterium(signed int result, int a2, int (__fastcall *a3)(int, _DWORD))
{
  _DWORD *v3; // r4
  int v4; // r8
  int (__fastcall *v5)(int, _DWORD); // r9
  int i; // r6
  _DWORD *v7; // r7
  _DWORD *j; // r5
  _DWORD *v9; // r10

  v3 = (_DWORD *)result;
  v4 = a2;
  v5 = a3;
  for ( i = 0; i < v3[4]; ++i )
  {
    v7 = *(_DWORD **)(*v3 + 4 * i);
    for ( j = (_DWORD *)*v7; j; j = v9 )
    {
      v9 = (_DWORD *)j[2];
      result = v5(v4, *(_DWORD *)*j);
      if ( result )
      {
        result = Curl_llist_remove((int)v7, j, (int)v3);
        --v3[5];
      }
    }
  }
  return result;
}

//----- (00069500) --------------------------------------------------------
_DWORD *__fastcall Curl_hash_destroy(_DWORD *result)
{
  _DWORD *v1; // r4

  v1 = result;
  if ( result )
  {
    Curl_hash_clean(result);
    result = (_DWORD *)Curl_cfree(v1);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006951C) --------------------------------------------------------
int __fastcall Curl_hash_str(unsigned __int8 *a1, int a2, unsigned int a3)
{
  unsigned __int8 *v3; // r3
  unsigned int v4; // r1
  unsigned int v5; // r0
  int v6; // t1

  v3 = a1;
  v4 = (unsigned int)&a1[a2];
  v5 = 5381;
  while ( (unsigned int)v3 < v4 )
  {
    v6 = *v3++;
    v5 = 33 * v5 ^ v6;
  }
  return v5 % a3;
}

//----- (00069540) --------------------------------------------------------
bool __fastcall Curl_str_key_compare(unsigned __int8 *a1, size_t a2, unsigned __int8 *a3, int a4)
{
  _BOOL4 result; // r0

  if ( a2 != a4 || *a1 != *a3 )
    result = 0;
  else
    result = memcmp(a1, a3, a2) == 0;
  return result;
}

//----- (00069568) --------------------------------------------------------
int __fastcall sub_69568(int result)
{
  if ( result )
    result = Curl_cfree(result);
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00069588) --------------------------------------------------------
int __fastcall sub_69588(_DWORD *a1, int a2, int a3)
{
  return *a1 % a3;
}

//----- (000695A2) --------------------------------------------------------
int __fastcall sub_695A2(int result, int a2)
{
  if ( *(_DWORD *)(result + 16) != a2 )
  {
    *(_DWORD *)(result + 16) = a2;
    if ( a2 == 15 )
      --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(result + 8) + 8) + 68);
  }
  return result;
}

//----- (000695B4) --------------------------------------------------------
int *__fastcall sub_695B4(int a1, int a2)
{
  int **v2; // r6
  _DWORD *v3; // r4
  int v4; // r8
  int v5; // r7
  int *result; // r0
  int v7; // r2
  signed int v8; // r3
  int v9; // [sp+0h] [bp-20h]
  int v10; // [sp+4h] [bp-1Ch]

  v9 = a1;
  v10 = a2;
  v2 = (int **)a1;
  v3 = (_DWORD *)a2;
  curlx_tvnow(&v9);
  v4 = v9;
  v5 = v10;
  result = Curl_splay(0, 0, *v2);
  *v2 = result;
  v7 = result[3];
  if ( v7 < v4 || v7 <= v4 && result[4] <= v5 )
  {
    v8 = 0;
  }
  else
  {
    result = (int *)curlx_tvdiff(result[3], result[4], v9, v10);
    if ( result )
    {
      *v3 = result;
      return result;
    }
    v8 = 1;
  }
  *v3 = v8;
  return result;
}

//----- (00069610) --------------------------------------------------------
int __fastcall sub_69610(_DWORD *a1, _DWORD *a2)
{
  int v2; // r2
  _DWORD *v3; // r3
  int result; // r0
  int v5; // r3
  int v6; // r3

  v2 = a1[2];
  if ( *(_BYTE *)(v2 + 34153) )
    return 0;
  v3 = (_DWORD *)a1[3];
  if ( !v3 )
    return 0;
  if ( (unsigned int)(a1[4] - 2) <= 0xC )
    *v3 = v2;
  switch ( a1[4] )
  {
    case 2:
      result = Curl_resolv_getsock(a1[3], (int)a2, 5, a1[4] - 2);
      break;
    case 3:
    case 4:
      v5 = a1[3];
      *a2 = *(_DWORD *)(v5 + 212);
      if ( *(_BYTE *)(v5 + 309) )
        result = 1;
      else
        result = 0x10000;
      break;
    case 5:
      result = Curl_protocol_getsock(a1[3]);
      break;
    case 7:
    case 8:
      result = Curl_doing_getsock(a1[3]);
      break;
    case 9:
      v6 = a1[3];
      result = 0x10000;
      *a2 = *(_DWORD *)(v6 + 216);
      break;
    case 0xA:
    case 0xB:
    case 0xC:
      result = Curl_single_getsock((_DWORD *)a1[3], a2, 5);
      break;
    default:
      return 0;
  }
  return result;
}

//----- (000696A8) --------------------------------------------------------
_DWORD *__fastcall sub_696A8(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  int v3; // r6
  int v4; // r5
  int v5; // r10
  signed int v6; // r7
  int *v7; // r0
  int v8; // r0
  int v9; // r9
  int v10; // r11
  int *v11; // r7
  int *v12; // r0
  _DWORD *result; // r0
  int i; // r9
  int v15; // r2
  int v16; // r3
  _DWORD *v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r7
  int *v21; // r0
  int **v22; // r7
  int *v23; // r3
  int v24; // r7
  signed int v25; // r3
  int **v26; // r2
  int *v27; // r3
  int v28; // r2
  int v29; // [sp+10h] [bp-50h]
  int v30; // [sp+18h] [bp-48h]
  int v31; // [sp+1Ch] [bp-44h]
  int v32; // [sp+20h] [bp-40h]
  int s; // [sp+24h] [bp-3Ch]
  int v34; // [sp+28h] [bp-38h]
  int v35; // [sp+2Ch] [bp-34h]
  int v36; // [sp+30h] [bp-30h]
  int v37; // [sp+34h] [bp-2Ch]

  v2 = a2;
  v3 = a1;
  s = -1;
  v4 = 0;
  v34 = -1;
  v35 = -1;
  v36 = -1;
  v37 = -1;
  v5 = sub_69610(a2, &s);
  do
  {
    v6 = 1 << (v4 + 16);
    if ( !((v6 | (1 << v4)) & v5) )
      break;
    v7 = *(int **)(v3 + 88);
    v30 = *(&s + v4);
    v8 = Curl_hash_pick(v7, (int)&v30, 4);
    v9 = ((1 << v4) & v5) != 0;
    if ( v6 & v5 )
      v9 |= 2u;
    v10 = v8;
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 12) == v9 )
        goto LABEL_13;
    }
    else
    {
      v11 = *(int **)(v3 + 88);
      v29 = v2[2];
      v12 = *(int **)(v3 + 88);
      v31 = v30;
      v10 = Curl_hash_pick(v12, (int)&v31, 4);
      if ( !v10 )
      {
        result = (_DWORD *)Curl_ccalloc(24, 1);
        v10 = (int)result;
        if ( !result )
          return result;
        *result = v29;
        result[4] = v31;
        if ( !Curl_hash_add(v11, &v31, 4u, (int)result) )
          return (_DWORD *)Curl_cfree(v10);
      }
    }
    (*(void (__fastcall **)(_DWORD, int, int, _DWORD, _DWORD))(v3 + 72))(
      v2[2],
      v30,
      v9,
      *(_DWORD *)(v3 + 76),
      *(_DWORD *)(v10 + 20));
    *(_DWORD *)(v10 + 12) = v9;
LABEL_13:
    ++v4;
  }
  while ( v4 != 5 );
  for ( i = 0; i < v2[13]; ++i )
  {
    v15 = v2[i + 8];
    v16 = 0;
    v30 = v2[i + 8];
    while ( v16 < v4 )
    {
      if ( v15 == *(&s + v16) )
      {
        v30 = -1;
        break;
      }
      ++v16;
    }
    if ( v30 != -1 )
    {
      v17 = (_DWORD *)Curl_hash_pick(*(int **)(v3 + 88), (int)&v30, 4);
      if ( v17 )
      {
        v18 = *v17;
        v19 = *(_DWORD *)(*(_DWORD *)(*v17 + 12) + 12);
        if ( !v19 )
          goto LABEL_24;
        v22 = *(int ***)(v19 + 376);
        if ( v22 && (unsigned int)v22[3] > 1 )
        {
          if ( v18 == v2[2] )
          {
            v23 = *v22;
            v24 = **v22;
            if ( v23 && v24 == v18 )
              *v17 = *(_DWORD *)v23[2];
            else
              *v17 = v24;
          }
          v25 = 0;
        }
        else
        {
          v25 = 1;
        }
        v26 = *(int ***)(v19 + 372);
        if ( !v26 || (unsigned int)v26[3] <= 1 )
        {
          if ( !v25 )
            continue;
LABEL_24:
          (*(void (__fastcall **)(_DWORD, int, signed int, _DWORD, _DWORD))(v3 + 72))(
            v2[2],
            v30,
            4,
            *(_DWORD *)(v3 + 76),
            v17[5]);
          v20 = *(_DWORD *)(v3 + 88);
          v21 = *(int **)(v3 + 88);
          v32 = v30;
          if ( Curl_hash_pick(v21, (int)&v32, 4) )
            Curl_hash_delete(v20, (int)&v32, 4);
          continue;
        }
        if ( *v17 == v2[2] )
        {
          v27 = *v26;
          v28 = **v26;
          if ( v27 && v28 == *v17 )
            *v17 = *(_DWORD *)v27[2];
          else
            *v17 = v28;
        }
      }
    }
  }
  result = memcpy(v2 + 8, &s, 4 * v4);
  v2[13] = v4;
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006989C) --------------------------------------------------------
int __fastcall sub_6989C(int a1, int a2, int a3)
{
  int v3; // r4
  int v5; // r2
  int v6; // r3
  _DWORD *v7; // r3
  _DWORD *v8; // r5
  int v9; // r1
  int v10; // [sp+4h] [bp-14h]
  int v11; // [sp+8h] [bp-10h]

  v10 = a2;
  v11 = a3;
  v3 = a1;
  if ( !*(_DWORD *)(a1 + 108) )
    return 0;
  if ( *(_DWORD *)(a1 + 84) )
    sub_695B4(a1 + 84, (int)&v10);
  else
    v10 = -1;
  v5 = v10;
  if ( v10 < 0 )
    return 0;
  v6 = *(_DWORD *)(v3 + 84);
  if ( *(_DWORD *)(v6 + 12) == *(_DWORD *)(v3 + 116) && *(_DWORD *)(v6 + 16) == *(_DWORD *)(v3 + 120) )
    return 0;
  v7 = (_DWORD *)(v6 + 12);
  v8 = (_DWORD *)(v3 + 116);
  v9 = v7[1];
  *v8 = *v7;
  v8[1] = v9;
  return (*(int (__fastcall **)(int, int, _DWORD))(v3 + 108))(v3, v5, *(_DWORD *)(v3 + 112));
}

//----- (000698F0) --------------------------------------------------------
int *curl_multi_init()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  int *v2; // r6

  v0 = (_DWORD *)Curl_ccalloc(124, 1);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 764702;
    v2 = Curl_mk_dnscache();
    v1[20] = v2;
    if ( !v2 )
    {
LABEL_7:
      ((void (__cdecl *)(void *))Curl_cfree)(v1);
      return v2;
    }
    v2 = Curl_hash_alloc(911, (int)sub_69588, (int)&loc_6957C + 1, (int)sub_69568);
    v1[22] = v2;
    if ( !v2 )
    {
LABEL_6:
      Curl_hash_destroy((_DWORD *)v1[20]);
      goto LABEL_7;
    }
    v2 = Curl_mk_connc(1, -1);
    v1[24] = v2;
    if ( !v2 )
    {
      Curl_hash_destroy((_DWORD *)v1[22]);
      goto LABEL_6;
    }
    v1[1] = v1 + 1;
    v1[2] = v1 + 1;
  }
  return v1;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00069980) --------------------------------------------------------
int __fastcall Curl_multi_canPipeline(int a1)
{
  return *(unsigned __int8 *)(a1 + 92);
}

//----- (00069986) --------------------------------------------------------
int __fastcall Curl_multi_handlePipeBreak(int result)
{
  int v1; // r3

  v1 = *(_DWORD *)(result + 612);
  if ( v1 )
    *(_DWORD *)(v1 + 12) = 0;
  return result;
}

//----- (00069994) --------------------------------------------------------
signed int __fastcall curl_multi_fdset(_DWORD *a1, int a2, int a3, int a4, signed int *a5)
{
  int v5; // r9
  int v6; // r10
  _DWORD *v7; // r6
  _DWORD *v8; // r5
  signed int v9; // r7
  int v10; // r0
  int v11; // r4
  signed int v12; // r3
  signed int result; // r0
  char v14[60]; // [sp+4h] [bp-3Ch]

  v5 = a2;
  v6 = a3;
  v7 = a1;
  if ( !a1 || *a1 != 764702 )
    return 1;
  v8 = (_DWORD *)a1[1];
  v9 = -1;
  while ( v8 != v7 + 1 )
  {
    v10 = sub_69610(v8, v14);
    v11 = 0;
    do
    {
      if ( (v10 >> v11) & 1 )
      {
        v12 = *(_DWORD *)&v14[4 * v11];
        *(_DWORD *)(v5 + 4 * (v12 >> 5)) |= 1 << (v12 & 0x1F);
      }
      else
      {
        v12 = -1;
      }
      if ( (v10 >> (v11 + 16)) & 1 )
      {
        v12 = *(_DWORD *)&v14[4 * v11];
        *(_DWORD *)(v6 + 4 * (v12 >> 5)) |= 1 << (v12 & 0x1F);
      }
      if ( v12 == -1 )
        break;
      ++v11;
      if ( v9 < v12 )
        v9 = v12;
    }
    while ( v11 != 5 );
    v8 = (_DWORD *)*v8;
  }
  result = 0;
  *a5 = v9;
  return result;
}
// 69994: using guessed type char var_3C[60];

//----- (00069A44) --------------------------------------------------------
signed int __fastcall curl_multi_cleanup(int a1)
{
  int v1; // r4
  int v2; // r5
  int v3; // r1
  _DWORD *v4; // r3
  int v5; // r0
  _DWORD *i; // r6
  int v7; // r0
  _DWORD *v8; // r8
  _DWORD *j; // r5
  _DWORD *v10; // r3
  _DWORD *v11; // r9
  int v12; // r0

  v1 = a1;
  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1;
  v2 = 0;
  *(_DWORD *)a1 = 0;
  Curl_hash_destroy(*(_DWORD **)(a1 + 80));
  Curl_hash_destroy(*(_DWORD **)(v1 + 88));
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 88) = 0;
  while ( 1 )
  {
    v4 = *(_DWORD **)(v1 + 96);
    if ( v2 >= v4[1] )
      break;
    v5 = *(_DWORD *)(*v4 + 4 * v2);
    if ( v5 )
    {
      if ( *(_DWORD *)(v5 + 48) & 4 )
      {
        Curl_disconnect((int **)v5);
        *(_DWORD *)(**(_DWORD **)(v1 + 96) + 4 * v2) = 0;
      }
    }
    ++v2;
  }
  for ( i = *(_DWORD **)(v1 + 104); i; i = v8 )
  {
    *(_DWORD *)(i[1] + 34168) = 0;
    v7 = i[1];
    if ( *(_BYTE *)(v7 + 34172) )
      Curl_close(v7, v3);
    v8 = (_DWORD *)*i;
    Curl_cfree(i);
  }
  Curl_rm_connc(*(void **)(v1 + 96));
  for ( j = *(_DWORD **)(v1 + 4); j != (_DWORD *)(v1 + 4); j = v11 )
  {
    v10 = (_DWORD *)j[2];
    v11 = (_DWORD *)*j;
    if ( v10[1] == 3 )
    {
      *v10 = 0;
      *(_DWORD *)(j[2] + 4) = 0;
    }
    *(_DWORD *)(j[2] + 1148) = 0;
    Curl_easy_addmulti(j[2], 0);
    v12 = j[6];
    if ( v12 )
      Curl_cfree(v12);
    Curl_cfree(j);
  }
  Curl_cfree(v1);
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00069B20) --------------------------------------------------------
_DWORD *__fastcall curl_multi_info_read(_DWORD *result, int *a2)
{
  _DWORD *v2; // r3
  _DWORD *i; // r3
  int v4; // r4
  int v5; // r2

  v2 = 0;
  *a2 = 0;
  if ( result )
  {
    if ( *result == 764702 && (v2 = (_DWORD *)result[16]) != 0 )
    {
      for ( i = (_DWORD *)result[1]; i != result + 1; i = (_DWORD *)*i )
      {
        v4 = i[7];
        if ( v4 )
        {
          i[7] = v4 - 1;
          break;
        }
      }
      v5 = result[16] - 1;
      result[16] = v5;
      *a2 = v5;
      result = (_DWORD *)i[6];
    }
    else
    {
      result = v2;
    }
  }
  return result;
}

//----- (00069B60) --------------------------------------------------------
signed int __fastcall curl_multi_setopt(int a1, unsigned int a2, int a3, int a4)
{
  char v4; // r3
  int varg_r2; // [sp+10h] [bp-8h]
  int varg_r3; // [sp+14h] [bp-4h]

  varg_r2 = a3;
  varg_r3 = a4;
  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1;
  if ( a2 == 10002 )
  {
    *(_DWORD *)(a1 + 76) = varg_r2;
    return 0;
  }
  if ( a2 > 0x2712 )
  {
    switch ( a2 )
    {
      case 0x4E21u:
        *(_DWORD *)(a1 + 72) = varg_r2;
        return 0;
      case 0x4E24u:
        *(_DWORD *)(a1 + 108) = varg_r2;
        return 0;
      case 0x2715u:
        *(_DWORD *)(a1 + 112) = varg_r2;
        return 0;
    }
  }
  else
  {
    if ( a2 == 3 )
    {
      v4 = varg_r2;
      if ( varg_r2 )
        v4 = 1;
      *(_BYTE *)(a1 + 92) = v4;
      return 0;
    }
    if ( a2 == 6 )
    {
      *(_DWORD *)(a1 + 100) = varg_r2;
      return 0;
    }
  }
  return 6;
}

//----- (00069BDC) --------------------------------------------------------
signed int __fastcall curl_multi_timeout(_DWORD *a1, _DWORD *a2)
{
  if ( !a1 || *a1 != 764702 )
    return 1;
  if ( a1[21] )
    sub_695B4((int)(a1 + 21), (int)a2);
  else
    *a2 = -1;
  return 0;
}

//----- (00069C08) --------------------------------------------------------
int *__fastcall Curl_expire(int *result, int a2)
{
  int v2; // r7
  int v3; // r6
  int v4; // r8
  _DWORD *v5; // r4
  int *v6; // r5
  signed int v7; // r2
  int v8; // r9
  int v9; // r8
  signed int v10; // r2
  int *v11; // [sp+0h] [bp-28h]
  int v12; // [sp+4h] [bp-24h]

  v11 = result;
  v12 = a2;
  v2 = (int)result;
  v3 = result[2];
  v4 = a2;
  if ( v3 )
  {
    v5 = result + 8512;
    v6 = result + 8527;
    if ( a2 )
    {
      curlx_tvnow((__time_t *)&v11);
      v8 = (int)v11 + v4 / 1000;
      v9 = v12 + 1000 * (v4 % 1000);
      if ( v9 > (signed int)&unk_F4240 )
      {
        ++v8;
        v9 -= 1000000;
      }
      if ( v5[15] || v6[1] )
      {
        v11 = (int *)v8;
        v12 = v9;
        result = (int *)curlx_tvdiff(v8, v9, *v6, v6[1]);
        if ( (signed int)result > 0 )
          return result;
        v10 = Curl_splayremovebyaddr(*(int **)(v3 + 84), (int)(v5 + 17), (int **)(v3 + 84));
        if ( v10 )
          Curl_infof(v2, "Internal error removing splay node = %d\n", v10);
      }
      v5[15] = v8;
      v5[16] = v9;
      v5[22] = v2;
      result = Curl_splayinsert((int *)*v6, v6[1], *(int **)(v3 + 84), v5 + 17);
      *(_DWORD *)(v3 + 84) = result;
    }
    else if ( result[8527] || result[8528] )
    {
      v7 = Curl_splayremovebyaddr(*(int **)(v3 + 84), (int)(result + 8529), (int **)(v3 + 84));
      if ( v7 )
        Curl_infof(v2, "Internal error clearing splay node = %d\n", v7);
      result = (int *)Curl_infof(v2, "Expire cleared\n", v7);
      v5[15] = 0;
      v5[16] = 0;
    }
  }
  return result;
}

//----- (00069D04) --------------------------------------------------------
signed int __fastcall curl_multi_remove_handle(_DWORD *a1, int a2)
{
  _DWORD *v2; // r5
  int v3; // r4
  _BYTE *v4; // r3
  int v5; // r6
  int v6; // r9
  int v7; // r3
  _DWORD *v8; // r2
  int v9; // r1
  _DWORD *v10; // r3
  _DWORD *v11; // r6
  int v12; // r3
  int v13; // r1
  _DWORD *v14; // r2
  int v15; // r3
  _DWORD *v16; // r3
  _DWORD *v17; // r3
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v22; // r10
  _DWORD *v23; // r0
  _DWORD **v24; // r8
  _DWORD *v25; // r6
  char *v26; // r12
  _DWORD *v27; // r2
  int i; // r3
  _DWORD *v29; // r1
  signed int v30; // r3
  _DWORD *v31; // r11
  char *v32; // ST00_4
  int v33; // r1
  _DWORD *v34; // r0

  v2 = a1;
  if ( !a1 || *a1 != 764702 )
    return 1;
  if ( *(_DWORD *)(a2 + 34312) != -1059136595 )
    return 2;
  v3 = *(_DWORD *)(a2 + 12);
  if ( !v3 )
    return 2;
  v4 = *(_BYTE **)(v3 + 12);
  v5 = *(_DWORD *)(v3 + 16) - 15;
  if ( *(_DWORD *)(v3 + 16) != 15 )
    v5 = 1;
  if ( v4 )
    LOBYTE(v4) = *v4
               - *(_BYTE *)(v3 + 8)
               + ((unsigned int)(*(_DWORD *)v4 - *(_DWORD *)(v3 + 8)) <= 0)
               + *(_BYTE *)(v3 + 8)
               - *v4;
  v6 = (unsigned __int8)v4 & 1;
  if ( v5 )
    --a1[17];
  v7 = *(_DWORD *)(v3 + 12);
  if ( v7
    && (unsigned int)(*(_DWORD *)(*(_DWORD *)(v7 + 372) + 12) + *(_DWORD *)(*(_DWORD *)(v7 + 376) + 12)) > 1
    && (unsigned int)(*(_DWORD *)(v3 + 16) - 7) <= 7 )
  {
    *(_BYTE *)(v7 + 296) = 1;
    **(_DWORD **)(v3 + 12) = *(_DWORD *)(v3 + 8);
  }
  Curl_expire(*(int **)(v3 + 8), 0);
  v8 = *(_DWORD **)(v3 + 8);
  if ( v8[1] == 3 )
  {
    *v8 = 0;
    *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4) = 0;
  }
  v9 = *(_DWORD *)(v3 + 12);
  if ( v9 )
  {
    if ( v6 )
    {
      Curl_done((int **)(v3 + 12), *(_DWORD *)(v3 + 20), v5);
      v10 = *(_DWORD **)(v3 + 12);
      if ( v10 )
        *v10 = *(_DWORD *)(v3 + 8);
    }
    else
    {
      Curl_getoff_all_pipelines(*(_DWORD *)(v3 + 8), v9);
    }
  }
  v11 = (_DWORD *)v2[24];
  v12 = 0;
  v13 = *(_DWORD *)(v3 + 8);
  while ( v12 < v11[1] )
  {
    v14 = *(_DWORD **)(*v11 + 4 * v12);
    if ( v14 && *v14 == v13 && v14[12] & 4 )
    {
      *(_DWORD *)(v13 + 34168) = v2;
      v22 = *(_DWORD *)(v3 + 8);
      v23 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(8u, 1u);
      if ( v23 )
      {
        v23[1] = v22;
        *v23 = v2[26];
        v2[26] = v23;
      }
      v24 = (_DWORD **)v2[26];
      v25 = *v24;
      v26 = "Delayed kill of easy handle %p\n";
      while ( v25 )
      {
        v27 = (_DWORD *)v2[24];
        for ( i = 0; ; ++i )
        {
          if ( i >= v27[1] )
          {
            v30 = 0;
            goto LABEL_53;
          }
          v29 = *(_DWORD **)(*v27 + 4 * i);
          if ( v29 )
          {
            if ( *v29 == v25[1] )
              break;
          }
        }
        v30 = 1;
LABEL_53:
        v31 = (_DWORD *)*v25;
        if ( !v30 )
        {
          v32 = v26;
          Curl_infof(v22, v26, v25[1]);
          *(_DWORD *)(v25[1] + 34168) = 0;
          Curl_close(v25[1], v33);
          *v24 = v31;
          v34 = v25;
          v25 = v24;
          Curl_cfree(v34);
          v26 = v32;
        }
        v24 = (_DWORD **)v25;
        v25 = v31;
      }
      break;
    }
    ++v12;
  }
  v15 = *(_DWORD *)(v3 + 8);
  if ( *(_DWORD *)(*(_DWORD *)(v15 + 1148) + 8) == 1 )
  {
    *(_DWORD *)(v15 + 1148) = 0;
    v16 = *(_DWORD **)(v3 + 12);
    if ( v16 )
    {
      if ( v6 && !(*(_DWORD *)(v16[93] + 12) + *(_DWORD *)(v16[94] + 12)) )
        v16[11] = -1;
    }
  }
  *(_DWORD *)(v3 + 16) = 15;
  sub_696A8((int)v2, (_DWORD *)v3);
  Curl_easy_addmulti(*(_DWORD *)(v3 + 8), 0);
  v17 = *(_DWORD **)(v3 + 4);
  if ( v17 )
    *v17 = *(_DWORD *)v3;
  if ( *(_DWORD *)v3 )
    *(_DWORD *)(*(_DWORD *)v3 + 4) = *(_DWORD *)(v3 + 4);
  *(_DWORD *)(*(_DWORD *)(v3 + 8) + 612) = 0;
  *(_DWORD *)(*(_DWORD *)(v3 + 8) + 12) = 0;
  v18 = *(_DWORD *)(v3 + 24);
  if ( v18 )
    Curl_cfree(v18);
  Curl_cfree(v3);
  --v2[15];
  sub_6989C((int)v2, v19, v20);
  return 0;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00069F2C) --------------------------------------------------------
signed int __fastcall curl_multi_add_handle(_DWORD *a1, int a2)
{
  int v2; // r6
  _DWORD *v3; // r5
  _DWORD *v4; // r7
  int v5; // r4
  _DWORD *i; // r0
  _DWORD *v7; // r8
  int v8; // r3
  int v9; // r3
  _DWORD *v10; // r3
  int v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r1
  int v14; // r2
  signed int v15; // r0
  signed int v16; // r2
  signed int v17; // r3
  int v18; // r1
  int v19; // r2

  v2 = a2;
  v3 = a1;
  if ( !a1 || *a1 != 764702 )
    return 1;
  if ( *(_DWORD *)(a2 + 34312) != -1059136595 )
    return 2;
  v4 = *(_DWORD **)(a2 + 8);
  if ( v4 )
    return 2;
  v5 = Curl_ccalloc(56, 1);
  if ( v5 )
  {
    for ( i = (_DWORD *)v3[26]; i; i = (_DWORD *)*i )
    {
      v7 = (_DWORD *)*i;
      if ( i[1] == v2 )
      {
        Curl_cfree(i);
        if ( v4 )
          *v4 = v7;
        else
          v3[26] = v7;
        break;
      }
      v4 = i;
    }
    v8 = *(_DWORD *)(v5 + 16);
    *(_DWORD *)(v5 + 8) = v2;
    if ( v8 )
      *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)(v2 + 12) = v5;
    v9 = *(_DWORD *)(v5 + 8);
    if ( *(_DWORD *)v9 && *(_DWORD *)(v9 + 4) == 1 )
    {
      Curl_hash_destroy(*(_DWORD **)v9);
      **(_DWORD **)(v5 + 8) = 0;
      *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4) = 0;
    }
    v10 = *(_DWORD **)(v5 + 8);
    if ( !*v10 || !v10[1] )
    {
      *v10 = v3[20];
      *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4) = 3;
    }
    v11 = *(_DWORD *)(v5 + 8);
    v12 = *(_DWORD **)(v11 + 1148);
    if ( v12 )
    {
      if ( v12[2] )
        goto LABEL_25;
      Curl_rm_connc(v12);
      v11 = *(_DWORD *)(v5 + 8);
    }
    *(_DWORD *)(v11 + 1148) = v3[24];
LABEL_25:
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 8) + 1148) + 8) = 1;
    *(_DWORD *)v5 = v3 + 1;
    *(_DWORD *)(v5 + 4) = v3[2];
    v3[2] = v5;
    **(_DWORD **)(v5 + 4) = v5;
    Curl_easy_addmulti(v2, (int)v3);
    *(_DWORD *)(*(_DWORD *)(v5 + 8) + 612) = v5;
    Curl_expire(*(int **)(v5 + 8), 1);
    v13 = (_DWORD *)v3[24];
    v14 = v3[15] + 1;
    v3[15] = v14;
    v15 = v13[1];
    v16 = 4 * v14;
    if ( v16 > v15 )
    {
      v17 = v3[25];
      if ( v17 && v17 < v16 )
      {
        if ( v17 <= v15 )
          goto LABEL_32;
        v16 = v3[25];
      }
      if ( Curl_ch_connc(v2, v13, v16) )
      {
        curl_multi_remove_handle(v3, v2);
        return 3;
      }
    }
LABEL_32:
    ++v3[17];
    memset(v3 + 29, 0, 8u);
    sub_6989C((int)v3, v18, v19);
    return 0;
  }
  return 3;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006A08C) --------------------------------------------------------
int __fastcall sub_6A08C(int a1, int a2, int a3)
{
  int v3; // r4
  _DWORD *v4; // r3
  int v5; // r5
  _DWORD *v6; // r8
  int v7; // r7
  unsigned int v8; // r9
  _DWORD *i; // r6
  double v10; // r0
  int v11; // r1
  _DWORD *v12; // r3
  _DWORD **v13; // r3
  int v15; // [sp+0h] [bp-28h]
  int v16; // [sp+4h] [bp-24h]
  int v17; // [sp+8h] [bp-20h]

  v15 = a1;
  v16 = a2;
  v17 = a3;
  v3 = a1;
  v4 = *(_DWORD **)(a1 + 372);
  v5 = *(unsigned __int8 *)(a1 + 370);
  v6 = (_DWORD *)*v4;
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 376) + 12) + v4[3];
  if ( *(_BYTE *)(a1 + 370) || !v7 )
  {
    if ( *(_BYTE *)(a1 + 370) )
      v8 = 5;
    else
      v8 = 1;
    v5 = 0;
    for ( i = **(_DWORD ***)(a1 + 380); v5 + v7 < v8 && i; i = **(_DWORD ***)(v3 + 380) )
    {
      ++v5;
      Curl_llist_move(*(_DWORD **)(v3 + 380), (int)i, *(_DWORD **)(v3 + 372), *(_DWORD *)(*(_DWORD *)(v3 + 372) + 4));
      LODWORD(v10) = *i;
      Curl_pgrsTime(v10);
    }
    if ( v5 )
    {
      curlx_tvnow(&v15);
      v11 = v16;
      v12 = (_DWORD *)(v3 + 196);
      *v12 = v15;
      v12[1] = v11;
      v13 = *(_DWORD ***)(v3 + 372);
      if ( v6 != *v13 )
      {
        *(_BYTE *)(v3 + 369) = 0;
        Curl_infof(*(_DWORD *)v3, "%p is at send pipe head!\n", **v13);
        Curl_expire(***(int ****)(v3 + 372), 1);
      }
    }
  }
  return v5;
}

//----- (0006A13C) --------------------------------------------------------
signed int __fastcall sub_6A13C(double a1)
{
  double v1; // r6
  int v2; // r5
  int v3; // r2
  int v4; // r3
  int v5; // r3
  signed int v6; // r0
  signed int v7; // r4
  int *v8; // r0
  int v9; // r4
  int v10; // r10
  int v11; // r5
  int v12; // r9
  unsigned int v13; // r5
  _DWORD *v14; // r1
  signed int v15; // r0
  signed int v16; // r3
  int v17; // r2
  int *v18; // r0
  signed int v19; // r0
  signed int v20; // r0
  int v21; // r1
  int v22; // r3
  signed int v23; // r3
  int v24; // r0
  int v25; // r3
  _BYTE *v26; // r3
  int v27; // r3
  signed int v28; // r3
  signed int v29; // r0
  int v30; // r3
  signed int v31; // r0
  int v32; // r2
  int v33; // r1
  int v34; // r3
  int v35; // r1
  _DWORD *v36; // r2
  int v37; // r3
  int v38; // r2
  signed int v39; // r0
  int v40; // r3
  int v41; // r1
  int v42; // r0
  signed int v43; // r0
  int v44; // r3
  int v45; // r0
  int v46; // r4
  _DWORD *v47; // r2
  _DWORD *v48; // r0
  _DWORD *v49; // r1
  _DWORD **v50; // r3
  int v51; // r3
  int v52; // r1
  _DWORD *v53; // r2
  _QWORD *v54; // r12
  __int64 v55; // r2
  __int64 v56; // r4
  signed int v57; // r3
  _QWORD *v58; // r1
  signed __int64 v59; // r4
  signed __int64 v60; // r4
  int v61; // r0
  int v62; // r2
  int v63; // r3
  int v64; // r4
  int v65; // r1
  int v66; // r2
  int **v67; // r3
  int v68; // r3
  int v69; // r4
  int (__fastcall *v70)(int *, int, int); // r0
  signed int v71; // r3
  int v72; // r1
  signed int v73; // r0
  int v74; // r1
  int v75; // r2
  int v76; // r2
  int v77; // r1
  int v78; // r2
  _DWORD *v79; // r2
  _DWORD *v80; // r0
  double v82; // [sp+0h] [bp-28h]

  v82 = a1;
  v1 = a1;
  LODWORD(a1) = *(_DWORD *)(HIDWORD(a1) + 8);
  v2 = 0;
  WORD1(v82) = 0;
  if ( *(_DWORD *)(LODWORD(a1) + 34312) != -1059136595 )
    return 2;
  v3 = *(unsigned __int8 *)(LODWORD(a1) + 34153);
  if ( *(_BYTE *)(LODWORD(a1) + 34153) )
  {
    Curl_infof(
      SLODWORD(a1),
      "Pipe broke: handle 0x%x, url = %s\n",
      HIDWORD(a1),
      *(_DWORD *)(LODWORD(a1) + 34180),
      LODWORD(v82));
    v4 = *(_DWORD *)(HIDWORD(v1) + 16);
    if ( v4 != 15 )
    {
      v2 = -1;
      if ( v4 != 1 )
        *(_DWORD *)(HIDWORD(v1) + 16) = 1;
      *(_DWORD *)(HIDWORD(v1) + 20) = 0;
    }
    *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 8) + 34153) = 0;
    *(_DWORD *)(HIDWORD(v1) + 12) = 0;
    goto LABEL_176;
  }
  if ( (unsigned int)(*(_DWORD *)(HIDWORD(a1) + 16) - 2) <= 0xC )
    **(_DWORD **)(HIDWORD(a1) + 12) = LODWORD(a1);
  v5 = *(_DWORD *)(HIDWORD(a1) + 16);
  switch ( v5 )
  {
    case 0:
      v6 = Curl_pretransfer(*(_DWORD **)(HIDWORD(a1) + 8));
      *(_DWORD *)(HIDWORD(v1) + 20) = v6;
      if ( v6 )
        goto LABEL_12;
      if ( *(_DWORD *)(HIDWORD(v1) + 16) != 1 )
        *(_DWORD *)(HIDWORD(v1) + 16) = 1;
      *(_DWORD *)(*(_DWORD *)(HIDWORD(v1) + 8) + 1144) = 2;
      goto LABEL_116;
    case 1:
      LODWORD(a1) = *(_DWORD *)(HIDWORD(a1) + 8);
      Curl_pgrsTime(a1);
      v8 = Curl_connect(*(_DWORD *)(HIDWORD(v1) + 8), (int *)(HIDWORD(v1) + 12), (_BYTE *)&v82 + 1, (_BYTE *)&v82 + 2);
      *(_DWORD *)(HIDWORD(v1) + 20) = v8;
      if ( v8 )
        goto LABEL_12;
      v9 = *(_DWORD *)(HIDWORD(v1) + 12);
      v10 = *(_DWORD *)(HIDWORD(v1) + 8);
      v11 = *(_DWORD *)(*(_DWORD *)(v9 + 372) + 12);
      v12 = *(_DWORD *)(*(_DWORD *)(v9 + 376) + 12);
      if ( Curl_isPipeliningEnabled(*(_DWORD *)(HIDWORD(v1) + 8))
        && (v13 = v12 + v11) != 0
        && (!*(_BYTE *)(v9 + 370) || v13 > 4) )
      {
        v14 = *(_DWORD **)(v9 + 380);
      }
      else
      {
        v14 = *(_DWORD **)(v9 + 372);
      }
      v15 = Curl_addHandleToPipeline(v10, v14);
      *(_DWORD *)(HIDWORD(v1) + 20) = v15;
      if ( v15 )
        goto LABEL_12;
      v7 = BYTE1(v82);
      if ( BYTE1(v82) )
      {
        if ( *(_DWORD *)(HIDWORD(v1) + 16) == 2 )
          goto LABEL_12;
        v16 = 2;
        goto LABEL_94;
      }
      if ( BYTE2(v82) )
      {
LABEL_71:
        if ( *(_BYTE *)(LODWORD(v1) + 92) )
          v33 = 6;
        else
          v33 = 7;
        sub_695A2(SHIDWORD(v1), v33);
      }
      else
      {
        v17 = *(_DWORD *)(HIDWORD(v1) + 16);
        if ( *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 309) )
        {
          if ( v17 == 4 )
            goto LABEL_116;
          v7 = BYTE2(v82);
          *(_DWORD *)(HIDWORD(v1) + 16) = 4;
        }
        else
        {
          if ( v17 == 3 )
            goto LABEL_116;
          v7 = *(unsigned __int8 *)(*(_DWORD *)(HIDWORD(v1) + 12) + 309);
          *(_DWORD *)(HIDWORD(v1) + 16) = 3;
        }
      }
      goto LABEL_81;
    case 2:
      v18 = *(int **)(HIDWORD(a1) + 12);
      HIDWORD(v82) = 0;
      v19 = Curl_is_resolved(v18, (int *)&v82 + 1, v3, v5);
      v2 = HIDWORD(v82);
      *(_DWORD *)(HIDWORD(v1) + 20) = v19;
      if ( !v2 )
        goto LABEL_48;
      sub_696A8(SLODWORD(v1), (_DWORD *)HIDWORD(v1));
      v20 = Curl_async_resolved(*(int ***)(HIDWORD(v1) + 12), (_BYTE *)&v82 + 2);
      *(_DWORD *)(HIDWORD(v1) + 20) = v20;
      if ( v20 )
      {
        *(_DWORD *)(HIDWORD(v1) + 12) = 0;
        v2 = 0;
        goto LABEL_48;
      }
      if ( BYTE2(v82) )
      {
        if ( *(_BYTE *)(LODWORD(v1) + 92) )
          v21 = 6;
        else
          v21 = 7;
        sub_695A2(SHIDWORD(v1), v21);
      }
      else
      {
        v22 = *(_DWORD *)(HIDWORD(v1) + 16);
        if ( *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 309) )
        {
          if ( v22 == 4 )
            goto LABEL_47;
          v23 = 4;
        }
        else
        {
          if ( v22 == 3 )
            goto LABEL_47;
          v23 = 3;
        }
        *(_DWORD *)(HIDWORD(v1) + 16) = v23;
      }
LABEL_47:
      v2 = -1;
LABEL_48:
      v7 = *(_DWORD *)(HIDWORD(v1) + 20) != 0;
      goto LABEL_169;
    case 3:
      v29 = Curl_is_connected(*(_DWORD *)(HIDWORD(a1) + 12), 0, &v82, v5);
      v30 = LOBYTE(v82);
      *(_DWORD *)(HIDWORD(v1) + 20) = v29;
      if ( v30 )
      {
        v31 = Curl_connected_proxy(*(_DWORD *)(HIDWORD(v1) + 12));
        *(_DWORD *)(HIDWORD(v1) + 20) = v31;
        if ( !v31 )
          *(_DWORD *)(HIDWORD(v1) + 20) = Curl_protocol_connect(*(_DWORD *)(HIDWORD(v1) + 12), (_BYTE *)&v82 + 2);
      }
      v7 = *(_DWORD *)(HIDWORD(v1) + 20);
      if ( v7 )
        goto LABEL_167;
      if ( !LOBYTE(v82) )
        goto LABEL_12;
      if ( BYTE2(v82) )
        goto LABEL_71;
      v32 = *(_DWORD *)(HIDWORD(v1) + 16);
      if ( !*(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 309) )
      {
        if ( v32 != 5 )
          *(_DWORD *)(HIDWORD(v1) + 16) = 5;
        goto LABEL_12;
      }
      if ( v32 == 4 )
        goto LABEL_12;
      v7 = BYTE2(v82);
      *(_DWORD *)(HIDWORD(v1) + 16) = 4;
      goto LABEL_86;
    case 4:
      v24 = Curl_http_connect(*(_DWORD *)(HIDWORD(a1) + 12), (_BYTE *)&v82 + 2);
      v25 = *(_DWORD *)(HIDWORD(v1) + 12);
      *(_DWORD *)(HIDWORD(v1) + 20) = v24;
      if ( *(_BYTE *)(v25 + 318) )
      {
        v26 = *(_BYTE **)(*(_DWORD *)(HIDWORD(v1) + 8) + 288);
        if ( v26 )
          *v26 = 0;
        v7 = 0;
        *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 8) + 33984) = 0;
        v27 = *(_DWORD *)(HIDWORD(v1) + 16);
        *(_DWORD *)(HIDWORD(v1) + 20) = 0;
        if ( v27 != 1 )
        {
          v28 = 1;
          goto LABEL_80;
        }
        goto LABEL_116;
      }
      if ( !v24 )
      {
        v7 = *(unsigned __int8 *)(v25 + 309);
        if ( !*(_BYTE *)(v25 + 309) && *(_DWORD *)(HIDWORD(v1) + 16) != 3 )
        {
          *(_DWORD *)(HIDWORD(v1) + 16) = 3;
          goto LABEL_168;
        }
      }
      goto LABEL_12;
    case 5:
      v7 = Curl_protocol_connecting(*(_DWORD *)(HIDWORD(a1) + 12), (_BYTE *)&v82 + 2);
      *(_DWORD *)(HIDWORD(v1) + 20) = v7;
      if ( v7 )
        goto LABEL_107;
      if ( BYTE2(v82) )
        goto LABEL_71;
      goto LABEL_12;
    case 6:
      v34 = *(_DWORD *)(HIDWORD(a1) + 12);
      v7 = *(unsigned __int8 *)(v34 + 369);
      if ( *(_BYTE *)(v34 + 369) )
        goto LABEL_12;
      v35 = *(_DWORD *)(HIDWORD(a1) + 8);
      v36 = **(_DWORD ***)(v34 + 372);
      if ( !v36 || *v36 != v35 )
        goto LABEL_12;
      *(_BYTE *)(v34 + 369) = 1;
      if ( *(_DWORD *)(HIDWORD(v1) + 16) == 7 )
        goto LABEL_116;
      v28 = 7;
      goto LABEL_80;
    case 7:
      v37 = *(_DWORD *)(HIDWORD(a1) + 8);
      v2 = *(unsigned __int8 *)(v37 + 697);
      if ( *(_BYTE *)(v37 + 697) )
      {
        *(_BYTE *)(*(_DWORD *)(HIDWORD(a1) + 12) + 296) = 0;
        v38 = *(_DWORD *)(HIDWORD(a1) + 16);
        *(_DWORD *)(HIDWORD(a1) + 20) = 0;
        if ( v38 != 14 )
          *(_DWORD *)(HIDWORD(a1) + 16) = 14;
        goto LABEL_85;
      }
      v39 = Curl_do((int ***)(HIDWORD(a1) + 12), (int)&v82 + 4, v3, (int **)v37);
      *(_DWORD *)(HIDWORD(v1) + 20) = v39;
      if ( v39 )
      {
        Curl_posttransfer(*(_DWORD *)(HIDWORD(v1) + 8));
        Curl_done((int **)(HIDWORD(v1) + 12), *(_DWORD *)(HIDWORD(v1) + 20), v2);
        v7 = 1;
        goto LABEL_169;
      }
      v7 = BYTE4(v82);
      v40 = *(_DWORD *)(HIDWORD(v1) + 16);
      if ( !BYTE4(v82) )
      {
        if ( v40 == 8 )
          goto LABEL_12;
        *(_DWORD *)(HIDWORD(v1) + 16) = 8;
        goto LABEL_86;
      }
      v41 = *(_DWORD *)(HIDWORD(v1) + 12);
      v7 = *(unsigned __int8 *)(v41 + 304);
      if ( *(_BYTE *)(v41 + 304) )
      {
        if ( v40 == 9 )
          goto LABEL_12;
        v16 = 9;
LABEL_94:
        *(_DWORD *)(HIDWORD(v1) + 16) = v16;
        v7 = 0;
        goto LABEL_86;
      }
LABEL_101:
      if ( v40 == 10 )
        goto LABEL_116;
      v28 = 10;
LABEL_80:
      *(_DWORD *)(HIDWORD(v1) + 16) = v28;
      goto LABEL_81;
    case 8:
      v42 = Curl_protocol_doing(*(_DWORD *)(HIDWORD(a1) + 12), (_BYTE *)&v82 + 4);
      *(_DWORD *)(HIDWORD(v1) + 20) = v42;
      if ( v42 )
        goto LABEL_107;
      if ( !BYTE4(v82) )
        goto LABEL_12;
      v7 = *(unsigned __int8 *)(*(_DWORD *)(HIDWORD(v1) + 12) + 304);
      v40 = *(_DWORD *)(HIDWORD(v1) + 16);
      if ( !*(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 304) )
        goto LABEL_101;
      if ( v40 != 9 )
        *(_DWORD *)(HIDWORD(v1) + 16) = 9;
      goto LABEL_12;
    case 9:
      v43 = Curl_is_connected(*(_DWORD *)(HIDWORD(a1) + 12), 1, &v82, v5);
      v44 = LOBYTE(v82);
      *(_DWORD *)(HIDWORD(v1) + 20) = v43;
      if ( !v44 )
        goto LABEL_12;
      v45 = Curl_do_more(*(_DWORD **)(HIDWORD(v1) + 12));
      *(_DWORD *)(HIDWORD(v1) + 20) = v45;
      if ( v45 )
      {
LABEL_107:
        Curl_posttransfer(*(_DWORD *)(HIDWORD(v1) + 8));
        Curl_done((int **)(HIDWORD(v1) + 12), *(_DWORD *)(HIDWORD(v1) + 20), 0);
LABEL_167:
        v7 = 1;
        goto LABEL_168;
      }
      if ( *(_DWORD *)(HIDWORD(v1) + 16) == 10 )
        goto LABEL_116;
      v7 = 0;
      *(_DWORD *)(HIDWORD(v1) + 16) = 10;
      goto LABEL_81;
    case 10:
      v46 = *(_DWORD *)(HIDWORD(a1) + 12);
      v47 = *(_DWORD **)(HIDWORD(a1) + 8);
      v48 = *(_DWORD **)(v46 + 372);
      v49 = (_DWORD *)*v48;
      while ( 2 )
      {
        if ( v49 )
        {
          if ( (_DWORD *)*v49 != v47 )
          {
            v49 = (_DWORD *)v49[2];
            continue;
          }
          Curl_llist_move(v48, (int)v49, *(_DWORD **)(v46 + 376), *(_DWORD *)(*(_DWORD *)(v46 + 376) + 4));
          v50 = *(_DWORD ***)(v46 + 372);
          v47 = *v50;
          if ( *v50 )
          {
            *(_BYTE *)(v46 + 369) = 0;
            Curl_infof(*(_DWORD *)v46, "%p is at send pipe head B!\n", **v50);
            Curl_expire(***(int ****)(v46 + 372), 1);
          }
        }
        break;
      }
      sub_6A08C(*(_DWORD *)(HIDWORD(v1) + 12), (int)v49, (int)v47);
      if ( *(_DWORD *)(HIDWORD(v1) + 16) != 11 )
        *(_DWORD *)(HIDWORD(v1) + 16) = 11;
LABEL_116:
      v7 = 0;
LABEL_81:
      v2 = -1;
      goto LABEL_169;
    case 11:
      v51 = *(_DWORD *)(HIDWORD(a1) + 12);
      v7 = *(unsigned __int8 *)(v51 + 368);
      if ( *(_BYTE *)(v51 + 368) )
        goto LABEL_12;
      v52 = *(_DWORD *)(HIDWORD(a1) + 8);
      v53 = **(_DWORD ***)(v51 + 376);
      if ( !v53 || *v53 != v52 )
        goto LABEL_12;
      *(_BYTE *)(v51 + 368) = 1;
      if ( *(_DWORD *)(HIDWORD(v1) + 16) == 12 )
        goto LABEL_116;
      v28 = 12;
      goto LABEL_80;
    case 12:
      v58 = *(_QWORD **)(HIDWORD(a1) + 8);
      v59 = v58[57];
      if ( v59 < 1 || v59 >= v58[121] )
      {
        v60 = v58[58];
        if ( v60 < 1 || v60 >= v58[120] )
        {
          v61 = Curl_readwrite(*(_DWORD *)(HIDWORD(v1) + 12), (bool *)&v82 + 3);
          v62 = *(_DWORD *)(HIDWORD(v1) + 8);
          *(_DWORD *)(HIDWORD(v1) + 20) = v61;
          if ( !(*(_DWORD *)(v62 + 244) & 1) )
            *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 368) = 0;
          if ( !(*(_DWORD *)(v62 + 244) & 2) )
            *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 369) = 0;
          if ( *(_DWORD *)(HIDWORD(v1) + 20) )
          {
            v63 = *(_DWORD *)(HIDWORD(v1) + 12);
            if ( !(*(_DWORD *)(v63 + 48) & 4) )
              *(_BYTE *)(v63 + 296) = 1;
            Curl_posttransfer(*(_DWORD *)(HIDWORD(v1) + 8));
            Curl_done((int **)(HIDWORD(v1) + 12), *(_DWORD *)(HIDWORD(v1) + 20), 0);
            goto LABEL_85;
          }
          if ( !BYTE3(v82) )
          {
LABEL_12:
            v7 = 0;
LABEL_168:
            v2 = 0;
            goto LABEL_169;
          }
          v64 = Curl_retry_request(*(_DWORD **)(HIDWORD(v1) + 12), (_DWORD *)&v82 + 1);
          Curl_posttransfer(*(_DWORD *)(HIDWORD(v1) + 8));
          Curl_removeHandleFromPipeline(
            *(_DWORD *)(HIDWORD(v1) + 8),
            *(_DWORD ***)(*(_DWORD *)(HIDWORD(v1) + 12) + 376));
          v67 = **(int ****)(*(_DWORD *)(HIDWORD(v1) + 12) + 376);
          if ( v67 )
            Curl_expire(*v67, 1);
          sub_6A08C(*(_DWORD *)(HIDWORD(v1) + 12), v65, v66);
          v68 = *(_DWORD *)(HIDWORD(v1) + 8);
          if ( *(_DWORD *)(v68 + 256) )
          {
            if ( !v64 )
            {
              HIDWORD(v82) = *(_DWORD *)(v68 + 256);
              *(_DWORD *)(v68 + 256) = 0;
              v69 = 3;
LABEL_151:
              v70 = Curl_done((int **)(HIDWORD(v1) + 12), 0, 0);
              *(_DWORD *)(HIDWORD(v1) + 20) = v70;
              if ( !v70 )
                *(_DWORD *)(HIDWORD(v1) + 20) = Curl_follow(*(_DWORD *)(HIDWORD(v1) + 8), SHIDWORD(v82), v69);
              if ( *(_DWORD *)(HIDWORD(v1) + 20) )
              {
                v2 = 0;
                ((void (__cdecl *)(void *))Curl_cfree)((void *)HIDWORD(v82));
LABEL_165:
                v7 = 0;
                goto LABEL_169;
              }
              if ( *(_DWORD *)(HIDWORD(v1) + 16) == 1 )
              {
LABEL_163:
                v2 = -1;
                goto LABEL_165;
              }
              v71 = 1;
LABEL_162:
              *(_DWORD *)(HIDWORD(v1) + 16) = v71;
              goto LABEL_163;
            }
          }
          else if ( !v64 )
          {
            v72 = *(_DWORD *)(v68 + 252);
            if ( v72 )
            {
              HIDWORD(v82) = *(_DWORD *)(v68 + 252);
              *(_DWORD *)(v68 + 252) = 0;
              v73 = Curl_follow(*(_DWORD *)(HIDWORD(v1) + 8), v72, 1);
              *(_DWORD *)(HIDWORD(v1) + 20) = v73;
              if ( v73 )
                ((void (__cdecl *)(void *))Curl_cfree)((void *)HIDWORD(v82));
            }
            if ( *(_DWORD *)(HIDWORD(v1) + 16) == 14 )
              goto LABEL_163;
            v71 = 14;
            goto LABEL_162;
          }
          v69 = 2;
          goto LABEL_151;
        }
      }
      v57 = 13;
LABEL_133:
      *(_DWORD *)(HIDWORD(v1) + 16) = v57;
LABEL_85:
      v7 = 0;
LABEL_86:
      v2 = v7;
LABEL_169:
      if ( *(_DWORD *)(HIDWORD(v1) + 16) != 15 && *(_DWORD *)(HIDWORD(v1) + 20) )
      {
        *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 8) + 34153) = 0;
        v76 = *(_DWORD *)(HIDWORD(v1) + 12);
        if ( v76 )
        {
          *(_BYTE *)(v76 + 369) = 0;
          *(_BYTE *)(*(_DWORD *)(HIDWORD(v1) + 12) + 368) = 0;
          Curl_removeHandleFromPipeline(
            *(_DWORD *)(HIDWORD(v1) + 8),
            *(_DWORD ***)(*(_DWORD *)(HIDWORD(v1) + 12) + 372));
          Curl_removeHandleFromPipeline(
            *(_DWORD *)(HIDWORD(v1) + 8),
            *(_DWORD ***)(*(_DWORD *)(HIDWORD(v1) + 12) + 376));
          sub_6A08C(*(_DWORD *)(HIDWORD(v1) + 12), v77, v78);
        }
        if ( v7 )
        {
          Curl_disconnect(*(int ***)(HIDWORD(v1) + 12));
          *(_DWORD *)(HIDWORD(v1) + 12) = 0;
        }
        sub_695A2(SHIDWORD(v1), 15);
      }
LABEL_176:
      if ( *(_DWORD *)(HIDWORD(v1) + 16) == 15 && !*(_DWORD *)(HIDWORD(v1) + 24) )
      {
        v79 = *(_DWORD **)(HIDWORD(v1) + 8);
        if ( v79[1] == 3 )
        {
          *v79 = 0;
          *(_DWORD *)(*(_DWORD *)(HIDWORD(v1) + 8) + 4) = 0;
        }
        v80 = (_DWORD *)Curl_cmalloc(16);
        if ( !v80 )
          return 3;
        *v80 = 1;
        v80[1] = *(_DWORD *)(HIDWORD(v1) + 8);
        v80[2] = *(_DWORD *)(HIDWORD(v1) + 20);
        v80[3] = 0;
        *(_DWORD *)(HIDWORD(v1) + 24) = v80;
        *(_DWORD *)(HIDWORD(v1) + 28) = 1;
        ++*(_DWORD *)(LODWORD(v1) + 64);
      }
      if ( v2 != -1 )
        return 0;
      Curl_expire(*(int **)(HIDWORD(v1) + 8), 1);
      return -1;
    case 13:
      Curl_pgrsUpdate(*(int **)(HIDWORD(a1) + 12));
      v54 = *(_QWORD **)(HIDWORD(v1) + 8);
      v55 = v54[57];
      if ( v55 && v54[121] >= v55 )
        goto LABEL_12;
      v56 = v54[58];
      if ( v56 )
      {
        if ( v54[120] >= v56 )
          goto LABEL_12;
      }
      if ( *(_DWORD *)(HIDWORD(v1) + 16) == 12 )
        goto LABEL_12;
      v57 = 12;
      goto LABEL_133;
    case 14:
      Curl_removeHandleFromPipeline(*(_DWORD *)(HIDWORD(a1) + 8), *(_DWORD ***)(*(_DWORD *)(HIDWORD(a1) + 12) + 376));
      sub_6A08C(*(_DWORD *)(HIDWORD(v1) + 12), v74, v75);
      v2 = -*(unsigned __int8 *)(*(_DWORD *)(HIDWORD(v1) + 12) + 317);
      *(_DWORD *)(HIDWORD(v1) + 20) = Curl_done((int **)(HIDWORD(v1) + 12), 0, 0);
      sub_695A2(SHIDWORD(v1), 15);
      goto LABEL_165;
    case 15:
      v7 = 0;
      *(_DWORD *)(HIDWORD(a1) + 12) = 0;
      goto LABEL_168;
    default:
      return 4;
  }
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006A878) --------------------------------------------------------
signed int __fastcall curl_multi_perform(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r8
  int v3; // r4
  signed int v4; // r5
  _DWORD *v5; // r6
  int v6; // r7
  signed int v7; // r0
  int *v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r2
  int v13; // [sp+4h] [bp-2Ch]
  int *v14; // [sp+8h] [bp-28h]
  int v15; // [sp+Ch] [bp-24h]

  v2 = a2;
  v3 = (int)a1;
  if ( !a1 || *a1 != 764702 )
    return 1;
  v4 = 0;
  v6 = (int)(a1 + 1);
  v5 = (_DWORD *)a1[1];
  while ( v5 != (_DWORD *)v6 )
  {
    v7 = sub_6A13C(COERCE_DOUBLE(__PAIR__((unsigned int)v5, v3)));
    v5 = (_DWORD *)*v5;
    if ( v7 )
      v4 = v7;
  }
  while ( 1 )
  {
    curlx_tvnow((__time_t *)&v14);
    v8 = Curl_splaygetbest(v14, v15, *(int **)(v3 + 84), &v13);
    v10 = v13;
    *(_DWORD *)(v3 + 84) = v8;
    if ( !v10 )
      break;
    v11 = *(_DWORD *)(v10 + 20) + 34048;
    *(_DWORD *)(v11 + 60) = 0;
    *(_DWORD *)(v11 + 64) = 0;
  }
  *v2 = *(_DWORD *)(v3 + 68);
  if ( v4 <= 0 )
    sub_6989C(v3, v9, 0);
  return v4;
}

//----- (0006A8FC) --------------------------------------------------------
signed int __fastcall sub_6A8FC(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // r4
  int v6; // r6
  signed int v7; // r0
  _DWORD *v8; // r5
  signed int v9; // r6
  int v10; // r0
  int v11; // r5
  int v12; // r3
  int **v13; // r2
  int *v14; // r2
  int **v15; // r3
  int *v16; // r3
  int v17; // r3
  double v18; // r0
  signed int v19; // r0
  int v20; // r3
  int *v21; // r2
  int *v22; // r0
  int v23; // r2
  int v24; // r5
  int v25; // r3
  double v26; // r0
  int v28; // [sp+4h] [bp-34h]
  int v29; // [sp+Ch] [bp-2Ch]
  int *v30; // [sp+10h] [bp-28h]
  int v31; // [sp+14h] [bp-24h]

  v5 = (_DWORD *)a1;
  v6 = a4;
  v28 = a3;
  if ( a2 )
  {
    v7 = curl_multi_perform((_DWORD *)a1, a5);
    v8 = (_DWORD *)v5[1];
    v9 = v7;
    while ( v8 != v5 + 1 )
    {
      sub_696A8((int)v5, v8);
      v8 = (_DWORD *)*v8;
    }
    return v9;
  }
  if ( a3 == -1 || (v10 = Curl_hash_pick(*(int **)(a1 + 88), (int)&v28, 4)) == 0 )
  {
    v9 = 0;
LABEL_24:
    while ( 1 )
    {
      curlx_tvnow((__time_t *)&v30);
      v21 = (int *)v5[21];
      v31 += 1000;
      v22 = Curl_splaygetbest(v30, v31, v21, &v29);
      v23 = v29;
      v5[21] = v22;
      if ( !v23 )
        break;
      v24 = *(_DWORD *)(v23 + 20);
      v25 = v24 + 34048;
      *(_DWORD *)(v25 + 60) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      if ( v24 )
      {
        LODWORD(v26) = v5;
        HIDWORD(v26) = *(_DWORD *)(v24 + 612);
        v9 = sub_6A13C(v26);
        if ( v9 <= 0 )
          sub_696A8((int)v5, *(_DWORD **)(v24 + 612));
      }
    }
    *a5 = v5[17];
    return v9;
  }
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)(*(_DWORD *)v10 + 34312) == -1059136595 )
  {
    v12 = *(_DWORD *)(*(_DWORD *)(v11 + 612) + 12);
    if ( v12 )
    {
      if ( v6 & 2 && (v13 = *(int ***)(v12 + 372)) != 0 && (v14 = *v13) != 0 )
      {
        v11 = *v14;
      }
      else if ( v6 & 1 )
      {
        v15 = *(int ***)(v12 + 376);
        if ( v15 )
        {
          v16 = *v15;
          if ( v16 )
            v11 = *v16;
        }
      }
    }
    v17 = *(_DWORD *)(*(_DWORD *)(v11 + 612) + 12);
    if ( v17 )
      *(_DWORD *)(v17 + 840) = v6;
    LODWORD(v18) = v5;
    HIDWORD(v18) = *(_DWORD *)(v11 + 612);
    v19 = sub_6A13C(v18);
    v20 = *(_DWORD *)(*(_DWORD *)(v11 + 612) + 12);
    v9 = v19;
    if ( v20 )
      *(_DWORD *)(v20 + 840) = 0;
    if ( v19 <= 0 )
      sub_696A8((int)v5, *(_DWORD **)(v11 + 612));
    goto LABEL_24;
  }
  return 4;
}

//----- (0006AA1C) --------------------------------------------------------
signed int __fastcall curl_multi_socket(int a1, int a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r1
  int v5; // r2
  signed int v6; // r5

  v3 = a1;
  v6 = sub_6A8FC(a1, 0, a2, 0, a3);
  if ( v6 <= 0 )
    sub_6989C(v3, v4, v5);
  return v6;
}

//----- (0006AA3E) --------------------------------------------------------
signed int __fastcall curl_multi_socket_action(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r4
  int v5; // r1
  int v6; // r2
  signed int v7; // r5

  v4 = a1;
  v7 = sub_6A8FC(a1, 0, a2, a3, a4);
  if ( v7 <= 0 )
    sub_6989C(v4, v5, v6);
  return v7;
}

//----- (0006AA62) --------------------------------------------------------
signed int __fastcall curl_multi_socket_all(int a1, _DWORD *a2)
{
  int v2; // r4
  int v3; // r1
  int v4; // r2
  signed int v5; // r5

  v2 = a1;
  v5 = sub_6A8FC(a1, 1, -1, 0, a2);
  if ( v5 <= 0 )
    sub_6989C(v2, v3, v4);
  return v5;
}

//----- (0006AA84) --------------------------------------------------------
signed int __fastcall curl_multi_assign(int a1, int a2, int a3)
{
  int v3; // r4
  int v5; // r0
  int v6; // [sp+4h] [bp-Ch]

  v3 = a3;
  v6 = a2;
  if ( a2 == -1 )
    return 5;
  v5 = Curl_hash_pick(*(int **)(a1 + 88), (int)&v6, 4);
  if ( !v5 )
    return 5;
  *(_DWORD *)(v5 + 20) = v3;
  return 0;
}

//----- (0006AAA8) --------------------------------------------------------
const char *__fastcall curl_easy_strerror(int a1)
{
  const char *result; // r0

  switch ( a1 )
  {
    case 0:
      result = "No error";
      break;
    case 1:
      result = "Unsupported protocol";
      break;
    case 2:
      result = "Failed initialization";
      break;
    case 3:
      result = "URL using bad/illegal format or missing URL";
      break;
    case 5:
      result = "Couldn't resolve proxy name";
      break;
    case 6:
      result = "Couldn't resolve host name";
      break;
    case 7:
      result = "Couldn't connect to server";
      break;
    case 8:
      result = "FTP: weird server reply";
      break;
    case 9:
      result = "Access denied to remote resource";
      break;
    case 11:
      result = "FTP: unknown PASS reply";
      break;
    case 13:
      result = "FTP: unknown PASV reply";
      break;
    case 14:
      result = "FTP: unknown 227 response format";
      break;
    case 15:
      result = "FTP: can't figure out the host in the PASV response";
      break;
    case 17:
      result = "FTP: couldn't set file type";
      break;
    case 18:
      result = "Transferred a partial file";
      break;
    case 19:
      result = "FTP: couldn't retrieve (RETR failed) the specified file";
      break;
    case 21:
      result = "Quote command returned error";
      break;
    case 22:
      result = "HTTP response code said error";
      break;
    case 23:
      result = "Failed writing received data to disk/application";
      break;
    case 25:
      result = "Upload failed (at start/before it took off)";
      break;
    case 26:
      result = "Failed to open/read local data from file/application";
      break;
    case 27:
      result = "Out of memory";
      break;
    case 28:
      result = "Timeout was reached";
      break;
    case 30:
      result = "FTP: command PORT failed";
      break;
    case 31:
      result = "FTP: command REST failed";
      break;
    case 33:
      result = "Requested range was not delivered by the server";
      break;
    case 34:
      result = "Internal problem setting up the POST";
      break;
    case 35:
      result = "SSL connect error";
      break;
    case 36:
      result = "Couldn't resume download";
      break;
    case 37:
      result = "Couldn't read a file:// file";
      break;
    case 38:
      result = "LDAP: cannot bind";
      break;
    case 39:
      result = "LDAP: search failed";
      break;
    case 41:
      result = "A required function in the library was not found";
      break;
    case 42:
      result = "Operation was aborted by an application callback";
      break;
    case 43:
      result = "A libcurl function was given a bad argument";
      break;
    case 45:
      result = "Failed binding local connection end";
      break;
    case 47:
      result = "Number of redirects hit maximum amount";
      break;
    case 48:
      result = "User specified an unknown telnet option";
      break;
    case 49:
      result = "Malformed telnet option";
      break;
    case 51:
      result = "SSL peer certificate or SSH remote key was not OK";
      break;
    case 52:
      result = "Server returned nothing (no headers, no data)";
      break;
    case 53:
      result = "SSL crypto engine not found";
      break;
    case 54:
      result = "Can not set SSL crypto engine as default";
      break;
    case 55:
      result = "Failed sending data to the peer";
      break;
    case 56:
      result = "Failure when receiving data from the peer";
      break;
    case 58:
      result = "Problem with the local SSL certificate";
      break;
    case 59:
      result = "Couldn't use specified SSL cipher";
      break;
    case 60:
      result = "Peer certificate cannot be authenticated with known CA certificates";
      break;
    case 61:
      result = "Unrecognized HTTP Content-Encoding";
      break;
    case 62:
      result = "Invalid LDAP URL";
      break;
    case 63:
      result = "Maximum file size exceeded";
      break;
    case 64:
      result = "Requested SSL level failed";
      break;
    case 65:
      result = "Send failed since rewinding of the data stream failed";
      break;
    case 66:
      result = "Failed to initialise SSL crypto engine";
      break;
    case 67:
      result = "Login denied";
      break;
    case 68:
      result = "TFTP: File Not Found";
      break;
    case 69:
      result = "TFTP: Access Violation";
      break;
    case 70:
      result = "Disk full or allocation exceeded";
      break;
    case 71:
      result = "TFTP: Illegal operation";
      break;
    case 72:
      result = "TFTP: Unknown transfer ID";
      break;
    case 73:
      result = "Remote file already exists";
      break;
    case 74:
      result = "TFTP: No such user";
      break;
    case 75:
      result = "Conversion failed";
      break;
    case 76:
      result = "Caller must register CURLOPT_CONV_ callback options";
      break;
    case 77:
      result = "Problem with the SSL CA cert (path? access rights?)";
      break;
    case 78:
      result = "Remote file not found";
      break;
    case 79:
      result = "Error in the SSH layer";
      break;
    case 80:
      result = "Failed to shut down the SSL connection";
      break;
    case 81:
      result = "Socket not ready for send/recv";
      break;
    case 82:
      result = "Failed to load CRL file (path? access rights?, format?)";
      break;
    case 83:
      result = "Issuer check against peer certificate failed";
      break;
    default:
      result = "Unknown error";
      break;
  }
  return result;
}

//----- (0006AE2C) --------------------------------------------------------
const char *__fastcall curl_multi_strerror(int a1)
{
  const char *result; // r0

  switch ( a1 + 1 )
  {
    case 0:
      result = "Please call curl_multi_perform() soon";
      break;
    case 1:
      result = "No error";
      break;
    case 2:
      result = "Invalid multi handle";
      break;
    case 3:
      result = "Invalid easy handle";
      break;
    case 4:
      result = "Out of memory";
      break;
    case 5:
      result = "Internal error";
      break;
    case 6:
      result = "Invalid socket argument";
      break;
    case 7:
      result = "Unknown option";
      break;
    default:
      result = "Unknown error";
      break;
  }
  return result;
}

//----- (0006AE98) --------------------------------------------------------
const char *__fastcall curl_share_strerror(int a1)
{
  const char *result; // r0

  switch ( a1 )
  {
    case 0:
      result = "No error";
      break;
    case 1:
      result = "Unknown share option";
      break;
    case 2:
      result = "Share currently in use";
      break;
    case 3:
      result = "Invalid share handle";
      break;
    case 4:
      result = "Out of memory";
      break;
    default:
      result = "CURLSHcode unknown";
      break;
  }
  return result;
}

//----- (0006AEE4) --------------------------------------------------------
int __fastcall Curl_strerror(int a1, int a2, int a3, int a4)
{
  int v4; // r5
  int v5; // r7
  _BYTE *v6; // r4
  int v7; // r6
  char *v8; // r0
  char *v9; // r0
  int v10; // r1
  int v11; // r2
  _DWORD *v12; // r0
  int v13; // r1
  int v14; // r2
  int v16; // [sp+0h] [bp-18h]

  v16 = a4;
  v4 = a1;
  v5 = a2;
  v6 = (_BYTE *)(a1 + 444);
  v7 = *(_DWORD *)_errno(a1, a2, a3);
  *v6 = 0;
  if ( strerror_r(v5, v6, 255) && !*(_BYTE *)(v4 + 444) )
    curl_msnprintf(v4 + 444, 255, "Unknown error %d", v5, v16);
  *(_BYTE *)(v4 + 699) = 0;
  v8 = strrchr((const char *)(v4 + 444), 10);
  if ( v8 && v8 - v6 > 1 )
    *v8 = 0;
  v9 = strrchr((const char *)(v4 + 444), 13);
  if ( v9 && v9 - v6 > 0 )
    *v9 = 0;
  v12 = (_DWORD *)_errno(v9, v10, v11);
  if ( v7 != *v12 )
    *(_DWORD *)_errno(v12, v13, v14) = v7;
  return v4 + 444;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 258B0: using guessed type int __fastcall strerror_r(_DWORD, _DWORD, _DWORD);

//----- (0006AF60) --------------------------------------------------------
int __fastcall sub_6AF60(int a1, signed int a2)
{
  int v2; // r8
  signed int v3; // r9
  int v4; // r0
  int v5; // r3
  signed int v6; // r4
  char *v7; // r6
  int v8; // r9
  signed int v9; // r7
  int v10; // r6
  int v11; // r1
  int v12; // r2
  int v14; // [sp+0h] [bp-E0h]
  char v15; // [sp+40h] [bp-A0h]

  v2 = a1 + 34048;
  v3 = a2;
  v4 = ares_getsock(*(_DWORD *)(a1 + 34104), (int)&v14, 16);
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = &v15 + v5;
    *((_WORD *)v7 + 2) = 0;
    *((_WORD *)v7 + 3) = 0;
    if ( (v4 >> v6) & 1 )
    {
      *(_DWORD *)(&v15 + v5) = *(&v14 + v6);
      *((_WORD *)v7 + 2) |= 0x41u;
    }
    if ( (v4 >> (v6 + 16)) & 1 )
    {
      *(_DWORD *)(&v15 + v5) = *(&v14 + v6);
      *((_WORD *)v7 + 2) |= 0x104u;
    }
    if ( !*((_WORD *)v7 + 2) )
      break;
    ++v6;
    v5 += 8;
    if ( v6 == 16 )
      goto LABEL_10;
  }
  if ( !v6 )
  {
LABEL_11:
    v8 = 0;
    ares_process_fd(*(int **)(v2 + 56), -1, -1);
    return v8;
  }
LABEL_10:
  v8 = Curl_poll((struct pollfd *)&v15, v6, v3, v5);
  if ( !v8 )
    goto LABEL_11;
  v9 = 0;
  v10 = 0;
  do
  {
    ++v9;
    if ( *(_WORD *)(&v15 + v10 + 6) & 0x41 )
      v11 = *(_DWORD *)(&v15 + v10);
    else
      v11 = -1;
    if ( *(_WORD *)(&v15 + v10 + 6) & 0x104 )
      v12 = *(_DWORD *)(&v15 + v10);
    else
      v12 = -1;
    ares_process_fd(*(int **)(v2 + 56), v11, v12);
    v10 += 8;
  }
  while ( v9 < v6 );
  return v8;
}

//----- (0006B026) --------------------------------------------------------
int __fastcall Curl_resolv_getsock(int a1, int a2, signed int a3, int a4)
{
  int **v4; // r4
  int v5; // r0
  int v6; // r5
  _DWORD *v7; // r0
  int v9; // [sp+0h] [bp-20h]
  int v10; // [sp+4h] [bp-1Ch]
  int v11; // [sp+8h] [bp-18h]
  int v12; // [sp+Ch] [bp-14h]

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v4 = (int **)a1;
  v5 = ares_getsock(*(_DWORD *)(*(_DWORD *)a1 + 34104), a2, a3);
  v9 = 300;
  v10 = 0;
  v6 = v5;
  v7 = ares_timeout((*v4)[8526], &v9, &v11);
  Curl_expire(*v4, 1000 * *v7 + v7[1] / 1000);
  return v6;
}

//----- (0006B070) --------------------------------------------------------
signed int __fastcall Curl_is_resolved(int *a1, int *a2, int a3, int a4)
{
  int v4; // r7
  int *v5; // r4
  int *v6; // r6
  int v7; // r3
  int v8; // r5
  const char *v9; // r0
  signed int result; // r0
  int v11; // [sp+0h] [bp-18h]

  v11 = a4;
  v4 = *a1;
  v5 = a1;
  *a2 = 0;
  v6 = a2;
  sub_6AF60(*a1, 0);
  if ( !*((_BYTE *)v5 + 712) )
    return *((unsigned __int8 *)v5 + 712);
  v7 = v5[177];
  if ( v7 )
  {
    *v6 = v7;
    result = 0;
  }
  else
  {
    v8 = v5[36];
    v9 = ares_strerror(v5[179]);
    Curl_failf(v4, "Could not resolve host: %s (%s)", v8, v9, v11);
    result = 6;
  }
  return result;
}

//----- (0006B0BC) --------------------------------------------------------
signed int __fastcall Curl_wait_for_resolv(int *a1, _DWORD *a2)
{
  int *v2; // r4
  int v3; // r5
  _DWORD *v4; // r8
  signed int v5; // r10
  int v6; // r0
  _DWORD *v7; // r0
  int v8; // r0
  unsigned int v9; // r0
  int v10; // r6
  const char *v11; // r0
  signed int result; // r0
  int v13; // [sp+0h] [bp-50h]
  __time_t v14; // [sp+8h] [bp-48h]
  int v15; // [sp+Ch] [bp-44h]
  char v16; // [sp+10h] [bp-40h]
  int v17; // [sp+18h] [bp-38h]
  int v18; // [sp+1Ch] [bp-34h]
  __time_t v19; // [sp+20h] [bp-30h]
  int v20; // [sp+24h] [bp-2Ch]

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  curlx_tvnow(&v14);
  v5 = *(_DWORD *)(*v2 + 428);
  if ( !v5 )
  {
    v5 = *(_DWORD *)(*v2 + 424);
    if ( !v5 )
      v5 = 300000;
  }
  while ( 1 )
  {
    v17 = v5 / 1000;
    v6 = *(_DWORD *)(v3 + 34104);
    v18 = 1000 * (v5 % 1000);
    v7 = ares_timeout(v6, &v17, &v16);
    v13 = 1000 * *v7;
    sub_6AF60(*v2, v13 + v7[1] / 1000);
    if ( *((_BYTE *)v2 + 712) )
      break;
    curlx_tvnow(&v19);
    v8 = curlx_tvdiff(v19, v20, v14, v15);
    if ( !v8 )
      v8 = 1;
    v5 -= v8;
    if ( v5 < 0 )
    {
      ares_cancel(*(_DWORD **)(v3 + 34104));
      break;
    }
  }
  if ( v4 )
    *v4 = v2[177];
  if ( !v2[177] )
  {
    if ( v5 >= 0 && (v9 = v2[179], v9 != 12) )
    {
      if ( !*((_BYTE *)v2 + 712) )
      {
        result = 28;
        goto LABEL_19;
      }
      v10 = v2[36];
      v11 = ares_strerror(v9);
      Curl_failf(v3, "Could not resolve host: %s (%s)", v10, v11, v13, &v17);
    }
    else
    {
      Curl_failf(v3, "Resolving host timed out: %s", v2[36]);
    }
    result = 6;
LABEL_19:
    *((_BYTE *)v2 + 296) = 1;
    return result;
  }
  return 0;
}

//----- (0006B1DC) --------------------------------------------------------
int __fastcall Curl_getaddrinfo(int *a1, const char *a2, int a3, _DWORD *a4)
{
  int v4; // r10
  int *v5; // r4
  int v6; // r9
  char *v7; // r6
  _DWORD *v8; // r8
  int result; // r0
  int v10; // r7
  _BYTE savedregs[36]; // [sp+Ch] [bp+0h]

  *(_DWORD *)savedregs = a4;
  v4 = *a1;
  v5 = a1;
  v6 = a3;
  *a4 = 0;
  v7 = (char *)a2;
  v8 = a4;
  if ( inet_pton(2, a2, savedregs) > 0 )
    return Curl_ip2addr(2, (int *)savedregs, (int)v7, v6);
  result = Curl_cstrdup(v7);
  v10 = result;
  if ( result )
  {
    Curl_safefree(v5[175]);
    v5[175] = v10;
    v5[176] = v6;
    *((_BYTE *)v5 + 712) = 0;
    v5[179] = 0;
    v5[177] = 0;
    ares_gethostbyname(*(_DWORD *)(v4 + 34104), v7, 2, (int)Curl_addrinfo4_callback, (int)v5);
    result = 0;
    *v8 = 1;
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (0006B268) --------------------------------------------------------
signed int __fastcall Curl_addrinfo4_callback(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  int v5; // r7
  int v6; // r5
  signed int v7; // r6
  const char *v8; // r8

  v4 = a1;
  *(_DWORD *)(a1 + 716) = a2;
  if ( a2 )
  {
    v7 = 0;
    v8 = 0;
  }
  else
  {
    v5 = Curl_addrinfo_copy(a4, *(_DWORD *)(a1 + 704));
    if ( v5 )
    {
      v6 = *(_DWORD *)v4;
      if ( *(_DWORD *)(*(_DWORD *)v4 + 16) )
        Curl_share_lock(*(_DWORD *)v4, 3);
      v7 = 0;
      v8 = Curl_cache_addr((int **)v6, v5, *(_DWORD *)(v4 + 700), *(_DWORD *)(v4 + 704));
      if ( !v8 )
      {
        v7 = 27;
        Curl_freeaddrinfo(v5);
      }
      if ( *(_DWORD *)(v6 + 16) )
        Curl_share_unlock(v6, 3);
    }
    else
    {
      v7 = 27;
      v8 = 0;
    }
  }
  *(_DWORD *)(v4 + 708) = v8;
  *(_BYTE *)(v4 + 712) = 1;
  return v7;
}
// 6BEA4: using guessed type int __fastcall Curl_addrinfo_copy(_DWORD, _DWORD);

//----- (0006B2D8) --------------------------------------------------------
signed int __fastcall sub_6B2D8(signed int result, int a2, int a3)
{
  signed int v3; // r5
  int v4; // r2
  int v5; // r0
  int v6; // r1
  int v7; // r2
  signed int v8; // r4
  int v9; // [sp+0h] [bp-28h]
  int v10; // [sp+4h] [bp-24h]
  __time_t v11; // [sp+8h] [bp-20h]
  int v12; // [sp+Ch] [bp-1Ch]

  v3 = result;
  if ( result )
  {
    if ( result < 0 )
    {
      *(_DWORD *)_errno(result, a2, a3) = 22;
      result = -1;
    }
    else
    {
      curlx_tvnow(&v9);
      v4 = v3;
      while ( 1 )
      {
        v5 = poll(0, 0, v4);
        v8 = v5;
        if ( v5 != -1 )
          break;
        if ( !(*(_DWORD *)_errno(-1, v6, v7) & 0xFFFFFFFB) )
        {
          curlx_tvnow(&v11);
          v4 = v3 - curlx_tvdiff(v11, v12, v9, v10);
          if ( v4 > 0 )
            continue;
        }
        goto LABEL_11;
      }
      v8 = v5;
      if ( v5 )
        v8 = -1;
LABEL_11:
      result = v8;
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0006B342) --------------------------------------------------------
signed int __fastcall Curl_socket_ready(int a1, int a2, signed int a3)
{
  int v3; // r8
  int v4; // r7
  signed int v5; // r4
  signed int result; // r0
  int v7; // r5
  nfds_t v8; // r6
  _WORD *v9; // r3
  int v10; // r1
  int v11; // r2
  signed int v12; // r3
  int v13; // [sp+0h] [bp-40h]
  int v14; // [sp+4h] [bp-3Ch]
  __time_t v15; // [sp+8h] [bp-38h]
  int v16; // [sp+Ch] [bp-34h]
  struct pollfd fds; // [sp+10h] [bp-30h]
  _WORD v18[4]; // [sp+20h] [bp-20h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v13 = 0;
  v14 = 0;
  if ( a1 == -1 && a2 == -1 )
    return sub_6B2D8(a3, 0, a3);
  if ( a3 <= 0 )
  {
    v7 = 0;
  }
  else
  {
    v7 = a3;
    curlx_tvnow(&v13);
  }
  v8 = 0;
  if ( v3 != -1 )
  {
    fds.revents = 0;
    v8 = 1;
    fds.fd = v3;
    fds.events = 195;
  }
  if ( v4 != -1 )
  {
    v9 = &v18[4 * v8++];
    *((_DWORD *)v9 - 4) = v4;
    *(v9 - 6) = 260;
    *(v9 - 5) = 0;
  }
  while ( 1 )
  {
    if ( v5 < 0 )
    {
      v7 = -1;
    }
    else if ( !v5 )
    {
      v7 = 0;
    }
    result = poll(&fds, v8, v7);
    if ( result != -1 )
      break;
    if ( !(*(_DWORD *)_errno(-1, v10, v11) & 0xFFFFFFFB) )
    {
      if ( v5 <= 0 )
        continue;
      curlx_tvnow(&v15);
      v7 = v5 - curlx_tvdiff(v15, v16, v13, v14);
      if ( v7 > 0 )
        continue;
    }
    return -1;
  }
  if ( result < 0 )
    return -1;
  if ( result )
  {
    if ( v3 == -1 )
    {
      result = 0;
      v12 = 0;
    }
    else
    {
      result = (fds.revents & 0x59) != 0;
      if ( fds.revents & 0xA2 )
        result |= 4u;
      v12 = 1;
    }
    if ( v4 != -1 )
    {
      LOWORD(v12) = v18[4 * v12 - 5];
      if ( v12 & 0x104 )
        result |= 2u;
      if ( v12 & 0x38 )
        result |= 4u;
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0006B45A) --------------------------------------------------------
int __fastcall Curl_poll(struct pollfd *a1, nfds_t a2, signed int a3, int a4)
{
  int v4; // r3
  nfds_t v5; // r8
  signed int v6; // r4
  struct pollfd *v7; // r6
  int result; // r0
  int v9; // r5
  int v10; // r1
  int v11; // r2
  int v12; // [sp+0h] [bp-28h]
  int v13; // [sp+4h] [bp-24h]
  int v14; // [sp+8h] [bp-20h]
  int v15; // [sp+Ch] [bp-1Ch]

  v14 = a3;
  v15 = a4;
  v4 = 0;
  v5 = a2;
  v6 = a3;
  v12 = 0;
  v7 = a1;
  v13 = 0;
  if ( a1 )
  {
    while ( v4 != a2 )
    {
      a3 = a1[v4].fd + 1;
      if ( a1[v4].fd != -1 )
      {
        if ( v6 <= 0 )
        {
          v9 = 0;
        }
        else
        {
          v9 = v6;
          curlx_tvnow(&v12);
        }
        while ( 1 )
        {
          if ( v6 < 0 )
          {
            v9 = -1;
          }
          else if ( !v6 )
          {
            v9 = 0;
          }
          result = poll(v7, v5, v9);
          if ( result != -1 )
            break;
          if ( !(*(_DWORD *)_errno(-1, v10, v11) & 0xFFFFFFFB) )
          {
            if ( v6 <= 0 )
              continue;
            curlx_tvnow(&v14);
            v9 = v6 - curlx_tvdiff(v14, v15, v12, v13);
            if ( v9 > 0 )
              continue;
          }
          return -1;
        }
        return result;
      }
      ++v4;
    }
  }
  return sub_6B2D8(v6, a2, a3);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0006B4EC) --------------------------------------------------------
int *__fastcall Curl_splay(int *a1, int a2, int *a3)
{
  int v3; // r4
  int *v4; // r1
  int *v5; // r5
  int v6; // r3
  int v7; // r3
  int **v8; // r3
  int *v9; // r6
  int v10; // r3
  int *v11; // r6
  int v13; // [sp+8h] [bp-28h]
  int v14; // [sp+Ch] [bp-24h]

  v3 = a2;
  if ( !a3 )
    return a3;
  v14 = 0;
  v13 = 0;
  v4 = &v13;
  v5 = &v13;
  while ( 1 )
  {
    v6 = a3[3];
    if ( (signed int)a1 < v6 )
      break;
    if ( (signed int)a1 <= v6 )
    {
      v7 = a3[4];
      if ( v3 < v7 )
        break;
      if ( v3 <= v7 )
        goto LABEL_16;
    }
    v8 = (int **)a3[1];
    if ( !v8 )
      goto LABEL_16;
    v9 = v8[3];
    if ( (signed int)a1 >= (signed int)v9 && ((signed int)a1 > (signed int)v9 || v3 > (signed int)v8[4]) )
    {
      a3[1] = (int)*v8;
      *v8 = a3;
      if ( !v8[1] )
        goto LABEL_15;
      a3 = (int *)v8;
    }
    v5[1] = (int)a3;
    v5 = a3;
    v10 = a3[1];
    a3 = v4;
LABEL_14:
    v4 = a3;
    a3 = (int *)v10;
  }
  v8 = (int **)*a3;
  if ( !*a3 )
    goto LABEL_16;
  v11 = v8[3];
  if ( (signed int)a1 >= (signed int)v11 && ((signed int)a1 > (signed int)v11 || v3 >= (signed int)v8[4]) )
  {
LABEL_23:
    *v4 = (int)a3;
    v10 = *a3;
    goto LABEL_14;
  }
  *a3 = (int)v8[1];
  v8[1] = a3;
  if ( *v8 )
  {
    a3 = (int *)v8;
    goto LABEL_23;
  }
LABEL_15:
  a3 = (int *)v8;
LABEL_16:
  v5[1] = *a3;
  *v4 = a3[1];
  *a3 = v14;
  a3[1] = v13;
  return a3;
}

//----- (0006B584) --------------------------------------------------------
int *__fastcall Curl_splayinsert(int *a1, int a2, int *a3, _DWORD *a4)
{
  int v4; // r5
  _DWORD *v5; // r4
  int *result; // r0
  int *v7; // r0
  int *v8; // r3
  _DWORD *v9; // r3
  int v10; // r3
  int v11; // r3
  int *v12; // [sp+0h] [bp-20h]

  v4 = a2;
  v12 = a1;
  v5 = a4;
  result = a3;
  if ( a4 )
  {
    if ( !a3 )
    {
      a4[1] = 0;
      *a4 = 0;
      goto LABEL_11;
    }
    v7 = Curl_splay(v12, a2, a3);
    v8 = (int *)v7[3];
    if ( v12 == v8 )
    {
      if ( v4 == v7[4] )
      {
        v5[2] = v7;
        v5[3] = v12;
        v5[4] = v4;
        *v5 = *v7;
        v5[1] = v7[1];
        *v7 = (int)v5;
        v9 = v7 + 3;
        *v9 = -1;
        v9[1] = -1;
        return v5;
      }
    }
    else
    {
      if ( (signed int)v12 < (signed int)v8 )
      {
LABEL_9:
        v10 = *v7;
        v5[1] = v7;
        *v5 = v10;
        *v7 = 0;
LABEL_11:
        v5[3] = v12;
        v5[4] = v4;
        v5[2] = 0;
        return v5;
      }
      if ( (signed int)v12 > (signed int)v8 )
      {
LABEL_10:
        v11 = v7[1];
        *v5 = v7;
        v5[1] = v11;
        v7[1] = 0;
        goto LABEL_11;
      }
    }
    if ( v4 < v7[4] )
      goto LABEL_9;
    goto LABEL_10;
  }
  return result;
}

//----- (0006B60C) --------------------------------------------------------
int *__fastcall Curl_splaygetbest(int *a1, int a2, int *a3, _DWORD *a4)
{
  _DWORD *v4; // r6
  int *v5; // r8
  int v6; // r7
  int *v7; // r4
  int *v8; // r0
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int *v12; // r2
  _DWORD *v13; // r3
  int v14; // r1
  int *result; // r0
  int *v16; // [sp+0h] [bp-20h]
  int v17; // [sp+4h] [bp-1Ch]

  v4 = a4;
  v16 = a1;
  v17 = a2;
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if ( !a3 )
  {
    *a4 = 0;
    return v7;
  }
  v8 = Curl_splay(a1, a2, a3);
  v9 = v8[3];
  v7 = v8;
  if ( (signed int)v5 < v9 || (signed int)v5 <= v9 && v6 < v8[4] )
  {
    v10 = *v8;
    if ( !*v8 )
    {
LABEL_18:
      *v4 = v10;
      return v7;
    }
    v7 = Curl_splay(*(int **)(v10 + 12), *(_DWORD *)(v10 + 16), v8);
  }
  v11 = v7[3];
  if ( (signed int)v5 < v11 || (signed int)v5 <= v11 && v6 < v7[4] )
  {
    v10 = 0;
    goto LABEL_18;
  }
  v12 = (int *)v7[2];
  if ( v12 )
  {
    v13 = v12 + 3;
    v14 = v7[4];
    *v13 = v7[3];
    v13[1] = v14;
    result = v12;
    v12[1] = v7[1];
    *v12 = *v7;
    *v4 = v7;
  }
  else
  {
    if ( *v7 )
    {
      result = Curl_splay(v16, v17, (int *)*v7);
      result[1] = v7[1];
    }
    else
    {
      result = (int *)v7[1];
    }
    *v4 = v7;
  }
  return result;
}

//----- (0006B6A0) --------------------------------------------------------
signed int __fastcall Curl_splayremovebyaddr(int *a1, int a2, int **a3)
{
  int *v3; // r3
  int v4; // r4
  int **v5; // r6
  _DWORD *v6; // r2
  signed int result; // r0
  int **v8; // r5
  int *v9; // r3
  int *v10; // r1
  int **v11; // r2

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !a1 || !a2 )
    return 1;
  if ( *(_DWORD *)(a2 + 12) != -1 || *(_DWORD *)(a2 + 16) != -1 )
  {
    v8 = (int **)(a2 + 12);
    if ( (int *)a2 == Curl_splay(*(int **)(a2 + 12), *(_DWORD *)(a2 + 16), a1) )
    {
      v9 = *(int **)(v4 + 8);
      if ( v9 )
      {
        v10 = *(int **)(v4 + 16);
        v11 = (int **)(v9 + 3);
        *v11 = *v8;
        v11[1] = v10;
        v9[1] = *(_DWORD *)(v4 + 4);
        *v9 = *(_DWORD *)v4;
      }
      else if ( *(_DWORD *)v4 )
      {
        v9 = Curl_splay(*v8, *(_DWORD *)(v4 + 16), *(int **)v4);
        v9[1] = *(_DWORD *)(v4 + 4);
      }
      else
      {
        v9 = *(int **)(v4 + 4);
      }
      *v5 = v9;
      result = 0;
    }
    else
    {
      result = 2;
    }
  }
  else if ( *(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 8) = *(_DWORD *)(a2 + 8);
    v6 = *(_DWORD **)(a2 + 8);
    if ( v6 )
      *v6 = *(_DWORD *)a2;
    result = 0;
    *(_DWORD *)a2 = 0;
    *v5 = v3;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (0006B72C) --------------------------------------------------------
int __fastcall Curl_freeaddrinfo(int result)
{
  _DWORD *i; // r4
  int v2; // r0
  int v3; // r0
  _DWORD *v4; // r6

  for ( i = (_DWORD *)result; i; i = v4 )
  {
    v2 = i[6];
    if ( v2 )
      Curl_cfree(v2);
    v3 = i[5];
    if ( v3 )
      Curl_cfree(v3);
    v4 = (_DWORD *)i[7];
    result = Curl_cfree(i);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006B75C) --------------------------------------------------------
int __fastcall Curl_getaddrinfo_ex(const char *a1, const char *a2, const struct addrinfo *a3, size_t **a4)
{
  size_t **v4; // r11
  int v5; // r6
  struct addrinfo *v6; // r5
  size_t *v7; // r10
  size_t *v8; // r7
  int *v9; // r0
  size_t *v10; // r4
  int v11; // r2
  signed int v12; // r0
  void *v13; // r0
  void (__cdecl *v14)(void *); // r3
  const char *v15; // r0
  char *v16; // r0
  void *v17; // r0
  int v18; // r0
  struct addrinfo *pai; // [sp+Ch] [bp-2Ch]

  v4 = a4;
  *a4 = 0;
  v5 = getaddrinfo(a1, a2, a3, &pai);
  if ( !v5 )
  {
    v6 = pai;
    v7 = 0;
    v8 = 0;
    while ( v6 )
    {
      v9 = (int *)((void *(__cdecl *)(size_t))Curl_cmalloc)(0x20u);
      v10 = (size_t *)v9;
      if ( !v9 )
        goto LABEL_21;
      *v9 = v6->ai_flags;
      v9[1] = v6->ai_family;
      v9[2] = v6->ai_socktype;
      v11 = v6->ai_protocol;
      v9[4] = 0;
      v9[6] = 0;
      v9[3] = v11;
      v9[5] = 0;
      v9[7] = 0;
      v12 = v6->ai_addrlen;
      if ( v12 > 0 && v6->ai_canonname )
      {
        v10[4] = v12;
        v13 = (void *)((int (*)(void))Curl_cmalloc)();
        v10[6] = (size_t)v13;
        if ( !v13 )
        {
          v14 = (void (__cdecl *)(void *))Curl_cfree;
LABEL_15:
          v14(v10);
LABEL_21:
          v5 = 6;
          break;
        }
        memcpy(v13, v6->ai_canonname, v10[4]);
      }
      v15 = (const char *)v6->ai_addr;
      if ( v15 )
      {
        v16 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v15);
        v10[5] = (size_t)v16;
        if ( !v16 )
        {
          v17 = (void *)v10[6];
          if ( v17 )
            ((void (__cdecl *)(void *))Curl_cfree)(v17);
          v14 = (void (__cdecl *)(void *))Curl_cfree;
          goto LABEL_15;
        }
      }
      if ( !v8 )
        v8 = v10;
      if ( v7 )
        v7[7] = (size_t)v10;
      v6 = v6->ai_next;
      v7 = v10;
    }
    if ( pai )
      freeaddrinfo(pai);
    if ( v5 )
    {
      v18 = (int)v8;
      v8 = 0;
      Curl_freeaddrinfo(v18);
    }
    *v4 = v8;
  }
  return v5;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006B854) --------------------------------------------------------
int __fastcall Curl_he2ai(int result, unsigned __int16 a2)
{
  int v2; // r5
  int v3; // r9
  unsigned int v4; // r11
  int v5; // r6
  _DWORD *i; // r7
  _DWORD *v7; // r8
  _DWORD *v8; // r4
  char *v9; // r0
  void (__cdecl *v10)(void *); // r3
  int v11; // r0
  int v12; // r3
  int v13; // r3

  v2 = result;
  if ( result )
  {
    v3 = 0;
    v4 = a2;
    v5 = 0;
    for ( i = 0; ; i = v8 )
    {
      v7 = *(_DWORD **)(*(_DWORD *)(v2 + 16) + v3);
      if ( !v7 )
        return v5;
      v8 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, 0x20u);
      if ( !v8 )
        break;
      v9 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(*(const char **)v2);
      v8[5] = v9;
      if ( !v9 )
      {
        v10 = (void (__cdecl *)(void *))Curl_cfree;
LABEL_9:
        v10(v8);
        break;
      }
      v11 = Curl_ccalloc(1, 16);
      v8[6] = v11;
      if ( !v11 )
      {
        ((void (__cdecl *)(void *))Curl_cfree)((void *)v8[5]);
        v10 = (void (__cdecl *)(void *))Curl_cfree;
        goto LABEL_9;
      }
      if ( !v5 )
        v5 = (int)v8;
      if ( i )
        i[7] = v8;
      v12 = *(_DWORD *)(v2 + 8);
      v8[2] = 1;
      v8[4] = 16;
      v8[1] = v12;
      if ( v12 == 2 )
      {
        v13 = v8[6];
        *(_DWORD *)(v13 + 4) = *v7;
        *(_WORD *)v13 = *(_DWORD *)(v2 + 8);
        *(_WORD *)(v13 + 2) = __rev16(v4);
      }
      v3 += 4;
    }
    Curl_freeaddrinfo(v5);
    result = 0;
  }
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006B928) --------------------------------------------------------
int __fastcall Curl_ip2addr(int a1, int *a2, int a3, unsigned __int16 a4)
{
  int v4; // r7
  unsigned __int16 v5; // r8
  int *v6; // r9
  int v7; // r6
  int result; // r0
  int *v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r2
  int v13; // r7

  v4 = a1;
  v5 = a4;
  v6 = a2;
  v7 = a3;
  result = Curl_cmalloc(32);
  v9 = (int *)result;
  if ( result )
  {
    v10 = Curl_cstrdup(v7);
    v11 = v10;
    if ( v10 )
    {
      if ( v4 == 2 )
      {
        v12 = *v6;
        *v9 = v10;
        v9[2] = 2;
        v9[5] = v12;
        v9[3] = 4;
        v9[1] = 0;
        v9[7] = 0;
        v9[4] = (int)(v9 + 6);
        v9[6] = (int)(v9 + 5);
        v13 = Curl_he2ai((int)v9, v5);
        Curl_cfree(v11);
        Curl_cfree(v9);
        result = v13;
      }
      else
      {
        Curl_cfree(v10);
        Curl_cfree(v9);
        result = 0;
      }
    }
    else
    {
      Curl_cfree(v9);
      result = v11;
    }
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006B9C8) --------------------------------------------------------
int *__fastcall curl_slist_append(int a1, int a2)
{
  int v2; // r5
  int v3; // r6
  int *v4; // r4
  int v5; // r0
  int v6; // r6
  int i; // r3

  v2 = a1;
  v3 = a2;
  v4 = (int *)Curl_cmalloc(8);
  if ( !v4 )
    return v4;
  v5 = Curl_cstrdup(v3);
  v6 = v5;
  if ( !v5 )
  {
    Curl_cfree(v4);
    return (int *)v6;
  }
  *v4 = v5;
  v4[1] = 0;
  if ( !v2 )
    return v4;
  for ( i = v2; *(_DWORD *)(i + 4); i = *(_DWORD *)(i + 4) )
    ;
  *(_DWORD *)(i + 4) = v4;
  return (int *)v2;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006BA28) --------------------------------------------------------
int __fastcall curl_slist_free_all(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r6

  v1 = (_DWORD *)result;
  if ( result )
  {
    while ( 1 )
    {
      v2 = (_DWORD *)v1[1];
      if ( *v1 )
        Curl_cfree(*v1);
      result = Curl_cfree(v1);
      if ( !v2 )
        break;
      v1 = v2;
    }
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006BA50) --------------------------------------------------------
int __fastcall Curl_slist_duplicate(int *a1)
{
  int *v1; // r5
  int i; // r4
  int result; // r0
  int *v4; // r0
  int *v5; // r6

  v1 = a1;
  for ( i = 0; ; i = (int)v4 )
  {
    result = i;
    if ( !v1 )
      break;
    v4 = curl_slist_append(i, *v1);
    v5 = v4;
    if ( !v4 )
    {
      curl_slist_free_all(i);
      return (int)v5;
    }
    v1 = (int *)v1[1];
  }
  return result;
}

//----- (0006BA76) --------------------------------------------------------
int __fastcall curlx_nonblock(int a1)
{
  int v1; // r4

  v1 = a1;
  fcntl(a1, 3, 0);
  return j_fcntl(v1, 4);
}

//----- (0006BA9E) --------------------------------------------------------
__time_t *__fastcall curlx_tvnow(__time_t *a1)
{
  __time_t *v1; // r4
  int v2; // r1
  __time_t v4; // [sp+0h] [bp-20h]
  int v5; // [sp+4h] [bp-1Ch]
  struct timespec tp; // [sp+8h] [bp-18h]

  v1 = a1;
  if ( clock_gettime(1, &tp) )
  {
    gettimeofday((struct timeval *)&v4, 0);
  }
  else
  {
    v4 = tp.tv_sec;
    v5 = tp.tv_nsec / 1000;
  }
  v2 = v5;
  *v1 = v4;
  v1[1] = v2;
  return v1;
}

//----- (0006BAD8) --------------------------------------------------------
int __fastcall curlx_tvdiff(int a1, int a2, int a3, int a4)
{
  return (a2 - a4) / 1000 + 1000 * (a1 - a3);
}

//----- (0006BB08) --------------------------------------------------------
double __fastcall curlx_tvdiff_secs(int a1, int a2, int a3, int a4)
{
  return (double)(a1 - a3) + (double)(a2 - a4) / 1000000.0;
}

//----- (0006BB50) --------------------------------------------------------
void Curl_tvlong()
{
  ;
}

//----- (0006BB5E) --------------------------------------------------------
bool __fastcall sub_6BB5E(_DWORD *a1, int a2)
{
  _BOOL4 result; // r0

  if ( a1[1] - *(_DWORD *)(a2 + 4) < *a1 )
    result = 0;
  else
    result = *(_DWORD *)(a2 + 8) == 0;
  return result;
}

//----- (0006BB7C) --------------------------------------------------------
int *__fastcall sub_6BB7C(int *result)
{
  int *v1; // r4

  v1 = result;
  if ( result )
  {
    Curl_freeaddrinfo(*result);
    result = (int *)Curl_cfree(v1);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006BB9C) --------------------------------------------------------
void *Curl_global_host_cache_init()
{
  int v0; // r5

  v0 = dword_2F849C;
  if ( !dword_2F849C )
  {
    if ( Curl_hash_init((int *)&unk_2F8484, 7, (int)Curl_hash_str, (int)Curl_str_key_compare, (int)sub_6BB7C) )
      return (void *)v0;
    dword_2F849C = 1;
  }
  return &unk_2F8484;
}
// 2F849C: using guessed type int dword_2F849C;

//----- (0006BBE8) --------------------------------------------------------
int Curl_global_host_cache_dtor()
{
  int result; // r0

  if ( dword_2F849C )
  {
    result = Curl_hash_clean(&unk_2F8484);
    dword_2F849C = 0;
  }
  return result;
}
// 2F849C: using guessed type int dword_2F849C;

//----- (0006BC04) --------------------------------------------------------
int __fastcall Curl_num_addresses(int a1)
{
  int v1; // r3

  v1 = 0;
  while ( a1 )
  {
    a1 = *(_DWORD *)(a1 + 28);
    ++v1;
  }
  return v1;
}

//----- (0006BC12) --------------------------------------------------------
const char *__fastcall Curl_printable_address(int a1, char *a2, socklen_t a3)
{
  const char *result; // r0

  if ( *(_DWORD *)(a1 + 4) == 2 )
    result = j_inet_ntop(2, (const void *)(*(_DWORD *)(a1 + 24) + 4), a2, a3);
  else
    result = 0;
  return result;
}

//----- (0006BC34) --------------------------------------------------------
signed int *__fastcall Curl_hostcache_prune(signed int *result, time_t a2, int a3, time_t a4)
{
  signed int *v4; // r4
  signed int v5; // r0
  time_t timer; // [sp+4h] [bp-14h]
  int v7; // [sp+8h] [bp-10h]
  time_t v8; // [sp+Ch] [bp-Ch]

  timer = a2;
  v7 = a3;
  v8 = a4;
  v4 = result;
  if ( result[150] != -1 && *result )
  {
    if ( result[4] )
      Curl_share_lock((int)result, 3);
    time(&timer);
    v5 = *v4;
    v7 = v4[150];
    v8 = timer;
    result = (signed int *)Curl_hash_clean_with_criterium(v5, (int)&v7, (int (__fastcall *)(int, _DWORD))sub_6BB5E);
    if ( v4[4] )
      result = (signed int *)Curl_share_unlock((int)v4, 3);
  }
  return result;
}

//----- (0006BC80) --------------------------------------------------------
const char *__fastcall Curl_cache_addr(int **a1, time_t a2, int a3, int a4)
{
  int **v4; // r6
  time_t v5; // r8
  const char *result; // r0
  char *v7; // r7
  size_t v8; // r9
  char *v9; // r0
  char *v10; // r5
  int v11; // r6
  time_t timer; // [sp+4h] [bp-24h]
  int v13; // [sp+8h] [bp-20h]

  timer = a2;
  v13 = a3;
  v4 = a1;
  v5 = a2;
  result = (const char *)curl_maprintf("%s:%d", a3, a4);
  v7 = (char *)result;
  if ( result )
  {
    v8 = strlen(result);
    v9 = (char *)Curl_ccalloc(12, 1);
    v10 = v9;
    if ( v9 )
    {
      *(_DWORD *)v9 = v5;
      *((_DWORD *)v9 + 2) = 0;
      v11 = Curl_hash_add(*v4, v7, v8 + 1, (int)v9);
      if ( v11 )
      {
        time(&timer);
        *(_DWORD *)(v11 + 4) = timer;
        ++*(_DWORD *)(v11 + 8);
      }
      else
      {
        ((void (__cdecl *)(void *))Curl_cfree)(v10);
      }
      ((void (__cdecl *)(void *))Curl_cfree)(v7);
      result = (const char *)v11;
    }
    else
    {
      ((void (__cdecl *)(void *))Curl_cfree)(v7);
      result = v10;
    }
  }
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006BD10) --------------------------------------------------------
signed int __fastcall Curl_resolv(int *a1, const char *a2, int a3, const char **a4)
{
  int *v4; // r7
  int v5; // r4
  const char **v6; // r8
  const char *v7; // r10
  int v8; // r9
  const char *v9; // r0
  int v10; // r6
  size_t v11; // r5
  int v12; // r11
  signed int v13; // r5
  int v14; // r2
  int v15; // r6
  const char *v16; // r0
  int v17; // r3
  signed int result; // r0
  const char *v19; // [sp+4h] [bp-34h]
  int v20; // [sp+8h] [bp-30h]
  time_t timer; // [sp+Ch] [bp-2Ch]

  v4 = a1;
  v5 = *a1;
  v6 = a4;
  *a4 = 0;
  v7 = a2;
  v8 = a3;
  v19 = 0;
  v9 = (const char *)curl_maprintf("%s:%d");
  v10 = (int)v9;
  if ( v9 )
  {
    v11 = strlen(v9);
    if ( *(_DWORD *)(v5 + 16) )
      Curl_share_lock(v5, 3);
    v12 = Curl_hash_pick(*(int **)v5, v10, v11 + 1);
    v19 = (const char *)v12;
    if ( v12 )
    {
      if ( *(_DWORD *)(v5 + 600) != -1 )
      {
        if ( *(_DWORD *)v5 )
        {
          time(&timer);
          v20 = *(_DWORD *)(v5 + 600);
          if ( sub_6BB5E(&v20, v12) )
          {
            Curl_hash_clean_with_criterium(*(_DWORD *)v5, (int)&v20, (int (__fastcall *)(int, _DWORD))sub_6BB5E);
            v19 = 0;
          }
        }
      }
    }
    if ( v19 )
    {
      v13 = 0;
      ++*((_DWORD *)v19 + 2);
    }
    else
    {
      v13 = -1;
    }
    if ( *(_DWORD *)(v5 + 16) )
      Curl_share_unlock(v5, 3);
    Curl_cfree(v10);
    if ( v19 )
      goto LABEL_27;
    if ( Curl_ipvalid(v5) )
    {
      v15 = Curl_getaddrinfo(v4, v7, v8, &v20);
      if ( v15 )
      {
        if ( *(_DWORD *)(v5 + 16) )
          Curl_share_lock(v5, 3);
        v16 = Curl_cache_addr((int **)v5, v15, (int)v7, v8);
        v17 = *(_DWORD *)(v5 + 16);
        v19 = v16;
        if ( v17 )
          Curl_share_unlock(v5, 3);
        if ( v19 )
          v13 = 0;
        else
          Curl_freeaddrinfo(v15);
        goto LABEL_27;
      }
      if ( !v20 )
      {
LABEL_27:
        result = v13;
        *v6 = v19;
        return result;
      }
      if ( !Curl_is_resolved(v4, (int *)&v19, v14, v20) )
      {
        v13 = v19 == 0;
        goto LABEL_27;
      }
    }
  }
  return -1;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006BE48) --------------------------------------------------------
signed int __fastcall Curl_resolv_timeout(int *a1, const char *a2, int a3, const char **a4)
{
  *a4 = 0;
  return Curl_resolv(a1, a2, a3, a4);
}

//----- (0006BE56) --------------------------------------------------------
int __fastcall Curl_resolv_unlock(int result, int a2)
{
  int v2; // r4
  int v3; // r5

  v2 = result;
  v3 = a2;
  if ( *(_DWORD *)(result + 16) )
    result = Curl_share_lock(result, 3);
  --*(_DWORD *)(v3 + 8);
  if ( *(_DWORD *)(v2 + 16) )
    result = Curl_share_unlock(v2, 3);
  return result;
}

//----- (0006BE80) --------------------------------------------------------
int *Curl_mk_dnscache()
{
  return Curl_hash_alloc(7, (int)Curl_hash_str, (int)Curl_str_key_compare, (int)sub_6BB7C);
}

//----- (0006BEA8) --------------------------------------------------------
char *__fastcall sub_6BEA8(char *a1, int a2, signed __int64 a3)
{
  int v3; // r8
  signed __int64 v5; // r0
  signed __int64 v6; // r0
  signed __int64 v7; // [sp+0h] [bp-30h]

  v3 = (int)a1;
  if ( a3 < 1 )
    return j_strcpy(a1, "--:--:--");
  if ( a3 / 3600 < 100 )
    return curl_msnprintf((int)a1, 9, "%2lld:%02lld:%02lld");
  v5 = a3 / (unsigned int)"dentEv";
  v7 = a3 / (unsigned int)"dentEv";
  if ( v5 >= 1000 )
    return curl_msnprintf(v3, 9, "%7lldd", HIDWORD(v5) - ((unsigned int)v5 < 0x3E8), v7);
  v6 = __PAIR__(
         (4294880896u * (unsigned __int64)(unsigned int)v5 >> 32) + -86400 * HIDWORD(v5) - v5,
         -86400 * (signed int)v5)
     + a3;
  return curl_msnprintf(v3, 9, "%3lldd %02lldh", (_DWORD)((unsigned __int64)(v6 % 3600) >> 32), v7, v6 / 3600);
}

//----- (0006BFB0) --------------------------------------------------------
int __fastcall sub_6BFB0(signed __int64 a1, int a2)
{
  int v2; // r8
  int v3; // r0
  const char *v4; // r2

  v2 = a2;
  if ( a1 > 99999 )
  {
    if ( *(_QWORD *)dword_6C0E8 < a1 )
    {
      if ( a1 < 104857600 )
      {
        curl_msnprintf(
          a2,
          6,
          "%2lld.%0lldM",
          (_DWORD)((unsigned __int64)((a1 & 0xFFFFF) % 104857) >> 32),
          (unsigned int)(a1 >> 20),
          SHIDWORD(a1) >> 20,
          (a1 & 0xFFFFF) / 104857);
        return v2;
      }
      if ( a1 >= 10485760000LL )
      {
        if ( SHIDWORD(a1) < 25 )
        {
          curl_msnprintf(
            a2,
            6,
            "%2lld.%0lldG",
            (_DWORD)((unsigned __int64)(((unsigned int)a1 & 0x3FFFFFFF) % 107374182LL) >> 32),
            (unsigned int)(a1 >> 30),
            SHIDWORD(a1) >> 30,
            ((unsigned int)a1 & 0x3FFFFFFF) / 107374182LL);
          return v2;
        }
        if ( a1 > 10737418239999LL )
        {
          if ( a1 > 10995116277759999LL )
          {
            v3 = a2;
            v4 = "%4lldP";
          }
          else
          {
            v3 = a2;
            v4 = "%4lldT";
          }
        }
        else
        {
          v3 = a2;
          v4 = "%4lldG";
        }
      }
      else
      {
        v3 = a2;
        v4 = "%4lldM";
      }
    }
    else
    {
      v3 = a2;
      v4 = "%4lldk";
    }
  }
  else
  {
    v3 = a2;
    v4 = "%5lld";
  }
  curl_msnprintf(v3, 6, v4);
  return v2;
}
// 6C0E8: using guessed type int dword_6C0E8[2];

//----- (0006C128) --------------------------------------------------------
_QWORD *__fastcall Curl_pgrsResetTimes(_QWORD *result)
{
  result[122] = 0LL;
  result[123] = 0LL;
  result[125] = 0LL;
  result[126] = 0LL;
  return result;
}

//----- (0006C13E) --------------------------------------------------------
int __fastcall Curl_pgrsTime(double a1)
{
  int v1; // r4
  double *v2; // r4
  double v4; // [sp+0h] [bp-48h]
  __time_t v5; // [sp+8h] [bp-40h]
  int v6; // [sp+Ch] [bp-3Ch]
  __time_t v7; // [sp+10h] [bp-38h]
  int v8; // [sp+14h] [bp-34h]
  __time_t v9; // [sp+18h] [bp-30h]
  int v10; // [sp+1Ch] [bp-2Ch]
  __time_t v11; // [sp+20h] [bp-28h]
  int v12; // [sp+24h] [bp-24h]
  __time_t v13; // [sp+28h] [bp-20h]
  int v14; // [sp+2Ch] [bp-1Ch]
  __time_t v15; // [sp+30h] [bp-18h]
  int v16; // [sp+34h] [bp-14h]

  v1 = LODWORD(a1);
  switch ( HIDWORD(a1) )
  {
    case 1:
      curlx_tvnow(&v5);
      a1 = curlx_tvdiff_secs(v5, v6, *(_DWORD *)(v1 + 1032), *(_DWORD *)(v1 + 1036));
      *(double *)(v1 + 976) = a1;
      break;
    case 2:
      curlx_tvnow(&v7);
      a1 = curlx_tvdiff_secs(v7, v8, *(_DWORD *)(v1 + 1032), *(_DWORD *)(v1 + 1036));
      *(double *)(v1 + 984) = a1;
      break;
    case 3:
      curlx_tvnow(&v9);
      a1 = curlx_tvdiff_secs(v9, v10, *(_DWORD *)(v1 + 1032), *(_DWORD *)(v1 + 1036));
      *(double *)(v1 + 992) = a1;
      break;
    case 4:
      curlx_tvnow(&v11);
      a1 = curlx_tvdiff_secs(v11, v12, *(_DWORD *)(v1 + 1032), *(_DWORD *)(v1 + 1036));
      *(double *)(v1 + 1000) = a1;
      break;
    case 5:
      curlx_tvnow(&v13);
      a1 = curlx_tvdiff_secs(v13, v14, *(_DWORD *)(v1 + 1032), *(_DWORD *)(v1 + 1036));
      *(double *)(v1 + 1008) = a1;
      break;
    case 7:
      v2 = (double *)(LODWORD(a1) + 1032);
      curlx_tvnow((__time_t *)&v4);
      a1 = v4;
      *v2 = v4;
      break;
    case 8:
      curlx_tvnow(&v15);
      a1 = curlx_tvdiff_secs(v15, v16, *(_DWORD *)(v1 + 1024), *(_DWORD *)(v1 + 1028));
      *(double *)(v1 + 1016) = a1;
      break;
    default:
      return LODWORD(a1);
  }
  return LODWORD(a1);
}

//----- (0006C214) --------------------------------------------------------
void __fastcall __spoils<R2,R3,R12> Curl_pgrsStartNow(int a1, int a2, int a3)
{
  int v3; // r5
  _DWORD *v4; // r3
  int v5; // r1
  int v6; // [sp+0h] [bp-18h]
  int v7; // [sp+8h] [bp-10h]

  v7 = a3;
  v3 = a1;
  *(_DWORD *)(a1 + 1136) = 0;
  curlx_tvnow(&v6);
  v4 = (_DWORD *)(v3 + 1024);
  *v4 = v6;
  v4[1] = v5;
}

//----- (0006C234) --------------------------------------------------------
_QWORD *__fastcall Curl_pgrsSetDownloadCounter(int a1, int a2, __int64 a3)
{
  _QWORD *result; // r0

  result = (_QWORD *)(a1 + 912);
  *result = a3;
  return result;
}

//----- (0006C23E) --------------------------------------------------------
_QWORD *__fastcall Curl_pgrsSetUploadCounter(int a1, int a2, __int64 a3)
{
  _QWORD *result; // r0

  result = (_QWORD *)(a1 + 920);
  *result = a3;
  return result;
}

//----- (0006C248) --------------------------------------------------------
int __fastcall Curl_pgrsSetDownloadSize(int result, int a2, __int64 a3)
{
  bool v3; // nf
  unsigned __int8 v4; // vf
  int v5; // r3
  unsigned int v6; // r3

  *(_QWORD *)(result + 896) = a3;
  v4 = __OFSUB__(HIDWORD(a3), (unsigned int)a3 < 1);
  v3 = HIDWORD(a3) - ((unsigned int)a3 < 1) < 0;
  v5 = *(_DWORD *)(result + 944);
  if ( v3 ^ v4 )
    v6 = v5 & 0xFFFFFFBF;
  else
    v6 = v5 | 0x40;
  *(_DWORD *)(result + 944) = v6;
  return result;
}

//----- (0006C26A) --------------------------------------------------------
int __fastcall Curl_pgrsSetUploadSize(int result, int a2, __int64 a3)
{
  bool v3; // nf
  unsigned __int8 v4; // vf
  int v5; // r3
  unsigned int v6; // r3

  *(_QWORD *)(result + 904) = a3;
  v4 = __OFSUB__(HIDWORD(a3), (unsigned int)a3 < 1);
  v3 = HIDWORD(a3) - ((unsigned int)a3 < 1) < 0;
  v5 = *(_DWORD *)(result + 944);
  if ( v3 ^ v4 )
    v6 = v5 & 0xFFFFFFDF;
  else
    v6 = v5 | 0x20;
  *(_DWORD *)(result + 944) = v6;
  return result;
}

//----- (0006C290) --------------------------------------------------------
int __fastcall Curl_pgrsUpdate(int *a1)
{
  int v1; // r8
  double v2; // d9
  int v3; // r6
  double v4; // d8
  double v5; // r0
  signed __int64 v6; // r0
  __int64 *v7; // r10
  __int64 v8; // kr08_8
  double v9; // r0
  int v10; // r0
  int v11; // r2
  unsigned int v12; // r1
  unsigned int v13; // r11
  __int64 v14; // r2
  int v15; // r12
  int v16; // r1
  _QWORD *v17; // r7
  _DWORD *v18; // r3
  int v19; // r1
  int v20; // r0
  int v21; // r9
  int v22; // r3
  int v23; // r9
  int v24; // r0
  signed int v25; // r11
  __int64 v26; // r2
  double v27; // r0
  signed __int64 v28; // r0
  signed int v29; // r3
  unsigned __int64 v30; // r2
  int v31; // r2
  int (__fastcall *v32)(_DWORD, int, int, int, _DWORD, _DWORD, _DWORD, _DWORD, int, int); // r4
  int v33; // r6
  int v34; // r1
  int v35; // r7
  __int64 v36; // r0
  __int64 v37; // ST00_8
  __int64 v38; // r0
  __int64 v39; // ST08_8
  int v40; // r0
  int v41; // r1
  int v42; // r4
  int v43; // r9
  signed __int64 v44; // r2
  signed __int64 v45; // r6
  signed __int64 v46; // r4
  signed __int64 v47; // r2
  signed __int64 v48; // r6
  unsigned int v49; // r9
  unsigned int v50; // r10
  int v51; // r11
  signed __int64 v52; // r6
  signed __int64 v53; // r0
  signed __int64 v54; // r2
  int v55; // r1
  int v56; // r1
  __int64 v57; // r2
  __int64 *v58; // r1
  __int64 *v59; // r0
  __int64 v60; // r6
  signed __int64 v61; // r6
  int v62; // ST44_4
  int v63; // ST68_4
  int v64; // ST70_4
  int v65; // r7
  int v66; // r6
  int v67; // r5
  int v68; // r0
  int v70; // [sp+4h] [bp-11Ch]
  int v71; // [sp+14h] [bp-10Ch]
  int v72; // [sp+44h] [bp-DCh]
  __int64 v73; // [sp+48h] [bp-D8h]
  __int64 v74; // [sp+48h] [bp-D8h]
  signed __int64 v75; // [sp+50h] [bp-D0h]
  __int64 v76; // [sp+50h] [bp-D0h]
  _QWORD *v77; // [sp+58h] [bp-C8h]
  signed __int64 v78; // [sp+58h] [bp-C8h]
  signed __int64 v79; // [sp+58h] [bp-C8h]
  int v80; // [sp+60h] [bp-C0h]
  int v81; // [sp+64h] [bp-BCh]
  int v82; // [sp+7Ch] [bp-A4h]
  int v83; // [sp+80h] [bp-A0h]
  char v84; // [sp+84h] [bp-9Ch]
  __int16 v85; // [sp+8Eh] [bp-92h]
  char v86; // [sp+98h] [bp-88h]
  __int16 v87; // [sp+A2h] [bp-7Eh]
  int v88; // [sp+ACh] [bp-74h]
  __int16 v89; // [sp+B6h] [bp-6Ah]
  char v90; // [sp+C0h] [bp-60h]
  char v91; // [sp+CCh] [bp-54h]
  char v92; // [sp+D8h] [bp-48h]

  v1 = *a1;
  v2 = 1.0;
  v72 = *(_DWORD *)(*a1 + 1136);
  curlx_tvnow(&v82);
  v3 = v82;
  v4 = (double)(v82 - *(_DWORD *)(v1 + 1024)) + (double)(v83 - *(_DWORD *)(v1 + 1028)) / 1000000.0;
  *(double *)(v1 + 952) = v4;
  v73 = *(_QWORD *)(v1 + 912);
  LODWORD(v5) = _floatdidf(v73);
  if ( v4 > 0.0 )
    v2 = v4;
  LODWORD(v6) = _fixdfdi(COERCE_UNSIGNED_INT64(v5 / v2), COERCE_UNSIGNED_INT64(v5 / v2) >> 32);
  v75 = v6;
  *(_QWORD *)(v1 + 960) = v6;
  v7 = (__int64 *)(v1 + 920);
  v8 = *(_QWORD *)(v1 + 920);
  LODWORD(v9) = _floatdidf(*(_QWORD *)(v1 + 920));
  v10 = _fixdfdi(COERCE_UNSIGNED_INT64(v9 / v2), COERCE_UNSIGNED_INT64(v9 / v2) >> 32);
  v11 = *(_DWORD *)(v1 + 888);
  *(_DWORD *)(v1 + 968) = v10;
  *(_DWORD *)(v1 + 972) = v12;
  v13 = v12;
  if ( v11 == v3 )
  {
    v29 = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 888) = v3;
    v14 = v8;
    v15 = v10;
    v16 = v1 + 8 * (v72 % 6);
    v77 = (_QWORD *)(v16 + 1040);
    v17 = (_QWORD *)(v1 + 928);
    if ( v8 < v73 )
      v14 = v73;
    *(_QWORD *)(v16 + 1040) = v14;
    v18 = (_DWORD *)(v16 + 1088);
    v19 = v83;
    *v18 = v82;
    v18[1] = v19;
    v20 = *(_DWORD *)(v1 + 1136) + 1;
    *(_DWORD *)(v1 + 1136) = v20;
    if ( v20 == 1 )
    {
      v30 = __PAIR__(v13, v15);
      if ( (signed __int64)__PAIR__(v13, v15) < v75 )
        v30 = v75;
      *v17 = v30;
    }
    else
    {
      if ( v20 <= 5 )
        v21 = 0;
      else
        v21 = v20 % 6;
      v22 = v21 + 136;
      v23 = v21 + 130;
      v24 = curlx_tvdiff(v82, v83, *(_DWORD *)(v1 + 8 * v22), *(_DWORD *)(v1 + 8 * v22 + 4));
      if ( v24 )
        v25 = v24;
      else
        v25 = 1;
      v26 = *v77 - *(_QWORD *)(v1 + 8 * v23);
      if ( v26 <= 4294967 )
      {
        v28 = 1000 * v26 / v25;
      }
      else
      {
        LODWORD(v27) = _floatdidf(v26);
        LODWORD(v28) = _fixdfdi(
                         COERCE_UNSIGNED_INT64(v27 / ((double)v25 / 1000.0)),
                         COERCE_UNSIGNED_INT64(v27 / ((double)v25 / 1000.0)) >> 32);
      }
      *v17 = v28;
    }
    v29 = 1;
  }
  v31 = *(_DWORD *)(v1 + 944);
  v81 = *(_DWORD *)(v1 + 944) & 0x10;
  if ( v31 & 0x10 )
    return 0;
  v32 = *(int (__fastcall **)(_DWORD, int, int, int, _DWORD, _DWORD, _DWORD, _DWORD, int, int))(v1 + 372);
  if ( v32 )
  {
    v33 = _floatdidf(*(_QWORD *)(v1 + 896));
    v35 = v34;
    LODWORD(v36) = _floatdidf(*(_QWORD *)(v1 + 912));
    v37 = v36;
    LODWORD(v38) = _floatdidf(*(_QWORD *)(v1 + 904));
    v39 = v38;
    v40 = _floatdidf(*v7);
    v42 = v32(*(_DWORD *)(v1 + 416), v41, v33, v35, v37, HIDWORD(v37), v39, HIDWORD(v39), v40, v41);
    if ( v42 )
    {
      Curl_failf(v1, "Callback aborted");
      v81 = v42;
    }
  }
  else if ( v29 )
  {
    if ( !(v31 & 0x80) )
    {
      if ( *(_QWORD *)(v1 + 34192) )
        curl_mfprintf(*(_DWORD *)(v1 + 280), "** Resuming transfer from byte position %lld\n");
      curl_mfprintf(
        *(_DWORD *)(v1 + 280),
        "  %% Total    %% Received %% Xferd  Average Speed   Time    Time     Time  Current\n"
        "                                 Dload  Upload   Total   Spent    Left  Speed\n");
      *(_DWORD *)(v1 + 944) |= 0x80u;
    }
    v43 = *(_DWORD *)(v1 + 944);
    if ( v43 & 0x20 && (v44 = *(_QWORD *)(v1 + 968), v44 >= 1) && (v45 = *(_QWORD *)(v1 + 904), v45 >= 101) )
    {
      v46 = v45 / v44;
      v80 = (unsigned __int64)(*v7 / (v45 / 100)) >> 32;
      LODWORD(v76) = *v7 / (v45 / 100);
    }
    else
    {
      v46 = 0LL;
      LODWORD(v76) = 0;
      v80 = 0;
    }
    if ( v43 & 0x40 && (v47 = *(_QWORD *)(v1 + 960), v47 >= 1) && (v48 = *(_QWORD *)(v1 + 896), v48 >= 101) )
    {
      v49 = (unsigned __int64)(v48 / v47) >> 32;
      v50 = v48 / v47;
      LODWORD(v74) = (unsigned __int64)(*(_QWORD *)(v1 + 912) / (v48 / 100)) >> 32;
      v51 = *(_QWORD *)(v1 + 912) / (v48 / 100);
    }
    else
    {
      v50 = 0;
      LODWORD(v74) = 0;
      v49 = 0;
      v51 = 0;
    }
    v52 = __PAIR__(v49, v50);
    LODWORD(v53) = _fixdfdi(LODWORD(v4), HIDWORD(v4));
    v78 = v53;
    if ( (signed __int64)__PAIR__(v49, v50) < v46 )
      v52 = v46;
    if ( v52 )
      v54 = v52 - v53;
    else
      v54 = 0LL;
    sub_6BEA8(&v90, (__PAIR__(v49, v50) - v46) >> 32, v54);
    sub_6BEA8(&v91, v55, v52);
    sub_6BEA8(&v92, v56, v78);
    HIDWORD(v57) = *(_DWORD *)(v1 + 944);
    v58 = (__int64 *)(v1 + 920);
    v59 = (__int64 *)(v1 + 912);
    if ( v57 & 0x2000000000LL )
      LODWORD(v57) = v1 + 904;
    if ( v57 & 0x2000000000LL )
      v60 = *(_QWORD *)v57;
    else
      v60 = *v58;
    if ( v57 & 0x4000000000LL )
      HIDWORD(v57) = v1 + 896;
    else
      v57 = *v59;
    if ( *(_DWORD *)(v1 + 944) & 0x40 )
      v57 = *(_QWORD *)HIDWORD(v57);
    v61 = v60 + v57;
    if ( v61 < 101 )
      v79 = 0LL;
    else
      v79 = (*v58 + *v59) / (v61 / 100);
    v62 = *(_DWORD *)(v1 + 280);
    v63 = sub_6BFB0(v61, (int)&v86);
    v64 = sub_6BFB0(*(_QWORD *)(v1 + 912), (int)&v84);
    v65 = sub_6BFB0(*(_QWORD *)(v1 + 920), (int)&v85);
    v66 = sub_6BFB0(*(_QWORD *)(v1 + 960), (int)&v87);
    v67 = sub_6BFB0(*(_QWORD *)(v1 + 968), (int)&v88);
    v68 = sub_6BFB0(*(_QWORD *)(v1 + 928), (int)&v89);
    curl_mfprintf(
      v62,
      "\r%3lld %s  %3lld %s  %3lld %s  %s  %s %s %s %s %s",
      v79,
      v63,
      v70,
      v51,
      (_DWORD)v74,
      v64,
      v71,
      (_DWORD)v76,
      v80,
      v65,
      v66,
      v67,
      &v91,
      &v92,
      &v90,
      v68);
    fflush(*(FILE **)(v1 + 280));
  }
  return v81;
}

//----- (0006C790) --------------------------------------------------------
int __fastcall Curl_pgrsDone(int *a1)
{
  int v1; // r4
  int result; // r0

  v1 = *a1;
  *(_DWORD *)(*a1 + 888) = 0;
  result = Curl_pgrsUpdate(a1);
  *(_DWORD *)(v1 + 1136) = 0;
  return result;
}

//----- (0006C7A4) --------------------------------------------------------
_DWORD *__fastcall sub_6C7A4(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r5
  int v5; // r4
  _DWORD *result; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  result = (_DWORD *)Curl_ccalloc(64, 1);
  if ( !result )
    return 0;
  if ( v3 )
    result[3] = v3;
  if ( v4 )
    result[6] = v4;
  result[8] = 1;
  if ( !v5 )
    return 0;
  result[15] = *(_DWORD *)(v5 + 60);
  *(_DWORD *)(v5 + 60) = result;
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (0006C7DC) --------------------------------------------------------
signed int __fastcall sub_6C7DC(int **a1, void *a2, size_t a3)
{
  void *v3; // r8
  int *v4; // r3
  int **v5; // r4
  size_t v6; // r7
  _BOOL4 v7; // r6
  int v8; // r3
  size_t v9; // r0
  size_t v10; // r5
  FILE *v11; // r0

  v3 = a2;
  v4 = *a1;
  v5 = a1;
  v6 = a3;
  v7 = (unsigned int)((*a1)[1] - 2) <= 0;
  if ( (unsigned int)((*a1)[1] - 2) <= 0 )
  {
    v8 = v4[2];
    v9 = ((int (__fastcall *)(void *, signed int))a1[3])(a2, 1);
  }
  else
  {
    if ( !a1[2] )
    {
      v11 = fopen((const char *)v4[2], "rb");
      v5[2] = (int *)v11;
      if ( !v11 )
        return -1;
    }
    v9 = fread(v3, 1u, v6, (FILE *)v5[2]);
  }
  v10 = v9;
  if ( !v9 || v9 > v6 )
  {
    if ( !v7 )
    {
      fclose((FILE *)v5[2]);
      v5[2] = 0;
    }
    *v5 = (int *)**v5;
  }
  return v10;
}

//----- (0006C84C) --------------------------------------------------------
const char *__fastcall sub_6C84C(int a1)
{
  const char *result; // r0
  const char *v2; // r5
  char *(__cdecl *v3)(const char *); // r4
  char *v4; // r0
  char *v5; // r4

  result = (const char *)Curl_cstrdup(a1);
  v2 = result;
  if ( result )
  {
    v3 = (char *(__cdecl *)(const char *))Curl_cstrdup;
    v4 = basename(result);
    v5 = v3(v4);
    Curl_cfree(v2);
    result = v5;
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006C880) --------------------------------------------------------
signed int __fastcall sub_6C880(_DWORD **a1, unsigned int a2, const char *a3, size_t a4, _QWORD *a5)
{
  _DWORD **v5; // r9
  size_t v6; // r7
  unsigned int v7; // r8
  const char *v8; // r10
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  void *v11; // r0
  int v12; // r3
  __int64 v13; // r2
  int v15; // [sp+0h] [bp-88h]
  int v16; // [sp+30h] [bp-58h]
  int v17; // [sp+34h] [bp-54h]

  v5 = a1;
  v6 = a4;
  v7 = a2;
  v8 = a3;
  v9 = (_DWORD *)Curl_cmalloc(16);
  v10 = v9;
  if ( !v9 )
    return 27;
  *v9 = 0;
  if ( v7 > 1 )
  {
    v9[2] = v8;
  }
  else
  {
    if ( !v6 )
      v6 = strlen(v8);
    v11 = (void *)Curl_cmalloc(v6 + 1);
    v10[2] = v11;
    if ( !v11 )
    {
      Curl_cfree(v10);
      return 27;
    }
    memcpy(v11, v8, v6);
    v12 = v10[2];
    v10[3] = v6;
    *(_BYTE *)(v12 + v6) = 0;
  }
  v10[1] = v7;
  if ( *v5 )
    **v5 = v10;
  *v5 = v10;
  if ( a5 )
  {
    if ( v7 == 3 )
    {
      if ( !curl_strequal("-", (const char *)v10[2]) && !stat((const char *)v10[2], (struct stat *)&v15) )
      {
        HIDWORD(v13) = v17;
        LODWORD(v13) = v16 + *a5;
        *a5 += v13;
      }
    }
    else
    {
      *a5 += v6;
    }
  }
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006C950) --------------------------------------------------------
signed int sub_6C950(_DWORD **a1, _QWORD *a2, char *a3, ...)
{
  _DWORD **v3; // r7
  _QWORD *v4; // r6
  char v6; // [sp+Ch] [bp-1024h]
  va_list varg_r3; // [sp+102Ch] [bp-4h]

  va_start(varg_r3, a3);
  v3 = a1;
  v4 = a2;
  curl_mvsnprintf(&v6, 4096, a3, (int)varg_r3);
  return sub_6C880(v3, 0, &v6, 0, v4);
}

//----- (0006C9B8) --------------------------------------------------------
int __fastcall sub_6C9B8(const char *a1, size_t a2)
{
  const char *v2; // r7
  size_t v3; // r4
  signed int v4; // r6
  _BYTE *v6; // r0
  _BYTE *v7; // r5

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    v4 = 0;
  }
  else
  {
    if ( !a1 )
      return Curl_cstrdup(&byte_E4496);
    v4 = 1;
    v3 = strlen(a1);
  }
  v6 = (_BYTE *)Curl_cmalloc(v4 + v3);
  v7 = v6;
  if ( v6 )
  {
    memcpy(v6, v2, v3);
    if ( v4 )
      v7[v3] = 0;
  }
  return (int)v7;
}
// E4496: using guessed type char byte_E4496;
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006CA0C) --------------------------------------------------------
signed int curl_formadd(_DWORD *a1, _DWORD **a2, ...)
{
  int **v2; // r11
  int v3; // r0
  int *v4; // r10
  int *v5; // r5
  int **v6; // r6
  signed int v7; // r9
  int *v8; // r3
  int **v9; // r7
  int v10; // r11
  int *v11; // r3
  int *v12; // r3
  int *v13; // r3
  int *v14; // r3
  int *v15; // r0
  int v16; // r0
  int v17; // r3
  int *v18; // r0
  bool v19; // zf
  int v20; // r0
  int v21; // r0
  int v22; // r1
  unsigned int v23; // r0
  int *v24; // r3
  int *v25; // r3
  int *v26; // r0
  int *v27; // r0
  int v28; // r0
  int *v29; // r3
  int *v30; // r0
  int v31; // r0
  const char *v32; // r6
  _DWORD *i; // r7
  int v34; // r3
  const char *v35; // r9
  const char *v36; // r10
  int v37; // r8
  char *v38; // r11
  size_t v39; // r0
  int v40; // r0
  int v41; // r0
  const char *v42; // r11
  int v43; // r10
  int v44; // r9
  int v45; // r8
  int v46; // r0
  _DWORD *v47; // r3
  size_t v48; // r0
  _DWORD *v49; // ST00_4
  _DWORD *v50; // r1
  int *v51; // r4
  const char *v53; // r1
  size_t v54; // [sp+0h] [bp-68h]
  size_t v55; // [sp+0h] [bp-68h]
  int *ptr; // [sp+4h] [bp-64h]
  int (__fastcall *v57)(const char *); // [sp+8h] [bp-60h]
  int v58; // [sp+8h] [bp-60h]
  int v59; // [sp+Ch] [bp-5Ch]
  int v60; // [sp+10h] [bp-58h]
  int v61; // [sp+14h] [bp-54h]
  int v62; // [sp+18h] [bp-50h]
  int v63; // [sp+1Ch] [bp-4Ch]
  _DWORD *v64; // [sp+20h] [bp-48h]
  _DWORD **varg_r1; // [sp+5Ch] [bp-Ch]
  va_list varg_r2; // [sp+60h] [bp-8h]

  va_start(varg_r2, a2);
  varg_r1 = a2;
  v64 = a1;
  va_copy(v2, varg_r2);
  v3 = Curl_ccalloc(64, 1);
  ptr = (int *)v3;
  if ( !v3 )
    return 1;
  v4 = 0;
  v5 = (int *)v3;
  v6 = 0;
  v7 = 0;
  while ( v7 )
  {
    v8 = *v6;
    v4 = v6[1];
    v6 += 2;
    if ( v8 == (int *)((char *)&word_10 + 1) )
    {
      v7 = 0;
      goto LABEL_174;
    }
    v9 = v2;
LABEL_7:
    switch ( (unsigned int)v8 )
    {
      case 1u:
        goto LABEL_12;
      case 2u:
        v5[8] |= 4u;
LABEL_12:
        if ( *v5 )
          goto LABEL_13;
        if ( v7 )
        {
          v11 = v4;
        }
        else
        {
          v11 = *v9;
          ++v9;
        }
        if ( !v11 )
          goto LABEL_10;
        *v5 = (int)v11;
        goto LABEL_109;
      case 3u:
        if ( v5[2] )
          goto LABEL_13;
        if ( v7 )
        {
          v12 = v4;
        }
        else
        {
          v12 = *v9;
          ++v9;
        }
        v5[2] = (int)v12;
        goto LABEL_109;
      case 4u:
        goto LABEL_25;
      case 5u:
        v5[8] |= 8u;
LABEL_25:
        if ( v5[3] )
          goto LABEL_13;
        if ( v7 )
        {
          v13 = v4;
        }
        else
        {
          v13 = *v9;
          ++v9;
        }
        if ( !v13 )
          goto LABEL_10;
        goto LABEL_83;
      case 6u:
        if ( v5[5] )
          goto LABEL_13;
        if ( v7 )
        {
          v14 = v4;
        }
        else
        {
          v14 = *v9;
          ++v9;
        }
        v5[5] = (int)v14;
        goto LABEL_109;
      case 7u:
        if ( v5[8] )
          goto LABEL_13;
        if ( v7 )
        {
          v15 = v4;
        }
        else
        {
          v15 = *v9;
          ++v9;
        }
        if ( !v15 )
          goto LABEL_10;
        v16 = Curl_cstrdup(v15);
        v5[3] = v16;
        if ( !v16 )
          goto LABEL_96;
        v17 = v5[8] | 2;
        goto LABEL_51;
      case 8u:
        if ( v7 )
        {
          v10 = 6;
LABEL_156:
          if ( v5 )
            goto LABEL_157;
          goto LABEL_166;
        }
        v6 = (int **)*v9;
        v2 = v9 + 1;
        if ( !*v9 )
          goto LABEL_10;
        v7 = 1;
        break;
      case 0xAu:
        if ( v7 )
        {
          v18 = v4;
        }
        else
        {
          v18 = *v9;
          ++v9;
        }
        if ( v5[3] )
        {
          v19 = (v5[8] & 1) == 0;
          goto LABEL_57;
        }
        if ( !v18 )
          goto LABEL_10;
        v20 = Curl_cstrdup(v18);
        v5[3] = v20;
        if ( !v20 )
          goto LABEL_96;
        v17 = v5[8] | 1;
LABEL_51:
        v5[8] = v17;
        *((_BYTE *)v5 + 16) = 1;
        goto LABEL_109;
      case 0xBu:
        if ( v7 )
        {
          v18 = v4;
        }
        else
        {
          v18 = *v9;
          ++v9;
        }
        if ( !v5[3] )
        {
          if ( v18 )
          {
            v23 = Curl_cstrdup(v18);
            v10 = 1 - v23;
            v5[3] = v23;
            if ( v23 > 1 )
              v10 = 0;
          }
          else
          {
            v10 = 3;
          }
          v5[8] |= 0x10u;
          goto LABEL_110;
        }
        v19 = (v5[8] & 0x10) == 0;
LABEL_57:
        if ( v19 )
          goto LABEL_13;
        if ( !v18 )
        {
LABEL_10:
          v10 = 3;
          goto LABEL_156;
        }
        v21 = Curl_cstrdup(v18);
        v22 = 0;
        goto LABEL_91;
      case 0xCu:
        v5[8] |= 0x20u;
        if ( v5[9] )
          goto LABEL_13;
        if ( v7 )
        {
          v24 = v4;
        }
        else
        {
          v24 = *v9;
          ++v9;
        }
        if ( !v24 )
          goto LABEL_10;
        v5[9] = (int)v24;
        goto LABEL_109;
      case 0xDu:
        if ( v5[10] )
          goto LABEL_13;
        if ( v7 )
        {
          v25 = v4;
        }
        else
        {
          v25 = *v9;
          ++v9;
        }
        v5[10] = (int)v25;
        goto LABEL_109;
      case 0xEu:
        if ( v7 )
        {
          v26 = v4;
        }
        else
        {
          v26 = *v9;
          ++v9;
        }
        if ( v5[6] )
        {
          if ( !(v5[8] & 1) )
          {
LABEL_13:
            v10 = 2;
            goto LABEL_156;
          }
          if ( !v26 )
            goto LABEL_10;
          v22 = Curl_cstrdup(v26);
          v21 = 0;
LABEL_91:
          v27 = sub_6C7A4(v21, v22, (int)v5);
          v10 = 1 - (_DWORD)v27;
          v5 = v27;
          if ( (unsigned int)v27 > 1 )
            v10 = 0;
LABEL_110:
          if ( v10 )
            goto LABEL_156;
          goto LABEL_111;
        }
        if ( !v26 )
          goto LABEL_10;
        v28 = Curl_cstrdup(v26);
        v5[6] = v28;
        if ( !v28 )
        {
LABEL_96:
          v10 = 1;
          goto LABEL_156;
        }
        *((_BYTE *)v5 + 28) = 1;
LABEL_109:
        v2 = v9;
        break;
      case 0xFu:
        if ( v7 )
        {
          v29 = v4;
        }
        else
        {
          v29 = *v9;
          ++v9;
        }
        if ( v5[14] )
          goto LABEL_13;
        v5[14] = (int)v29;
        goto LABEL_109;
      case 0x10u:
        if ( v7 )
        {
          v30 = v4;
        }
        else
        {
          v30 = *v9;
          ++v9;
        }
        if ( v5[11] )
          goto LABEL_13;
        v31 = Curl_cstrdup(v30);
        v5[11] = v31;
        if ( !v31 )
          goto LABEL_96;
        *((_BYTE *)v5 + 48) = 1;
        goto LABEL_109;
      case 0x13u:
        v5[8] |= 0x40u;
        if ( v5[13] )
          goto LABEL_13;
        if ( v7 )
        {
          v13 = v4;
        }
        else
        {
          v13 = *v9;
          ++v9;
        }
        if ( !v13 )
          goto LABEL_10;
        v5[13] = (int)v13;
LABEL_83:
        v5[3] = (int)v13;
        goto LABEL_109;
      default:
        v10 = 4;
        goto LABEL_156;
    }
LABEL_174:
    v9 = v2;
LABEL_111:
    v2 = v9;
  }
  v8 = *v2;
  v9 = v2 + 1;
  if ( *v2 != (int *)((char *)&word_10 + 1) )
    goto LABEL_7;
  v5 = ptr;
  v32 = 0;
  for ( i = 0; ; i = v47 )
  {
    if ( (!*v5 || !v5[3]) && !i
      || v5[5] && v5[8] & 1
      || (v34 = v5[8], (v5[8] & 9) == 9)
      || !v5[9] && (v5[8] & 0x30) == 48
      || (v5[8] & 0xA) == 10 )
    {
      v10 = 5;
      goto LABEL_157;
    }
    if ( v34 & 0x11 && !v5[6] )
    {
      v35 = "application/octet-stream";
      v36 = (const char *)v5[3];
      if ( v32 )
        v35 = v32;
      v57 = (int (__fastcall *)(const char *))Curl_cstrdup;
      if ( v36 )
      {
        v37 = 0;
        while ( 1 )
        {
          v38 = &aGif[12 * v37];
          v54 = strlen(v36);
          v39 = strlen(&aGif[12 * v37]);
          if ( v54 >= v39 && curl_strequal(&v36[v54 - v39], v38) )
            break;
          if ( ++v37 == 6 )
            goto LABEL_132;
        }
        v35 = (const char *)*((_DWORD *)v38 + 2);
      }
LABEL_132:
      v40 = v57(v35);
      v5[6] = v40;
      if ( !v40 )
        goto LABEL_133;
      *((_BYTE *)v5 + 28) = 1;
    }
    if ( !(v5[8] & 4) && v5 == ptr )
      break;
LABEL_141:
    if ( !(v5[8] & 0x6B) )
    {
      v41 = sub_6C9B8((const char *)v5[3], v5[5]);
      v5[3] = v41;
      if ( !v41 )
        goto LABEL_133;
      *((_BYTE *)v5 + 16) = 1;
    }
    v58 = v5[5];
    v42 = (const char *)*v5;
    v43 = v5[3];
    v59 = v5[9];
    v44 = v5[11];
    v45 = v5[13];
    v60 = v5[10];
    v61 = v5[6];
    v62 = v5[8];
    v63 = v5[14];
    v55 = v5[2];
    v46 = Curl_ccalloc(52, 1);
    v47 = (_DWORD *)v46;
    if ( !v46 )
    {
LABEL_133:
      v10 = 1;
      goto LABEL_157;
    }
    *(_DWORD *)(v46 + 4) = v42;
    if ( v42 )
    {
      if ( v55 )
      {
        v48 = v55;
      }
      else
      {
        v49 = (_DWORD *)v46;
        v48 = strlen(v42);
        v47 = v49;
      }
    }
    else
    {
      v48 = 0;
    }
    v47[2] = v48;
    v47[3] = v43;
    v47[4] = v58;
    v47[11] = v44;
    v47[12] = v45;
    v47[5] = v59;
    v47[6] = v60;
    v47[7] = v61;
    v47[8] = v63;
    v47[10] = v62;
    if ( i )
    {
      v47[9] = i[9];
      i[9] = v47;
    }
    else
    {
      v50 = *varg_r1;
      if ( !*varg_r1 )
        v50 = v64;
      *v50 = v47;
      *varg_r1 = v47;
    }
    v53 = (const char *)v5[6];
    v5 = (int *)v5[15];
    if ( !v53 )
      v53 = v32;
    if ( !v5 )
    {
      v10 = 0;
      goto LABEL_166;
    }
    v32 = v53;
  }
  if ( *v5 )
    *v5 = sub_6C9B8((const char *)*v5, v5[2]);
  v10 = 1;
  if ( *ptr )
  {
    *((_BYTE *)ptr + 4) = 1;
    goto LABEL_141;
  }
  v5 = ptr;
LABEL_157:
  if ( *((_BYTE *)v5 + 4) )
    Curl_cfree(*v5);
  if ( *((_BYTE *)v5 + 16) )
    Curl_cfree(v5[3]);
  if ( *((_BYTE *)v5 + 28) )
    Curl_cfree(v5[6]);
  if ( *((_BYTE *)v5 + 48) )
    Curl_cfree(v5[11]);
LABEL_166:
  while ( 1 )
  {
    v51 = (int *)ptr[15];
    Curl_cfree(ptr);
    if ( !v51 )
      break;
    ptr = v51;
  }
  return v10;
}
// 10: using guessed type __int16 word_10;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006CF68) --------------------------------------------------------
_DWORD **__fastcall Curl_formclean(_DWORD **result)
{
  _DWORD *v1; // r7
  _DWORD *v2; // r4
  _DWORD *v3; // r6

  v1 = result;
  v2 = *result;
  if ( *result )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)*v2;
      if ( v2[1] <= 1u )
        Curl_cfree(v2[2]);
      result = (_DWORD **)Curl_cfree(v2);
      if ( !v3 )
        break;
      v2 = v3;
    }
    *v1 = 0;
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006CF98) --------------------------------------------------------
int __fastcall curl_formfree(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r6
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0

  v1 = (_DWORD *)result;
  if ( result )
  {
    while ( 1 )
    {
      v2 = (_DWORD *)*v1;
      if ( v1[9] )
        curl_formfree();
      if ( !(v1[10] & 4) )
      {
        v3 = v1[1];
        if ( v3 )
          Curl_cfree(v3);
      }
      if ( !(v1[10] & 0x48) )
      {
        v4 = v1[3];
        if ( v4 )
          Curl_cfree(v4);
      }
      v5 = v1[7];
      if ( v5 )
        Curl_cfree(v5);
      v6 = v1[11];
      if ( v6 )
        Curl_cfree(v6);
      result = Curl_cfree(v1);
      if ( !v2 )
        break;
      v1 = v2;
    }
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006CFF0) --------------------------------------------------------
signed int __fastcall Curl_FormInit(_DWORD *a1, int a2)
{
  if ( !a2 )
    return 1;
  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return 0;
}

//----- (0006D004) --------------------------------------------------------
signed int __fastcall Curl_FormReader(void *a1, int a2, int a3, int **a4)
{
  void *v4; // r8
  int *v5; // r5
  int **v6; // r4
  size_t v7; // r6
  signed int result; // r0
  int *v9; // r3
  int *v10; // r2
  int v11; // r1
  int *v12; // r3
  int *v13; // r3
  char *v14; // r0
  size_t v15; // r2
  char *v16; // r1

  v4 = a1;
  v5 = *a4;
  v6 = a4;
  v7 = a3 * a2;
  if ( !*a4 )
    return (signed int)v5;
  if ( (unsigned int)(v5[1] - 2) > 1 || (result = sub_6C7DC(a4, a1, v7)) == 0 )
  {
    v5 = 0;
    while ( 1 )
    {
      v13 = v6[1];
      v14 = (char *)v5 + (_DWORD)v4;
      v15 = (*v6)[3] - (_DWORD)v13;
      v16 = (char *)v13 + (*v6)[2];
      if ( v15 > v7 - (unsigned int)v5 )
        break;
      memcpy(v14, v16, v15);
      v9 = *v6;
      v10 = v6[1];
      v11 = (*v6)[3];
      v6[1] = 0;
      v12 = (int *)*v9;
      v5 = (int *)((char *)v5 + v11 - (_DWORD)v10);
      *v6 = v12;
      if ( !v12 || (unsigned int)v12[1] > 1 )
        return (signed int)v5;
    }
    memcpy(v14, v16, v7 - (_DWORD)v5);
    result = v7;
    v6[1] = (int *)((char *)v6[1] + v7 - (_DWORD)v5);
  }
  return result;
}

//----- (0006D082) --------------------------------------------------------
int __fastcall Curl_formpostheader(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // r3
  int v3; // r4

  v2 = *a1;
  if ( !*a1 )
    return 0;
  v3 = v2[2];
  *a2 = v2[3];
  *a1 = (_DWORD *)**a1;
  return v3;
}

//----- (0006D09C) --------------------------------------------------------
int Curl_rand()
{
  dword_2F84A0 = 1103515245 * dword_2F84A0 + 12345;
  return __ROR4__(dword_2F84A0, 16);
}
// 2F84A0: using guessed type int dword_2F84A0;

//----- (0006D0BC) --------------------------------------------------------
char *Curl_FormBoundary()
{
  char *v0; // r0
  char *v1; // r4
  size_t i; // r5

  v0 = (char *)Curl_cmalloc(41);
  v1 = v0;
  if ( v0 )
  {
    strcpy(v0, "----------------------------");
    for ( i = strlen(v1); i <= 0x27; ++i )
      v1[i] = a0123456789abcd[Curl_rand() & 0xF];
    v1[40] = 0;
  }
  return v1;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006D10C) --------------------------------------------------------
signed int __fastcall Curl_getFormData(_DWORD *a1, signed int a2, signed int a3, _QWORD *a4)
{
  char *v4; // r6
  signed int v5; // r10
  int *v6; // r5
  signed int v7; // r4
  const char *v8; // r3
  char *v9; // r11
  signed int result; // r0
  signed int v11; // r9
  char *v12; // r8
  char *v13; // r3
  signed int v14; // r0
  char *v15; // r3
  int v16; // r3
  FILE *v17; // r0
  signed int v18; // r0
  size_t v19; // r3
  const char *v20; // r2
  unsigned int v21; // r1
  size_t v22; // r3
  void (__cdecl *v23)(void *); // r3
  int *v24; // [sp+Ch] [bp-1Ch]
  _DWORD *i; // [sp+10h] [bp-18h]
  _DWORD *v26; // [sp+14h] [bp-14h]
  _QWORD *v27; // [sp+18h] [bp-10h]
  int v28; // [sp+28h] [bp+0h]
  int v29; // [sp+2Ch] [bp+4h]
  __int64 v30; // [sp+30h] [bp+8h]
  char ptr; // [sp+3Ch] [bp+14h]
  int v32; // [sp+23Ch] [bp+214h]

  v5 = a3;
  v27 = a4;
  v6 = &GLOBAL_OFFSET_TABLE_;
  v26 = a1;
  v7 = a2;
  v30 = 0LL;
  v28 = 0;
  *a1 = 0;
  if ( !a2 )
    goto LABEL_64;
  v4 = Curl_FormBoundary();
  if ( !v4 )
  {
LABEL_65:
    result = 27;
    goto LABEL_66;
  }
  if ( v5 )
    v8 = (const char *)v5;
  else
    v8 = "Content-Type: multipart/form-data";
  v9 = (char *)sub_6C950((_DWORD **)&v28, 0, "%s; boundary=%s\r\n", v8, v4);
  if ( v9 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v4);
    result = (signed int)v9;
    goto LABEL_66;
  }
  v29 = v28;
  do
  {
    if ( v30 && (v11 = sub_6C950((_DWORD **)&v28, &v30, "\r\n")) != 0
      || (v11 = sub_6C950((_DWORD **)&v28, &v30, "--%s\r\n", v4)) != 0
      || (v11 = sub_6C950((_DWORD **)&v28, &v30, "Content-Disposition: form-data; name=\"")) != 0
      || (v11 = sub_6C880((_DWORD **)&v28, 0, *(const char **)(v7 + 4), *(_DWORD *)(v7 + 8), &v30)) != 0
      || (v11 = sub_6C950((_DWORD **)&v28, &v30, "\"")) != 0
      || *(_DWORD *)(v7 + 36)
      && (v9 = Curl_FormBoundary(),
          (v11 = sub_6C950((_DWORD **)&v28, &v30, "\r\nContent-Type: multipart/mixed, boundary=%s\r\n", v9)) != 0) )
    {
LABEL_73:
      Curl_formclean((_DWORD **)&v29);
      v23 = (void (__cdecl *)(void *))Curl_cfree;
LABEL_74:
      v23(v4);
      result = v11;
      goto LABEL_66;
    }
    v24 = (int *)v7;
    do
    {
      if ( *(_DWORD *)(v7 + 36) )
      {
        v12 = 0;
        if ( !v24[11] )
        {
          v12 = (char *)sub_6C84C(v24[3]);
          if ( !v12 )
          {
            Curl_formclean((_DWORD **)&v29);
            ((void (__cdecl *)(void *))Curl_cfree)(v4);
            goto LABEL_65;
          }
        }
        v13 = (char *)v24[11];
        if ( !v13 )
          v13 = v12;
        v14 = sub_6C950((_DWORD **)&v28, &v30, "\r\n--%s\r\nContent-Disposition: attachment; filename=\"%s\"", v9, v13);
      }
      else
      {
        if ( !(*(_DWORD *)(v7 + 40) & 0x51) )
          goto LABEL_30;
        v12 = *(char **)(v7 + 36);
        if ( !*(_DWORD *)(v7 + 44) )
          v12 = (char *)sub_6C84C(*(_DWORD *)(v7 + 12));
        v15 = *(char **)(v7 + 44);
        if ( !v15 )
          v15 = v12;
        v14 = sub_6C950((_DWORD **)&v28, &v30, "; filename=\"%s\"", v15);
      }
      v5 = v14;
      if ( v12 )
        ((void (__cdecl *)(void *))Curl_cfree)(v12);
      if ( v5 )
        goto LABEL_67;
LABEL_30:
      if ( v24[7] )
      {
        v5 = sub_6C950((_DWORD **)&v28, &v30, "\r\nContent-Type: %s");
        if ( v5 )
          goto LABEL_67;
      }
      for ( i = (_DWORD *)v24[8]; i; i = (_DWORD *)i[1] )
      {
        v5 = sub_6C950((_DWORD **)&v28, &v30, "\r\n%s", *i);
        if ( v5 )
          goto LABEL_67;
      }
      v5 = sub_6C950((_DWORD **)&v28, &v30, "\r\n\r\n");
      if ( v5 )
        goto LABEL_67;
      v16 = *(_DWORD *)(v7 + 40);
      if ( !(v16 << 30) )
      {
        if ( v16 & 0x10 )
        {
          v20 = *(const char **)(v7 + 20);
          v21 = 1;
          v22 = *(_DWORD *)(v7 + 24);
        }
        else
        {
          v22 = *(_DWORD *)(v7 + 16);
          if ( *(_DWORD *)(v7 + 40) << 25 >= 0 )
          {
            v21 = 1;
            v20 = *(const char **)(v7 + 12);
          }
          else
          {
            v21 = 2;
            v20 = *(const char **)(v7 + 48);
          }
        }
        v18 = sub_6C880((_DWORD **)&v28, v21, v20, v22, &v30);
LABEL_55:
        v5 = v18;
        if ( v18 )
          goto LABEL_67;
        goto LABEL_56;
      }
      if ( curl_strequal("-", (const char *)v24[3]) )
        goto LABEL_49;
      v17 = fopen((const char *)v24[3], "rb");
      if ( !v17 )
      {
        Curl_formclean((_DWORD **)&v29);
        ((void (__cdecl *)(void *))Curl_cfree)(v4);
        *v26 = 0;
        result = 26;
        goto LABEL_66;
      }
      if ( v17 != (FILE *)&_sF )
      {
        fclose(v17);
        v18 = sub_6C880((_DWORD **)&v28, 3u, (const char *)v24[3], 0, &v30);
        goto LABEL_55;
      }
LABEL_49:
      while ( 1 )
      {
        v19 = fread(&ptr, 1u, 0x200u, (FILE *)&_sF);
        if ( !v19 )
          break;
        v18 = sub_6C880((_DWORD **)&v28, 1u, &ptr, v19, &v30);
        if ( v18 )
          goto LABEL_55;
      }
LABEL_56:
      v24 = (int *)v24[9];
    }
    while ( v24 );
    if ( *(_DWORD *)(v7 + 36) )
    {
      v11 = sub_6C950((_DWORD **)&v28, &v30, "\r\n--%s--", v9);
      ((void (__cdecl *)(void *))Curl_cfree)(v9);
      if ( v11 )
        goto LABEL_73;
    }
    v7 = *(_DWORD *)v7;
  }
  while ( v7 );
  v6 = (int *)&Curl_cfree;
  v11 = sub_6C950((_DWORD **)&v28, &v30, "\r\n--%s--\r\n", v4);
  if ( v11 )
  {
    Curl_formclean((_DWORD **)&v29);
    v23 = (void (__cdecl *)(void *))Curl_cfree;
    goto LABEL_74;
  }
  *v27 = v30;
  ((void (__cdecl *)(void *))Curl_cfree)(v4);
  *v26 = v29;
LABEL_64:
  result = v7;
LABEL_66:
  while ( v32 != _stack_chk_guard )
  {
LABEL_67:
    Curl_formclean((_DWORD **)&v29);
    (**(void (__cdecl ***)(void *))((char *)v6 + 0xFFFFFCF0))(v4);
    result = v5;
  }
  return result;
}
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006D4D0) --------------------------------------------------------
signed int __fastcall curl_formget(signed int a1, int a2, int (__fastcall *a3)(int, int *, signed int))
{
  int v3; // r8
  int (__fastcall *v4)(int, int *, signed int); // r9
  signed int result; // r0
  _DWORD *i; // r4
  signed int v7; // r0
  int v8; // ST04_4
  signed int v9; // [sp+4h] [bp-2054h]
  _DWORD *v10; // [sp+Ch] [bp-204Ch]
  int v11; // [sp+10h] [bp-2048h]
  int v12; // [sp+1Ch] [bp-203Ch]
  FILE *v13; // [sp+24h] [bp-2034h]
  int v14; // [sp+2Ch] [bp-202Ch]

  v3 = a2;
  v4 = a3;
  result = Curl_getFormData(&v10, a1, 0, &v11);
  if ( !result )
  {
    for ( i = v10; i; i = (_DWORD *)*i )
    {
      if ( i[1] == 3 )
      {
        Curl_FormInit(&v12, (int)i);
        while ( 1 )
        {
          v7 = sub_6C7DC((int **)&v12, &v14, 0x2000u);
          if ( v7 == -1 )
            break;
          v9 = v7;
          if ( v7 != v4(v3, &v14, v7) )
            break;
          if ( v9 != 0x2000 )
            goto LABEL_14;
        }
        if ( v13 )
          fclose(v13);
LABEL_13:
        Curl_formclean(&v10);
        return -1;
      }
      v8 = i[3];
      if ( v8 != v4(v3, (int *)i[2], i[3]) )
        goto LABEL_13;
LABEL_14:
      ;
    }
    Curl_formclean(&v10);
    result = 0;
  }
  return result;
}

//----- (0006D5A8) --------------------------------------------------------
int Curl_srand()
{
  dword_2F84A0 = time(0);
  Curl_rand();
  Curl_rand();
  return Curl_rand();
}
// 2F84A0: using guessed type int dword_2F84A0;

//----- (0006D5CC) --------------------------------------------------------
int __fastcall sub_6D5CC(void *ptr)
{
  _DWORD *v1; // r5
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0

  v1 = ptr;
  v2 = *((_DWORD *)ptr + 8);
  if ( v2 )
    Curl_cfree(v2);
  v3 = v1[4];
  if ( v3 )
    Curl_cfree(v3);
  v4 = v1[3];
  if ( v4 )
    Curl_cfree(v4);
  v5 = v1[1];
  if ( v5 )
    Curl_cfree(v5);
  v6 = v1[2];
  if ( v6 )
    Curl_cfree(v6);
  v7 = v1[11];
  if ( v7 )
    Curl_cfree(v7);
  v8 = v1[10];
  if ( v8 )
    Curl_cfree(v8);
  return Curl_cfree(v1);
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006D61C) --------------------------------------------------------
int __fastcall sub_6D61C(int *a1, int a2)
{
  int *v2; // r4
  int v3; // r0
  int v4; // r5
  int result; // r0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( v3 )
    Curl_cfree(v3);
  result = Curl_cstrdup(v4);
  *v2 = result;
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006D648) --------------------------------------------------------
bool __fastcall sub_6D648(const char *a1, const char *a2)
{
  const char *v2; // r4
  unsigned __int8 *v3; // r6
  size_t v4; // r5
  size_t v5; // r0
  _BOOL4 result; // r0

  v2 = a2;
  v3 = (unsigned __int8 *)a1;
  v4 = strlen(a1);
  v5 = strlen(v2);
  if ( v4 > v5 )
    result = 0;
  else
    result = Curl_raw_equal(v3, &v2[v5 - v4]) != 0;
  return result;
}

//----- (0006D674) --------------------------------------------------------
void *__fastcall sub_6D674(int a1)
{
  char *v1; // r1
  const char *v2; // r3
  char *v3; // r2
  const char *v4; // lr
  const char *v5; // r7
  const char *v6; // r6
  __int64 v7; // r4
  int v8; // r12
  char *v9; // r0
  int v11; // [sp+Ch] [bp-2Ch]

  if ( *(_BYTE *)(a1 + 50) )
    v1 = "#HttpOnly_";
  else
    v1 = &byte_E4496;
  v2 = *(const char **)(a1 + 16);
  if ( !*(_BYTE *)(a1 + 36) )
  {
    v3 = &byte_E4496;
    goto LABEL_11;
  }
  if ( v2 )
  {
    if ( *v2 == 46 )
      v3 = &byte_E4496;
    else
      v3 = ".";
LABEL_11:
    if ( v2 )
      goto LABEL_13;
    goto LABEL_12;
  }
  v3 = &byte_E4496;
LABEL_12:
  v2 = "unknown";
LABEL_13:
  if ( *(_BYTE *)(a1 + 36) )
    v4 = "TRUE";
  else
    v4 = "FALSE";
  v5 = *(const char **)(a1 + 12);
  if ( !v5 )
    v5 = "/";
  if ( *(_BYTE *)(a1 + 48) )
    v6 = "TRUE";
  else
    v6 = "FALSE";
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)(a1 + 8);
  if ( !v9 )
    v9 = &byte_E4496;
  return curl_maprintf("%s%s%s\t%s\t%s\t%s\t%lld\t%s\t%s", v1, v3, v2, v4, v5, v6, v11, v7, v8, v9);
}
// E4496: using guessed type char byte_E4496;

//----- (0006D744) --------------------------------------------------------
_DWORD *__fastcall Curl_cookie_add(int a1, int a2, int a3, int a4, const char *a5, char *a6)
{
  int v6; // r10
  int v7; // r7
  __int64 v8; // r8
  int *v9; // r5
  signed int v10; // r6
  _DWORD *result; // r0
  _DWORD *v12; // r4
  char *v13; // r0
  const char *v14; // r1
  char *v15; // r7
  const char *v16; // r11
  int v17; // r2
  int v18; // t1
  int v19; // r3
  signed int v20; // r8
  const char *v21; // r0
  char *v22; // r0
  const char *v23; // r11
  const char *v24; // r7
  int v25; // r8
  int v26; // t1
  char *v27; // r0
  size_t i; // r0
  const char *v29; // r1
  int v30; // r3
  int v31; // r3
  int v32; // t1
  int v33; // r3
  int v34; // r0
  char *v35; // r1
  const char *v36; // r0
  int v37; // r0
  int v38; // r0
  int v39; // r0
  int v40; // r3
  char *v41; // r0
  char *v42; // r0
  char *v43; // r0
  char *v44; // r0
  int v45; // r7
  _BOOL4 v46; // r0
  char *v47; // r0
  char *v48; // r0
  _BOOL4 v49; // r0
  char *v50; // r0
  signed int *v51; // r7
  unsigned __int8 *v52; // r0
  _BYTE *v53; // r1
  unsigned __int8 *v54; // r0
  _BYTE *v55; // r1
  const char *v56; // r2
  char *v57; // r0
  size_t v58; // r8
  void *v59; // r0
  void (__cdecl **v60)(void *); // r5
  void (__cdecl **v61)(void *); // r8
  void *v62; // r0
  void *v63; // r0
  void *v64; // r0
  void *v65; // r0
  void *v66; // r0
  void *v67; // r0
  int v68; // r1
  int v69; // r2
  int v70; // r3
  _DWORD *v71; // r5
  int v72; // r1
  int v73; // r2
  int v74; // r3
  _DWORD *v75; // r5
  int v76; // r1
  int v77; // r2
  int v78; // r3
  int v79; // r1
  void (__cdecl *v80)(void *); // r3
  int v81; // [sp+Ch] [bp-46Ch]
  int v82; // [sp+18h] [bp-460h]
  char *s1; // [sp+20h] [bp-458h]
  int v84; // [sp+24h] [bp-454h]
  int (__fastcall **v85)(int); // [sp+30h] [bp-448h]
  time_t v86; // [sp+44h] [bp-434h]
  int v87; // [sp+48h] [bp-430h]
  char v88; // [sp+4Ch] [bp-42Ch]
  int v89; // [sp+44Ch] [bp-2Ch]

  v6 = a2;
  v7 = a3;
  HIDWORD(v8) = a4;
  v9 = &GLOBAL_OFFSET_TABLE_;
  v84 = a1;
  s1 = a6;
  v10 = (signed int)&_stack_chk_guard;
  v86 = time(0);
  result = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(0x38u, 1u);
  v12 = result;
  if ( !result )
    goto LABEL_153;
  if ( !v7 )
  {
    v87 = 0;
    if ( !strncmp((const char *)HIDWORD(v8), "#HttpOnly_", 0xAu) )
    {
      HIDWORD(v8) += 10;
      *((_BYTE *)v12 + 50) = 1;
    }
    if ( *(_BYTE *)HIDWORD(v8) != 35 )
    {
      v42 = strchr((const char *)HIDWORD(v8), 13);
      if ( v42 )
        *v42 = 0;
      v43 = strchr((const char *)HIDWORD(v8), 10);
      if ( v43 )
        *v43 = 0;
      v44 = strtok_r((char *)HIDWORD(v8), "\t", (char **)&v87);
      HIDWORD(v8) = v44;
      if ( v44 )
      {
        if ( !strchr(v44, 58) )
        {
          v10 = 0;
          v45 = 0;
          s1 = "TRUE";
          while ( !v45 )
          {
            switch ( v10 )
            {
              case 0:
                if ( *(_BYTE *)HIDWORD(v8) == 46 )
                  ++HIDWORD(v8);
                v47 = ((char *(__cdecl *)(const char *))Curl_cstrdup)((const char *)HIDWORD(v8));
                v12[4] = v47;
                goto LABEL_119;
              case 1:
                v46 = Curl_raw_equal((unsigned __int8 *)HIDWORD(v8), "TRUE");
                if ( v46 )
                  LOBYTE(v46) = 1;
                *((_BYTE *)v12 + 36) = v46;
                break;
              case 2:
                if ( !strcmp("TRUE", (const char *)HIDWORD(v8)) || !strcmp("FALSE", (const char *)HIDWORD(v8)) )
                {
                  v48 = ((char *(__cdecl *)(const char *))Curl_cstrdup)("/");
                  v45 = 1 - (_DWORD)v48;
                  v12[3] = v48;
                  if ( (unsigned int)v48 > 1 )
                    v45 = 0;
LABEL_113:
                  v49 = Curl_raw_equal((unsigned __int8 *)HIDWORD(v8), "TRUE");
                  v10 = 3;
                  if ( v49 )
                    LOBYTE(v49) = 1;
                  *((_BYTE *)v12 + 48) = v49;
                }
                else
                {
                  v47 = ((char *(__cdecl *)(const char *))Curl_cstrdup)((const char *)HIDWORD(v8));
                  v12[3] = v47;
LABEL_119:
                  v45 = v47 == 0;
                }
                break;
              case 3:
                goto LABEL_113;
              case 4:
                *((_QWORD *)v12 + 3) = strtoll((const char *)HIDWORD(v8), 0, 10);
                break;
              case 5:
                v47 = ((char *(__cdecl *)(const char *))Curl_cstrdup)((const char *)HIDWORD(v8));
                v12[1] = v47;
                goto LABEL_119;
              case 6:
                v47 = ((char *(__cdecl *)(const char *))Curl_cstrdup)((const char *)HIDWORD(v8));
                v12[2] = v47;
                goto LABEL_119;
              default:
                break;
            }
            ++v10;
            HIDWORD(v8) = strtok_r(0, "\t", (char **)&v87);
            if ( !HIDWORD(v8) )
            {
              if ( v10 != 6 )
              {
                if ( v45 || v10 != 7 )
                  goto LABEL_86;
                goto LABEL_125;
              }
LABEL_121:
              v50 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(&byte_E4496);
              v12[2] = v50;
              if ( !v50 || v45 )
                goto LABEL_86;
              goto LABEL_125;
            }
          }
          if ( v10 != 6 )
            goto LABEL_86;
          goto LABEL_121;
        }
      }
    }
LABEL_98:
    ((void (__cdecl *)(void *))Curl_cfree)(v12);
    goto LABEL_87;
  }
  v85 = &Curl_cmalloc;
  v10 = (signed int)((void *(__cdecl *)(size_t))Curl_cmalloc)(0x1388u);
  if ( !v10 )
    goto LABEL_98;
  v13 = strchr((const char *)HIDWORD(v8), 59);
  v14 = (const char *)HIDWORD(v8);
  v15 = v13;
  do
  {
    v16 = v14;
    v18 = *(unsigned __int8 *)v14++;
    v17 = v18;
  }
  while ( v18 && (v17 == 32 || v17 == 9) );
  HIDWORD(v8) = 0;
  while ( 1 )
  {
    v27 = strchr(v16, 61);
    if ( !v27 || v15 && v15 <= v27 )
    {
      if ( sscanf(v16, "%4999[^;\r\n]", v10) )
      {
        if ( Curl_raw_equal("secure", (_BYTE *)v10) )
        {
          *((_BYTE *)v12 + 48) = 1;
        }
        else if ( Curl_raw_equal("httponly", (_BYTE *)v10) )
        {
          *((_BYTE *)v12 + 50) = 1;
        }
      }
      goto LABEL_23;
    }
    *(_BYTE *)v10 = 0;
    v88 = 0;
    if ( sscanf(v16, "%1023[^;=]=%4999[^;\r\n]", &v88, v10) > 0 )
      break;
LABEL_23:
    if ( v15 && *v15 )
    {
      v24 = v15 + 1;
      do
      {
        v16 = v24;
        v26 = *(unsigned __int8 *)v24++;
        v25 = v26;
      }
      while ( v26 && (v25 == 32 || v25 == 9) );
      v15 = strchr(v16, 59);
      if ( v15 )
        continue;
      if ( v25 )
      {
        v15 = strchr(v16, 0);
        if ( v15 )
          continue;
      }
    }
    if ( !HIDWORD(v8) )
    {
      if ( v12[4] )
        goto LABEL_154;
      if ( !a5 )
        goto LABEL_154;
      v41 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(a5);
      v12[4] = v41;
      if ( v41 )
        goto LABEL_154;
    }
    goto LABEL_83;
  }
  for ( i = strlen((const char *)v10); i; *(_BYTE *)(v10 + i) = 0 )
  {
    v30 = *(unsigned __int8 *)(v10 + --i);
    if ( v30 != 32 && v30 != 9 )
      break;
  }
  v29 = (const char *)v10;
  do
  {
    v23 = v29;
    v32 = *(unsigned __int8 *)v29++;
    v31 = v32;
  }
  while ( v32 && (v31 == 32 || v31 == 9) );
  if ( Curl_raw_equal("path", &v88) )
  {
    sub_6D61C(v12 + 3, (int)v23);
    v33 = v12[3];
    goto LABEL_52;
  }
  if ( !Curl_raw_equal("domain", &v88) )
  {
    if ( Curl_raw_equal("version", &v88) )
    {
      sub_6D61C(v12 + 10, (int)v23);
      v33 = v12[10];
LABEL_52:
      if ( !v33 )
        goto LABEL_83;
      goto LABEL_23;
    }
    if ( Curl_raw_equal("max-age", &v88) )
    {
      sub_6D61C(v12 + 11, (int)v23);
      v36 = (const char *)v12[11];
      if ( !v36 )
        goto LABEL_83;
      if ( *v36 == 34 )
        ++v36;
      v37 = atoi(v36);
      v38 = v37 + v86;
    }
    else
    {
      if ( !Curl_raw_equal("expires", &v88) )
      {
        if ( !v12[1] )
        {
          v12[1] = ((char *(__cdecl *)(const char *))Curl_cstrdup)(&v88);
          v39 = Curl_cstrdup(v23);
          v40 = v12[1];
          v12[2] = v39;
          if ( !v40 || !v39 )
            goto LABEL_83;
        }
        goto LABEL_23;
      }
      sub_6D61C(v12 + 8, (int)v23);
      if ( !v12[8] )
        goto LABEL_83;
      v38 = curl_getdate((char *)v10);
    }
    *((_QWORD *)v12 + 3) = v38;
    goto LABEL_23;
  }
  v19 = *(unsigned __int8 *)v23;
  v20 = 1;
  if ( v19 == 46 )
    v21 = v23 + 1;
  else
    v21 = v23;
  while ( 1 )
  {
    v82 = v19;
    v22 = strchr(v21, 46);
    v19 = v82;
    if ( !v22 )
      break;
    v21 = v22 + 1;
    ++v20;
    if ( !v21 )
      goto LABEL_16;
  }
  if ( v20 == 1 )
  {
    v34 = v84;
    v35 = "skipped cookie with illegal dotcount domain: %s\n";
LABEL_49:
    HIDWORD(v8) = 1;
    Curl_infof(v34, v35, v23, v19);
    goto LABEL_23;
  }
LABEL_16:
  if ( v82 == 46 )
    ++v23;
  if ( a5 && !sub_6D648(v23, a5) )
  {
    v34 = v84;
    v35 = "skipped cookie with bad tailmatch domain: %s\n";
    goto LABEL_49;
  }
  if ( *v23 == 46 )
    ++v23;
  sub_6D61C(v12 + 4, (int)v23);
  if ( v12[4] )
  {
    *((_BYTE *)v12 + 36) = 1;
    goto LABEL_23;
  }
LABEL_83:
  HIDWORD(v8) = 1;
  while ( 2 )
  {
    (**(void (__cdecl ***)(void *))((char *)v9 + 0xFFFFFCF0))((void *)v10);
    if ( HIDWORD(v8) || !v12[1] )
    {
LABEL_86:
      sub_6D5CC(v12);
LABEL_87:
      result = 0;
      goto LABEL_153;
    }
LABEL_125:
    v10 = *(unsigned __int8 *)(v6 + 8);
    if ( !*(_BYTE *)(v6 + 8) && *(_BYTE *)(v6 + 16) && !*((_QWORD *)v12 + 3) )
    {
      sub_6D5CC(v12);
      goto LABEL_152;
    }
    *((_BYTE *)v12 + 49) = v10;
    v51 = 0;
    v10 = *(_DWORD *)v6;
    while ( 2 )
    {
      if ( !v10 )
      {
        v10 = (signed int)v12;
        v12 = 0;
        goto LABEL_142;
      }
      if ( !Curl_raw_equal(*(unsigned __int8 **)(v10 + 4), (_BYTE *)v12[1]) )
        goto LABEL_139;
      v52 = *(unsigned __int8 **)(v10 + 16);
      v53 = (_BYTE *)v12[4];
      if ( !v52 )
      {
        if ( !v53 )
          goto LABEL_137;
        goto LABEL_139;
      }
      if ( !v53 || !Curl_raw_equal(v52, v53) )
        goto LABEL_139;
LABEL_137:
      v54 = *(unsigned __int8 **)(v10 + 12);
      v55 = (_BYTE *)v12[3];
      if ( !v54 )
      {
        if ( !v55 )
          break;
        goto LABEL_139;
      }
      if ( !v55 || !Curl_raw_equal(v54, v55) )
      {
LABEL_139:
        v51 = (signed int *)v10;
        v10 = *(_DWORD *)v10;
        continue;
      }
      break;
    }
    if ( !*((_BYTE *)v12 + 49) && *(_BYTE *)(v10 + 49) )
      goto LABEL_86;
    *v12 = *(_DWORD *)v10;
    v60 = *(void (__cdecl ***)(void *))((char *)v9 + 0xFFFFFCF0);
    v61 = v60;
    (*v60)(*(void **)(v10 + 4));
    v62 = *(void **)(v10 + 8);
    if ( v62 )
      (*v60)(v62);
    v63 = *(void **)(v10 + 16);
    if ( v63 )
      (*v60)(v63);
    v64 = *(void **)(v10 + 12);
    if ( v64 )
      (*v60)(v64);
    v65 = *(void **)(v10 + 32);
    if ( v65 )
      (*v60)(v65);
    v66 = *(void **)(v10 + 40);
    if ( v66 )
      (*v60)(v66);
    v67 = *(void **)(v10 + 44);
    if ( v67 )
      (*v60)(v67);
    v68 = v12[1];
    v69 = v12[2];
    v70 = v12[3];
    *(_DWORD *)v10 = *v12;
    *(_DWORD *)(v10 + 4) = v68;
    *(_DWORD *)(v10 + 8) = v69;
    *(_DWORD *)(v10 + 12) = v70;
    v71 = (_DWORD *)(v10 + 16);
    v72 = v12[5];
    v73 = v12[6];
    v74 = v12[7];
    *v71 = v12[4];
    v71[1] = v72;
    v71[2] = v73;
    v71[3] = v74;
    v75 = (_DWORD *)(v10 + 32);
    v76 = v12[9];
    v77 = v12[10];
    v78 = v12[11];
    *v75 = v12[8];
    v75[1] = v76;
    v75[2] = v77;
    v75[3] = v78;
    v9 = (int *)(v10 + 48);
    v79 = v12[13];
    v51 = (signed int *)v10;
    v80 = *v61;
    *v9 = v12[12];
    v9[1] = v79;
    v80(v12);
    while ( *v51 )
      v51 = (signed int *)*v51;
    v12 = &dword_0 + 1;
LABEL_142:
    if ( *(_BYTE *)(v6 + 8) )
    {
      if ( v12 )
        v56 = "Replaced";
      else
        v56 = "Added";
      v8 = *(_QWORD *)(v10 + 24);
      Curl_infof(
        v84,
        "%s cookie %s=\"%s\" for domain %s, path %s, expire %d\n",
        v56,
        *(_DWORD *)(v10 + 4),
        *(_DWORD *)(v10 + 8),
        *(_DWORD *)(v10 + 16),
        *(_DWORD *)(v10 + 12),
        v81,
        *(_QWORD *)(v10 + 24));
    }
    if ( !v12 )
    {
      if ( v51 )
        *v51 = v10;
      else
        *(_DWORD *)v6 = v10;
    }
    ++*(_DWORD *)(v6 + 12);
LABEL_152:
    result = (_DWORD *)v10;
LABEL_153:
    if ( v89 != _stack_chk_guard )
    {
LABEL_154:
      if ( v12[3] )
        continue;
      if ( !s1 )
        continue;
      v57 = strrchr(s1, 47);
      if ( !v57 )
        continue;
      v58 = v57 - s1 + 1;
      v59 = (void *)(*v85)(v57 - s1 + 2);
      v12[3] = v59;
      if ( v59 )
      {
        memcpy(v59, s1, v58);
        *(_BYTE *)(v12[3] + v58) = 0;
        continue;
      }
      goto LABEL_83;
    }
    return result;
  }
}
// 0: using guessed type int dword_0;
// E4496: using guessed type char byte_E4496;
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006DE74) --------------------------------------------------------
_DWORD *__fastcall Curl_cookie_init(int a1, const char *a2, _DWORD *a3, char a4)
{
  int v4; // r10
  const char *v5; // r6
  char v6; // r9
  _DWORD *v7; // r4
  const char *v8; // r0
  signed int v9; // r8
  FILE *v10; // r7
  char *v11; // r6
  int v12; // r3
  int v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r1
  int v17; // t1

  v4 = a1;
  v5 = a2;
  v6 = a4;
  v7 = a3;
  if ( !a3 )
  {
    v7 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, 0x14u);
    if ( !v7 )
      return v7;
    if ( v5 )
      v8 = v5;
    else
      v8 = "none";
    v7[1] = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v8);
  }
  v9 = 0;
  *((_BYTE *)v7 + 8) = 0;
  if ( v5 )
  {
    if ( curl_strequal(v5, "-") )
    {
      v10 = (FILE *)&_sF;
      goto LABEL_11;
    }
    if ( *v5 )
    {
      v9 = 1;
      v10 = fopen(v5, "r");
      goto LABEL_11;
    }
  }
  v9 = 1;
  v10 = 0;
LABEL_11:
  *((_BYTE *)v7 + 16) = v6;
  if ( v10 )
  {
    v11 = (char *)Curl_cmalloc(5000);
    if ( v11 )
    {
      while ( fgets(v11, 5000, v10) )
      {
        if ( Curl_raw_nequal("Set-Cookie:", (int)v11, 11) )
        {
          v12 = (int)(v11 + 11);
          v13 = 1;
        }
        else
        {
          v12 = (int)v11;
          v13 = 0;
        }
        v14 = (unsigned __int8 *)v12;
        do
        {
          v15 = (int)v14;
          v17 = *v14++;
          v16 = v17;
        }
        while ( v17 && (v16 == 32 || v16 == 9) );
        Curl_cookie_add(v4, (int)v7, v13, v15, 0, 0);
      }
      Curl_cfree(v11);
    }
    if ( v9 )
      fclose(v10);
  }
  *((_BYTE *)v7 + 8) = 1;
  return v7;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006DFA0) --------------------------------------------------------
int __fastcall Curl_cookie_loadfiles(int result)
{
  int v1; // r4
  int v2; // r5

  v1 = result;
  v2 = *(_DWORD *)(result + 880);
  if ( v2 )
  {
    Curl_share_lock(result, 2);
    do
    {
      *(_DWORD *)(v1 + 884) = Curl_cookie_init(v1, *(const char **)v2, *(_DWORD **)(v1 + 884), *(_BYTE *)(v1 + 488));
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
    Curl_share_unlock(v1, 2);
    result = curl_slist_free_all(*(_DWORD *)(v1 + 880));
    *(_DWORD *)(v1 + 880) = 0;
  }
  return result;
}

//----- (0006DFE4) --------------------------------------------------------
_DWORD *__fastcall Curl_cookie_getlist(int **a1, unsigned __int8 *a2, const char *a3, int a4)
{
  int **v4; // r4
  unsigned __int8 *v5; // r9
  const char *v6; // r10
  int v7; // r11
  signed int v8; // r0
  int *v10; // r7
  _DWORD *v11; // r6
  __int64 v12; // r4
  const char *v13; // r0
  const char *v14; // r4
  _BOOL4 v15; // r0
  size_t v16; // r0
  _DWORD *v17; // r0
  int *v18; // r2
  _DWORD *v19; // r1
  int v20; // t1
  _DWORD *v21; // r0
  __int64 v22; // [sp+0h] [bp-28h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = time(0);
  if ( !v4 )
    return 0;
  v10 = *v4;
  if ( !*v4 )
    return 0;
  v11 = 0;
  v22 = v8;
  while ( 1 )
  {
    v12 = *((_QWORD *)v10 + 3);
    if ( v12 && v22 >= v12 )
      goto LABEL_26;
    if ( *((_BYTE *)v10 + 48) && !v7 )
      goto LABEL_26;
    v13 = (const char *)v10[4];
    if ( v13 && (!*((_BYTE *)v10 + 36) || !sub_6D648(v13, (const char *)v5)) )
    {
      if ( *((_BYTE *)v10 + 36) )
        goto LABEL_26;
      v15 = Curl_raw_equal(v5, (_BYTE *)v10[4]);
      if ( !v15 )
        goto LABEL_26;
    }
    v14 = (const char *)v10[3];
    if ( v14 )
    {
      v16 = strlen((const char *)v10[3]);
      if ( strncmp(v14, v6, v16) )
        goto LABEL_26;
    }
    v17 = (_DWORD *)Curl_cmalloc(56);
    if ( !v17 )
      break;
    v18 = v10;
    v19 = v17;
    do
    {
      v20 = *v18;
      ++v18;
      *v19 = v20;
      ++v19;
    }
    while ( v18 != v10 + 14 );
    *v17 = v11;
    v11 = v17;
LABEL_26:
    v10 = (int *)*v10;
    if ( !v10 )
      return v11;
  }
  while ( v11 )
  {
    v21 = v11;
    v11 = (_DWORD *)*v11;
    Curl_cfree(v21);
  }
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006E0C8) --------------------------------------------------------
_DWORD *__fastcall Curl_cookie_freelist(_DWORD *result, int a2)
{
  int v2; // r5
  _DWORD *v3; // r4

  v2 = a2;
  if ( result )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)*result;
      result = (_DWORD *)(v2 ? sub_6D5CC(result) : Curl_cfree(result));
      if ( !v3 )
        break;
      result = v3;
    }
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E0F0) --------------------------------------------------------
_DWORD *__fastcall Curl_cookie_clearall(_DWORD *result)
{
  _DWORD *v1; // r4

  v1 = result;
  if ( result )
  {
    result = Curl_cookie_freelist((_DWORD *)*result, 1);
    *v1 = 0;
    v1[3] = 0;
  }
  return result;
}

//----- (0006E106) --------------------------------------------------------
_QWORD *__fastcall Curl_cookie_clearsess(_QWORD *result)
{
  _DWORD *v1; // r6
  _DWORD *v2; // r4
  _QWORD *v3; // r7
  _QWORD *v4; // r5

  v1 = result;
  v2 = *(_DWORD **)result;
  if ( *(_DWORD *)result )
  {
    result = *(_QWORD **)result;
    v3 = v2;
    while ( 1 )
    {
      v4 = *(_QWORD **)result;
      if ( !result[3] )
      {
        if ( v3 == result )
          v3 = *(_QWORD **)result;
        if ( v2 == (_DWORD *)result )
          v2 = *(_DWORD **)result;
        else
          *v2 = v4;
        sub_6D5CC(result);
        result = v2;
        --v1[3];
      }
      if ( !v4 )
        break;
      v2 = result;
      result = v4;
    }
    *v1 = v3;
  }
  return result;
}

//----- (0006E144) --------------------------------------------------------
int __fastcall Curl_cookie_cleanup(int result)
{
  _DWORD **v1; // r4
  int v2; // r0
  _DWORD *i; // r0
  _DWORD *v4; // r5

  v1 = (_DWORD **)result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( v2 )
      Curl_cfree(v2);
    for ( i = *v1; i; i = v4 )
    {
      v4 = (_DWORD *)*i;
      sub_6D5CC(i);
    }
    result = Curl_cfree(v1);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E17C) --------------------------------------------------------
signed int __fastcall Curl_cookie_output(int a1, const char *a2)
{
  const char *v2; // r4
  _DWORD **v3; // r6
  _BOOL4 v5; // r5
  FILE *v6; // r4
  _DWORD *i; // r6
  void *v8; // r7

  v2 = a2;
  v3 = (_DWORD **)a1;
  if ( !a1 || !*(_DWORD *)(a1 + 12) )
    return 0;
  v5 = curl_strequal("-", a2);
  if ( v5 )
  {
    v5 = 1;
    v6 = (FILE *)((char *)&_sF + 84);
LABEL_8:
    fputs(
      "# Netscape HTTP Cookie File\n"
      "# http://curl.haxx.se/rfc/cookie_spec.html\n"
      "# This file was generated by libcurl! Edit at your own risk.\n"
      "\n",
      v6);
    for ( i = *v3; i; i = (_DWORD *)*i )
    {
      v8 = sub_6D674((int)i);
      if ( !v8 )
      {
        curl_mfprintf((int)v6, "#\n# Fatal libcurl error\n");
        if ( !v5 )
          fclose(v6);
        return 1;
      }
      curl_mfprintf((int)v6, "%s\n", v8);
      Curl_cfree(v8);
    }
    if ( !v5 )
      fclose(v6);
    return 0;
  }
  v6 = fopen(v2, "w");
  if ( v6 )
    goto LABEL_8;
  return 1;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E230) --------------------------------------------------------
int *__fastcall Curl_cookie_list(int a1)
{
  _DWORD **v1; // r3
  int *v2; // r5
  _DWORD *v3; // r6
  int v4; // r4
  void *v5; // r7

  v1 = *(_DWORD ***)(a1 + 884);
  if ( !v1 )
    return 0;
  v2 = v1[3];
  if ( v2 )
  {
    v3 = *v1;
    v4 = 0;
    v2 = 0;
    while ( v3 )
    {
      v5 = sub_6D674((int)v3);
      if ( !v5 )
      {
        curl_slist_free_all(v4);
        return 0;
      }
      v2 = curl_slist_append((int)v2, (int)v5);
      Curl_cfree(v5);
      if ( !v2 )
      {
        curl_slist_free_all(v4);
        return v2;
      }
      if ( !v4 )
        v4 = (int)v2;
      v3 = (_DWORD *)*v3;
    }
  }
  return v2;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E290) --------------------------------------------------------
int __fastcall sub_6E290(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r0
  signed int v3; // r2
  int result; // r0
  signed int v5; // r2
  bool v6; // zf

  v1 = a1;
  v2 = *a1 & a1[2];
  if ( v2 & 4 )
  {
    v3 = 4;
LABEL_5:
    v1[1] = v3;
    result = 1;
    goto LABEL_14;
  }
  if ( v2 & 2 )
  {
    v3 = 2;
    goto LABEL_5;
  }
  v5 = v2 << 28;
  if ( v2 & 8 )
  {
    v3 = 8;
    goto LABEL_5;
  }
  result = v2 & 1;
  v6 = result == 0;
  if ( result )
    result = 1;
  else
    v5 = 0x40000000;
  if ( v6 )
    v1[1] = v5;
  else
    v1[1] = result;
LABEL_14:
  v1[2] = 0;
  return result;
}

//----- (0006E2CA) --------------------------------------------------------
signed int __fastcall sub_6E2CA(int a1, _DWORD *a2)
{
  int v2; // r3
  signed int result; // r0

  v2 = *(_DWORD *)(a1 + 212);
  result = 0x10000;
  *a2 = v2;
  return result;
}

//----- (0006E2D6) --------------------------------------------------------
size_t __fastcall sub_6E2D6(void *a1, int a2, int a3, int a4)
{
  int v4; // r8
  int v5; // r7
  size_t v6; // r9
  __int64 v7; // r2
  const void *v8; // r1
  __int64 v9; // r4
  size_t result; // r0
  int v11; // r2
  int v12; // r2
  __int64 v13; // r4

  v4 = a4;
  v5 = *(_DWORD *)(*(_DWORD *)a4 + 34200);
  if ( !*(_QWORD *)(v5 + 8) )
    return 0;
  v6 = a3 * a2;
  *(_BYTE *)(*(_DWORD *)a4 + 271) = (unsigned int)(*(_DWORD *)(v5 + 88) - 1) <= 0;
  v7 = *(_QWORD *)(v5 + 8);
  v8 = *(const void **)(v5 + 16);
  if ( HIDWORD(v7) + (v6 < (unsigned int)v7) > 0 )
  {
    memcpy(a1, v8, v6);
    v13 = *(_QWORD *)(v5 + 8);
    result = v6;
    *(_DWORD *)(v5 + 16) += v6;
    *(_QWORD *)(v5 + 8) = v13 - v6;
  }
  else
  {
    memcpy(a1, v8, v7);
    v9 = *(_QWORD *)(v5 + 80);
    result = *(_DWORD *)(v5 + 8);
    if ( v9 )
    {
      v11 = *(_DWORD *)(v5 + 72);
      *(_QWORD *)(v5 + 8) = v9;
      *(_DWORD *)(v5 + 16) = v11;
      *(_DWORD *)(v4 + 404) = *(_DWORD *)(v5 + 64);
      *(_DWORD *)(v4 + 408) = *(_DWORD *)(v5 + 68);
      v12 = *(_DWORD *)(v5 + 88);
      *(_QWORD *)(v5 + 80) = 0LL;
      *(_DWORD *)(v5 + 88) = v12 + 1;
    }
    else
    {
      *(_QWORD *)(v5 + 8) = 0LL;
    }
  }
  return result;
}

//----- (0006E37C) --------------------------------------------------------
signed int __fastcall sub_6E37C(int a1, const void *a2, signed int a3)
{
  unsigned int v3; // r6
  void **v4; // r4
  const void *v5; // r8
  size_t v6; // r5
  void *v7; // r0
  int v8; // r6
  void *v9; // r0
  signed int result; // r0

  v3 = *(_DWORD *)(a1 + 8);
  v4 = (void **)a1;
  v5 = a2;
  v6 = a3;
  v7 = *(void **)a1;
  if ( ~a3 < v3 )
    goto LABEL_14;
  if ( !v7 || (char *)(a3 + v3) > (char *)v4[1] - 1 )
  {
    if ( a3 < 0 || (v3 & 0x80000000) != 0 || ~(2 * a3) < 2 * v3 )
      v8 = -1;
    else
      v8 = 2 * (v3 + a3);
    if ( v7 )
      v9 = ((void *(__cdecl *)(void *, size_t))Curl_crealloc)(v7, v8);
    else
      v9 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v8);
    if ( !v9 )
    {
      v7 = *v4;
LABEL_14:
      Curl_safefree((int)v7);
      ((void (__cdecl *)(void *))Curl_cfree)(v4);
      return 27;
    }
    *v4 = v9;
    v4[1] = (void *)v8;
  }
  memcpy((char *)v4[2] + (_DWORD)*v4, v5, v6);
  result = 0;
  v4[2] = (char *)v4[2] + v6;
  return result;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006E41C) --------------------------------------------------------
signed int __fastcall sub_6E41C(int *a1, int a2)
{
  int v2; // r6
  int v3; // r7
  void **v4; // r4
  int v5; // r3
  int v6; // r2
  size_t v7; // r0
  signed int result; // r0
  char *v9; // r1
  void *ptr; // [sp+Ch] [bp-1Ch]

  v2 = a2;
  v3 = *a1;
  if ( a2 )
  {
    v4 = (void **)(a1 + 83);
    v5 = a1[45];
    v6 = a1[46];
  }
  else
  {
    v5 = a1[43];
    v4 = (void **)(a1 + 86);
    v6 = a1[44];
  }
  curl_msnprintf(v3 + 1172, 16385, "%s:%s", v5, v6);
  v7 = strlen((const char *)(v3 + 1172));
  if ( !Curl_base64_encode(v3, (const char *)(v3 + 1172), v7, (const char **)&ptr) )
    goto LABEL_15;
  if ( *v4 )
    Curl_cfree(*v4);
  v9 = v2 ? "Proxy-" : &byte_E4496;
  *v4 = curl_maprintf("%sAuthorization: Basic %s\r\n", v9, ptr);
  Curl_cfree(ptr);
  if ( *v4 )
    result = 0;
  else
LABEL_15:
    result = 27;
  return result;
}
// E4496: using guessed type char byte_E4496;
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E4B8) --------------------------------------------------------
signed int sub_6E4B8(void **a1, char *a2, ...)
{
  void **v2; // r5
  const char *v3; // r0
  char *v4; // r6
  signed int v5; // r0
  signed int v6; // r5
  signed int result; // r0
  va_list varg_r2; // [sp+20h] [bp-8h]

  va_start(varg_r2, a2);
  v2 = a1;
  v3 = (const char *)curl_mvaprintf(a2, (int)varg_r2);
  v4 = (char *)v3;
  if ( v3 )
  {
    v5 = strlen(v3);
    v6 = sub_6E37C((int)v2, v4, v5);
    ((void (__cdecl *)(void *))Curl_cfree)(v4);
    result = v6;
  }
  else
  {
    if ( *v2 )
      ((void (__cdecl *)(void *))Curl_cfree)(*v2);
    ((void (__cdecl *)(void *))Curl_cfree)(v2);
    result = 27;
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E50C) --------------------------------------------------------
signed int __fastcall sub_6E50C(int a1, void **a2)
{
  int v2; // r5
  void **v3; // r7
  const char **i; // r4
  const char *v5; // r6
  char *v6; // r0
  int v7; // r3
  int v8; // t1
  signed int result; // r0

  v2 = a1;
  v3 = a2;
  for ( i = *(const char ***)(*(_DWORD *)a1 + 480); i; i = (const char **)i[1] )
  {
    v5 = *i;
    v6 = strchr(*i, 58);
    if ( v6 )
    {
      while ( 1 )
      {
        v8 = (unsigned __int8)(v6++)[1];
        v7 = v8;
        if ( !v8 )
          break;
        if ( !(*(_BYTE *)(v7 + ctype_ + 1) & 8) )
        {
          if ( *(_DWORD *)(v2 + 356) && Curl_raw_nequal("Host:", (int)v5, 5) )
            break;
          if ( *(_DWORD *)(*(_DWORD *)v2 + 528) == 3 && Curl_raw_nequal("Content-Type:", (int)*i, 13) )
            break;
          if ( *(_BYTE *)(v2 + 310) && Curl_raw_nequal("Content-Length", (int)*i, 14) )
            break;
          result = sub_6E4B8(v3, "%s\r\n", *i);
          if ( !result )
            break;
          return result;
        }
      }
    }
  }
  return 0;
}

//----- (0006E5C4) --------------------------------------------------------
signed int __fastcall sub_6E5C4(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  _DWORD *v5; // r6
  int v6; // r8
  _DWORD *v7; // r10
  int v8; // r4
  char *v9; // r11
  int v10; // r5
  unsigned int v11; // r7
  int v12; // r3
  size_t v13; // r9
  int v14; // ST0C_4
  signed int v15; // r9
  size_t v16; // r12
  int v17; // r0
  size_t v18; // r8
  unsigned int v19; // r1
  int v20; // r0
  signed int result; // r0
  unsigned int v22; // [sp+Ch] [bp-34h]
  unsigned int v23; // [sp+14h] [bp-2Ch]

  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = (int)a2;
  v9 = (char *)*a1;
  v10 = *(_DWORD *)(*a2 + 34200);
  v11 = a1[2];
  v12 = a2[a5 + 53];
  if ( a2[12] & 2 )
  {
    if ( v11 >= 0x4000 )
      v13 = 0x4000;
    else
      v13 = a1[2];
    v14 = a2[a5 + 53];
    memcpy((void *)(*a2 + 17557), v9, v13);
    v12 = v14;
    v9 = (char *)(*(_DWORD *)v8 + 17557);
  }
  else
  {
    v13 = a1[2];
  }
  v15 = Curl_write((int *)v8, v12, v9, v13, (ssize_t *)&v23);
  if ( !v15 )
  {
    v16 = v11 - v6;
    v17 = *(_DWORD *)v8;
    if ( v11 - v6 >= v23 )
      v16 = v23;
    v18 = v23 - v16;
    if ( *(_BYTE *)(v17 + 672) )
    {
      v22 = v16;
      Curl_debug(v17, 2u, v9, v16, v8);
      if ( v23 > v22 )
        Curl_debug(*(_DWORD *)v8, 4u, &v9[v22], v18, v8);
    }
    if ( v18 )
      *(_QWORD *)(v10 + 40) += v18;
    v19 = v23;
    *v7 += v23;
    if ( v10 )
    {
      if ( v19 != v11 )
      {
        v20 = *v5 + v19;
        *(_DWORD *)(v10 + 64) = *(_DWORD *)(v8 + 404);
        *(_DWORD *)(v10 + 68) = *(_DWORD *)(v8 + 408);
        *(_DWORD *)(v10 + 72) = *(_DWORD *)(v10 + 16);
        *(_QWORD *)(v10 + 80) = *(_QWORD *)(v10 + 8);
        *(_DWORD *)(v8 + 408) = v8;
        *(_DWORD *)(v8 + 404) = sub_6E2D6;
        *(_DWORD *)(v10 + 16) = v20;
        *(_QWORD *)(v10 + 8) = v11 - v19;
        result = 0;
        *(_DWORD *)(v10 + 92) = v5;
        *(_DWORD *)(v10 + 88) = 1;
        return result;
      }
      *(_DWORD *)(v10 + 88) = 2;
    }
    else
    {
      if ( v19 != v11 )
        return 55;
      *(_BYTE *)(v8 + 369) = 0;
    }
  }
  if ( *v5 )
    Curl_cfree(*v5);
  Curl_cfree(v5);
  return v15;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E714) --------------------------------------------------------
signed int __fastcall Curl_http_done(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r7
  int v5; // r8
  int v6; // r10
  int v7; // r9
  _DWORD *v9; // r5
  int v10; // r3
  FILE *v11; // r0

  v3 = a1;
  v4 = *(_DWORD *)a1;
  v5 = a2;
  v6 = a3;
  v7 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  Curl_unencode_cleanup(a1);
  *(_DWORD *)(v3 + 404) = *(_DWORD *)(v4 + 368);
  *(_DWORD *)(v3 + 408) = *(_DWORD *)(v4 + 300);
  *(_DWORD *)(v3 + 396) = *(_DWORD *)(v4 + 336);
  *(_DWORD *)(v3 + 400) = *(_DWORD *)(v4 + 400);
  if ( !v7 )
    return 0;
  v9 = *(_DWORD **)(v7 + 92);
  if ( v9 )
  {
    Curl_cfree(*v9);
    Curl_cfree(v9);
    *(_DWORD *)(v7 + 92) = 0;
  }
  v10 = *(_DWORD *)(v4 + 528);
  if ( v10 == 3 )
  {
    *(_QWORD *)(v4 + 56) = *(_QWORD *)(v7 + 40) + *(_QWORD *)(v7 + 32);
    Curl_formclean((_DWORD **)v7);
    v11 = *(FILE **)(v7 + 56);
    if ( v11 )
    {
      fclose(v11);
      *(_DWORD *)(v7 + 56) = 0;
    }
  }
  else if ( v10 == 4 )
  {
    *(_QWORD *)(v4 + 56) = *(_QWORD *)(v7 + 40) + *(_QWORD *)(v7 + 32);
  }
  if ( v5 )
    return v5;
  if ( v6
    || *(_BYTE *)(v3 + 307)
    || *(_QWORD *)(v7 + 32) + (signed __int64)*(signed int *)(v4 + 72) - *(signed int *)(v4 + 76) >= 1 )
  {
    return 0;
  }
  Curl_failf(v4, "Empty reply from server");
  return 52;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0006E80C) --------------------------------------------------------
bool __fastcall sub_6E80C(int a1, _DWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 532);
  if ( v2 == 2 )
    return 1;
  if ( v2 != 1 )
  {
    if ( *a2 != 11 )
    {
      if ( *a2 != 10 )
        return *(_DWORD *)(a1 + 34148) != 10;
      return 0;
    }
    return 1;
  }
  return 0;
}

//----- (0006E838) --------------------------------------------------------
_BYTE *__fastcall sub_6E838(_BYTE **a1, const char *a2)
{
  _BYTE **v2; // r4
  int v3; // r5
  int v4; // r6

  v2 = a1;
  v3 = (int)a2;
  v4 = strlen(a2);
  while ( v2 )
  {
    if ( Curl_raw_nequal(*v2, v3, v4) )
      return *v2;
    v2 = (_BYTE **)v2[1];
  }
  return 0;
}

//----- (0006E860) --------------------------------------------------------
signed int __fastcall sub_6E860(int a1, int a2, void **a3)
{
  int v3; // r4
  int v4; // r5
  void **v5; // r6
  signed int result; // r0

  v3 = a1 + 34048;
  *(_BYTE *)(a1 + 34152) = 0;
  v4 = a1;
  v5 = a3;
  if ( !sub_6E80C(a1, (_DWORD *)(a2 + 192)) || sub_6E838(*(_BYTE ***)(v4 + 480), "Expect:") )
    return 0;
  result = sub_6E4B8(v5, "Expect: 100-continue\r\n");
  if ( !result )
    *(_BYTE *)(v3 + 104) = 1;
  return result;
}

//----- (0006E8A8) --------------------------------------------------------
signed int __fastcall sub_6E8A8(int *a1, int a2, const char *a3, int a4)
{
  const char *v4; // r9
  int v5; // r8
  int *v6; // r4
  int v7; // r10
  int v8; // r5
  signed int result; // r0
  int v10; // r2
  int v11; // r2
  int v12; // r3
  int v13; // r11
  const char *v14; // r3
  char *v15; // r2
  char v16; // r3
  int v17; // r3
  int v18; // r6
  unsigned __int8 *v19; // r0
  const char *v20; // r3
  char *v21; // r2
  int v22; // [sp+Ch] [bp-2Ch]

  v4 = a3;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = *a1 + 34048;
  if ( !*((_BYTE *)a1 + 299) || !*((_BYTE *)a1 + 301) )
  {
    result = *((unsigned __int8 *)a1 + 300);
    if ( !*((_BYTE *)v6 + 300) )
    {
      *(_BYTE *)(v8 + 32) = 1;
      *(_BYTE *)(v8 + 48) = 1;
      return result;
    }
  }
  v10 = *(_DWORD *)(v8 + 20);
  if ( v10 && !*(_DWORD *)(v8 + 24) )
    *(_DWORD *)(v8 + 24) = v10;
  v11 = *(_DWORD *)(v8 + 36);
  if ( v11 && !*(_DWORD *)(v8 + 40) )
    *(_DWORD *)(v8 + 40) = v11;
  if ( !*((_BYTE *)v6 + 299) || *((unsigned __int8 *)v6 + 308) != a4 )
  {
    *(_BYTE *)(v8 + 48) = 1;
    goto LABEL_29;
  }
  v12 = *(_DWORD *)(v8 + 40);
  v13 = *v6;
  if ( v12 == 2 )
  {
    result = Curl_output_digest(v6, 1, a2, v4);
    if ( result )
      return result;
    v14 = "Digest";
LABEL_23:
    v15 = (char *)v6[45];
    if ( !v15 )
      v15 = &byte_E4496;
    Curl_infof(v13, "%s auth using %s with user '%s'\n", "Proxy", v14, v15);
    v16 = *(_BYTE *)(v8 + 48) ^ 1;
    goto LABEL_27;
  }
  if ( v12 == 1 )
  {
    if ( !*((_BYTE *)v6 + 301)
      || (v22 = *(_DWORD *)(v8 + 40), sub_6E838(*(_BYTE ***)(v13 + 480), "Proxy-authorization:")) )
    {
      v14 = 0;
    }
    else
    {
      result = sub_6E41C(v6, v22);
      if ( result )
        return result;
      v14 = "Basic";
    }
    *(_BYTE *)(v8 + 48) = 1;
    if ( v14 )
      goto LABEL_23;
  }
  v16 = 0;
LABEL_27:
  *(_BYTE *)(v8 + 49) = v16;
LABEL_29:
  if ( *(_BYTE *)(v5 + 33952) )
  {
    if ( !*((_BYTE *)v6 + 314) )
    {
      v19 = *(unsigned __int8 **)(v5 + 33956);
      if ( v19 )
      {
        if ( !*(_BYTE *)(v5 + 658) )
        {
          result = Curl_raw_equal(v19, (_BYTE *)v6[35]);
          if ( !result )
          {
            *(_BYTE *)(v8 + 32) = 1;
            return result;
          }
        }
      }
    }
  }
  v17 = *(_DWORD *)(v8 + 24);
  v18 = *v6;
  if ( v17 == 2 )
  {
    result = Curl_output_digest(v6, 0, v7, v4);
    if ( result )
      return result;
    v20 = "Digest";
  }
  else
  {
    if ( v17 != 1 )
      goto LABEL_52;
    if ( !*((_BYTE *)v6 + 300) || sub_6E838(*(_BYTE ***)(v18 + 480), "Authorization:") )
    {
      v20 = 0;
    }
    else
    {
      result = sub_6E41C(v6, 0);
      if ( result )
        return result;
      v20 = "Basic";
    }
    *(_BYTE *)(v8 + 32) = 1;
    if ( !v20 )
    {
LABEL_52:
      result = 0;
      *(_BYTE *)(v8 + 33) = 0;
      return result;
    }
  }
  v21 = (char *)v6[43];
  if ( !v21 )
    v21 = &byte_E4496;
  Curl_infof(v18, "%s auth using %s with user '%s'\n", "Server", v20, v21);
  result = 0;
  *(_BYTE *)(v8 + 33) = *(_BYTE *)(v8 + 32) ^ 1;
  return result;
}
// E4496: using guessed type char byte_E4496;

//----- (0006EA78) --------------------------------------------------------
char *__fastcall Curl_copy_header_value(char *s)
{
  int v1; // r2
  char *v2; // r3
  int v3; // r5
  const char *v4; // r4
  int v5; // r2
  int v6; // t1
  char *v7; // r1
  char *v8; // r0
  char *result; // r0
  char *v10; // r6
  size_t v11; // r6
  char *v12; // r0
  char *v13; // r5

  while ( 1 )
  {
    v1 = (unsigned __int8)*s;
    v2 = s++;
    if ( !v1 )
      break;
    if ( v1 == 58 )
    {
      v2 = s;
      break;
    }
  }
  v3 = ctype_;
  do
  {
    v4 = v2;
    v6 = (unsigned __int8)*v2++;
    v5 = v6;
  }
  while ( v6 && *(_BYTE *)(v5 + ctype_ + 1) & 8 );
  v7 = strchr(v4, 13);
  if ( v7 || (v8 = strchr(v4, 10), (v7 = v8) != 0 || (result = strchr(v4, 0), (v7 = result) != 0)) )
  {
    do
    {
      v10 = v7;
      if ( v7 <= v4 )
        break;
      --v7;
    }
    while ( *(_BYTE *)((unsigned __int8)*v10 + v3 + 1) & 8 );
    v11 = v10 - v4 + 1;
    v12 = (char *)Curl_cmalloc(v11 + 1);
    v13 = v12;
    if ( v12 )
    {
      memcpy(v12, v4, v11);
      v13[v11] = 0;
    }
    result = v13;
  }
  return result;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006EB0C) --------------------------------------------------------
signed int __fastcall Curl_http_perhapsrewind(int a1)
{
  int v1; // r6
  int v2; // r7
  int v3; // r8
  int v4; // r2
  int v5; // r3
  int v6; // r9
  __int64 v7; // r4
  signed __int64 v8; // r2
  bool v9; // zf
  const char *v10; // r0
  bool v11; // zf
  int v12; // r1

  v1 = a1;
  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)a1 + 34048;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  if ( !v4 )
    return 0;
  if ( !(*(_DWORD *)(a1 + 48) & 1) )
    return 0;
  v5 = *(_DWORD *)(v2 + 528);
  if ( v5 == 1 || v5 == 5 )
    return 0;
  v6 = *(unsigned __int8 *)(a1 + 310);
  v7 = *(_QWORD *)(v4 + 40);
  if ( *(_BYTE *)(a1 + 310) )
  {
    LODWORD(v8) = 0;
    goto LABEL_18;
  }
  switch ( v5 )
  {
    case 3:
      v8 = *(_QWORD *)(v4 + 8);
      break;
    case 4:
      v8 = *(_QWORD *)(v2 + 440);
      break;
    case 2:
      v8 = *(_QWORD *)(v2 + 344);
      v9 = HIDWORD(v8) == -1;
      if ( HIDWORD(v8) == -1 )
        v9 = (_DWORD)v8 == -1;
      if ( v9 )
      {
        v10 = *(const char **)(v2 + 332);
        if ( v10 )
        {
          LODWORD(v8) = strlen(v10);
LABEL_18:
          HIDWORD(v8) = 0;
          break;
        }
      }
      break;
    default:
      v8 = -1LL;
      break;
  }
  v11 = HIDWORD(v8) == -1;
  if ( HIDWORD(v8) == -1 )
    v11 = (_DWORD)v8 == -1;
  *(_BYTE *)(v1 + 311) = 0;
  if ( !v11 )
  {
    v12 = (unsigned __int64)(v7 - v8) >> 32;
    if ( v7 >= v8 )
    {
LABEL_33:
      if ( v7 )
        return Curl_readrewind(v1, v12, v8);
      return 0;
    }
  }
  if ( *(_DWORD *)(v3 + 40) != 8 )
  {
    v12 = *(_DWORD *)(v3 + 24);
    if ( v12 != 8 )
    {
LABEL_32:
      LODWORD(v8) = 0;
      *(_BYTE *)(v1 + 296) = 1;
      *(_QWORD *)(v2 + 24) = 0LL;
      goto LABEL_33;
    }
  }
  if ( v8 - v7 < 2000 || *(_DWORD *)(v1 + 412) )
  {
    if ( !v6 )
      *(_BYTE *)(v1 + 311) = 1;
    return 0;
  }
  if ( !*(_BYTE *)(v1 + 296) )
  {
    Curl_infof(v2, "NTLM send, close instead of sending %lld bytes\n");
    goto LABEL_32;
  }
  return 0;
}

//----- (0006EC14) --------------------------------------------------------
int __fastcall Curl_http_input_auth(int *a1, int a2, int a3)
{
  int v3; // r7
  int *v4; // r10
  int v5; // r9
  int v6; // r5
  unsigned __int8 *v7; // r2
  _DWORD *v8; // r6
  int v9; // r4
  unsigned __int8 *v10; // r8
  int v11; // r3
  int v12; // t1
  int v13; // r3
  int v14; // r6

  v3 = *a1;
  v4 = a1;
  v5 = a2;
  v6 = *a1 + 34048;
  if ( a2 == 407 )
  {
    v7 = (unsigned __int8 *)(a3 + 19);
    v8 = (_DWORD *)(*a1 + 34236);
    v9 = *a1 + 34084;
  }
  else
  {
    v7 = (unsigned __int8 *)(a3 + 17);
    v8 = (_DWORD *)(*a1 + 34240);
    v9 = *a1 + 34068;
  }
  do
  {
    v10 = v7;
    v12 = *v7++;
    v11 = v12;
  }
  while ( v12 && *(_BYTE *)(v11 + ctype_ + 1) & 8 );
  if ( Curl_raw_nequal("Digest", (int)v10, 6) )
  {
    v13 = *(_DWORD *)(v9 + 8);
    if ( v13 & 2 )
    {
      Curl_infof(v3, "Ignoring duplicate digest auth header.\n", *(_DWORD *)(v9 + 8) << 30);
    }
    else
    {
      *v8 |= 2u;
      *(_DWORD *)(v9 + 8) |= 2u;
      if ( Curl_input_digest(v4, (unsigned int)(v5 - 407) <= 0, v10) != 4 )
      {
        Curl_infof(v3, "Authentication problem. Ignoring this.\n");
        *(_BYTE *)(v6 + 52) = 1;
      }
    }
  }
  else if ( Curl_raw_nequal("Basic", (int)v10, 5) )
  {
    *v8 |= 1u;
    v14 = *(_DWORD *)(v9 + 4);
    *(_DWORD *)(v9 + 8) |= 1u;
    if ( v14 == 1 )
    {
      *(_DWORD *)(v9 + 8) = 0;
      Curl_infof(v3, "Authentication problem. Ignoring this.\n");
      *(_BYTE *)(v6 + 52) = 1;
    }
  }
  return 0;
}

//----- (0006ED0C) --------------------------------------------------------
signed int __fastcall Curl_http_should_fail(unsigned __int8 *a1)
{
  int v1; // r4
  signed int v2; // r1
  int v3; // r3

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(*(_DWORD *)a1 + 144);
  if ( !*(_BYTE *)(*(_DWORD *)a1 + 656) )
    return *(unsigned __int8 *)(*(_DWORD *)a1 + 656);
  if ( v2 < 400 || *(_QWORD *)(v1 + 34192) && *(_DWORD *)(v1 + 528) == 1 && v2 == 416 )
    return 0;
  if ( v2 == 401 )
  {
    v3 = a1[300];
LABEL_10:
    if ( v3 )
      return *(unsigned __int8 *)(v1 + 34100);
    return 1;
  }
  if ( v2 == 407 )
  {
    v3 = a1[301];
    goto LABEL_10;
  }
  return 1;
}

//----- (0006ED68) --------------------------------------------------------
signed int __fastcall Curl_http_auth_act(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r5
  int v2; // r4
  signed int v3; // r3
  signed int result; // r0
  int v5; // r7
  signed int v6; // r3
  int v7; // r0
  int v8; // r0

  v1 = a1;
  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 144);
  if ( (unsigned int)(v3 - 100) <= 0x63 )
    return 0;
  if ( *(_BYTE *)(v2 + 34100) )
  {
    if ( *(_BYTE *)(v2 + 656) )
      result = 22;
    else
      result = 0;
    return result;
  }
  v5 = a1[300];
  if ( a1[300] )
  {
    if ( v3 != 401 )
    {
      v5 = a1[310];
      if ( !a1[310] )
        goto LABEL_15;
      if ( v3 >= 300 )
      {
        v5 = *(unsigned __int8 *)(v2 + 34100);
        goto LABEL_15;
      }
    }
    v5 = sub_6E290((_DWORD *)(v2 + 34068));
    if ( !v5 )
      *(_BYTE *)(v2 + 34100) = 1;
  }
LABEL_15:
  if ( v1[301] )
  {
    v6 = *(_DWORD *)(v2 + 144);
    if ( v6 == 407 || v1[310] && v6 < 300 )
    {
      if ( sub_6E290((_DWORD *)(v2 + 34084)) )
        goto LABEL_22;
      *(_BYTE *)(v2 + 34100) = 1;
    }
  }
  if ( !v5 )
  {
    if ( *(_DWORD *)(v2 + 144) < 300 && !*(_BYTE *)(v2 + 34080) && v1[310] && (*(_DWORD *)(v2 + 528) & 0xFFFFFFFB) != 1 )
    {
      v8 = Curl_cstrdup(*(_DWORD *)(v2 + 864));
      *(_DWORD *)(v2 + 256) = v8;
      if ( !v8 )
        return 27;
      *(_BYTE *)(v2 + 34080) = 1;
    }
    goto LABEL_29;
  }
LABEL_22:
  Curl_safefree(*(_DWORD *)(v2 + 256));
  v7 = Curl_cstrdup(*(_DWORD *)(v2 + 864));
  *(_DWORD *)(v2 + 256) = v7;
  if ( !v7 )
    return 27;
  if ( (*(_DWORD *)(v2 + 528) & 0xFFFFFFFB) == 1 || v1[311] || (result = Curl_http_perhapsrewind((int)v1)) == 0 )
  {
LABEL_29:
    if ( !Curl_http_should_fail(v1) )
      return 0;
    Curl_failf(v2, "The requested URL returned error: %d", *(_DWORD *)(v2 + 144));
    result = 22;
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (0006EEA0) --------------------------------------------------------
signed int __fastcall Curl_compareheader(_BYTE *a1, const char *a2, const char *a3)
{
  _BYTE *v3; // r5
  int v4; // r4
  const char *v5; // r6
  int v6; // r7
  const char *v8; // r3
  const char *v9; // r4
  int v10; // r2
  int v11; // t1
  char *v12; // r1
  char *v13; // r0
  unsigned int v14; // r5
  char *v15; // r4
  unsigned int v16; // r7

  v3 = a1;
  v4 = (int)a2;
  v5 = a3;
  v6 = strlen(a2);
  if ( Curl_raw_nequal(v3, v4, v6) )
  {
    v8 = &v3[v6];
    do
    {
      v9 = v8;
      v11 = *(unsigned __int8 *)v8++;
      v10 = v11;
    }
    while ( v11 && *(_BYTE *)(v10 + ctype_ + 1) & 8 );
    v12 = strchr(v9, 13);
    if ( !v12 )
    {
      v13 = strchr(v9, 10);
      v12 = v13;
      if ( !v13 )
        v12 = strchr(v9, 0);
    }
    v14 = v12 - v9;
    v15 = v12;
    v16 = strlen(v5);
    while ( v14 >= v16 )
    {
      if ( Curl_raw_nequal(&v15[-v14], (int)v5, v16) )
        return 1;
      --v14;
    }
  }
  return 0;
}

//----- (0006EF28) --------------------------------------------------------
signed int __fastcall Curl_http(int *a1, _BYTE *a2)
{
  int v2; // r7
  int v3; // r10
  int v4; // r6
  int v5; // r4
  const char *v6; // r5
  signed int v7; // r3
  char *v8; // r9
  char *v9; // r0
  signed int result; // r0
  signed int v11; // r0
  void *v12; // r0
  char *v13; // r0
  const char *v14; // r2
  void *v15; // r0
  char v16; // r3
  signed int v17; // r4
  _BYTE *v18; // r0
  char *v19; // r4
  void *v20; // r0
  __int64 v21; // r2
  bool v22; // zf
  char v23; // r3
  char *v24; // r4
  char *v25; // r0
  char *v26; // r4
  char *v27; // r0
  int v28; // r2
  bool v29; // zf
  char *v30; // r1
  char *v31; // r3
  void *v32; // r0
  char *v33; // r1
  char *v34; // r3
  int v35; // r3
  const char *v36; // r8
  const char *v37; // r5
  const char *v38; // r4
  char *v39; // r11
  size_t v40; // r8
  size_t v41; // r0
  char *v42; // r0
  char *v43; // r5
  char *v44; // r0
  char *v45; // r3
  signed int v46; // r0
  unsigned int v47; // r0
  int v48; // r11
  signed int v49; // r4
  _BYTE *v50; // r0
  signed int v51; // r4
  int v52; // r0
  char *v53; // r1
  const char *v54; // r3
  __int64 v55; // r2
  int (__fastcall *v56)(_DWORD); // r1
  signed __int64 v57; // r2
  int v58; // r0
  int v59; // r12
  signed int v60; // r8
  int v61; // r0
  signed __int64 v62; // r2
  int v63; // r1
  void *v64; // r0
  void *v65; // r0
  void *v66; // r0
  _QWORD *v67; // lr
  __int64 v68; // r2
  const char *v69; // r4
  void **v70; // r0
  void **v71; // r8
  signed int v72; // r0
  char *v73; // r12
  char *v74; // r11
  _BYTE *v75; // r3
  char *v76; // r5
  char *v77; // r2
  char *v78; // r3
  _BYTE *v79; // r1
  char *v80; // r4
  char *v81; // r3
  char *v82; // ST34_4
  char *v83; // ST30_4
  char *v84; // ST2C_4
  _BYTE *v85; // r0
  char *v86; // r1
  char *v87; // r2
  unsigned __int8 *v88; // r1
  char *v89; // r11
  int v90; // r5
  signed int v91; // r0
  char *v92; // r2
  struct tm *v93; // r0
  int v94; // r4
  int v95; // r4
  int v96; // r3
  char *v97; // r1
  int v98; // r1
  signed int v99; // r3
  int v100; // r1
  int v101; // r0
  char *v102; // r1
  int v103; // r3
  const void *v104; // r0
  int v105; // r1
  __int64 v106; // r4
  bool v107; // zf
  int v108; // r1
  signed int v109; // r8
  signed int v110; // r3
  int v111; // r2
  signed __int64 v112; // r4
  bool v113; // zf
  const char *v114; // r0
  int v115; // r1
  int v116; // r3
  __int64 v117; // r2
  int v118; // r3
  __int64 v119; // r2
  signed int v120; // r3
  int v121; // [sp+4h] [bp-BCh]
  int v122; // [sp+8h] [bp-B8h]
  int v123; // [sp+Ch] [bp-B4h]
  int v124; // [sp+2Ch] [bp-94h]
  size_t n; // [sp+38h] [bp-88h]
  __int64 na; // [sp+38h] [bp-88h]
  size_t nb; // [sp+38h] [bp-88h]
  char *v128; // [sp+40h] [bp-80h]
  signed int v129; // [sp+44h] [bp-7Ch]
  size_t v130; // [sp+48h] [bp-78h]
  int v131; // [sp+48h] [bp-78h]
  signed int v132; // [sp+4Ch] [bp-74h]
  const char *v133; // [sp+50h] [bp-70h]
  const char *v134; // [sp+54h] [bp-6Ch]
  char *v135; // [sp+58h] [bp-68h]
  struct tm tp; // [sp+60h] [bp-60h]
  int v137; // [sp+8Ch] [bp-34h]
  int v138; // [sp+90h] [bp-30h]
  int v139; // [sp+94h] [bp-2Ch]

  v2 = (int)a1;
  v3 = (int)&GLOBAL_OFFSET_TABLE_;
  v4 = *a1;
  v5 = *a1 + 34048;
  v6 = *(const char **)(*a1 + 34180);
  v134 = (const char *)a1[35];
  v137 = 0;
  v138 = 0;
  v7 = *(_DWORD *)(v4 + 528);
  *a2 = 1;
  v129 = v7;
  Curl_reset_reqproto((int)a1);
  v8 = *(char **)(v5 + 152);
  if ( !v8 )
  {
    v9 = (char *)((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(0x60u, 1u);
    v8 = v9;
    if ( !v9 )
      goto LABEL_3;
    *(_DWORD *)(v5 + 152) = v9;
  }
  if ( !*(_BYTE *)(v4 + 33952) )
  {
    v12 = *(void **)(v4 + 33956);
    if ( v12 )
      ((void (__cdecl *)(void *))Curl_cfree)(v12);
    v13 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(*(const char **)(v2 + 140));
    *(_DWORD *)(v4 + 33956) = v13;
    if ( !v13 )
      goto LABEL_3;
  }
  if ( *(_DWORD *)(v2 + 48) & 5 )
  {
    v11 = v129;
    if ( *(_BYTE *)(v4 + 664) )
      v11 = 4;
    v129 = v11;
  }
  v128 = *(char **)(v4 + 736);
  if ( !v128 )
  {
    if ( *(_BYTE *)(v4 + 662) )
    {
      v128 = "HEAD";
    }
    else
    {
      switch ( v129 )
      {
        case 2:
        case 3:
          v14 = "POST";
          goto LABEL_22;
        case 4:
          v14 = "PUT";
LABEL_22:
          v128 = (char *)v14;
          break;
        case 5:
          v128 = "HEAD";
          break;
        default:
          v128 = "GET";
          break;
      }
    }
  }
  if ( sub_6E838(*(_BYTE ***)(v4 + 480), "User-Agent:") )
  {
    v15 = *(void **)(v2 + 336);
    if ( v15 )
    {
      ((void (__cdecl *)(void *))Curl_cfree)(v15);
      *(_DWORD *)(v2 + 336) = 0;
    }
  }
  result = sub_6E8A8((int *)v2, (int)v128, v6, 0);
  if ( result )
    goto LABEL_347;
  v16 = (*(_BYTE *)(v5 + 33) || *(_BYTE *)(v5 + 49)) && (v129 & 0xFFFFFFFB) != 1 ? 1 : 0;
  *(_BYTE *)(v2 + 310) = v16;
  Curl_safefree(*(_DWORD *)(v2 + 352));
  if ( !*(_DWORD *)(v4 + 872) || sub_6E838(*(_BYTE ***)(v4 + 480), "Referer:") )
    *(_DWORD *)(v2 + 352) = 0;
  else
    *(_DWORD *)(v2 + 352) = curl_maprintf("Referer: %s\r\n", *(_DWORD *)(v4 + 872));
  v17 = !*(_DWORD *)(v4 + 728) || sub_6E838(*(_BYTE ***)(v4 + 480), "Cookie:") ? 0 : *(_DWORD *)(v4 + 728);
  v132 = v17;
  if ( !sub_6E838(*(_BYTE ***)(v4 + 480), "Accept-Encoding:") )
  {
    if ( *(_DWORD *)(v4 + 744) )
    {
      Curl_safefree(*(_DWORD *)(v2 + 340));
      v20 = curl_maprintf("Accept-Encoding: %s\r\n", *(_DWORD *)(v4 + 744));
      *(_DWORD *)(v2 + 340) = v20;
      if ( !v20 )
      {
LABEL_3:
        result = 27;
        goto LABEL_347;
      }
    }
  }
  v18 = sub_6E838(*(_BYTE ***)(v4 + 480), "Transfer-Encoding:");
  if ( v18 )
  {
    v19 = &byte_E4496;
    *(_BYTE *)(v4 + 269) = Curl_compareheader(v18, "Transfer-Encoding:", "chunked");
  }
  else
  {
    if ( !(*(_DWORD *)(v2 + 48) & 1) || !*(_BYTE *)(v4 + 664) )
      goto LABEL_357;
    v21 = *(_QWORD *)(v4 + 440);
    v22 = HIDWORD(v21) == -1;
    if ( HIDWORD(v21) == -1 )
      v22 = (_DWORD)v21 == -1;
    if ( v22 )
    {
      if ( !sub_6E80C(v4, (_DWORD *)(v2 + 192)) )
      {
        Curl_failf(v4, "Chunky upload is not supported by HTTP 1.0");
        result = 25;
        goto LABEL_347;
      }
      v23 = 1;
    }
    else
    {
LABEL_357:
      v23 = 0;
    }
    *(_BYTE *)(v4 + 269) = v23;
    if ( *(_BYTE *)(v4 + 269) )
      v19 = "Transfer-Encoding: chunked\r\n";
    else
      v19 = &byte_E4496;
  }
  v133 = v19;
  Curl_safefree(*(_DWORD *)(v2 + 356));
  v24 = sub_6E838(*(_BYTE ***)(v4 + 480), "Host:");
  if ( v24 && (!*(_BYTE *)(v4 + 33952) || Curl_raw_equal(*(unsigned __int8 **)(v4 + 33956), *(_BYTE **)(v2 + 140))) )
  {
    v25 = Curl_copy_header_value(v24);
    v26 = v25;
    if ( !v25 )
      goto LABEL_3;
    if ( *v25 )
    {
      v27 = strchr(v25, 58);
      if ( v27 )
        *v27 = 0;
      Curl_safefree(*(_DWORD *)(v2 + 360));
      *(_DWORD *)(v2 + 360) = v26;
    }
    else
    {
      ((void (__cdecl *)(void *))Curl_cfree)(v25);
    }
    *(_DWORD *)(v2 + 356) = 0;
  }
  else
  {
    v28 = *(unsigned __int16 *)(v2 + 168);
    if ( *(_DWORD *)(v2 + 48) & 2 )
      v29 = v28 == 443;
    else
      v29 = v28 == 80;
    if ( v29 )
    {
      if ( *(_BYTE *)(v2 + 302) )
      {
        v30 = "[";
        v31 = "]";
      }
      else
      {
        v30 = &byte_E4496;
        v31 = &byte_E4496;
      }
      v32 = curl_maprintf("Host: %s%s%s\r\n", v30, v134, v31);
    }
    else
    {
      if ( *(_BYTE *)(v2 + 302) )
      {
        v33 = "[";
        v34 = "]";
      }
      else
      {
        v33 = &byte_E4496;
        v34 = &byte_E4496;
      }
      v32 = curl_maprintf("Host: %s%s%s:%d\r\n", v33, v134, v34, *(unsigned __int16 *)(v2 + 168));
    }
    *(_DWORD *)(v2 + 356) = v32;
    if ( !*(_DWORD *)(v2 + 356) )
      goto LABEL_3;
  }
  v35 = *(unsigned __int8 *)(v2 + 299);
  if ( !*(_BYTE *)(v2 + 299) )
    goto LABEL_358;
  if ( *(_BYTE *)(v2 + 308) )
  {
    v48 = 0;
    goto LABEL_105;
  }
  v36 = *(const char **)(v2 + 144);
  v37 = *(const char **)(v2 + 140);
  if ( v36 != v37 )
  {
    v38 = *(const char **)(v4 + 864);
    v39 = strstr(*(const char **)(v4 + 864), *(const char **)(v2 + 144));
    if ( v39 )
    {
      v40 = strlen(v36);
      n = strlen(v37);
      v41 = strlen(v38);
      v130 = v41;
      v42 = (char *)((void *(__cdecl *)(size_t))Curl_cmalloc)(n + v41 + 1 - v40);
      v43 = v42;
      if ( !v42 )
        goto LABEL_3;
      memcpy(v42, v38, v39 - v38);
      memcpy(&v43[v39 - v38], *(const void **)(v2 + 140), n);
      memcpy(&v43[n + v39 - v38], &v39[v40], v130 + v38 - v39 + 1 - v40);
      if ( *(_BYTE *)(v4 + 868) )
        ((void (__cdecl *)(void *))Curl_cfree)(*(void **)(v4 + 864));
      *(_DWORD *)(v4 + 864) = v43;
      *(_BYTE *)(v4 + 868) = 1;
    }
  }
  v6 = *(const char **)(v4 + 864);
  if ( !Curl_raw_nequal("ftp://", *(_DWORD *)(v4 + 864), 6) )
  {
    v48 = 0;
    goto LABEL_105;
  }
  if ( *(_BYTE *)(v4 + 716) )
  {
    v44 = strstr(v6, ";type=");
    v45 = v44;
    if ( !v44 )
      goto LABEL_348;
    v46 = (unsigned __int8)v44[6];
    if ( v46 )
    {
      if ( !v45[7] )
      {
        v47 = (unsigned __int8)(Curl_raw_toupper(v46) - 65);
        if ( v47 > 8 || !((1 << v47) & 0x109) )
          goto LABEL_348;
      }
    }
  }
  while ( 2 )
  {
    v35 = *(unsigned __int8 *)(v2 + 300);
    if ( !*(_BYTE *)(v2 + 300) )
    {
LABEL_358:
      v48 = v35;
      goto LABEL_105;
    }
    v48 = *(unsigned __int8 *)(v2 + 315) ^ 1;
LABEL_105:
    if ( v129 == 3 )
    {
      v49 = *(_DWORD *)(v4 + 484);
      v50 = sub_6E838(*(_BYTE ***)(v4 + 480), "Content-Type:");
      v51 = Curl_getFormData(v8, v49, (signed int)v50, (_QWORD *)v8 + 1);
      if ( v51 )
      {
        v52 = v4;
        v53 = "failed creating formpost data";
        goto LABEL_333;
      }
    }
    if ( sub_6E838(*(_BYTE ***)(v4 + 480), "Accept:") )
      v54 = 0;
    else
      v54 = "Accept: */*\r\n";
    v131 = v4 + 1172;
    *((_DWORD *)v8 + 6) = v54;
    if ( (unsigned int)(v129 - 2) <= 2 )
    {
      v55 = *(_QWORD *)(v4 + 34192);
      if ( v55 )
      {
        if ( v55 < 0 )
          *(_QWORD *)(v4 + 34192) = 0LL;
        if ( *(_QWORD *)(v4 + 34192) && !*(_BYTE *)(v4 + 33952) )
        {
          v56 = *(int (__fastcall **)(_DWORD))(v2 + 396);
          if ( v56 )
          {
            v58 = v56(*(_DWORD *)(v2 + 400));
            if ( v58 )
            {
              if ( v58 == 2 )
              {
                v59 = v4 + 34048;
                na = 0LL;
                while ( 1 )
                {
                  v60 = (unsigned int)(*(_DWORD *)(v59 + 144) - na) >= 0x4000 ? 0x4000 : *(_DWORD *)(v59 + 144) - na;
                  v124 = v59;
                  v61 = (*(int (__fastcall **)(int, signed int, signed int, _DWORD))(v4 + 368))(
                          v131,
                          1,
                          v60,
                          *(_DWORD *)(v4 + 300));
                  v59 = v124;
                  na += (unsigned int)v61;
                  if ( v61 != v60 )
                    break;
                  if ( na == *(_QWORD *)(v124 + 144) )
                    goto LABEL_118;
                }
                Curl_failf(v4, "Could only read %lld bytes from the input");
              }
              else
              {
                Curl_failf(v4, "Could not seek stream");
              }
              result = 26;
              goto LABEL_347;
            }
          }
LABEL_118:
          v57 = *(_QWORD *)(v4 + 440);
          if ( v57 >= 1 )
          {
            v62 = v57 - *(_QWORD *)(v4 + 34192);
            *(_QWORD *)(v4 + 440) = v62;
            if ( v62 < 1 )
            {
              Curl_failf(v4, "File already completely uploaded");
              result = 18;
              goto LABEL_347;
            }
          }
        }
      }
    }
    if ( *(_BYTE *)(v4 + 34184) )
    {
      if ( (v129 & 0xFFFFFFFB) != 1 )
      {
LABEL_136:
        if ( !sub_6E838(*(_BYTE ***)(v4 + 480), "Content-Range:") )
        {
          v65 = *(void **)(v2 + 348);
          if ( v65 )
            (**(void (__cdecl ***)(void *))(v3 + 0xFFFFFCF0))(v65);
          if ( (signed int)(*(_QWORD *)(v4 + 472) >> 32) >= 0 )
          {
            v67 = (_QWORD *)(v4 + 440);
            v68 = *(_QWORD *)(v4 + 34192);
            v66 = v68 ? curl_maprintf(
                          "Content-Range: bytes %s%lld/%lld\r\n",
                          *(_DWORD *)(v4 + 34188),
                          (_DWORD)v68 + *(_DWORD *)v67 - 1,
                          (_DWORD)(((_DWORD)v68 + *(_DWORD *)v67 != 0) + ((unsigned __int64)(v68 + *v67) >> 32) - 1),
                          v68 + *v67) : curl_maprintf("Content-Range: bytes %s/%lld\r\n", *(_DWORD *)(v4 + 34188), *v67);
          }
          else
          {
            v66 = curl_maprintf(
                    "Content-Range: bytes 0-%lld/%lld\r\n",
                    v63,
                    (unsigned int)*(_QWORD *)(v4 + 440) - 1,
                    (_DWORD)(((unsigned int)*(_QWORD *)(v4 + 440) != 0) + (*(_QWORD *)(v4 + 440) >> 32) - 1),
                    *(_QWORD *)(v4 + 440));
          }
          *(_DWORD *)(v2 + 348) = v66;
          if ( !*(_DWORD *)(v2 + 348) )
            goto LABEL_3;
        }
        goto LABEL_152;
      }
      if ( sub_6E838(*(_BYTE ***)(v4 + 480), "Range:") )
      {
        if ( v129 != 1 )
          goto LABEL_136;
      }
      else
      {
        v64 = *(void **)(v2 + 348);
        if ( v64 )
          (**(void (__cdecl ***)(void *))(v3 + 0xFFFFFCF0))(v64);
        *(_DWORD *)(v2 + 348) = curl_maprintf("Range: bytes=%s\r\n", *(_DWORD *)(v4 + 34188));
      }
    }
LABEL_152:
    if ( sub_6E80C(v4, (_DWORD *)(v2 + 192)) )
      v69 = "1.1";
    else
      v69 = "1.0";
    nb = (size_t)v69;
    v70 = (void **)(**(void *(__cdecl ***)(size_t, size_t))(v3 + 0xFFFFFD08))(0xCu, 1u);
    v71 = v70;
    if ( !v70 )
      goto LABEL_3;
    result = sub_6E4B8(v70, "%s ", v128);
    if ( result )
      goto LABEL_347;
    if ( v48 )
    {
      result = sub_6E4B8(v71, "ftp://%s:%s@%s", *(_DWORD *)(v2 + 172), *(_DWORD *)(v2 + 176), v6 + 6);
    }
    else
    {
      v72 = strlen(v6);
      result = sub_6E37C((int)v71, v6, v72);
    }
    if ( result )
      goto LABEL_347;
    if ( *(_DWORD *)(v2 + 332) )
      v73 = *(char **)(v2 + 332);
    else
      v73 = &byte_E4496;
    if ( *(_DWORD *)(v2 + 344) )
      v128 = *(char **)(v2 + 344);
    else
      v128 = &byte_E4496;
    if ( *(_BYTE *)(v4 + 34184) )
    {
      if ( *(_DWORD *)(v2 + 348) )
        v74 = *(char **)(v2 + 348);
      else
        v74 = &byte_E4496;
    }
    else
    {
      v74 = &byte_E4496;
    }
    v75 = *(_BYTE **)(v4 + 820);
    if ( v75 )
    {
      if ( *v75 )
      {
        v76 = *(char **)(v2 + 336);
        if ( !v76 )
          v76 = &byte_E4496;
      }
      else
      {
        v76 = &byte_E4496;
      }
    }
    else
    {
      v76 = &byte_E4496;
    }
    v77 = *(char **)(v2 + 356);
    if ( !v77 )
      v77 = &byte_E4496;
    v78 = (char *)*((_DWORD *)v8 + 6);
    if ( !v78 )
      v78 = &byte_E4496;
    v79 = *(_BYTE **)(v4 + 744);
    v135 = v78;
    if ( v79 )
    {
      if ( *v79 )
      {
        v80 = *(char **)(v2 + 340);
        if ( !v80 )
          v80 = &byte_E4496;
      }
      else
      {
        v80 = &byte_E4496;
      }
    }
    else
    {
      v80 = &byte_E4496;
    }
    if ( *(_DWORD *)(v4 + 872) )
    {
      if ( *(_DWORD *)(v2 + 352) )
        v81 = *(char **)(v2 + 352);
      else
        v81 = &byte_E4496;
    }
    else
    {
      v81 = &byte_E4496;
    }
    if ( *(_BYTE *)(v2 + 299) )
    {
      if ( *(_BYTE *)(v2 + 308) )
      {
        v86 = &byte_E4496;
      }
      else
      {
        v82 = v77;
        v83 = v81;
        v84 = v73;
        v85 = sub_6E838(*(_BYTE ***)(v4 + 480), "Proxy-Connection:");
        v77 = v82;
        v81 = v83;
        v73 = v84;
        if ( v85 )
          v86 = &byte_E4496;
        else
          v86 = "Proxy-Connection: Keep-Alive\r\n";
      }
    }
    else
    {
      v86 = &byte_E4496;
    }
    v51 = sub_6E4B8(
            v71,
            "%s HTTP/%s\r\n%s%s%s%s%s%s%s%s%s%s",
            &v137,
            nb,
            v73,
            v128,
            v74,
            v76,
            v77,
            v135,
            v80,
            v81,
            v86,
            v133);
    Curl_safefree(*(_DWORD *)(v2 + 344));
    *(_DWORD *)(v2 + 344) = 0;
    if ( v51 )
      goto LABEL_354;
    if ( !*(_DWORD *)(v4 + 884) )
    {
      if ( v132 )
        goto LABEL_206;
      goto LABEL_203;
    }
    Curl_share_lock(v4, 2);
    v88 = *(unsigned __int8 **)(v2 + 360);
    if ( !v88 )
      v88 = (unsigned __int8 *)v134;
    v128 = (char *)Curl_cookie_getlist(
                     *(int ***)(v4 + 884),
                     v88,
                     *(const char **)(v4 + 34180),
                     (*(_DWORD *)(v2 + 48) >> 1) & 1);
    Curl_share_unlock(v4, 2);
    if ( !v128 )
    {
      if ( v132 )
        goto LABEL_206;
      goto LABEL_203;
    }
    v89 = v128;
    v90 = 0;
    v133 = "; ";
    v134 = "Cookie: ";
    while ( !*((_DWORD *)v89 + 2) )
    {
LABEL_219:
      v89 = *(char **)v89;
      if ( !v89 )
        goto LABEL_222;
    }
    if ( v90 )
    {
      v92 = "; ";
    }
    else
    {
      v91 = sub_6E4B8(v71, "Cookie: ");
      if ( v91 )
        goto LABEL_221;
      v92 = &byte_E4496;
    }
    v91 = sub_6E4B8(v71, "%s%s=%s", v92, *((_DWORD *)v89 + 1), *((_DWORD *)v89 + 2));
    if ( !v91 )
    {
      ++v90;
      goto LABEL_219;
    }
LABEL_221:
    v51 = v91;
LABEL_222:
    Curl_cookie_freelist(v128, 0);
    if ( v132 )
    {
      if ( v51 )
        goto LABEL_354;
      if ( v90 )
      {
        v87 = "; ";
LABEL_226:
        v51 = sub_6E4B8(v71, "%s%s", v87, v132);
LABEL_228:
        if ( !v51 )
        {
          v51 = sub_6E37C((int)v71, "\r\n", 2);
          goto LABEL_230;
        }
        goto LABEL_354;
      }
LABEL_206:
      v51 = sub_6E4B8(v71, "Cookie: ");
      if ( !v51 )
      {
        v87 = &byte_E4496;
        goto LABEL_226;
      }
      goto LABEL_354;
    }
    if ( v90 )
      goto LABEL_228;
LABEL_230:
    if ( v51 )
    {
LABEL_354:
      result = v51;
      goto LABEL_347;
    }
LABEL_203:
    if ( !*(_DWORD *)(v4 + 520)
      || ((v93 = gmtime_r((const time_t *)(v4 + 524), &tp), (v94 = v93->tm_wday) == 0) ? (v95 = 6) : (v95 = v94 - 1),
          (curl_msnprintf(
             v131,
             0x3FFF,
             "%s, %02d %s %4d %02d:%02d:%02d GMT",
             *(_DWORD *)(*(_DWORD *)(v3 + 0xFFFFFD1C) + 4 * v95),
             v93->tm_mday,
             *(_DWORD *)(*(_DWORD *)(v3 + 0xFFFFFD20) + 4 * v93->tm_mon),
             v93->tm_year + 1900,
             v93->tm_hour,
             v93->tm_min,
             v93->tm_sec),
           v96 = *(_DWORD *)(v4 + 520),
           v96 == 2) ? (v97 = "If-Unmodified-Since: %s\r\n") : v96 == 3 ? (v97 = "Last-Modified: %s\r\n") : (v97 = "If-Modified-Since: %s\r\n"),
          (result = sub_6E4B8(v71, v97, v131)) == 0) )
    {
      result = sub_6E50C(v2, v71);
      if ( !result )
      {
        *((_DWORD *)v8 + 4) = 0;
        Curl_pgrsSetUploadSize(v4, v98, 0LL);
        if ( v129 != 3 )
        {
          if ( v129 != 4 )
          {
            if ( v129 == 2 )
            {
              v3 = *(unsigned __int8 *)(v2 + 310);
              if ( *(_BYTE *)(v2 + 310) )
                goto LABEL_359;
              v112 = *(_QWORD *)(v4 + 344);
              v113 = HIDWORD(v112) == -1;
              if ( HIDWORD(v112) == -1 )
                v113 = (_DWORD)v112 == -1;
              if ( !v113 )
              {
LABEL_293:
                if ( !*(_BYTE *)(v4 + 269) && (v3 || !sub_6E838(*(_BYTE ***)(v4 + 480), "Content-Length:")) )
                {
                  result = sub_6E4B8(v71, "Content-Length: %lld\r\n", v112);
                  if ( result )
                    goto LABEL_347;
                }
                if ( !sub_6E838(*(_BYTE ***)(v4 + 480), "Content-Type:") )
                {
                  result = sub_6E4B8(v71, "Content-Type: application/x-www-form-urlencoded\r\n");
                  if ( result )
                    goto LABEL_347;
                }
                v115 = -(HIDWORD(v112) + ((unsigned int)v112 > 0x400));
                if ( v112 <= 1024 )
                {
                  *(_BYTE *)(v4 + 34152) = 0;
                }
                else
                {
                  result = sub_6E860(v4, v2, v71);
                  if ( result )
                    goto LABEL_347;
                }
                if ( *(_DWORD *)(v4 + 332) )
                {
                  if ( !*(_BYTE *)(v4 + 34152) && v112 < 0x10000 )
                  {
                    result = sub_6E37C((int)v71, "\r\n", 2);
                    if ( result )
                      goto LABEL_347;
                    if ( *(_BYTE *)(v4 + 269) )
                    {
                      result = sub_6E4B8(v71, "%x\r\n", (_DWORD)v112);
                      if ( !result )
                      {
                        result = sub_6E37C((int)v71, *(const void **)(v4 + 332), v112);
                        if ( !result )
                          result = sub_6E37C((int)v71, "\r\n0\r\n\r\n", 7);
                      }
                      LODWORD(v112) = v112 + 7;
                    }
                    else
                    {
                      result = sub_6E37C((int)v71, *(const void **)(v4 + 332), v112);
                    }
                    if ( result )
                      goto LABEL_347;
LABEL_331:
                    v51 = sub_6E5C4(v71, (_DWORD *)v2, (_DWORD *)(v4 + 34232), v112, 0);
                    if ( v51 )
                    {
                      v52 = v4;
                      v53 = "Failed sending HTTP POST request";
                      goto LABEL_333;
                    }
LABEL_337:
                    v118 = *((_DWORD *)v8 + 4);
                    if ( v118 )
                      v118 = (int)(v8 + 40);
                    else
                      v51 = -1;
                    v123 = v118;
                    v121 = (int)(v8 + 32);
                    v122 = v51;
LABEL_340:
                    result = Curl_setup_transfer((int *)v2, 0, -1LL, 1, v121, v122, v123);
LABEL_341:
                    if ( result )
                      goto LABEL_347;
LABEL_342:
                    v119 = *((_QWORD *)v8 + 5);
                    if ( v119 && (Curl_pgrsSetUploadCounter(v4, v100, v119), Curl_pgrsUpdate((int *)v2)) )
                      result = 42;
                    else
                      result = 0;
                    goto LABEL_347;
                  }
                  *((_QWORD *)v8 + 1) = v112;
                  v116 = *(_DWORD *)(v4 + 332);
                  *((_DWORD *)v8 + 22) = 2;
                  *((_DWORD *)v8 + 4) = v116;
                  *(_DWORD *)(v2 + 408) = v2;
                  *(_DWORD *)(v2 + 404) = sub_6E2D6;
                  Curl_pgrsSetUploadSize(v4, v115, *((_QWORD *)v8 + 1));
                  result = sub_6E37C((int)v71, "\r\n", 2);
                  if ( result )
                    goto LABEL_347;
                }
                else
                {
                  result = sub_6E37C((int)v71, "\r\n", 2);
                  if ( result )
                    goto LABEL_347;
                  v117 = *(_QWORD *)(v4 + 344);
                  if ( v117 )
                  {
                    if ( v112 )
                      HIDWORD(v117) = HIDWORD(v112);
                    else
                      LODWORD(v117) = -1;
                    if ( v112 )
                      LODWORD(v117) = v112;
                    else
                      HIDWORD(v117) = v117;
                    Curl_pgrsSetUploadSize(v4, v112 | HIDWORD(v112), v117);
                    if ( !*(_BYTE *)(v2 + 310) )
                    {
                      *((_QWORD *)v8 + 1) = v112;
                      *((_DWORD *)v8 + 4) = v8 + 16;
                    }
                  }
                }
                LODWORD(v112) = 0;
                goto LABEL_331;
              }
              v114 = *(const char **)(v4 + 332);
              if ( !v114 )
LABEL_359:
                LODWORD(v112) = 0;
              else
                LODWORD(v112) = strlen(v114);
              HIDWORD(v112) = 0;
              goto LABEL_293;
            }
            v99 = sub_6E37C((int)v71, "\r\n", 2);
            if ( !v99 )
            {
              v51 = sub_6E5C4(v71, (_DWORD *)v2, (_DWORD *)(v4 + 34232), 0, 0);
              if ( v51 )
              {
                v52 = v4;
                v53 = "Failed sending HTTP request";
                goto LABEL_333;
              }
              goto LABEL_337;
            }
            goto LABEL_346;
          }
          if ( *(_BYTE *)(v2 + 310) )
          {
            v106 = 0LL;
LABEL_275:
            if ( !*(_BYTE *)(v4 + 269) )
            {
              result = sub_6E4B8(v71, "Content-Length: %lld\r\n", v106);
              if ( result )
                goto LABEL_347;
            }
          }
          else
          {
            v106 = *(_QWORD *)(v4 + 440);
            v107 = HIDWORD(v106) == -1;
            if ( HIDWORD(v106) == -1 )
              v107 = (_DWORD)v106 == -1;
            if ( !v107 )
              goto LABEL_275;
          }
          result = sub_6E860(v4, v2, v71);
          if ( result )
            goto LABEL_347;
          result = sub_6E37C((int)v71, "\r\n", 2);
          v3 = result;
          if ( result )
            goto LABEL_347;
          Curl_pgrsSetUploadSize(v4, v108, v106);
          v109 = sub_6E5C4(v71, (_DWORD *)v2, (_DWORD *)(v4 + 34232), v3, v3);
          if ( v109 )
          {
            Curl_failf(v4, "Failed sending PUT request");
            result = v109;
            goto LABEL_347;
          }
          if ( v106 )
          {
            v111 = (int)(v8 + 40);
            v110 = 0;
          }
          else
          {
            v110 = -1;
            v111 = 0;
          }
          v123 = v111;
          v121 = (int)(v8 + 32);
          v122 = v110;
          goto LABEL_340;
        }
        if ( *(_DWORD *)v8 && !*(_BYTE *)(v2 + 310) )
        {
          if ( Curl_FormInit((_DWORD *)v8 + 12, *(_DWORD *)v8) )
          {
            v101 = v4;
            v102 = "Internal HTTP POST error!";
          }
          else
          {
            *((_DWORD *)v8 + 15) = *(_DWORD *)(v2 + 404);
            v103 = *(_DWORD *)(v3 + 0xFFFFFD24);
            *(_DWORD *)(v2 + 408) = v8 + 48;
            *(_DWORD *)(v2 + 404) = v103;
            *((_DWORD *)v8 + 22) = 2;
            if ( !*(_BYTE *)(v4 + 269) )
            {
              result = sub_6E4B8(v71, "Content-Length: %lld\r\n", *((_QWORD *)v8 + 1));
              if ( result )
                goto LABEL_347;
            }
            result = sub_6E860(v4, v2, v71);
            if ( result )
              goto LABEL_347;
            tp.tm_sec = 0;
            v104 = (const void *)Curl_formpostheader((_DWORD **)v8 + 12, &tp);
            if ( v104 )
            {
              result = sub_6E37C((int)v71, v104, tp.tm_sec);
              if ( result )
                goto LABEL_347;
              v51 = sub_6E37C((int)v71, "\r\n", 2);
              if ( v51 )
                goto LABEL_354;
              Curl_pgrsSetUploadSize(v4, v105, *((_QWORD *)v8 + 1));
              v51 = sub_6E5C4(v71, (_DWORD *)v2, (_DWORD *)(v4 + 34232), 0, 0);
              if ( v51 )
              {
                Curl_failf(v4, "Failed sending POST request");
              }
              else
              {
                v51 = Curl_setup_transfer((int *)v2, 0, -1LL, 1, (int)(v8 + 32), 0, (int)(v8 + 40));
                if ( !v51 )
                  goto LABEL_342;
              }
              Curl_formclean((_DWORD **)v8);
              goto LABEL_354;
            }
            v101 = v4;
            v102 = "Could not get Content-Type header line!";
          }
          Curl_failf(v101, v102);
          result = 34;
          goto LABEL_347;
        }
        v99 = sub_6E4B8(v71, "Content-Length: 0\r\n\r\n");
        if ( v99 )
        {
LABEL_346:
          result = v99;
          goto LABEL_347;
        }
        v51 = sub_6E5C4(v71, (_DWORD *)v2, (_DWORD *)(v4 + 34232), 0, 0);
        if ( !v51 )
        {
          result = Curl_setup_transfer((int *)v2, 0, -1LL, 1, (int)(v8 + 32), -1, 0);
          goto LABEL_341;
        }
        v52 = v4;
        v53 = "Failed sending POST request";
LABEL_333:
        Curl_failf(v52, v53);
        goto LABEL_354;
      }
    }
LABEL_347:
    v6 = (const char *)&_stack_chk_guard;
    if ( v139 != _stack_chk_guard )
    {
LABEL_348:
      if ( *(_BYTE *)(v4 + 651) )
        v120 = 97;
      else
        v120 = 105;
      curl_msnprintf((int)&v137, 8, ";type=%c", v120);
      continue;
    }
    return result;
  }
}
// E4496: using guessed type char byte_E4496;
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0006FFD8) --------------------------------------------------------
signed int __fastcall Curl_proxyCONNECT(int *a1, int a2, int a3, int a4)
{
  int v4; // r5
  int v5; // r4
  signed int v6; // r1
  int v7; // r0
  int v8; // r6
  void **v9; // r6
  const char *v10; // r7
  void (__fastcall *v11)(void *); // r3
  void *v12; // r0
  signed int v13; // r10
  const char *v14; // r10
  char *v15; // r9
  signed int result; // r0
  char *v17; // r11
  char *v18; // r3
  char *v19; // r2
  int v20; // r0
  unsigned int v21; // r8
  _BYTE *v22; // r11
  char *v23; // r7
  signed int v24; // r6
  signed int v25; // r2
  signed int v26; // r0
  int v27; // r0
  signed int v28; // r10
  int v29; // r10
  int v30; // r1
  int v31; // r3
  int v32; // r2
  char v33; // r11
  __int64 v34; // [sp+18h] [bp-A0h]
  size_t v35; // [sp+24h] [bp-94h]
  signed int v36; // [sp+28h] [bp-90h]
  signed int v37; // [sp+2Ch] [bp-8Ch]
  signed int v38; // [sp+30h] [bp-88h]
  _BYTE *v39; // [sp+34h] [bp-84h]
  int v40; // [sp+38h] [bp-80h]
  int v41; // [sp+40h] [bp-78h]
  int v42; // [sp+44h] [bp-74h]
  int v43; // [sp+48h] [bp-70h]
  int v44; // [sp+4Ch] [bp-6Ch]
  _BYTE *v45; // [sp+50h] [bp-68h]
  int v46; // [sp+54h] [bp-64h]
  char *v47; // [sp+5Ch] [bp-5Ch]
  int v48; // [sp+74h] [bp-44h]
  int v49; // [sp+78h] [bp-40h]
  int v50; // [sp+7Ch] [bp-3Ch]
  __time_t v51; // [sp+80h] [bp-38h]
  int v52; // [sp+84h] [bp-34h]
  __time_t v53; // [sp+88h] [bp-30h]
  int v54; // [sp+8Ch] [bp-2Ch]

  v4 = (int)a1;
  v5 = *a1;
  v46 = a2;
  v43 = a3;
  v6 = *(_DWORD *)(*a1 + 424);
  v44 = a4;
  if ( !v6 )
    v6 = 3600000;
  v48 = 0;
  v37 = 0;
  v42 = (int)&a1[v46];
  v7 = *(_DWORD *)(v42 + 212);
  *(_BYTE *)(v4 + 318) = 0;
  v36 = 0;
  v34 = 0LL;
  v38 = v6;
  v41 = v7;
  while ( 2 )
  {
    v8 = *(unsigned __int8 *)(v4 + 309);
    if ( !*(_BYTE *)(v4 + 309) )
    {
      Curl_infof(v5, "Establish HTTP proxy tunnel to %s:%d\n", v43, v44);
      if ( *(_DWORD *)(v5 + 256) )
      {
        ((void (*)(void))Curl_cfree)();
        *(_DWORD *)(v5 + 256) = v8;
      }
      v9 = (void **)Curl_ccalloc(12, 1);
      if ( !v9 )
        return 27;
      v10 = (const char *)curl_maprintf("%s:%d", v43, v44);
      if ( !v10 )
      {
        v11 = (void (__fastcall *)(void *))Curl_cfree;
        v12 = v9;
LABEL_17:
        v11(v12);
        return 27;
      }
      v13 = sub_6E8A8((int *)v4, (int)"CONNECT", v10, 1);
      if ( !v13 )
      {
        if ( *(_DWORD *)(v4 + 188) == 1 )
          v14 = "1.0";
        else
          v14 = "1.1";
        if ( sub_6E838(*(_BYTE ***)(v5 + 480), "Host:") )
        {
          v15 = &byte_E4496;
        }
        else
        {
          v15 = (char *)curl_maprintf("Host: %s\r\n", v10);
          if ( !v15 )
          {
            Curl_cfree(v9);
            v11 = (void (__fastcall *)(void *))Curl_cfree;
            v12 = (void *)v10;
            goto LABEL_17;
          }
        }
        if ( sub_6E838(*(_BYTE ***)(v5 + 480), "Proxy-Connection:") )
          v17 = &byte_E4496;
        else
          v17 = "Proxy-Connection: Keep-Alive\r\n";
        if ( sub_6E838(*(_BYTE ***)(v5 + 480), "User-Agent:") )
        {
          v18 = &byte_E4496;
        }
        else if ( *(_DWORD *)(v5 + 820) )
        {
          v18 = *(char **)(v4 + 336);
        }
        else
        {
          v18 = &byte_E4496;
        }
        v19 = *(char **)(v4 + 332);
        if ( !v19 )
          v19 = &byte_E4496;
        v13 = sub_6E4B8(v9, "CONNECT %s:%d HTTP/%s\r\n%s%s%s%s", v43, v44, v14, v15, v19, v18, v17);
        if ( *v15 )
          Curl_cfree(v15);
        if ( v13
          || (v13 = sub_6E50C(v4, v9)) != 0
          || (v13 = sub_6E4B8(v9, "\r\n")) != 0
          || (v13 = sub_6E5C4(v9, (_DWORD *)v4, (_DWORD *)(v5 + 34232), 0, v46), (v9 = (void **)v13) != 0) )
        {
          v9 = 0;
          Curl_failf(v5, "Failed sending CONNECT to proxy");
        }
      }
      Curl_cfree(v10);
      Curl_safefree((int)v9);
      if ( v13 )
        return v13;
      *(_BYTE *)(v4 + 309) = 1;
    }
    curlx_tvnow(&v51);
    if ( v38 - curlx_tvdiff(v51, v52, *(_DWORD *)(v4 + 196), *(_DWORD *)(v4 + 200)) <= 0 )
    {
      v20 = v5;
LABEL_62:
      Curl_failf(v20, "Proxy CONNECT aborted due to timeout");
      return 56;
    }
    if ( *(_DWORD *)(v5 + 1144) == 2 )
    {
      result = Curl_socket_ready(v41, -1, 0);
      if ( !result )
        return result;
    }
    *(_BYTE *)(v4 + 309) = 0;
    v21 = 0;
    v35 = 0;
    v22 = (_BYTE *)(v5 + 1172);
    v23 = (char *)(v5 + 1172);
    v24 = 1;
    while ( 1 )
    {
      curlx_tvnow(&v53);
      v25 = v38 - curlx_tvdiff(v53, v54, *(_DWORD *)(v4 + 196), *(_DWORD *)(v4 + 200));
      if ( v25 <= 0 )
      {
        v20 = v5;
        goto LABEL_62;
      }
      if ( v25 >= 1000 )
        v25 = 1000;
      v26 = Curl_socket_ready(v41, -1, v25);
      if ( v26 == -1 )
      {
        Curl_failf(v5, "Proxy CONNECT aborted due to select/poll error");
LABEL_65:
        v28 = 1;
        goto LABEL_56;
      }
      if ( !v26 )
        goto LABEL_117;
      v27 = Curl_read(v4, v41, v22, 0x4000 - v21, (int)&v49);
      v28 = v27;
      if ( v27 < 0 )
      {
        v28 = 0;
        goto LABEL_57;
      }
      if ( v27 )
      {
        v24 = 0;
        goto LABEL_117;
      }
      v40 = v49;
      if ( v49 <= 0 )
      {
        if ( *(_DWORD *)(v5 + 316) && *(_DWORD *)(v5 + 34092) )
        {
          v24 = 0;
          *(_BYTE *)(v4 + 318) = 1;
          goto LABEL_56;
        }
        v24 = 0;
        Curl_failf(v5, "Proxy CONNECT aborted");
        goto LABEL_65;
      }
      if ( v24 > 1 )
      {
        if ( v34 )
        {
          v22 = (_BYTE *)(v5 + 1172);
          v34 -= v49;
          if ( v34 < 1 )
            goto LABEL_119;
        }
        else
        {
          v50 = v27;
          if ( Curl_httpchunk_read((int *)v4, (const char *)(v5 + 1172), v49, &v50) == -1 )
          {
            v24 = v28;
            Curl_infof(v5, "chunk reading DONE\n");
          }
          else
          {
            Curl_infof(v5, "Read %d bytes of chunk, continue\n", v50);
          }
          v22 = (_BYTE *)(v5 + 1172);
        }
LABEL_75:
        v21 = 0;
        goto LABEL_121;
      }
      v45 = v22;
      v39 = v22;
      while ( 1 )
      {
        do
        {
          v22 = v39;
          v29 = v39 - v45;
          if ( v39 - v45 >= v49 )
          {
            v21 += v40;
            goto LABEL_117;
          }
          ++v39;
          ++v35;
        }
        while ( *v22 != 10 );
        if ( *(_BYTE *)(v5 + 672) )
          Curl_debug(v5, 1u, v23, v35, v4);
        if ( *(_BYTE *)(v5 + 659) )
          v30 = 3;
        else
          v30 = 2;
        result = Curl_client_write((int *)v4, v30, v23, v35);
        if ( result )
          return result;
        v31 = (unsigned __int8)*v23;
        if ( v31 == 13 || v31 == 10 )
          break;
        v33 = v23[v35];
        v23[v35] = 0;
        v47 = &v23[v35];
        if ( Curl_raw_nequal("WWW-Authenticate:", (int)v23, 17) && *(_DWORD *)(v5 + 144) == 401
          || Curl_raw_nequal("Proxy-authenticate:", (int)v23, 19) && *(_DWORD *)(v5 + 144) == 407 )
        {
          result = Curl_http_input_auth((int *)v4, *(_DWORD *)(v5 + 144), (int)v23);
          if ( result )
            return result;
        }
        else if ( Curl_raw_nequal("Content-Length:", (int)v23, 15) )
        {
          v34 = strtoll(v23 + 15, 0, 10);
        }
        else if ( Curl_compareheader(v23, "Connection:", "close") )
        {
          v36 = 1;
        }
        else if ( Curl_compareheader(v23, "Transfer-Encoding:", "chunked") )
        {
          Curl_infof(v5, "CONNECT responded chunked\n");
          Curl_httpchunk_init((_DWORD *)v4);
          v37 = 1;
        }
        else if ( Curl_compareheader(v23, "Proxy-Connection:", "close") )
        {
          v36 = 1;
        }
        else if ( sscanf(v23, "HTTP/1.%d %d", &v48, v5 + 144) == 2 )
        {
          *(_DWORD *)(v5 + 34212) = *(_DWORD *)(v5 + 144);
        }
        v23 = v39;
        v35 = 0;
        *v47 = v33;
      }
      if ( *(_DWORD *)(v5 + 144) != 407 )
        goto LABEL_118;
      v21 = *(unsigned __int8 *)(v5 + 34100);
      if ( *(_BYTE *)(v5 + 34100) )
        goto LABEL_118;
      if ( !v34 )
      {
        if ( !v37 )
        {
          v24 = 0;
          v22 = (_BYTE *)(v5 + 1172);
          v21 = 0;
          goto LABEL_121;
        }
        v32 = v49 - v29;
        *(_BYTE *)(v5 + 249) = 1;
        Curl_infof(v5, "%d bytes of chunk left\n", v32);
        if ( v23[1] == 10 )
        {
          ++v23;
          ++v29;
        }
        if ( Curl_httpchunk_read((int *)v4, v23 + 1, v49 - v29, &v49) == -1 )
        {
          Curl_infof(v5, "chunk reading DONE\n");
LABEL_118:
          v22 = (_BYTE *)(v5 + 1172);
LABEL_119:
          v24 = 0;
          v21 = 0;
LABEL_117:
          v28 = 0;
          goto LABEL_56;
        }
        v22 = (_BYTE *)(v5 + 1172);
        v24 = 2;
        Curl_infof(v5, "Read %d bytes of chunk, continue\n", v49);
        goto LABEL_75;
      }
      v22 = (_BYTE *)(v5 + 1172);
      Curl_infof(v5, "Ignore %lld bytes of response-body\n", v34);
      v34 -= v49 - v29;
      if ( v34 < 1 )
        goto LABEL_119;
      v24 = 2;
LABEL_121:
      v28 = v21;
LABEL_56:
      if ( Curl_pgrsUpdate((int *)v4) )
        return 42;
LABEL_57:
      if ( v21 >= 0x4000 || !v24 )
        break;
      if ( v28 )
        return 56;
    }
    if ( v28 )
      return 56;
    if ( *(_DWORD *)(v5 + 34212) != 200 )
    {
      result = Curl_http_auth_act((unsigned __int8 *)v4);
      if ( result )
        return result;
      if ( *(_BYTE *)(v4 + 296) )
        goto LABEL_144;
    }
    if ( v36 )
    {
LABEL_144:
      if ( *(_DWORD *)(v5 + 256) )
      {
        close(*(_DWORD *)(v42 + 212));
        v36 = 1;
        *(_DWORD *)(v42 + 212) = -1;
        break;
      }
      v36 = 1;
    }
    if ( *(_DWORD *)(v5 + 256) )
      continue;
    break;
  }
  if ( *(_DWORD *)(v5 + 144) != 200 )
  {
    Curl_failf(v5, "Received HTTP code %d from proxy after CONNECT");
    if ( v36 )
    {
      if ( *(_DWORD *)(v5 + 256) )
        *(_BYTE *)(v4 + 318) = 1;
    }
    return 56;
  }
  Curl_safefree(*(_DWORD *)(v4 + 332));
  *(_DWORD *)(v4 + 332) = 0;
  *(_BYTE *)(v5 + 34096) = 1;
  Curl_infof(v5, "Proxy replied OK to CONNECT request\n");
  *(_BYTE *)(v5 + 249) = 0;
  return 0;
}
// E4496: using guessed type char byte_E4496;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000706E8) --------------------------------------------------------
int __fastcall Curl_http_connect(int a1, _BYTE *a2)
{
  _BYTE *v2; // r5
  int v3; // r2
  int v4; // r4
  int v5; // r6
  int result; // r0

  v2 = a2;
  v3 = *(unsigned __int8 *)(a1 + 308);
  v4 = a1;
  v5 = *(_DWORD *)a1;
  *(_BYTE *)(a1 + 296) = 0;
  if ( !v3
    || !*(_BYTE *)(a1 + 299)
    || (result = Curl_proxyCONNECT((int *)a1, 0, *(_DWORD *)(a1 + 140), *(unsigned __int16 *)(a1 + 168))) == 0 )
  {
    if ( *(_BYTE *)(v4 + 309) )
    {
      result = 0;
    }
    else
    {
      result = *(_DWORD *)(v4 + 48) & 2;
      if ( result )
      {
        if ( *(_DWORD *)(v5 + 1144) == 2 )
          result = 7;
        else
          result = 2;
      }
      else
      {
        *v2 = 1;
      }
    }
  }
  return result;
}

//----- (00070740) --------------------------------------------------------
int __fastcall sub_70740(int a1, unsigned int a2, const void *a3, size_t a4)
{
  int v4; // r5
  int (__cdecl *v5)(int, unsigned int); // r4
  const void *v6; // r8
  size_t v7; // r7
  int v8; // ST00_4
  int result; // r0

  v4 = a1;
  v5 = *(int (__cdecl **)(int, unsigned int))(a1 + 376);
  v6 = a3;
  v7 = a4;
  if ( v5 )
  {
    v8 = *(_DWORD *)(a1 + 284);
    result = v5(a1, a2);
  }
  else
  {
    if ( a2 <= 2 )
    {
      fwrite(&asc_EBA95[3 * a2], 2u, 1u, *(FILE **)(a1 + 280));
      fwrite(v6, v7, 1u, *(FILE **)(v4 + 280));
    }
    result = 0;
  }
  return result;
}

//----- (00070790) --------------------------------------------------------
signed int __fastcall Curl_read_plain(int a1, void *a2, size_t a3, ssize_t *a4)
{
  ssize_t *v4; // r5
  ssize_t v5; // r0
  int v6; // r1
  int v7; // r2
  signed int v8; // r4
  int v9; // r0
  signed int result; // r0

  v4 = a4;
  v5 = recv(a1, a2, a3, 0);
  v8 = v5;
  if ( v5 == -1 )
  {
    v9 = *(_DWORD *)_errno(-1, v6, v7);
    if ( v9 == 11 )
    {
      result = v8;
    }
    else if ( v9 == 4 )
    {
      result = -1;
    }
    else
    {
      result = 56;
    }
  }
  else
  {
    *v4 = v5;
    result = 0;
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000707C0) --------------------------------------------------------
int __fastcall Curl_read(int a1, int a2, void *dest, size_t n, int a5)
{
  size_t v5; // r9
  int v6; // r4
  int v7; // r11
  char *v8; // r7
  int v9; // r0
  int v10; // r3
  _BOOL4 v11; // r3
  int v12; // r10
  int v13; // r2
  char *v14; // r1
  size_t v15; // r5
  int v16; // r3
  signed int v17; // r2
  int result; // r0
  size_t v19; // r5
  size_t na; // [sp+4h] [bp-2Ch]
  void *v21; // [sp+8h] [bp-28h]

  v21 = dest;
  v5 = n;
  na = 0;
  v6 = a1;
  v7 = a2;
  v8 = (char *)dest;
  v9 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  if ( v9 )
    LOBYTE(v9) = Curl_multi_canPipeline(v9);
  v10 = *(_DWORD *)(v6 + 216);
  *(_DWORD *)a5 = 0;
  v11 = (unsigned int)(v7 - v10) <= 0;
  v12 = v9 & 1;
  if ( v9 & 1 )
  {
    v13 = *(_DWORD *)(v6 + 388);
    v14 = *(char **)(v6 + 384);
    v15 = *(_DWORD *)(v6 + 392) - v13;
    if ( v5 < v15 )
      v15 = v5;
    if ( v15 )
    {
      memcpy(v8, &v14[v13], v15);
      v16 = *(_DWORD *)(v6 + 388);
      *(_BYTE *)(v6 + 317) = 0;
      *(_DWORD *)(v6 + 388) = v16 + v15;
LABEL_24:
      *(_DWORD *)a5 = v15;
      return 0;
    }
    if ( v5 >= 0x4000 )
      v17 = 0x4000;
    else
      v17 = v5;
  }
  else
  {
    v14 = v8;
    v17 = *(_DWORD *)(*(_DWORD *)v6 + 604);
    if ( !v17 )
      v17 = 0x4000;
    if ( v17 >= (signed int)v5 )
      v17 = v5;
  }
  if ( *(_DWORD *)(v6 + 8 * (v11 + 27) + 8) == 2 )
    return -1;
  if ( *(_DWORD *)(v6 + 364) )
  {
    na = -1;
  }
  else
  {
    result = Curl_read_plain(v7, v14, v17, (ssize_t *)&na);
    if ( result )
      return result;
  }
  v19 = na;
  if ( (na & 0x80000000) == 0 )
  {
    if ( v12 )
    {
      memcpy(v8, *(const void **)(v6 + 384), na);
      *(_DWORD *)(v6 + 392) = v19;
      *(_DWORD *)(v6 + 388) = v19;
    }
    v15 = v19 + *(_DWORD *)a5;
    goto LABEL_24;
  }
  return 0;
}

//----- (000708A4) --------------------------------------------------------
int __fastcall Curl_debug(int a1, unsigned int a2, const void *a3, size_t a4, int a5)
{
  const void *v5; // r9
  size_t v6; // r10
  int v7; // r6
  unsigned int v8; // r7
  int v9; // r3
  const char *v10; // r4
  const char *v11; // r5
  size_t v12; // r0
  int result; // r0
  char v14; // [sp+Ch] [bp-C4h]
  int v15; // [sp+ACh] [bp-24h]

  v5 = a3;
  v6 = a4;
  v7 = a1;
  v8 = a2;
  if ( *(_BYTE *)(a1 + 648) )
  {
    if ( a5 )
    {
      v9 = *(_DWORD *)(a5 + 144);
      if ( v9 )
      {
        switch ( a2 )
        {
          case 1u:
            goto LABEL_11;
          case 2u:
            v10 = "Header";
            v11 = "to";
            goto LABEL_8;
          case 3u:
            v10 = "Data";
            v11 = "from";
            goto LABEL_8;
          case 4u:
            v10 = "Data";
            v11 = "to";
            goto LABEL_8;
          default:
            break;
        }
      }
    }
  }
def_708DA:
  result = sub_70740(v7, v8, v5, v6);
  while ( 1 )
  {
    v9 = _stack_chk_guard;
    if ( v15 == _stack_chk_guard )
      return result;
LABEL_11:
    v10 = "Header";
    v11 = "from";
LABEL_8:
    curl_msnprintf((int)&v14, 160, "[%s %s %s]", v10, v11, v9);
    v12 = strlen(&v14);
    result = sub_70740(v7, 0, &v14, v12);
    if ( !result )
      goto def_708DA;
  }
}

//----- (00070978) --------------------------------------------------------
int Curl_infof(int result, char *a2, ...)
{
  int v2; // r5
  size_t v3; // r0
  char v4; // [sp+10h] [bp-828h]
  char *varg_r1; // [sp+82Ch] [bp-Ch]
  va_list varg_r2; // [sp+830h] [bp-8h]

  va_start(varg_r2, a2);
  varg_r1 = a2;
  v2 = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 672) )
    {
      curl_mvsnprintf(&v4, 2049, varg_r1, (int)varg_r2);
      v3 = strlen(&v4);
      result = Curl_debug(v2, 0, &v4, v3, 0);
    }
  }
  return result;
}

//----- (000709E0) --------------------------------------------------------
char *Curl_failf(int a1, char *a2, ...)
{
  const char *v2; // r5
  int v3; // r4
  char *result; // r0
  size_t v5; // r0
  size_t v6; // r3
  va_list varg_r2; // [sp+28h] [bp-8h]

  va_start(varg_r2, a2);
  v2 = (const char *)(a1 + 1172);
  v3 = a1;
  curl_mvsnprintf((_BYTE *)(a1 + 1172), 0x4000, a2, (int)varg_r2);
  result = *(char **)(v3 + 288);
  if ( result && !*(_BYTE *)(v3 + 33984) )
  {
    result = curl_msnprintf((int)result, 256, "%s", v2);
    *(_BYTE *)(v3 + 33984) = 1;
  }
  if ( *(_BYTE *)(v3 + 672) )
  {
    v5 = strlen(v2);
    v6 = v5;
    if ( v5 <= 0x3FFE )
    {
      v6 = v5 + 1;
      *(_BYTE *)(v3 + v5 + 1172) = 10;
      *(_BYTE *)(v3 + v5 + 1 + 1172) = 0;
    }
    result = (char *)Curl_debug(v3, 0, v2, v6, 0);
  }
  return result;
}

//----- (00070A64) --------------------------------------------------------
ssize_t __fastcall sub_70A64(int *a1, int a2, const void *a3, size_t a4)
{
  int *v4; // r5
  int v5; // r1
  int v6; // r2
  ssize_t v7; // r4
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r6
  int v12; // r0

  v4 = a1;
  v7 = send(a1[a2 + 53], a3, a4, 0x4000);
  if ( v7 == -1 )
  {
    v8 = *(_DWORD *)_errno(-1, v5, v6);
    if ( v8 == 11 || v8 == 4 )
    {
      v7 = 0;
    }
    else
    {
      v11 = *v4;
      v12 = Curl_strerror((int)v4, v8, v9, v10);
      Curl_failf(v11, "Send failure: %s", v12);
    }
  }
  return v7;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00070AB0) --------------------------------------------------------
signed int __fastcall Curl_write(int *a1, int a2, const void *a3, size_t a4, ssize_t *a5)
{
  int v5; // r5
  int v6; // r6
  signed int v7; // r1
  ssize_t v8; // r0
  signed int result; // r0

  v5 = a1[54];
  v6 = (unsigned int)(a2 - v5) <= 0;
  if ( a2 == v5 )
    v7 = 56;
  else
    v7 = 54;
  if ( a1[v7 + 2] == 2 || a1[91] )
    v8 = -1;
  else
    v8 = sub_70A64(a1, v6, a3, a4);
  *a5 = v8;
  if ( v8 == -1 )
    result = 55;
  else
    result = 0;
  return result;
}

//----- (00070AF4) --------------------------------------------------------
signed int __fastcall Curl_write_plain(int *a1, int a2, const void *a3, size_t a4, ssize_t *a5)
{
  ssize_t v5; // r0
  signed int result; // r0

  v5 = sub_70A64(a1, (unsigned int)(a2 - a1[54]) <= 0, a3, a4);
  *a5 = v5;
  if ( v5 == -1 )
    result = 55;
  else
    result = 0;
  return result;
}

//----- (00070B14) --------------------------------------------------------
signed int __fastcall Curl_client_write(int *a1, int a2, const char *a3, int a4)
{
  int *v4; // r7
  int v5; // r10
  char *v6; // r6
  int v7; // r5
  int v8; // r4
  int v9; // r5
  int v11; // r8
  char *v12; // r0
  char *v13; // r7
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r7
  int v16; // r11
  signed int v17; // r12
  const char *v18; // r3
  _BYTE *v19; // r2
  const char *v20; // ST08_4
  int v21; // r0
  unsigned __int8 v22; // r2
  int v23; // r2
  unsigned int v24; // r4
  int v25; // r3
  bool v26; // cf
  int v27; // r0
  void *v28; // r0
  void *v29; // r7
  _DWORD *v30; // r3
  int (__fastcall *v31)(char *, signed int, int, _DWORD); // r7
  int v32; // r0
  void *v33; // r0
  void *v34; // r7
  _DWORD *v35; // r3
  signed int v36; // [sp+4h] [bp-34h]

  v4 = a1;
  v5 = a2;
  v6 = (char *)a3;
  v7 = *a1;
  v8 = a4;
  if ( !a4 )
    v8 = strlen(a3);
  if ( *(_DWORD *)(v7 + 244) & 0x10 )
  {
    v9 = v7 + 33792;
    if ( v5 != *(_DWORD *)(v9 + 184) )
      return 56;
    v11 = v8 + *(_DWORD *)(v9 + 180);
    v12 = (char *)((void *(__cdecl *)(void *, size_t))Curl_crealloc)(*(void **)(v9 + 176), v8 + *(_DWORD *)(v9 + 180));
    v13 = v12;
    if ( v12 )
    {
      memcpy(&v12[*(_DWORD *)(v9 + 180)], v6, v8);
      *(_DWORD *)(v9 + 176) = v13;
      *(_DWORD *)(v9 + 180) = v11;
      return 0;
    }
    return 27;
  }
  if ( v5 & 1 )
  {
    if ( v4[12] & 4 && *((_BYTE *)v4 + 784) == 65 && v6 )
    {
      if ( !v8 )
        goto LABEL_41;
      if ( *(_BYTE *)(v7 + 34154) )
      {
        if ( *v6 == 10 )
        {
          memmove(v6, v6 + 1, --v8);
          ++*(_QWORD *)(v7 + 34160);
        }
        *(_BYTE *)(v7 + 34154) = 0;
      }
      v14 = (unsigned __int8 *)memchr(v6, 13, v8);
      v15 = v14;
      if ( v14 )
      {
        v16 = (int)(v14 + 1);
        v17 = 10;
        v18 = "\r\n";
        while ( 1 )
        {
          v19 = (_BYTE *)(v16 - 1);
          if ( v15 >= (unsigned __int8 *)&v6[v8 - 1] )
            break;
          v20 = v18;
          v36 = v17;
          v21 = memcmp(v15, v18, 2u);
          v18 = v20;
          v17 = v36;
          if ( v21 )
          {
            v23 = *v15;
            if ( v23 == 13 )
              *(_BYTE *)(v16 - 1) = v36;
            else
              *(_BYTE *)(v16 - 1) = v23;
          }
          else
          {
            v22 = (v15++)[1];
            *(_BYTE *)(v16 - 1) = v22;
            ++*(_QWORD *)(v7 + 34160);
          }
          ++v15;
          ++v16;
        }
        v24 = (unsigned int)&v6[v8];
        if ( (unsigned int)v15 < v24 )
        {
          v25 = *v15;
          if ( v25 == 13 )
          {
            *v19 = 10;
            *(_BYTE *)(v7 + 34154) = 1;
          }
          else
          {
            *v19 = v25;
          }
          v19 = (_BYTE *)v16;
        }
        v26 = (unsigned int)v19 >= v24;
        v8 = v19 - v6;
        if ( !v26 )
          *v19 = 0;
      }
    }
    if ( v8 )
    {
      v27 = (*(int (__fastcall **)(char *, signed int, int, _DWORD))(v7 + 360))(v6, 1, v8, *(_DWORD *)(v7 + 296));
      if ( v27 == 268435457 )
      {
        v28 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v8);
        v29 = v28;
        if ( v28 )
        {
          memcpy(v28, v6, v8);
          v30 = (_DWORD *)(v7 + 33792);
          v30[44] = v29;
          v30[45] = v8;
          v30[46] = v5;
LABEL_37:
          *(_DWORD *)(v7 + 244) |= 0x10u;
          return 0;
        }
        return 27;
      }
      if ( v27 != v8 )
      {
        Curl_failf(v7, "Failed writing body (%d != %d)", v27, v8);
        return 23;
      }
    }
  }
LABEL_41:
  if ( !(v5 & 2) )
    return 0;
  v31 = *(int (__fastcall **)(char *, signed int, int, _DWORD))(v7 + 364);
  if ( !v31 )
  {
    if ( !*(_DWORD *)(v7 + 304) )
      return 0;
    v31 = *(int (__fastcall **)(char *, signed int, int, _DWORD))(v7 + 360);
  }
  v32 = v31(v6, 1, v8, *(_DWORD *)(v7 + 304));
  if ( v32 != 268435457 )
  {
    if ( v32 == v8 )
      return 0;
    Curl_failf(v7, "Failed writing header");
    return 23;
  }
  v33 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v8);
  v34 = v33;
  if ( v33 )
  {
    memcpy(v33, v6, v8);
    v35 = (_DWORD *)(v7 + 33792);
    v35[44] = v34;
    v35[45] = v8;
    v35[46] = 2;
    goto LABEL_37;
  }
  return 27;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00070D64) --------------------------------------------------------
signed int Curl_sendf(int a1, int *a2, char *a3, ...)
{
  int *v3; // r6
  int v4; // r10
  int v5; // r9
  const char *v6; // r0
  const char *v7; // r11
  const char *v8; // r4
  size_t v9; // r5
  signed int v10; // r8
  size_t v12; // [sp+8h] [bp-38h]
  int **v13; // [sp+Ch] [bp-34h]
  va_list varg_r3; // [sp+3Ch] [bp-4h]

  va_start(varg_r3, a3);
  v3 = a2;
  v4 = a1;
  v5 = *a2;
  va_copy(v13, varg_r3);
  v6 = (const char *)curl_mvaprintf(a3, (int)varg_r3);
  v7 = v6;
  if ( !v6 )
    return 27;
  v8 = v6;
  v12 = 0;
  v9 = strlen(v6);
  while ( 1 )
  {
    v10 = Curl_write(v3, v4, v8, v9, (ssize_t *)&v12);
    if ( v10 )
      break;
    if ( *(_BYTE *)(v5 + 672) )
      Curl_debug(v5, 4u, v8, v12, (int)v3);
    if ( v12 == v9 )
      break;
    v9 -= v12;
    v8 += v12;
  }
  Curl_cfree(v7);
  return v10;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00070DE8) --------------------------------------------------------
signed int __fastcall sub_70DE8(int *a1, int a2)
{
  int *v2; // r4
  int v3; // r0
  int v4; // r5
  int v5; // r0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( v3 )
  {
    Curl_cfree(v3);
    *v2 = 0;
  }
  if ( !v4 )
    return 0;
  v5 = Curl_cstrdup(v4);
  if ( v5 )
  {
    *v2 = v5;
    return 0;
  }
  return 27;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00070E28) --------------------------------------------------------
int __fastcall sub_70E28(int a1)
{
  _DWORD *v1; // r3
  int v2; // r2
  int v3; // r0
  int v4; // r2
  int v5; // ST00_4
  int v6; // ST04_4

  v1 = (_DWORD *)a1;
  v2 = *(unsigned __int8 *)(a1 + 298);
  v3 = *(_DWORD *)a1;
  if ( v2 )
    v4 = v1[40];
  else
    v4 = v1[36];
  v5 = v1[41];
  v6 = v1[11];
  return Curl_infof(v3, "Connected to %s (%s) port %d (#%d)\n", v4);
}

//----- (00070E60) --------------------------------------------------------
signed int __fastcall sub_70E60(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  int v4; // r0
  int v5; // r3

  v2 = a1;
  v3 = a2;
  if ( *(_DWORD *)(a1 + 732) )
  {
    if ( *(_DWORD *)(a1 + 880) )
      Curl_cookie_loadfiles(a1);
    Curl_share_lock(v2, 2);
    if ( Curl_cookie_output(*(_DWORD *)(v2 + 884), *(const char **)(v2 + 732)) )
      Curl_infof(v2, "WARNING: failed to save cookies in %s\n", *(_DWORD *)(v2 + 732));
  }
  else
  {
    if ( a2 )
    {
      v4 = *(_DWORD *)(a1 + 880);
      if ( v4 )
        curl_slist_free_all(v4);
    }
    Curl_share_lock(v2, 2);
  }
  if ( v3 )
  {
    v5 = *(_DWORD *)(v2 + 16);
    if ( !v5 || *(_DWORD *)(v2 + 884) != *(_DWORD *)(v5 + 24) )
      Curl_cookie_cleanup(*(_DWORD *)(v2 + 884));
  }
  return Curl_share_unlock(v2, 2);
}

//----- (00070EDC) --------------------------------------------------------
int **__fastcall sub_70EDC(int **result)
{
  int v1; // r5
  int *i; // r4
  int v3; // r0
  int *v4; // r6

  v1 = (int)result;
  if ( result )
  {
    for ( i = *result; i; i = v4 )
    {
      v3 = *i;
      v4 = (int *)i[2];
      *(_BYTE *)(*i + 34153) = 1;
      Curl_multi_handlePipeBreak(v3);
      result = (int **)Curl_llist_remove(v1, i, 0);
    }
  }
  return result;
}

//----- (00070F08) --------------------------------------------------------
signed int __fastcall sub_70F08(const char *a1, char *a2)
{
  const char *v2; // r9
  const char *v3; // r5
  signed int result; // r0
  size_t v5; // r7
  char *v6; // r0
  size_t v7; // r8
  unsigned int i; // r4
  unsigned int j; // r6

  v2 = a1;
  v3 = a2;
  if ( !a2 )
    return 0;
  result = (unsigned __int8)*a2;
  if ( !*a2 )
    return result;
  if ( !Curl_raw_equal("*", a2) )
  {
    v5 = strlen(v3);
    v6 = strchr(v2, 58);
    if ( v6 )
      v7 = v6 - v2;
    else
      v7 = strlen(v2);
    for ( i = 0; i < v5; i = j + 1 )
    {
      do
      {
        if ( !strchr(", ", (unsigned __int8)v3[i]) )
          break;
        ++i;
      }
      while ( i < v5 );
      if ( i == v5 )
        break;
      for ( j = i; j < v5 && !strchr(", ", (unsigned __int8)v3[j]); ++j )
        ;
      if ( v3[i] == 46 )
        ++i;
      if ( j - i <= v7
        && Curl_raw_nequal(&v3[i], (int)&v2[v7 - j + i], j - i)
        && (j - i == v7 || v2[v7 - j - 1 + i] == 46) )
      {
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

//----- (00070FDC) --------------------------------------------------------
int __fastcall Curl_safefree(int result)
{
  if ( result )
    result = Curl_cfree(result);
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00070FF0) --------------------------------------------------------
int __fastcall sub_70FF0(int result)
{
  int *v1; // r4
  int v2; // r0
  int v3; // r0

  v1 = (int *)result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 216);
    if ( v2 != -1 )
      close(v2);
    v3 = v1[53];
    if ( v3 != -1 )
      close(v3);
    Curl_safefree(v1[43]);
    Curl_safefree(v1[44]);
    Curl_safefree(v1[45]);
    Curl_safefree(v1[46]);
    Curl_safefree(v1[83]);
    Curl_safefree(v1[84]);
    Curl_safefree(v1[86]);
    Curl_safefree(v1[85]);
    Curl_safefree(v1[87]);
    Curl_safefree(v1[88]);
    Curl_safefree(v1[89]);
    Curl_safefree(v1[90]);
    Curl_safefree(v1[181]);
    Curl_safefree(v1[33]);
    Curl_safefree(v1[37]);
    Curl_safefree(v1[96]);
    Curl_llist_destroy(v1[93], 0);
    Curl_llist_destroy(v1[94], 0);
    Curl_llist_destroy(v1[95], 0);
    Curl_safefree(v1[175]);
    Curl_safefree(v1[180]);
    Curl_free_ssl_config(v1 + 59);
    result = Curl_cfree(v1);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000710D8) --------------------------------------------------------
signed int __fastcall sub_710D8(const char *a1, int *a2, int *a3)
{
  int *v3; // r5
  int *v4; // r6
  const char *v5; // r4
  char *v7; // r0
  char *v8; // r7
  size_t v9; // r8
  _BYTE *v10; // r0
  _BYTE *v11; // r9
  int *v12; // r0
  int v13; // r1

  v3 = a2;
  v4 = a3;
  v5 = a1;
  if ( !a1 )
  {
    Curl_safefree(*a2);
    *v3 = (int)v5;
    Curl_safefree(*v4);
    *v4 = (int)v5;
    return (signed int)v5;
  }
  v7 = strchr(a1, 58);
  v8 = v7;
  if ( !v7 )
  {
    v12 = v3;
    v13 = (int)v5;
    return sub_70DE8(v12, v13);
  }
  v9 = v7 - v5;
  v10 = (_BYTE *)Curl_cmalloc(v7 - v5 + 1);
  v11 = v10;
  if ( v10 )
  {
    memcpy(v10, v5, v9);
    v11[v9] = 0;
    Curl_safefree(*v3);
    *v3 = (int)v11;
    v12 = v4;
    v13 = (int)(v8 + 1);
    return sub_70DE8(v12, v13);
  }
  return 27;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00071150) --------------------------------------------------------
int __fastcall Curl_freeset(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r3
  int result; // r0

  v1 = a1;
  v2 = 0;
  do
  {
    v3 = v1 + v2;
    v2 += 4;
    result = Curl_safefree(*(_DWORD *)(v3 + 720));
  }
  while ( v2 != 132 );
  return result;
}

//----- (00071168) --------------------------------------------------------
signed int __fastcall Curl_dupset(int a1, int a2)
{
  char *v2; // r6
  int v3; // r5
  int v4; // r4
  signed int result; // r0

  v2 = (char *)(a1 + 720);
  v3 = a2;
  v4 = 0;
  memcpy((void *)(a1 + 280), (const void *)(a2 + 280), 0x248u);
  memset(v2, 0, 0x84u);
  do
  {
    result = sub_70DE8((int *)&v2[v4], *(_DWORD *)(v3 + v4 + 720));
    if ( result )
      break;
    v4 += 4;
  }
  while ( v4 != 132 );
  return result;
}

//----- (000711A4) --------------------------------------------------------
int *__fastcall Curl_mk_connc(int a1, signed int a2)
{
  signed int v2; // r4
  int *v3; // r5
  int v4; // r6

  v2 = a2;
  if ( a1 )
  {
    if ( a2 <= 0 )
    {
      v2 = 10;
      goto LABEL_7;
    }
  }
  else if ( a2 <= 0 )
  {
    v2 = 5;
    goto LABEL_7;
  }
  if ( a2 >= 0x1FFFFFFF )
    v2 = 0x1FFFFFFF;
LABEL_7:
  v3 = (int *)Curl_ccalloc(1, 12);
  if ( v3 )
  {
    v4 = Curl_ccalloc(v2, 4);
    *v3 = v4;
    if ( !v4 )
    {
      Curl_cfree(v3);
      return 0;
    }
    v3[1] = v2;
  }
  return v3;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00071204) --------------------------------------------------------
int __fastcall Curl_rm_connc(void *ptr)
{
  _DWORD *v1; // r4
  int v2; // r5
  int v3; // r0

  v1 = ptr;
  if ( *(_DWORD *)ptr )
  {
    v2 = 0;
    while ( v2 < v1[1] )
    {
      v3 = *(_DWORD *)(*v1 + 4 * v2++);
      sub_70FF0(v3);
    }
    Curl_cfree(*v1);
  }
  return Curl_cfree(v1);
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00071244) --------------------------------------------------------
int __fastcall Curl_init_userdefined(_DWORD *a1)
{
  _DWORD *v1; // r1
  int result; // r0

  v1 = a1;
  a1[5] = &_sF;
  *a1 = (char *)&_sF + 168;
  a1[4] = (char *)&_sF + 84;
  a1[20] = &fwrite;
  a1[22] = &fread;
  result = 0;
  v1[80] = 60;
  *((_QWORD *)v1 + 20) = -1LL;
  *((_QWORD *)v1 + 8) = -1LL;
  v1[62] = 1;
  *((_BYTE *)v1 + 396) = 1;
  *((_BYTE *)v1 + 397) = 1;
  v1[88] = 1;
  v1[75] = 5;
  v1[8] = 1;
  v1[3] = 1080;
  v1[9] = 1;
  *((_BYTE *)v1 + 375) = 1;
  v1[66] = 1;
  *((_BYTE *)v1 + 312) = 1;
  v1[14] = 0;
  v1[107] = 420;
  v1[30] = 0;
  v1[31] = 0;
  v1[32] = 0;
  v1[33] = 0;
  v1[11] = -1;
  v1[79] = 0;
  v1[67] = 2;
  v1[105] = -1;
  v1[108] = 493;
  v1[144] = 0xFFFF;
  v1[145] = 64495;
  return result;
}

//----- (00071300) --------------------------------------------------------
signed int __fastcall Curl_open(int *a1)
{
  int *v1; // r8
  int v2; // r0
  int v3; // r4
  int v5; // r7
  signed int v6; // r6
  void *v7; // r0
  int v8; // r0
  signed int v9; // r6
  void *v10; // r0

  v1 = a1;
  v2 = Curl_ccalloc(1, 34320);
  v3 = v2;
  if ( !v2 )
    return 27;
  v5 = v2 + 34048;
  *(_DWORD *)(v2 + 34312) = -1059136595;
  v6 = ares_init((_DWORD *)(v2 + 34104));
  if ( !v6 )
  {
    v7 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(0x100u);
    *(_DWORD *)(v3 + 1164) = v7;
    if ( v7 )
    {
      Curl_easy_initHandleData(v3);
      v8 = Curl_init_userdefined((_DWORD *)(v3 + 280));
      *(_DWORD *)(v3 + 1168) = 256;
      *(_DWORD *)(v3 + 1160) = -1;
      *(_DWORD *)(v3 + 944) |= 0x10u;
      *(_QWORD *)(v3 + 33944) = -1LL;
      v9 = v8;
      if ( !v8 )
      {
        *v1 = v3;
        return v9;
      }
    }
    else
    {
      v9 = 27;
    }
    ares_destroy(*(_DWORD *)(v5 + 56));
    v10 = *(void **)(v3 + 1164);
    if ( v10 )
      ((void (__cdecl *)(void *))Curl_cfree)(v10);
    Curl_freeset(v3);
    ((void (__cdecl *)(void *))Curl_cfree)((void *)v3);
    return v9;
  }
  ((void (__cdecl *)(void *))Curl_cfree)((void *)v3);
  if ( v6 == 15 )
    return 27;
  return 2;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000713E4) --------------------------------------------------------
int __fastcall Curl_isPipeliningEnabled(int a1)
{
  int result; // r0

  result = *(_DWORD *)(a1 + 8);
  if ( result )
    result = Curl_multi_canPipeline(result);
  return result;
}

//----- (000713F0) --------------------------------------------------------
int __fastcall Curl_disconnect(int **a1)
{
  int v1; // r4
  int *v2; // r5
  time_t v3; // r1
  int v4; // r2
  time_t v5; // r3
  int v6; // r3
  int v7; // r0
  void (__fastcall *v8)(int); // r3
  _DWORD *v9; // r3

  v1 = (int)a1;
  if ( !a1 )
    return 0;
  v2 = *a1;
  if ( !*a1 )
    return 0;
  Curl_expire(*a1, 0);
  Curl_hostcache_prune(v2, v3, v4, v5);
  v6 = *(_DWORD *)(v1 + 428);
  if ( !*(_DWORD *)(v1 + 412) )
  {
    if ( !v6 )
      goto LABEL_7;
    goto LABEL_5;
  }
  *((_BYTE *)v2 + 34080) = 0;
  v2[8518] = v2[8517];
  if ( v6 )
  {
LABEL_5:
    *((_BYTE *)v2 + 34096) = 0;
    v2[8522] = v2[8521];
  }
  *((_BYTE *)v2 + 34100) = 0;
LABEL_7:
  v7 = v2[64];
  if ( v7 )
  {
    Curl_cfree(v7);
    v2[64] = 0;
  }
  v8 = *(void (__fastcall **)(int))(*(_DWORD *)(v1 + 320) + 44);
  if ( v8 )
    v8(v1);
  if ( *(_DWORD *)(v1 + 44) != -1 )
  {
    Curl_infof((int)v2, "Closing connection #%ld\n");
    v9 = (_DWORD *)v2[287];
    if ( v9 )
      *(_DWORD *)(*v9 + 4 * *(_DWORD *)(v1 + 44)) = 0;
  }
  if ( Curl_isPipeliningEnabled((int)v2) )
  {
    sub_70EDC(*(int ***)(v1 + 372));
    sub_70EDC(*(int ***)(v1 + 376));
    sub_70EDC(*(int ***)(v1 + 380));
  }
  sub_70FF0(v1);
  v2[8551] = 0;
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000714BC) --------------------------------------------------------
signed int __fastcall sub_714BC(int a1, int a2)
{
  int *v2; // r6
  signed int v3; // r4
  signed int v4; // r8
  signed int i; // r5
  _DWORD *v6; // r3
  int v7; // r3
  int v8; // r0
  int **v9; // r0
  int v11; // [sp+0h] [bp-20h]
  int v12; // [sp+4h] [bp-1Ch]

  v11 = a1;
  v12 = a2;
  v2 = (int *)a1;
  v3 = -1;
  curlx_tvnow(&v11);
  v4 = -1;
  for ( i = 0; ; ++i )
  {
    v6 = (_DWORD *)v2[287];
    if ( !v6 || i >= v6[1] )
      break;
    v7 = *(_DWORD *)(*v6 + 4 * i);
    if ( v7 && !*(_BYTE *)(v7 + 40) )
    {
      v8 = curlx_tvdiff(v11, v12, *(_DWORD *)(v7 + 196), *(_DWORD *)(v7 + 200));
      if ( v8 > v4 )
      {
        v3 = i;
        v4 = v8;
      }
    }
  }
  if ( v3 >= 0 )
  {
    v9 = *(int ***)(*v6 + 4 * v3);
    *v9 = v2;
    Curl_disconnect(v9);
    *(_DWORD *)(*(_DWORD *)v2[287] + 4 * v3) = 0;
  }
  return v3;
}

//----- (00071528) --------------------------------------------------------
int __fastcall Curl_close(int a1, int a2)
{
  int v2; // r4
  int v3; // r3

  v2 = a1;
  if ( *(_DWORD *)(a1 + 8) )
    Curl_multi_rmeasy();
  *(_DWORD *)(v2 + 34312) = 0;
  v3 = *(_DWORD *)(v2 + 1148);
  if ( v3 && !*(_DWORD *)(v3 + 8) )
  {
    while ( sub_714BC(v2, a2) != -1 )
      ;
    Curl_rm_connc(*(void **)(v2 + 1148));
  }
  if ( *(_DWORD *)(v2 + 34168) )
  {
    *(_BYTE *)(v2 + 34172) = 1;
  }
  else
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
    {
      Curl_hash_destroy(*(_DWORD **)v2);
      *(_DWORD *)(v2 + 4) = 0;
      *(_DWORD *)v2 = 0;
    }
    if ( *(_BYTE *)(v2 + 34185) )
      Curl_cfree(*(_DWORD *)(v2 + 34188));
    Curl_safefree(*(_DWORD *)(v2 + 34176));
    Curl_safefree(*(_DWORD *)(v2 + 34200));
    Curl_safefree(*(_DWORD *)(v2 + 33956));
    Curl_safefree(*(_DWORD *)(v2 + 33980));
    if ( *(_BYTE *)(v2 + 876) )
      Curl_cfree(*(_DWORD *)(v2 + 872));
    if ( *(_BYTE *)(v2 + 868) )
      Curl_cfree(*(_DWORD *)(v2 + 864));
    Curl_safefree(*(_DWORD *)(v2 + 1164));
    sub_70E60(v2, 1);
    Curl_digest_cleanup(v2);
    Curl_safefree(*(_DWORD *)(v2 + 34248));
    Curl_safefree(*(_DWORD *)(v2 + 34252));
    ares_destroy(*(_DWORD *)(v2 + 34104));
    if ( *(_DWORD *)(v2 + 16) )
    {
      Curl_share_lock(v2, 1);
      --*(_DWORD *)(*(_DWORD *)(v2 + 16) + 4);
      Curl_share_unlock(v2, 1);
    }
    Curl_freeset(v2);
    Curl_cfree(v2);
  }
  return 0;
}
// 69F28: using guessed type int Curl_multi_rmeasy(void);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007162C) --------------------------------------------------------
signed int __fastcall Curl_ch_connc(int a1, _DWORD *a2, signed int a3)
{
  int v3; // r6
  signed int v4; // r5
  _DWORD *v5; // r4
  int *v6; // r0
  int v8; // r8
  signed int v9; // r7
  int **v10; // r0
  int v11; // r0
  signed int i; // r3

  v3 = a1;
  if ( a3 < 1 )
    v4 = 1;
  else
    v4 = a3;
  v5 = a2;
  if ( a2 )
  {
    if ( v4 < a2[1] )
    {
      v8 = 4 * v4;
      v9 = v4;
      while ( v9 < v5[1] )
      {
        ++v9;
        v10 = *(int ***)(*v5 + v8);
        v8 += 4;
        Curl_disconnect(v10);
      }
      if ( *(_DWORD *)(v3 + 1160) <= v4 )
        *(_DWORD *)(v3 + 1160) = -1;
    }
    if ( v4 >= 0x1FFFFFFF )
      v4 = 0x1FFFFFFF;
    v11 = Curl_crealloc(*v5, 4 * v4);
    if ( !v11 )
      return 27;
    for ( i = v5[1]; i < v4; ++i )
      *(_DWORD *)(v11 + 4 * i) = 0;
    *v5 = v11;
    v5[1] = v4;
  }
  else
  {
    v6 = Curl_mk_connc(0, v4);
    *(_DWORD *)(v3 + 1148) = v6;
    if ( !v6 )
      return 27;
  }
  return 0;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);

//----- (000716C4) --------------------------------------------------------
signed int __fastcall Curl_setopt(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int *v4; // r4
  signed int result; // r0
  int v6; // r3
  int v7; // r3
  int v8; // r3
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // r3
  unsigned int v17; // r3
  int *v18; // r0
  _QWORD *v19; // r6
  _QWORD *v20; // r6
  _QWORD *v21; // r6
  int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r3
  unsigned int v26; // r3
  int v27; // r3
  int v28; // r3
  int v29; // r3
  int v30; // r3
  const char *v31; // r1
  int v32; // r3
  const void *v33; // r9
  __int64 v34; // r4
  __int64 *v35; // r8
  bool v36; // zf
  bool v37; // cf
  __int64 v38; // r0
  void *v39; // r0
  void *v40; // r4
  int v41; // r4
  _QWORD *v42; // r7
  _QWORD *v43; // r7
  __int64 v44; // r4
  int *v45; // r0
  signed int v46; // r4
  int v47; // r3
  unsigned __int8 *v48; // r4
  int v49; // r0
  int v50; // r4
  unsigned int v51; // r3
  int v52; // r2
  unsigned int v53; // r3
  unsigned int v54; // r3
  int v55; // r2
  unsigned int v56; // r3
  int v57; // r3
  int v58; // r3
  int v59; // r3
  _QWORD *v60; // r6
  _QWORD *v61; // r6
  const char *v62; // r0
  int *v63; // r1
  int *v64; // r2
  _QWORD *v65; // r6
  _QWORD *v66; // r6
  int v67; // r3
  int v68; // r3
  int v69; // r4
  int v70; // r3
  int v71; // r0
  _QWORD *v72; // r6
  int v73; // r3
  int v74; // r3
  int v75; // r3
  int v76; // r3

  v3 = a1;
  v4 = a3;
  if ( a2 == 10001 )
  {
    *(_DWORD *)(a1 + 296) = *a3;
    return 0;
  }
  if ( a2 > 0x2711 )
  {
    if ( a2 == 10097 )
    {
      v18 = (int *)(a1 + 800);
    }
    else
    {
      if ( a2 <= 0x2771 )
      {
        if ( a2 != 10031 )
        {
          if ( a2 > 0x272F )
          {
            if ( a2 == 10076 )
            {
              v18 = (int *)(a1 + 816);
            }
            else if ( a2 > 0x275C )
            {
              if ( a2 == 10087 )
              {
                v18 = (int *)(a1 + 760);
              }
              else if ( a2 > 0x2767 )
              {
                if ( a2 == 10089 )
                {
                  if ( *a3 && *(_BYTE *)*a3 )
                    return 2;
                  return 0;
                }
                if ( a2 >= 0x2769 )
                {
                  if ( a2 == 10093 )
                  {
                    *(_DWORD *)(a1 + 500) = *a3;
                    return 0;
                  }
                  if ( a2 == 10095 )
                  {
                    *(_DWORD *)(a1 + 284) = *a3;
                    return 0;
                  }
                  return 2;
                }
                v18 = (int *)(a1 + 768);
              }
              else
              {
                if ( a2 == 10082 )
                {
                  v46 = sub_70DE8((int *)(a1 + 732), *a3);
                  *(_DWORD *)(v3 + 884) = Curl_cookie_init(v3, 0, *(_DWORD **)(v3 + 884), *(_BYTE *)(v3 + 488));
                  return v46;
                }
                if ( a2 > 0x2762 )
                {
                  if ( a2 == 10083 )
                  {
                    v18 = (int *)(a1 + 808);
                  }
                  else
                  {
                    if ( a2 != 10086 )
                      return 2;
                    v18 = (int *)(a1 + 724);
                  }
                }
                else
                {
                  if ( a2 != 10077 )
                    return 2;
                  v18 = (int *)(a1 + 812);
                }
              }
            }
            else
            {
              if ( a2 == 10057 )
              {
                *(_DWORD *)(a1 + 416) = *a3;
                return 0;
              }
              if ( a2 > 0x2749 )
              {
                if ( a2 == 10063 )
                {
                  result = sub_70DE8((int *)(a1 + 772), *a3);
                  v68 = *(_DWORD *)(v3 + 772);
                  if ( v68 )
                    LOBYTE(v68) = 1;
                  *(_BYTE *)(v3 + 673) = v68;
                  return result;
                }
                if ( a2 > 0x274F )
                {
                  if ( a2 != 10065 )
                  {
                    if ( a2 == 10070 )
                    {
                      *(_DWORD *)(a1 + 516) = *a3;
                      return 0;
                    }
                    return 2;
                  }
                  v18 = (int *)(a1 + 804);
                }
                else
                {
                  if ( a2 != 10062 )
                    return 2;
                  v18 = (int *)(a1 + 740);
                }
              }
              else
              {
                if ( a2 == 10037 )
                {
                  result = *a3;
                  *(_DWORD *)(v3 + 280) = *a3;
                  if ( !result )
                  {
                    *(_DWORD *)(v3 + 280) = (char *)&_sF + 168;
                    return result;
                  }
                  return 0;
                }
                if ( a2 == 10039 )
                {
                  *(_DWORD *)(a1 + 496) = *a3;
                  return 0;
                }
                if ( a2 != 10036 )
                  return 2;
                v18 = (int *)(a1 + 736);
              }
            }
          }
          else
          {
            if ( a2 == 10016 )
            {
              if ( *(_BYTE *)(a1 + 876) )
              {
                Curl_cfree(*(_DWORD *)(a1 + 872));
                *(_BYTE *)(v3 + 876) = 0;
              }
              result = sub_70DE8((int *)(v3 + 792), *v4);
              *(_DWORD *)(v3 + 872) = *(_DWORD *)(v3 + 792);
              return result;
            }
            if ( a2 > 0x2720 )
            {
              if ( a2 == 10024 )
              {
                *(_DWORD *)(a1 + 484) = *a3;
                *(_DWORD *)(a1 + 528) = 3;
                result = 0;
                *(_BYTE *)(v3 + 662) = 0;
                return result;
              }
              if ( a2 > 0x2728 )
              {
                if ( a2 == 10026 )
                {
                  v18 = (int *)(a1 + 764);
                }
                else
                {
                  if ( a2 >= 0x272A )
                  {
                    if ( a2 == 10028 )
                    {
                      *(_DWORD *)(a1 + 492) = *a3;
                      return 0;
                    }
                    if ( a2 == 10029 )
                    {
                      *(_DWORD *)(a1 + 304) = *a3;
                      return 0;
                    }
                    return 2;
                  }
                  v18 = (int *)(a1 + 720);
                }
              }
              else if ( a2 == 10018 )
              {
                v18 = (int *)(a1 + 820);
              }
              else
              {
                if ( a2 < 0x2722 )
                {
                  result = sub_70DE8((int *)(a1 + 756), *a3);
                  v57 = *(_DWORD *)(v3 + 756);
                  if ( v57 )
                    LOBYTE(v57) = 1;
                  *(_BYTE *)(v3 + 654) = v57;
                  return result;
                }
                if ( a2 != 10022 )
                {
                  if ( a2 == 10023 )
                  {
                    *(_DWORD *)(a1 + 480) = *a3;
                    return 0;
                  }
                  return 2;
                }
                v18 = (int *)(a1 + 728);
              }
            }
            else
            {
              if ( a2 == 10006 )
              {
                v62 = (const char *)*a3;
                v63 = (int *)(v3 + 840);
                v64 = (int *)(v3 + 844);
                return sub_710D8(v62, v63, v64);
              }
              if ( a2 > 0x2716 )
              {
                if ( a2 == 10009 )
                {
                  *(_DWORD *)(a1 + 300) = *a3;
                  return 0;
                }
                if ( a2 > 0x2719 )
                {
                  if ( a2 == 10010 )
                  {
                    *(_DWORD *)(a1 + 288) = *a3;
                    return 0;
                  }
                  if ( a2 == 10015 )
                  {
                    *(_DWORD *)(a1 + 332) = *a3;
                    sub_70DE8((int *)(a1 + 780), 0);
                    result = 0;
                    *(_DWORD *)(v3 + 528) = 2;
                    return result;
                  }
                  return 2;
                }
                if ( a2 != 10007 )
                  return 2;
                v18 = (int *)(a1 + 788);
              }
              else
              {
                if ( a2 != 10004 )
                {
                  if ( a2 <= 0x2714 )
                  {
                    if ( a2 == 10002 )
                    {
                      if ( *(_BYTE *)(a1 + 868) )
                      {
                        Curl_cfree(*(_DWORD *)(a1 + 864));
                        *(_BYTE *)(v3 + 868) = 0;
                      }
                      result = sub_70DE8((int *)(v3 + 796), *v4);
                      *(_DWORD *)(v3 + 864) = *(_DWORD *)(v3 + 796);
                      return result;
                    }
                    return 2;
                  }
                  v62 = (const char *)*a3;
                  v63 = (int *)(v3 + 832);
                  v64 = (int *)(v3 + 836);
                  return sub_710D8(v62, v63, v64);
                }
                v18 = (int *)(a1 + 784);
              }
            }
          }
          goto LABEL_507;
        }
        if ( !*a3 )
          return 0;
        v45 = curl_slist_append(*(_DWORD *)(a1 + 880), *a3);
        if ( v45 )
        {
          *(_DWORD *)(v3 + 880) = v45;
          return 0;
        }
        return 27;
      }
      if ( a2 == 10176 )
      {
        v18 = (int *)(a1 + 844);
      }
      else if ( a2 > 0x27C0 )
      {
        if ( a2 == 20144 )
        {
          *(_DWORD *)(a1 + 412) = *a3;
          return 0;
        }
        if ( a2 > 0x4EB0 )
        {
          if ( a2 == 30116 )
          {
            v66 = (_QWORD *)(a1 + 472);
            result = 0;
            *v66 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
            return result;
          }
          if ( a2 <= 0x75A4 )
          {
            if ( a2 == 20163 )
            {
              *(_DWORD *)(a1 + 392) = *a3;
              return 0;
            }
            if ( a2 > 0x4EC3 )
            {
              if ( a2 == 20167 )
              {
                *(_DWORD *)(a1 + 336) = *a3;
                return 0;
              }
              if ( a2 == 30115 )
              {
                v19 = (_QWORD *)(a1 + 440);
                result = 0;
                *v19 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
                return result;
              }
            }
            else if ( a2 == 20148 )
            {
              *(_DWORD *)(a1 + 384) = *a3;
              return 0;
            }
            return 2;
          }
          if ( a2 != 30120 )
          {
            if ( a2 > 0x75A8 )
            {
              if ( a2 == 30145 )
              {
                v61 = (_QWORD *)(a1 + 456);
                result = 0;
                *v61 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
                return result;
              }
              if ( a2 == 30146 )
              {
                v21 = (_QWORD *)(a1 + 464);
                result = 0;
                *v21 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
                return result;
              }
            }
            else if ( a2 == 30117 )
            {
              v20 = (_QWORD *)(a1 + 624);
              result = 0;
              *v20 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
              return result;
            }
            return 2;
          }
          v43 = (_QWORD *)(a1 + 344);
          v44 = *(_QWORD *)(((unsigned int)a3 + 7) & 0xFFFFFFF8);
          if ( *(_QWORD *)(a1 + 344) < v44 && *(_DWORD *)(a1 + 332) == *(_DWORD *)(a1 + 780) )
          {
            sub_70DE8((int *)(a1 + 780), 0);
            *(_DWORD *)(v3 + 332) = 0;
          }
          *v43 = v44;
          return 0;
        }
        if ( a2 == 20079 )
        {
          *(_DWORD *)(a1 + 364) = *a3;
          return 0;
        }
        if ( a2 > 0x4E6F )
        {
          if ( a2 == 20130 )
          {
            *(_DWORD *)(a1 + 380) = *a3;
            return 0;
          }
          if ( a2 > 0x4EA2 )
          {
            if ( a2 == 20142 )
            {
              *(_DWORD *)(a1 + 404) = *a3;
              return 0;
            }
            if ( a2 == 20143 )
            {
              *(_DWORD *)(a1 + 408) = *a3;
              return 0;
            }
          }
          else if ( a2 == 20094 )
          {
            *(_DWORD *)(a1 + 376) = *a3;
            return 0;
          }
          return 2;
        }
        if ( a2 == 20011 )
        {
          result = *a3;
          *(_DWORD *)(v3 + 360) = *a3;
          if ( !result )
          {
            *(_DWORD *)(v3 + 360) = &fwrite;
            return result;
          }
          return 0;
        }
        if ( a2 > 0x4E2B )
        {
          if ( a2 != 20012 )
          {
            if ( a2 == 20056 )
            {
              result = *a3;
              *(_DWORD *)(v3 + 372) = *a3;
              if ( result )
              {
                result = 0;
                *(_BYTE *)(v3 + 936) = 1;
              }
              else
              {
                *(_BYTE *)(v3 + 936) = 0;
              }
              return result;
            }
            return 2;
          }
          result = *a3;
          *(_DWORD *)(v3 + 368) = *a3;
          if ( !result )
          {
            *(_DWORD *)(v3 + 368) = &fread;
            return result;
          }
          return 0;
        }
        if ( a2 != 10177 )
          return 2;
        v18 = (int *)(a1 + 848);
      }
      else if ( a2 == 10147 )
      {
        v18 = (int *)(a1 + 752);
      }
      else if ( a2 > 0x27A3 )
      {
        if ( a2 == 10169 )
        {
          v18 = (int *)(a1 + 824);
        }
        else
        {
          if ( a2 <= 0x27B9 )
          {
            if ( a2 == 10164 )
            {
              *(_DWORD *)(a1 + 396) = *a3;
              return 0;
            }
            if ( a2 <= 0x27B4 )
            {
              if ( a2 == 10149 )
              {
                *(_DWORD *)(a1 + 388) = *a3;
                return 0;
              }
              return 2;
            }
            if ( a2 != 10165 )
            {
              if ( a2 == 10168 )
              {
                *(_DWORD *)(a1 + 400) = *a3;
                return 0;
              }
              return 2;
            }
            v33 = (const void *)*a3;
            if ( !*a3 )
              goto LABEL_524;
            v35 = (__int64 *)(a1 + 344);
            v34 = *(_QWORD *)(a1 + 344);
            v36 = HIDWORD(v34) == -1;
            if ( HIDWORD(v34) == -1 )
              v36 = (_DWORD)v34 == -1;
            if ( v36 )
            {
LABEL_524:
              result = sub_70DE8((int *)(a1 + 780), *a3);
            }
            else
            {
              v37 = HIDWORD(v34) >= 1;
              if ( HIDWORD(v34) == 1 )
                v37 = 1;
              if ( v37 )
                goto LABEL_525;
              sub_70DE8((int *)(a1 + 780), 0);
              v38 = *v35;
              if ( !*v35 )
                LODWORD(v38) = 1;
              v39 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v38);
              v40 = v39;
              if ( !v39 )
              {
LABEL_525:
                result = 27;
              }
              else
              {
                if ( *v35 )
                  memcpy(v39, v33, *v35);
                result = 0;
                *(_DWORD *)(v3 + 780) = v40;
              }
            }
            *(_DWORD *)(v3 + 332) = *(_DWORD *)(v3 + 780);
            *(_DWORD *)(v3 + 528) = 2;
            return result;
          }
          if ( a2 == 10173 )
          {
            v18 = (int *)(a1 + 832);
          }
          else if ( a2 > 0x27BD )
          {
            if ( a2 == 10174 )
            {
              v18 = (int *)(a1 + 836);
            }
            else
            {
              if ( a2 != 10175 )
                return 2;
              v18 = (int *)(a1 + 840);
            }
          }
          else
          {
            if ( a2 != 10170 )
              return 2;
            v18 = (int *)(a1 + 828);
          }
        }
      }
      else
      {
        if ( a2 == 10104 )
        {
          *(_DWORD *)(a1 + 616) = *a3;
          return 0;
        }
        if ( a2 <= 0x2778 )
        {
          if ( a2 != 10102 )
          {
            if ( a2 > 0x2776 )
            {
              *(_DWORD *)(a1 + 608) = *a3;
              return 0;
            }
            if ( a2 != 10100 )
              return 2;
            v69 = *a3;
            if ( *(_DWORD *)(a1 + 16) )
            {
              Curl_share_lock(a1, 1);
              if ( *(_DWORD *)(v3 + 4) == 4 )
              {
                *(_DWORD *)v3 = 0;
                *(_DWORD *)(v3 + 4) = 0;
              }
              v70 = *(_DWORD *)(v3 + 16);
              if ( *(_DWORD *)(v70 + 24) == *(_DWORD *)(v3 + 884) )
                *(_DWORD *)(v3 + 884) = 0;
              --*(_DWORD *)(v70 + 4);
              Curl_share_unlock(v3, 1);
            }
            *(_DWORD *)(v3 + 16) = v69;
            if ( v69 )
            {
              Curl_share_lock(v3, 1);
              ++*(_DWORD *)(*(_DWORD *)(v3 + 16) + 4);
              if ( *(_DWORD *)(*(_DWORD *)(v3 + 16) + 20) )
              {
                if ( *(_DWORD *)(v3 + 4) == 1 )
                  Curl_hash_destroy(*(_DWORD **)v3);
                *(_DWORD *)v3 = *(_DWORD *)(*(_DWORD *)(v3 + 16) + 20);
                *(_DWORD *)(v3 + 4) = 4;
              }
              if ( *(_DWORD *)(*(_DWORD *)(v3 + 16) + 24) )
              {
                v71 = *(_DWORD *)(v3 + 884);
                if ( v71 )
                  Curl_cookie_cleanup(v71);
                *(_DWORD *)(v3 + 884) = *(_DWORD *)(*(_DWORD *)(v3 + 16) + 24);
              }
              Curl_share_unlock(v3, 1);
              return 0;
            }
            return 0;
          }
          v31 = (const char *)*a3;
          v18 = (int *)(a1 + 744);
          if ( *a3 && !*v31 )
            v31 = "deflate, gzip";
          return sub_70DE8(v18, (int)v31);
        }
        if ( a2 == 10131 )
        {
          *(_DWORD *)(a1 + 420) = *a3;
          return 0;
        }
        if ( a2 > 0x2793 )
        {
          if ( a2 != 10134 )
          {
            if ( a2 != 10135 )
              return 2;
            v48 = (unsigned __int8 *)*a3;
            if ( !*a3 )
              return 0;
            if ( Curl_raw_equal((unsigned __int8 *)*a3, "ALL") )
            {
              Curl_cookie_clearall(*(_DWORD **)(v3 + 884));
              return 0;
            }
            if ( Curl_raw_equal(v48, "SESS") )
            {
              Curl_cookie_clearsess(*(_QWORD **)(v3 + 884));
              return 0;
            }
            if ( Curl_raw_equal(v48, "FLUSH") )
            {
              sub_70E60(v3, 0);
              return 0;
            }
            if ( !*(_DWORD *)(v3 + 884) )
              *(_DWORD *)(v3 + 884) = Curl_cookie_init(v3, 0, 0, 1);
            v49 = Curl_cstrdup(v48);
            v50 = v49;
            if ( v49 )
            {
              if ( Curl_raw_nequal("Set-Cookie:", v49, 11) )
                Curl_cookie_add(v3, *(_DWORD *)(v3 + 884), 1, v50 + 11, 0, 0);
              else
                Curl_cookie_add(v3, *(_DWORD *)(v3 + 884), 0, v50, 0, 0);
              Curl_cfree(v50);
              return 0;
            }
            return 27;
          }
          v18 = (int *)(a1 + 748);
        }
        else
        {
          if ( a2 != 10118 )
            return 2;
          v18 = (int *)(a1 + 776);
        }
      }
    }
LABEL_507:
    v31 = (const char *)*a3;
    return sub_70DE8(v18, (int)v31);
  }
  if ( a2 == 85 )
  {
    v58 = *a3;
    if ( *a3 )
      LOBYTE(v58) = 1;
    *(_BYTE *)(a1 + 676) = v58;
    return 0;
  }
  if ( a2 > 0x55 )
  {
    if ( a2 == 137 )
    {
      v59 = *a3;
      if ( *a3 )
        LOBYTE(v59) = 1;
      *(_BYTE *)(a1 + 696) = v59;
      return 0;
    }
    if ( a2 > 0x89 )
    {
      if ( a2 == 157 )
      {
        v75 = 1 - *a3;
        if ( (unsigned int)*a3 > 1 )
          LOBYTE(v75) = 0;
        *(_BYTE *)(a1 + 704) = v75;
        return 0;
      }
      if ( a2 > 0x9D )
      {
        if ( a2 == 166 )
        {
          if ( *a3 )
          {
            if ( *a3 == 1 )
            {
              *(_BYTE *)(a1 + 716) = 1;
              result = 0;
            }
            else
            {
              result = 2;
            }
          }
          else
          {
            result = 0;
            *(_BYTE *)(v3 + 716) = 0;
          }
        }
        else
        {
          if ( a2 > 0xA6 )
          {
            if ( a2 == 178 )
            {
              *(_DWORD *)(a1 + 436) = *a3;
              return 0;
            }
            if ( a2 > 0xB2 )
            {
              if ( a2 == 181 )
              {
                *(_DWORD *)(a1 + 856) = *(unsigned __int16 *)a3;
                return 0;
              }
              if ( a2 == 182 )
              {
                *(_DWORD *)(a1 + 860) = *(unsigned __int16 *)a3;
                return 0;
              }
            }
            else if ( a2 == 171 )
            {
              *(_DWORD *)(a1 + 852) = *a3;
              return 0;
            }
            return 2;
          }
          if ( a2 == 159 )
          {
            *(_DWORD *)(a1 + 708) = *a3;
            return 0;
          }
          if ( a2 >= 0x9F )
          {
            if ( a2 == 160 )
            {
              *(_DWORD *)(a1 + 712) = *a3;
              return 0;
            }
            if ( a2 == 161 )
            {
              v17 = *a3;
              *(_BYTE *)(a1 + 328) = *(_BYTE *)a3 & 1;
              *(_BYTE *)(a1 + 329) = (v17 >> 1) & 1;
              return 0;
            }
            return 2;
          }
          v76 = 1 - *a3;
          if ( (unsigned int)*a3 > 1 )
            LOBYTE(v76) = 0;
          *(_BYTE *)(a1 + 705) = v76;
          result = 0;
        }
        return result;
      }
      if ( a2 == 141 )
      {
        v74 = *a3;
        if ( *a3 )
          LOBYTE(v74) = 1;
        *(_BYTE *)(a1 + 697) = v74;
        return 0;
      }
      if ( a2 <= 0x8D )
      {
        v15 = *a3;
        if ( a2 == 139 )
        {
          *(_WORD *)(a1 + 352) = v15;
          result = 0;
        }
        else
        {
          if ( a2 > 0x8B )
            *(_DWORD *)(a1 + 356) = v15;
          else
            *(_DWORD *)(a1 + 632) = v15;
          result = 0;
        }
        return result;
      }
      if ( a2 == 154 )
      {
        *(_DWORD *)(a1 + 688) = *a3;
        return 0;
      }
      if ( a2 > 0x9A )
      {
        if ( a2 == 155 )
        {
          *(_DWORD *)(a1 + 424) = *a3;
          return 0;
        }
        if ( a2 == 156 )
        {
          *(_DWORD *)(a1 + 428) = *a3;
          return 0;
        }
        return 2;
      }
      if ( a2 == 150 )
      {
        v16 = *a3;
        if ( *a3 )
          LOBYTE(v16) = 1;
        *(_BYTE *)(a1 + 592) = v16;
        return 0;
      }
      return 2;
    }
    if ( a2 == 107 )
    {
      v51 = *a3;
      v52 = ((unsigned int)*a3 >> 4) & 1;
      *(_BYTE *)(a1 + 34082) = v52;
      if ( v52 )
        v51 = v51 & 0xFFFFFFEF | 2;
      v53 = v51 & 0xFFFFFFF3;
      if ( v53 )
      {
        *(_DWORD *)(a1 + 312) = v53;
        return 0;
      }
    }
    else
    {
      if ( a2 <= 0x6B )
      {
        if ( a2 != 98 )
        {
          if ( a2 > 0x62 )
          {
            if ( a2 == 101 )
            {
              *(_DWORD *)(a1 + 596) = *a3;
              return 0;
            }
            if ( a2 > 0x65 )
            {
              if ( a2 == 105 )
              {
                v32 = *a3;
                if ( *a3 )
                  LOBYTE(v32) = 1;
                *(_BYTE *)(a1 + 658) = v32;
                return 0;
              }
              if ( a2 == 106 )
              {
                v13 = *a3;
                if ( *a3 )
                  LOBYTE(v13) = 1;
                *(_BYTE *)(a1 + 677) = v13;
                return 0;
              }
            }
            else if ( a2 == 99 )
            {
              v12 = *a3;
              if ( *a3 )
                LOBYTE(v12) = 1;
              *(_BYTE *)(a1 + 692) = v12;
              return 0;
            }
          }
          else
          {
            switch ( a2 )
            {
              case 0x5Cu:
                *(_DWORD *)(a1 + 600) = *a3;
                return 0;
              case 0x60u:
                v47 = *a3;
                if ( *a3 )
                  LOBYTE(v47) = 1;
                *(_BYTE *)(a1 + 488) = v47;
                return 0;
              case 0x5Bu:
                v11 = *a3;
                if ( *a3 )
                  LOBYTE(v11) = 1;
                *(_BYTE *)(a1 + 693) = v11;
                return 0;
            }
          }
          return 2;
        }
        if ( (unsigned int)(*a3 - 1) > 0x3FFE )
        {
          result = 0;
          *(_DWORD *)(v3 + 604) = 0;
          return result;
        }
        *(_DWORD *)(a1 + 604) = *a3;
        return 0;
      }
      if ( a2 == 114 )
      {
        v72 = (_QWORD *)(a1 + 624);
        result = 0;
        *v72 = *a3;
        return result;
      }
      if ( a2 > 0x72 )
      {
        if ( a2 == 121 )
        {
          v73 = *a3;
          if ( *a3 )
            LOBYTE(v73) = 1;
          *(_BYTE *)(a1 + 694) = v73;
          result = 0;
        }
        else
        {
          if ( a2 <= 0x79 )
          {
            if ( a2 == 119 )
            {
              *(_DWORD *)(a1 + 680) = *a3;
              return 0;
            }
            return 2;
          }
          if ( a2 == 129 )
          {
            *(_DWORD *)(a1 + 684) = *a3;
            return 0;
          }
          if ( a2 != 136 )
            return 2;
          v14 = *a3;
          if ( *a3 )
            LOBYTE(v14) = 1;
          *(_BYTE *)(a1 + 695) = v14;
          result = 0;
        }
        return result;
      }
      if ( a2 != 111 )
      {
        if ( a2 > 0x6F )
        {
          if ( a2 == 112 )
          {
            *(_DWORD *)(a1 + 432) = 1000 * *a3;
            return 0;
          }
          if ( a2 == 113 )
          {
            *(_DWORD *)(a1 + 620) = *a3;
            return 0;
          }
        }
        else if ( a2 == 110 )
        {
          *(_DWORD *)(a1 + 636) = *a3;
          return 0;
        }
        return 2;
      }
      v54 = *a3;
      v55 = ((unsigned int)*a3 >> 4) & 1;
      *(_BYTE *)(a1 + 34098) = v55;
      if ( v55 )
        v54 = v54 & 0xFFFFFFEF | 2;
      v56 = v54 & 0xFFFFFFF3;
      if ( v56 )
      {
        *(_DWORD *)(a1 + 316) = v56;
        return 0;
      }
    }
    return 2;
  }
  if ( a2 == 50 )
  {
    v30 = *a3;
    if ( *a3 )
      LOBYTE(v30) = 1;
    *(_BYTE *)(a1 + 652) = v30;
    return 0;
  }
  if ( a2 > 0x32 )
  {
    if ( a2 == 64 )
    {
      *(_DWORD *)(a1 + 544) = *a3;
      return 0;
    }
    if ( a2 <= 0x40 )
    {
      if ( a2 == 54 )
        goto LABEL_308;
      if ( a2 <= 0x36 )
      {
        v7 = *a3;
        if ( a2 == 52 )
        {
          if ( v7 )
            LOBYTE(v7) = 1;
          *(_BYTE *)(a1 + 657) = v7;
          result = 0;
        }
        else if ( a2 > 0x34 )
        {
          if ( v7 )
            LOBYTE(v7) = 1;
          *(_BYTE *)(a1 + 651) = v7;
          result = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 668) = v7;
          result = 0;
        }
        return result;
      }
      if ( a2 == 59 )
      {
        *(_DWORD *)(a1 + 292) = *a3;
        return 0;
      }
      if ( a2 > 0x3B )
      {
        if ( a2 == 60 )
        {
          v41 = *a3;
          v42 = (_QWORD *)(a1 + 344);
          if ( *(_QWORD *)(a1 + 344) < (signed __int64)*a3 && *(_DWORD *)(a1 + 332) == *(_DWORD *)(a1 + 780) )
          {
            sub_70DE8((int *)(a1 + 780), 0);
            *(_DWORD *)(v3 + 332) = 0;
          }
          *v42 = v41;
          return 0;
        }
        if ( a2 == 61 )
        {
          v9 = *a3;
          if ( *a3 )
            LOBYTE(v9) = 1;
          *(_BYTE *)(a1 + 650) = v9;
          return 0;
        }
      }
      else if ( a2 == 58 )
      {
        v8 = *a3;
        if ( *a3 )
          LOBYTE(v8) = 1;
        *(_BYTE *)(a1 + 661) = v8;
        return 0;
      }
      return 2;
    }
    if ( a2 == 75 )
    {
      v22 = *a3;
      if ( *a3 )
        LOBYTE(v22) = 1;
      *(_BYTE *)(a1 + 674) = v22;
      return 0;
    }
    if ( a2 <= 0x4B )
    {
      if ( a2 == 69 )
      {
        v29 = *a3;
        if ( *a3 )
          LOBYTE(v29) = 1;
        *(_BYTE *)(a1 + 649) = v29;
        result = 0;
      }
      else
      {
        if ( a2 <= 0x45 )
        {
          if ( a2 == 68 )
          {
            *(_DWORD *)(a1 + 324) = *a3;
            return 0;
          }
          return 2;
        }
        if ( a2 == 71 )
          return Curl_ch_connc(a1, *(_DWORD **)(a1 + 1148), *a3);
        if ( a2 != 74 )
          return 2;
        v10 = *a3;
        if ( *a3 )
          LOBYTE(v10) = 1;
        *(_BYTE *)(a1 + 675) = v10;
        result = 0;
      }
      return result;
    }
    if ( a2 != 80 )
    {
      if ( a2 > 0x50 )
      {
        if ( a2 == 81 )
        {
          *(_DWORD *)(a1 + 548) = *a3;
          return 0;
        }
        if ( a2 == 84 )
        {
          *(_DWORD *)(a1 + 532) = *a3;
          return 0;
        }
      }
      else if ( a2 == 78 )
      {
        *(_DWORD *)(a1 + 428) = 1000 * *a3;
        return 0;
      }
      return 2;
    }
    if ( *a3 )
    {
      *(_DWORD *)(a1 + 528) = 1;
      result = 0;
      *(_BYTE *)(v3 + 664) = 0;
      *(_BYTE *)(v3 + 662) = 0;
      return result;
    }
    return 0;
  }
  if ( a2 == 33 )
  {
    *(_DWORD *)(a1 + 520) = *a3;
    return 0;
  }
  if ( a2 > 0x21 )
  {
    if ( a2 == 44 )
    {
      v27 = *a3;
      if ( *a3 )
        LOBYTE(v27) = 1;
      *(_BYTE *)(a1 + 662) = v27;
      return 0;
    }
    if ( a2 <= 0x2C )
    {
      if ( a2 == 41 )
      {
        v23 = *a3;
        if ( *a3 )
          LOBYTE(v23) = 1;
        *(_BYTE *)(a1 + 672) = v23;
        return 0;
      }
      if ( a2 <= 0x29 )
      {
        if ( a2 == 34 )
        {
          *(_DWORD *)(a1 + 524) = *a3;
          return 0;
        }
        return 2;
      }
      if ( a2 == 42 )
      {
        v24 = *a3;
        if ( *a3 )
          LOBYTE(v24) = 1;
        *(_BYTE *)(a1 + 659) = v24;
        return 0;
      }
      if ( a2 == 43 )
      {
        result = *a3;
        v25 = *(_DWORD *)(v3 + 944);
        if ( *a3 )
          result = 1;
        *(_BYTE *)(v3 + 655) = result;
        if ( result )
        {
          v26 = v25 | 0x10;
          result = 0;
        }
        else
        {
          v26 = v25 & 0xFFFFFFEF;
        }
        *(_DWORD *)(v3 + 944) = v26;
        return result;
      }
      return 2;
    }
    if ( a2 != 46 )
    {
      if ( a2 < 0x2E )
      {
        v28 = *a3;
        if ( *a3 )
          LOBYTE(v28) = 1;
        *(_BYTE *)(a1 + 656) = v28;
        return 0;
      }
      if ( a2 == 47 )
      {
        result = 0;
        if ( *a3 )
        {
          *(_BYTE *)(v3 + 662) = 0;
          *(_DWORD *)(v3 + 528) = 2;
        }
        else
        {
          result = 0;
          *(_DWORD *)(v3 + 528) = 1;
        }
        return result;
      }
      if ( a2 == 48 )
      {
        v6 = *a3;
        if ( *a3 )
          LOBYTE(v6) = 1;
        *(_BYTE *)(a1 + 653) = v6;
        return 0;
      }
      return 2;
    }
LABEL_308:
    result = *a3;
    if ( *a3 )
      result = 1;
    *(_BYTE *)(v3 + 664) = result;
    if ( result )
    {
      *(_BYTE *)(v3 + 662) = 0;
      *(_DWORD *)(v3 + 528) = 4;
      result = 0;
    }
    else
    {
      *(_DWORD *)(v3 + 528) = 1;
    }
    return result;
  }
  if ( a2 == 19 )
  {
    *(_DWORD *)(a1 + 448) = *a3;
    return 0;
  }
  if ( a2 <= 0x13 )
  {
    switch ( a2 )
    {
      case 0xDu:
        *(_DWORD *)(a1 + 424) = 1000 * *a3;
        return 0;
      case 0xEu:
        v60 = (_QWORD *)(a1 + 440);
        result = 0;
        *v60 = *a3;
        return result;
      case 3u:
        *(_DWORD *)(a1 + 308) = *a3;
        return 0;
    }
    return 2;
  }
  if ( a2 == 21 )
  {
    v65 = (_QWORD *)(a1 + 472);
    result = 0;
    *v65 = *a3;
    return result;
  }
  if ( a2 < 0x15 )
  {
    *(_DWORD *)(a1 + 452) = *a3;
    return 0;
  }
  if ( a2 != 27 )
  {
    if ( a2 == 32 )
    {
      *(_DWORD *)(a1 + 536) = *a3;
      return 0;
    }
    return 2;
  }
  v67 = *a3;
  if ( *a3 )
    LOBYTE(v67) = 1;
  *(_BYTE *)(a1 + 489) = v67;
  return 0;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000726D4) --------------------------------------------------------
int __fastcall sub_726D4(int a1, int *a2, char **a3, _BYTE *a4)
{
  int v4; // r4
  unsigned __int8 *v5; // r11
  int v6; // r5
  _DWORD *v7; // r0
  int v8; // r1
  _DWORD *v9; // r3
  unsigned int v10; // r2
  unsigned __int8 *v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r0
  _DWORD *v16; // r0
  int v17; // r3
  void *v18; // r0
  size_t v19; // r0
  signed int v20; // r8
  int v21; // r8
  void *v22; // r0
  _BYTE *v23; // r0
  char *v24; // r6
  size_t v25; // r0
  char *v26; // r0
  const char *v27; // r7
  size_t v28; // r0
  char *v29; // r0
  const char *v30; // r1
  const char *v31; // r7
  char *v32; // r0
  const char *v33; // r0
  char *v34; // r0
  char *v35; // r8
  size_t v36; // r7
  size_t v37; // r0
  size_t v38; // r0
  const char *v39; // r0
  char *v40; // r0
  char *v41; // r6
  unsigned int v42; // r0
  char *v43; // r8
  unsigned int v44; // r7
  size_t v45; // r0
  int v46; // r3
  void *v47; // r0
  int v48; // r6
  _DWORD *v49; // r7
  int v50; // t1
  int v51; // r3
  int (__fastcall *v52)(int); // r3
  int v53; // r3
  const char *v54; // r1
  const char *v55; // r1
  int v56; // r0
  int v57; // r0
  int v58; // r0
  const char *v59; // r6
  char *v60; // r1
  char *v61; // r0
  const char *v62; // r9
  const char *v63; // r8
  const char *v64; // r2
  int v65; // r3
  char *v66; // r0
  char *v67; // r0
  char v68; // r9
  int v69; // r0
  int v70; // r3
  char *v71; // r6
  const char *v72; // r0
  char *v73; // r0
  int v74; // r3
  int v75; // r3
  unsigned int v76; // r0
  int result; // r0
  int v78; // r0
  const char *v79; // r6
  char *v80; // r0
  const char *v81; // r0
  const char *v82; // r6
  const char *v83; // r0
  const char *v84; // r8
  char *v85; // r8
  int v86; // r1
  int i; // r3
  _BOOL4 v88; // r0
  char *v89; // r2
  char *v90; // r6
  char *v91; // r1
  void *v92; // r6
  const char *v93; // r1
  const char *v94; // r1
  int v95; // r0
  char *(__cdecl *v96)(const char *); // r3
  char *v97; // r0
  int v98; // r0
  char *v99; // r0
  int v100; // r3
  int v101; // r0
  int v102; // r0
  char *v103; // r0
  int v104; // r3
  const char *v105; // r0
  int v106; // r6
  int v107; // r8
  _DWORD *v108; // r3
  int v109; // r7
  int v110; // r9
  int v111; // r0
  int v112; // r3
  const char *v113; // r1
  const char *v114; // r3
  int v115; // r2
  signed int v116; // r0
  signed int v117; // r0
  _DWORD *v118; // r0
  _DWORD *v119; // r3
  _DWORD *v120; // r3
  int v121; // r0
  char *v122; // r1
  int v123; // r3
  _BOOL4 v124; // r0
  int v125; // r3
  int v126; // r0
  int v127; // r3
  int v128; // r3
  int v129; // r1
  int v130; // r2
  int v131; // r3
  int v132; // r3
  int v133; // [sp+0h] [bp-478h]
  int *v134; // [sp+14h] [bp-464h]
  char *v135; // [sp+1Ch] [bp-45Ch]
  char **v136; // [sp+20h] [bp-458h]
  _BYTE *v137; // [sp+24h] [bp-454h]
  int *v138; // [sp+28h] [bp-450h]
  __time_t v139; // [sp+38h] [bp-440h]
  int v140; // [sp+3Ch] [bp-43Ch]
  char v141; // [sp+47h] [bp-431h]
  char *endptr; // [sp+48h] [bp-430h]
  char v143; // [sp+4Ch] [bp-42Ch]
  char v144; // [sp+14Bh] [bp-32Dh]
  char dest; // [sp+14Ch] [bp-32Ch]
  char v146; // [sp+24Bh] [bp-22Dh]
  int v147; // [sp+24Ch] [bp-22Ch]
  char s; // [sp+250h] [bp-228h]
  char v149; // [sp+34Bh] [bp-12Dh]
  int v150; // [sp+34Ch] [bp-12Ch]
  int v151; // [sp+350h] [bp-128h]
  char v152; // [sp+44Bh] [bp-2Dh]
  int v153; // [sp+44Ch] [bp-2Ch]

  v6 = a1;
  v137 = a4;
  v136 = a3;
  v138 = a2;
  *a3 = 0;
  *a4 = 0;
  if ( !*(_DWORD *)(a1 + 864) )
    goto LABEL_120;
  v7 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, 0x350u);
  v4 = (int)v7;
  if ( v7 )
  {
    v7[80] = &off_EF69C;
    v7[53] = -1;
    v7[54] = -1;
    v7[11] = -1;
    *((_BYTE *)v7 + 296) = 1;
    curlx_tvnow(&v139);
    v8 = v140;
    v9 = (_DWORD *)(v4 + 204);
    *v9 = v139;
    v9[1] = v8;
  }
  *v138 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = v6;
    v10 = *(_DWORD *)(v6 + 596);
    *(_DWORD *)(v4 + 188) = v10;
    v11 = *(unsigned __int8 **)(v6 + 784);
    if ( v11 )
    {
      v11 = (unsigned __int8 *)*v11;
      if ( v11 )
        LOBYTE(v11) = 1;
    }
    v12 = (unsigned __int8)v11 & 1;
    *(_BYTE *)(v4 + 298) = v12;
    if ( v12 )
      LOBYTE(v12) = v10 <= 1;
    *(_BYTE *)(v4 + 299) = v12;
    v13 = *(_DWORD *)(v6 + 840);
    if ( v13 )
      LOBYTE(v13) = 1;
    *(_BYTE *)(v4 + 301) = v13;
    *(_BYTE *)(v4 + 308) = *(_BYTE *)(v6 + 650);
    v14 = *(_DWORD *)(v6 + 832);
    if ( v14 )
      LOBYTE(v14) = 1;
    *(_BYTE *)(v4 + 300) = v14;
    *(_BYTE *)(v4 + 312) = *(_BYTE *)(v6 + 676);
    *(_BYTE *)(v4 + 313) = *(_BYTE *)(v6 + 677);
    v15 = *(_DWORD *)(v6 + 8);
    if ( !v15
      || !Curl_multi_canPipeline(v15)
      || *(_DWORD *)(v4 + 384)
      || (v18 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(0x4000u, 1u), (*(_DWORD *)(v4 + 384) = v18) != 0) )
    {
      *(_DWORD *)(v4 + 372) = Curl_llist_alloc((int)&locret_70E24 + 1);
      *(_DWORD *)(v4 + 376) = Curl_llist_alloc((int)&locret_70E24 + 1);
      v16 = Curl_llist_alloc((int)&locret_70E24 + 1);
      v17 = *(_DWORD *)(v4 + 372);
      *(_DWORD *)(v4 + 380) = v16;
      if ( v17 )
      {
        if ( *(_DWORD *)(v4 + 376) && v16 )
        {
          v19 = strlen(*(const char **)(v6 + 864));
          v20 = v19 <= 0xFF ? 256 : v19;
          Curl_safefree(*(_DWORD *)(v6 + 34176));
          v21 = v20 + 2;
          v22 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v21);
          *(_DWORD *)(v6 + 34176) = v22;
          if ( v22 )
          {
            *(_DWORD *)(v6 + 34180) = v22;
            v23 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v21);
            *(_DWORD *)(v4 + 132) = v23;
            if ( v23 )
            {
              *(_DWORD *)(v4 + 140) = v23;
              *v23 = 0;
              v5 = (unsigned __int8 *)(v4 + 112);
              v24 = *(char **)(v6 + 34180);
              if ( sscanf(*(const char **)(v6 + 864), "%15[^:]:%[^\n]", v4 + 112, *(_DWORD *)(v6 + 34180)) == 2
                && Curl_raw_equal((unsigned __int8 *)(v4 + 112), "file") )
              {
                if ( *v24 == 47 && v24[1] == 47 )
                {
                  v25 = strlen(v24 + 2);
                  memmove(v24, v24 + 2, v25 + 1);
                }
                if ( *v24 != 47 )
                {
                  v26 = strchr(v24, 47);
                  v27 = v26;
                  if ( v26 )
                  {
                    if ( v26[1] == 47 )
                      v27 = v26 + 1;
                    v28 = strlen(v27);
                    memmove(v24, v27, v28 + 1);
                  }
                }
                strcpy((char *)(v4 + 112), "file");
              }
              else
              {
                *v24 = 0;
                if ( sscanf(
                       *(const char **)(v6 + 864),
                       "%15[^\n:]://%[^\n/]%[^\n]",
                       v4 + 112,
                       *(_DWORD *)(v4 + 140),
                       v24) <= 1 )
                {
                  if ( sscanf(*(const char **)(v6 + 864), "%[^\n/]%[^\n]", *(_DWORD *)(v4 + 140), v24) <= 0 )
                  {
                    Curl_failf(v6, "<url> malformed");
                    goto LABEL_120;
                  }
                  if ( Curl_raw_nequal("FTP.", *(_DWORD *)(v4 + 140), 4) )
                  {
                    v29 = (char *)(v4 + 112);
                    v30 = "ftp";
                  }
                  else if ( Curl_raw_nequal("DICT.", *(_DWORD *)(v4 + 140), 5) )
                  {
                    v29 = (char *)(v4 + 112);
                    v30 = "DICT";
                  }
                  else if ( Curl_raw_nequal("LDAP.", *(_DWORD *)(v4 + 140), 5) )
                  {
                    v29 = (char *)(v4 + 112);
                    v30 = "LDAP";
                  }
                  else
                  {
                    v29 = (char *)(v4 + 112);
                    v30 = "http";
                  }
                  strcpy(v29, v30);
                  *(_DWORD *)(v4 + 48) |= 0x800000u;
                }
              }
              v31 = *(const char **)(v4 + 140);
              v32 = strchr(*(const char **)(v4 + 140), 64);
              if ( v32 )
                v33 = v32 + 1;
              else
                v33 = v31;
              v34 = strchr(v33, 63);
              v35 = v34;
              if ( v34 )
              {
                v36 = strlen(v34);
                v37 = strlen(v24);
                memmove(&v24[v36 + 1], v24, v37 + 1);
                memcpy(v24 + 1, v35, v36);
                *v24 = 47;
                *v35 = 0;
              }
              else if ( !*v24 )
              {
                strcpy(v24, "/");
              }
              if ( *v24 == 63 )
              {
                v38 = strlen(v24);
                memmove(v24 + 1, v24, v38 + 1);
                *v24 = 47;
              }
              v39 = *(const char **)(v4 + 140);
              if ( *v39 == 91 )
              {
                v40 = strstr(v39, "%25");
                v41 = v40;
                if ( v40 )
                {
                  v42 = strtoul(v40 + 3, &endptr, 10);
                  v43 = endptr;
                  v44 = v42;
                  if ( *endptr == 93 )
                  {
                    v45 = strlen(endptr);
                    memmove(v41, v43, v45 + 1);
                    if ( !*(_BYTE *)(v6 + 33952) )
                      *(_DWORD *)(v4 + 108) = v44;
                  }
                  else
                  {
                    Curl_infof(v6, "Invalid IPv6 address format\n");
                  }
                }
              }
              v46 = *(_DWORD *)(v6 + 852);
              if ( v46 )
                *(_DWORD *)(v4 + 108) = v46;
              if ( *(_DWORD *)(v4 + 48) & 0x800000 )
              {
                v47 = curl_maprintf("%s://%s", v4 + 112, *(_DWORD *)(v6 + 864));
                if ( !v47 )
                {
                  Curl_safefree(0);
                  goto LABEL_70;
                }
                *(_DWORD *)(v6 + 864) = v47;
                *(_BYTE *)(v6 + 868) = 1;
                *(_DWORD *)(v4 + 48) &= 0xFF7FFFFF;
              }
              *(_DWORD *)(v4 + 128) = 1;
              v49 = &unk_F0494;
              do
              {
                v50 = v49[1];
                ++v49;
                v48 = v50;
                if ( !v50 )
                  goto LABEL_123;
              }
              while ( !Curl_raw_equal(*(unsigned __int8 **)v48, (_BYTE *)(v4 + 112)) );
              v51 = *(_DWORD *)(v48 + 52);
              if ( !(v51 & *(_DWORD *)(v6 + 856)) )
                goto LABEL_123;
              if ( *(_BYTE *)(v6 + 33952) )
                goto LABEL_122;
              goto LABEL_77;
            }
          }
        }
      }
    }
  }
LABEL_70:
  v48 = 27;
  while ( 1 )
  {
    result = v48;
    v51 = _stack_chk_guard;
    if ( v153 == _stack_chk_guard )
      return result;
LABEL_122:
    if ( !(v51 & *(_DWORD *)(v6 + 860)) )
    {
LABEL_123:
      v48 = 1;
      Curl_failf(v6, "Protocol %s not supported or disabled in libcurl", v5);
      goto LABEL_142;
    }
LABEL_77:
    *(_DWORD *)(v4 + 320) = v48;
    v52 = *(int (__fastcall **)(int))(v48 + 4);
    if ( v52 )
    {
      v78 = v52(v4);
      if ( !v78 )
      {
        v48 = *(_DWORD *)(v4 + 320);
        goto LABEL_78;
      }
      v48 = v78;
LABEL_142:
      Curl_safefree(0);
    }
    else
    {
LABEL_78:
      *(_DWORD *)(v4 + 164) = *(_DWORD *)(v48 + 48);
      *(_WORD *)(v4 + 168) = *(_DWORD *)(v48 + 48);
      v53 = *(_DWORD *)(v4 + 48) | *(_DWORD *)(v48 + 52);
      *(_DWORD *)(v4 + 48) = v53;
      v143 = 0;
      dest = 0;
      if ( v53 & 0x35 )
      {
        v79 = *(const char **)(v4 + 140);
        v80 = strchr(*(const char **)(v4 + 140), 64);
        if ( v80 )
        {
          *(_DWORD *)(v4 + 140) = v80 + 1;
          *(_BYTE *)(v4 + 315) = 1;
          if ( *(_DWORD *)(v6 + 668) != 2 )
          {
            *(_BYTE *)(v4 + 300) = 1;
            if ( *v79 == 58 )
              sscanf(v79, ":%255[^@]", &dest);
            else
              sscanf(v79, "%255[^:@]:%255[^@]", &v143, &dest, v133);
            if ( v143 )
            {
              v81 = (const char *)curl_easy_unescape(v6, &v143, 0, 0);
              v82 = v81;
              if ( !v81 )
                goto LABEL_70;
              if ( strlen(v81) <= 0xFF )
                strcpy(&v143, v82);
              Curl_cfree(v82);
            }
            if ( dest )
            {
              v83 = (const char *)curl_easy_unescape(v6, &dest, 0, 0);
              v84 = v83;
              if ( !v83 )
                goto LABEL_70;
              if ( strlen(v83) <= 0xFF )
                strcpy(&dest, v84);
              Curl_cfree(v84);
            }
          }
        }
      }
      if ( *(_BYTE *)(v4 + 301) )
      {
        v147 = 0;
        memset(&s, 0, 0xFCu);
        v150 = 0;
        memset(&v151, 0, 0xFCu);
        v54 = *(const char **)(v6 + 840);
        if ( v54 )
        {
          strncpy((char *)&v147, v54, 0x100u);
          v149 = 0;
        }
        v55 = *(const char **)(v6 + 844);
        if ( v55 )
        {
          strncpy((char *)&v150, v55, 0x100u);
          v152 = 0;
        }
        v56 = curl_easy_unescape(v6, (char *)&v147, 0, 0);
        *(_DWORD *)(v4 + 180) = v56;
        if ( !v56 )
          goto LABEL_70;
        v57 = curl_easy_unescape(v6, (char *)&v150, 0, 0);
        *(_DWORD *)(v4 + 184) = v57;
        if ( !v57 )
          goto LABEL_70;
      }
      v58 = *(_DWORD *)(v6 + 784);
      if ( v58 )
      {
        v59 = (const char *)Curl_cstrdup(v58);
        if ( !v59 )
        {
          Curl_failf(v6, "memory shortage");
          goto LABEL_70;
        }
      }
      else
      {
        v59 = 0;
      }
      v60 = *(char **)(v6 + 848);
      if ( v60 && sub_70F08(*(const char **)(v4 + 140), v60) )
      {
        if ( !v59 )
          goto LABEL_165;
      }
      else
      {
        if ( !v59 )
        {
          v85 = (char *)curl_getenv("no_proxy");
          if ( !v85 )
            v85 = (char *)curl_getenv("NO_PROXY");
          if ( !sub_70F08(*(const char **)(v4 + 140), v85) )
          {
            v86 = tolower_tab_;
            for ( i = 0; v5[i]; ++i )
              *((_BYTE *)&v150 + i) = *(_WORD *)(v86 + 2 * (v5[i] + 1));
            if ( (strcpy((char *)&v150 + i, "_proxy"), (v59 = (const char *)curl_getenv((const char *)&v150)) == 0)
              && (Curl_raw_equal("http_proxy", &v150)
               || (Curl_strntoupper((signed int)&v150, (int)&v150, 128),
                   (v59 = (const char *)curl_getenv((const char *)&v150)) == 0))
              || !*v59 )
            {
              v59 = (const char *)curl_getenv("all_proxy");
              if ( !v59 )
                v59 = (const char *)curl_getenv("ALL_PROXY");
            }
          }
          if ( v85 )
            Curl_cfree(v85);
          if ( !v59 )
            goto LABEL_165;
        }
        if ( *v59 )
        {
          if ( *(_DWORD *)(v4 + 188) <= 1u )
          {
            *(_DWORD *)(v4 + 48) = *(_DWORD *)(v4 + 48) & 0xC00002 | 1;
            *(_BYTE *)(v4 + 299) = 1;
          }
          *(_BYTE *)(v4 + 298) = 1;
          v61 = strstr(v59, "://");
          if ( v61 )
            v62 = v61 + 3;
          else
            v62 = v59;
          v135 = strchr(v62, 64);
          if ( v135 )
          {
            LOBYTE(v150) = 0;
            if ( sscanf(v62, "%255[^:@]:%255[^@]", &v147) > 0 )
            {
              Curl_safefree(*(_DWORD *)(v4 + 180));
              v101 = curl_easy_unescape(v6, (char *)&v147, 0, 0);
              *(_DWORD *)(v4 + 180) = v101;
              if ( !v101
                || (Curl_safefree(*(_DWORD *)(v4 + 184)),
                    v102 = curl_easy_unescape(v6, (char *)&v150, 0, 0),
                    (*(_DWORD *)(v4 + 184) = v102) == 0)
                || (*(_BYTE *)(v4 + 301) = 1, (v62 = (const char *)Curl_cstrdup(v135 + 1)) == 0) )
              {
                Curl_cfree(v59);
                goto LABEL_70;
              }
              v105 = v59;
              v59 = v62;
              Curl_cfree(v105);
            }
          }
          if ( *v62 == 91 )
          {
            v63 = v62 + 1;
            v64 = v62 + 1;
            while ( 1 )
            {
              v65 = *(unsigned __int8 *)v64;
              v62 = v64++;
              if ( !v65 )
                break;
              if ( !(*(_BYTE *)(ctype_ + v65 + 1) & 0x44) && v65 != 58 && v65 != 37 && v65 != 46 )
              {
                v66 = (char *)v62;
                if ( v65 == 93 )
                {
                  v62 = v64;
                  *v66 = 0;
                  goto LABEL_105;
                }
                break;
              }
            }
            Curl_infof(v6, "Invalid IPv6 address format\n", v64);
          }
          else
          {
            v63 = v62;
          }
LABEL_105:
          v67 = strchr(v62, 58);
          v68 = (char)v67;
          if ( v67 )
          {
            *v67 = 0;
            *(_DWORD *)(v4 + 164) = atoi(v67 + 1);
          }
          else
          {
            v103 = strchr(v63, 47);
            if ( v103 )
              *v103 = v68;
            v104 = *(_DWORD *)(v6 + 292);
            if ( v104 )
              *(_DWORD *)(v4 + 164) = v104;
          }
          v69 = Curl_cstrdup(v63);
          *(_DWORD *)(v4 + 148) = v69;
          *(_DWORD *)(v4 + 156) = v69;
          Curl_cfree(v59);
          if ( !*(_DWORD *)(v4 + 148) )
            goto LABEL_70;
          goto LABEL_108;
        }
      }
      Curl_cfree(v59);
LABEL_165:
      *(_BYTE *)(v4 + 298) = 0;
      *(_BYTE *)(v4 + 299) = 0;
      *(_BYTE *)(v4 + 301) = 0;
      *(_BYTE *)(v4 + 308) = 0;
LABEL_108:
      v70 = *(_DWORD *)(v4 + 48);
      if ( v70 & 0x400 )
      {
        v48 = (*(int (__fastcall **)(int, char **))(*(_DWORD *)(v4 + 320) + 20))(v4, &endptr);
        if ( !v48 )
        {
          *(_DWORD *)v4 = v6;
          *(_BYTE *)(v4 + 305) = 1;
          sub_25D50(v6, v4);
          v6 = sub_25C98(v6);
          if ( v6 )
          {
            v48 = v6;
            (*(void (__fastcall **)(int, int, _DWORD))(*(_DWORD *)(v4 + 320) + 12))(v4, v6, 0);
          }
          else
          {
            v48 = Curl_setup_transfer((int *)v4, -1, -1LL, 0, 0, -1, 0);
          }
        }
      }
      else
      {
        if ( v70 & 0x400000 && *(_BYTE *)(v4 + 299) )
          *(_BYTE *)(v4 + 308) = 1;
        if ( sscanf(*(const char **)(v4 + 140), "[%*45[0123456789abcdefABCDEF:.]%c", &v141) != 1 || v141 != 93 )
        {
          v71 = strrchr(*(const char **)(v4 + 140), 58);
        }
        else
        {
          *(_BYTE *)(v4 + 302) = 1;
          v71 = 0;
          v72 = (const char *)(*(_DWORD *)(v4 + 140) + 1);
          *(_DWORD *)(v4 + 140) = v72;
          v73 = strchr(v72, 93);
          v74 = (unsigned __int8)v73[1];
          *v73 = 0;
          if ( v74 == 58 )
            v71 = v73 + 1;
        }
        v75 = *(_DWORD *)(v6 + 308);
        if ( v75 && *(_BYTE *)(v6 + 33992) )
        {
          *(_WORD *)(v4 + 168) = v75;
          if ( v71 )
            *v71 = 0;
          if ( *(_BYTE *)(v4 + 299) )
          {
            if ( Curl_raw_equal("ftp", v5) )
              v88 = 1;
            else
              v88 = Curl_raw_equal("ftps", v5) != 0;
            if ( *(_BYTE *)(v4 + 302) )
              v89 = "[";
            else
              v89 = &byte_E4496;
            if ( *(_BYTE *)(v4 + 302) )
              v90 = "]";
            else
              v90 = &byte_E4496;
            if ( v88 )
              v91 = "/";
            else
              v91 = &byte_E4496;
            v92 = curl_maprintf(
                    "%s://%s%s%s:%d%s%s",
                    v5,
                    v89,
                    *(_DWORD *)(v4 + 140),
                    v90,
                    *(unsigned __int16 *)(v4 + 168),
                    v91,
                    *(_DWORD *)(v6 + 34180));
            if ( !v92 )
              goto LABEL_70;
            if ( *(_BYTE *)(v6 + 868) )
              Curl_cfree(*(_DWORD *)(v6 + 864));
            *(_DWORD *)(v6 + 864) = v92;
            *(_BYTE *)(v6 + 868) = 1;
          }
          goto LABEL_193;
        }
        if ( !v71 || (v76 = strtoul(v71 + 1, &endptr, 10), endptr == v71 + 1) || *endptr )
        {
LABEL_193:
          v93 = *(const char **)(v6 + 832);
          if ( v93 )
          {
            strncpy(&v143, v93, 0x100u);
            v144 = 0;
          }
          v94 = *(const char **)(v6 + 836);
          if ( v94 )
          {
            strncpy(&dest, v94, 0x100u);
            v146 = 0;
          }
          *(_BYTE *)(v4 + 314) = 0;
          if ( *(_DWORD *)(v6 + 668) )
          {
            if ( Curl_parsenetrc(*(unsigned __int8 **)(v4 + 140), (unsigned __int8 *)&v143, &dest, *(char **)(v6 + 776)) )
            {
              Curl_infof(v6, "Couldn't find host %s in the .netrc file; using defaults\n", *(_DWORD *)(v4 + 140));
            }
            else
            {
              *(_BYTE *)(v4 + 314) = 1;
              *(_BYTE *)(v4 + 300) = 1;
            }
          }
          if ( !(*(_DWORD *)(v4 + 48) & 4) || *(_BYTE *)(v4 + 300) )
          {
            v98 = Curl_cstrdup(&v143);
            v96 = (char *(__cdecl *)(const char *))Curl_cstrdup;
            *(_DWORD *)(v4 + 172) = v98;
            v97 = &dest;
          }
          else
          {
            v95 = Curl_cstrdup("anonymous");
            v96 = (char *(__cdecl *)(const char *))Curl_cstrdup;
            *(_DWORD *)(v4 + 172) = v95;
            v97 = "ftp@example.com";
          }
          v99 = v96(v97);
          v100 = *(_DWORD *)(v4 + 172);
          *(_DWORD *)(v4 + 176) = v99;
          if ( !v100 )
            goto LABEL_70;
          if ( !*(_DWORD *)(v4 + 176) )
            goto LABEL_70;
          *(_DWORD *)(v6 + 552) = *(_DWORD *)(v6 + 800);
          *(_DWORD *)(v6 + 556) = *(_DWORD *)(v6 + 804);
          *(_DWORD *)(v6 + 560) = *(_DWORD *)(v6 + 824);
          *(_DWORD *)(v6 + 564) = *(_DWORD *)(v6 + 828);
          *(_DWORD *)(v6 + 568) = *(_DWORD *)(v6 + 816);
          *(_DWORD *)(v6 + 572) = *(_DWORD *)(v6 + 812);
          *(_DWORD *)(v6 + 576) = *(_DWORD *)(v6 + 808);
          v134 = (int *)(v4 + 236);
          if ( !Curl_clone_ssl_config(v6 + 536, v4 + 236) )
            goto LABEL_70;
          if ( !*(_BYTE *)(v6 + 675) || *(_BYTE *)(v6 + 33952) )
          {
            v106 = 0;
            v107 = sub_25D24(v6);
            while ( 1 )
            {
              v108 = *(_DWORD **)(v6 + 1148);
              if ( v106 >= v108[1] )
                goto LABEL_236;
              v109 = *(_DWORD *)(*v108 + 4 * v106);
              if ( v109 )
                break;
LABEL_235:
              ++v106;
            }
            v110 = *(_DWORD *)(*(_DWORD *)(v109 + 376) + 12) + *(_DWORD *)(*(_DWORD *)(v109 + 372) + 12);
            if ( *(_DWORD *)(v109 + 44) == -1 )
              *(_DWORD *)(v109 + 44) = v106;
            if ( !v110 )
            {
              if ( !*(_BYTE *)(v109 + 40) && Curl_socket_ready(*(_DWORD *)(v109 + 212), -1, 0) )
              {
                *(_DWORD *)v109 = v6;
                Curl_infof(v6, "Connection #%d seems to be dead!\n", v106);
                Curl_disconnect((int **)v109);
                *(_DWORD *)(**(_DWORD **)(v6 + 1148) + 4 * v106) = 0;
                goto LABEL_235;
              }
              if ( v107 )
                goto LABEL_261;
              if ( !*(_BYTE *)(v109 + 60) )
              {
                v121 = v6;
                v122 = "Connection #%ld hasn't finished name resolve, can't reuse\n";
LABEL_274:
                Curl_infof(v121, v122, *(_DWORD *)(v109 + 44));
                goto LABEL_235;
              }
              if ( *(_DWORD *)(v109 + 212) == -1 || *(_BYTE *)(v109 + 296) )
              {
                v122 = "Connection #%ld isn't open enough, can't reuse\n";
                v121 = v6;
                goto LABEL_274;
              }
LABEL_276:
              v123 = *(_DWORD *)(v4 + 48);
              if ( !((*(_DWORD *)(v109 + 48) ^ v123) & 0x400000)
                && *(unsigned __int8 *)(v4 + 298) == *(unsigned __int8 *)(v109 + 298)
                && (v107 || !*(_BYTE *)(v109 + 40)) )
              {
                if ( !*(_BYTE *)(v4 + 299)
                  || v123 & 0x400000
                  || *(_BYTE *)(v109 + 299)
                  && *(_BYTE *)(v4 + 308)
                  && *(_BYTE *)(v109 + 308)
                  && Curl_raw_equal(*(unsigned __int8 **)(v4 + 156), *(_BYTE **)(v109 + 156))
                  && *(_DWORD *)(v4 + 164) == *(_DWORD *)(v109 + 164) )
                {
                  if ( Curl_raw_equal(v5, (_BYTE *)(v109 + 112)) )
                  {
                    v124 = Curl_raw_equal(*(unsigned __int8 **)(v4 + 140), *(_BYTE **)(v109 + 140));
                    if ( v124
                      && *(unsigned __int16 *)(v4 + 168) == *(unsigned __int16 *)(v109 + 168)
                      && (!(*(_DWORD *)(v4 + 48) & 0x400000)
                       || Curl_ssl_config_matches((int)v134, v109 + 236) && *(_DWORD *)(v109 + 224) == 2) )
                    {
                      if ( (v125 = *(_DWORD *)(v4 + 48), !(v125 & 4)) && (!(v125 & 1) || *(_DWORD *)(v6 + 34068) != 8)
                        || curl_strequal(*(const char **)(v4 + 172), *(const char **)(v109 + 172))
                        && curl_strequal(*(const char **)(v4 + 176), *(const char **)(v109 + 176)) )
                      {
LABEL_307:
                        *(_BYTE *)(v109 + 40) = 1;
                        v126 = *(_DWORD *)(v4 + 148);
                        if ( v126 )
                          Curl_cfree(v126);
                        Curl_free_ssl_config(v134);
                        *(_DWORD *)v109 = *(_DWORD *)v4;
                        v127 = *(unsigned __int8 *)(v4 + 300);
                        *(_BYTE *)(v109 + 300) = v127;
                        if ( v127 )
                        {
                          Curl_safefree(*(_DWORD *)(v109 + 172));
                          Curl_safefree(*(_DWORD *)(v109 + 176));
                          *(_DWORD *)(v109 + 172) = *(_DWORD *)(v4 + 172);
                          *(_DWORD *)(v109 + 176) = *(_DWORD *)(v4 + 176);
                          *(_DWORD *)(v4 + 172) = 0;
                          *(_DWORD *)(v4 + 176) = 0;
                        }
                        v128 = *(unsigned __int8 *)(v4 + 301);
                        *(_BYTE *)(v109 + 301) = v128;
                        if ( v128 )
                        {
                          Curl_safefree(*(_DWORD *)(v109 + 180));
                          Curl_safefree(*(_DWORD *)(v109 + 184));
                          *(_DWORD *)(v109 + 180) = *(_DWORD *)(v4 + 180);
                          *(_DWORD *)(v109 + 184) = *(_DWORD *)(v4 + 184);
                          *(_DWORD *)(v4 + 180) = 0;
                          *(_DWORD *)(v4 + 184) = 0;
                        }
                        if ( *(_BYTE *)(v109 + 298) )
                        {
                          Curl_cfree(*(_DWORD *)(v109 + 132));
                          v129 = *(_DWORD *)(v4 + 136);
                          v130 = *(_DWORD *)(v4 + 140);
                          v131 = *(_DWORD *)(v4 + 144);
                          *(_DWORD *)(v109 + 132) = *(_DWORD *)(v4 + 132);
                          *(_DWORD *)(v109 + 136) = v129;
                          *(_DWORD *)(v109 + 140) = v130;
                          *(_DWORD *)(v109 + 144) = v131;
                        }
                        else
                        {
                          Curl_cfree(*(_DWORD *)(v4 + 132));
                        }
                        *(_BYTE *)(v109 + 297) = 1;
                        Curl_safefree(*(_DWORD *)(v4 + 172));
                        Curl_safefree(*(_DWORD *)(v4 + 176));
                        Curl_safefree(*(_DWORD *)(v4 + 180));
                        Curl_safefree(*(_DWORD *)(v4 + 184));
                        Curl_llist_destroy(*(_DWORD *)(v4 + 372), 0);
                        Curl_llist_destroy(*(_DWORD *)(v4 + 376), 0);
                        Curl_llist_destroy(*(_DWORD *)(v4 + 380), 0);
                        Curl_safefree(*(_DWORD *)(v4 + 384));
                        Curl_cfree(v4);
                        *v138 = v109;
                        if ( *(_DWORD *)(v109 + 156) )
                          v132 = *(_DWORD *)(v109 + 160);
                        else
                          v132 = *(_DWORD *)(v109 + 144);
                        v4 = v109;
                        Curl_infof(
                          v6,
                          "Re-using existing connection! (#%ld) with host %s\n",
                          *(_DWORD *)(v109 + 44),
                          v132,
                          v133);
                        strcpy((char *)(v6 + 34256), (const char *)(v109 + 60));
                        goto LABEL_237;
                      }
                    }
                  }
                }
                else if ( *(_BYTE *)(v109 + 298)
                       && *(_DWORD *)(v4 + 188) == *(_DWORD *)(v109 + 188)
                       && Curl_raw_equal(*(unsigned __int8 **)(v4 + 156), *(_BYTE **)(v109 + 156))
                       && *(_DWORD *)(v4 + 164) == *(_DWORD *)(v109 + 164) )
                {
                  goto LABEL_307;
                }
              }
              goto LABEL_235;
            }
            if ( !v107 )
              goto LABEL_235;
LABEL_261:
            v118 = **(_DWORD ***)(v109 + 372);
            if ( v118 )
              v118 = (_DWORD *)*v118;
            v119 = **(_DWORD ***)(v109 + 376);
            if ( v119 )
            {
              v120 = (_DWORD *)*v119;
              if ( !v118 )
              {
                if ( !v120 )
                  goto LABEL_276;
                v118 = v120;
              }
            }
            else if ( !v118 )
            {
              goto LABEL_276;
            }
            if ( !sub_25D24((int)v118) )
              goto LABEL_235;
            goto LABEL_276;
          }
LABEL_236:
          sub_25D50(v6, v4);
LABEL_237:
          v48 = sub_25C98(v6);
          if ( !v48 )
          {
            *(_DWORD *)(v4 + 404) = *(_DWORD *)(v6 + 368);
            *(_DWORD *)(v4 + 408) = *(_DWORD *)(v6 + 300);
            *(_DWORD *)(v4 + 396) = *(_DWORD *)(v6 + 336);
            *(_DWORD *)(v4 + 400) = *(_DWORD *)(v6 + 400);
            v111 = *(_DWORD *)(v6 + 424);
            v112 = *(_DWORD *)(v6 + 428);
            if ( v111 )
            {
              if ( v112 && v111 >= v112 )
                v111 = *(_DWORD *)(v6 + 428);
            }
            else
            {
              v111 = *(_DWORD *)(v6 + 428);
            }
            if ( *(_BYTE *)(v4 + 297) )
            {
              *v136 = 0;
              if ( *(_BYTE *)(v4 + 298) )
                *(_DWORD *)(v4 + 144) = *(_DWORD *)(v4 + 140);
            }
            else
            {
              v113 = *(const char **)(v4 + 140);
              v114 = *(const char **)(v4 + 156);
              *(_DWORD *)(v4 + 144) = v113;
              if ( v114 && *v114 )
              {
                *(_DWORD *)(v4 + 160) = v114;
                v133 = v111;
                v117 = Curl_resolv_timeout((int *)v4, v114, *(_DWORD *)(v4 + 164), (const char **)&endptr);
                if ( v117 == 1 )
                {
                  *v137 = 1;
                }
                else
                {
                  if ( v117 == -2 )
                    goto LABEL_251;
                  if ( !endptr )
                  {
                    v48 = 5;
                    Curl_failf(v6, "Couldn't resolve proxy '%s'", *(_DWORD *)(v4 + 160));
                  }
                }
              }
              else
              {
                v115 = *(unsigned __int16 *)(v4 + 168);
                *(_DWORD *)(v4 + 164) = v115;
                v133 = v111;
                v116 = Curl_resolv_timeout((int *)v4, v113, v115, (const char **)&endptr);
                if ( v116 == 1 )
                {
                  *v137 = 1;
                  goto LABEL_259;
                }
                if ( v116 == -2 )
                {
LABEL_251:
                  v48 = 28;
                  goto LABEL_259;
                }
                if ( !endptr )
                {
                  v48 = 6;
                  Curl_failf(v6, "Couldn't resolve host '%s'", *(_DWORD *)(v4 + 144));
                }
              }
LABEL_259:
              *v136 = endptr;
            }
          }
        }
        else
        {
          if ( v76 < 0x10000 )
          {
            *v71 = 0;
            *(_WORD *)(v4 + 168) = v76;
            goto LABEL_193;
          }
          Curl_failf(v6, "Port number too large: %lu", v76);
LABEL_120:
          v48 = 3;
        }
      }
    }
  }
}
// E4496: using guessed type char byte_E4496;
// EF69C: using guessed type char *off_EF69C;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000737EC) --------------------------------------------------------
signed int __fastcall Curl_addHandleToPipeline(int a1, _DWORD *a2)
{
  signed int result; // r0

  if ( Curl_llist_insert_next(a2, a2[1], a1) )
    result = 0;
  else
    result = 27;
  return result;
}

//----- (00073802) --------------------------------------------------------
signed int __fastcall Curl_removeHandleFromPipeline(int a1, _DWORD **a2)
{
  int v2; // r3
  _DWORD *i; // r1

  v2 = (int)a2;
  for ( i = *a2; i; i = (_DWORD *)i[2] )
  {
    if ( *i == a1 )
    {
      Curl_llist_remove(v2, i, 0);
      return 1;
    }
  }
  return 0;
}

//----- (00073824) --------------------------------------------------------
signed int __fastcall Curl_getoff_all_pipelines(int a1, int a2)
{
  int v2; // r5
  int v3; // r7
  int v4; // r4
  _DWORD *v5; // r3
  int v6; // r6
  _DWORD *v7; // r3

  v2 = a1;
  v3 = *(unsigned __int8 *)(a2 + 368);
  v4 = a2;
  if ( *(_BYTE *)(a2 + 368) )
  {
    v5 = **(_DWORD ***)(a2 + 376);
    if ( v5 )
      v5 = (_DWORD *)*v5;
    v3 = (unsigned int)v5 - a1 <= 0;
  }
  v6 = *(unsigned __int8 *)(a2 + 369);
  if ( *(_BYTE *)(a2 + 369) )
  {
    v7 = **(_DWORD ***)(a2 + 372);
    if ( v7 )
      v7 = (_DWORD *)*v7;
    v6 = (unsigned int)v7 - a1 <= 0;
  }
  if ( Curl_removeHandleFromPipeline(a1, *(_DWORD ***)(a2 + 376)) && v3 << 31 < 0 )
    *(_BYTE *)(v4 + 368) = 0;
  if ( Curl_removeHandleFromPipeline(v2, *(_DWORD ***)(v4 + 372)) && v6 << 31 < 0 )
    *(_BYTE *)(v4 + 369) = 0;
  return Curl_removeHandleFromPipeline(v2, *(_DWORD ***)(v4 + 380));
}

//----- (00073890) --------------------------------------------------------
signed int __fastcall Curl_connected_proxy(int a1)
{
  signed int result; // r0

  if ( *(_BYTE *)(a1 + 305) )
    return 0;
  switch ( *(_DWORD *)(*(_DWORD *)a1 + 596) )
  {
    case 4:
      result = Curl_SOCKS4(
                 *(_DWORD *)(a1 + 180),
                 *(const char **)(a1 + 140),
                 *(unsigned __int16 *)(a1 + 168),
                 0,
                 (int *)a1,
                 0);
      break;
    case 5:
    case 7:
      result = Curl_SOCKS5(
                 *(_DWORD *)(a1 + 180),
                 *(_DWORD *)(a1 + 184),
                 *(char **)(a1 + 140),
                 *(unsigned __int16 *)(a1 + 168),
                 0,
                 a1);
      break;
    case 6:
      result = Curl_SOCKS4(
                 *(_DWORD *)(a1 + 180),
                 *(const char **)(a1 + 140),
                 *(unsigned __int16 *)(a1 + 168),
                 0,
                 (int *)a1,
                 1);
      break;
    default:
      return 0;
  }
  return result;
}

//----- (000738FE) --------------------------------------------------------
int __fastcall Curl_protocol_getsock(int a1)
{
  int (*v1)(void); // r3
  int result; // r0

  v1 = *(int (**)(void))(*(_DWORD *)(a1 + 320) + 32);
  if ( v1 )
    result = v1();
  else
    result = 0;
  return result;
}

//----- (00073910) --------------------------------------------------------
int __fastcall Curl_doing_getsock(int a1)
{
  int (*v1)(void); // r3
  int result; // r0

  v1 = (int (*)(void))a1;
  if ( a1 && (v1 = *(int (**)(void))(*(_DWORD *)(a1 + 320) + 36)) != 0 )
    result = v1();
  else
    result = (int)v1;
  return result;
}

//----- (00073926) --------------------------------------------------------
int __fastcall Curl_protocol_connecting(int a1, _BYTE *a2)
{
  int result; // r0

  if ( a1 && *(_DWORD *)(*(_DWORD *)(a1 + 320) + 24) )
  {
    *a2 = 0;
    result = (*(int (**)(void))(*(_DWORD *)(a1 + 320) + 24))();
  }
  else
  {
    result = 0;
    *a2 = 1;
  }
  return result;
}

//----- (0007394A) --------------------------------------------------------
int __fastcall Curl_protocol_doing(int a1, _BYTE *a2)
{
  int result; // r0

  if ( a1 && *(_DWORD *)(*(_DWORD *)(a1 + 320) + 28) )
  {
    *a2 = 0;
    result = (*(int (**)(void))(*(_DWORD *)(a1 + 320) + 28))();
  }
  else
  {
    result = 0;
    *a2 = 1;
  }
  return result;
}

//----- (0007396E) --------------------------------------------------------
int __fastcall Curl_protocol_connect(int a1, _BYTE *a2)
{
  unsigned int v2; // r6
  int v3; // r4
  _BYTE *v4; // r5
  int result; // r0
  int v6; // r1
  _DWORD *v7; // r3
  int v8; // [sp+0h] [bp-18h]
  _BYTE *v9; // [sp+4h] [bp-14h]

  v8 = a1;
  v9 = a2;
  v2 = *(_DWORD *)a1;
  v3 = a1;
  *a2 = 0;
  v4 = a2;
  if ( *(_BYTE *)(a1 + 305) )
  {
    if ( *(_BYTE *)(a1 + 306) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 320) + 24);
      if ( !result )
      {
        *a2 = 1;
        return result;
      }
      return 0;
    }
  }
  else
  {
    Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(2, v2)));
    if ( *(_BYTE *)(v2 + 672) )
      sub_70E28(v3);
  }
  if ( !*(_BYTE *)(v3 + 306) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(v3 + 320) + 20) )
    {
      curlx_tvnow(&v8);
      v6 = (int)v9;
      v7 = (_DWORD *)(v3 + 196);
      *v7 = v8;
      v7[1] = v6;
      result = (*(int (__fastcall **)(int, _BYTE *))(*(_DWORD *)(v3 + 320) + 20))(v3, v4);
      if ( result )
        return result;
    }
    else
    {
      *v4 = 1;
    }
    *(_BYTE *)(v3 + 306) = 1;
  }
  return 0;
}

//----- (000739E8) --------------------------------------------------------
signed int __fastcall sub_739E8(int *a1, int *a2, _BYTE *a3)
{
  int v3; // r6
  int v4; // r7
  int *v5; // r9
  double v6; // r0
  _BYTE *v7; // r8
  signed int result; // r0
  signed int v9; // r4
  void *v10; // r0
  int v11; // r3
  char *v12; // r2
  int v13; // r3
  char v14; // r3
  _BYTE *v15; // r3
  _DWORD *v16; // r6
  int v17; // r1
  __time_t v18; // [sp+8h] [bp-38h]
  int v19; // [sp+Ch] [bp-34h]
  char v20; // [sp+13h] [bp-2Dh]
  int v21; // [sp+14h] [bp-2Ch]

  v3 = (int)a1;
  v4 = *a1;
  v5 = a2;
  HIDWORD(v6) = 1;
  v7 = a3;
  LODWORD(v6) = *a1;
  Curl_pgrsTime(v6);
  if ( *(_DWORD *)(v3 + 48) & 0x400 )
  {
    result = 0;
    *v7 = 1;
    return result;
  }
  *v7 = 0;
  *(_BYTE *)(v3 + 318) = 0;
  if ( *(_DWORD *)(v4 + 820) )
  {
    Curl_safefree(*(_DWORD *)(v3 + 336));
    v10 = curl_maprintf("User-Agent: %s\r\n", *(_DWORD *)(v4 + 820));
    *(_DWORD *)(v3 + 336) = v10;
    if ( !v10 )
      return 27;
  }
  *(_DWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 34160) = 0LL;
  v9 = 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(v3 + 212) != -1 )
    {
      Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(2, v4)));
      Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(3, v4)));
      *(_BYTE *)(v3 + 305) = 1;
      *v7 = 1;
      if ( *(_BYTE *)(v4 + 672) )
        sub_70E28(v3);
      goto LABEL_28;
    }
    v20 = 0;
    if ( *(_BYTE *)(v3 + 298) )
    {
      v11 = *(_DWORD *)(v3 + 156);
      v12 = "proxy ";
    }
    else
    {
      v11 = *(_DWORD *)(v3 + 140);
      v12 = &byte_E4496;
    }
    Curl_infof(v4, "About to connect() to %s%s port %d (#%d)\n", v12, v11, *(_DWORD *)(v3 + 164), *(_DWORD *)(v3 + 44));
    v9 = Curl_connecthost((int **)v3, v5, (signed int *)(v3 + 212), &v21, &v20);
    if ( v9
      || (v13 = v21, *(_DWORD *)(v3 + 52) = v5, *(_DWORD *)(v3 + 56) = v13, v20) && (v9 = Curl_connected_proxy(v3)) != 0 )
    {
      v20 = 0;
    }
    v14 = v20;
    if ( !v20 )
      goto LABEL_12;
    v9 = Curl_protocol_connect(v3, v7);
    if ( !v9 )
    {
      v14 = 1;
LABEL_12:
      *(_BYTE *)(v3 + 305) = v14;
    }
    if ( !*(_BYTE *)(v3 + 318) )
      break;
    v15 = *(_BYTE **)(v4 + 288);
    if ( v15 )
      *v15 = 0;
    *(_BYTE *)(v4 + 33984) = 0;
  }
  if ( v9 )
    return v9;
LABEL_28:
  v16 = (_DWORD *)(v3 + 196);
  curlx_tvnow(&v18);
  v17 = v19;
  *v16 = v18;
  v16[1] = v17;
  return v9;
}
// E4496: using guessed type char byte_E4496;

//----- (00073B60) --------------------------------------------------------
int *__fastcall Curl_connect(int a1, int *a2, _BYTE *a3, _BYTE *a4)
{
  _BYTE *v4; // r6
  _BYTE *v5; // r7
  int v6; // r8
  int ***v7; // r5
  int v8; // r0
  int *v9; // r0
  int *v10; // r4
  int *v12; // [sp+4h] [bp-1Ch]

  v12 = a2;
  v4 = a3;
  v5 = a4;
  *a3 = 0;
  v6 = a1;
  v7 = (int ***)a2;
  v8 = sub_726D4(a1, a2, (char **)&v12, a3);
  if ( !v8 )
  {
    v9 = (int *)*v7;
    if ( (*v7)[93][3] || *(_DWORD *)(v9[94] + 12) )
    {
      *v5 = 1;
      return 0;
    }
    if ( !v12 && *v4 )
      v10 = v12;
    else
      v10 = (int *)sub_739E8(v9, v12, v5);
    if ( !v12 )
    {
      if ( !v10 )
        return v10;
      goto LABEL_13;
    }
    if ( !v10 )
      return 0;
    Curl_resolv_unlock(v6, (int)v12);
    v8 = (int)v10;
  }
  v10 = (int *)v8;
LABEL_13:
  if ( *v7 )
  {
    Curl_disconnect(*v7);
    *v7 = 0;
  }
  return v10;
}

//----- (00073BD6) --------------------------------------------------------
signed int __fastcall Curl_async_resolved(int **a1, _BYTE *a2)
{
  int **v2; // r4
  signed int v3; // r5

  v2 = a1;
  v3 = sub_739E8((int *)a1, a1[177], a2);
  if ( v3 )
    Curl_disconnect(v2);
  return v3;
}

//----- (00073BF4) --------------------------------------------------------
int (__fastcall *__fastcall Curl_done(int **a1, int a2, int a3))(int *, int, int)
{
  int **v3; // r9
  int *v4; // r4
  int v5; // r10
  int v6; // r8
  int v7; // r5
  int (__fastcall *result)(int *, int, int); // r0
  void *v9; // r0
  void *v10; // r0
  int v11; // r1
  int (__fastcall *v12)(int *, int, int); // r6
  void *v13; // r0
  int v14; // r3
  int v15; // r0
  int v16; // r3

  v3 = a1;
  v4 = *a1;
  v5 = a2;
  v6 = a3;
  v7 = **a1;
  Curl_expire((int *)**a1, 0);
  if ( *((_BYTE *)v4 + 316) )
    return 0;
  Curl_getoff_all_pipelines(v7, (int)v4);
  if ( *(_DWORD *)(v4[93] + 12) + *(_DWORD *)(v4[94] + 12) )
  {
    if ( !*(_BYTE *)(v7 + 674) && !*((_BYTE *)v4 + 296) )
      return 0;
  }
  *((_BYTE *)v4 + 316) = 1;
  v9 = *(void **)(v7 + 256);
  if ( v9 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v9);
    *(_DWORD *)(v7 + 256) = 0;
  }
  v10 = *(void **)(v7 + 252);
  if ( v10 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v10);
    *(_DWORD *)(v7 + 252) = 0;
  }
  v11 = v4[13];
  if ( v11 )
  {
    Curl_resolv_unlock(v7, v11);
    v4[13] = 0;
  }
  v12 = *(int (__fastcall **)(int *, int, int))(v4[80] + 12);
  if ( v12 )
    v12 = (int (__fastcall *)(int *, int, int))v12(v4, v5, v6);
  Curl_pgrsDone(v4);
  v13 = *(void **)(v7 + 33968);
  if ( v13 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v13);
    *(_DWORD *)(v7 + 33968) = 0;
  }
  ares_cancel(*(_DWORD **)(v7 + 34104));
  if ( *(_BYTE *)(v7 + 674) || *((_BYTE *)v4 + 296) || v6 || (v14 = v4[11], v14 == -1) )
  {
    v15 = Curl_disconnect((int **)v4);
    if ( !v12 )
      v12 = (int (__fastcall *)(int *, int, int))v15;
  }
  else
  {
    *((_BYTE *)v4 + 40) = 0;
    *(_DWORD *)(v7 + 1160) = v14;
    if ( *((_BYTE *)v4 + 299) )
      v16 = v4[40];
    else
      v16 = v4[36];
    Curl_infof(v7, "Connection #%ld to host %s left intact\n", v4[11], v16);
  }
  result = v12;
  *v3 = 0;
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00073D18) --------------------------------------------------------
signed int __fastcall Curl_do(int ***a1, int a2, int a3, int **a4)
{
  int **v4; // r3
  int *v5; // r8
  _BYTE *v6; // r7
  int v7; // r6
  signed int v8; // r3
  int v9; // r1
  int ****v10; // r3
  _DWORD *v11; // r3
  int v12; // r1
  int v13; // r3
  int v14; // r1
  int v15; // r1
  int (*v16)(void); // r3
  signed int result; // r0
  int *v18; // r4
  int (__fastcall *v19)(int *, int, int); // r0
  int *v20; // r0
  int **v21; // r3
  int *v22; // r1
  int *v23; // r2
  int *v24; // r3
  int ***v25; // [sp+0h] [bp-30h]
  int v26; // [sp+4h] [bp-2Ch]
  int v27; // [sp+8h] [bp-28h]
  int **v28; // [sp+Ch] [bp-24h]

  v25 = a1;
  v26 = a2;
  v27 = a3;
  v28 = a4;
  v4 = *a1;
  v5 = (int *)a1;
  v6 = (_BYTE *)a2;
  v28 = v4;
  v7 = (int)*v4;
  *((_BYTE *)v4 + 316) = 0;
  *((_BYTE *)v4 + 304) = 0;
  *(_BYTE *)(v7 + 34152) = 0;
  if ( *(_BYTE *)(v7 + 662) )
  {
    v8 = 5;
  }
  else
  {
    if ( *(_DWORD *)(v7 + 528) != 5 )
      goto LABEL_6;
    v8 = 1;
  }
  *(_DWORD *)(v7 + 528) = v8;
LABEL_6:
  Curl_easy_initHandleData(v7);
  curlx_tvnow((__time_t *)&v25);
  v9 = v26;
  v10 = (int ****)(v7 + 80);
  *v10 = v25;
  v10[1] = (int ***)v9;
  v11 = (_DWORD *)(v7 + 88);
  v12 = *(_DWORD *)(v7 + 84);
  *v11 = *(_DWORD *)(v7 + 80);
  v11[1] = v12;
  *(_DWORD *)(v7 + 232) = v7 + 1172;
  *(_DWORD *)(v7 + 236) = v7 + 17557;
  v13 = *(_DWORD *)(v7 + 1164);
  *(_BYTE *)(v7 + 96) = 1;
  *(_QWORD *)(v7 + 56) = 0LL;
  *(_DWORD *)(v7 + 108) = v13;
  *(_BYTE *)(v7 + 249) = 0;
  Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(4, v7)));
  Curl_speedinit(v7);
  Curl_pgrsSetUploadCounter(v7, v14, 0LL);
  Curl_pgrsSetDownloadCounter(v7, v15, 0LL);
  v16 = (int (*)(void))v28[80][2];
  if ( !v16 )
    return 0;
  v18 = (int *)v16();
  if ( v18 != (int *)((char *)&dword_34 + 3) )
    goto LABEL_18;
  if ( !*((_BYTE *)v28 + 297) )
    return (signed int)v18;
  Curl_infof(v7, "Re-used connection seems dead, get a new one\n");
  *((_BYTE *)v28 + 296) = 1;
  v19 = Curl_done((int **)&v28, 55, 0);
  v18 = (int *)v19;
  if ( v19 )
  {
    if ( v19 != (int (__fastcall *)(int *, int, int))((char *)&dword_34 + 3) )
      return (signed int)v18;
  }
  HIBYTE(v27) = 1;
  v18 = Curl_connect(v7, v5, (_BYTE *)&v27 + 2, (_BYTE *)&v27 + 3);
  if ( v18 )
    return (signed int)v18;
  v20 = (int *)*v5;
  v28 = (int **)*v5;
  if ( !BYTE2(v27)
    || (result = Curl_wait_for_resolv(v20, 0)) == 0 && (result = Curl_async_resolved(v28, (_BYTE *)&v27 + 3)) == 0 )
  {
    v18 = (int *)((int (*)(void))v28[80][2])();
LABEL_18:
    if ( !v18 )
    {
      if ( !*v6 )
        return 0;
      v21 = v28;
      *((_BYTE *)*v28 + 268) = 0;
      *((_BYTE *)*v21 + 272) = 0;
      v22 = v21[81];
      v23 = *v21;
      v24 = v21[82];
      if ( (signed int)v22 >= (signed int)v24 )
        v24 = v22;
      v23[60] = (int)v24 + 1;
    }
    return (signed int)v18;
  }
  return result;
}
// 34: using guessed type int dword_34;

//----- (00073E9C) --------------------------------------------------------
int __fastcall Curl_do_more(_DWORD *a1)
{
  _DWORD *v1; // r4
  int (*v2)(void); // r3
  int result; // r0
  int v4; // r2

  v1 = a1;
  v2 = *(int (**)(void))(a1[80] + 16);
  if ( !v2 || (result = v2()) == 0 )
  {
    result = 0;
    *(_BYTE *)(*v1 + 268) = 0;
    *(_BYTE *)(*v1 + 272) = 0;
    v4 = v1[82];
    if ( v1[81] >= v4 )
      v4 = v1[81];
    *(_DWORD *)(*v1 + 240) = v4 + 1;
  }
  return result;
}

//----- (00073ED4) --------------------------------------------------------
int __fastcall Curl_reset_reqproto(int a1)
{
  int v1; // r5
  int v2; // r4
  int result; // r0

  v1 = a1;
  v2 = *(_DWORD *)a1 + 34048;
  result = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  if ( result && *(_DWORD *)(v2 + 156) != v1 )
  {
    result = Curl_cfree(result);
    *(_DWORD *)(v2 + 152) = 0;
  }
  *(_DWORD *)(v2 + 156) = v1;
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00073F08) --------------------------------------------------------
_BYTE *__fastcall sub_73F08(int a1, char *a2, int a3)
{
  char *v3; // r5
  _BYTE *v5; // r4
  int v6; // r1
  int i; // r2
  unsigned int v8; // r3
  unsigned int v9; // t1
  char *v10; // [sp+4h] [bp-14h]
  int v11; // [sp+8h] [bp-10h]

  v10 = a2;
  v11 = a3;
  v3 = (char *)curl_easy_unescape(a1, a2, 0, &v10);
  if ( !v3 )
    return 0;
  v5 = malloc(2 * (_DWORD)v10 + 1);
  if ( !v5 )
    return 0;
  v6 = (int)(v3 - 1);
  for ( i = 0; ; ++i )
  {
    v9 = *(unsigned __int8 *)(v6++ + 1);
    v8 = v9;
    if ( !v9 )
      break;
    if ( v8 <= 0x20 || v8 == 127 || v8 == 39 || v8 == 34 || v8 == 92 )
      v5[i++] = 92;
    v5[i] = v8;
  }
  v5[i] = v8;
  free(v3);
  return v5;
}

//----- (00073F64) --------------------------------------------------------
char *__fastcall sub_73F64(int *a1, _BYTE *a2)
{
  int v2; // r5
  int *v3; // r7
  int v4; // r9
  char *v5; // r4
  char *v6; // r0
  char *v7; // r11
  const char *v8; // r4
  const char *v9; // r6
  char *v10; // r10
  char *v11; // r0
  int v12; // r2
  char *v13; // r0
  char *v14; // r0
  _BYTE *v15; // r10
  char *result; // r0
  signed int v17; // r4
  int v18; // r0
  _BOOL4 v19; // r0
  char *v20; // r0
  char *v21; // r10
  const char *v22; // r4
  char *v23; // r6
  char *v24; // r0
  int v25; // r2
  char *v26; // r0
  _BYTE *v27; // r0
  void *v28; // r6
  unsigned __int8 *v29; // r2
  int v30; // r1
  int v31; // t1
  int v32; // [sp+14h] [bp-2Ch]

  v2 = *a1;
  v3 = a1;
  v4 = a1[53];
  v5 = *(char **)(*a1 + 34180);
  v32 = *a1 + 56;
  *a2 = 1;
  if ( Curl_raw_nequal(v5, (int)"/MATCH:", 7)
    || Curl_raw_nequal(v5, (int)"/M:", 3)
    || Curl_raw_nequal(v5, (int)"/FIND:", 6) )
  {
    v6 = strchr(v5, 58);
    v7 = v6;
    if ( v6 )
    {
      v10 = v6 + 1;
      v11 = strchr(v6 + 1, 58);
      if ( v11 )
      {
        v9 = v11 + 1;
        *v11 = 0;
        v13 = strchr(v11 + 1, 58);
        if ( v13 )
        {
          v8 = v13 + 1;
          *v13 = 0;
          v14 = strchr(v13 + 1, 58);
          if ( v14 )
            *v14 = 0;
        }
        else
        {
          v8 = 0;
        }
      }
      else
      {
        v9 = 0;
        v8 = 0;
      }
      if ( v10 && v7[1] )
      {
LABEL_16:
        if ( v9 )
        {
          if ( !*v9 )
            v9 = "!";
        }
        else
        {
          v9 = "!";
        }
        if ( v8 )
        {
          if ( !*v8 )
            v8 = ".";
        }
        else
        {
          v8 = ".";
        }
        v15 = sub_73F08(v2, v10, v12);
        if ( v15 )
        {
          v17 = Curl_sendf(v4, v3, "CLIENT libcurl 7.19.6\r\nMATCH %s %s %s\r\nQUIT\r\n", v9, v8, v15);
          free(v15);
          if ( v17 )
          {
            v18 = v2;
LABEL_56:
            Curl_failf(v18, "Failed sending DICT request");
            return (char *)v17;
          }
          return (char *)Curl_setup_transfer(v3, v17, -1LL, v17, v32, -1, v17);
        }
        return (_BYTE *)(&dword_18 + 3);
      }
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    Curl_infof(v2, "lookup word is missing");
    v10 = "default";
    goto LABEL_16;
  }
  v19 = Curl_raw_nequal(v5, (int)"/DEFINE:", 8);
  if ( v19 || Curl_raw_nequal(v5, (int)"/D:", 3) || Curl_raw_nequal(v5, (int)"/LOOKUP:", 8) )
  {
    v20 = strchr(v5, 58);
    v21 = v20;
    if ( v20 )
    {
      v23 = v20 + 1;
      v24 = strchr(v20 + 1, 58);
      if ( v24 )
      {
        v22 = v24 + 1;
        *v24 = 0;
        v26 = strchr(v24 + 1, 58);
        if ( v26 )
          *v26 = 0;
      }
      else
      {
        v22 = 0;
      }
      if ( v23 && v21[1] )
      {
LABEL_41:
        if ( v22 )
        {
          if ( !*v22 )
            v22 = "!";
        }
        else
        {
          v22 = "!";
        }
        v27 = sub_73F08(v2, v23, v25);
        v28 = v27;
        if ( v27 )
        {
          v17 = Curl_sendf(v4, v3, "CLIENT libcurl 7.19.6\r\nDEFINE %s %s\r\nQUIT\r\n", v22, v27);
          free(v28);
          if ( v17 )
          {
            v18 = v2;
            goto LABEL_56;
          }
          return (char *)Curl_setup_transfer(v3, v17, -1LL, v17, v32, -1, v17);
        }
        return (_BYTE *)(&dword_18 + 3);
      }
    }
    else
    {
      v22 = 0;
    }
    Curl_infof(v2, "lookup word is missing");
    v23 = "default";
    goto LABEL_41;
  }
  result = strchr(v5, 47);
  if ( result )
  {
    v29 = (unsigned __int8 *)(result + 1);
    while ( 1 )
    {
      v31 = *v29++;
      v30 = v31;
      if ( !v31 )
        break;
      if ( v30 == 58 )
        *(v29 - 1) = 32;
    }
    v17 = Curl_sendf(v4, v3, "CLIENT libcurl 7.19.6\r\n%s\r\nQUIT\r\n");
    if ( v17 )
    {
      v18 = v2;
      goto LABEL_56;
    }
    return (char *)Curl_setup_transfer(v3, v17, -1LL, v17, v32, -1, v17);
  }
  return result;
}
// 18: using guessed type int dword_18;

//----- (000741F4) --------------------------------------------------------
const char *__fastcall Curl_if2ip(int a1, const char *a2, char *a3, socklen_t a4)
{
  socklen_t v4; // r9
  int v5; // r5
  char *v6; // r10
  const char *v7; // r6
  size_t v8; // r11
  int v9; // r4
  const char *v11; // r5
  int v12; // [sp+0h] [bp-50h]
  char s; // [sp+4h] [bp-4Ch]
  int af; // [sp+14h] [bp-3Ch]
  int v15; // [sp+18h] [bp-38h]

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  if ( !a2 )
    return 0;
  if ( a1 != 2 )
    return 0;
  v8 = strlen(a2);
  if ( v8 > 0xF )
    return 0;
  v9 = socket(v5, 1, 0);
  if ( v9 == -1 )
    return 0;
  memset(&s, 0, 0x20u);
  memcpy(&s, v7, v8 + 1);
  LOWORD(af) = v5;
  if ( ioctl(v9, 0x8915u, &s) < 0 )
  {
    close(v9);
    return 0;
  }
  v12 = v15;
  v11 = inet_ntop((unsigned __int16)af, &v12, v6, v4);
  close(v9);
  return v11;
}

//----- (0007429C) --------------------------------------------------------
void *__fastcall Curl_speedinit(int a1)
{
  return j_memset((void *)(a1 + 1152), 0, 8u);
}

//----- (000742A8) --------------------------------------------------------
signed int __fastcall Curl_speedcheck(int a1, int a2, int a3)
{
  int v3; // r6
  _QWORD *v4; // r4
  int *v5; // r8
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r4
  int v10; // r5
  bool v11; // zf
  bool v12; // nf
  unsigned __int8 v13; // vf
  int *v14; // r0
  signed int result; // r0
  int v16; // r1
  int v17; // [sp+0h] [bp-20h]
  int v18; // [sp+4h] [bp-1Ch]

  v17 = a2;
  v18 = a3;
  v3 = a1;
  v4 = (_QWORD *)(a1 + 928);
  v5 = (int *)(a1 + 1152);
  if ( (signed int)(*(_QWORD *)(a1 + 928) >> 32) >= 0
    && *(_DWORD *)(a1 + 452)
    && (v6 = *v5, Curl_tvlong(), v7)
    && *v4 < (signed __int64)*(signed int *)(v3 + 448) )
  {
    v8 = curlx_tvdiff(v17, v18, *v5, v5[1]);
    v9 = *(_DWORD *)(v3 + 452);
    v10 = v8;
    v8 /= 1000;
    v13 = __OFSUB__(v8, v9);
    v11 = v8 == v9;
    v12 = v8 - v9 < 0;
    v14 = (int *)v3;
    if ( !((unsigned __int8)(v12 ^ v13) | v11) )
    {
      Curl_failf(
        v3,
        "Operation too slow. Less than %d bytes/sec transfered the last %d seconds",
        *(_DWORD *)(v3 + 448),
        *(_DWORD *)(v3 + 452),
        v17,
        v18);
      return 28;
    }
    v16 = v10;
  }
  else
  {
    *v5 = v17;
    v5[1] = v18;
    result = *(_DWORD *)(v3 + 448);
    if ( !result )
      return result;
    v14 = (int *)v3;
    v16 = 1000 * *(_DWORD *)(v3 + 452);
  }
  Curl_expire(v14, v16);
  return 0;
}

//----- (00074348) --------------------------------------------------------
int __fastcall curl_getenv(const char *a1)
{
  char *v1; // r0
  int v2; // r3
  int result; // r0

  v1 = getenv(a1);
  v2 = (int)v1;
  if ( v1 && (v2 = (unsigned __int8)*v1, *v1) )
    result = Curl_cstrdup(v1);
  else
    result = v2;
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (0007436C) --------------------------------------------------------
int __fastcall curl_easy_escape(int a1, const char *a2, int a3)
{
  const char *v3; // r9
  unsigned int v4; // r5
  int v5; // r4
  int v6; // r8
  unsigned int v7; // r10
  int v8; // r6
  unsigned int v9; // r7
  bool v10; // cf
  bool v11; // zf
  int v13; // r0
  int v14; // [sp+0h] [bp-30h]
  int v15; // [sp+4h] [bp-2Ch]

  v14 = a1;
  v3 = a2;
  if ( a3 )
    v4 = a3 + 1;
  else
    v4 = strlen(a2) + 1;
  v5 = Curl_cmalloc(v4);
  if ( !v5 )
    return v5;
  v6 = 0;
  v7 = v4;
  v8 = 0;
  v15 = v4 - 1;
  while ( 1 )
  {
    if ( v6 == v15 )
    {
      *(_BYTE *)(v5 + v8) = 0;
      return v5;
    }
    v9 = (unsigned __int8)v3[v6];
    if ( v9 > 0x5A )
    {
      v10 = v9 - 97 >= 0x19;
      v11 = v9 == 122;
    }
    else
    {
      if ( v9 >= 0x41 )
        goto LABEL_15;
      v10 = v9 - 48 >= 9;
      v11 = v9 == 57;
    }
    if ( v11 || !v10 )
    {
LABEL_15:
      *(_BYTE *)(v5 + v8++) = v9;
      goto LABEL_16;
    }
    v7 += 2;
    if ( v7 > v4 )
      break;
LABEL_21:
    curl_msnprintf(v5 + v8, 4, "%%%02X", v9, v14);
    v8 += 3;
LABEL_16:
    ++v6;
  }
  v4 *= 2;
  v13 = Curl_crealloc(v5, v4);
  if ( v13 )
  {
    v5 = v13;
    goto LABEL_21;
  }
  Curl_cfree(v5);
  return 0;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00074430) --------------------------------------------------------
int __fastcall curl_escape(const char *a1, int a2)
{
  return curl_easy_escape(0, a1, a2);
}

//----- (0007443C) --------------------------------------------------------
int __fastcall curl_easy_unescape(int a1, char *a2, int a3, _DWORD *a4)
{
  char *v4; // r4
  _DWORD *v5; // r8
  int v6; // r6
  int v7; // r7
  int v8; // r5
  int v9; // r2
  int v10; // r12
  int v11; // r3
  char v12; // r0
  int v14; // [sp+0h] [bp-30h]
  char *endptr; // [sp+4h] [bp-2Ch]
  int v16; // [sp+8h] [bp-28h]

  v14 = a1;
  endptr = a2;
  v16 = a3;
  v4 = a2;
  v5 = a4;
  if ( a3 )
    v6 = a3 + 1;
  else
    v6 = strlen(a2) + 1;
  v7 = Curl_cmalloc(v6);
  if ( v7 )
  {
    v8 = 0;
    while ( 1 )
    {
      v9 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      v10 = (unsigned __int8)*v4;
      if ( v10 == 37 && *(_BYTE *)(ctype_ + (unsigned __int8)v4[1] + 1) & 0x44 )
      {
        v11 = (unsigned __int8)v4[2];
        if ( *(_BYTE *)(ctype_ + v11 + 1) & 0x44 )
        {
          LOBYTE(v14) = v4[1];
          *(_WORD *)((char *)&v14 + 1) = (unsigned __int8)v11;
          v4 += 2;
          v12 = strtol((const char *)&v14, &endptr, 16);
          v9 = v6 - 3;
          LOBYTE(v10) = v12;
        }
      }
      *(_BYTE *)(v7 + v8) = v10;
      ++v4;
      ++v8;
      v6 = v9;
    }
    *(_BYTE *)(v7 + v8) = 0;
    if ( v5 )
      *v5 = v8;
  }
  return v7;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000744E4) --------------------------------------------------------
int __fastcall curl_unescape(char *a1, int a2)
{
  return curl_easy_unescape(0, a1, a2, 0);
}

//----- (000744F4) --------------------------------------------------------
int __fastcall curl_free(int result)
{
  if ( result )
    result = Curl_cfree(result);
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00074508) --------------------------------------------------------
int __fastcall sub_74508(unsigned __int8 *a1, _DWORD *a2)
{
  int i; // r3
  int v3; // r2
  int v4; // t1
  int v5; // r4

  for ( i = 0; ; i = v5 + 10 * i )
  {
    v4 = *a1++;
    v3 = v4;
    v5 = v4 - 48;
    if ( (unsigned int)(v4 - 48) > 9 )
      break;
  }
  if ( !i )
    return i;
  if ( v3 == 36 )
  {
    *a2 = a1;
    return i;
  }
  return 0;
}

//----- (00074530) --------------------------------------------------------
signed int __fastcall sub_74530(signed int result, _DWORD *a2)
{
  result = (unsigned __int8)result;
  if ( a2[1] >= a2[2] )
    return -1;
  *(_BYTE *)(*a2)++ = result;
  ++a2[1];
  return result;
}

//----- (00074554) --------------------------------------------------------
signed int __fastcall sub_74554(unsigned __int8 a1, int *a2)
{
  int *v2; // r4
  int v3; // r5
  signed int v4; // r6
  int v5; // r0
  unsigned int v6; // r1
  int v7; // r0
  signed int result; // r0
  int v9; // r3

  v2 = a2;
  v3 = *a2;
  v4 = a1;
  if ( *a2 )
  {
    v6 = a2[2];
    if ( v2[1] + 1 < v6 )
      goto LABEL_8;
    v7 = Curl_crealloc(v3, 2 * v6);
    if ( v7 )
    {
      v9 = v2[2];
      *v2 = v7;
      v2[2] = 2 * v9;
      goto LABEL_8;
    }
LABEL_6:
    result = -1;
    v2[3] = 1;
    return result;
  }
  v5 = Curl_cmalloc(32);
  *v2 = v5;
  if ( !v5 )
    goto LABEL_6;
  v2[1] = 0;
  v2[2] = 32;
LABEL_8:
  result = v4;
  *(_BYTE *)(*v2 + v2[1]++) = v4;
  return result;
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000745CA) --------------------------------------------------------
char *curl_msnprintf(int a1, int a2, const char *a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp-4h]

  va_start(varg_r3, a3);
  return curl_mvsnprintf((_BYTE *)a1, a2, (char *)a3, (int)varg_r3);
}

//----- (000745E4) --------------------------------------------------------
char *__fastcall sub_745E4(int a1, int (__fastcall *a2)(signed int, int), char *a3, int a4)
{
  signed int v4; // r9
  int v5; // r10
  char *v6; // r7
  signed int v7; // r11
  unsigned int v8; // r8
  char *v9; // r5
  int v10; // r6
  char *v11; // r3
  signed int v12; // r0
  unsigned __int8 *v13; // r0
  int v14; // r0
  unsigned int v15; // r4
  char *result; // r0
  unsigned int v17; // r3
  bool v18; // zf
  char *v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r2
  int v23; // r3
  _QWORD *v24; // r3
  __int64 v25; // r2
  _QWORD *v26; // r3
  char *v27; // r3
  int v28; // r0
  int v29; // r0
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r2
  int v33; // r4
  __int64 v34; // r2
  _BYTE *v35; // r2
  int v36; // r4
  signed int v37; // r0
  int v38; // r3
  int v39; // r3
  int v40; // r0
  int v41; // r4
  unsigned int i; // r3
  int v43; // r4
  int v44; // r3
  int v45; // r2
  int v46; // r4
  int v47; // r3
  unsigned int v48; // r3
  char *v49; // r4
  signed int v50; // r5
  size_t v51; // r0
  char *v52; // r0
  int v53; // r3
  char v54; // r3
  _QWORD *v55; // r1
  char *v56; // r3
  unsigned int v57; // r3
  int v58; // r0
  int v59; // r0
  int v60; // r2
  signed int v61; // r3
  char *v62; // r1
  signed int v63; // r1
  char *v64; // r3
  _DWORD *v65; // r3
  _DWORD *v66; // r3
  int v67; // r3
  _DWORD *v68; // r3
  int v69; // [sp+0h] [bp-240h]
  int v70; // [sp+4h] [bp-23Ch]
  int (__fastcall *v71)(signed int, int); // [sp+8h] [bp-238h]
  signed __int64 v72; // [sp+10h] [bp-230h]
  const char *v73; // [sp+18h] [bp-228h]
  char *v74; // [sp+1Ch] [bp-224h]
  char **v75; // [sp+20h] [bp-220h]
  int v76; // [sp+24h] [bp-21Ch]
  char *endptr; // [sp+3Ch] [bp-204h]
  char v78; // [sp+40h] [bp-200h]
  char v79[40]; // [sp+240h] [bp+0h]
  char v80; // [sp+268h] [bp+28h]
  char dest[4]; // [sp+E44h] [bp+C04h]
  char s; // [sp+E48h] [bp+C08h]
  char v83[255]; // [sp+E64h] [bp+C24h]
  char v84; // [sp+F63h] [bp+D23h]
  int v85; // [sp+F64h] [bp+D24h]
  char v86[4]; // [sp+F68h] [bp+D28h]

  v6 = 0;
  v74 = a3;
  v7 = (signed int)v79;
  v8 = 0;
  v71 = a2;
  v9 = 0;
  v10 = a4;
  v70 = a1;
  endptr = a3;
  LODWORD(v72) = &v78;
LABEL_2:
  while ( 1 )
  {
    v11 = endptr;
    v12 = (unsigned __int8)*endptr;
    if ( !*endptr )
      break;
    v13 = (unsigned __int8 *)(endptr++ + 1);
    if ( *v11 == 37 )
    {
      if ( v11[1] != 37 )
      {
        ++v8;
        v14 = sub_74508(v13, &endptr);
        v15 = 0;
        v5 = 0;
        v4 = 0;
        if ( !v14 )
          v14 = v8;
        v73 = (const char *)v14;
        if ( (signed int)v6 < v14 )
          v6 = (char *)v14;
        goto LABEL_10;
      }
      endptr = v11 + 2;
    }
  }
  v19 = &v80;
  v9 = (_BYTE *)(&dword_0 + 3);
  while ( v12 < (signed int)v6 )
  {
    if ( ++v12 < (signed int)v6 && *((_DWORD *)v19 - 4) == 9 )
    {
      v20 = *(_DWORD *)v10;
      v10 += 4;
      *(_QWORD *)v19 = v20;
    }
    switch ( *((_DWORD *)v19 - 10) )
    {
      case 0:
      case 1:
      case 2:
      case 4:
        v21 = *(_DWORD *)v10;
        v10 += 4;
        *((_DWORD *)v19 - 6) = v21;
        break;
      case 3:
        v22 = *((_DWORD *)v19 - 9);
        if ( (*((_DWORD *)v19 - 9) & 0x240) == 576 || (v23 = *((_DWORD *)v19 - 9), v23 & 0x40) )
        {
          v24 = (_QWORD *)((v10 + 7) & 0xFFFFFFF8);
          v10 = (int)(v24 + 1);
          *((_QWORD *)v19 - 3) = *v24;
        }
        else
        {
          v18 = (v22 & 0x220) == 544;
          LODWORD(v25) = *(_DWORD *)v10;
          if ( v18 || !(v23 & 0x20) && v23 & 0x200 )
            HIDWORD(v25) = 0;
          else
            v25 = (signed int)v25;
          *((_QWORD *)v19 - 3) = v25;
          v10 += 4;
        }
        break;
      case 7:
        v26 = (_QWORD *)((v10 + 7) & 0xFFFFFFF8);
        v10 = (int)(v26 + 1);
        *((_QWORD *)v19 - 3) = *v26;
        break;
      case 9:
        *((_DWORD *)v19 - 10) = 3;
        break;
      default:
        break;
    }
    v19 += 24;
  }
  v8 = 0;
  v10 = 0;
  endptr = v74;
  v75 = (char **)&v78;
  v73 = "0123456789abcdefghijklmnopqrstuvwxyz";
  while ( 1 )
  {
LABEL_48:
    v27 = endptr;
    if ( !*endptr )
      goto LABEL_244;
    if ( *endptr != 37 )
      break;
    ++endptr;
    if ( v27[1] != 37 )
    {
      v28 = sub_74508((unsigned __int8 *)v27 + 1, &endptr);
      if ( v28 )
        v29 = v28 - 1;
      else
        v29 = v8;
      v4 = 24;
      v9 = v79;
      v30 = 24 * v29;
      v76 = v8 + 1;
      v6 = &v79[v30];
      v31 = *(_DWORD *)&v79[v30 + 4];
      v32 = *(char **)&v79[v30 + 8];
      if ( v31 & 0x4000 )
        v32 = &v79[24 * (_DWORD)v32];
      else
        v4 = *(_DWORD *)&v79[v30 + 8];
      if ( v31 & 0x4000 )
        v4 = *((_DWORD *)v32 + 4);
      v5 = v31 & 0x10000;
      if ( v31 & 0x10000 )
      {
        v76 = v8 + 2;
        v7 = *(_DWORD *)&v79[24 * *((_DWORD *)v6 + 3) + 16];
      }
      else if ( *(_DWORD *)&v79[v30 + 4] << 16 >= 0 )
      {
        v7 = -1;
      }
      else
      {
        v7 = *((_DWORD *)v6 + 3);
      }
      v8 = (v31 >> 3) & 1;
      v74 = (char *)((v31 >> 3) & 1);
      switch ( *(_DWORD *)&v79[v30] )
      {
        case 1:
          v9 = (char *)*((_DWORD *)v6 + 4);
          if ( v9 )
          {
            v8 = strlen(*((const char **)v6 + 4));
LABEL_153:
            if ( v7 != -1 )
              goto LABEL_156;
          }
          else
          {
            if ( v7 == -1 || v7 > 4 )
            {
              v8 = 5;
              *((_DWORD *)v6 + 1) = v31 & 0xFFFFFFF7;
              v9 = "(nil)";
              goto LABEL_153;
            }
            v8 = *((_DWORD *)v6 + 4);
            v9 = &byte_E4496;
LABEL_156:
            if ( v8 >= v7 )
              v8 = v7;
          }
          v4 -= v8;
          if ( *((_DWORD *)v6 + 1) & 8 )
          {
            if ( v71(34, v70) == -1 )
              goto LABEL_244;
            ++v10;
          }
          v44 = *((_DWORD *)v6 + 1);
          v45 = v44 << 29;
          if ( !(v44 & 4) )
          {
            v46 = v10 + v4;
            while ( 1 )
            {
              v10 = v46 - v4--;
              if ( v4 + 1 <= 0 )
                break;
              if ( v71(32, v70) == -1 )
                goto LABEL_244;
            }
          }
          v8 += v10;
          v9 -= v10;
          while ( v10 != v8 )
          {
            if ( ((int (__fastcall *)(_DWORD, int, int))v71)((unsigned __int8)v9[v10], v70, v45) == -1 )
              goto LABEL_244;
            ++v10;
          }
          if ( *((_DWORD *)v6 + 1) & 4 )
          {
            v4 += v10;
            while ( v4 - v10 > 0 )
            {
              if ( ((int (__fastcall *)(signed int, int, int))v71)(32, v70, v45) == -1 )
                goto LABEL_244;
              ++v10;
            }
          }
          v47 = *((_DWORD *)v6 + 1);
          v6 = (char *)(v47 << 28);
          if ( v47 & 8 )
          {
            if ( ((int (__fastcall *)(signed int, int, int))v71)(34, v70, v45) == -1 )
              goto LABEL_244;
            ++v10;
          }
          goto def_74836;
        case 2:
          v48 = *((_DWORD *)v6 + 4);
          if ( v48 )
          {
            if ( v31 & 0x1000 )
              v73 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            else
              v73 = "0123456789abcdefghijklmnopqrstuvwxyz";
            v72 = v48;
            v5 = 16;
            v9 = 0;
            v74 = (_BYTE *)(&dword_0 + 1);
            goto LABEL_94;
          }
          v9 = (char *)(v4 - 5);
          if ( v31 & 4 )
          {
            v4 += v10 - 5;
            while ( 1 )
            {
              v10 = v4 - (_DWORD)v9--;
              if ( (signed int)(v9 + 1) <= 0 )
                break;
              if ( v71(32, v70) == -1 )
                goto LABEL_244;
            }
          }
          v49 = &aNil_0[-v10];
          while ( v49[v10] )
          {
            if ( ((int (*)(void))v71)() == -1 )
              goto LABEL_244;
            ++v10;
          }
          if ( !(*((_DWORD *)v6 + 1) & 4) )
          {
            v9 += v10;
            while ( (signed int)&v9[-v10] > 0 )
            {
              if ( v71(32, v70) == -1 )
                goto LABEL_244;
              ++v10;
            }
          }
          goto def_74836;
        case 3:
          v72 = *((_QWORD *)v6 + 2);
          if ( v31 & 0x20000 )
          {
            if ( !(v31 & 4) )
            {
              v33 = v4 + v10;
              while ( 1 )
              {
                v10 = v33 - v4--;
                if ( v4 <= 0 )
                  break;
                if ( v71(32, v70) == -1 )
                  goto LABEL_244;
              }
            }
            if ( v71((unsigned __int8)v72, v70) == -1 )
              goto LABEL_244;
            ++v10;
            if ( *((_DWORD *)v6 + 1) & 4 )
            {
              while ( --v4 > 0 )
              {
                if ( v71(32, v70) == -1 )
                  goto LABEL_244;
                ++v10;
              }
            }
            goto def_74836;
          }
          if ( v31 & 0x200 )
          {
            v5 = 10;
            v9 = (char *)(v31 & 0x20000);
            goto LABEL_94;
          }
          if ( v31 & 0x400 )
          {
            v5 = 8;
LABEL_93:
            v9 = 0;
            goto LABEL_94;
          }
          if ( !(v31 & 0x800) )
          {
            if ( v72 < 0 )
            {
              v5 = 10;
              v9 = (_BYTE *)(&dword_0 + 1);
              LODWORD(v34) = -(signed int)v72;
              HIDWORD(v34) = HIDWORD(v72) - (2 * HIDWORD(v72) + ((unsigned int)v72 > 0));
              v72 = v34;
              goto LABEL_94;
            }
            v5 = 10;
            goto LABEL_93;
          }
          v5 = 16;
          if ( v31 & 0x1000 )
          {
            v9 = 0;
            v73 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          }
          else
          {
            v9 = 0;
            v73 = "0123456789abcdefghijklmnopqrstuvwxyz";
          }
LABEL_94:
          if ( v7 == -1 )
            v7 = 1;
          v8 = (unsigned int)&v84;
          while ( v72 )
          {
            *(_BYTE *)v8-- = v73[v72 % (unsigned __int64)v5];
            v72 /= (unsigned __int64)v5;
          }
          v35 = (_BYTE *)v8;
          v4 += v8 - (_DWORD)&v84;
          v7 += v8 - (_DWORD)&v84;
          if ( v74 && v5 == 8 )
          {
            if ( v7 <= 0 )
            {
              --v8;
              *v35 = 48;
              --v4;
              goto LABEL_110;
            }
          }
          else if ( v7 <= 0 )
          {
            goto LABEL_107;
          }
          v4 -= v7;
          v7 -= v8;
          while ( (signed int)(v8 + v7) > 0 )
            *(_BYTE *)v8-- = 48;
LABEL_107:
          if ( v74 && v5 == 16 )
            v4 -= 2;
LABEL_110:
          if ( v9 || *(_DWORD *)&v79[v30 + 4] << 30 )
            --v4;
          if ( !(*((_DWORD *)v6 + 1) & 0x104) )
          {
            v36 = v4 + v10;
            while ( 1 )
            {
              v10 = v36 - v4--;
              if ( v4 + 1 <= 0 )
                break;
              if ( v71(32, v70) == -1 )
                goto LABEL_244;
            }
          }
          if ( v9 )
          {
            v37 = 45;
          }
          else
          {
            v38 = *((_DWORD *)v6 + 1);
            if ( v38 & 2 )
            {
              v37 = 43;
            }
            else
            {
              if ( !(v38 & 1) )
                goto LABEL_126;
              v37 = 32;
            }
          }
          if ( v71(v37, v70) == -1 )
            goto LABEL_244;
          ++v10;
LABEL_126:
          if ( v74 && v5 == 16 )
          {
            if ( v71(48, v70) == -1 )
              goto LABEL_244;
            v39 = *((_DWORD *)v6 + 1);
            v9 = (char *)(v39 << 19);
            if ( v39 & 0x1000 )
              v40 = v71(88, v70);
            else
              v40 = v71(120, v70);
            if ( v40 == -1 )
            {
              result = (char *)(v10 + 1);
              goto LABEL_245;
            }
            v10 += 2;
          }
          if ( (*((_DWORD *)v6 + 1) & 0x104) == 256 )
          {
            v41 = v10 + v4;
            while ( 1 )
            {
              v10 = v41 - v4--;
              if ( v4 + 1 <= 0 )
                break;
              if ( v71(48, v70) == -1 )
                goto LABEL_244;
            }
          }
          v5 = v10 - v8;
          v9 = &v84;
          for ( i = v8; ; i = v43 )
          {
            v43 = i + 1;
            v10 = v5 + i;
            if ( i + 1 > (unsigned int)&v84 )
              break;
            if ( v71(*(unsigned __int8 *)(i + 1), v70) == -1 )
              goto LABEL_244;
          }
          if ( *((_DWORD *)v6 + 1) & 4 )
          {
            v4 += v10;
            while ( v4 - v10 > 0 )
            {
              if ( v71(32, v70) == -1 )
                goto LABEL_244;
              ++v10;
            }
          }
def_74836:
          v8 = v76;
          v56 = *v75;
          ++v75;
          endptr = v56;
          continue;
        case 4:
          v55 = (_QWORD *)*((_DWORD *)v6 + 4);
          if ( v31 & 0x40 )
          {
            *v55 = v10;
          }
          else if ( !(v31 & 0x20) && v31 & 0x10 )
          {
            *(_WORD *)v55 = v10;
          }
          else
          {
            *(_DWORD *)v55 = v10;
          }
          goto def_74836;
        case 7:
          *(_DWORD *)dest = 37;
          v69 = v31 & 0x4000;
          memset(&s, 0, 0x1Cu);
          v4 = 32 - strlen(dest);
          if ( v31 & 0x2000 )
          {
            v7 = *((_DWORD *)v6 + 2);
          }
          else if ( v31 & 0x4000 )
          {
            v7 = *(_DWORD *)&v79[24 * *((_DWORD *)v6 + 2) + 16];
          }
          else
          {
            v7 = -1;
          }
          if ( v31 & 0x8000 )
          {
            v50 = *((_DWORD *)v6 + 3);
          }
          else if ( v5 )
          {
            v50 = *(_DWORD *)&v79[24 * *((_DWORD *)v6 + 3) + 16];
          }
          else
          {
            v50 = -1;
          }
          if ( v31 & 4 )
            strcat(dest, "-");
          if ( v31 & 2 )
            strcat(dest, "+");
          if ( v31 & 1 )
            strcat(dest, (const char *)&unk_E49A3);
          if ( v8 )
            strcat(dest, "#");
          v51 = strlen(dest);
          v8 = (unsigned int)&dest[v51];
          if ( v7 >= 0 )
          {
            v52 = curl_msnprintf((int)&dest[v51], v4, "%ld", v7, v69);
            v8 += (unsigned int)v52;
            v4 -= (signed int)v52;
          }
          if ( v50 >= 0 )
            v8 += (unsigned int)curl_msnprintf(v8, v4, ".%ld", v50, v69);
          if ( *((_DWORD *)v6 + 1) & 0x20 )
            *(_BYTE *)(++v8 - 1) = 108;
          v53 = *((_DWORD *)v6 + 1);
          if ( v53 & 0x40000 )
          {
            if ( v53 & 0x1000 )
              v54 = 69;
            else
              v54 = 101;
          }
          else if ( v53 & 0x80000 )
          {
            if ( v53 & 0x1000 )
              v54 = 71;
            else
              v54 = 103;
          }
          else
          {
            v54 = 102;
          }
          *(_BYTE *)v8 = v54;
          *(_BYTE *)(v8 + 1) = 0;
          v9 = &v83[-v10];
          sprintf(v83, dest, *((_QWORD *)v6 + 2), v69);
          while ( 2 )
          {
            if ( !v9[v10] )
              goto def_74836;
            if ( ((int (*)(void))v71)() != -1 )
            {
              ++v10;
              continue;
            }
            goto LABEL_244;
          }
        default:
          goto def_74836;
      }
    }
    endptr = v27 + 2;
    if ( ((int (*)(void))v71)() == -1 )
      goto LABEL_244;
    ++v10;
  }
  while ( v71((unsigned __int8)*endptr, v70) != -1 )
  {
    ++v10;
    if ( !*++endptr || *endptr == 37 )
      goto LABEL_48;
  }
LABEL_244:
  result = (char *)v10;
LABEL_245:
  v15 = (unsigned int)&_stack_chk_guard;
  if ( v85 != _stack_chk_guard )
  {
    while ( 1 )
    {
      endptr = result + 1;
      v57 = (unsigned __int8)*result;
      if ( v57 > 0x39 )
      {
        if ( v57 == 104 )
        {
          v15 |= 0x10u;
        }
        else
        {
          if ( v57 > 0x68 )
          {
            if ( v57 != 113 )
            {
              if ( v57 == 122 )
                goto LABEL_336;
              if ( v57 != 108 )
                goto LABEL_10;
              if ( !(v15 & 0x20) )
              {
LABEL_336:
                v15 |= 0x20u;
                goto LABEL_10;
              }
            }
LABEL_284:
            v15 |= 0x40u;
            goto LABEL_10;
          }
          if ( v57 == 76 )
          {
            v15 |= 0x80u;
          }
          else if ( v57 == 79 )
          {
            goto LABEL_284;
          }
        }
      }
      else
      {
        if ( v57 < 0x31 )
        {
          if ( v57 == 43 )
          {
            v15 |= 2u;
            goto LABEL_10;
          }
          if ( v57 <= 0x2B )
          {
            switch ( v57 )
            {
              case 0x23u:
                v15 |= 8u;
                break;
              case 0x2Au:
                v58 = sub_74508((unsigned __int8 *)result + 1, &endptr);
                ++v8;
                v15 |= 0x4000u;
                if ( v58 )
                  v4 = v58;
                else
                  v4 = v8;
                if ( (signed int)v6 < v4 )
                  v6 = (char *)v4;
                break;
              case 0x20u:
                v15 |= 1u;
                break;
            }
            goto LABEL_10;
          }
          if ( v57 == 46 )
          {
            if ( result[1] == 42 )
            {
              endptr = result + 2;
              v59 = sub_74508((unsigned __int8 *)result + 2, &endptr);
              ++v8;
              v15 |= 0x18000u;
              if ( v59 )
                v5 = v59;
              else
                v5 = v8;
              if ( (signed int)v6 < v5 )
                v6 = (char *)v5;
            }
            else
            {
              v15 |= 0x8000u;
              v5 = strtol(result + 1, &endptr, 10);
            }
            goto LABEL_10;
          }
          if ( v57 != 48 )
          {
            if ( v57 == 45 )
              v15 = v15 & 0xFFFFFEFF | 4;
            goto LABEL_10;
          }
          if ( !(v15 & 4) )
            v15 |= 0x100u;
        }
        v15 |= 0x2000u;
        v4 = strtol(result, &endptr, 10);
      }
LABEL_10:
      result = endptr;
      v17 = (unsigned __int8)*endptr;
      if ( v17 > 0x39 )
      {
        if ( v17 != 104 )
        {
          if ( v17 > 0x68 )
          {
            if ( v17 != 113 && v17 != 122 )
            {
              v18 = v17 == 108;
              goto LABEL_25;
            }
          }
          else if ( v17 != 76 )
          {
            v18 = v17 == 79;
            goto LABEL_25;
          }
        }
      }
      else if ( v17 < 0x30 )
      {
        if ( v17 > 0x2B )
        {
          if ( v17 - 45 > 1 )
            goto LABEL_291;
        }
        else if ( v17 < 0x2A && v17 != 32 )
        {
          v18 = v17 == 35;
LABEL_25:
          if ( !v18 )
          {
LABEL_291:
            v60 = (int)(v73 - 1);
            if ( v17 == 102 )
            {
              v61 = 7;
              v62 = &v86[24 * v60 - 3368];
              goto LABEL_293;
            }
            if ( v17 <= 0x66 )
            {
              if ( v17 == 88 )
              {
                v15 |= 0x1800u;
                *(_DWORD *)&v86[24 * v60 - 3368] = 3;
                goto LABEL_298;
              }
              if ( v17 <= 0x58 )
              {
                switch ( v17 )
                {
                  case 0x47u:
                    v15 |= 0x81000u;
                    *(_DWORD *)&v86[24 * v60 - 3368] = 7;
                    goto LABEL_298;
                  case 0x53u:
                    v15 |= 8u;
                    goto LABEL_296;
                  case 0x45u:
                    v15 |= 0x41000u;
                    *(_DWORD *)&v86[24 * v60 - 3368] = 7;
                    goto LABEL_298;
                }
LABEL_311:
                *(_DWORD *)&v86[24 * v60 - 3368] = v9;
                goto LABEL_298;
              }
              if ( v17 != 100 )
              {
                if ( v17 <= 0x64 )
                {
                  if ( v17 != 99 )
                    goto LABEL_311;
                  v15 |= 0x20000u;
                  *(_DWORD *)&v86[24 * v60 - 3368] = 3;
                }
                else
                {
                  v15 |= 0x40000u;
                  *(_DWORD *)&v86[24 * v60 - 3368] = 7;
                }
                goto LABEL_298;
              }
LABEL_313:
              v63 = 3;
              v64 = &v86[24 * v60 - 3368];
LABEL_297:
              *(_DWORD *)v64 = v63;
              goto LABEL_298;
            }
            if ( v17 == 111 )
            {
              v15 |= 0x400u;
              *(_DWORD *)&v86[24 * v60 - 3368] = 3;
              goto LABEL_298;
            }
            if ( v17 <= 0x6F )
            {
              if ( v17 == 105 )
                goto LABEL_313;
              if ( v17 != 110 )
              {
                if ( v17 != 103 )
                  goto LABEL_311;
                v15 |= 0x80000u;
                *(_DWORD *)&v86[24 * v60 - 3368] = 7;
                goto LABEL_298;
              }
              v61 = 4;
              v62 = &v86[24 * v60 - 3368];
LABEL_293:
              *(_DWORD *)v62 = v61;
              goto LABEL_298;
            }
            if ( v17 == 115 )
            {
LABEL_296:
              v63 = 1;
              v64 = &v86[24 * v60 - 3368];
              goto LABEL_297;
            }
            if ( v17 <= 0x73 )
            {
              if ( v17 != 112 )
                goto LABEL_311;
              v61 = 2;
              v62 = &v86[24 * v60 - 3368];
              goto LABEL_293;
            }
            if ( v17 == 117 )
            {
              v15 |= 0x200u;
              *(_DWORD *)&v86[24 * v60 - 3368] = 3;
            }
            else
            {
              if ( v17 != 120 )
                goto LABEL_311;
              v15 |= 0x800u;
              *(_DWORD *)&v86[24 * v60 - 3368] = 3;
            }
LABEL_298:
            v65 = (_DWORD *)(v7 + 24 * v60);
            v65[1] = v15;
            v65[2] = v4;
            v65[3] = v5;
            if ( v15 & 0x4000 )
            {
              v60 = v4 - 1;
              v65[2] = v4 - 1;
              v66 = (_DWORD *)(v7 + 24 * (v4 - 1));
              *v66 = 9;
              v66[1] = v9;
              v66[2] = v9;
              v66[3] = v9;
            }
            if ( v15 & 0x10000 )
            {
              v67 = v5 - 1;
              v5 = 24 * (v5 - 1);
              *(_DWORD *)&v86[24 * v60 - 3356] = v67;
              v68 = (_DWORD *)(v7 + v5);
              *(_DWORD *)(v7 + v5) = 9;
              v68[1] = v9;
              v68[2] = v9;
              v68[3] = v9;
            }
            *(_DWORD *)v72 = result + 1;
            LODWORD(v72) = v72 + 4;
            goto LABEL_2;
          }
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// E4496: using guessed type char byte_E4496;
// 745E4: using guessed type char var_D2C[40];
// 745E4: using guessed type char var_108[255];
// 745E4: using guessed type char var_4[4];

//----- (00075110) --------------------------------------------------------
char *__fastcall curl_mvsnprintf(_BYTE *a1, int a2, char *a3, int a4)
{
  char *result; // r0
  _BYTE *v5; // [sp+4h] [bp-14h]
  int v6; // [sp+8h] [bp-10h]
  int v7; // [sp+Ch] [bp-Ch]

  v7 = a2;
  v5 = a1;
  v6 = 0;
  result = sub_745E4((int)&v5, (int (__fastcall *)(signed int, int))sub_74530, a3, a4);
  if ( v7 )
  {
    if ( v7 == v6 )
      *(v5 - 1) = 0;
    else
      *v5 = 0;
  }
  return result;
}

//----- (00075140) --------------------------------------------------------
void *curl_maprintf(char *a1, ...)
{
  bool v1; // zf
  void *result; // r0
  void *ptr; // [sp+8h] [bp-28h]
  int v4; // [sp+Ch] [bp-24h]
  void *v5; // [sp+10h] [bp-20h]
  int v6; // [sp+14h] [bp-1Ch]
  char *varg_r0; // [sp+20h] [bp-10h]
  va_list varg_r1; // [sp+24h] [bp-Ch]

  va_start(varg_r1, a1);
  varg_r0 = a1;
  ptr = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v1 = sub_745E4((int)&ptr, (int (__fastcall *)(signed int, int))sub_74554, a1, (int)varg_r1) + 1 == 0;
  result = v5;
  if ( v1 || v6 )
  {
    if ( v5 )
    {
      Curl_cfree(ptr);
      result = 0;
    }
  }
  else if ( v5 )
  {
    *((_BYTE *)ptr + v4) = v6;
    result = ptr;
  }
  else
  {
    result = (void *)Curl_cstrdup(&byte_E4496);
  }
  return result;
}
// E4496: using guessed type char byte_E4496;
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000751B0) --------------------------------------------------------
void *__fastcall curl_mvaprintf(char *a1, int a2)
{
  bool v2; // zf
  void *result; // r0
  void *ptr; // [sp+0h] [bp-18h]
  int v5; // [sp+4h] [bp-14h]
  void *v6; // [sp+8h] [bp-10h]
  int v7; // [sp+Ch] [bp-Ch]

  ptr = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v2 = sub_745E4((int)&ptr, (int (__fastcall *)(signed int, int))sub_74554, a1, a2) + 1 == 0;
  result = v6;
  if ( v2 || v7 )
  {
    if ( v6 )
    {
      Curl_cfree(ptr);
      result = 0;
    }
  }
  else if ( v6 )
  {
    *((_BYTE *)ptr + v5) = v7;
    result = ptr;
  }
  else
  {
    result = (void *)Curl_cstrdup(&byte_E4496);
  }
  return result;
}
// E4496: using guessed type char byte_E4496;
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00075214) --------------------------------------------------------
char *curl_msprintf(_BYTE *a1, char *a2, ...)
{
  char *result; // r0
  _BYTE *v3; // [sp+4h] [bp-1Ch]
  int v4; // [sp+8h] [bp-18h]
  int **v5; // [sp+Ch] [bp-14h]
  int varg_r2; // [sp+18h] [bp-8h]
  va_list varg_r2a; // [sp+18h] [bp-8h]
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(varg_r3, _DWORD);
  v4 = varg_r2;
  v3 = a1;
  va_copy(v5, varg_r2a);
  result = sub_745E4((int)&v3, (int (__fastcall *)(signed int, int))sub_745BC, a2, (int)varg_r2a);
  *v3 = 0;
  return result;
}
// 745BC: using guessed type int sub_745BC();

//----- (00075240) --------------------------------------------------------
char *curl_mprintf(char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch]

  va_start(varg_r1, a1);
  return sub_745E4((int)&_sF + 84, (int (__fastcall *)(signed int, int))&fputc, a1, (int)varg_r1);
}

//----- (00075270) --------------------------------------------------------
char *curl_mfprintf(int a1, char *a2, ...)
{
  va_list varg_r2; // [sp+10h] [bp-8h]

  va_start(varg_r2, a2);
  return sub_745E4(a1, (int (__fastcall *)(signed int, int))&fputc, a2, (int)varg_r2);
}

//----- (00075294) --------------------------------------------------------
char *__fastcall curl_mvsprintf(_BYTE *a1, char *a2, int a3)
{
  char *result; // r0
  _BYTE *v4; // [sp+4h] [bp-14h]
  int v5; // [sp+8h] [bp-10h]

  v5 = a3;
  v4 = a1;
  result = sub_745E4((int)&v4, (int (__fastcall *)(signed int, int))sub_745BC, a2, a3);
  *v4 = 0;
  return result;
}
// 745BC: using guessed type int sub_745BC();

//----- (000752BC) --------------------------------------------------------
char *__fastcall curl_mvprintf(char *a1, int a2)
{
  return sub_745E4((int)&_sF + 84, (int (__fastcall *)(signed int, int))&fputc, a1, a2);
}

//----- (000752DC) --------------------------------------------------------
char *__fastcall curl_mvfprintf(int a1, char *a2, int a3)
{
  return sub_745E4(a1, (int (__fastcall *)(signed int, int))&fputc, a2, a3);
}

//----- (000752F8) --------------------------------------------------------
int __fastcall sub_752F8(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = a1;
  curl_slist_free_all(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 34200) + 6312));
  Curl_cfree(*(_DWORD *)(*(_DWORD *)v1 + 34200));
  result = 0;
  *(_DWORD *)(*(_DWORD *)v1 + 34200) = 0;
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00075338) --------------------------------------------------------
signed int __fastcall sub_75338(int a1)
{
  int v1; // r6
  int v2; // r4
  const char **i; // r5
  _BOOL4 v4; // r0
  bool v5; // r9
  int v6; // r1
  signed int result; // r0
  int v8; // r3
  int *v9; // [sp+0h] [bp-8Ch]
  char v10; // [sp+Ch] [bp-80h]
  int v11; // [sp+8Ch] [bp+0h]

  v1 = *(_DWORD *)a1;
  v9 = (int *)&_stack_chk_guard;
  v2 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  if ( *(_BYTE *)(a1 + 300) )
  {
    curl_msnprintf((int)&v11, 256, "USER,%s", *(_DWORD *)(a1 + 172), &_stack_chk_guard);
    *(_DWORD *)(v2 + 6312) = curl_slist_append(*(_DWORD *)(v2 + 6312), (int)&v11);
    *(_DWORD *)(v2 + 2212) = 1;
  }
  for ( i = *(const char ***)(v1 + 516); ; i = (const char **)i[1] )
  {
    if ( !i )
    {
      result = 0;
      goto LABEL_18;
    }
    if ( sscanf(*i, "%127[^= ]%*[ =]%255s", &v10, &v11, v9) != 2 )
    {
      Curl_failf(v1, "Syntax error in telnet option: %s", *i);
      result = 49;
      goto LABEL_18;
    }
    v4 = Curl_raw_equal((unsigned __int8 *)&v10, "TTYPE");
    v5 = v4;
    if ( v4 )
    {
      strncpy((char *)(v2 + 6152), (const char *)&v11, 0x1Fu);
      *(_BYTE *)(v2 + 6183) = 0;
      *(_DWORD *)(v2 + 2152) = 1;
      continue;
    }
    if ( Curl_raw_equal((unsigned __int8 *)&v10, "XDISPLOC") )
    {
      strncpy((char *)(v2 + 6184), (const char *)&v11, 0x7Fu);
      *(_BYTE *)(v2 + 6311) = v5;
      *(_DWORD *)(v2 + 2196) = 1;
      continue;
    }
    if ( !Curl_raw_equal((unsigned __int8 *)&v10, "NEW_ENV") )
    {
      Curl_failf(v1, "Unknown telnet option %s", *i);
      result = 48;
      goto LABEL_18;
    }
    v6 = Curl_cstrdup(&v11);
    if ( !v6 )
      break;
    *(_DWORD *)(v2 + 6312) = curl_slist_append(*(_DWORD *)(v2 + 6312), v6);
    *(_DWORD *)(v2 + 2212) = 1;
  }
  result = 27;
LABEL_18:
  v8 = *v9;
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (00075498) --------------------------------------------------------
int __fastcall sub_75498(int result, int a2, const char *a3, char *a4)
{
  const char *v4; // r4
  int v5; // r6
  signed int v6; // r5
  int v7; // r2
  char *v8; // r1
  const char *v9; // r3
  const char *v10; // r2
  char *v11; // r1
  int v12; // r2
  void *v13; // [sp+0h] [bp-20h]
  int v14; // [sp+4h] [bp-1Ch]
  const char *v15; // [sp+8h] [bp-18h]

  v14 = a2;
  v15 = a3;
  v4 = a3;
  v5 = a2;
  v6 = (signed int)a4;
  if ( !*(_BYTE *)(result + 672) )
    return result;
  if ( a3 != (_BYTE *)&off_FC + 3 )
  {
    if ( a3 == (_BYTE *)&dword_F8 + 3 )
    {
      v9 = "WILL";
    }
    else if ( a3 == (const char *)&off_FC )
    {
      v9 = "WONT";
    }
    else if ( a3 == (_BYTE *)&off_FC + 1 )
    {
      v9 = "DO";
    }
    else
    {
      if ( a3 != (_BYTE *)&off_FC + 2 )
      {
        v12 = a2;
        v13 = a4;
        v9 = v4;
        v11 = "%s %d %d\n";
        return Curl_infof(result, v11, v12, v9, v13, v14, v15);
      }
      v9 = "DONT";
    }
    if ( v6 > 39 )
    {
      if ( v6 != 255 )
      {
LABEL_21:
        v13 = (void *)v6;
        v11 = "%s %s %d\n";
        goto LABEL_22;
      }
      v10 = "EXOPL";
    }
    else
    {
      v10 = off_EF70C[v6 + 20];
      if ( !v10 )
        goto LABEL_21;
    }
    v13 = (void *)v10;
    v11 = "%s %s %s\n";
LABEL_22:
    v12 = v5;
    return Curl_infof(result, v11, v12, v9, v13, v14, v15);
  }
  if ( (unsigned int)(a4 - 236) > 0x13 )
  {
    v7 = a2;
    v8 = "%s IAC %d\n";
  }
  else
  {
    v7 = a2;
    v8 = "%s IAC %s\n";
    a4 = off_EF70C[(_DWORD)(a4 - 236)];
  }
  return Curl_infof(result, v8, v7, a4);
}
// F8: using guessed type int;
// FC: using guessed type void *;
// EF70C: using guessed type char *off_EF70C[61];

//----- (00075570) --------------------------------------------------------
int __fastcall sub_75570(int *a1, int a2, int a3)
{
  int v3; // r7
  int *v4; // r4
  const char *v5; // r6
  char *v6; // r5
  ssize_t v7; // r0
  int v8; // r1
  int v9; // r2
  _DWORD *v10; // r0
  int buf; // [sp+4h] [bp-1Ch]
  int v13; // [sp+8h] [bp-18h]

  buf = a2;
  v13 = a3;
  v3 = *a1;
  v4 = a1;
  LOBYTE(buf) = -1;
  v5 = (const char *)a2;
  BYTE1(buf) = a2;
  v6 = (char *)a3;
  BYTE2(buf) = a3;
  v7 = send(a1[53], &buf, 3u, 0x4000);
  if ( v7 < 0 )
  {
    v10 = (_DWORD *)_errno(v7, v8, v9);
    Curl_failf(v3, "Sending data failed (%d)", *v10);
  }
  return sub_75498(*v4, (int)"SENT", v5, v6);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000755C8) --------------------------------------------------------
int __fastcall sub_755C8(int result, int a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // r6
  int v5; // r4
  int v6; // r9
  unsigned __int8 *v7; // r5
  const char *v8; // r2
  unsigned int v9; // r7
  signed int v10; // r8
  int v11; // r0
  char *v12; // r1
  char *v13; // r2
  int v14; // r0
  char *v15; // r1
  char *v16; // r2
  int v17; // r0
  char *v18; // r1
  unsigned int v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r1
  int v22; // r0
  char **v23; // r2
  char *v24; // r1
  char *v25; // r2
  int v26; // r0
  char *v27; // r1
  int v28; // r3
  unsigned int v29; // r7
  unsigned int v30; // r7
  int v31; // r0
  char *v32; // r1
  int v33; // r2

  v4 = a4;
  v5 = result;
  v6 = a2;
  v7 = a3;
  if ( *(_BYTE *)(result + 672) )
  {
    if ( a2 )
    {
      if ( a2 == 60 )
        v8 = "RCVD";
      else
        v8 = "SENT";
      Curl_infof(result, "%s IAC SB ", v8);
      if ( v4 <= 2 )
      {
        v9 = 0;
      }
      else
      {
        v9 = v7[v4 - 2];
        v10 = v7[v4 - 1];
        if ( v9 != 255 || v10 != 240 )
        {
          Curl_infof(v5, "(terminated by ");
          if ( v9 > 0x27 )
          {
            v11 = v5;
            if ( v9 - 236 > 0x13 )
            {
              v13 = (char *)v9;
              v12 = "%d ";
            }
            else
            {
              v12 = "%s ";
              v13 = off_EF70C[v9 - 236];
            }
          }
          else
          {
            v11 = v5;
            v12 = "%s ";
            v13 = off_EF70C[v9 + 20];
          }
          Curl_infof(v11, v12, v13);
          if ( v10 > 39 )
          {
            v14 = v5;
            if ( (unsigned int)(v10 - 236) > 0x13 )
            {
              v16 = (char *)v10;
              v15 = "%d";
            }
            else
            {
              v15 = "%s";
              v16 = off_EF70C[v10 - 236];
            }
          }
          else
          {
            v14 = v5;
            v15 = "%s";
            v16 = off_EF70C[v10 + 20];
          }
          Curl_infof(v14, v15, v16);
          Curl_infof(v5, ", not IAC SE!) ");
        }
      }
      v4 -= 2;
    }
    else
    {
      v9 = 0;
    }
    if ( !v4 )
    {
      v17 = v5;
      v18 = "(Empty suboption?)";
      return Curl_infof(v17, v18);
    }
    v19 = *v7;
    if ( v19 > 0x27 )
    {
      v22 = v5;
      v25 = (char *)v7[v9];
      v24 = "%d (unknown)";
    }
    else
    {
      v20 = v19;
      v21 = (unsigned __int8)(v19 - 24);
      if ( v21 <= 0xF && (1 << v21) & 0x8801 )
      {
        v22 = v5;
        v23 = &off_EF70C[v20];
        v24 = "%s";
      }
      else
      {
        v22 = v5;
        v23 = &off_EF70C[v20];
        v24 = "%s (unsupported)";
      }
      v25 = v23[20];
    }
    result = Curl_infof(v22, v24, v25);
    switch ( v7[1] )
    {
      case 0u:
        v26 = v5;
        v27 = " IS";
        goto LABEL_37;
      case 1u:
        v26 = v5;
        v27 = " SEND";
        goto LABEL_37;
      case 2u:
        v26 = v5;
        v27 = " INFO/REPLY";
        goto LABEL_37;
      case 3u:
        v26 = v5;
        v27 = " NAME";
LABEL_37:
        result = Curl_infof(v26, v27);
        break;
      default:
        break;
    }
    v28 = *v7;
    if ( v28 == 35 )
    {
LABEL_42:
      v7[v4] = 0;
      result = Curl_infof(v5, " \"%s\"", v7 + 2);
LABEL_55:
      if ( !v6 )
        return result;
      v17 = v5;
      v18 = "\n";
      return Curl_infof(v17, v18);
    }
    if ( v28 != 39 )
    {
      if ( v28 != 24 )
      {
        v29 = 2;
        while ( v29 < v4 )
        {
          v33 = v7[v29++];
          result = Curl_infof(v5, " %.2x", v33);
        }
        goto LABEL_55;
      }
      goto LABEL_42;
    }
    if ( v7[1] )
      goto LABEL_55;
    v30 = 3;
    result = Curl_infof(v5, (char *)&unk_E49A3);
    while ( 1 )
    {
      if ( v30 >= v4 )
        goto LABEL_55;
      if ( !v7[v30] )
        break;
      if ( v7[v30] == 1 )
      {
        v31 = v5;
        v32 = " = ";
LABEL_50:
        result = Curl_infof(v31, v32);
        goto LABEL_52;
      }
      result = Curl_infof(v5, "%c");
LABEL_52:
      ++v30;
    }
    v31 = v5;
    v32 = ", ";
    goto LABEL_50;
  }
  return result;
}
// EF70C: using guessed type char *off_EF70C[61];

//----- (00075844) --------------------------------------------------------
int __fastcall sub_75844(int *a1)
{
  int *v1; // r7
  int v2; // r5
  int v3; // r6
  int result; // r0
  unsigned __int8 *v5; // r3
  int v6; // r4
  size_t v7; // r9
  ssize_t v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r2
  int v12; // r0
  ssize_t v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r0
  unsigned int v17; // r3
  int v18; // r8
  signed int v19; // r4
  size_t v20; // r12
  const char *v21; // r0
  char *v22; // ST18_4
  ssize_t v23; // r0
  int v24; // r1
  int v25; // r2
  _DWORD *v26; // r0
  char *s; // [sp+18h] [bp-938h]
  char v28; // [sp+24h] [bp-92Ch]
  char v29; // [sp+A4h] [bp-8ACh]
  char v30[2048]; // [sp+124h] [bp-82Ch]
  char v31[2048]; // [sp+126h] [bp-82Ah]

  v1 = a1;
  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 34200);
  result = sub_755C8(*a1, 60, (unsigned __int8 *)(v3 + 6316), *(_DWORD *)(v3 + 6832) - *(_DWORD *)(v3 + 6828) + 2);
  v5 = *(unsigned __int8 **)(v3 + 6828);
  *(_DWORD *)(v3 + 6828) = v5 + 1;
  v6 = *v5;
  switch ( v6 )
  {
    case 35:
      v7 = strlen((const char *)(v3 + 6184));
      curl_msnprintf((int)v30, 2048, "%c%c%c%c%s%c%c");
      v13 = send(v1[53], v30, v7 + 6, 0x4000);
      if ( v13 < 0 )
      {
        v11 = *(_DWORD *)_errno(v13, v14, v15);
        v12 = v2;
        goto LABEL_8;
      }
      break;
    case 39:
      curl_msnprintf((int)v30, 2048, "%c%c%c%c", 255, 250, 39, 0);
      v18 = *(_DWORD *)(v3 + 6312);
      v19 = 4;
      while ( v18 )
      {
        s = *(char **)v18;
        v20 = v19 + 1 + strlen(*(const char **)v18);
        if ( v20 <= 0x7F9 )
        {
          v21 = s;
          v22 = (char *)v20;
          sscanf(v21, "%127[^,],%127s", &v28, &v29);
          curl_msnprintf((int)&v30[v19], 2048 - v19, "%c%s%c%s", 0, &v28, 1, &v29);
          v19 = (signed int)v22;
        }
        v18 = *(_DWORD *)(v18 + 4);
      }
      curl_msnprintf((int)&v30[v19], 2048 - v19, "%c%c", 255, 240);
      v23 = send(v1[53], v30, v19 + 2, 0x4000);
      if ( v23 < 0 )
      {
        v26 = (_DWORD *)_errno(v23, v24, v25);
        Curl_failf(v2, "Sending data failed (%d)", *v26);
      }
      v16 = v2;
      v17 = v19;
      return sub_755C8(v16, 62, (unsigned __int8 *)v31, v17);
    case 24:
      v7 = strlen((const char *)(v3 + 6152));
      curl_msnprintf((int)v30, 2048, "%c%c%c%c%s%c%c");
      v8 = send(v1[53], v30, v7 + 6, 0x4000);
      if ( v8 < 0 )
      {
        v11 = *(_DWORD *)_errno(v8, v9, v10);
        v12 = v2;
LABEL_8:
        Curl_failf(v12, "Sending data failed (%d)", v11);
        break;
      }
      break;
    default:
      return result;
  }
  v16 = v2;
  v17 = v7 + 4;
  return sub_755C8(v16, 62, (unsigned __int8 *)v31, v17);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 75844: using guessed type char var_82C[2048];

//----- (00075A70) --------------------------------------------------------
signed int __fastcall sub_75A70(int *a1, _BYTE *a2)
{
  int v2; // r3
  int v3; // r2
  int *v4; // r4
  int v5; // r0
  int v6; // r3
  int v7; // r0
  signed int result; // r0
  signed int v9; // r5
  int v10; // r3
  char *v11; // r6
  int v12; // r0
  ssize_t v13; // r0
  unsigned __int8 *v14; // r8
  int v15; // r9
  char v16; // r3
  int v17; // t1
  signed int v18; // r7
  bool v19; // zf
  signed int v20; // r11
  signed int v21; // r0
  int v22; // r0
  int v23; // r11
  signed int v24; // r5
  signed int v25; // r8
  _DWORD *v26; // r9
  signed int *v27; // r7
  int v28; // r10
  int *v29; // r0
  signed int v30; // r3
  _DWORD *v31; // r3
  _BYTE *v32; // r2
  _BYTE *v33; // r2
  signed int v34; // r3
  _DWORD *v35; // r3
  int v36; // r2
  int v37; // r2
  int v38; // r0
  int v39; // r2
  int *v40; // r0
  int v41; // r1
  _DWORD *v42; // r3
  int v43; // r2
  int v44; // r2
  int v45; // r2
  int v46; // r2
  _BYTE *v47; // r3
  _BYTE *v48; // r2
  int v49; // r8
  int v50; // r9
  int v51; // r3
  int v52; // r2
  int v53; // r3
  int v54; // r2
  int v55; // r3
  int v56; // r3
  signed int v57; // r7
  int v58; // r0
  int v59; // [sp+14h] [bp-6Ch]
  signed int *v60; // [sp+18h] [bp-68h]
  int v61; // [sp+1Ch] [bp-64h]
  int v62; // [sp+20h] [bp-60h]
  char v63; // [sp+2Ch] [bp-54h]
  char v64; // [sp+2Dh] [bp-53h]
  int v65; // [sp+30h] [bp-50h]
  int v66; // [sp+34h] [bp-4Ch]
  __time_t v67; // [sp+38h] [bp-48h]
  int v68; // [sp+3Ch] [bp-44h]
  int v69; // [sp+40h] [bp-40h]
  __int16 v70; // [sp+44h] [bp-3Ch]
  int v71; // [sp+48h] [bp-38h]
  __int16 v72; // [sp+4Ch] [bp-34h]
  __int16 v73; // [sp+4Eh] [bp-32h]
  int v74; // [sp+50h] [bp-30h]
  __int16 v75; // [sp+54h] [bp-2Ch]
  __int16 v76; // [sp+56h] [bp-2Ah]

  v2 = a1[53];
  v3 = *a1;
  v4 = a1;
  *a2 = 1;
  v61 = v2;
  v59 = v3;
  v5 = Curl_ccalloc(1, 6840);
  if ( v5 )
  {
    *(_DWORD *)(*v4 + 34200) = v5;
    v6 = v5 + 6816;
    *(_DWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 12) = v5 + 6316;
    *(_DWORD *)(v5 + 2056) = 1;
    *(_DWORD *)(v5 + 2068) = 1;
    v7 = v5 + 5120;
    *(_DWORD *)(v7 + 8) = 1;
    *(_DWORD *)(v7 + 20) = 1;
    v60 = *(signed int **)(v59 + 34200);
    result = sub_75338((int)v4);
    if ( result )
      return result;
    v9 = 0;
    v10 = v61;
    v11 = (char *)(v59 + 1172);
    v72 = 1;
    v74 = 0;
    v71 = v61;
    v75 = 1;
    while ( 1 )
    {
      v12 = Curl_poll((struct pollfd *)&v71, 2u, 1000, v10);
      if ( v12 == -1 )
      {
LABEL_159:
        Curl_setup_transfer(v4, -1, -1LL, 0, 0, -1, 0);
        return v9;
      }
      if ( !v12 )
        goto LABEL_154;
      if ( v76 & 1 )
      {
        v13 = read(0, v11, 0xFFu);
        v14 = (unsigned __int8 *)(v59 + 1172);
        v15 = (int)&v11[v13];
        v65 = v13;
LABEL_8:
        if ( v14 != (unsigned __int8 *)v15 )
        {
          v17 = *v14++;
          v16 = v17;
          v18 = 0;
          v19 = v17 == 255;
          v63 = v17;
          if ( v17 == 255 )
            v20 = 2;
          else
            v20 = 1;
          if ( v19 )
            v64 = v16;
          while ( 1 )
          {
            v69 = v4[53];
            v70 = 4;
            if ( (unsigned int)(Curl_poll((struct pollfd *)&v69, 1u, -1, 4) + 1) <= 1 )
              break;
            v66 = 0;
            v21 = Curl_write(v4, v4[53], &v63 + v18, v20 - v18, &v66);
            v18 += v66;
            v9 = v21;
            if ( v21 )
              goto LABEL_161;
            if ( v18 >= v20 )
              goto LABEL_8;
          }
          v9 = 55;
          goto LABEL_161;
        }
        v9 = 0;
      }
      if ( v73 & 1 && (v22 = Curl_read((int)v4, v61, v11, 0x3FFFu, (int)&v65), v22 >= 0) )
      {
        if ( v22 )
        {
          v9 = v22;
LABEL_161:
          v57 = 0;
          goto LABEL_155;
        }
        v62 = v65;
        if ( v65 <= 0 )
          goto LABEL_161;
        v23 = *v4;
        v24 = -1;
        v25 = 0;
        v26 = *(_DWORD **)(*v4 + 34200);
        v27 = v26 + 1709;
        while ( 2 )
        {
          v28 = (unsigned __int8)v11[v25];
          switch ( *v27 )
          {
            case 0:
              if ( v28 != 255 )
              {
                if ( v28 == 13 )
                {
                  v30 = 6;
LABEL_53:
                  *v27 = v30;
                }
                goto LABEL_54;
              }
              *v27 = 1;
              if ( v24 == -1 )
                goto LABEL_30;
              v29 = v4;
              goto LABEL_35;
            case 1:
              goto LABEL_46;
            case 2:
              sub_75498(v23, (int)"RCVD", (_BYTE *)&dword_F8 + 3, (char *)(unsigned __int8)v11[v25]);
              *v26 = 1;
              v35 = (_DWORD *)(*(_DWORD *)(*v4 + 34200) + 4 * v28);
              v36 = v35[770];
              if ( v36 == 2 )
              {
                v38 = v35[1026];
                if ( !v38 )
                {
                  v35[770] = 1;
                  goto LABEL_123;
                }
                if ( v38 != 1 )
                  goto LABEL_123;
                v35[770] = 3;
                v35[1026] = 0;
                goto LABEL_75;
              }
              if ( v36 != 3 )
              {
                if ( v36 )
                  goto LABEL_123;
                if ( v35[1282] == 1 )
                {
                  v35[770] = 1;
                  goto LABEL_79;
                }
                goto LABEL_75;
              }
              v37 = v35[1026];
              if ( !v37 )
                goto LABEL_83;
              if ( v37 == 1 )
              {
                v35[770] = 1;
                v35[1026] = 0;
              }
              goto LABEL_123;
            case 3:
              sub_75498(v23, (int)"RCVD", (const char *)&off_FC, (char *)(unsigned __int8)v11[v25]);
              *v26 = 1;
              v35 = (_DWORD *)(*(_DWORD *)(*v4 + 34200) + 4 * v28);
              v39 = v35[770];
              if ( v39 != 2 )
              {
                if ( v39 == 3 )
                {
                  v37 = v35[1026];
                  if ( !v37 )
                    goto LABEL_83;
                  if ( v37 != 1 )
                    goto LABEL_123;
                  v35[770] = 2;
                  v35[1026] = 0;
LABEL_79:
                  v40 = v4;
                  v41 = 253;
                }
                else
                {
                  if ( v39 != 1 )
                    goto LABEL_123;
                  v35[770] = 0;
LABEL_75:
                  v40 = v4;
                  v41 = 254;
                }
                goto LABEL_105;
              }
              v37 = v35[1026];
              if ( !v37 )
              {
LABEL_83:
                v35[770] = v37;
                goto LABEL_123;
              }
              if ( v37 == 1 )
              {
                v35[770] = 0;
                v35[1026] = 0;
              }
              goto LABEL_123;
            case 4:
              sub_75498(v23, (int)"RCVD", (_BYTE *)&off_FC + 1, (char *)(unsigned __int8)v11[v25]);
              *v26 = 1;
              v42 = (_DWORD *)(*(_DWORD *)(*v4 + 34200) + 4 * v28);
              v43 = v42[2];
              if ( v43 == 2 )
              {
                v45 = v42[258];
                if ( !v45 )
                {
                  v42[2] = 1;
                  goto LABEL_123;
                }
                if ( v45 != 1 )
                  goto LABEL_123;
                v42[2] = 3;
                v42 += 1024;
                goto LABEL_99;
              }
              if ( v43 != 3 )
              {
                if ( v43 )
                  goto LABEL_123;
                if ( v42[514] == 1 )
                {
                  v42[2] = 1;
                  goto LABEL_104;
                }
                goto LABEL_100;
              }
              v44 = v42[258];
              if ( !v44 )
                goto LABEL_109;
              if ( v44 == 1 )
              {
                v42[2] = 1;
                goto LABEL_110;
              }
              goto LABEL_123;
            case 5:
              sub_75498(v23, (int)"RCVD", (_BYTE *)&off_FC + 2, (char *)(unsigned __int8)v11[v25]);
              *v26 = 1;
              v42 = (_DWORD *)(*(_DWORD *)(*v4 + 34200) + 4 * v28);
              v46 = v42[2];
              if ( v46 == 2 )
              {
                v44 = v42[258];
                if ( !v44 )
                {
LABEL_109:
                  v42[2] = v44;
                  goto LABEL_123;
                }
                if ( v44 == 1 )
                {
                  v42[2] = 0;
LABEL_110:
                  v42[258] = 0;
                }
              }
              else
              {
                if ( v46 == 3 )
                {
                  v44 = v42[258];
                  if ( !v44 )
                    goto LABEL_109;
                  if ( v44 != 1 )
                    goto LABEL_123;
                  v42[2] = 2;
                  v42[258] = 0;
LABEL_104:
                  v40 = v4;
                  v41 = 251;
                }
                else
                {
                  if ( v46 != 1 )
                    goto LABEL_123;
LABEL_99:
                  v42[2] = 0;
LABEL_100:
                  v40 = v4;
                  v41 = 252;
                }
LABEL_105:
                sub_75570(v40, v41, v28);
              }
LABEL_123:
              v34 = 0;
LABEL_124:
              *v27 = v34;
              goto def_75BFA;
            case 6:
              *v27 = 0;
              if ( v28 )
              {
LABEL_54:
                if ( v24 == -1 )
                  v24 = v25;
              }
              else
              {
                if ( v24 != -1 )
                {
                  v29 = v4;
LABEL_35:
                  v9 = Curl_client_write(v29, 1, &v11[v24], v25 - v24);
                  if ( v9 )
                    goto LABEL_161;
                }
LABEL_30:
                v24 = -1;
              }
def_75BFA:
              if ( ++v25 != v62 )
                continue;
              if ( v24 != -1 )
              {
                v9 = Curl_client_write(v4, 1, &v11[v24], v25 - v24);
                if ( v9 )
                  goto LABEL_161;
              }
              v9 = *v60;
              if ( !*v60 )
                goto LABEL_154;
              if ( v60[1] )
              {
                v9 = 0;
                goto LABEL_154;
              }
              v49 = 0;
              v50 = *(_DWORD *)(*v4 + 34200);
              do
              {
                if ( *(_DWORD *)(v50 + 2056) == 1 )
                {
                  v51 = *(_DWORD *)(*v4 + 34200) + 4 * v49;
                  v52 = *(_DWORD *)(v51 + 8);
                  switch ( v52 )
                  {
                    case 2:
                      if ( *(_DWORD *)(v51 + 1032) == 1 )
                        *(_DWORD *)(v51 + 1032) = 0;
                      break;
                    case 3:
                      if ( !*(_DWORD *)(v51 + 1032) )
                        *(_DWORD *)(v51 + 1032) = 1;
                      break;
                    case 0:
                      *(_DWORD *)(v51 + 8) = 2;
                      sub_75570(v4, 251, v49);
                      break;
                  }
                }
                if ( *(_DWORD *)(v50 + 5128) == 1 )
                {
                  v53 = *(_DWORD *)(*v4 + 34200) + 4 * v49;
                  v54 = *(_DWORD *)(v53 + 3080);
                  switch ( v54 )
                  {
                    case 2:
                      v56 = v53 + 4096;
                      if ( *(_DWORD *)(v56 + 8) == 1 )
                        *(_DWORD *)(v56 + 8) = 0;
                      break;
                    case 3:
                      v55 = v53 + 4096;
                      if ( !*(_DWORD *)(v55 + 8) )
                        *(_DWORD *)(v55 + 8) = 1;
                      break;
                    case 0:
                      *(_DWORD *)(v53 + 3080) = 2;
                      sub_75570(v4, 253, v49);
                      break;
                  }
                }
                ++v49;
                v50 += 4;
              }
              while ( v49 != 40 );
              v57 = 1;
              v9 = 0;
              v60[1] = 1;
              break;
            case 7:
              if ( v28 == 255 )
              {
                v34 = 8;
                goto LABEL_124;
              }
              v47 = (_BYTE *)v26[1707];
              if ( v47 < (_BYTE *)v26 + 6828 )
              {
                v26[1707] = v47 + 1;
                *v47 = v28;
              }
              goto def_75BFA;
            case 8:
              v31 = v26 + 1707;
              v32 = (_BYTE *)v26[1707];
              if ( v28 == 240 )
              {
                if ( v32 < (_BYTE *)v31 )
                {
                  *v31 = v32 + 1;
                  *v32 = -1;
                }
                v48 = (_BYTE *)*v31;
                if ( *v31 < (unsigned int)v31 )
                {
                  *v31 = v48 + 1;
                  *v48 = -16;
                }
                v26[1708] = *v31 - 2;
                *v31 = v26 + 1579;
                sub_75844(v4);
                goto LABEL_123;
              }
              if ( v28 == 255 )
              {
                if ( v32 < (_BYTE *)v31 )
                {
                  *v31 = v32 + 1;
                  *v32 = -1;
                }
LABEL_117:
                v34 = 7;
                goto LABEL_124;
              }
              if ( v32 < (_BYTE *)v31 )
              {
                *v31 = v32 + 1;
                *v32 = -1;
              }
              v33 = (_BYTE *)*v31;
              if ( *v31 < (unsigned int)v31 )
              {
                *v31 = v33 + 1;
                *v33 = v28;
              }
              v26[1708] = *v31 - 2;
              *v31 = v26 + 1579;
              sub_75498(v23, (int)"In SUBOPTION processing, RCVD", (_BYTE *)&off_FC + 3, (char *)v28);
              sub_75844(v4);
              *v27 = 1;
LABEL_46:
              switch ( v28 )
              {
                case 250:
                  v26[1707] = v26 + 1579;
                  goto LABEL_117;
                case 251:
                  v34 = 2;
                  goto LABEL_124;
                case 252:
                  v34 = 3;
                  goto LABEL_124;
                case 253:
                  v34 = 4;
                  goto LABEL_124;
                case 254:
                  v34 = 5;
                  goto LABEL_124;
                case 255:
                  v30 = 0;
                  goto LABEL_53;
                default:
                  *v27 = 0;
                  sub_75498(v23, (int)"RCVD", (_BYTE *)&off_FC + 3, (char *)v28);
                  break;
              }
              goto def_75BFA;
            default:
              goto def_75BFA;
          }
          break;
        }
      }
      else
      {
LABEL_154:
        v57 = 1;
      }
LABEL_155:
      v10 = *(_DWORD *)(v59 + 424);
      if ( v10 )
      {
        curlx_tvnow(&v67);
        v58 = curlx_tvdiff(v67, v68, v4[51], v4[52]);
        v10 = *(_DWORD *)(v59 + 424);
        if ( v58 >= v10 )
        {
          v9 = 28;
          Curl_failf(v59, "Time-out");
          goto LABEL_159;
        }
      }
      if ( !v57 )
        goto LABEL_159;
    }
  }
  return 27;
}
// F8: using guessed type int dword_F8;
// FC: using guessed type void *off_FC;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (000760C8) --------------------------------------------------------
signed int __fastcall Curl_parsenetrc(unsigned __int8 *a1, unsigned __int8 *a2, char *a3, char *a4)
{
  char *v4; // r6
  char *v5; // r5
  __uid_t v6; // r0
  struct passwd *v7; // r0
  _BOOL4 v9; // r4
  signed int v10; // r11
  signed int v11; // r10
  signed int v12; // r7
  signed int v13; // r8
  char *i; // r3
  _BOOL4 v15; // r0
  char *v16; // [sp+4h] [bp-164h]
  signed int v17; // [sp+8h] [bp-160h]
  signed int v18; // [sp+Ch] [bp-15Ch]
  unsigned __int8 *dest; // [sp+10h] [bp-158h]
  _BOOL4 v20; // [sp+14h] [bp-154h]
  FILE *stream; // [sp+18h] [bp-150h]
  char *v22; // [sp+1Ch] [bp-14Ch]
  unsigned __int8 *v23; // [sp+20h] [bp-148h]
  char *save_ptr; // [sp+38h] [bp-130h]
  char s; // [sp+3Ch] [bp-12Ch]

  v4 = a4;
  v22 = a3;
  dest = a2;
  v23 = a1;
  v20 = *a2 != 0;
  if ( a4 )
  {
    v18 = 0;
    v17 = 0;
    v5 = 0;
  }
  else
  {
    v5 = (char *)curl_getenv("HOME");
    if ( v5 )
    {
      v17 = 1;
    }
    else
    {
      v6 = geteuid();
      v7 = getpwuid(v6);
      if ( !v7 )
        return -1;
      v5 = v7->pw_gecos;
      if ( !v5 )
        return -1;
      v17 = (signed int)v4;
    }
    v4 = (char *)curl_maprintf("%s%s%s", v5, "/", ".netrc");
    if ( !v4 )
    {
      if ( v17 )
        ((void (__cdecl *)(void *))Curl_cfree)(v5);
      return -1;
    }
    v18 = 1;
  }
  stream = fopen(v4, "r");
  if ( stream )
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 1;
    while ( fgets(&s, 256, stream) )
    {
      for ( i = strtok_r(&s, " \t\n", &save_ptr); i; i = strtok_r(0, " \t\n", &save_ptr) )
      {
        if ( *dest && *v22 )
          goto LABEL_49;
        switch ( v12 )
        {
          case 1:
            if ( Curl_raw_equal(v23, i) )
            {
              v12 = 3;
              v13 = 0;
            }
            else
            {
              v12 = 0;
            }
            break;
          case 3:
            if ( v11 )
            {
              if ( v20 )
                v9 = Curl_raw_equal(dest, i);
              else
                strncpy((char *)dest, i, 0x3Fu);
              v11 = 0;
            }
            else if ( v10 )
            {
              if ( v9 || !v20 )
                strncpy(v22, i, 0x3Fu);
              v10 = 0;
            }
            else
            {
              v16 = i;
              if ( Curl_raw_equal("login", i) )
              {
                v11 = 1;
              }
              else if ( Curl_raw_equal("password", v16) )
              {
                v10 = 1;
              }
              else
              {
                v15 = Curl_raw_equal("machine", v16);
                if ( v15 )
                  v9 = 0;
                else
                  v12 = 3;
                if ( v15 )
                  v12 = 1;
              }
            }
            break;
          case 0:
            v12 = Curl_raw_equal("machine", i) != 0;
            break;
        }
      }
    }
LABEL_49:
    fclose(stream);
  }
  else
  {
    v13 = 1;
  }
  if ( v17 )
    ((void (__cdecl *)(void *))Curl_cfree)(v5);
  if ( v18 )
    ((void (__cdecl *)(void *))Curl_cfree)(v4);
  return v13;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000762F4) --------------------------------------------------------
int __fastcall Curl_initinfo(int a1)
{
  _DWORD *v1; // r4
  int v2; // r0
  int result; // r0

  v1 = (_DWORD *)(a1 + 34048);
  *(_QWORD *)(a1 + 976) = 0LL;
  *(_QWORD *)(a1 + 984) = 0LL;
  *(_QWORD *)(a1 + 1000) = 0LL;
  *(_QWORD *)(a1 + 1008) = 0LL;
  *(_QWORD *)(a1 + 952) = 0LL;
  *(_QWORD *)(a1 + 1016) = 0LL;
  v2 = *(_DWORD *)(a1 + 34248);
  v1[40] = 0;
  v1[42] = 0;
  v1[43] = -1;
  if ( v2 )
    Curl_cfree(v2);
  result = 0;
  v1[50] = 0;
  v1[45] = 0;
  v1[46] = 0;
  v1[49] = 0;
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00076350) --------------------------------------------------------
signed int __fastcall Curl_getinfo(int a1, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // r3
  int v5; // r1
  char **v6; // r2
  int **v7; // r5
  signed __int64 *v8; // r4
  _DWORD *v9; // r1
  int v10; // r3
  int v11; // r0
  __int64 *v12; // r0
  int *v13; // r0
  signed __int64 v14; // r2
  signed __int64 v15; // r0
  signed int result; // r0
  char *v17; // r3
  _DWORD *varg_r2; // [sp+20h] [bp-8h]
  int varg_r3; // [sp+24h] [bp-4h]

  varg_r2 = (_DWORD *)a3;
  varg_r3 = a4;
  v4 = a2;
  if ( !a1 )
    return 43;
  v5 = a2 & 0xF00000;
  if ( (v4 & 0xF00000) == 0x200000 )
  {
    v9 = varg_r2;
    if ( !varg_r2 )
      return 43;
    v7 = 0;
    v6 = 0;
    v8 = 0;
  }
  else
  {
    if ( (signed int)(v4 & 0xF00000) <= 0x200000 )
    {
      if ( v5 != 0x100000 )
        return 43;
      v6 = (char **)varg_r2;
      if ( !varg_r2 )
        return 43;
      v7 = 0;
      v8 = 0;
LABEL_15:
      v9 = 0;
      goto LABEL_18;
    }
    if ( v5 == 3145728 )
    {
      v8 = (signed __int64 *)varg_r2;
      if ( !varg_r2 )
        return 43;
      v7 = 0;
      v6 = 0;
      goto LABEL_15;
    }
    if ( v5 != 0x400000 )
      return 43;
    v7 = (int **)varg_r2;
    if ( !varg_r2 )
      return 43;
    v6 = 0;
    v8 = 0;
    v9 = 0;
  }
LABEL_18:
  if ( v4 == 2097181 )
  {
    Curl_getconnectinfo(a1, v9, 0);
    return 0;
  }
  if ( v4 <= 0x20001D )
  {
    if ( (_UNKNOWN *)v4 == &unk_20000C )
    {
      v10 = *(_DWORD *)(a1 + 34232);
    }
    else if ( v4 > (unsigned int)&unk_20000C )
    {
      if ( v4 == 2097174 )
      {
        v10 = *(_DWORD *)(a1 + 34212);
      }
      else if ( v4 > 0x200016 )
      {
        if ( (_UNKNOWN *)v4 == &unk_200018 )
        {
          v10 = *(_DWORD *)(a1 + 34236);
        }
        else if ( v4 >= (unsigned int)&unk_200018 )
        {
          if ( (_UNKNOWN *)v4 == &unk_200019 )
          {
            v11 = a1 + 33792;
          }
          else
          {
            if ( (_UNKNOWN *)v4 != &unk_20001A )
              return 43;
            v11 = a1 + 34048;
          }
          v10 = *(_DWORD *)(v11 + 196);
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 34240);
        }
      }
      else if ( v4 == 2097166 )
      {
        v10 = *(_DWORD *)(a1 + 34220);
      }
      else if ( v4 >= 0x20000E )
      {
        if ( v4 != 2097172 )
          return 43;
        v10 = *(_DWORD *)(a1 + 320);
      }
      else
      {
        v10 = *(_DWORD *)(a1 + 540);
      }
    }
    else
    {
      if ( v4 == 1048606 )
      {
        v17 = *(char **)(a1 + 34140);
        goto LABEL_101;
      }
      if ( v4 <= 0x10001E )
      {
        switch ( v4 )
        {
          case 0x100012u:
            v17 = *(char **)(a1 + 34248);
            break;
          case 0x100015u:
            v17 = *(char **)(a1 + 608);
            break;
          case 0x100001u:
            v17 = *(char **)(a1 + 864);
            if ( !v17 )
              v17 = &byte_E4496;
            break;
          default:
            return 43;
        }
LABEL_101:
        *v6 = v17;
        return 0;
      }
      if ( (_UNKNOWN *)v4 == &unk_100020 )
      {
        *v6 = (char *)(a1 + 34256);
        return 0;
      }
      if ( v4 < (unsigned int)&unk_100020 )
      {
        v17 = *(char **)(a1 + 34252);
        goto LABEL_101;
      }
      if ( v4 == 2097154 )
      {
        v10 = *(_DWORD *)(a1 + 34208);
      }
      else
      {
        if ( v4 != 2097163 )
          return 43;
        v10 = *(_DWORD *)(a1 + 34228);
      }
    }
LABEL_112:
    *v9 = v10;
    return 0;
  }
  if ( v4 == 3145738 )
  {
    v12 = (__int64 *)(a1 + 968);
LABEL_96:
    LODWORD(v15) = _floatdidf(*v12);
LABEL_98:
    *v8 = v15;
    return 0;
  }
  if ( v4 <= 0x30000A )
  {
    if ( v4 == 3145733 )
    {
      v14 = *(_QWORD *)(a1 + 984);
      goto LABEL_86;
    }
    if ( v4 <= 0x300005 )
    {
      if ( v4 == 3145731 )
      {
        v14 = *(_QWORD *)(a1 + 952);
      }
      else
      {
        if ( v4 <= 0x300003 )
        {
          if ( v4 != 2097187 )
            return 43;
          v10 = *(unsigned __int8 *)(a1 + 34224);
          goto LABEL_112;
        }
        v14 = *(_QWORD *)(a1 + 976);
      }
      goto LABEL_86;
    }
    if ( v4 == 3145735 )
    {
      v12 = (__int64 *)(a1 + 920);
    }
    else
    {
      if ( v4 < 0x300007 )
      {
        v14 = *(_QWORD *)(a1 + 1000);
LABEL_86:
        *v8 = v14;
        return 0;
      }
      if ( v4 == 3145736 )
      {
        v12 = (__int64 *)(a1 + 912);
      }
      else
      {
        if ( v4 != 3145737 )
          return 43;
        v12 = (__int64 *)(a1 + 960);
      }
    }
    goto LABEL_96;
  }
  if ( v4 == 3145747 )
  {
    v14 = *(_QWORD *)(a1 + 1016);
    goto LABEL_86;
  }
  if ( v4 <= 0x300013 )
  {
    switch ( v4 )
    {
      case 0x300010u:
        if ( *(_DWORD *)(a1 + 944) & 0x20 )
        {
          v12 = (__int64 *)(a1 + 904);
          goto LABEL_96;
        }
        break;
      case 0x300011u:
        v14 = *(_QWORD *)(a1 + 1008);
        goto LABEL_86;
      case 0x30000Fu:
        if ( *(_DWORD *)(a1 + 944) & 0x40 )
        {
          v12 = (__int64 *)(a1 + 896);
          goto LABEL_96;
        }
        break;
      default:
        return 43;
    }
    v15 = -4616189618054758400LL;
    goto LABEL_98;
  }
  if ( v4 == 4194331 )
  {
    result = 0;
    *v7 = 0;
    return result;
  }
  if ( v4 > 0x40001B )
  {
    if ( v4 == 4194332 )
    {
      v13 = Curl_cookie_list(a1);
    }
    else
    {
      if ( v4 != 4194338 )
        return 43;
      v13 = (int *)(a1 + 34304);
    }
    *v7 = v13;
    return 0;
  }
  if ( v4 == 3145761 )
  {
    v14 = *(_QWORD *)(a1 + 992);
    goto LABEL_86;
  }
  return 43;
}
// E4496: using guessed type char byte_E4496;

//----- (00076660) --------------------------------------------------------
int __fastcall sub_76660(int a1)
{
  int v1; // r1
  signed int v2; // r2
  int result; // r0
  int v4; // r3
  int v5; // t1

  v1 = a1 - 1;
  v2 = 1;
  result = 0;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)(v1++ + 1);
    v4 = v5;
    if ( !v5 )
      return result;
    if ( v4 == 32 )
    {
      if ( !v2 )
        goto LABEL_9;
      result += 3;
    }
    else
    {
      if ( v4 == 63 )
        v2 = 0;
LABEL_9:
      ++result;
    }
  }
}

//----- (00076684) --------------------------------------------------------
_BYTE *__fastcall sub_76684(_BYTE *result, int a2)
{
  int v2; // r1
  signed int v3; // r2
  int v4; // r3
  int v5; // t1

  v2 = a2 - 1;
  v3 = 1;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)(v2++ + 1);
    v4 = v5;
    if ( !v5 )
      break;
    if ( v4 == 32 )
    {
      if ( !v3 )
      {
        *result = 43;
        goto LABEL_10;
      }
      *result = 37;
      result += 3;
      *(result - 2) = 50;
      *(result - 1) = 48;
    }
    else
    {
      if ( v4 == 63 )
        v3 = 0;
      *result = v4;
LABEL_10:
      ++result;
    }
  }
  *result = v4;
  return result;
}

//----- (000766C0) --------------------------------------------------------
bool __fastcall sub_766C0(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  char *v4; // r6
  int v5; // r0

  v2 = a1;
  v3 = a2;
  while ( v2 )
  {
    v4 = *(char **)v2;
    v5 = strlen(*(const char **)v2);
    if ( Curl_raw_nequal(v4, v3, v5) )
      return 1;
    v2 = *(_DWORD *)(v2 + 4);
  }
  return Curl_raw_nequal("HTTP/", v3, 5) != 0;
}

//----- (000766FC) --------------------------------------------------------
signed int __fastcall Curl_fillreadbuffer(int a1, unsigned int a2, size_t *a3)
{
  size_t *v3; // r7
  int v4; // r4
  unsigned int v5; // r6
  unsigned int v6; // r0
  size_t v7; // r5
  signed int result; // r0
  const char *v9; // r6
  char *v10; // r8
  int v11; // r5
  void *v12; // r0
  size_t v13; // r0
  char v14; // [sp+8h] [bp-30h]

  v3 = a3;
  v4 = *(_DWORD *)a1;
  v5 = a2;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 269) )
  {
    v5 = a2 - 12;
    *(_DWORD *)(v4 + 264) += 10;
  }
  v6 = (*(int (__fastcall **)(_DWORD, signed int, unsigned int, _DWORD))(a1 + 404))(
         *(_DWORD *)(v4 + 264),
         1,
         v5,
         *(_DWORD *)(a1 + 408));
  v7 = v6;
  if ( v6 == 0x10000000 )
  {
    Curl_failf(v4, "operation aborted by callback");
    result = 42;
    *v3 = 0;
  }
  else if ( v6 == 268435457 )
  {
    *(_DWORD *)(v4 + 244) |= 0x20u;
    if ( *(_BYTE *)(v4 + 269) )
      *(_DWORD *)(v4 + 264) -= 10;
    result = 0;
    *v3 = 0;
  }
  else if ( v6 <= v5 )
  {
    if ( !*(_BYTE *)(v4 + 271) && *(_BYTE *)(v4 + 269) )
    {
      if ( *(_BYTE *)(v4 + 489) )
      {
        v9 = "\n";
      }
      else if ( *(_BYTE *)(v4 + 651) )
      {
        v9 = "\n";
      }
      else
      {
        v9 = "\r\n";
      }
      v10 = curl_msnprintf((int)&v14, 11, "%x%s", v6, v9);
      v11 = (int)&v10[v7];
      v12 = (void *)(*(_DWORD *)(v4 + 264) - (_DWORD)v10);
      *(_DWORD *)(v4 + 264) = v12;
      memcpy(v12, &v14, (size_t)v10);
      v13 = strlen(v9);
      memcpy((void *)(*(_DWORD *)(v4 + 264) + v11), v9, v13);
      if ( (char *)v11 == v10 )
        *(_BYTE *)(v4 + 248) = 1;
      v7 = v11 + strlen(v9);
    }
    result = 0;
    *v3 = v7;
  }
  else
  {
    *v3 = 0;
    Curl_failf(v4, "read function returned funny value");
    result = 26;
  }
  return result;
}

//----- (0007684C) --------------------------------------------------------
signed int __fastcall Curl_readrewind(int a1, int a2, int a3)
{
  int v3; // r4
  int (__fastcall *v5)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, int); // r1
  int v6; // r2
  int v7; // r0
  char *v8; // r1
  int (__fastcall *v9)(int, signed int, _DWORD); // r3
  int v10; // r5
  int v11; // [sp+4h] [bp-14h]

  v11 = a2;
  v3 = *(_DWORD *)a1;
  *(_BYTE *)(a1 + 311) = 0;
  *(_DWORD *)(v3 + 244) &= 0xFFFFFFFD;
  if ( *(_DWORD *)(v3 + 332) || *(_DWORD *)(v3 + 528) == 3 )
    return 0;
  v5 = *(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, int))(v3 + 336);
  if ( !v5 )
  {
    v9 = *(int (__fastcall **)(int, signed int, _DWORD))(v3 + 380);
    if ( v9 )
    {
      v10 = v9(v3, 1, *(_DWORD *)(v3 + 420));
      Curl_infof(v3, "the ioctl callback returned %d\n", v10);
      if ( v10 )
      {
        v7 = v3;
        v6 = v10;
        v8 = "ioctl callback returned error %d";
        goto LABEL_10;
      }
    }
    else if ( *(size_t (***)(void *, size_t, size_t, FILE *))(v3 + 368) != &fread
           || fseek(*(FILE **)(v3 + 300), *(_DWORD *)(v3 + 380), *(_DWORD *)(v3 + 380)) == -1 )
    {
      Curl_failf(v3, "necessary data rewind wasn't possible");
      return 65;
    }
    return 0;
  }
  v6 = v5(*(_DWORD *)(v3 + 400), v5, 0, 0, *(_DWORD *)(v3 + 332), v11, a3);
  if ( !v6 )
    return 0;
  v7 = v3;
  v8 = "seek callback returned error %d";
LABEL_10:
  Curl_failf(v7, v8, v6);
  return 65;
}

//----- (0007690C) --------------------------------------------------------
int __fastcall Curl_readwrite(int a1, bool *a2)
{
  int v2; // r4
  signed int v3; // r6
  int v4; // r8
  int v5; // r0
  int v6; // r1
  int result; // r0
  int v8; // r6
  size_t v9; // r7
  __int64 v10; // r0
  bool v11; // zf
  signed __int64 v12; // r2
  int v13; // r1
  _DWORD *v14; // r3
  _BOOL4 v15; // r7
  int i; // r3
  const char *v17; // r2
  size_t v18; // r6
  int v19; // r1
  int v20; // r1
  int v21; // r3
  signed int v22; // r11
  signed int v23; // r3
  int v24; // r3
  char **v25; // r6
  __int64 v26; // r2
  __int64 v27; // r0
  int v28; // r6
  int v29; // r3
  int v30; // r2
  const void *v31; // r6
  size_t v32; // r2
  _BYTE *v33; // r0
  int v34; // r1
  unsigned int v35; // r2
  void *v36; // r0
  unsigned int v37; // r2
  unsigned int v38; // r6
  int v39; // r11
  char *v40; // r0
  int v41; // r0
  size_t v42; // r3
  unsigned int v43; // r3
  int v44; // r2
  signed int v45; // r3
  int v46; // r11
  int v47; // r0
  size_t v48; // r11
  size_t v49; // r6
  unsigned int v50; // r2
  void *v51; // r0
  unsigned int v52; // r3
  char *v53; // r0
  int v54; // r3
  int v55; // r1
  int v56; // r3
  size_t v57; // r3
  const char *v58; // r0
  int v59; // r3
  _BYTE *v60; // r3
  int v61; // r2
  __int64 v62; // r2
  bool v63; // zf
  int v64; // r0
  signed int v65; // r2
  __int64 v66; // r2
  bool v67; // zf
  int v68; // r0
  int v69; // r1
  int v70; // r3
  _BOOL4 v71; // r0
  bool v72; // r6
  char *v73; // r0
  char *v74; // r6
  int v75; // r0
  char *v76; // r1
  unsigned __int8 *v77; // r3
  int v78; // r6
  int v79; // r2
  int v80; // t1
  signed int v81; // r3
  const char *v82; // r3
  const char *v83; // r0
  int v84; // r2
  int v85; // t1
  __int64 v86; // r0
  const char *v87; // r2
  int v88; // r0
  int v89; // r3
  _BOOL4 v90; // r0
  int v91; // r3
  int v92; // r3
  char *v93; // r0
  int v94; // r1
  int v95; // r2
  int v96; // r3
  int v97; // r0
  signed int v98; // r0
  int v99; // r6
  signed __int64 v100; // r2
  bool v101; // zf
  int v102; // r6
  signed int v103; // r3
  int v104; // r1
  __int64 v105; // r2
  int v106; // r3
  int v107; // r3
  int v108; // r1
  int v109; // r5
  int v110; // r3
  int v111; // r2
  int v112; // r1
  _DWORD *v113; // r3
  int v114; // r6
  unsigned int v115; // r3
  int v116; // r7
  int v117; // r2
  _DWORD *v118; // r0
  int v119; // r1
  int v120; // r9
  int v121; // lr
  __int64 v122; // r2
  int v123; // r3
  int v124; // r3
  int v125; // r1
  __int64 v126; // r2
  int *v127; // r5
  int v128; // r1
  _QWORD *v129; // r1
  _QWORD *v130; // r1
  int v131; // r3
  __int64 v132; // r6
  bool v133; // zf
  __int64 v134; // ST00_8
  __int64 v135; // r2
  bool v136; // zf
  __int64 v137; // r6
  signed int v138; // r3
  int v139; // r3
  int v140; // [sp+0h] [bp-78h]
  size_t v141; // [sp+24h] [bp-54h]
  unsigned int v142; // [sp+24h] [bp-54h]
  int v143; // [sp+28h] [bp-50h]
  signed int v144; // [sp+2Ch] [bp-4Ch]
  __int64 v145; // [sp+30h] [bp-48h]
  bool *v146; // [sp+38h] [bp-40h]
  _DWORD *v147; // [sp+3Ch] [bp-3Ch]
  __time_t v148; // [sp+40h] [bp-38h]
  int v149; // [sp+44h] [bp-34h]
  size_t n; // [sp+48h] [bp-30h]
  int v151; // [sp+4Ch] [bp-2Ch]

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 840);
  v4 = a1;
  *(_DWORD *)(a1 + 840) = 0;
  v144 = v3;
  if ( (*(_DWORD *)(v2 + 244) & 0x15) == 1 )
    v5 = *(_DWORD *)(a1 + 324);
  else
    v5 = -1;
  v146 = a2;
  if ( (*(_DWORD *)(v2 + 244) & 0x2A) == 2 )
    v6 = *(_DWORD *)(v4 + 328);
  else
    v6 = -1;
  if ( !v3 )
    v144 = Curl_socket_ready(v5, v6, 0);
  if ( v144 == 4 )
  {
    Curl_failf(v2, "select/poll returned error");
    return 55;
  }
  v8 = *(_DWORD *)(v2 + 244) & 1;
  if ( !v8 )
    goto LABEL_305;
  if ( !(v144 & 1) )
  {
    v8 = *(unsigned __int8 *)(v4 + 317);
    if ( !*(_BYTE *)(v4 + 317) )
      goto LABEL_305;
  }
  v147 = (_DWORD *)(v2 + 34148);
  *v146 = 0;
  v8 = 0;
LABEL_15:
  v9 = *(_DWORD *)(v2 + 604);
  v10 = *(_QWORD *)(v2 + 24);
  if ( !v9 )
    v9 = 0x4000;
  v11 = HIDWORD(v10) == -1;
  if ( HIDWORD(v10) == -1 )
    v11 = (_DWORD)v10 == -1;
  if ( v11
    || *(_BYTE *)(v2 + 96)
    || (v12 = v10 - *(_QWORD *)(v2 + 56), v12 >= v9)
    || (v9 = v10 - *(_DWORD *)(v2 + 56), (_DWORD)v10 != *(_DWORD *)(v2 + 56)) )
  {
    result = Curl_read(v4, *(_DWORD *)(v4 + 324), *(void **)(v2 + 232), v9, (int)&n);
    if ( result < 0 )
      goto LABEL_298;
    if ( result )
    {
LABEL_303:
      if ( !result )
        goto LABEL_304;
      return result;
    }
  }
  else
  {
    n = 0;
  }
  if ( !*(_QWORD *)(v2 + 56) && !*(_QWORD *)(v2 + 64) )
  {
    Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(5, v2)));
    if ( *(_DWORD *)(v2 + 156) )
    {
      curlx_tvnow(&v148);
      v13 = v149;
      v14 = (_DWORD *)(v2 + 148);
      *v14 = v148;
      v14[1] = v13;
    }
  }
  if ( n )
    v15 = 0;
  else
    v15 = *(_DWORD *)(v2 + 228) == 0;
  if ( (signed int)n <= 0 && !v15 )
  {
    *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
    goto LABEL_50;
  }
  *(_BYTE *)(*(_DWORD *)(v2 + 232) + n) = 0;
  *(_DWORD *)(v2 + 116) = *(_DWORD *)(v2 + 232);
  for ( i = *(unsigned __int8 *)(v2 + 96); ; i = **(unsigned __int8 **)(v2 + 116) )
  {
    if ( !i )
      goto LABEL_221;
    v31 = *(const void **)(v2 + 116);
    v32 = n;
    *(_DWORD *)(v2 + 120) = v31;
    v141 = v32;
    v33 = memchr(v31, 10, v32);
    v34 = *(_DWORD *)(v2 + 112);
    v35 = *(_DWORD *)(v2 + 1168);
    *(_DWORD *)(v2 + 124) = v33;
    if ( !v33 )
    {
      if ( v141 + v34 >= v35 )
      {
        v36 = *(void **)(v2 + 1164);
        v37 = 2 * v35;
        v38 = 3 * (v141 + v34) >> 1;
        if ( v38 < v37 )
          v38 = v37;
        v39 = *(_DWORD *)(v2 + 108) - (_DWORD)v36;
        v40 = (char *)((void *(__cdecl *)(void *, size_t))Curl_crealloc)(v36, v38);
        if ( !v40 )
        {
          v41 = v2;
LABEL_83:
          Curl_failf(v41, "Failed to alloc memory for big header!");
LABEL_148:
          result = 27;
LABEL_302:
          v8 = 1;
          goto LABEL_303;
        }
        *(_DWORD *)(v2 + 1164) = v40;
        *(_DWORD *)(v2 + 1168) = v38;
        *(_DWORD *)(v2 + 108) = &v40[v39];
      }
      memcpy(*(void **)(v2 + 108), *(const void **)(v2 + 116), n);
      v42 = n;
      *(_DWORD *)(v2 + 108) += n;
      v43 = v42 + *(_DWORD *)(v2 + 112);
      v44 = *(_DWORD *)(v2 + 104);
      *(_DWORD *)(v2 + 112) = v43;
      if ( !v44 && v43 > 5 && !sub_766C0(*(_DWORD *)(v2 + 616), *(_DWORD *)(v2 + 1164)) )
      {
        *(_BYTE *)(v2 + 96) = 0;
        v45 = 2;
        goto LABEL_90;
      }
      goto LABEL_221;
    }
    v46 = v33 - (_BYTE *)v31;
    v47 = (int)(v33 + 1);
    v48 = v46 + 1;
    v49 = v47 - (_DWORD)v31;
    n = v141 - v48;
    *(_DWORD *)(v2 + 116) = v47;
    if ( v49 + v34 >= v35 )
    {
      v50 = 2 * v35;
      v51 = *(void **)(v2 + 1164);
      v52 = 3 * (v49 + v34) >> 1;
      if ( v52 < v50 )
        v52 = v50;
      v142 = v52;
      v143 = *(_DWORD *)(v2 + 108) - (_DWORD)v51;
      v53 = (char *)((void *(__cdecl *)(void *, size_t))Curl_crealloc)(v51, v52);
      if ( !v53 )
      {
        v41 = v2;
        goto LABEL_83;
      }
      *(_DWORD *)(v2 + 1168) = v142;
      *(_DWORD *)(v2 + 1164) = v53;
      *(_DWORD *)(v2 + 108) = &v53[v143];
    }
    memcpy(*(void **)(v2 + 108), *(const void **)(v2 + 120), v49);
    v54 = *(_DWORD *)(v2 + 108);
    *(_DWORD *)(v2 + 108) = v54 + v49;
    *(_DWORD *)(v2 + 112) += v49;
    *(_BYTE *)(v54 + v49) = 0;
    v55 = *(_DWORD *)(v2 + 1164);
    *(_DWORD *)(v2 + 124) = *(_DWORD *)(v2 + 108);
    v56 = *(_DWORD *)(v2 + 104);
    *(_DWORD *)(v2 + 128) = v55;
    if ( !v56 && *(_DWORD *)(v2 + 112) > 5u && !sub_766C0(*(_DWORD *)(v2 + 616), v55) )
    {
      v57 = n;
      *(_BYTE *)(v2 + 96) = 0;
      if ( v57 )
      {
        v45 = 1;
LABEL_90:
        *(_DWORD *)(v2 + 100) = v45;
      }
      else
      {
        n = v48;
        *(_DWORD *)(v2 + 100) = 2;
      }
LABEL_221:
      if ( !*(_DWORD *)(v2 + 116) || *(_BYTE *)(v2 + 96) )
        goto LABEL_222;
      if ( (signed int)n <= 0 && !v15 )
        goto LABEL_296;
      if ( !*(_DWORD *)(v2 + 228) && !v15 && *(_DWORD *)(v4 + 48) & 1 )
      {
        if ( *(_DWORD *)(v2 + 256) )
        {
          v8 = 1;
          if ( *(_BYTE *)(v4 + 296) )
          {
            result = 0;
            *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
            *v146 = 1;
            goto LABEL_304;
          }
          *(_BYTE *)(v2 + 249) = 1;
          Curl_infof(v2, "Ignoring the response-body\n");
        }
        if ( *(_QWORD *)(v2 + 34192) && !*(_BYTE *)(v2 + 132) && *(_DWORD *)(v2 + 528) == 1 && !*(_BYTE *)(v2 + 249) )
        {
          Curl_failf(v2, "HTTP server doesn't seem to support byte ranges. Cannot resume.");
          return 33;
        }
        v94 = *(_DWORD *)(v2 + 520);
        if ( v94 )
        {
          if ( !*(_DWORD *)(v2 + 34188) )
          {
            v95 = *(_DWORD *)(v2 + 224);
            if ( v95 > 0 )
            {
              v96 = *(_DWORD *)(v2 + 524);
              if ( v96 > 0 )
              {
                if ( v94 == 2 )
                {
                  if ( v95 > v96 )
                  {
                    v8 = 1;
                    Curl_infof(v2, "The requested document is not old enough\n");
                    *v146 = 1;
                    *(_BYTE *)(v2 + 34224) = 1;
                    goto LABEL_301;
                  }
                }
                else if ( v95 < v96 )
                {
                  v8 = 1;
                  Curl_infof(v2, "The requested document is not new enough\n");
                  *v146 = 1;
                  result = 0;
                  *(_BYTE *)(v2 + 34224) = 1;
                  goto LABEL_304;
                }
              }
            }
          }
        }
      }
      ++*(_DWORD *)(v2 + 228);
      if ( *(_BYTE *)(v2 + 672) )
      {
        v97 = v2;
        v140 = v4;
        if ( !*(_DWORD *)(v2 + 100) )
          goto LABEL_252;
        Curl_debug(v2, 3u, *(const void **)(v2 + 1164), *(_DWORD *)(v2 + 112), v4);
        if ( *(_DWORD *)(v2 + 100) == 1 )
        {
          v97 = v2;
          v140 = v4;
LABEL_252:
          Curl_debug(v97, 3u, *(const void **)(v2 + 116), n, v140);
        }
      }
      if ( *(_BYTE *)(v2 + 268) )
      {
        v98 = Curl_httpchunk_read((int *)v4, *(const char **)(v2 + 116), n, &n);
        if ( v98 > 0 )
        {
          if ( v98 == 4 )
          {
            Curl_failf(v2, "Failed writing data");
            result = 23;
          }
          else
          {
            Curl_failf(v2, "Received problem %d in the chunky parser");
            result = 56;
          }
          return result;
        }
        if ( v98 == -1 )
        {
          *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
          v99 = *(_DWORD *)(v4 + 36);
          if ( v99 )
          {
            Curl_infof(*(_DWORD *)v4, "Leftovers after chunking.  Rewinding %d bytes\n", *(_DWORD *)(v4 + 36));
            *(_DWORD *)(v4 + 388) -= v99;
            *(_BYTE *)(v4 + 317) = 1;
          }
        }
      }
      v100 = *(_QWORD *)(v2 + 40);
      v101 = HIDWORD(v100) == -1;
      if ( HIDWORD(v100) == -1 )
        v101 = (_DWORD)v100 == -1;
      if ( !v101 )
      {
        v145 = *(_QWORD *)(v2 + 56);
        if ( v145 + (signed int)n >= v100 )
        {
          v102 = v145 + n - v100;
          if ( (_DWORD)v145 + n != (_DWORD)v100 && !*(_BYTE *)(v2 + 249) )
          {
            Curl_infof(
              v2,
              "Rewinding stream by : %d bytes on url %s (size = %lld, maxdownload = %lld, bytecount = %lld, nread = %d)\n",
              (_DWORD)v145 + n - (_DWORD)v100,
              *(_DWORD *)(v2 + 34180),
              *(_QWORD *)(v2 + 24),
              v100,
              v145,
              n);
            *(_DWORD *)(v4 + 388) -= v102;
            *(_BYTE *)(v4 + 317) = 1;
          }
          v103 = *(_DWORD *)(v2 + 40) - *(_DWORD *)(v2 + 56);
          if ( v103 < 0 )
            v103 = 0;
          n = v103;
          *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
        }
      }
      v104 = n;
      v105 = *(_QWORD *)(v2 + 56) + (signed int)n;
      *(_QWORD *)(v2 + 56) = v105;
      Curl_pgrsSetDownloadCounter(v2, v104, v105);
      if ( *(_BYTE *)(v2 + 268) )
        goto LABEL_222;
      v106 = *(_DWORD *)(v2 + 100);
      if ( n || v106 )
      {
        if ( v106 )
        {
          if ( !*(_BYTE *)(v2 + 249) )
          {
            result = Curl_client_write((int *)v4, 1, *(const char **)(v2 + 1164), *(_DWORD *)(v2 + 112));
            if ( result )
              goto LABEL_302;
          }
        }
LABEL_277:
        if ( *(_DWORD *)(v2 + 100) > 1u )
          goto LABEL_293;
        result = *(unsigned __int8 *)(*(_DWORD *)v4 + 705);
        if ( *(_BYTE *)(*(_DWORD *)v4 + 705) )
          goto LABEL_286;
        v107 = *(_DWORD *)(v2 + 160);
        if ( v107 == 1 )
        {
          if ( !*(_BYTE *)(v2 + 249) )
            result = Curl_unencode_deflate_write((int *)v4, v2 + 24, n);
        }
        else if ( v107 == 2 )
        {
          if ( !*(_BYTE *)(v2 + 249) )
            result = Curl_unencode_gzip_write((int *)v4, (_DWORD *)(v2 + 24), n);
        }
        else if ( v107 )
        {
          Curl_failf(
            v2,
            "Unrecognized content encoding type. libcurl understands `identity', `deflate' and `gzip' content encodings.");
          result = 61;
        }
        else
        {
LABEL_286:
          if ( !*(_BYTE *)(v2 + 249) )
          {
            result = Curl_client_write((int *)v4, 1, *(const char **)(v2 + 116), n);
            goto LABEL_294;
          }
LABEL_293:
          result = 0;
        }
LABEL_294:
        *(_DWORD *)(v2 + 100) = 0;
        if ( result )
          goto LABEL_302;
LABEL_222:
        if ( v15 )
          *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
        goto LABEL_296;
      }
      if ( v15 )
        goto LABEL_277;
LABEL_296:
      if ( !(*(_DWORD *)(v4 + 48) & 0x30) )
        goto LABEL_50;
      v8 = 1;
      goto LABEL_15;
    }
    v58 = *(const char **)(v2 + 128);
    v59 = *(unsigned __int8 *)v58;
    if ( v59 == 10 )
      break;
    if ( v59 == 13 )
    {
      *(_DWORD *)(v2 + 128) = v58 + 1;
      break;
    }
    v24 = *(_DWORD *)(v2 + 104);
    *(_DWORD *)(v2 + 104) = v24 + 1;
    if ( !v24 )
    {
      if ( sscanf(v58, " HTTP/%d.%d %3d", &v151, v4 + 192, v2 + 144) == 3 )
      {
        *(_DWORD *)(v4 + 192) += 10 * v151;
      }
      else
      {
        v68 = sscanf(*(const char **)(v2 + 128), " HTTP %3d", v2 + 144);
        *(_DWORD *)(v4 + 192) = 10;
        if ( !v68 )
        {
          if ( !sub_766C0(*(_DWORD *)(v2 + 616), *(_DWORD *)(v2 + 128)) )
          {
            *(_BYTE *)(v2 + 96) = 0;
            goto LABEL_221;
          }
          *(_DWORD *)(v2 + 144) = 200;
          *(_DWORD *)(v4 + 192) = 10;
        }
      }
      v65 = *(_DWORD *)(v2 + 144);
      *(_DWORD *)(v2 + 34208) = v65;
      *(_DWORD *)(v2 + 34216) = *(_DWORD *)(v4 + 192);
      v69 = *(_DWORD *)(v4 + 192);
      if ( !*v147 || *v147 > v69 )
        *v147 = v69;
      if ( *(_BYTE *)(v2 + 656) && v65 >= 400 )
      {
        if ( v65 == 401 )
        {
          v70 = *(unsigned __int8 *)(v4 + 300);
          goto LABEL_139;
        }
        if ( v65 != 407 )
          goto LABEL_404;
        v70 = *(unsigned __int8 *)(v4 + 301);
LABEL_139:
        if ( !v70 )
        {
LABEL_404:
          if ( !*(_QWORD *)(v2 + 34192) || *(_DWORD *)(v2 + 528) != 1 || v65 != 416 )
          {
            v64 = v2;
            goto LABEL_142;
          }
        }
      }
      v138 = *(_DWORD *)(v4 + 192);
      if ( v138 == 10 )
      {
        Curl_infof(v2, "HTTP 1.0, assume close after body\n");
        *(_BYTE *)(v4 + 296) = 1;
      }
      else if ( v138 > 10 && !*(_BYTE *)(v4 + 296) )
      {
        *(_BYTE *)(v4 + 370) = 1;
      }
      v139 = *(_DWORD *)(v2 + 144);
      if ( v139 == 304 || v139 == 416 || v139 == 204 )
      {
        if ( *(_DWORD *)(v2 + 520) )
          *(_BYTE *)(v2 + 34224) = 1;
        *(_QWORD *)(v2 + 24) = 0LL;
        *(_QWORD *)(v2 + 40) = 0LL;
        *(_BYTE *)(v2 + 250) = 1;
      }
    }
    if ( !*(_BYTE *)(v2 + 250) )
    {
      v25 = (char **)*(unsigned __int8 *)(v2 + 695);
      if ( !*(_BYTE *)(v2 + 695) && Curl_raw_nequal("Content-Length:", *(_DWORD *)(v2 + 128), 15) )
      {
        v26 = strtoll((const char *)(*(_DWORD *)(v2 + 128) + 15), v25, 10);
        v27 = *(_QWORD *)(v2 + 624);
        if ( v27 && v27 < v26 )
        {
          Curl_failf(v2, "Maximum file size exceeded");
          result = 63;
          goto LABEL_302;
        }
        if ( v26 < 0 )
        {
          *(_BYTE *)(v4 + 296) = 1;
          Curl_infof(v2, "Negative content-length: %lld, closing after transfer\n", (_DWORD)v26);
        }
        else
        {
          *(_QWORD *)(v2 + 24) = v26;
          *(_QWORD *)(v2 + 40) = v26;
          Curl_pgrsSetDownloadSize(v2, SHIDWORD(v27), v26);
        }
        goto LABEL_58;
      }
    }
    v71 = Curl_raw_nequal("Content-Type:", *(_DWORD *)(v2 + 128), 13);
    v72 = v71;
    if ( v71 )
    {
      v73 = Curl_copy_header_value(*(char **)(v2 + 128));
      v74 = v73;
      if ( !v73 )
        goto LABEL_148;
      if ( !*v73 )
        goto LABEL_214;
      Curl_safefree(*(_DWORD *)(v2 + 34248));
      *(_DWORD *)(v2 + 34248) = v74;
    }
    else
    {
      if ( *(_DWORD *)(v4 + 192) == 10
        && *(_BYTE *)(v4 + 299)
        && Curl_compareheader(*(_BYTE **)(v2 + 128), "Proxy-Connection:", "keep-alive") )
      {
        v75 = v2;
        *(_BYTE *)(v4 + 296) = v72;
        v76 = "HTTP/1.0 proxy connection set to keep alive!\n";
LABEL_159:
        Curl_infof(v75, v76);
        goto LABEL_58;
      }
      if ( *(_DWORD *)(v4 + 192) == 11
        && *(_BYTE *)(v4 + 299)
        && Curl_compareheader(*(_BYTE **)(v2 + 128), "Proxy-Connection:", "close") )
      {
        v75 = v2;
        *(_BYTE *)(v4 + 296) = 1;
        v76 = "HTTP/1.1 proxy connection set close!\n";
        goto LABEL_159;
      }
      if ( *(_DWORD *)(v4 + 192) == 10 && Curl_compareheader(*(_BYTE **)(v2 + 128), "Connection:", "keep-alive") )
      {
        v75 = v2;
        *(_BYTE *)(v4 + 296) = 0;
        v76 = "HTTP/1.0 connection set to keep alive!\n";
        goto LABEL_159;
      }
      if ( Curl_compareheader(*(_BYTE **)(v2 + 128), "Connection:", "close") )
      {
        *(_BYTE *)(v4 + 296) = 1;
      }
      else if ( Curl_compareheader(*(_BYTE **)(v2 + 128), "Transfer-Encoding:", "chunked") )
      {
        *(_BYTE *)(v2 + 268) = 1;
        Curl_httpchunk_init((_DWORD *)v4);
      }
      else if ( Curl_raw_nequal("Trailer:", *(_DWORD *)(v2 + 128), 8)
             || Curl_raw_nequal("Trailers:", *(_DWORD *)(v2 + 128), 9) )
      {
        *(_BYTE *)(v2 + 272) = 1;
      }
      else if ( Curl_raw_nequal("Content-Encoding:", *(_DWORD *)(v2 + 128), 17) && *(_DWORD *)(v2 + 744) )
      {
        v77 = (unsigned __int8 *)(*(_DWORD *)(v2 + 128) + 17);
        do
        {
          v78 = (int)v77;
          v80 = *v77++;
          v79 = v80;
        }
        while ( v80 && *(_BYTE *)(v79 + ctype_ + 1) & 8 );
        if ( Curl_raw_nequal("identity", v78, 8) )
        {
          v81 = 0;
LABEL_180:
          *(_DWORD *)(v2 + 160) = v81;
          goto LABEL_58;
        }
        if ( Curl_raw_nequal("deflate", v78, 7) )
        {
          v81 = 1;
          goto LABEL_180;
        }
        if ( Curl_raw_nequal("gzip", v78, 4) || Curl_raw_nequal("x-gzip", v78, 6) )
        {
          v81 = 2;
          goto LABEL_180;
        }
        if ( Curl_raw_nequal("compress", v78, 8) || Curl_raw_nequal("x-compress", v78, 10) )
        {
          v81 = 3;
          goto LABEL_180;
        }
      }
      else
      {
        if ( Curl_raw_nequal("Content-Range:", *(_DWORD *)(v2 + 128), 14) )
        {
          v82 = (const char *)(*(_DWORD *)(v2 + 128) + 14);
          do
          {
            v83 = v82;
            v85 = *(unsigned __int8 *)v82++;
            v84 = v85;
          }
          while ( v85 && (unsigned int)(v84 - 48) > 9 );
          v86 = strtoll(v83, 0, 10);
          *(_QWORD *)(v2 + 136) = v86;
          if ( *(_QWORD *)(v2 + 34192) == v86 )
            *(_BYTE *)(v2 + 132) = 1;
          goto LABEL_58;
        }
        if ( *(_DWORD *)(v2 + 884) && Curl_raw_nequal("Set-Cookie:", *(_DWORD *)(v2 + 128), 11) )
        {
          Curl_share_lock(v2, 2);
          v87 = *(const char **)(v4 + 360);
          if ( !v87 )
            v87 = *(const char **)(v4 + 140);
          Curl_cookie_add(v2, *(_DWORD *)(v2 + 884), 1, *(_DWORD *)(v2 + 128) + 11, v87, *(char **)(v2 + 34180));
          Curl_share_unlock(v2, 2);
          goto LABEL_58;
        }
        if ( Curl_raw_nequal("Last-Modified:", *(_DWORD *)(v2 + 128), 14)
          && (*(_DWORD *)(v2 + 520) || *(_BYTE *)(v2 + 649)) )
        {
          v151 = time(0);
          v88 = curl_getdate((char *)(*(_DWORD *)(v2 + 128) + 14));
          v89 = *(unsigned __int8 *)(v2 + 649);
          *(_DWORD *)(v2 + 224) = v88;
          if ( v89 )
            *(_DWORD *)(v2 + 34220) = v88;
          goto LABEL_58;
        }
        if ( Curl_raw_nequal("WWW-Authenticate:", *(_DWORD *)(v2 + 128), 17) && *(_DWORD *)(v2 + 144) == 401
          || (v90 = Curl_raw_nequal("Proxy-authenticate:", *(_DWORD *)(v2 + 128), 19), v91 = *(_DWORD *)(v2 + 144), v90)
          && v91 == 407 )
        {
          result = Curl_http_input_auth((int *)v4, *(_DWORD *)(v2 + 144), *(_DWORD *)(v2 + 128));
          goto LABEL_218;
        }
        if ( (unsigned int)(v91 - 300) <= 0x63 && Curl_raw_nequal("Location:", *(_DWORD *)(v2 + 128), 9) )
        {
          v73 = Curl_copy_header_value(*(char **)(v2 + 128));
          if ( !v73 )
            goto LABEL_148;
          if ( !*v73 )
          {
LABEL_214:
            ((void (__cdecl *)(void *))Curl_cfree)(v73);
            goto LABEL_58;
          }
          v92 = *(unsigned __int8 *)(v2 + 657);
          *(_DWORD *)(v2 + 252) = v73;
          if ( v92 )
          {
            v93 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v73);
            *(_DWORD *)(v2 + 256) = v93;
            if ( !v93 )
              goto LABEL_148;
            result = Curl_http_perhapsrewind(v4);
LABEL_218:
            if ( result )
              goto LABEL_302;
            goto LABEL_58;
          }
        }
      }
    }
LABEL_58:
    if ( *(_BYTE *)(v2 + 659) )
      v28 = 3;
    else
      v28 = 2;
    if ( *(_BYTE *)(v2 + 672) )
      Curl_debug(v2, 1u, *(const void **)(v2 + 128), *(_DWORD *)(v2 + 112), v4);
    result = Curl_client_write((int *)v4, v28, *(const char **)(v2 + 128), *(_DWORD *)(v2 + 112));
    if ( result )
      goto LABEL_302;
    v29 = *(_DWORD *)(v2 + 112);
    *(_DWORD *)(v2 + 34228) += v29;
    v30 = *(_DWORD *)(v2 + 72);
    *(_DWORD *)(v2 + 112) = 0;
    *(_DWORD *)(v2 + 72) = v29 + v30;
    *(_DWORD *)(v2 + 108) = *(_DWORD *)(v2 + 1164);
LABEL_65:
    ;
  }
  v60 = *(_BYTE **)(v2 + 128);
  if ( *v60 == 10 )
    *(_DWORD *)(v2 + 128) = v60 + 1;
  if ( (unsigned int)(*(_DWORD *)(v2 + 144) - 100) > 0x63 )
  {
    *(_BYTE *)(v2 + 96) = 0;
    v62 = *(_QWORD *)(v2 + 24);
    v63 = HIDWORD(v62) == -1;
    if ( HIDWORD(v62) == -1 )
      v63 = (_DWORD)v62 == -1;
    if ( v63 && !*(_BYTE *)(v2 + 268) && !*(_BYTE *)(v4 + 296) && *(_DWORD *)(v4 + 192) > 10 )
    {
      Curl_infof(v2, "no chunk, no close, no size. Assume close to signal end\n", (_DWORD)v62);
      *(_BYTE *)(v4 + 296) = 1;
    }
  }
  else
  {
    *(_BYTE *)(v2 + 96) = 1;
    v61 = *(_DWORD *)(v2 + 156);
    *(_DWORD *)(v2 + 104) = 0;
    if ( v61 )
    {
      *(_DWORD *)(v2 + 156) = 0;
      *(_DWORD *)(v2 + 244) |= 2u;
    }
  }
  if ( *(_DWORD *)(v2 + 144) == 417 )
  {
    *(_DWORD *)(v2 + 156) = 3;
    *(_DWORD *)(v2 + 244) &= 0xFFFFFFFD;
  }
  if ( Curl_http_should_fail((unsigned __int8 *)v4) )
  {
    v64 = v2;
    v65 = *(_DWORD *)(v2 + 144);
LABEL_142:
    Curl_failf(v64, "The requested URL returned error: %d", v65);
    result = 22;
    goto LABEL_302;
  }
  v17 = *(const char **)(v2 + 1164);
  v18 = *(_DWORD *)(v2 + 128) - (_DWORD)v17;
  if ( *(_BYTE *)(v2 + 659) )
    v19 = 3;
  else
    v19 = 2;
  result = Curl_client_write((int *)v4, v19, v17, *(_DWORD *)(v2 + 128) - (_DWORD)v17);
  if ( result )
    goto LABEL_302;
  *(_DWORD *)(v2 + 34228) += v18;
  v20 = *(_DWORD *)(v2 + 144);
  v21 = *(_DWORD *)(v2 + 72) + v18;
  *(_DWORD *)(v2 + 72) = v21;
  if ( (unsigned int)(v20 - 100) > 0x63 )
    v21 = 0;
  *(_DWORD *)(v2 + 76) = v21;
  if ( *(_QWORD *)(v2 + 34192) )
  {
    v23 = *(_DWORD *)(v2 + 528);
    if ( v23 == 1 && v20 == 416 )
      goto LABEL_405;
  }
  result = Curl_http_auth_act((unsigned __int8 *)v4);
  v22 = result;
  if ( result )
    goto LABEL_302;
  v23 = *(unsigned __int8 *)(v4 + 311);
  if ( !*(_BYTE *)(v4 + 311) )
  {
LABEL_405:
    v22 = v23;
  }
  else
  {
    Curl_infof(v2, "Keep sending data to get tossed away!\n");
    *(_DWORD *)(v2 + 244) |= 2u;
  }
  if ( *(_BYTE *)(v2 + 96) )
  {
    *(_DWORD *)(v2 + 108) = *(_DWORD *)(v2 + 1164);
    *(_DWORD *)(v2 + 112) = 0;
    if ( v22 )
      goto LABEL_50;
    goto LABEL_65;
  }
  if ( *(_BYTE *)(v2 + 662) )
  {
    v22 = 1;
  }
  else if ( *(_BYTE *)(v2 + 268) )
  {
    *(_QWORD *)(v2 + 24) = -1LL;
  }
  v66 = *(_QWORD *)(v2 + 24);
  v67 = HIDWORD(v66) == -1;
  if ( HIDWORD(v66) == -1 )
    v67 = (_DWORD)v66 == -1;
  if ( !v67 )
  {
    Curl_pgrsSetDownloadSize(v2, v20, v66);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(v2 + 24);
  }
  if ( !*(_QWORD *)(v2 + 40) || v22 )
  {
    v22 = 1;
    *(_DWORD *)(v2 + 244) &= 0xFFFFFFFE;
  }
  if ( *(_BYTE *)(v2 + 672) )
    Curl_debug(v2, 1u, *(const void **)(v2 + 120), v18, v4);
  if ( !v22 )
    goto LABEL_221;
LABEL_50:
  v8 = 1;
LABEL_298:
  if ( (*(_DWORD *)(v2 + 244) & 3) == 2 )
  {
    result = *(unsigned __int8 *)(v4 + 296);
    if ( *(_BYTE *)(v4 + 296) )
    {
      Curl_infof(v2, "we are done reading and this is set to close, stop send\n");
      *(_DWORD *)(v2 + 244) &= 0xFFFFFFFD;
      goto LABEL_301;
    }
  }
  else
  {
LABEL_301:
    result = 0;
  }
LABEL_304:
  if ( *v146 )
    return result;
LABEL_305:
  if ( !(*(_DWORD *)(v2 + 244) & 2) )
    goto LABEL_349;
  v108 = v144 << 30;
  if ( !(v144 & 2) )
    goto LABEL_349;
  if ( !*(_QWORD *)(v2 + 56) && !*(_QWORD *)(v2 + 64) )
    Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(5, v2)));
  v109 = v8 | 2;
  if ( *(_DWORD *)(v2 + 260) )
    goto LABEL_339;
  *(_DWORD *)(v2 + 264) = *(_DWORD *)(v2 + 236);
  if ( *(_BYTE *)(v2 + 248) )
    goto LABEL_312;
  if ( *(_DWORD *)(v2 + 156) == 2 && *(_DWORD *)(*(_DWORD *)(v2 + 34200) + 88) == 2 )
  {
    *(_DWORD *)(v2 + 156) = 1;
    *(_DWORD *)(v2 + 244) &= 0xFFFFFFFD;
    curlx_tvnow(&v148);
    v112 = v149;
    v113 = (_DWORD *)(v2 + 148);
    v109 = v8;
    *v113 = v148;
    v113[1] = v112;
    goto LABEL_348;
  }
  v114 = *(_DWORD *)(v4 + 48) & 1;
  if ( v114 )
  {
    v115 = *(_DWORD *)(*(_DWORD *)(v2 + 34200) + 88) - 1;
    v114 = v115 + (v115 <= 0) + 1 - *(_DWORD *)(*(_DWORD *)(v2 + 34200) + 88);
  }
  result = Curl_fillreadbuffer(v4, 0x4000u, (size_t *)&v151);
  if ( result )
  {
LABEL_347:
    if ( !result )
      goto LABEL_348;
    return result;
  }
  v116 = v151;
  if ( !v151 )
  {
LABEL_312:
    v110 = *(_DWORD *)(v2 + 244);
    v111 = v110 << 26;
    if ( !(v110 & 0x20) )
      goto LABEL_322;
    goto LABEL_348;
  }
  if ( v151 > 0 )
  {
    *(_DWORD *)(v2 + 260) = v151;
    if ( !v114 && (*(_BYTE *)(v2 + 489) || *(_BYTE *)(v2 + 651)) )
    {
      if ( !*(_DWORD *)(v2 + 33980) )
        *(_DWORD *)(v2 + 33980) = ((void *(__cdecl *)(size_t))Curl_cmalloc)(0x8000u);
      if ( !*(_DWORD *)(v2 + 33980) )
      {
        Curl_failf(v2, "Failed to alloc scratch buffer!");
        return 27;
      }
      v117 = 0;
      v118 = (_DWORD *)(v2 + 33980);
      v119 = 0;
      do
      {
        v120 = *(unsigned __int8 *)(*(_DWORD *)(v2 + 264) + v119);
        if ( v120 == 10 )
        {
          v121 = v117 + 1;
          *(_BYTE *)(*v118 + v117) = 13;
          *(_BYTE *)(*v118 + v117 + 1) = 10;
          if ( !*(_BYTE *)(v2 + 489) )
          {
            v122 = *(_QWORD *)(v2 + 440);
            LODWORD(v122) = *(unsigned __int64 *)(v2 + 440) + 1;
            *(_QWORD *)(v2 + 440) = v122 + 1;
          }
        }
        else
        {
          v121 = v117;
          *(_BYTE *)(*v118 + v117) = v120;
        }
        ++v119;
        v117 = v121 + 1;
      }
      while ( v119 != v116 );
      if ( v117 != v119 )
      {
        v123 = *(_DWORD *)(v2 + 33980);
        *(_DWORD *)(v2 + 260) = v117;
        *(_DWORD *)(v2 + 264) = v123;
      }
    }
LABEL_339:
    result = Curl_write((int *)v4, *(_DWORD *)(v4 + 328), *(const void **)(v2 + 264), *(_DWORD *)(v2 + 260), &v151);
    if ( !result )
    {
      if ( *(_BYTE *)(v2 + 672) )
        Curl_debug(v2, 4u, *(const void **)(v2 + 264), v151, v4);
      v124 = *(_DWORD *)(v2 + 260);
      v125 = v151;
      if ( v124 == v151 )
      {
        *(_DWORD *)(v2 + 264) = *(_DWORD *)(v2 + 236);
        *(_DWORD *)(v2 + 260) = 0;
        if ( *(_BYTE *)(v2 + 248) )
          *(_DWORD *)(v2 + 244) &= 0xFFFFFFFD;
      }
      else
      {
        *(_DWORD *)(v2 + 260) = v124 - v151;
        *(_DWORD *)(v2 + 264) += v125;
      }
      v126 = *(_QWORD *)(v2 + 64) + v125;
      *(_QWORD *)(v2 + 64) = v126;
      Curl_pgrsSetUploadCounter(v2, v125, v126);
      goto LABEL_348;
    }
    goto LABEL_347;
  }
LABEL_322:
  *(_DWORD *)(v2 + 244) &= 0xFFFFFFFD;
  if ( *(_BYTE *)(v4 + 311) )
  {
    result = Curl_readrewind(v4, v108, v111);
    goto LABEL_347;
  }
LABEL_348:
  v8 = v109;
LABEL_349:
  v127 = (int *)(v2 + 88);
  curlx_tvnow(&v148);
  v128 = v149;
  *(_DWORD *)(v2 + 88) = v148;
  *(_DWORD *)(v2 + 92) = v128;
  if ( v8 )
  {
    v129 = *(_QWORD **)(v2 + 32);
    if ( v129 )
      *v129 = *(_QWORD *)(v2 + 56);
    v130 = *(_QWORD **)(v2 + 48);
    if ( v130 )
      *v130 = *(_QWORD *)(v2 + 64);
  }
  else if ( *(_DWORD *)(v2 + 156) == 1
         && curlx_tvdiff(*v127, *(_DWORD *)(v2 + 92), *(_DWORD *)(v2 + 148), *(_DWORD *)(v2 + 152)) > 1000 )
  {
    v131 = *(_DWORD *)(v2 + 244) | 2;
    *(_DWORD *)(v2 + 156) = 0;
    *(_DWORD *)(v2 + 244) = v131;
    Curl_infof(v2, "Done waiting for 100-continue\n");
  }
  if ( Curl_pgrsUpdate((int *)v4) )
    return 42;
  result = Curl_speedcheck(v2, *v127, *(_DWORD *)(v2 + 92));
  if ( !result )
  {
    if ( *(_DWORD *)(v2 + 424)
      && curlx_tvdiff(*v127, *(_DWORD *)(v2 + 92), *(_DWORD *)(v2 + 80), *(_DWORD *)(v2 + 84)) >= *(_DWORD *)(v2 + 424) )
    {
      v132 = *(_QWORD *)(v2 + 24);
      v133 = HIDWORD(v132) == -1;
      if ( HIDWORD(v132) == -1 )
        v133 = (_DWORD)v132 == -1;
      v134 = *(_QWORD *)(v2 + 56);
      if ( v133 )
        Curl_failf(v2, "Operation timed out after %ld milliseconds with %lld bytes received");
      else
        Curl_failf(v2, "Operation timed out after %ld milliseconds with %lld out of %lld bytes received");
      return 28;
    }
    if ( *(_DWORD *)(v2 + 244) )
    {
LABEL_369:
      result = 0;
      *v146 = (*(_DWORD *)(v2 + 244) & 0x33) == 0;
      return result;
    }
    if ( !*(_BYTE *)(v2 + 662) )
    {
      v135 = *(_QWORD *)(v2 + 24);
      v136 = HIDWORD(v135) == -1;
      if ( HIDWORD(v135) == -1 )
        v136 = (_DWORD)v135 == -1;
      if ( !v136 )
      {
        v137 = *(_QWORD *)(v2 + 56);
        if ( v137 != v135 && v137 != *(_QWORD *)(v2 + 34160) + v135 && !*(_DWORD *)(v2 + 256) )
        {
          Curl_failf(v2, "transfer closed with %lld bytes remaining to read", v135 - v137);
          return 18;
        }
      }
      if ( *(_BYTE *)(v2 + 268) && *(_DWORD *)(v4 + 28) != 8 )
      {
        Curl_failf(v2, "transfer closed with outstanding read data remaining");
        return 18;
      }
    }
    if ( Curl_pgrsUpdate((int *)v4) )
      return 42;
    goto LABEL_369;
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00077B74) --------------------------------------------------------
int __fastcall Curl_single_getsock(_DWORD *a1, _DWORD *a2, signed int a3)
{
  _DWORD *v3; // r3
  int v4; // r6
  unsigned int v5; // r4
  int v7; // r2
  int v8; // r0

  v3 = a1;
  v4 = *a1;
  v5 = *(_DWORD *)(a1[80] + 40);
  if ( v5 )
    return ((int (*)(void))v5)();
  if ( a3 <= 1 )
    return v5;
  if ( (*(_DWORD *)(v4 + 244) & 0x15) == 1 )
  {
    v5 = 1;
    *a2 = a1[81];
  }
  if ( (*(_DWORD *)(v4 + 244) & 0x2A) != 2 )
    return v5;
  v7 = a1[82];
  v8 = *(_DWORD *)(v4 + 244) & 1;
  if ( v3[81] == v7 && v8 )
    LOBYTE(v8) = 0;
  else
    a2[v8] = v7;
  return (1 << (v8 + 16)) | v5;
}

//----- (00077BD8) --------------------------------------------------------
signed int __fastcall Curl_pretransfer(_DWORD *a1)
{
  int v1; // r4
  signed int result; // r0
  int v3; // r5
  _BYTE *v4; // r7
  int v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r2

  v1 = (int)a1;
  if ( a1[216] )
  {
    v3 = (int)(a1 + 8512);
    v4 = a1 + 8448;
    a1[80] = 0;
    v4[160] = 0;
    v4[192] = 0;
    *(_DWORD *)(v3 + 100) = 0;
    *(_BYTE *)(v3 + 52) = 0;
    *(_DWORD *)(v3 + 20) = a1[78];
    v5 = a1[79];
    v6 = a1[8563];
    *(_DWORD *)(v3 + 36) = v5;
    Curl_safefree(v6);
    *(_DWORD *)(v3 + 204) = 0;
    if ( *(_DWORD *)(v1 + 880) )
      Curl_cookie_loadfiles(v1);
    v4[200] = 1;
    Curl_initinfo(v1);
    Curl_pgrsStartNow(v1, v7, v8);
    result = 0;
  }
  else
  {
    Curl_failf((int)a1, "No URL set!");
    result = 3;
  }
  return result;
}

//----- (00077C48) --------------------------------------------------------
int __fastcall Curl_posttransfer(int a1)
{
  if ( !(*(_DWORD *)(a1 + 944) & 0x10) && !*(_BYTE *)(a1 + 936) )
    curl_mfprintf(*(_DWORD *)(a1 + 280), "\n");
  return 0;
}

//----- (00077C6C) --------------------------------------------------------
signed int __fastcall Curl_follow(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r4
  int v5; // r2
  char *v7; // r0
  const char *v8; // r0
  char *v9; // r9
  char *v10; // r0
  char *v11; // r6
  char *v12; // r0
  char *v13; // r0
  char *v14; // r0
  unsigned __int8 *v15; // r7
  int v16; // r11
  char *v17; // r0
  char *v18; // r7
  char *v19; // r0
  char *v20; // r0
  int v21; // r11
  size_t v22; // r0
  _BYTE *v23; // r0
  _BYTE *v24; // r10
  int v25; // r2
  int v26; // r12
  int v27; // r0
  _BYTE *v28; // r0
  _BYTE *v29; // r6
  void *v30; // r0
  int v31; // r3
  int v32; // r0
  char *v33; // r1
  const char *v34; // r2
  size_t n; // [sp+4h] [bp-4Ch]
  int v36; // [sp+8h] [bp-48h]
  char v37; // [sp+13h] [bp-3Dh]
  char v38; // [sp+14h] [bp-3Ch]

  v3 = a2;
  v4 = a1;
  v36 = a3;
  if ( a3 != 3 )
    goto LABEL_11;
  v5 = *(_DWORD *)(a1 + 324);
  if ( v5 != -1 && *(_DWORD *)(a1 + 320) >= v5 )
  {
    Curl_failf(a1, "Maximum (%d) redirects followed");
    return 47;
  }
  *(_BYTE *)(a1 + 33952) = 1;
  ++*(_DWORD *)(a1 + 320);
  if ( !*(_BYTE *)(a1 + 661) )
  {
LABEL_11:
    if ( sscanf((const char *)v3, "%15[^?&/:]://%c", &v38, &v37) == 2 )
    {
      if ( strchr((const char *)v3, 32) )
      {
        v27 = sub_76660(v3);
        v28 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v27 + 1);
        v29 = v28;
        if ( !v28 )
          return 27;
        sub_76684(v28, v3);
        v30 = (void *)v3;
        v3 = (int)v29;
        ((void (__cdecl *)(void *))Curl_cfree)(v30);
      }
      if ( v36 == 1 )
      {
        v24 = (_BYTE *)v3;
LABEL_63:
        *(_DWORD *)(v4 + 34252) = v24;
        return 0;
      }
      v24 = (_BYTE *)v3;
      *(_BYTE *)(v4 + 33992) = 0;
    }
    else
    {
      v8 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(*(const char **)(v4 + 864));
      v9 = (char *)v8;
      if ( !v8 )
        return 27;
      v10 = strstr(v8, "//");
      if ( v10 )
        v11 = v10 + 2;
      else
        v11 = v9;
      if ( *(_BYTE *)v3 == 47 )
      {
        v18 = strchr(v11, 47);
        if ( v18 )
        {
          v19 = strchr(v11, 63);
          if ( v19 && v18 >= v19 )
            v18 = v19;
          *v18 = 0;
        }
        else
        {
          v20 = strchr(v11, 63);
          if ( v20 )
            *v20 = 0;
        }
        v15 = (unsigned __int8 *)v3;
      }
      else
      {
        v12 = strchr(v11, 63);
        if ( v12 )
          *v12 = 0;
        if ( *(_BYTE *)v3 != 63 )
        {
          v13 = strrchr(v11, 47);
          if ( v13 )
            *v13 = 0;
        }
        v14 = strchr(v11, 47);
        if ( v14 )
          v11 = v14 + 1;
        else
          v11 = 0;
        if ( *(_BYTE *)v3 != 46 || *(_BYTE *)(v3 + 1) != 47 )
          v15 = (unsigned __int8 *)v3;
        else
          v15 = (unsigned __int8 *)(v3 + 2);
        v16 = 0;
        while ( *v15 == 46 && v15[1] == 46 && v15[2] == 47 )
        {
          ++v16;
          v15 += 3;
        }
        if ( v11 )
        {
          while ( v16 )
          {
            v17 = strrchr(v11, 47);
            --v16;
            if ( !v17 )
            {
              *v11 = 0;
              break;
            }
            *v17 = 0;
          }
        }
      }
      v21 = sub_76660((int)v15);
      v22 = strlen(v9);
      n = v22;
      v23 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v22 + v21 + 2);
      v24 = v23;
      if ( !v23 )
      {
        ((void (__cdecl *)(void *))Curl_cfree)(v9);
        return 27;
      }
      memcpy(v23, v9, n);
      v25 = *v15;
      v26 = n;
      if ( v25 != 47 && (!v11 || *v11) && v25 != 63 )
      {
        v24[n] = 47;
        v26 = n + 1;
      }
      sub_76684(&v24[v26], (int)v15);
      ((void (__cdecl *)(void *))Curl_cfree)(v9);
      ((void (__cdecl *)(void *))Curl_cfree)((void *)v3);
      if ( v36 == 1 )
        goto LABEL_63;
    }
    if ( *(_BYTE *)(v4 + 868) )
      ((void (__cdecl *)(void *))Curl_cfree)(*(void **)(v4 + 864));
    else
      *(_BYTE *)(v4 + 868) = 1;
    *(_DWORD *)(v4 + 864) = v24;
    Curl_infof(v4, "Issue another request to this URL: '%s'\n", v24);
    v31 = *(_DWORD *)(v4 + 34208);
    if ( v31 == 302 )
    {
      if ( (unsigned int)(*(_DWORD *)(v4 + 528) - 2) > 1 || *(_BYTE *)(v4 + 329) )
        goto LABEL_83;
      v32 = v4;
      v33 = "Violate RFC 2616/10.3.3 and switch from POST to GET\n";
    }
    else
    {
      if ( v31 == 303 )
      {
        if ( *(_DWORD *)(v4 + 528) != 1 )
        {
          *(_DWORD *)(v4 + 528) = 1;
          if ( *(_BYTE *)(v4 + 662) )
            v34 = "HEAD";
          else
            v34 = "GET";
          Curl_infof(v4, "Disables POST, goes with %s\n", v34);
        }
        goto LABEL_83;
      }
      if ( v31 != 301 || (unsigned int)(*(_DWORD *)(v4 + 528) - 2) > 1 || *(_BYTE *)(v4 + 328) )
      {
LABEL_83:
        Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(8, v4)));
        Curl_pgrsResetTimes((_QWORD *)v4);
        return 0;
      }
      v32 = v4;
      v33 = "Violate RFC 2616/10.3.2 and switch from POST to GET\n";
    }
    Curl_infof(v32, v33);
    *(_DWORD *)(v4 + 528) = 1;
    goto LABEL_83;
  }
  if ( *(_BYTE *)(a1 + 876) )
    ((void (__cdecl *)(void *))Curl_cfree)(*(void **)(a1 + 872));
  v7 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(*(const char **)(v4 + 864));
  *(_DWORD *)(v4 + 872) = v7;
  if ( v7 )
  {
    *(_BYTE *)(v4 + 876) = 1;
    goto LABEL_11;
  }
  *(_BYTE *)(v4 + 876) = 0;
  return 27;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00077FD4) --------------------------------------------------------
int __fastcall Curl_retry_request(_DWORD *a1, _DWORD *a2)
{
  _BYTE *v2; // r4
  int v3; // r5
  _DWORD *v4; // r6
  int result; // r0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( !*(_BYTE *)(*a1 + 664) || (result = a1[12] & 1) != 0 )
  {
    if ( *(_QWORD *)(v3 + 56) + *(signed int *)(v3 + 72) )
      goto LABEL_10;
    result = (unsigned __int8)v2[297];
    if ( !v2[297] )
      return result;
    if ( *(_BYTE *)(v3 + 662) )
    {
LABEL_10:
      result = 0;
    }
    else
    {
      Curl_infof(v3, "Connection died, retrying a fresh connect\n");
      *v4 = Curl_cstrdup(*(_DWORD *)(*(_DWORD *)v2 + 864));
      result = 1;
      v2[296] = 1;
      v2[307] = 1;
    }
  }
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (0007803C) --------------------------------------------------------
signed int __fastcall Curl_perform(_DWORD *a1)
{
  int v1; // r6
  signed int result; // r0
  int v3; // r2
  int *v4; // r4
  int **v5; // r3
  int v6; // r5
  int (__fastcall *v7)(int *, int, int); // r0
  int v8; // r0
  int v9; // r11
  int v10; // r10
  int v11; // r5
  int v12; // r1
  __int64 v13; // r2
  int v14; // r4
  int v15; // r5
  __int64 v16; // r0
  int v17; // r0
  int v18; // r3
  signed int v19; // r2
  int v20; // r1
  int v21; // r2
  int v22; // r0
  int v23; // r10
  const char *v24; // r0
  char *v25; // r0
  const char *v26; // r0
  const char *v27; // r2
  char *v28; // r1
  int (__fastcall *v29)(int *, int, int); // r0
  int v30; // r0
  signed int v31; // [sp+0h] [bp-40h]
  unsigned __int8 v32; // [sp+Eh] [bp-32h]
  char v33; // [sp+Fh] [bp-31h]
  int v34; // [sp+10h] [bp-30h]
  void *ptr; // [sp+14h] [bp-2Ch]

  v34 = 0;
  v1 = (int)a1;
  ptr = 0;
  a1[286] = 1;
  result = Curl_pretransfer(a1);
  if ( result )
    return result;
  while ( 1 )
  {
    v33 = 1;
    Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(7, v1)));
    v4 = Curl_connect(v1, &v34, &v32, &v33);
    if ( v4 )
      goto LABEL_64;
    v5 = (int **)v32;
    if ( v32 )
    {
      v4 = (int *)Curl_wait_for_resolv((int *)v34, 0);
      if ( v4 )
        Curl_disconnect((int **)v34);
      else
        v4 = (int *)Curl_async_resolved((int **)v34, &v33);
      if ( v4 )
        goto LABEL_64;
    }
    v6 = *(unsigned __int8 *)(v1 + 697);
    if ( *(_BYTE *)(v1 + 697) )
    {
      *(_BYTE *)(v34 + 296) = (_BYTE)v4;
      v7 = Curl_done((int **)&v34, 0, 0);
LABEL_63:
      v4 = (int *)v7;
      goto LABEL_64;
    }
    v8 = Curl_do((int ***)&v34, (int)&v32, v3, v5);
    v9 = v34;
    v4 = (int *)v8;
    if ( v8 )
      break;
    v10 = *(_DWORD *)v34;
    v33 = 0;
    if ( (*(_DWORD *)(v34 + 324) != -1 || *(_DWORD *)(v34 + 328) != -1)
      && (*(_BYTE *)(v10 + 270) || !*(_BYTE *)(v10 + 662)) )
    {
      v31 = 1;
      while ( 1 )
      {
        if ( v33 )
          break;
        v12 = *(_DWORD *)(v10 + 244);
        if ( v12 & 2 )
        {
          v13 = *(_QWORD *)(v10 + 456);
          if ( !v13 || *(_QWORD *)(v10 + 968) < v13 )
          {
            v14 = *(_DWORD *)(v9 + 328);
            *(_DWORD *)(v10 + 244) = v12 & 0xFFFFFFF7;
            goto LABEL_24;
          }
          *(_DWORD *)(v10 + 244) = v12 | 8;
        }
        v14 = -1;
LABEL_24:
        v15 = *(_DWORD *)(v10 + 244);
        if ( !(v15 & 1) )
          goto LABEL_29;
        v16 = *(_QWORD *)(v10 + 464);
        if ( v16 && *(_QWORD *)(v10 + 960) >= v16 )
        {
          *(_DWORD *)(v10 + 244) = v15 | 4;
LABEL_29:
          v17 = -1;
          goto LABEL_30;
        }
        v17 = *(_DWORD *)(v9 + 324);
        *(_DWORD *)(v10 + 244) = v15 & 0xFFFFFFFB;
LABEL_30:
        v18 = *(_DWORD *)(v10 + 244);
        if ( v18 & 0x10 )
          v17 = -1;
        if ( v18 & 0x20 )
          v14 = -1;
        if ( v31 )
        {
          if ( v17 == -1 )
          {
            if ( v14 == -1 )
              v19 = 1000;
            else
              v19 = 0;
          }
          else
          {
            v19 = 0;
          }
        }
        else
        {
          v19 = 1000;
        }
        if ( Curl_socket_ready(v17, v14, v19) == -1 )
        {
          if ( *(_DWORD *)_errno(0, v20, v21) != 4 )
          {
            v11 = 56;
            goto LABEL_48;
          }
        }
        else
        {
          v22 = Curl_readwrite(v9, (bool *)&v33);
          v11 = v22;
          if ( v22 )
          {
            if ( v22 != 56 )
              goto LABEL_81;
            goto LABEL_48;
          }
          v31 = 0;
        }
      }
    }
    v11 = 0;
LABEL_48:
    if ( Curl_retry_request((_DWORD *)v34, &ptr) )
    {
      v23 = 2;
      if ( ptr )
        goto LABEL_76;
    }
    else
    {
      if ( v11 )
      {
LABEL_81:
        v23 = 0;
        goto LABEL_83;
      }
      v24 = *(const char **)(v1 + 256);
      if ( v24 )
      {
        v23 = 3;
        v25 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v24);
        ptr = v25;
      }
      else
      {
        v26 = *(const char **)(v1 + 252);
        if ( !v26 )
        {
          v23 = 0;
LABEL_76:
          v11 = 0;
          goto LABEL_77;
        }
        v23 = 1;
        v25 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v26);
        ptr = v25;
      }
      if ( v25 )
        goto LABEL_76;
    }
    v11 = 27;
LABEL_83:
    v30 = *(_DWORD *)(v34 + 216);
    *(_BYTE *)(v34 + 296) = 1;
    if ( v30 != -1 )
    {
      close(v30);
      *(_DWORD *)(v34 + 216) = -1;
    }
LABEL_77:
    v29 = Curl_done((int **)&v34, v11, 0);
    v4 = (int *)v29;
    if ( v11 )
    {
      v4 = (int *)v11;
      goto LABEL_64;
    }
    if ( !v29 && v23 )
    {
      v7 = (int (__fastcall *)(int *, int, int))Curl_follow(v1, (int)ptr, v23);
      if ( v7 )
        goto LABEL_63;
      ptr = 0;
      if ( v23 != 1 )
        continue;
    }
    goto LABEL_64;
  }
  if ( v34 )
    Curl_done((int **)&v34, v8, v6);
LABEL_64:
  if ( ptr )
    ((void (__cdecl *)(void *))Curl_cfree)(ptr);
  if ( v4 && !*(_BYTE *)(v1 + 33984) )
  {
    v27 = curl_easy_strerror((int)v4);
    if ( v27 )
    {
      v28 = "%s";
    }
    else
    {
      v27 = (const char *)v4;
      v28 = "unspecified error %d";
    }
    Curl_failf(v1, v28, v27);
  }
  result = Curl_posttransfer(v1);
  if ( v4 )
    result = (signed int)v4;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00078324) --------------------------------------------------------
int __fastcall Curl_setup_transfer(int *a1, int a2, __int64 a3, char a4, int a5, int a6, int a7)
{
  bool v7; // zf
  int *v8; // r5
  int v9; // r6
  int v10; // r4
  _DWORD *v11; // r3
  _DWORD *v12; // r4
  int v13; // r1

  v7 = a2 == -1;
  v8 = a1;
  if ( a2 != -1 )
    a2 = (int)&a1[a2];
  v9 = a6;
  v10 = *a1;
  if ( !v7 )
    a2 = *(_DWORD *)(a2 + 212);
  a1[81] = a2;
  if ( a6 != -1 )
    v9 = (int)&a1[a6];
  if ( a6 != -1 )
    v9 = *(_DWORD *)(v9 + 212);
  a1[82] = v9;
  *(_DWORD *)(v10 + 32) = a5;
  *(_BYTE *)(v10 + 270) = a4;
  *(_QWORD *)(v10 + 24) = a3;
  *(_DWORD *)(v10 + 48) = a7;
  if ( !a4 )
  {
    *(_BYTE *)(v10 + 96) = 0;
    if ( a3 >= 1 )
      Curl_pgrsSetDownloadSize(v10, HIDWORD(a3) - ((unsigned int)a3 < 1), a3);
  }
  if ( *(_BYTE *)(v10 + 270) || !*(_BYTE *)(v10 + 662) )
  {
    if ( v8[81] != -1 )
      *(_DWORD *)(v10 + 244) |= 1u;
    if ( v8[82] != -1 )
    {
      if ( *(_BYTE *)(v10 + 34152) )
      {
        if ( *(_DWORD *)(*(_DWORD *)(v10 + 34200) + 88) == 2 )
        {
          *(_DWORD *)(v10 + 156) = 1;
          v11 = (_DWORD *)(v10 + 148);
          v12 = (_DWORD *)(v10 + 80);
          v13 = v12[1];
          *v11 = *v12;
          v11[1] = v13;
          return 0;
        }
        *(_DWORD *)(v10 + 156) = 2;
      }
      *(_DWORD *)(v10 + 244) |= 2u;
      return 0;
    }
  }
  return 0;
}

//----- (000783E2) --------------------------------------------------------
bool __fastcall curl_strequal(const char *a1, const char *a2)
{
  return strcasecmp(a1, a2) == 0;
}

//----- (000783F2) --------------------------------------------------------
bool __fastcall curl_strnequal(const char *a1, const char *a2, size_t a3)
{
  return strncasecmp(a1, a2, a3) == 0;
}

//----- (00078402) --------------------------------------------------------
_DWORD *__fastcall Curl_httpchunk_init(_DWORD *result)
{
  result[6] = 0;
  result[9] = 0;
  result[7] = 1;
  return result;
}

//----- (00078410) --------------------------------------------------------
signed int __fastcall Curl_httpchunk_read(int *a1, const char *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r8
  int v5; // r7
  int *v6; // r4
  const char *v7; // r5
  unsigned int v8; // r6
  signed int result; // r0
  int v10; // r2
  char *v11; // r1
  signed int v12; // r3
  unsigned int v13; // r0
  signed int v14; // r3
  int v15; // r3
  int v16; // t1
  int v17; // r0
  int v18; // r11
  int v19; // r3
  int v20; // r3
  signed int v21; // r0
  signed int v22; // r3
  int v23; // r1
  int v24; // r1
  int v25; // r0
  int v26; // r0
  int v27; // r3
  int v28; // r2
  int v29; // r3
  int v30; // r1
  int v31; // r3

  v4 = a4;
  v5 = *a1;
  *a4 = 0;
  v6 = a1;
  v7 = a2;
  v8 = a3;
  if ( *(_BYTE *)(v5 + 704) && !*(_BYTE *)(v5 + 249) && Curl_client_write(a1, 1, a2, a3) )
    return 4;
  while ( 2 )
  {
    if ( !v8 )
      return 0;
    switch ( v6[7] )
    {
      case 1:
        v10 = *(unsigned __int8 *)v7;
        if ( (unsigned int)(v10 - 48) <= 9 )
        {
          v11 = (_BYTE *)(&dword_0 + 1);
        }
        else if ( (v10 & 0xFFFFFFDF) - 65 <= 5 )
        {
          v11 = (char *)&dword_0 + 1;
        }
        else
        {
          v11 = 0;
        }
        v12 = v6[6];
        if ( v11 )
        {
          if ( v12 > 15 )
            return 1;
          ++v7;
          --v8;
          *((_BYTE *)v6 + v12 + 4) = v10;
          v6[6] = v12 + 1;
          continue;
        }
        if ( !v12 )
          return 2;
        *((_BYTE *)v6 + v12 + 4) = 0;
        v13 = strtoul((const char *)v6 + 4, 0, 16);
        v14 = 2;
        v6[8] = v13;
        goto LABEL_25;
      case 2:
        v15 = *(unsigned __int8 *)v7;
        --v8;
        ++v7;
        if ( v15 == 13 )
          v6[7] = 3;
        continue;
      case 3:
        v16 = *(unsigned __int8 *)v7++;
        --v8;
        if ( v16 != 10 )
        {
          v14 = 3;
          goto LABEL_25;
        }
        if ( v6[8] )
        {
          v14 = 4;
          goto LABEL_25;
        }
        if ( !*(_BYTE *)(v5 + 272) )
        {
          v14 = 7;
          goto LABEL_25;
        }
        v6[7] = 9;
        v6[183] = 0;
        continue;
      case 4:
        v17 = *v6;
        if ( v8 >= v6[8] )
          v18 = v6[8];
        else
          v18 = v8;
        if ( *(_BYTE *)(v17 + 705) )
          goto LABEL_36;
        v19 = *(_DWORD *)(v5 + 160);
        if ( v19 == 1 )
        {
          *(_DWORD *)(v5 + 116) = v7;
          v21 = Curl_unencode_deflate_write(v6, v5 + 24, v18);
          goto LABEL_44;
        }
        if ( v19 == 2 )
        {
          *(_DWORD *)(v5 + 116) = v7;
          v21 = Curl_unencode_gzip_write(v6, (_DWORD *)(v5 + 24), v18);
LABEL_44:
          if ( v21 )
            return 4;
          goto LABEL_37;
        }
        if ( v19 )
        {
          Curl_failf(
            v17,
            "Unrecognized content encoding type. libcurl understands `identity', `deflate' and `gzip' content encodings.");
          return 6;
        }
LABEL_36:
        if ( !*(_BYTE *)(v5 + 249) && !*(_BYTE *)(v5 + 704) )
        {
          v21 = Curl_client_write(v6, 1, v7, v18);
          goto LABEL_44;
        }
LABEL_37:
        v7 += v18;
        v8 -= v18;
        *v4 += v18;
        v20 = v6[8] - v18;
        v6[8] = v20;
        if ( !v20 )
        {
          v14 = 5;
LABEL_25:
          v6[7] = v14;
        }
        continue;
      case 5:
        if ( *v7 != 13 )
          return 3;
        v22 = 6;
        goto LABEL_70;
      case 6:
        if ( *v7 != 10 )
          return 3;
        Curl_httpchunk_init(v6);
        goto LABEL_65;
      case 7:
        if ( *v7 != 13 )
          return 3;
        v22 = 8;
        goto LABEL_70;
      case 8:
        if ( *v7 == 10 )
          goto LABEL_72;
        return 3;
      case 9:
        v23 = v6[182];
        if ( v6[183] < v23 )
          goto LABEL_56;
        if ( v23 )
        {
          v24 = 2 * v23;
          v25 = v6[181];
          v6[182] = v24;
          v26 = Curl_crealloc(v25, v24);
        }
        else
        {
          v6[182] = 128;
          v26 = Curl_cmalloc(128);
        }
        if ( !v26 )
          return 7;
        v6[181] = v26;
LABEL_56:
        v27 = v6[183];
        v28 = v6[181];
        v6[183] = v27 + 1;
        *(_BYTE *)(v28 + v27) = *v7;
        if ( *v7 != 13 )
          goto LABEL_65;
        v14 = 10;
        goto LABEL_25;
      case 10:
        if ( *v7 != 13 )
          return 3;
        v22 = 11;
LABEL_70:
        v6[7] = v22;
        goto LABEL_65;
      case 11:
        if ( *v7 != 10 )
          return 3;
        v29 = v6[183];
        v30 = v6[181];
        v6[183] = v29 + 1;
        *(_BYTE *)(v30 + v29) = 10;
        *(_BYTE *)(v6[181] + v6[183]) = 0;
        v31 = v6[183];
        if ( v31 != 2 )
        {
          if ( !*(_BYTE *)(v5 + 704) && Curl_client_write(v6, 2, (const char *)v6[181], v31) )
            return 4;
          v6[7] = 9;
          v6[183] = 0;
LABEL_65:
          ++v7;
          --v8;
          continue;
        }
        v6[7] = 8;
LABEL_72:
        result = -1;
        v6[9] = v8 - 1;
        return result;
      default:
        return 5;
    }
  }
}
// 0: using guessed type int dword_0;
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000786CC) --------------------------------------------------------
_DWORD *__fastcall Curl_llist_init(_DWORD *result, int a2)
{
  result[2] = a2;
  result[3] = 0;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (000786D8) --------------------------------------------------------
_DWORD *__fastcall Curl_llist_alloc(int a1)
{
  int v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r4

  v1 = a1;
  v2 = (_DWORD *)Curl_cmalloc(16);
  v3 = v2;
  if ( v2 )
    Curl_llist_init(v2, v1);
  return v3;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (000786FC) --------------------------------------------------------
_DWORD *__fastcall Curl_llist_insert_next(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r5
  int v5; // r6
  _DWORD *result; // r0
  int v7; // r3
  int v8; // r3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  result = (_DWORD *)Curl_cmalloc(12);
  if ( result )
  {
    *result = v5;
    if ( v3[3] )
    {
      v7 = *(_DWORD *)(v4 + 8);
      result[1] = v4;
      result[2] = v7;
      v8 = *(_DWORD *)(v4 + 8);
      if ( v8 )
        *(_DWORD *)(v8 + 4) = result;
      else
        v3[1] = result;
      *(_DWORD *)(v4 + 8) = result;
    }
    else
    {
      *v3 = result;
      result[1] = 0;
      *(_DWORD *)(*v3 + 8) = 0;
      v3[1] = result;
    }
    result = &dword_0 + 1;
    ++v3[3];
  }
  return result;
}
// 0: using guessed type int dword_0;
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00078744) --------------------------------------------------------
signed int __fastcall Curl_llist_remove(int a1, _DWORD *a2, int a3)
{
  int v3; // r5
  _DWORD *v4; // r4
  int v5; // r3
  int v6; // r3
  int v7; // r1

  v3 = a1;
  v4 = a2;
  if ( a2 && *(_DWORD *)(a1 + 12) )
  {
    v5 = a2[2];
    if ( a2 == *(_DWORD **)a1 )
    {
      *(_DWORD *)a1 = v5;
      if ( !v5 )
      {
        *(_DWORD *)(a1 + 4) = 0;
LABEL_10:
        (*(void (__fastcall **)(int, _DWORD))(a1 + 8))(a3, *v4);
        Curl_cfree(v4);
        --*(_DWORD *)(v3 + 12);
        return 1;
      }
      v6 = a2[2];
      v7 = 0;
    }
    else
    {
      *(_DWORD *)(a2[1] + 8) = v5;
      v6 = a2[2];
      v7 = a2[1];
      if ( !v6 )
      {
        *(_DWORD *)(a1 + 4) = v7;
        goto LABEL_10;
      }
    }
    *(_DWORD *)(v6 + 4) = v7;
    goto LABEL_10;
  }
  return 1;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00078798) --------------------------------------------------------
int __fastcall Curl_llist_destroy(int result, int a2)
{
  int v2; // r5
  int v3; // r4

  v2 = a2;
  v3 = result;
  if ( result )
  {
    while ( *(_DWORD *)(v3 + 12) )
      Curl_llist_remove(v3, *(_DWORD **)(v3 + 4), v2);
    result = Curl_cfree(v3);
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (000787C4) --------------------------------------------------------
int __fastcall Curl_llist_count(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000787C8) --------------------------------------------------------
signed int __fastcall Curl_llist_move(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // r4
  int v5; // r4
  int v6; // r5
  int v7; // r0
  int v8; // r0
  signed int result; // r0

  if ( !a2 )
    return 0;
  if ( !a1[3] )
    return 0;
  v4 = *(_DWORD *)(a2 + 8);
  if ( a2 != *a1 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = v4;
    v5 = *(_DWORD *)(a2 + 8);
    v6 = *(_DWORD *)(a2 + 4);
    if ( !v5 )
    {
      a1[1] = v6;
      goto LABEL_10;
    }
LABEL_9:
    *(_DWORD *)(v5 + 4) = v6;
    goto LABEL_10;
  }
  *a1 = v4;
  if ( v4 )
  {
    v5 = *(_DWORD *)(a2 + 8);
    v6 = 0;
    goto LABEL_9;
  }
  a1[1] = 0;
LABEL_10:
  --a1[3];
  if ( a3[3] )
  {
    v7 = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 8) = v7;
    v8 = *(_DWORD *)(a4 + 8);
    if ( v8 )
      *(_DWORD *)(v8 + 4) = a2;
    else
      a3[1] = a2;
    *(_DWORD *)(a4 + 8) = a2;
  }
  else
  {
    *a3 = a2;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(*a3 + 8) = 0;
    a3[1] = a2;
  }
  result = 1;
  ++a3[3];
  return result;
}

//----- (00078834) --------------------------------------------------------
signed int __fastcall sub_78834(_BYTE *a1, int a2, _DWORD *a3)
{
  char v3; // r4
  int v4; // r3
  int v5; // r5
  int v6; // r0
  _BYTE *v7; // r0
  int v8; // r5
  int v9; // t1
  signed int result; // r0

  v3 = a1[3];
  if ( a1[2] != 8 || a1[3] & 0xE0 )
    return 1;
  v4 = a2 - 10;
  v5 = (int)(a1 + 10);
  if ( a1[3] & 4 )
  {
    if ( v4 <= 1 )
      return 2;
    v6 = (unsigned __int8)a1[10] | ((unsigned __int8)a1[11] << 8);
    if ( v6 + 1 >= v4 )
      return 2;
    v4 += -2 - v6;
    v5 += v6 + 2;
  }
  if ( v3 & 8 )
  {
    while ( 1 )
    {
      v7 = (_BYTE *)v5;
      if ( !v4 )
        return 2;
      ++v5;
      --v4;
      if ( !*v7 )
      {
        v5 = (int)(v7 + 1);
        break;
      }
    }
  }
  if ( v3 & 0x10 )
  {
    v8 = v5 - 1;
    while ( v4 )
    {
      v9 = *(unsigned __int8 *)(v8++ + 1);
      --v4;
      if ( !v9 )
        goto LABEL_15;
    }
    return 2;
  }
LABEL_15:
  if ( !(v3 & 2) )
  {
LABEL_18:
    result = 0;
    *a3 = a2 - v4;
    return result;
  }
  if ( v4 > 1 )
  {
    v4 -= 2;
    goto LABEL_18;
  }
  return 2;
}

//----- (000788B0) --------------------------------------------------------
signed int __fastcall sub_788B0(int a1, int a2)
{
  if ( a2 )
    Curl_failf(a1, "Error while processing content unencoding: %s", a2);
  else
    Curl_failf(a1, "Error while processing content unencoding: Unknown failure within decompression software.", 0);
  return 61;
}

//----- (000788D4) --------------------------------------------------------
signed int __fastcall sub_788D4(int *a1, int a2)
{
  int *v2; // r8
  _DWORD *v3; // r4
  z_stream *v4; // r5
  char *v5; // r6
  signed int i; // r3
  int v8; // r3
  unsigned int v9; // r0
  unsigned int v10; // r9
  signed int v11; // r3
  signed int v12; // ST04_4
  int v13; // r6
  signed int v14; // [sp+4h] [bp-34h]
  int v15; // [sp+8h] [bp-30h]
  int v16; // [sp+Ch] [bp-2Ch]

  v2 = a1;
  v3 = (_DWORD *)a2;
  v4 = (z_stream *)(a2 + 144);
  v15 = *(_DWORD *)(a2 + 148);
  v16 = *(_DWORD *)(a2 + 144);
  v5 = (char *)Curl_cmalloc(0x10000);
  if ( !v5 )
  {
    inflateEnd(v4);
    v3[35] = 0;
    return 27;
  }
  for ( i = 1; ; i = 0 )
  {
    v3[39] = v5;
    v3[40] = 0x10000;
    v14 = i;
    v9 = inflate(v4, 2);
    v10 = v9;
    if ( v9 <= 1 )
      break;
    if ( !v14 || v9 != -3 || (inflateEnd(v4), inflateInit2_(v4, -15, "1.2.3", 56)) )
    {
      ((void (__cdecl *)(void *))Curl_cfree)(v5);
      goto LABEL_20;
    }
    v3[36] = v16;
    v3[37] = v15;
LABEL_7:
    ;
  }
  v8 = v3[40];
  if ( v8 != 0x10000 )
  {
    v11 = Curl_client_write(v2, 1, v5, 0x10000 - v8);
    if ( v11 )
    {
      v12 = v11;
      ((void (__cdecl *)(void *))Curl_cfree)(v5);
      inflateEnd(v4);
      v3[35] = 0;
      return v12;
    }
  }
  if ( v10 != 1 )
  {
    if ( !v3[37] )
    {
      ((void (__cdecl *)(void *))Curl_cfree)(v5);
      return 0;
    }
    goto LABEL_7;
  }
  ((void (__cdecl *)(void *))Curl_cfree)(v5);
  v13 = inflateEnd(v4);
  if ( !v13 )
  {
    inflateEnd(v4);
    v3[35] = 0;
    return v13;
  }
LABEL_20:
  v13 = sub_788B0(*v2, v3[42]);
  inflateEnd(v4);
  v3[35] = 0;
  return v13;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00078A20) --------------------------------------------------------
signed int __fastcall Curl_unencode_deflate_write(int *a1, int a2, int a3)
{
  int *v3; // r5
  _DWORD *v4; // r4
  int v5; // r6
  int v7; // r3

  v3 = a1;
  v4 = (_DWORD *)a2;
  v5 = a3;
  if ( !*(_DWORD *)(a2 + 140) )
  {
    *(_DWORD *)(a2 + 176) = 0;
    *(_DWORD *)(a2 + 180) = 0;
    *(_DWORD *)(a2 + 184) = 0;
    *(_DWORD *)(a2 + 144) = 0;
    *(_DWORD *)(a2 + 148) = 0;
    if ( inflateInit_((z_streamp)(a2 + 144), "1.2.3", 56) )
      return sub_788B0(*v3, v4[42]);
    v4[35] = 1;
  }
  v7 = v4[23];
  v4[37] = v5;
  v4[36] = v7;
  return sub_788D4(v3, (int)v4);
}

//----- (00078A80) --------------------------------------------------------
signed int __fastcall Curl_unencode_gzip_write(int *a1, _DWORD *a2, signed int a3)
{
  int *v3; // r6
  int v4; // r4
  signed int v5; // r5
  z_stream *v6; // r7
  const char *v7; // r0
  signed int v8; // r3
  signed int result; // r0
  int v10; // r3
  int v11; // r3
  _BYTE *v12; // r0
  signed int v13; // r0
  int v14; // r3
  int v15; // r2
  void *v16; // r0
  void *v17; // r5
  void *v18; // r10
  int v19; // r1
  char *v20; // r9
  int v21; // r1
  _BYTE *v22; // r0
  signed int v23; // r0
  int v24; // r2
  int v25; // r5
  int v26; // r1
  signed int v27; // r5
  int v28; // r3
  _DWORD *v29; // [sp+4h] [bp-24h]

  v29 = a2;
  v3 = a1;
  v4 = (int)a2;
  v5 = a3;
  v6 = (z_stream *)(a2 + 36);
  if ( !a2[35] )
  {
    a2[44] = 0;
    a2[45] = 0;
    a2[46] = 0;
    a2[36] = 0;
    a2[37] = 0;
    v7 = zlibVersion();
    if ( strcmp(v7, "1.2.0.4") < 0 )
    {
      if ( !inflateInit2_(v6, -15, "1.2.3", 56) )
      {
        v8 = 1;
        goto LABEL_8;
      }
    }
    else if ( !inflateInit2_(v6, 47, "1.2.3", 56) )
    {
      v8 = 4;
LABEL_8:
      *(_DWORD *)(v4 + 140) = v8;
      goto LABEL_9;
    }
    return sub_788B0(*v3, *(_DWORD *)(v4 + 168));
  }
LABEL_9:
  v10 = *(_DWORD *)(v4 + 140);
  if ( v10 != 4 )
  {
    if ( v10 == 1 )
    {
      v12 = *(_BYTE **)(v4 + 92);
      if ( v5 > 9 )
      {
        if ( *v12 != 31 || (unsigned __int8)v12[1] != 139 )
          goto LABEL_36;
        v13 = sub_78834(v12, v5, &v29);
        if ( !v13 )
        {
          v14 = (int)v29;
          v15 = *(_DWORD *)(v4 + 92);
          *(_DWORD *)(v4 + 148) = v5 - (_DWORD)v29;
          *(_DWORD *)(v4 + 144) = v15 + v14;
          goto LABEL_34;
        }
        if ( v13 != 2 )
        {
LABEL_36:
          v27 = sub_788B0(*v3, *(_DWORD *)(v4 + 168));
          inflateEnd(v6);
          result = v27;
          *(_DWORD *)(v4 + 140) = 0;
          return result;
        }
      }
      *(_DWORD *)(v4 + 148) = v5;
      v16 = ((void *(__cdecl *)(size_t))Curl_cmalloc)(v5);
      v17 = v16;
      *(_DWORD *)(v4 + 144) = v16;
      if ( !v16 )
      {
        inflateEnd(v6);
        *(_DWORD *)(v4 + 140) = v17;
        return 27;
      }
      memcpy(v16, *(const void **)(v4 + 92), *(_DWORD *)(v4 + 148));
      *(_DWORD *)(v4 + 140) = 2;
    }
    else
    {
      if ( v10 != 2 )
      {
        v28 = *(_DWORD *)(v4 + 92);
        *(_DWORD *)(v4 + 148) = v5;
        *(_DWORD *)(v4 + 144) = v28;
        goto LABEL_38;
      }
      v18 = *(void **)(v4 + 144);
      v19 = *(_DWORD *)(v4 + 148) + v5;
      *(_DWORD *)(v4 + 148) = v19;
      v20 = (char *)((void *(__cdecl *)(void *, size_t))Curl_crealloc)(v18, v19);
      *(_DWORD *)(v4 + 144) = v20;
      if ( !v20 )
      {
        ((void (__cdecl *)(void *))Curl_cfree)(v18);
        inflateEnd(v6);
        *(_DWORD *)(v4 + 140) = 0;
        return 27;
      }
      memcpy(&v20[*(_DWORD *)(v4 + 148) - v5], *(const void **)(v4 + 92), v5);
      v21 = *(_DWORD *)(v4 + 148);
      v22 = *(_BYTE **)(v4 + 144);
      if ( v21 > 9 )
      {
        if ( *v22 != 31 || (unsigned __int8)v22[1] != 139 )
        {
LABEL_35:
          ((void (__cdecl *)(void *))Curl_cfree)(*(void **)(v4 + 144));
          goto LABEL_36;
        }
        v23 = sub_78834(v22, v21, &v29);
        if ( v23 )
        {
          if ( v23 == 2 )
            return 0;
          goto LABEL_35;
        }
        ((void (__cdecl *)(void *))Curl_cfree)(*(void **)(v4 + 144));
        v24 = *(_DWORD *)(v4 + 148);
        v25 = (int)v29 + v5 - v24;
        v26 = *(_DWORD *)(v4 + 92);
        *(_DWORD *)(v4 + 148) = v24 - (_DWORD)v29;
        *(_DWORD *)(v4 + 144) = v26 + v25;
LABEL_34:
        *(_DWORD *)(v4 + 140) = 3;
LABEL_38:
        result = *(_DWORD *)(v4 + 148);
        if ( !result )
          return result;
        return sub_788D4(v3, v4);
      }
    }
    return 0;
  }
  v11 = *(_DWORD *)(v4 + 92);
  *(_DWORD *)(v4 + 148) = v5;
  *(_DWORD *)(v4 + 144) = v11;
  return sub_788D4(v3, v4);
}
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00078C88) --------------------------------------------------------
int __fastcall Curl_unencode_cleanup(int result)
{
  z_stream *v1; // r4

  v1 = *(z_stream **)result;
  if ( *(_DWORD *)(*(_DWORD *)result + 164) )
  {
    result = inflateEnd(v1 + 3);
    v1[2].reserved = 0;
  }
  return result;
}

//----- (00078CA4) --------------------------------------------------------
_DWORD *curl_share_init()
{
  _DWORD *result; // r0

  result = (_DWORD *)Curl_ccalloc(28, 1);
  if ( result )
    *result |= 2u;
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (00078CC4) --------------------------------------------------------
signed int __fastcall curl_share_setopt(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // r4
  int v5; // r2
  _DWORD *v6; // r0
  signed int result; // r0
  int v8; // r3
  _DWORD *v9; // r0
  int v10; // r0
  int varg_r2; // [sp+18h] [bp-8h]
  int varg_r3; // [sp+1Ch] [bp-4h]

  varg_r2 = a3;
  varg_r3 = a4;
  v4 = a1;
  if ( a1[1] )
    return 2;
  switch ( a2 )
  {
    case 1:
      v5 = varg_r2;
      *a1 |= 1 << varg_r2;
      if ( v5 == 2 )
      {
        if ( a1[6] )
          goto LABEL_21;
        v6 = Curl_cookie_init(0, 0, 0, 1);
        v4[6] = v6;
      }
      else
      {
        if ( v5 != 3 )
          goto def_78D44;
        if ( a1[5] )
          goto LABEL_21;
        v6 = Curl_mk_dnscache();
        v4[5] = v6;
      }
      if ( v6 )
        goto LABEL_21;
      return 4;
    case 2:
      v8 = varg_r2;
      *a1 &= ~(1 << varg_r2);
      switch ( v8 )
      {
        case 2:
          v10 = a1[6];
          if ( !v10 )
            goto LABEL_21;
          Curl_cookie_cleanup(v10);
          result = 0;
          v4[6] = 0;
          return result;
        case 3:
          v9 = (_DWORD *)a1[5];
          if ( !v9 )
            goto LABEL_21;
          Curl_hash_destroy(v9);
          result = 0;
          v4[5] = 0;
          return result;
        case 4:
        case 5:
          goto LABEL_21;
        default:
          goto def_78D44;
      }
      goto def_78D44;
    case 3:
      a1[2] = varg_r2;
      goto LABEL_21;
    case 4:
      a1[3] = varg_r2;
      goto LABEL_21;
    case 5:
      a1[4] = varg_r2;
LABEL_21:
      result = 0;
      break;
    default:
def_78D44:
      result = 1;
      break;
  }
  return result;
}

//----- (00078D94) --------------------------------------------------------
int __fastcall curl_share_cleanup(void *ptr)
{
  _DWORD *v1; // r4
  void (__fastcall *v2)(_DWORD, signed int, signed int, _DWORD); // r5
  void (__fastcall *v3)(_DWORD, signed int, _DWORD); // r3
  _DWORD *v4; // r0
  int v5; // r0
  void (__fastcall *v6)(_DWORD, signed int, _DWORD); // r3
  int result; // r0

  v1 = ptr;
  if ( !ptr )
    return 3;
  v2 = (void (__fastcall *)(_DWORD, signed int, signed int, _DWORD))*((_DWORD *)ptr + 2);
  if ( v2 )
    v2(0, 1, 2, *((_DWORD *)ptr + 4));
  if ( v1[1] )
  {
    v3 = (void (__fastcall *)(_DWORD, signed int, _DWORD))v1[3];
    if ( v3 )
      v3(0, 1, v1[4]);
    result = 2;
  }
  else
  {
    v4 = (_DWORD *)v1[5];
    if ( v4 )
    {
      Curl_hash_destroy(v4);
      v1[5] = 0;
    }
    v5 = v1[6];
    if ( v5 )
      Curl_cookie_cleanup(v5);
    v6 = (void (__fastcall *)(_DWORD, signed int, _DWORD))v1[3];
    if ( v6 )
      v6(0, 1, v1[4]);
    Curl_cfree(v1);
    result = 0;
  }
  return result;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00078DF4) --------------------------------------------------------
signed int __fastcall Curl_share_lock(int a1, char a2)
{
  _DWORD *v2; // r3
  void (*v3)(void); // r4
  int v4; // r3

  v2 = *(_DWORD **)(a1 + 16);
  if ( !v2 )
    return 3;
  if ( *v2 & (1 << a2) )
  {
    v3 = (void (*)(void))v2[2];
    if ( v3 )
    {
      v4 = v2[4];
      v3();
    }
  }
  return 0;
}

//----- (00078E14) --------------------------------------------------------
signed int __fastcall Curl_share_unlock(int a1, char a2)
{
  _DWORD *v2; // r3
  void (*v3)(void); // r4
  int v4; // r2

  v2 = *(_DWORD **)(a1 + 16);
  if ( !v2 )
    return 3;
  if ( *v2 & (1 << a2) )
  {
    v3 = (void (*)(void))v2[3];
    if ( v3 )
    {
      v4 = v2[4];
      v3();
    }
  }
  return 0;
}

//----- (00078E34) --------------------------------------------------------
char *__fastcall sub_78E34(int a1, int a2, int a3, int a4)
{
  int v4; // r5
  int v5; // r7
  int v6; // r4
  int v7; // r0
  int v8; // r3
  char *result; // r0
  int v10; // [sp+0h] [bp-18h]

  v10 = a4;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  do
  {
    v7 = v5 + 2 * v6;
    v8 = *(unsigned __int8 *)(v4 + v6++);
    result = curl_msnprintf(v7, 3, "%02x", v8, v10);
  }
  while ( v6 != 16 );
  return result;
}

//----- (00078E5C) --------------------------------------------------------
signed int __fastcall Curl_output_digest(int *a1, int a2, int a3, const char *a4)
{
  const char *v4; // r10
  int v5; // r7
  signed int *v6; // r4
  void **v7; // r5
  char *v8; // r9
  int v9; // r3
  char *v10; // r6
  signed int result; // r0
  size_t v12; // r0
  const char *v13; // r0
  char *v14; // r7
  int v15; // r2
  int v16; // r3
  void *v17; // r7
  const char *v18; // r0
  char *v19; // r11
  int v20; // r2
  int v21; // r3
  char *v22; // r0
  char *v23; // r0
  char *v24; // r11
  unsigned __int8 *v25; // r0
  int v26; // r2
  int v27; // r3
  signed int v28; // r3
  char *v29; // r0
  char *v30; // r11
  int v31; // r2
  int v32; // r3
  signed int v33; // r2
  char *v34; // r1
  char *v35; // r1
  void *v36; // r6
  void *v37; // r4
  int v38; // r4
  size_t v39; // r0
  char *v40; // r0
  char *v41; // r4
  int v42; // [sp+18h] [bp-A8h]
  int v43; // [sp+1Ch] [bp-A4h]
  int v44; // [sp+20h] [bp-A0h]
  int v45; // [sp+28h] [bp-98h]
  char v46; // [sp+2Ch] [bp-94h]
  int v47; // [sp+34h] [bp-8Ch]
  char v48; // [sp+3Ch] [bp-84h]
  char v49; // [sp+4Ch] [bp-74h]
  char v50; // [sp+70h] [bp-50h]

  v4 = a4;
  v5 = *a1;
  v44 = a3;
  v43 = a2;
  if ( a2 )
  {
    v6 = (signed int *)(v5 + 34032);
    v7 = (void **)(a1 + 83);
    v8 = (char *)a1[45];
    v9 = v5 + 34084;
    v10 = (char *)a1[46];
  }
  else
  {
    v8 = (char *)a1[43];
    v6 = (signed int *)(v5 + 33996);
    v10 = (char *)a1[44];
    v7 = (void **)(a1 + 86);
    v9 = v5 + 34068;
  }
  v42 = v9;
  if ( *v7 )
  {
    Curl_safefree((int)*v7);
    *v7 = 0;
  }
  if ( !v8 )
    v8 = &byte_E4496;
  if ( !v10 )
    v10 = &byte_E4496;
  result = *v6;
  if ( !*v6 )
  {
    *(_BYTE *)(v42 + 12) = 0;
    return result;
  }
  *(_BYTE *)(v42 + 12) = 1;
  if ( !v6[8] )
    v6[8] = 1;
  if ( !v6[1] )
  {
    curlx_tvnow(&v47);
    curl_msnprintf((int)&v46, 7, "%06ld", v47);
    v12 = strlen(&v46);
    if ( !Curl_base64_encode(v5, &v46, v12, (const char **)&v45) )
      return 27;
    v6[1] = v45;
  }
  v13 = (const char *)curl_maprintf("%s:%s:%s", v8, v6[2], v10);
  v14 = (char *)v13;
  if ( !v13 )
    return 27;
  Curl_md5it((int)&v48, v13);
  ((void (__cdecl *)(void *))Curl_cfree)(v14);
  v17 = (void *)Curl_cmalloc(33);
  if ( !v17 )
    return 27;
  sub_78E34((int)&v48, (int)v17, v15, v16);
  if ( v6[3] == 1 )
  {
    v18 = (const char *)curl_maprintf("%s:%s:%s", v17, *v6, v6[1]);
    v19 = (char *)v18;
    if ( v18 )
    {
      Curl_md5it((int)&v48, v18);
      ((void (__cdecl *)(void *))Curl_cfree)(v19);
      sub_78E34((int)&v48, (int)v17, v20, v21);
      goto LABEL_22;
    }
    return 27;
  }
LABEL_22:
  if ( *(_BYTE *)(v42 + 14) && (v22 = strchr(v4, 63)) != 0 )
    v23 = (char *)curl_maprintf("%s:%.*s", v44, v22 - v4, v4);
  else
    v23 = (char *)curl_maprintf("%s:%s", v44, v4);
  v24 = v23;
  if ( !v23 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v17);
    return 27;
  }
  v25 = (unsigned __int8 *)v6[6];
  if ( v25 )
    Curl_raw_equal(v25, "auth-int");
  Curl_md5it((int)&v48, v24);
  ((void (__cdecl *)(void *))Curl_cfree)(v24);
  sub_78E34((int)&v48, (int)&v50, v26, v27);
  v28 = v6[6];
  if ( v28 )
    v29 = (char *)curl_maprintf("%s:%s:%08x:%s:%s:%s", v17, *v6, v6[8], v6[1], v28, &v50);
  else
    v29 = (char *)curl_maprintf("%s:%s:%s", v17, *v6, &v50);
  v30 = v29;
  ((void (__cdecl *)(void *))Curl_cfree)(v17);
  if ( !v30 )
    return 27;
  Curl_md5it((int)&v48, v30);
  ((void (__cdecl *)(void *))Curl_cfree)(v30);
  sub_78E34((int)&v48, (int)&v49, v31, v32);
  v33 = v6[6];
  if ( v33 )
  {
    v34 = v43 ? "Proxy-" : &byte_E4496;
    *v7 = curl_maprintf(
            "%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", cnonce=\"%s\", nc=%08x, qop"
            "=\"%s\", response=\"%s\"",
            v34,
            v8,
            v6[2],
            *v6,
            v4,
            v6[1],
            v6[8],
            v33,
            &v49);
    if ( Curl_raw_equal((unsigned __int8 *)v6[6], "auth") )
      ++v6[8];
  }
  else
  {
    v35 = v43 ? "Proxy-" : &byte_E4496;
    *v7 = curl_maprintf(
            "%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"",
            v35,
            v8,
            v6[2],
            *v6,
            v4,
            &v49);
  }
  if ( !*v7 )
    return 27;
  if ( v6[5] )
  {
    v36 = curl_maprintf("%s, opaque=\"%s\"");
    if ( !v36 )
      return 27;
    ((void (__cdecl *)(void *))Curl_cfree)(*v7);
    *v7 = v36;
  }
  if ( v6[7] )
  {
    v37 = curl_maprintf("%s, algorithm=\"%s\"", *v7);
    if ( !v37 )
      return 27;
    ((void (__cdecl *)(void *))Curl_cfree)(*v7);
    *v7 = v37;
  }
  v38 = (int)*v7;
  v39 = strlen((const char *)*v7);
  v40 = (char *)Curl_crealloc(v38, v39 + 3);
  v41 = v40;
  if ( !v40 )
    return 27;
  strcat(v40, "\r\n");
  result = 0;
  *v7 = v41;
  return result;
}
// E4496: using guessed type char byte_E4496;
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (00079188) --------------------------------------------------------
void __fastcall Curl_digest_cleanup_one(void **a1)
{
  void **v1; // r4
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    ((void (__cdecl *)(void *))Curl_cfree)(v2);
  v3 = v1[1];
  *v1 = 0;
  if ( v3 )
    ((void (__cdecl *)(void *))Curl_cfree)(v3);
  v4 = v1[2];
  v1[1] = 0;
  if ( v4 )
    ((void (__cdecl *)(void *))Curl_cfree)(v4);
  v5 = v1[5];
  v1[2] = 0;
  if ( v5 )
    ((void (__cdecl *)(void *))Curl_cfree)(v5);
  v6 = v1[6];
  v1[5] = 0;
  if ( v6 )
    ((void (__cdecl *)(void *))Curl_cfree)(v6);
  v7 = v1[7];
  v1[6] = 0;
  if ( v7 )
    ((void (__cdecl *)(void *))Curl_cfree)(v7);
  v1[7] = 0;
  v1[8] = 0;
  v1[3] = 0;
  *((_BYTE *)v1 + 16) = 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (00079200) --------------------------------------------------------
signed int __fastcall Curl_input_digest(_DWORD *a1, int a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v4; // r8
  int v5; // r3
  int v6; // t1
  signed int result; // r0
  signed int v8; // r11
  int v9; // r8
  signed int v10; // r10
  unsigned __int8 *v11; // r3
  int v12; // r2
  unsigned __int8 *v13; // r3
  unsigned __int8 *v14; // r0
  int v15; // r2
  int v16; // t1
  int i; // r3
  int v18; // r2
  int v19; // r1
  signed int v20; // r12
  char *v21; // r2
  unsigned __int8 *v22; // r8
  _BOOL4 v23; // lr
  signed int v24; // r1
  unsigned int v25; // r3
  unsigned int v26; // t1
  int v27; // r0
  int v28; // r0
  char *v29; // r0
  unsigned __int8 *j; // r3
  int (__fastcall *v31)(const char *); // r3
  const char *v32; // r0
  int v33; // r0
  unsigned __int8 *v34; // [sp+4h] [bp-554h]
  void *v35; // [sp+Ch] [bp-54Ch]
  char *ptr; // [sp+10h] [bp-548h]
  unsigned __int8 *v37; // [sp+14h] [bp-544h]
  char *save_ptr; // [sp+28h] [bp-530h]
  char v39[256]; // [sp+2Ch] [bp-52Ch]
  char v40; // [sp+12Ch] [bp-42Ch]
  int v41; // [sp+52Ch] [bp-2Ch]

  if ( a2 )
    v3 = *a1 + 34032;
  else
    v3 = *a1 + 33996;
  do
  {
    v4 = (int)a3;
    v6 = *a3++;
    v5 = v6;
  }
  while ( v6 && *(_BYTE *)(v5 + ctype_ + 1) & 8 );
  result = Curl_raw_nequal("Digest", v4, 6);
  if ( !result )
    goto LABEL_87;
  v8 = 0;
  v9 = v4 + 6;
  v10 = 0;
  v35 = *(void **)v3;
  Curl_digest_cleanup_one((void **)v3);
LABEL_14:
  v13 = (unsigned __int8 *)v9;
  do
  {
    v14 = v13;
    v16 = *v13++;
    v15 = v16;
  }
  while ( v16 && *(_BYTE *)(v15 + ctype_ + 1) & 8 );
  for ( i = 0; ; ++i )
  {
    v18 = v14[i];
    v19 = (int)&v14[i];
    if ( !v14[i] || v18 == 61 || i == 255 )
      break;
    v39[i] = v18;
  }
  v39[i] = 0;
  if ( v18 != 61 )
  {
    if ( v35 && !*(_BYTE *)(v3 + 16) )
      goto LABEL_88;
    if ( *(_DWORD *)v3 )
      result = 4;
    else
      result = 1;
    goto LABEL_87;
  }
  v20 = 1023;
  v21 = &v40;
  if ( *(_BYTE *)(v19 + 1) == 34 )
    v22 = (unsigned __int8 *)(v19 + 2);
  else
    v22 = (unsigned __int8 *)(v19 + 1);
  v23 = *(unsigned __int8 *)(v19 + 1) == 34;
  v24 = 0;
  while ( 1 )
  {
    v37 = v22;
    v26 = *v22++;
    v25 = v26;
    if ( !v26 )
      break;
    v28 = v20 - 1;
    if ( !v20 )
      break;
    if ( v25 == 34 )
    {
      if ( v24 || !v23 )
        goto LABEL_45;
      v28 = 0;
    }
    else
    {
      if ( v25 > 0x22 )
      {
        if ( v25 != 44 )
        {
          if ( v25 == 92 && !v24 )
          {
            *v21 = 92;
            v24 = 1;
            ++v21;
            goto LABEL_48;
          }
LABEL_45:
          *v21 = v25;
          v24 = 0;
          ++v21;
          goto LABEL_48;
        }
        if ( v23 )
          goto LABEL_45;
      }
      else if ( v25 != 10 && v25 != 13 )
      {
        goto LABEL_45;
      }
      v28 = 0;
    }
LABEL_48:
    v20 = v28;
  }
  *v21 = 0;
  if ( Curl_raw_equal((unsigned __int8 *)v39, "nonce") )
  {
    v27 = Curl_cstrdup(&v40);
    *(_DWORD *)v3 = v27;
    goto LABEL_68;
  }
  if ( Curl_raw_equal((unsigned __int8 *)v39, "stale") )
  {
    if ( Curl_raw_equal((unsigned __int8 *)&v40, "true") )
    {
      *(_BYTE *)(v3 + 16) = 1;
      *(_DWORD *)(v3 + 32) = 1;
    }
    goto LABEL_12;
  }
  if ( Curl_raw_equal((unsigned __int8 *)v39, "realm") )
  {
    v27 = Curl_cstrdup(&v40);
    *(_DWORD *)(v3 + 8) = v27;
    goto LABEL_68;
  }
  if ( Curl_raw_equal((unsigned __int8 *)v39, "opaque") )
  {
    v27 = Curl_cstrdup(&v40);
    *(_DWORD *)(v3 + 20) = v27;
    goto LABEL_68;
  }
  if ( !Curl_raw_equal((unsigned __int8 *)v39, "qop") )
  {
    if ( !Curl_raw_equal((unsigned __int8 *)v39, "algorithm") )
      goto LABEL_12;
    v33 = Curl_cstrdup(&v40);
    *(_DWORD *)(v3 + 28) = v33;
    if ( !v33 )
      goto LABEL_80;
    if ( Curl_raw_equal((unsigned __int8 *)&v40, "MD5-sess") )
    {
      *(_DWORD *)(v3 + 12) = 1;
    }
    else
    {
      if ( !Curl_raw_equal((unsigned __int8 *)&v40, "MD5") )
      {
        result = 2;
        goto LABEL_87;
      }
      *(_DWORD *)(v3 + 12) = 0;
    }
LABEL_12:
    v11 = v37;
    while ( 1 )
    {
      v12 = *v11;
      v9 = (int)v11++;
      if ( !v12 )
        goto LABEL_14;
      if ( !(*(_BYTE *)(ctype_ + v12 + 1) & 8) )
      {
        if ( v12 == 44 )
          v9 = (int)v11;
        goto LABEL_14;
      }
    }
  }
  v29 = (char *)Curl_cstrdup(&v40);
  ptr = v29;
  if ( !v29 )
    goto LABEL_80;
  for ( j = (unsigned __int8 *)strtok_r(v29, ",", &save_ptr); j; j = (unsigned __int8 *)strtok_r(0, ",", &save_ptr) )
  {
    v34 = j;
    if ( Curl_raw_equal(j, "auth") )
    {
      v10 = 1;
    }
    else if ( Curl_raw_equal(v34, "auth-int") )
    {
      v8 = 1;
    }
  }
  Curl_cfree(ptr);
  if ( !v10 )
  {
    if ( v8 )
    {
      v31 = (int (__fastcall *)(const char *))Curl_cstrdup;
      v32 = "auth-int";
      goto LABEL_67;
    }
    goto LABEL_12;
  }
  v31 = (int (__fastcall *)(const char *))Curl_cstrdup;
  v32 = "auth";
LABEL_67:
  v27 = v31(v32);
  *(_DWORD *)(v3 + 24) = v27;
LABEL_68:
  if ( v27 )
    goto LABEL_12;
LABEL_80:
  result = 3;
LABEL_87:
  while ( v41 != _stack_chk_guard )
LABEL_88:
    result = 1;
  return result;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// 79200: using guessed type char var_52C[256];

//----- (00079538) --------------------------------------------------------
void __fastcall Curl_digest_cleanup(int a1)
{
  int v1; // r4

  v1 = a1 + 33792;
  Curl_digest_cleanup_one((void **)(a1 + 33996));
  Curl_digest_cleanup_one((void **)(v1 + 240));
}

//----- (00079552) --------------------------------------------------------
int __fastcall sub_79552(int result, int a2, unsigned int a3)
{
  unsigned int v3; // r3
  int v4; // r4

  v3 = 0;
  while ( 1 )
  {
    result += 4;
    if ( v3 >= a3 )
      break;
    *(_BYTE *)(result - 4) = *(_DWORD *)(a2 + v3);
    *(_BYTE *)(result - 3) = *(_WORD *)(a2 + v3) >> 8;
    *(_BYTE *)(result - 2) = *(_DWORD *)(a2 + v3) >> 16;
    v4 = *(_DWORD *)(a2 + v3);
    v3 += 4;
    *(_BYTE *)(result - 1) = HIBYTE(v4);
  }
  return result;
}

//----- (00079584) --------------------------------------------------------
void *__fastcall sub_79584(int *a1, int a2)
{
  int v2; // r4
  int v3; // r5
  int v4; // r3
  int v5; // r2
  int v6; // r4
  int v7; // r5
  int v8; // lr
  int v9; // r7
  int v10; // r5
  int v11; // r7
  int v12; // lr
  int v13; // r7
  int v14; // r5
  int v15; // r4
  int v16; // lr
  int v17; // r1
  int v18; // r5
  int v19; // r7
  int v20; // r4
  int v21; // r1
  int v22; // r12
  int v23; // r9
  int v24; // r5
  int v25; // r4
  int v26; // r1
  int v27; // r9
  int v28; // r5
  int v29; // r4
  int v30; // r1
  int v31; // r9
  int v32; // r8
  int v33; // r5
  int v34; // r12
  int v35; // r9
  int v36; // r1
  int v37; // r5
  int v38; // r12
  int v39; // r4
  int v40; // r1
  int v41; // r5
  int v42; // r12
  int v43; // r4
  int v44; // r10
  int v45; // r5
  int v46; // r12
  int v47; // r8
  int v48; // r4
  int v49; // r9
  int v50; // r12
  int v51; // r1
  int v52; // r8
  int v53; // r9
  int v54; // r5
  int v55; // r12
  int v56; // r8
  int v57; // r4
  int v58; // r5
  int v59; // r12
  int v60; // r1
  int v61; // r4
  int v62; // r5
  int v63; // lr
  int v64; // r1
  int v65; // r4
  int v66; // r5
  int v67; // lr
  int v68; // r1
  int v69; // r4
  int v70; // r5
  int v71; // lr
  int v72; // r1
  int v73; // r4
  int v74; // r5
  int v75; // lr
  int v76; // r5
  int v77; // r6
  int v78; // r3
  int v79; // r4
  int v81; // [sp+0h] [bp-78h]
  int v82; // [sp+4h] [bp-74h]
  int v83; // [sp+8h] [bp-70h]
  int *v84; // [sp+Ch] [bp-6Ch]
  int s; // [sp+10h] [bp-68h]
  int v86; // [sp+14h] [bp-64h]
  int v87; // [sp+18h] [bp-60h]
  int v88; // [sp+1Ch] [bp-5Ch]
  int v89; // [sp+20h] [bp-58h]
  int v90; // [sp+24h] [bp-54h]
  int v91; // [sp+28h] [bp-50h]
  int v92; // [sp+2Ch] [bp-4Ch]
  int v93; // [sp+30h] [bp-48h]
  int v94; // [sp+34h] [bp-44h]
  int v95; // [sp+38h] [bp-40h]
  int v96; // [sp+3Ch] [bp-3Ch]
  int v97; // [sp+40h] [bp-38h]
  int v98; // [sp+44h] [bp-34h]
  int v99; // [sp+48h] [bp-30h]
  int v100; // [sp+4Ch] [bp-2Ch]

  v2 = a1[2];
  v3 = a1[3];
  v4 = a1[1];
  v83 = *a1;
  v5 = 0;
  v81 = v2;
  v6 = a2;
  v82 = v3;
  do
  {
    v7 = *(unsigned __int8 *)(v6 + 2);
    v8 = v5 + 16;
    v9 = *(unsigned __int8 *)(v6 + 1);
    v6 += 4;
    v84 = &s;
    v10 = (v7 << 16) | (v9 << 8);
    v11 = *(unsigned __int8 *)(a2 + v5);
    v5 += 4;
    *(int *)((char *)&v81 + v8) = v10 | v11 | (*(unsigned __int8 *)(v6 - 1) << 24);
  }
  while ( v5 != 64 );
  v12 = v4 + __ROR4__((v82 & ~v4 | v81 & v4) + s - 680876936 + v83, 25);
  v13 = v12 + __ROR4__(v86 - 389564586 + v82 + (v12 & v4 | v81 & ~v12), 20);
  v14 = v13 + __ROR4__((v4 & ~v13 | v13 & v12) + v87 + 606105819 + v81, 15);
  v15 = v14 + __ROR4__((v12 & ~v14 | v14 & v13) + v88 - 1044525330 + v4, 10);
  v16 = v15 + __ROR4__(v12 + v89 - 176418897 + (v13 & ~v15 | v15 & v14), 25);
  v17 = v16 + __ROR4__((v14 & ~v16 | v16 & v15) + v13 + v90 + 1200080426, 20);
  v18 = v17 + __ROR4__(v14 + v91 - 1473231341 + (v15 & ~v17 | v17 & v16), 15);
  v19 = v18 + __ROR4__((v16 & ~v18 | v18 & v17) + v15 + v92 - 45705983, 10);
  v20 = v19 + __ROR4__((v17 & ~v19 | v19 & v18) + v16 + v93 + 1770035416, 25);
  v21 = v20 + __ROR4__(v17 + v94 - 1958414417 + (v18 & ~v20 | v20 & v19), 20);
  v22 = v21 + __ROR4__((v19 & ~v21 | v21 & v20) + v18 + v95 - 42063, 15);
  v23 = v22 + __ROR4__((v20 & ~v22 | v22 & v21) + v19 + v96 - 1990404162, 10);
  v24 = v23 + __ROR4__((v21 & ~v23 | v23 & v22) + v20 + v97 + 1804603682, 25);
  v25 = v24 + __ROR4__((v22 & ~v24 | v24 & v23) + v21 + v98 - 40341101, 20);
  v26 = v25 + __ROR4__((~v25 & v23 | v25 & v24) + v22 + v99 - 1502002290, 15);
  v27 = v26 + __ROR4__(v23 + v100 + 1236535329 + (~v26 & v24 | v26 & v25), 10);
  v28 = v27 + __ROR4__(v24 + v86 - 165796510 + (v27 & v25 | v26 & ~v25), 27);
  v29 = v28 + __ROR4__((v28 & v26 | v27 & ~v26) + v91 - 1069501632 + v25, 23);
  v30 = v29 + __ROR4__(v26 + v96 + 643717713 + (v29 & v27 | v28 & ~v27), 18);
  v31 = v30 + __ROR4__(v27 + s - 373897302 + (v30 & v28 | v29 & ~v28), 12);
  v32 = v31 + __ROR4__((v31 & v29 | v30 & ~v29) + v28 + v90 - 701558691, 27);
  v33 = v32 + __ROR4__((v32 & v30 | v31 & ~v30) + v29 + v95 + 38016083, 23);
  v34 = v33 + __ROR4__((v33 & v31 | v32 & ~v31) + v30 + v100 - 660478335, 18);
  v35 = v34 + __ROR4__(v31 + v89 - 405537848 + (v33 & ~v32 | v34 & v32), 12);
  v36 = v35 + __ROR4__((v34 & ~v33 | v35 & v33) + v32 + v94 + 568446438, 27);
  v37 = v36 + __ROR4__(v33 + v99 - 1019803690 + (v36 & v34 | v35 & ~v34), 23);
  v38 = v37 + __ROR4__(v34 + v88 - 187363961 + (v37 & v35 | v36 & ~v35), 18);
  v39 = v38 + __ROR4__((v38 & v36 | v37 & ~v36) + v35 + v93 + 1163531501, 12);
  v40 = v39 + __ROR4__(v36 + v98 - 1444681467 + (v39 & v37 | v38 & ~v37), 27);
  v41 = v40 + __ROR4__(v37 + v87 - 51403784 + (v40 & v38 | v39 & ~v38), 23);
  v42 = v41 + __ROR4__(v38 + v92 + 1735328473 + (v41 & v39 | v40 & ~v39), 18);
  v43 = v42 + __ROR4__(v39 + v97 - 1926607734 + (v42 & v40 | v41 & ~v40), 12);
  v44 = v43 + __ROR4__(v90 - 378558 + v40 + (v42 ^ v41 ^ v43), 28);
  v45 = v44 + __ROR4__(v41 + v93 - 2022574463 + (v43 ^ v42 ^ v44), 21);
  v46 = v45 + __ROR4__(v42 + v96 + 1839030562 + (v44 ^ v43 ^ v45), 16);
  v47 = v46 + __ROR4__(v43 + v99 - 35309556 + (v45 ^ v44 ^ v46), 9);
  v48 = v47 + __ROR4__(v86 - 1530992060 + v44 + (v46 ^ v45 ^ v47), 28);
  v49 = v48 + __ROR4__((v47 ^ v46 ^ v48) + v45 + v89 + 1272893353, 21);
  v50 = v49 + __ROR4__(v46 + v92 - 155497632 + (v48 ^ v47 ^ v49), 16);
  v51 = v50 + __ROR4__(v95 - 1094730640 + v47 + (v49 ^ v48 ^ v50), 9);
  v52 = v51 + __ROR4__((v50 ^ v49 ^ v51) + v48 + v98 + 681279174, 28);
  v53 = v52 + __ROR4__(v49 + s - 358537222 + (v51 ^ v50 ^ v52), 21);
  v54 = v53 + __ROR4__(v88 - 722521979 + v50 + (v52 ^ v51 ^ v53), 16);
  v55 = v54 + __ROR4__((v53 ^ v52 ^ v54) + v51 + v91 + 76029189, 9);
  v56 = v55 + __ROR4__(v52 + v94 - 640364487 + (v54 ^ v53 ^ v55), 28);
  v57 = v56 + __ROR4__(v97 - 421815835 + v53 + (v55 ^ v54 ^ v56), 21);
  v58 = v57 + __ROR4__(v54 + v100 + 530742520 + (v56 ^ v55 ^ v57), 16);
  v59 = v58 + __ROR4__(v55 + v87 - 995338651 + (v57 ^ v56 ^ v58), 9);
  v60 = v59 + __ROR4__(s - 198630844 + v56 + ((v59 | ~v57) ^ v58), 26);
  v61 = v60 + __ROR4__(v57 + v92 + 1126891415 + ((v60 | ~v58) ^ v59), 22);
  v62 = v61 + __ROR4__(v58 + v99 - 1416354905 + ((v61 | ~v59) ^ v60), 17);
  v63 = v62 + __ROR4__(v90 - 57434055 + v59 + ((v62 | ~v60) ^ v61), 11);
  v64 = v63 + __ROR4__(v60 + v97 + 1700485571 + ((v63 | ~v61) ^ v62), 26);
  v65 = v64 + __ROR4__(v61 + v88 - 1894986606 + ((v64 | ~v62) ^ v63), 22);
  v66 = v65 + __ROR4__(v62 + v95 - 1051523 + ((v65 | ~v63) ^ v64), 17);
  v67 = v66 + __ROR4__(v63 + v86 - 2054922799 + ((v66 | ~v64) ^ v65), 11);
  v68 = v67 + __ROR4__(v64 + v93 + 1873313359 + ((v67 | ~v65) ^ v66), 26);
  v69 = v68 + __ROR4__(v65 + v100 - 30611744 + ((v68 | ~v66) ^ v67), 22);
  v70 = v69 + __ROR4__(v66 + v91 - 1560198380 + ((v69 | ~v67) ^ v68), 17);
  v71 = v70 + __ROR4__(v67 + v98 + 1309151649 + ((v70 | ~v68) ^ v69), 11);
  v72 = v71 + __ROR4__(v68 + v89 - 145523070 + ((v71 | ~v69) ^ v70), 26);
  v73 = v72 + __ROR4__(v69 + v96 - 1120210379 + ((v72 | ~v70) ^ v71), 22);
  v74 = v70 + v87 + 718787259 + ((v73 | ~v71) ^ v72);
  v75 = v71 + v94 - 343485551;
  v76 = v73 + __ROR4__(v74, 17);
  *a1 = v72 + v83;
  v77 = v81;
  v78 = v4 + v76 + __ROR4__(v75 + ((v76 | ~v72) ^ v73), 11);
  v79 = v73 + v82;
  a1[1] = v78;
  a1[3] = v79;
  a1[2] = v77 + v76;
  return memset(&s, 0, 0x40u);
}

//----- (00079D08) --------------------------------------------------------
void *__fastcall sub_79D08(int *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // r6
  unsigned int v4; // r2
  int *v5; // r4
  char *v6; // r7
  int v7; // r0
  unsigned int v8; // r2
  size_t v9; // r5

  v3 = a3;
  v4 = a1[4];
  v5 = a1;
  v6 = a2;
  v7 = (v4 >> 3) & 0x3F;
  v8 = v4 + 8 * v3;
  v5[4] = v8;
  if ( v8 < 8 * v3 )
    ++v5[5];
  v9 = 64 - v7;
  v5[5] += v3 >> 29;
  if ( v3 < 64 - v7 )
  {
    v9 = 0;
  }
  else
  {
    memcpy((char *)v5 + v7 + 24, a2, v9);
    sub_79584(v5, (int)(v5 + 6));
    while ( v9 + 63 < v3 )
    {
      sub_79584(v5, (int)&v6[v9]);
      v9 += 64;
    }
    v7 = 0;
  }
  return j_memcpy((char *)v5 + v7 + 24, &v6[v9], v3 - v9);
}

//----- (00079D78) --------------------------------------------------------
void *__fastcall Curl_md5it(int a1, const char *a2)
{
  int v2; // r7
  char *v3; // r6
  unsigned int v4; // r0
  unsigned int v5; // r2
  unsigned int v6; // r2
  char v8; // [sp+4h] [bp-7Ch]
  int v9; // [sp+Ch] [bp-74h]
  int v10; // [sp+10h] [bp-70h]
  int v11; // [sp+14h] [bp-6Ch]
  int v12; // [sp+18h] [bp-68h]
  unsigned int v13; // [sp+1Ch] [bp-64h]
  int v14; // [sp+20h] [bp-60h]

  v2 = a1;
  v3 = (char *)a2;
  v14 = 0;
  v13 = 0;
  v9 = 1732584193;
  v10 = -271733879;
  v11 = -1732584194;
  v12 = 271733878;
  v4 = strlen(a2);
  sub_79D08(&v9, v3, v4);
  sub_79552((int)&v8, (int)&v13, 8u);
  v5 = (v13 >> 3) & 0x3F;
  if ( v5 > 0x37 )
    v6 = 120 - v5;
  else
    v6 = 56 - v5;
  sub_79D08(&v9, (char *)off_EBB00, v6);
  sub_79D08(&v9, &v8, 8u);
  sub_79552(v2, (int)&v9, 0x10u);
  return memset(&v9, 0, 0x58u);
}
// EBB00: using guessed type int *off_EBB00[16];

//----- (00079E20) --------------------------------------------------------
bool __fastcall Curl_ipvalid(int a1)
{
  return *(_DWORD *)(a1 + 620) != 2;
}

//----- (00079E2C) --------------------------------------------------------
int __fastcall curl_getdate(char *nptr)
{
  int v1; // r11
  int v2; // r5
  char *v3; // r10
  int v4; // r9
  int v5; // r6
  int v6; // r7
  int v7; // r4
  signed int v8; // r8
  char *v9; // r2
  int v10; // r3
  int v11; // r1
  char *v12; // r8
  size_t v13; // r0
  char **v14; // r2
  int v15; // r3
  char **v16; // ST0C_4
  _BOOL4 v17; // r0
  signed int v18; // r3
  int v19; // r0
  int v20; // r10
  signed int v21; // r3
  int v22; // r4
  int v23; // r8
  int result; // r0
  int v25; // r2
  char **v26; // r3
  char **v27; // ST10_4
  _BOOL4 v28; // r0
  int v29; // r2
  int v30; // [sp+Ch] [bp-7Ch]
  int v31; // [sp+Ch] [bp-7Ch]
  int v32; // [sp+10h] [bp-78h]
  signed int v33; // [sp+14h] [bp-74h]
  signed int v34; // [sp+18h] [bp-70h]
  char *v35; // [sp+1Ch] [bp-6Ch]
  int v36; // [sp+2Ch] [bp-5Ch]
  char *v37; // [sp+30h] [bp-58h]
  int v38; // [sp+34h] [bp-54h]
  char *endptr; // [sp+38h] [bp-50h]
  int v40; // [sp+3Ch] [bp-4Ch]
  char s; // [sp+40h] [bp-48h]
  int v42; // [sp+5Ch] [bp-2Ch]

  v2 = -1;
  v3 = nptr;
  v4 = 0;
  v5 = -1;
  v6 = -1;
  v7 = -1;
  v35 = nptr;
  v36 = -1;
  v37 = (char *)-1;
  v38 = -1;
  v34 = 7;
  v33 = -1;
  while ( *v3 )
  {
    if ( !--v34 )
      break;
    v9 = v3;
    do
    {
      v10 = (unsigned __int8)*v9;
      v3 = v9++;
      v11 = ctype_ + v10;
    }
    while ( v10 && !(*(_BYTE *)(v11 + 1) & 7) );
    v12 = v3;
    if ( *(unsigned __int8 *)(v11 + 1) << 30 )
    {
      v40 = 0;
      memset(&s, 0, 0x1Cu);
      sscanf(v3, "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]", &v40);
      v13 = strlen((const char *)&v40);
      v1 = v13;
      if ( v33 == -1 )
      {
        if ( v13 <= 3 )
          v14 = Curl_wkday;
        else
          v14 = off_EF834;
        v15 = 0;
        do
        {
          v16 = v14;
          v32 = v15;
          v17 = Curl_raw_equal((unsigned __int8 *)&v40, v14[v15]);
          v14 = v16;
          v18 = v32;
          if ( v17 )
            goto LABEL_83;
          v15 = v32 + 1;
        }
        while ( v32 != 6 );
      }
      if ( v7 == -1 )
      {
        v25 = 0;
        v26 = Curl_month;
        while ( 1 )
        {
          v31 = v25;
          v27 = v26;
          v28 = Curl_raw_equal((unsigned __int8 *)&v40, v26[v25]);
          v29 = v31;
          v26 = v27;
          if ( v28 )
            break;
          v25 = v31 + 1;
          if ( v31 == 11 )
            goto LABEL_76;
        }
LABEL_82:
        v18 = v33;
        v7 = v29;
LABEL_83:
        v33 = v18;
        goto LABEL_85;
      }
LABEL_76:
      if ( ++v2 )
        goto LABEL_80;
      v2 = (int)&unk_EBB40;
      while ( !Curl_raw_equal((unsigned __int8 *)&v40, (_BYTE *)v2) )
      {
        v2 += 12;
        if ( (_UNKNOWN *)v2 == &unk_EBD44 )
          goto LABEL_80;
      }
      v2 = 60 * *(_DWORD *)(v2 + 8);
LABEL_85:
      v3 += v1;
    }
    else if ( (unsigned int)(v10 - 48) <= 9 )
    {
      if ( v38 != -1 || sscanf(v3, "%02d:%02d:%02d", &v36, &v37, &v38) != 3 )
      {
        v19 = strtol(v3, &endptr, 10);
        v1 = v19;
        if ( v2 != -1
          || endptr - v3 != 4
          || v19 > 1400
          || v35 >= v3
          || (v20 = (unsigned __int8)*(v3 - 1), v20 != 43) && v20 != 45 )
        {
          v21 = 0;
        }
        else
        {
          v30 = 60 * (v19 / 100);
          v2 = 60 * (v19 % 100 + v30);
          if ( v20 == 43 )
            v2 = -60 * (v19 % 100 + v30);
          v21 = 1;
        }
        v3 = endptr;
        if ( endptr - v12 == 8 && v5 == -1 && v7 == -1 && v6 == -1 )
        {
          v5 = v19 / 10000;
          v7 = v19 % 10000 / 100 - 1;
          v1 = v19 % 100;
          goto LABEL_88;
        }
        if ( v21 )
        {
          v1 = v6;
          goto LABEL_88;
        }
        if ( v4 )
        {
          if ( !v4 )
            goto LABEL_80;
LABEL_41:
          if ( ++v5 )
            goto LABEL_80;
          if ( v19 <= 1899 )
          {
            if ( v19 <= 70 )
              v1 = v19 + 2000;
            else
              v1 = v19 + 1900;
          }
          v4 = v6 + 1;
          v5 = v1;
          if ( v6 != -1 )
            v4 = 1;
        }
        else
        {
          if ( v6 != -1 )
            goto LABEL_80;
          if ( (unsigned int)(v19 - 1) > 0x1E )
            goto LABEL_41;
          v4 = 1;
LABEL_88:
          v6 = v1;
        }
      }
      else
      {
        v3 += 8;
      }
    }
  }
  v8 = v7;
  if ( v38 == -1 )
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
  }
  if ( v6 == -1 )
  {
    result = -1;
    goto LABEL_81;
  }
  if ( v7 == -1 )
  {
    result = -1;
    goto LABEL_81;
  }
  if ( v5 == -1 )
  {
    result = -1;
    goto LABEL_81;
  }
  if ( v5 > 2037 )
  {
    result = 0x7FFFFFFF;
    goto LABEL_81;
  }
  v3 = v37;
  v1 = v36;
  v33 = v38;
  if ( v5 <= 1969 )
    goto LABEL_80;
  if ( v7 >= 0 )
  {
    if ( v7 > 11 )
    {
      v5 += v7 / -12;
      v7 %= 12;
    }
  }
  else
  {
    v22 = 11 - v7;
    v5 += v22 / 12;
    v7 = 11 - v22 % 12;
  }
  if ( v8 <= 1 )
    v23 = v5 - 1;
  else
    v23 = v5;
  v4 = v23 / 4 + v23 / -100;
  v5 = v23 / 400 + v4 - 477 + 365 * (v5 - 1970) + *((_DWORD *)&unk_EBB40 + v7 + 129);
  v6 = v6 + v5 - 1;
  v1 = v36 + 24 * v6;
  v3 = &v37[60 * v1];
  result = v38 + 60 * (_DWORD)v3;
  if ( result != -1 )
  {
    if ( v2 == -1 )
    {
      v2 = 0;
    }
    else if ( v2 > 0 && result + v2 < result )
    {
LABEL_80:
      result = -1;
      goto LABEL_81;
    }
    result += v2;
  }
LABEL_81:
  v29 = v42;
  if ( v42 != _stack_chk_guard )
    goto LABEL_82;
  return result;
}
// EF834: using guessed type char *off_EF834[27];
// EF850: using guessed type char *Curl_month[20];
// EF880: using guessed type char *Curl_wkday[8];

//----- (0007A1C8) --------------------------------------------------------
int __fastcall sub_7A1C8(unsigned __int8 *a1, _BYTE *a2)
{
  bool v2; // r3

  v2 = (char)a2;
  if ( a1 )
  {
    if ( a2 )
      return Curl_raw_equal(a1, a2) != 0;
  }
  else
  {
    v2 = a2 == 0;
  }
  return v2;
}

//----- (0007A1EA) --------------------------------------------------------
int __fastcall Curl_ssl_config_matches(int a1, int a2)
{
  unsigned __int8 **v2; // r5
  _BYTE **v3; // r4
  int result; // r0

  v2 = (unsigned __int8 **)a1;
  v3 = (_BYTE **)a2;
  if ( *(_DWORD *)a1 == *(_DWORD *)a2
    && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
    && sub_7A1C8(*(unsigned __int8 **)(a1 + 16), *(_BYTE **)(a2 + 16))
    && sub_7A1C8(v2[5], v3[5])
    && sub_7A1C8(v2[8], v3[8])
    && sub_7A1C8(v2[9], v3[9]) )
  {
    result = sub_7A1C8(v2[10], v3[10]);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0007A240) --------------------------------------------------------
bool __fastcall Curl_clone_ssl_config(int a1, int a2)
{
  _DWORD *v2; // r5
  _DWORD *v3; // r4
  const char *v4; // r0
  const char *v5; // r0
  char *v6; // r0
  char *v8; // r0
  const char *v9; // r0
  char *v10; // r0
  const char *v11; // r0
  char *v12; // r0
  const char *v13; // r0
  char *v14; // r0

  v2 = (_DWORD *)a1;
  v3 = (_DWORD *)a2;
  *(_BYTE *)(a2 + 56) = *(_BYTE *)(a1 + 56);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  v4 = *(const char **)(a1 + 20);
  if ( v4 )
  {
    v6 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v4);
    v3[5] = v6;
    if ( !v6 )
      return 0;
  }
  v5 = (const char *)v2[4];
  if ( v5 )
  {
    v8 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v5);
    v3[4] = v8;
    if ( !v8 )
      return 0;
  }
  v9 = (const char *)v2[10];
  if ( v9 )
  {
    v10 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v9);
    v3[10] = v10;
    if ( !v10 )
      return 0;
  }
  v11 = (const char *)v2[9];
  if ( v11 )
  {
    v12 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v11);
    v3[9] = v12;
    if ( !v12 )
      return 0;
  }
  v13 = (const char *)v2[8];
  if ( !v13 )
    return 1;
  v14 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v13);
  v3[8] = v14;
  return v14 != 0;
}
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);

//----- (0007A2D0) --------------------------------------------------------
int __fastcall Curl_free_ssl_config(int *a1)
{
  int *v1; // r4

  v1 = a1;
  Curl_safefree(a1[5]);
  Curl_safefree(v1[4]);
  Curl_safefree(v1[10]);
  Curl_safefree(v1[9]);
  return Curl_safefree(v1[8]);
}

//----- (0007A2F8) --------------------------------------------------------
int __fastcall sub_7A2F8(int a1)
{
  int v1; // r4

  v1 = *(_DWORD *)(a1 + 736);
  if ( v1 )
  {
    Curl_safefree(*(_DWORD *)(v1 + 320));
    Curl_safefree(*(_DWORD *)(v1 + 324));
    Curl_cfree(v1);
  }
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007A324) --------------------------------------------------------
signed int __fastcall sub_7A324(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r5
  int v3; // r0
  int *v4; // r7
  signed int result; // r0
  int v6; // r6
  int v7; // r0
  int v8; // r5
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r8
  int v13; // r0

  v1 = a1;
  v2 = *a1 == 0;
  time(a1 + 8);
  v3 = Curl_timeleft(v1[3], 0, v2);
  v4 = (int *)v1[3];
  if ( v3 >= 0 )
  {
    v6 = v1[8];
    if ( v2 )
    {
      v7 = (v3 + 500) / 1000;
      v1[9] = v6 + v7;
      v8 = v7;
      v9 = v7 / 5;
      if ( v9 > 0 )
        v1[7] = v9;
      if ( v9 <= 0 )
        v1[7] = 1;
      v10 = v8 / v1[7];
      if ( v10 <= 0 )
        v1[6] = 1;
      else
        v1[6] = v10;
    }
    else
    {
      if ( v3 )
        v11 = (v3 + 500) / 1000;
      else
        v11 = 3600;
      v1[9] = v6 + v11;
      v8 = v11 / 10;
      v1[7] = v11 / 10 / 15;
    }
    if ( v1[7] <= 2 )
      v1[7] = 3;
    if ( v1[7] > 50 )
      v1[7] = 50;
    v12 = v1[7];
    v13 = v8 / v1[7];
    if ( v13 <= 0 )
      v1[6] = 1;
    else
      v1[6] = v13;
    Curl_infof(*v4, "set timeouts for state %d; Total %d, retry %d maxtry %d\n", *v1, v1[9] - v6, v1[6], v12);
    result = 0;
  }
  else
  {
    Curl_failf(*v4, "Connection time-out");
    result = 28;
  }
  return result;
}

//----- (0007A40C) --------------------------------------------------------
signed int __fastcall sub_7A40C(int a1, _BYTE *a2)
{
  int *v2; // r5
  _BYTE *v3; // r8
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  signed int result; // r0
  signed int v7; // r6
  void *v8; // r0
  void *v9; // r0
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r0
  int v14; // r4
  int *v15; // r0
  int v16; // r2
  int v17; // r3
  int v18; // r0

  v2 = (int *)a1;
  v3 = a2;
  Curl_reset_reqproto(a1);
  v4 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(0x148u, 1u);
  v5 = v4;
  v2[184] = (int)v4;
  if ( !v4 )
    return 27;
  v7 = *(_DWORD *)(*v2 + 436);
  if ( v7 )
  {
    if ( (unsigned int)(v7 - 8) > 0xFFB0 )
      return 71;
  }
  else
  {
    v7 = 512;
  }
  if ( !v4[80] )
  {
    v8 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, v7 + 4);
    v5[80] = v8;
    if ( !v8 )
      return 27;
  }
  if ( !v5[81] )
  {
    v9 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, v7 + 4);
    v5[81] = v9;
    if ( !v9 )
      return 27;
  }
  *((_BYTE *)v2 + 296) = 1;
  v5[3] = v2;
  v10 = v2[53];
  v5[79] = v7;
  v5[4] = v10;
  *v5 = 0;
  v5[2] = -100;
  v5[78] = 512;
  *((_WORD *)v5 + 22) = *(_DWORD *)(v2[14] + 4);
  sub_7A324(v5);
  if ( !*((_BYTE *)v2 + 319) )
  {
    v13 = bind(v5[4], (const struct sockaddr *)(v5 + 11), *(_DWORD *)(v2[14] + 16));
    if ( v13 )
    {
      v14 = *v2;
      v15 = (int *)_errno(v13, v11, v12);
      v18 = Curl_strerror((int)v2, *v15, v16, v17);
      Curl_failf(v14, "bind() failed; %s", v18);
      return 7;
    }
    *((_BYTE *)v2 + 319) = 1;
  }
  Curl_pgrsStartNow(*v2, v11, v12);
  result = 0;
  *v3 = 1;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (0007A50C) --------------------------------------------------------
int __fastcall sub_7A50C(int *a1)
{
  Curl_pgrsDone(a1);
  return 0;
}

//----- (0007A518) --------------------------------------------------------
int __fastcall sub_7A518(_DWORD *a1)
{
  int v1; // r4
  _DWORD *v2; // r5
  char *v3; // r0
  signed int v4; // r0

  v1 = *a1;
  v2 = a1;
  a1[32] = 2;
  v3 = strstr(*(const char **)(v1 + 34180), ";mode=");
  if ( v3 || (v3 = strstr((const char *)v2[33], ";mode=")) != 0 )
  {
    *v3 = 0;
    v4 = Curl_raw_toupper((unsigned __int8)v3[6]);
    *(_BYTE *)(v1 + 651) = v4 == 65 || v4 == 78;
  }
  return 0;
}

//----- (0007A56C) --------------------------------------------------------
size_t __fastcall sub_7A56C(size_t a1, int a2, char *a3, const char *a4)
{
  char *v4; // r7
  const char *v5; // r4

  v4 = a3;
  v5 = a4;
  if ( strlen(a4) + a2 + 1 > a1 )
    return 0;
  strcpy(v4, v5);
  return strlen(v5) + 1;
}

//----- (0007A59C) --------------------------------------------------------
signed int __fastcall sub_7A59C(int a1, int a2)
{
  int *v2; // r3
  int v3; // r4
  int v4; // r5
  int v5; // r6
  int v6; // r2
  int v7; // r3
  int v8; // r0
  const char *v9; // r2
  char *v10; // r1
  _BYTE *v11; // r3
  ssize_t v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r4
  int *v16; // r0
  int v17; // r2
  int v18; // r3
  int v19; // r2
  int v20; // r0
  _BYTE *v21; // r3
  ssize_t v22; // r0
  int v23; // r1
  int v24; // r2
  int v25; // r4
  int *v26; // r0
  int v27; // r2
  int v28; // r3
  signed int v29; // r3
  ssize_t v30; // r0
  int v31; // r1
  int v32; // r2
  int v33; // r4
  int *v34; // r0
  int v35; // r2
  int v36; // r3

  v2 = *(int **)(a1 + 12);
  v3 = a1;
  v4 = *v2;
  switch ( a2 )
  {
    case 3:
      v5 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 3) | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 2) << 8);
      if ( *(unsigned __int16 *)(a1 + 40) + 1 != v5 )
      {
        Curl_infof(
          v4,
          "Received unexpected DATA packet block %d\n",
          *(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 3) | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 2) << 8));
        v6 = *(_DWORD *)(v3 + 28);
        v7 = *(_DWORD *)(v3 + 20) + 1;
        *(_DWORD *)(v3 + 20) = v7;
        if ( v7 > v6 )
        {
          v8 = v4;
          v9 = (const char *)(*(unsigned __int16 *)(v3 + 40) + 1);
          v10 = "tftp_rx: giving up waiting for block %d";
          goto LABEL_20;
        }
      }
      v11 = *(_BYTE **)(v3 + 324);
      *(_WORD *)(v3 + 40) = v5;
      *(_DWORD *)(v3 + 20) = 0;
      *v11 = 0;
      *(_BYTE *)(*(_DWORD *)(v3 + 324) + 1) = 4;
      LOWORD(v11) = *(_WORD *)(v3 + 40);
      *(_BYTE *)(*(_DWORD *)(v3 + 324) + 2) = BYTE1(v11);
      *(_BYTE *)(*(_DWORD *)(v3 + 324) + 3) = (_BYTE)v11;
      v12 = sendto(
              *(_DWORD *)(v3 + 16),
              *(const void **)(v3 + 324),
              4u,
              0x4000,
              (const struct sockaddr *)(v3 + 172),
              *(_DWORD *)(v3 + 300));
      if ( v12 < 0 )
      {
        v15 = *(_DWORD *)(v3 + 12);
        v16 = (int *)_errno(v12, v13, v14);
        v19 = Curl_strerror(v15, *v16, v17, v18);
        v20 = v4;
        goto LABEL_16;
      }
      if ( *(_DWORD *)(v3 + 312) + 3 < *(_DWORD *)(v3 + 304) )
        goto LABEL_11;
      goto LABEL_17;
    case 5:
      goto LABEL_17;
    case 6:
      v21 = *(_BYTE **)(a1 + 324);
      *(_WORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *v21 = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 324) + 1) = 4;
      LOWORD(v21) = *(_WORD *)(a1 + 40);
      *(_BYTE *)(*(_DWORD *)(a1 + 324) + 2) = BYTE1(v21);
      *(_BYTE *)(*(_DWORD *)(a1 + 324) + 3) = (_BYTE)v21;
      v22 = sendto(
              *(_DWORD *)(a1 + 16),
              *(const void **)(a1 + 324),
              4u,
              0x4000,
              (const struct sockaddr *)(a1 + 172),
              *(_DWORD *)(a1 + 300));
      if ( v22 < 0 )
      {
        v25 = *(_DWORD *)(v3 + 12);
        v26 = (int *)_errno(v22, v23, v24);
        v19 = Curl_strerror(v25, *v26, v27, v28);
        v20 = v4;
        goto LABEL_16;
      }
LABEL_11:
      v29 = 1;
      goto LABEL_18;
    case 7:
      ++*(_DWORD *)(a1 + 20);
      Curl_infof(v4, "Timeout waiting for block %d ACK.  Retries = %d\n");
      if ( *(_DWORD *)(v3 + 20) > *(_DWORD *)(v3 + 28) )
      {
        *(_DWORD *)(v3 + 8) = -99;
LABEL_17:
        v29 = 3;
LABEL_18:
        *(_DWORD *)v3 = v29;
        return 0;
      }
      v30 = sendto(
              *(_DWORD *)(v3 + 16),
              *(const void **)(v3 + 324),
              4u,
              0x4000,
              (const struct sockaddr *)(v3 + 172),
              *(_DWORD *)(v3 + 300));
      if ( v30 >= 0 )
        return 0;
      v33 = *(_DWORD *)(v3 + 12);
      v34 = (int *)_errno(v30, v31, v32);
      v19 = Curl_strerror(v33, *v34, v35, v36);
      v20 = v4;
LABEL_16:
      Curl_failf(v20, "%s", v19);
      return 55;
    default:
      v8 = *v2;
      v10 = "%s";
      v9 = "tftp_rx: internal error";
LABEL_20:
      Curl_failf(v8, v10, v9);
      return 71;
  }
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0007A754) --------------------------------------------------------
signed int __fastcall sub_7A754(int a1, int a2)
{
  int v2; // r5
  _DWORD *v3; // r4
  signed int result; // r0

  v2 = a2;
  v3 = (_DWORD *)a1;
  Curl_infof(**(_DWORD **)(a1 + 12), "%s\n", "Connected for receive");
  *v3 = 1;
  result = sub_7A324(v3);
  if ( !result )
    result = sub_7A59C((int)v3, v2);
  return result;
}

//----- (0007A78C) --------------------------------------------------------
signed int __fastcall sub_7A78C(int a1, int a2, int a3, int a4)
{
  int *v4; // r3
  int v5; // r4
  int v6; // r5
  int v7; // r2
  int v8; // r3
  int v9; // r0
  int v10; // r2
  char *v11; // r1
  ssize_t v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r4
  int *v16; // r0
  int v17; // r2
  int v18; // r3
  int v19; // r0
  __int16 v20; // r3
  signed int result; // r0
  __int16 v22; // r2
  signed int v23; // r0
  int v24; // r2
  signed int v25; // r6
  ssize_t v26; // r0
  int v27; // r1
  int v28; // r2
  int v29; // r4
  int *v30; // r0
  int v31; // r2
  int v32; // r3
  int v33; // r0
  int v34; // r1
  __int64 v35; // r2
  ssize_t v36; // r0
  int v37; // r1
  int v38; // r2
  int v39; // r4
  int *v40; // r0
  int v41; // r2
  int v42; // r3
  int v43; // r0
  int v44; // [sp+Ch] [bp-14h]

  v44 = a4;
  v4 = *(int **)(a1 + 12);
  v5 = a1;
  v6 = *v4;
  switch ( a2 )
  {
    case 4:
      if ( (*(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 3) | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 320) + 2) << 8)) == *(unsigned __int16 *)(a1 + 40) )
        goto LABEL_7;
      Curl_infof(v6, "Received ACK for block %d, expecting %d\n");
      v7 = *(_DWORD *)(v5 + 28);
      v8 = *(_DWORD *)(v5 + 20) + 1;
      *(_DWORD *)(v5 + 20) = v8;
      if ( v8 > v7 )
      {
        v9 = v6;
        v10 = *(unsigned __int16 *)(v5 + 40);
        v11 = "tftp_tx: giving up waiting for block %d ack";
        goto LABEL_18;
      }
      v12 = sendto(
              *(_DWORD *)(v5 + 16),
              (const void *)(v5 + 324),
              *(_DWORD *)(v5 + 308) + 4,
              0x4000,
              (const struct sockaddr *)(v5 + 172),
              *(_DWORD *)(v5 + 300));
      if ( v12 >= 0 )
        return 0;
      v15 = *(_DWORD *)(v5 + 12);
      v16 = (int *)_errno(v12, v13, v14);
      v19 = Curl_strerror(v15, *v16, v17, v18);
      v11 = "%s";
      v10 = v19;
      v9 = v6;
      goto LABEL_18;
    case 5:
      goto LABEL_20;
    case 6:
LABEL_7:
      v20 = *(_WORD *)(a1 + 40);
      result = 0;
      *(_DWORD *)(v5 + 20) = 0;
      *(_WORD *)(v5 + 40) = v20 + 1;
      **(_BYTE **)(v5 + 324) = 0;
      *(_BYTE *)(*(_DWORD *)(v5 + 324) + 1) = 3;
      v22 = *(_WORD *)(v5 + 40);
      *(_BYTE *)(*(_DWORD *)(v5 + 324) + 2) = HIBYTE(v22);
      *(_BYTE *)(*(_DWORD *)(v5 + 324) + 3) = v22;
      if ( *(unsigned __int16 *)(v5 + 40) > 1u && *(_DWORD *)(v5 + 308) < *(_DWORD *)(v5 + 312) )
      {
        *(_DWORD *)v5 = 3;
        return result;
      }
      v23 = Curl_fillreadbuffer(*(_DWORD *)(v5 + 12), *(_DWORD *)(v5 + 312), (size_t *)&v44);
      v24 = v44;
      *(_DWORD *)(v5 + 308) = v44;
      v25 = v23;
      if ( v23 )
        return v25;
      v26 = sendto(
              *(_DWORD *)(v5 + 16),
              *(const void **)(v5 + 324),
              v24 + 4,
              0x4000,
              (const struct sockaddr *)(v5 + 172),
              *(_DWORD *)(v5 + 300));
      if ( v26 < 0 )
      {
        v29 = *(_DWORD *)(v5 + 12);
        v30 = (int *)_errno(v26, v27, v28);
        v33 = Curl_strerror(v29, *v30, v31, v32);
        v11 = "%s";
        v10 = v33;
        v9 = v6;
        goto LABEL_18;
      }
      v34 = *(_DWORD *)(v5 + 308);
      v35 = *(_QWORD *)(v6 + 64) + (unsigned int)v34;
      *(_QWORD *)(v6 + 64) = v35;
      Curl_pgrsSetUploadCounter(v6, v34, v35);
      return v25;
    case 7:
      ++*(_DWORD *)(a1 + 20);
      Curl_infof(v6, "Timeout waiting for block %d ACK.  Retries = %d\n");
      if ( *(_DWORD *)(v5 + 20) > *(_DWORD *)(v5 + 28) )
      {
        *(_DWORD *)(v5 + 8) = -99;
LABEL_20:
        *(_DWORD *)v5 = 3;
        return 0;
      }
      v36 = sendto(
              *(_DWORD *)(v5 + 16),
              *(const void **)(v5 + 324),
              *(_DWORD *)(v5 + 308) + 4,
              0x4000,
              (const struct sockaddr *)(v5 + 172),
              *(_DWORD *)(v5 + 300));
      if ( v36 >= 0 )
      {
        Curl_pgrsSetUploadCounter(v6, v37, *(_QWORD *)(v6 + 64));
        return 0;
      }
      v39 = *(_DWORD *)(v5 + 12);
      v40 = (int *)_errno(v36, v37, v38);
      v43 = Curl_strerror(v39, *v40, v41, v42);
      v11 = "%s";
      v10 = v43;
      v9 = v6;
LABEL_18:
      Curl_failf(v9, v11, v10);
      return 55;
    default:
      Curl_failf(*v4, "%s", "tftp_tx: internal error");
      return 0;
  }
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0007A96C) --------------------------------------------------------
signed int __fastcall sub_7A96C(int a1, int a2, int a3, int a4)
{
  int v4; // r5
  _DWORD *v5; // r4
  signed int result; // r0
  int v7; // r2
  int v8; // [sp+0h] [bp-10h]

  v8 = a4;
  v4 = a2;
  v5 = (_DWORD *)a1;
  Curl_infof(**(_DWORD **)(a1 + 12), "%s\n", "Connected for transmit");
  *v5 = 2;
  result = sub_7A324(v5);
  if ( !result )
    result = sub_7A78C((int)v5, v4, v7, v8);
  return result;
}

//----- (0007A9A4) --------------------------------------------------------
signed int __fastcall sub_7A9A4(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  int v5; // r3
  const char *v6; // r7
  int v7; // r2
  int v8; // r3
  _BYTE *v9; // r3
  __int64 v10; // r2
  bool v11; // zf
  const char *v12; // r8
  size_t v13; // r9
  int v14; // r9
  __int64 v15; // r2
  bool v16; // zf
  int v17; // r9
  int v18; // r9
  int v19; // r9
  int v20; // r9
  int v21; // r9
  size_t v22; // r0
  ssize_t v23; // r0
  int v24; // r1
  int v25; // r2
  int v26; // r4
  int *v27; // r0
  int v28; // r2
  int v29; // r3
  int v30; // r0
  int v31; // r1
  signed int result; // r0
  char dest; // [sp+14h] [bp-64h]

  v3 = a1;
  v4 = **(_DWORD **)(a1 + 12);
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v5 = *(unsigned __int8 *)(v4 + 651);
      if ( *(_BYTE *)(v4 + 651) )
        v6 = "netascii";
      else
        v6 = "octet";
      switch ( a2 )
      {
        case 0:
        case 7:
          v7 = *(_DWORD *)(a1 + 28);
          v8 = *(_DWORD *)(a1 + 20) + 1;
          *(_DWORD *)(a1 + 20) = v8;
          if ( v8 <= v7 )
          {
            v9 = *(_BYTE **)(a1 + 324);
            if ( *(_BYTE *)(v4 + 664) )
            {
              *v9 = 0;
              *(_BYTE *)(*(_DWORD *)(a1 + 324) + 1) = 2;
              *(_DWORD *)(**(_DWORD **)(a1 + 12) + 264) = *(_DWORD *)(a1 + 324) + 4;
              v10 = *(_QWORD *)(v4 + 440);
              v11 = HIDWORD(v10) == -1;
              if ( HIDWORD(v10) == -1 )
                v11 = (_DWORD)v10 == -1;
              if ( !v11 )
                Curl_pgrsSetUploadSize(v4, a2, v10);
            }
            else
            {
              *v9 = 0;
              *(_BYTE *)(*(_DWORD *)(a1 + 324) + 1) = 1;
            }
            v12 = (const char *)curl_easy_unescape(v4, (char *)(*(_DWORD *)(**(_DWORD **)(v3 + 12) + 34180) + 1), 0, 0);
            if ( !v12 )
              return 27;
            curl_msnprintf(*(_DWORD *)(v3 + 324) + 2, *(_DWORD *)(v3 + 312), "%s%c%s%c", v12, 0, v6, 0);
            v13 = strlen(v12);
            v14 = strlen(v6) + v13 + 4;
            if ( !*(_BYTE *)(v4 + 664) )
              goto LABEL_40;
            v15 = *(_QWORD *)(v4 + 440);
            v16 = HIDWORD(v15) == -1;
            if ( HIDWORD(v15) == -1 )
              v16 = (_DWORD)v15 == -1;
            if ( v16 )
LABEL_40:
              strcpy(&dest, "0");
            else
              curl_msnprintf((int)&dest, 64, "%lld");
            v17 = v14 + sub_7A56C(*(_DWORD *)(v3 + 312), v14, (char *)(*(_DWORD *)(v3 + 324) + v14), "tsize");
            v18 = v17 + sub_7A56C(*(_DWORD *)(v3 + 312), v17, (char *)(*(_DWORD *)(v3 + 324) + v17), &dest);
            curl_msnprintf((int)&dest, 64, "%d", *(_DWORD *)(v3 + 316));
            v19 = v18 + sub_7A56C(*(_DWORD *)(v3 + 312), v18, (char *)(*(_DWORD *)(v3 + 324) + v18), "blksize");
            v20 = v19 + sub_7A56C(*(_DWORD *)(v3 + 312), v19, (char *)(*(_DWORD *)(v3 + 324) + v19), &dest);
            curl_msnprintf((int)&dest, 64, "%d", *(_DWORD *)(v3 + 24));
            v21 = v20 + sub_7A56C(*(_DWORD *)(v3 + 312), v20, (char *)(*(_DWORD *)(v3 + 324) + v20), "interval");
            v22 = sub_7A56C(*(_DWORD *)(v3 + 312), v21, (char *)(*(_DWORD *)(v3 + 324) + v21), &dest);
            v23 = sendto(
                    *(_DWORD *)(v3 + 16),
                    *(const void **)(v3 + 324),
                    v21 + v22,
                    0,
                    *(const struct sockaddr **)(*(_DWORD *)(*(_DWORD *)(v3 + 12) + 56) + 24),
                    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 12) + 56) + 16));
            if ( v23 < 0 )
            {
              v26 = *(_DWORD *)(v3 + 12);
              v27 = (int *)_errno(v23, v24, v25);
              v30 = Curl_strerror(v26, *v27, v28, v29);
              Curl_failf(v4, "%s", v30);
            }
            Curl_safefree((int)v12);
          }
          else
          {
            *(_DWORD *)(a1 + 8) = -98;
LABEL_30:
            *(_DWORD *)a1 = 3;
          }
          break;
        case 3:
          v31 = 3;
          goto LABEL_29;
        case 4:
          v31 = 4;
          goto LABEL_27;
        case 5:
          goto LABEL_30;
        case 6:
          v5 = *(unsigned __int8 *)(v4 + 664);
          v31 = 6;
          if ( *(_BYTE *)(v4 + 664) )
LABEL_27:
            result = sub_7A96C(a1, v31, a3, v5);
          else
LABEL_29:
            result = sub_7A754(a1, v31);
          return result;
        default:
          Curl_failf(**(_DWORD **)(a1 + 12), "tftp_send_first: internal error");
          goto LABEL_36;
      }
      goto LABEL_36;
    case 1:
      result = sub_7A59C(a1, a2);
      break;
    case 2:
      result = sub_7A78C(a1, a2, a3, *(_DWORD *)a1);
      break;
    case 3:
      Curl_infof(**(_DWORD **)(a1 + 12), "%s\n", "TFTP finished");
LABEL_36:
      result = 0;
      break;
    default:
      Curl_failf(**(_DWORD **)(a1 + 12), "%s", "Internal state machine error");
      result = 71;
      break;
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0007AC78) --------------------------------------------------------
signed int __fastcall sub_7AC78(int *a1, _BYTE *a2)
{
  int *v2; // r7
  int v3; // r8
  _BYTE *v4; // r5
  int v5; // r2
  int v6; // r4
  signed int v7; // r5
  signed int result; // r0
  signed int v9; // r0
  int v10; // r1
  int v11; // r2
  int *v12; // r0
  signed int v13; // r9
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r2
  int v18; // r2
  ssize_t v19; // r0
  int v20; // r3
  signed int v21; // r3
  const char *v22; // r2
  int v23; // r1
  __int64 v24; // r2
  char *v25; // r5
  int v26; // r6
  size_t v27; // r10
  _BYTE *v28; // r0
  int v29; // r11
  int v30; // r3
  int v31; // r0
  char *v32; // r1
  char **endptr; // ST14_4
  char *v34; // r0
  int v35; // r3
  unsigned int v36; // r11
  size_t v37; // r0
  int v38; // r11
  const char *v39; // r10
  int v40; // r0
  int v41; // r0
  signed int v42; // r3
  int v43; // r0
  const char *v44; // r2
  int v45; // r2
  int v46; // r0
  int v47; // r1
  int v48; // r5
  signed int v49; // r2
  int v50; // [sp+18h] [bp-D8h]
  int v51; // [sp+1Ch] [bp-D4h]
  int v52; // [sp+20h] [bp-D0h]
  socklen_t n; // [sp+3Ch] [bp-B4h]
  time_t timer; // [sp+40h] [bp-B0h]
  struct sockaddr addr; // [sp+44h] [bp-ACh]
  int v56; // [sp+C4h] [bp-2Ch]

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  *a2 = 1;
  Curl_reset_reqproto((int)a1);
  if ( !v2[184] )
  {
    result = sub_7A40C((int)v2, v4);
    if ( result )
      goto LABEL_84;
  }
  v6 = v2[184];
  v7 = sub_7A9A4(v2[184], 0, v5);
  while ( *(_DWORD *)v6 != 3 )
  {
    if ( v7 )
      goto LABEL_82;
    v9 = Curl_socket_ready(*(_DWORD *)(v6 + 16), -1, 1000 * *(_DWORD *)(v6 + 24));
    if ( v9 == -1 )
    {
      v12 = (int *)_errno(-1, v10, v11);
      v13 = 5;
      v16 = Curl_strerror((int)v2, *v12, v14, v15);
      Curl_failf(v3, "%s", v16);
      goto LABEL_8;
    }
    if ( !v9 )
      goto LABEL_55;
    v18 = *(_DWORD *)(v6 + 312);
    n = 128;
    v19 = recvfrom(*(_DWORD *)(v6 + 16), *(void **)(v6 + 320), v18 + 4, 0, &addr, &n);
    v20 = *(_DWORD *)(v6 + 300);
    *(_DWORD *)(v6 + 304) = v19;
    if ( !v20 )
    {
      memcpy((void *)(v6 + 172), &addr, n);
      *(_DWORD *)(v6 + 300) = n;
    }
    v21 = *(_DWORD *)(v6 + 304);
    if ( v21 <= 3 )
    {
      Curl_failf(v3, "Received too short packet");
LABEL_55:
      v13 = 7;
      goto LABEL_8;
    }
    v22 = *(const char **)(v6 + 320);
    v13 = *((unsigned __int8 *)v22 + 1) | (*(unsigned __int8 *)v22 << 8);
    switch ( v13 )
    {
      case 3:
        if ( v21 == 4
          || *(unsigned __int16 *)(v6 + 40) + 1 != (*((unsigned __int8 *)v22 + 3) | (*((unsigned __int8 *)v22 + 2) << 8)) )
        {
          goto LABEL_53;
        }
        result = Curl_client_write(v2, 1, v22 + 4, v21 - 4);
        if ( !result )
        {
          v23 = *(_DWORD *)(v6 + 304) - 4;
          v24 = *(_QWORD *)(v3 + 56) + v23;
          *(_QWORD *)(v3 + 56) = v24;
          Curl_pgrsSetDownloadCounter(v3, v23, v24);
          goto LABEL_53;
        }
        goto LABEL_84;
      case 4:
        goto LABEL_53;
      case 5:
        *(_DWORD *)(v6 + 8) = *((unsigned __int8 *)v22 + 3) | (*((unsigned __int8 *)v22 + 2) << 8);
        Curl_infof(v3, "%s\n", v22 + 4);
        goto LABEL_53;
      case 6:
        v52 = v21 - 2;
        v25 = (char *)(v22 + 2);
        v51 = (int)(v22 + 2);
        v26 = **(_DWORD **)(v6 + 12);
        *(_DWORD *)(v6 + 312) = 512;
        break;
      default:
        Curl_failf(v3, "%s", "Internal error: Unexpected packet");
        goto LABEL_53;
    }
    while ( (unsigned int)v25 < v51 + v52 )
    {
      v27 = v51 + v52 - (_DWORD)v25;
      v28 = memchr(v25, 0, v27);
      if ( v28 )
        v29 = v28 - v25;
      else
        v29 = v51 + v52 - (_DWORD)v25;
      v30 = v29 + 1;
      if ( v29 + 1 >= v27 )
        goto LABEL_88;
      endptr = (char **)(v27 - v30);
      v50 = (int)&v25[v30];
      v34 = (char *)memchr(&v25[v30], 0, v27 - v30);
      v35 = (int)endptr;
      if ( v34 )
        v35 = (int)&v34[-v50];
      v36 = v29 + 2 + v35;
      if ( v36 > v27 || (v37 = strlen(v25), v38 = (int)&v25[v36], v39 = &v25[v37 + 1], !v38) )
      {
LABEL_88:
        v31 = v26;
        v32 = "Malformed ACK packet, rejecting";
LABEL_49:
        Curl_failf(v31, v32);
        goto LABEL_85;
      }
      Curl_infof(v26, "got option=(%s) value=(%s)\n", v25, &v25[v37 + 1]);
      v40 = strlen(v25);
      if ( Curl_raw_nequal(v25, (int)"blksize", v40) )
      {
        v41 = strtol(v39, 0, 10);
        v42 = v41;
        if ( !v41 )
        {
          v31 = v26;
          v32 = "invalid blocksize value in OACK packet";
          goto LABEL_49;
        }
        if ( v41 > 65464 )
        {
          v43 = v26;
          v42 = 65464;
          v44 = "blksize is larger than max supported";
LABEL_42:
          Curl_failf(v43, "%s (%d)", v44, v42);
          goto LABEL_85;
        }
        if ( v41 <= 7 )
        {
          v43 = v26;
          v42 = 8;
          v44 = "blksize is smaller than min supported";
          goto LABEL_42;
        }
        v45 = *(_DWORD *)(v6 + 316);
        if ( v41 > v45 )
        {
          v43 = v26;
          v44 = "server requested blksize larger than allocated";
          goto LABEL_42;
        }
        *(_DWORD *)(v6 + 312) = v41;
        Curl_infof(v26, "%s (%d) %s (%d)\n", "blksize parsed from OACK", v41, "requested", v45);
      }
      else
      {
        v46 = strlen(v25);
        if ( Curl_raw_nequal(v25, (int)"tsize", v46) )
        {
          v48 = strtol(v39, 0, 10);
          v31 = v26;
          if ( !v48 )
          {
            v32 = "invalid tsize value in OACK packet";
            goto LABEL_49;
          }
          Curl_pgrsSetDownloadSize(v26, v47, v48);
          Curl_infof(v26, "%s (%d)\n", "tsize parsed from OACK", v48);
        }
      }
      v25 = (char *)v38;
    }
LABEL_53:
    if ( Curl_pgrsUpdate(v2) )
      goto LABEL_81;
LABEL_8:
    time(&timer);
    v17 = timer;
    if ( (signed int)timer > *(_DWORD *)(v6 + 36) )
    {
      *(_DWORD *)(v6 + 8) = -99;
      *(_DWORD *)v6 = 3;
    }
    v7 = sub_7A9A4(v6, v13, v17);
  }
  if ( v7 )
    goto LABEL_82;
  result = Curl_setup_transfer(v2, -1, -1LL, 0, 0, -1, 0);
  if ( result )
    goto LABEL_84;
  v49 = *(_DWORD *)(v6 + 8);
  if ( v49 == -100 )
  {
LABEL_82:
    result = v7;
  }
  else
  {
    if ( v49 != 2 )
    {
      if ( v49 > 2 )
      {
        if ( v49 == 5 )
        {
          result = 72;
          goto LABEL_84;
        }
        if ( v49 > 5 )
        {
          if ( v49 == 6 )
          {
            result = 73;
            goto LABEL_84;
          }
          if ( v49 == 7 )
          {
            result = 74;
            goto LABEL_84;
          }
        }
        else
        {
          if ( v49 == 3 )
          {
            result = 70;
            goto LABEL_84;
          }
          if ( v49 == 4 )
            goto LABEL_85;
        }
      }
      else
      {
        if ( v49 == -98 )
        {
          result = 7;
          goto LABEL_84;
        }
        if ( (unsigned __int8)((v49 + 98 < 0) ^ __OFADD__(v49, 98)) | (v49 == -98) )
        {
          if ( v49 == -99 )
          {
            result = 28;
            goto LABEL_84;
          }
        }
        else
        {
          if ( !v49 )
            goto LABEL_85;
          if ( v49 == 1 )
          {
            result = 68;
            goto LABEL_84;
          }
        }
      }
LABEL_81:
      result = 42;
      goto LABEL_84;
    }
    result = 69;
  }
LABEL_84:
  while ( v56 != _stack_chk_guard )
LABEL_85:
    result = 71;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0007B090) --------------------------------------------------------
signed int __fastcall Curl_blockread_all(int a1, int a2, char *a3, size_t a4, _DWORD *a5, int a6)
{
  size_t v6; // r8
  int v7; // r10
  int v8; // r7
  char *v9; // r5
  int v10; // r4
  int v11; // r2
  signed int result; // r0
  int v13; // [sp+4h] [bp+0h]
  __time_t v14; // [sp+8h] [bp+4h]
  int v15; // [sp+Ch] [bp+8h]

  v6 = a4;
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = 0;
  *a5 = 0;
  while ( 1 )
  {
    curlx_tvnow(&v14);
    v11 = curlx_tvdiff(v14, v15, *(_DWORD *)(v7 + 204), *(_DWORD *)(v7 + 208));
    if ( v11 > a6 || Curl_socket_ready(v8, -1, a6 - v11) <= 0 )
      break;
    result = Curl_read_plain(v8, v9, v6, &v13);
    if ( result )
      return result;
    if ( v6 == v13 )
    {
      *a5 = v10 + v6;
      return result;
    }
    if ( !v13 )
      break;
    v6 -= v13;
    v9 += v13;
    v10 += v13;
  }
  return -1;
}

//----- (0007B10C) --------------------------------------------------------
signed int __fastcall Curl_SOCKS4(int a1, const char *a2, unsigned int a3, int a4, int *a5, char a6)
{
  unsigned int v6; // r11
  int v7; // r10
  const char *v8; // r7
  int v9; // r8
  int v10; // r5
  signed int v12; // r0
  int v13; // r11
  size_t v14; // r10
  size_t v15; // r11
  int v16; // r0
  char *v17; // r1
  size_t v18; // r11
  char *v19; // r1
  int v20; // [sp+18h] [bp-188h]
  int *v21; // [sp+20h] [bp-180h]
  unsigned __int8 v22; // [sp+24h] [bp-17Ch]
  unsigned __int8 v23; // [sp+26h] [bp-17Ah]
  unsigned __int8 v24; // [sp+28h] [bp-178h]
  unsigned __int8 v25; // [sp+2Ah] [bp-176h]
  char v26; // [sp+2Ch] [bp-174h]
  char v27; // [sp+6Ch] [bp-134h]
  unsigned __int8 v28; // [sp+6Dh] [bp-133h]
  __int16 v29; // [sp+6Eh] [bp-132h]
  unsigned __int8 v30; // [sp+70h] [bp-130h]
  unsigned __int8 v31; // [sp+71h] [bp-12Fh]
  unsigned __int8 v32; // [sp+72h] [bp-12Eh]
  unsigned __int8 v33; // [sp+73h] [bp-12Dh]
  unsigned __int16 v34[128]; // [sp+74h] [bp-12Ch]

  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = a5[a4 + 53];
  v10 = *a5;
  v20 = Curl_timeleft((int)a5, 0, 1);
  if ( v20 < 0 )
  {
    Curl_failf(v10, "Connection time-out");
    return 28;
  }
  curlx_nonblock(v9);
  v27 = 4;
  v28 = 1;
  v29 = __rev16(v6);
  if ( !a6 )
  {
    v12 = Curl_resolv(a5, v8, v6, (const char **)&v21);
    if ( v12 == -1 )
      return 5;
    if ( v12 == 1 )
      Curl_wait_for_resolv(a5, &v21);
    if ( !v21
      || (v13 = *v21) == 0
      || ((Curl_printable_address(v13, &v26, 0x40u), sscanf(&v26, "%hu.%hu.%hu.%hu", &v22, &v23, &v24, &v25) != 4) ? (v13 = 0) : (v30 = v22, v31 = v23, v32 = v24, v33 = v25),
          Curl_resolv_unlock(v10, (int)v21),
          !v13) )
    {
      Curl_failf(v10, "Failed to resolve \"%s\" for SOCKS4 connect.", v8);
      return 6;
    }
  }
  LOBYTE(v34[0]) = 0;
  if ( v7 )
    strlcat(v34, v7, 254);
  v14 = strlen((const char *)v34) + 9;
  if ( a6 && (v30 = 0, v31 = 0, v32 = 0, v33 = 1, v15 = strlen(v8) + 1, (signed int)(v14 + v15) <= 262) )
    strcpy(&v27 + v14, v8);
  else
    v15 = 0;
  if ( Curl_write_plain(a5, v9, &v27, v14 + v15, (ssize_t *)&v22) || *(_DWORD *)&v22 != v14 + v15 )
  {
    v16 = v10;
    v17 = "Failed to send SOCKS4 connect request.";
  }
  else if ( a6
         && !v15
         && ((v18 = strlen(v8) + 1, Curl_write_plain(a5, v9, v8, v18, (ssize_t *)&v22)) || *(_DWORD *)&v22 != v18) )
  {
    v16 = v10;
    v17 = "Failed to send SOCKS4 connect request.";
  }
  else if ( Curl_blockread_all((int)a5, v9, &v27, 8u, &v21, v20) || v21 != (int *)byte_8 )
  {
    v16 = v10;
    v17 = "Failed to receive SOCKS4 connect request ack.";
  }
  else
  {
    if ( !v27 )
    {
      switch ( v28 )
      {
        case 0x5Au:
          if ( a6 )
            v19 = "SOCKS4a request granted.\n";
          else
            v19 = "SOCKS4 request granted.\n";
          Curl_infof(v10, v19);
          curlx_nonblock(v9);
          return 0;
        case 0x5Bu:
          Curl_failf(
            v10,
            "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected or failed.",
            v30,
            v31,
            v32,
            v33,
            (unsigned __int16)__rev16(v34[0]),
            91);
          return 7;
        case 0x5Cu:
          Curl_failf(
            v10,
            "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected because SOCKS server cannot conne"
            "ct to identd on the client.",
            v30,
            v31,
            v32,
            v33,
            (unsigned __int16)__rev16(v34[0]),
            92);
          break;
        case 0x5Du:
          Curl_failf(
            v10,
            "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected because the client program and id"
            "entd report different user-ids.",
            v30,
            v31,
            v32,
            v33,
            (unsigned __int16)__rev16(v34[0]),
            93);
          break;
        default:
          Curl_failf(
            v10,
            "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), Unknown.",
            v30,
            v31,
            v32,
            v33,
            (unsigned __int16)__rev16(v34[0]),
            v28);
          break;
      }
      return 7;
    }
    v16 = v10;
    v17 = "SOCKS4 reply has wrong version, version should be 4.";
  }
  Curl_failf(v16, v17);
  return 7;
}
// 25994: using guessed type int __fastcall strlcat(_DWORD, _DWORD, _DWORD);

//----- (0007B408) --------------------------------------------------------
int __fastcall Curl_SOCKS5(int a1, int a2, char *s, int a4, int a5, int a6)
{
  const char *v6; // r8
  const char *v7; // r11
  int v8; // r4
  int v9; // r6
  size_t v10; // r0
  size_t v11; // r10
  int v12; // r9
  int v13; // r0
  char *v14; // r1
  signed int v15; // r0
  int v16; // r0
  char *v17; // r1
  char v19; // r3
  signed int v20; // r0
  size_t n; // ST10_4
  size_t v22; // r0
  size_t v23; // r12
  size_t v24; // r3
  size_t v25; // ST14_4
  size_t v26; // ST10_4
  size_t v27; // r8
  size_t v28; // r8
  signed int v29; // r0
  int v30; // r8
  int v31; // r3
  int v32; // r10
  signed int v33; // [sp+18h] [bp-2E8h]
  char *src; // [sp+1Ch] [bp-2E4h]
  int v35; // [sp+20h] [bp-2E0h]
  char v36; // [sp+28h] [bp-2D8h]
  ssize_t v37; // [sp+2Ch] [bp-2D4h]
  int *v38; // [sp+30h] [bp-2D0h]
  unsigned __int8 v39; // [sp+34h] [bp-2CCh]
  unsigned __int8 v40; // [sp+36h] [bp-2CAh]
  unsigned __int8 v41; // [sp+38h] [bp-2C8h]
  unsigned __int8 v42; // [sp+3Ah] [bp-2C6h]
  char v43; // [sp+3Ch] [bp-2C4h]
  unsigned __int8 v44; // [sp+7Ch] [bp-284h]
  unsigned __int8 v45; // [sp+7Dh] [bp-283h]
  char v46; // [sp+7Eh] [bp-282h]
  char v47; // [sp+7Fh] [bp-281h]
  unsigned __int8 v48; // [sp+80h] [bp-280h]
  unsigned __int8 v49; // [sp+81h] [bp-27Fh]
  unsigned __int8 v50; // [sp+82h] [bp-27Eh]
  unsigned __int8 v51; // [sp+83h] [bp-27Dh]
  unsigned __int16 v52; // [sp+84h] [bp-27Ch]
  __int16 v53; // [sp+86h] [bp-27Ah]

  v6 = (const char *)a1;
  v35 = a4;
  v7 = (const char *)a2;
  src = s;
  v8 = *(_DWORD *)a6;
  v9 = *(_DWORD *)(a6 + 4 * a5 + 212);
  v10 = strlen(s);
  v11 = v10;
  if ( *(_DWORD *)(v8 + 596) == 5 )
  {
    v33 = 1;
  }
  else if ( v10 <= 0xFF )
  {
    v33 = 0;
  }
  else
  {
    Curl_infof(v8, "SOCKS5: server resolving disabled for hostnames of length > 255 [actual len=%d]\n", v10);
    v33 = 1;
  }
  v12 = Curl_timeleft(a6, 0, 1);
  if ( v12 < 0 )
  {
    v13 = v8;
    v14 = "Connection time-out";
LABEL_12:
    Curl_failf(v13, v14);
    return 28;
  }
  curlx_nonblock(v9);
  v15 = Curl_socket_ready(-1, v9, v12);
  if ( v15 == -1 )
  {
    v16 = *(_DWORD *)a6;
    v17 = "SOCKS5: no connection here";
LABEL_53:
    Curl_failf(v16, v17);
    return 7;
  }
  if ( !v15 )
  {
    v13 = *(_DWORD *)a6;
    v14 = "SOCKS5: connection timeout";
    goto LABEL_12;
  }
  if ( v15 & 4 )
  {
    v16 = *(_DWORD *)a6;
    v17 = "SOCKS5: error occured during connection";
    goto LABEL_53;
  }
  v46 = 0;
  v44 = 5;
  if ( v6 )
    v19 = 2;
  else
    v19 = 1;
  v47 = 2;
  v45 = v19;
  curlx_nonblock(v9);
  if ( Curl_write_plain((int *)a6, v9, &v44, v45 + 2, &v37) || v37 != v45 + 2 )
  {
    v16 = v8;
    v17 = "Unable to send initial SOCKS5 request.";
    goto LABEL_53;
  }
  curlx_nonblock(v9);
  v20 = Curl_socket_ready(v9, -1, v12);
  if ( v20 == -1 )
  {
    v16 = *(_DWORD *)a6;
    v17 = "SOCKS5 nothing to read";
    goto LABEL_53;
  }
  if ( !v20 )
  {
    v13 = *(_DWORD *)a6;
    v14 = "SOCKS5 read timeout";
    goto LABEL_12;
  }
  if ( v20 & 4 )
  {
    Curl_failf(*(_DWORD *)a6, "SOCKS5 read error occured", v20 + 1);
    return 56;
  }
  curlx_nonblock(v9);
  if ( Curl_blockread_all(a6, v9, (char *)&v44, 2u, &v36, v12) || *(_DWORD *)&v36 != 2 )
  {
    v16 = v8;
    v17 = "Unable to receive initial SOCKS5 response.";
    goto LABEL_53;
  }
  if ( v44 != 5 )
  {
    v16 = v8;
    v17 = "Received invalid version in initial SOCKS5 response.";
    goto LABEL_53;
  }
  if ( v45 )
  {
    if ( v45 != 2 )
    {
      v16 = v8;
      if ( v45 == 1 )
      {
        v17 = "SOCKS5 GSSAPI per-message authentication is not supported.";
      }
      else if ( v45 == 255 )
      {
        if ( v6 && *v6 )
          v17 = "No authentication method was acceptable.";
        else
          v17 = "No authentication method was acceptable. (It is quite likely that the SOCKS5 server wanted a username/pa"
                "ssword, since none was supplied to the server on this connection.)";
      }
      else
      {
        v17 = "Undocumented SOCKS5 mode attempted to be used by server.";
      }
      goto LABEL_53;
    }
    if ( v6 )
    {
      if ( v7 )
      {
        n = strlen(v6);
        v22 = strlen(v7);
        v23 = n;
        v24 = v22;
      }
      else
      {
        v24 = 0;
        v23 = 0;
      }
    }
    else
    {
      v24 = 0;
      v23 = 0;
    }
    v44 = 1;
    v45 = v23;
    v25 = v24;
    v26 = v23;
    memcpy(&v46, v6, v23);
    *(&v44 + v26 + 2) = v25;
    memcpy(&v44 + v26 + 3, v7, v25);
    v27 = v26 + 3 + v25;
    if ( Curl_write_plain((int *)a6, v9, &v44, v27, &v37) || v27 != v37 )
    {
      v16 = v8;
      v17 = "Failed to send SOCKS5 sub-negotiation request.";
      goto LABEL_53;
    }
    if ( Curl_blockread_all(a6, v9, (char *)&v44, 2u, &v36, v12) || *(_DWORD *)&v36 != 2 )
    {
      v16 = v8;
      v17 = "Unable to receive SOCKS5 sub-negotiation response.";
      goto LABEL_53;
    }
    if ( v45 )
    {
      Curl_failf(v8, "User was rejected by the SOCKS5 server (%d %d).", v44);
      return 7;
    }
  }
  v44 = 5;
  v46 = 0;
  v45 = 1;
  if ( v33 )
  {
    v29 = Curl_resolv((int *)a6, src, v35, (const char **)&v38);
    v47 = 1;
    if ( v29 != -1 )
    {
      if ( v29 == 1 )
        Curl_wait_for_resolv((int *)a6, &v38);
      if ( v38 )
      {
        v30 = *v38;
        if ( *v38 )
        {
          Curl_printable_address(*v38, &v43, 0x40u);
          if ( sscanf(&v43, "%hu.%hu.%hu.%hu", &v39, &v40, &v41, &v42) == 4 )
          {
            v48 = v39;
            v49 = v40;
            v50 = v41;
            v51 = v42;
          }
          else
          {
            v30 = 0;
          }
          Curl_resolv_unlock(v8, (int)v38);
          if ( v30 )
          {
            v28 = 10;
            v52 = __rev16(v35);
            goto LABEL_71;
          }
        }
      }
      Curl_failf(v8, "Failed to resolve \"%s\" for SOCKS5 connect.", src);
    }
    return 6;
  }
  v48 = v11;
  v28 = v11 + 7;
  v47 = 3;
  memcpy(&v49, src, v11);
  *(_WORD *)(&v44 + v11 + 5) = __rev16(v35);
LABEL_71:
  if ( Curl_write_plain((int *)a6, v9, &v44, v28, &v37) || v37 != v28 )
  {
    v16 = v8;
    v17 = "Failed to send SOCKS5 connect request.";
    goto LABEL_53;
  }
  if ( Curl_blockread_all(a6, v9, (char *)&v44, 0xAu, &v36, v12) || *(_DWORD *)&v36 != 10 )
  {
    v16 = v8;
    v17 = "Failed to receive SOCKS5 connect request ack.";
    goto LABEL_53;
  }
  if ( v44 != 5 )
  {
    v16 = v8;
    v17 = "SOCKS5 reply has wrong version, version should be 5.";
    goto LABEL_53;
  }
  if ( v45 )
  {
    Curl_failf(
      v8,
      "Can't complete SOCKS5 connection to %d.%d.%d.%d:%d. (%d)",
      v48,
      v49,
      v50,
      v51,
      (unsigned __int16)__rev16(v52),
      v45);
    return 7;
  }
  if ( v47 == 3 )
  {
    v31 = v48 + 7;
    if ( v31 <= 10 )
      goto LABEL_89;
LABEL_86:
    v32 = v31 - 10;
    if ( Curl_blockread_all(a6, v9, (char *)&v53, v31 - 10, &v36, v12) || *(_DWORD *)&v36 != v32 )
    {
      v16 = v8;
      v17 = "Failed to receive SOCKS5 connect request ack.";
      goto LABEL_53;
    }
    goto LABEL_89;
  }
  if ( v47 == 4 )
  {
    v31 = 22;
    goto LABEL_86;
  }
LABEL_89:
  curlx_nonblock(v9);
  return 0;
}

//----- (0007B8D4) --------------------------------------------------------
signed int __fastcall Curl_raw_toupper(signed int result)
{
  switch ( result )
  {
    case 97:
      result = 65;
      break;
    case 98:
      result = 66;
      break;
    case 99:
      result = 67;
      break;
    case 100:
      result = 68;
      break;
    case 101:
      result = 69;
      break;
    case 102:
      result = 70;
      break;
    case 103:
      result = 71;
      break;
    case 104:
      result = 72;
      break;
    case 105:
      result = 73;
      break;
    case 106:
      result = 74;
      break;
    case 107:
      result = 75;
      break;
    case 108:
      result = 76;
      break;
    case 109:
      result = 77;
      break;
    case 110:
      result = 78;
      break;
    case 111:
      result = 79;
      break;
    case 112:
      result = 80;
      break;
    case 113:
      result = 81;
      break;
    case 114:
      result = 82;
      break;
    case 115:
      result = 83;
      break;
    case 116:
      result = 84;
      break;
    case 117:
      result = 85;
      break;
    case 118:
      result = 86;
      break;
    case 119:
      result = 87;
      break;
    case 120:
      result = 88;
      break;
    case 121:
      result = 89;
      break;
    case 122:
      result = 90;
      break;
    default:
      return result;
  }
  return result;
}

//----- (0007B962) --------------------------------------------------------
bool __fastcall Curl_raw_equal(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 *v2; // r5
  _BYTE *v3; // r4
  unsigned __int8 *v4; // r7
  signed int v5; // r0
  signed int v6; // t1
  _BYTE *v7; // r6
  signed int v8; // r4
  signed int v10; // r8

  v2 = a1;
  v3 = a2;
  do
  {
    v4 = v2;
    v6 = *v2++;
    v5 = v6;
    v7 = v3;
    if ( !v6 )
      break;
    ++v3;
    if ( !*v7 )
      break;
    v10 = Curl_raw_toupper(v5);
  }
  while ( v10 == Curl_raw_toupper((unsigned __int8)*(v3 - 1)) );
  v8 = Curl_raw_toupper(*v4);
  return (unsigned int)(v8 - Curl_raw_toupper((unsigned __int8)*v7)) <= 0;
}

//----- (0007B9A8) --------------------------------------------------------
bool __fastcall Curl_raw_nequal(_BYTE *a1, int a2, int a3)
{
  int v3; // r4
  _BYTE *v4; // r5
  int v5; // r6
  unsigned __int8 *v6; // r7
  signed int v7; // r8
  signed int v8; // r4

  v3 = a2 + 1;
  v4 = a1;
  v5 = a3;
  while ( 1 )
  {
    v6 = (unsigned __int8 *)(v3 - 1);
    if ( !*v4 || !*(_BYTE *)(v3 - 1) )
      break;
    if ( !v5 )
      return 1;
    ++v3;
    v7 = Curl_raw_toupper((unsigned __int8)*v4);
    if ( v7 != Curl_raw_toupper(*(unsigned __int8 *)(v3 - 2)) )
      goto LABEL_6;
    --v5;
    ++v4;
  }
  if ( v5 )
  {
LABEL_6:
    v8 = Curl_raw_toupper((unsigned __int8)*v4);
    return (unsigned int)(v8 - Curl_raw_toupper(*v6)) <= 0;
  }
  return 1;
}

//----- (0007B9FC) --------------------------------------------------------
signed int __fastcall Curl_strntoupper(signed int result, int a2, int a3)
{
  signed int v3; // r7
  int v4; // r5
  int v5; // r6
  int v6; // r4

  v3 = result;
  v4 = a2;
  v5 = a3;
  if ( a3 )
  {
    v6 = 0;
    do
    {
      result = Curl_raw_toupper(*(unsigned __int8 *)(v4 + v6));
      *(_BYTE *)(v3 + v6) = result;
      if ( !*(_BYTE *)(v4 + v6) )
        break;
      ++v6;
    }
    while ( v5 != v6 );
  }
  return result;
}

//----- (0007BA1C) --------------------------------------------------------
int __fastcall sub_7BA1C(int a1)
{
  int v1; // r4
  int v2; // r0

  v1 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  Curl_safefree(*(_DWORD *)(v1 + 4));
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 != -1 )
    close(v2);
  return 0;
}

//----- (0007BA3C) --------------------------------------------------------
signed int __fastcall sub_7BA3C(int *a1, _BYTE *a2)
{
  int v2; // r7
  int v3; // r8
  _BYTE *v4; // r9
  int v5; // r6
  const char *v6; // r5
  const char **v7; // r4
  int v8; // r0
  int v9; // r0
  int v10; // r0
  signed int result; // r0

  v2 = *a1;
  v3 = (int)a1;
  v4 = a2;
  v5 = *a1 + 34048;
  v6 = (const char *)curl_easy_unescape(*a1, *(char **)(*a1 + 34180), 0, 0);
  if ( !v6 )
    return 27;
  Curl_reset_reqproto(v3);
  v7 = *(const char ***)(v5 + 152);
  if ( v7 )
  {
    Curl_safefree((int)v7[1]);
    v9 = (int)v7[2];
    if ( v9 != -1 )
      close(v9);
    *v7 = 0;
    v7[1] = 0;
    v7[2] = (const char *)-1;
  }
  else
  {
    v8 = Curl_ccalloc(12, 1);
    v7 = (const char **)v8;
    if ( !v8 )
    {
      Curl_cfree(v6);
      return 27;
    }
    *(_DWORD *)(v5 + 152) = v8;
  }
  v10 = open(v6, 0);
  *v7 = v6;
  v7[1] = v6;
  v7[2] = (const char *)v10;
  if ( *(_BYTE *)(v2 + 664) || v10 != -1 )
  {
    result = 0;
    *v4 = 1;
  }
  else
  {
    Curl_failf(v2, "Couldn't open file %s", *(_DWORD *)(v5 + 132));
    sub_7BA1C(v3);
    result = 37;
  }
  return result;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007BB00) --------------------------------------------------------
signed int __fastcall sub_7BB00(int *a1, _BYTE *a2)
{
  int v2; // r8
  _BYTE *v3; // r5
  int *v4; // r6
  int v5; // r1
  int v6; // r2
  signed int v7; // r5
  int v8; // r7
  const char **v9; // r4
  char *v10; // r5
  const char *v11; // r0
  const char *v12; // r1
  int v13; // r0
  int v14; // r0
  char *v15; // r1
  int v16; // r1
  FILE *v17; // r9
  signed int result; // r0
  __int64 v19; // r2
  bool v20; // zf
  signed int v21; // r1
  signed __int64 v22; // r4
  char *v23; // r12
  const void *v24; // r0
  __int64 v25; // r0
  signed int v26; // ST1C_4
  signed int v27; // r9
  struct tm *v28; // r0
  int v29; // r4
  int v30; // r4
  signed int v31; // r4
  int v32; // r1
  int v33; // r4
  const char *v34; // r0
  __int64 v35; // r10
  int v36; // r3
  __int64 v37; // r2
  bool v38; // zf
  signed __int64 v39; // r2
  __int64 v40; // r2
  __int64 v41; // r4
  __int64 v42; // r2
  int v43; // r1
  __int64 v44; // r4
  __int64 v45; // r10
  __int64 v46; // r10
  int v47; // r1
  signed int v48; // r9
  size_t v49; // r2
  int v50; // r3
  char *v51; // [sp+1Ch] [bp-E4h]
  __int64 v52; // [sp+20h] [bp-E0h]
  __int64 v53; // [sp+20h] [bp-E0h]
  int fd; // [sp+2Ch] [bp-D4h]
  char *endptr; // [sp+38h] [bp-C8h]
  __time_t v56; // [sp+3Ch] [bp-C4h]
  int v57; // [sp+40h] [bp-C0h]
  struct tm tp; // [sp+44h] [bp-BCh]
  char v59; // [sp+70h] [bp-90h]
  __int64 v60; // [sp+A0h] [bp-60h]
  char *v61; // [sp+C0h] [bp-40h]

  v2 = *a1;
  v3 = a2;
  v4 = a1;
  curlx_tvnow(&v56);
  *v3 = 1;
  Curl_initinfo(v2);
  Curl_pgrsStartNow(v2, v5, v6);
  v7 = *(unsigned __int8 *)(v2 + 664);
  v8 = *v4;
  if ( !*(_BYTE *)(v2 + 664) )
  {
    fd = *(_DWORD *)(*(_DWORD *)(v8 + 34200) + 8);
    if ( fstat(fd, (struct stat *)&v59) == -1 )
    {
      v27 = v7;
      v53 = 0LL;
    }
    else
    {
      v27 = 1;
      v53 = v60;
      *(_DWORD *)(v2 + 34220) = v61;
    }
    if ( *(_BYTE *)(v2 + 662) && *(_BYTE *)(v2 + 659) && v27 )
    {
      curl_msnprintf(v2 + 1172, 16385, "Content-Length: %lld\r\n");
      result = Curl_client_write(v4, 3, (const char *)(v2 + 1172), 0);
      if ( !result )
      {
        result = Curl_client_write(v4, 3, "Accept-ranges: bytes\r\n", 0);
        if ( !result )
        {
          endptr = v61;
          v28 = gmtime_r((const time_t *)&endptr, &tp);
          v29 = v28->tm_wday;
          if ( v29 )
            v30 = v29 - 1;
          else
            v30 = 6;
          curl_msnprintf(
            v2 + 1172,
            0x3FFF,
            "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n",
            Curl_wkday[v30],
            v28->tm_mday,
            Curl_month[v28->tm_mon],
            v28->tm_year + 1900,
            v28->tm_hour,
            v28->tm_min,
            v28->tm_sec);
          v31 = Curl_client_write(v4, 3, (const char *)(v2 + 1172), 0);
          Curl_pgrsSetDownloadSize(v2, v32, v53);
          result = v31;
        }
      }
      return result;
    }
    v33 = *v4;
    if ( !*(_BYTE *)(*v4 + 34184) || (v34 = *(const char **)(*v4 + 34188)) == 0 )
    {
      *(_QWORD *)(v33 + 40) = -1LL;
LABEL_73:
      v40 = *(_QWORD *)(v2 + 34192);
      if ( (signed int)(*(_QWORD *)(v2 + 34192) >> 32) < 0 )
      {
        if ( !v27 )
        {
          Curl_failf(v2, "Can't get the size of file.");
          return 26;
        }
        HIDWORD(v41) = HIDWORD(v60);
        LODWORD(v41) = v60 + v40;
        *(_QWORD *)(v2 + 34192) = v41 + v40;
      }
      v42 = *(_QWORD *)(v2 + 34192);
      v43 = (unsigned __int64)(v53 - v42) >> 32;
      if ( v53 < v42 )
      {
        Curl_failf(v2, "failed to resume file:// transfer");
        return 36;
      }
      v44 = *(_QWORD *)(v2 + 40);
      if ( v44 >= 1 )
      {
        if ( !v27 )
          goto LABEL_84;
      }
      else
      {
        v44 = v53 - v42;
        if ( !v27 )
          goto LABEL_84;
        v43 = v44 | HIDWORD(v44);
        if ( v53 == v42 )
          return 0;
      }
      Curl_pgrsSetDownloadSize(v2, v43, v44);
LABEL_84:
      v45 = *(_QWORD *)(v2 + 34192);
      if ( !v45 || v45 == lseek(fd, v45, 0) )
      {
        Curl_pgrsTime(COERCE_DOUBLE(__PAIR__(5, v2)));
        v46 = 0LL;
        while ( 1 )
        {
          v49 = 0x3FFF;
          if ( v44 <= 16382 )
            v49 = v44;
          v50 = read(fd, (void *)(v2 + 1172), v49);
          if ( v50 <= 0 || (*(_BYTE *)(v2 + 1172 + v50) = 0, !v44) )
          {
            v48 = 0;
            goto LABEL_97;
          }
          v46 += v50;
          v44 -= v50;
          result = Curl_client_write(v4, 1, (const char *)(v2 + 1172), v50);
          if ( result )
            return result;
          Curl_pgrsSetDownloadCounter(v2, v47, v46);
          if ( Curl_pgrsUpdate(v4) )
            break;
          v48 = Curl_speedcheck(v2, v56, v57);
          if ( v48 )
            goto LABEL_97;
        }
        v48 = 42;
LABEL_97:
        if ( Curl_pgrsUpdate(v4) )
          result = 42;
        else
          result = v48;
        return result;
      }
      return 36;
    }
    v35 = strtoll(v34, &endptr, 0);
    while ( endptr )
    {
      v36 = (unsigned __int8)*endptr;
      if ( !*endptr || !(*(_BYTE *)(ctype_ + v36 + 1) & 8) && v36 != 45 )
        break;
      ++endptr;
    }
    v37 = strtoll(endptr, (char **)&tp, 0);
    if ( endptr == (char *)tp.tm_sec )
      goto LABEL_107;
    v38 = HIDWORD(v37) == -1;
    if ( HIDWORD(v37) == -1 )
      v38 = (_DWORD)v37 == -1;
    if ( v38 )
    {
LABEL_107:
      if ( v35 >= 0 )
      {
LABEL_70:
        *(_QWORD *)(v33 + 34192) = v35;
        goto LABEL_73;
      }
    }
    else if ( v35 >= 0 )
    {
      v39 = v37 - v35 + 1;
      goto LABEL_69;
    }
    LODWORD(v39) = -(signed int)v35;
    HIDWORD(v39) = HIDWORD(v35) - (2 * HIDWORD(v35) + ((unsigned int)v35 > 0));
LABEL_69:
    *(_QWORD *)(v33 + 40) = v39;
    goto LABEL_70;
  }
  v9 = *(const char ***)(v8 + 34200);
  v10 = strchr(*v9, 47);
  curlx_tvnow(&tp.tm_sec);
  v4[101] = *(_DWORD *)(v8 + 368);
  v4[102] = *(_DWORD *)(v8 + 300);
  *(_DWORD *)(*v4 + 264) = v8 + 1172;
  if ( !v10 || !v10[1] )
    return 37;
  if ( *(_QWORD *)(v8 + 34192) )
  {
    v11 = *v9;
    v12 = "ab";
  }
  else
  {
    v13 = open(*v9, 577, *(_DWORD *)(*v4 + 708));
    if ( v13 < 0 )
    {
      v14 = v8;
      v15 = "Can't open %s for writing";
LABEL_11:
      Curl_failf(v14, v15, *v9);
      return 23;
    }
    close(v13);
    v11 = *v9;
    v12 = "wb";
  }
  v17 = fopen(v11, v12);
  if ( !v17 )
  {
    v14 = v8;
    v15 = "Can't open %s for writing";
    goto LABEL_11;
  }
  v19 = *(_QWORD *)(v8 + 440);
  v20 = HIDWORD(v19) == -1;
  if ( HIDWORD(v19) == -1 )
    v20 = (_DWORD)v19 == -1;
  if ( !v20 )
    Curl_pgrsSetUploadSize(v8, v16, v19);
  if ( (signed int)(*(_QWORD *)(v8 + 34192) >> 32) < 0 )
  {
    if ( fstat(*((signed __int16 *)v17 + 7), (struct stat *)&v59) )
    {
      fclose(v17);
      v14 = v8;
      v15 = "Can't get the size of %s";
      goto LABEL_11;
    }
    *(_QWORD *)(v8 + 34192) = v60;
  }
  v52 = 0LL;
  do
  {
    v21 = Curl_fillreadbuffer((int)v4, 0x4000u, (size_t *)&endptr);
    if ( v21 )
      break;
    if ( (signed int)endptr <= 0 )
    {
      if ( Curl_pgrsUpdate(v4) )
        v21 = 42;
      else
        v21 = 0;
      break;
    }
    v22 = *(_QWORD *)(v8 + 34192);
    v23 = endptr;
    if ( v22 )
    {
      if ( v22 < (signed int)endptr )
      {
        v24 = (const void *)(v8 + 1172 + v22);
        v23 = &endptr[-v22];
        *(_DWORD *)(v8 + 34192) = 0;
        *(_DWORD *)(v8 + 34196) = 0;
      }
      else
      {
        v24 = (const void *)(v8 + 1172);
        *(_QWORD *)(v8 + 34192) = v22 - (signed int)endptr;
        v23 = 0;
      }
    }
    else
    {
      v24 = (const void *)(v8 + 1172);
    }
    v51 = v23;
    if ( (char *)fwrite(v24, 1u, (size_t)v23, v17) != v23 )
    {
      v21 = 55;
      break;
    }
    HIDWORD(v25) = HIDWORD(v52);
    LODWORD(v25) = &v51[v52];
    v52 = (__int64)&v51[v25];
    Curl_pgrsSetUploadCounter(v8, SHIDWORD(v52), v52);
    if ( Curl_pgrsUpdate(v4) )
    {
      v21 = 42;
      break;
    }
    v21 = Curl_speedcheck(v8, tp.tm_sec, tp.tm_min);
  }
  while ( !v21 );
  v26 = v21;
  fclose(v17);
  return v26;
}
// EF850: using guessed type char *Curl_month[20];
// EF880: using guessed type char *Curl_wkday[8];

//----- (0007C01C) --------------------------------------------------------
char *__fastcall sub_7C01C(_BYTE *a1, int a2)
{
  int v2; // r5
  _BYTE *v3; // r6
  int v4; // r9
  int v5; // r4
  int v6; // r8
  char *result; // r0

  v2 = 0;
  v3 = a1;
  v4 = a2;
  v5 = 0;
  do
  {
    v6 = *(unsigned __int8 *)(v4 + v2);
    result = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", v6);
    if ( result )
    {
      v5 = &result[64 * v5] - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    }
    else if ( v6 == 61 )
    {
      v5 <<= 6;
    }
    ++v2;
  }
  while ( v2 != 4 );
  v3[2] = v5;
  v3[1] = BYTE1(v5);
  *v3 = BYTE2(v5);
  return result;
}

//----- (0007C064) --------------------------------------------------------
int __fastcall Curl_base64_decode(int a1, _DWORD *a2, int a3)
{
  int v3; // r6
  int *v4; // r4
  int v5; // r3
  signed int v6; // r5
  int v7; // r7
  int result; // r0
  int v9; // r9
  int v10; // r0
  int v11; // r8
  int v12; // r11
  int v13; // r4
  int v14; // r1
  int v15; // r7
  _BYTE *v16; // r0
  int v17; // r5
  int i; // r3
  _DWORD *v19; // [sp+4h] [bp-2Ch]
  int v20; // [sp+8h] [bp-28h]

  v19 = a2;
  v20 = a3;
  v3 = a1;
  v4 = a2;
  v5 = 0;
  *a2 = 0;
  while ( 1 )
  {
    v6 = *(unsigned __int8 *)(a1 + v5);
    if ( v6 == 61 )
      break;
    if ( !*(_BYTE *)(a1 + v5) )
      goto LABEL_8;
    ++v5;
  }
  if ( *(_BYTE *)(a1 + v5 + 1) == 61 )
    v6 = 2;
  else
    v6 = 1;
LABEL_8:
  v7 = (v5 + v6) >> 2;
  if ( v7 <= 0 )
    return 0;
  v9 = 3 * v7 - v6;
  v10 = Curl_cmalloc(v9 + 4);
  v11 = v10;
  if ( !v10 )
    return 0;
  v12 = v7 - 1;
  *v4 = v10;
  v13 = 0;
  while ( 1 )
  {
    v14 = v3 + 4 * v13;
    v15 = v11 + 3 * v13;
    if ( v13 >= v12 )
      break;
    v16 = (_BYTE *)(v11 + 3 * v13++);
    sub_7C01C(v16, v14);
  }
  v17 = 3 - v6;
  sub_7C01C(&v19, v14);
  for ( i = 0; i < v17; ++i )
    *(_BYTE *)(v15 + i) = *((_BYTE *)&v19 + i);
  result = v9;
  *(_BYTE *)(v15 + i) = 0;
  return result;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0007C0FC) --------------------------------------------------------
size_t __fastcall Curl_base64_encode(int a1, const char *a2, size_t a3, const char **a4)
{
  const char **v4; // r8
  const char *v5; // r7
  size_t v6; // r4
  size_t result; // r0
  const char *v8; // r6
  _BYTE *v9; // r5
  int v10; // r2
  int v11; // r3
  char v12; // t1
  unsigned int v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // lr
  unsigned __int8 v16; // [sp+14h] [bp-2Ch]
  unsigned __int8 v17; // [sp+15h] [bp-2Bh]
  unsigned __int8 v18; // [sp+16h] [bp-2Ah]

  v4 = a4;
  v5 = a2;
  *a4 = 0;
  v6 = a3;
  if ( !a3 )
    v6 = strlen(a2);
  result = Curl_cmalloc(4 * v6 / 3 + 4);
  v8 = (const char *)result;
  if ( result )
  {
    v9 = (_BYTE *)result;
    while ( v6 )
    {
      v10 = 0;
      v11 = 0;
      do
      {
        if ( v6 )
        {
          v12 = *v5++;
          ++v10;
          --v6;
          *(&v16 + v11) = v12;
        }
        else
        {
          *(&v16 + v11) = 0;
        }
        ++v11;
      }
      while ( v11 != 3 );
      v13 = (unsigned int)v16 >> 2;
      v14 = ((unsigned int)v17 >> 4) | 16 * (v16 & 3);
      v15 = ((unsigned int)v18 >> 6) | 4 * (v17 & 0xF);
      if ( v10 == 1 )
      {
        curl_msnprintf(
          (int)v9,
          5,
          "%c%c==",
          (unsigned __int8)aAbcdefghijklmn_0[v13],
          (unsigned __int8)aAbcdefghijklmn_0[v14]);
      }
      else if ( v10 == 2 )
      {
        curl_msnprintf(
          (int)v9,
          5,
          "%c%c%c=",
          (unsigned __int8)aAbcdefghijklmn_0[v13],
          (unsigned __int8)aAbcdefghijklmn_0[v14],
          (unsigned __int8)aAbcdefghijklmn_0[v15]);
      }
      else
      {
        curl_msnprintf(
          (int)v9,
          5,
          "%c%c%c%c",
          (unsigned __int8)aAbcdefghijklmn_0[v13],
          (unsigned __int8)aAbcdefghijklmn_0[v14],
          (unsigned __int8)aAbcdefghijklmn_0[v15],
          (unsigned __int8)aAbcdefghijklmn_0[v18 & 0x3F]);
      }
      v9 += 4;
    }
    *v9 = 0;
    *v4 = v8;
    result = j_strlen(v8);
  }
  return result;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0007C224) --------------------------------------------------------
void __fastcall sub_7C224(_DWORD *a1)
{
  _DWORD *v1; // r4
  int i; // r5
  void *v3; // r0
  void *v4; // r0

  v1 = a1;
  if ( a1[1] )
  {
    for ( i = 0; i < v1[2]; ++i )
    {
      v3 = *(void **)(v1[1] + 4 * i);
      if ( v3 )
      {
        ((void (__cdecl *)(void *))Curl_cfree)(v3);
        *(_DWORD *)(v1[1] + 4 * i) = 0;
      }
    }
    ((void (__cdecl *)(void *))Curl_cfree)((void *)v1[1]);
    v1[1] = 0;
    v1[2] = 0;
  }
  v4 = (void *)v1[4];
  if ( v4 )
  {
    ((void (__cdecl *)(void *))Curl_cfree)(v4);
    v1[4] = 0;
  }
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007C280) --------------------------------------------------------
int __fastcall sub_7C280(int *a1)
{
  int *v1; // r4
  int v2; // r6
  int *v3; // r5
  __time_t *v4; // r0
  int *v5; // r4
  int v6; // r0
  int v7; // r1
  int v9; // [sp+0h] [bp-28h]
  __time_t v10; // [sp+8h] [bp-20h]
  int v11; // [sp+Ch] [bp-1Ch]
  char v12; // [sp+10h] [bp-18h]

  v1 = a1;
  v2 = *(_DWORD *)(*a1 + 432);
  if ( v2 )
  {
    v3 = &v9;
    v4 = &v9;
LABEL_6:
    curlx_tvnow(v4);
    v6 = *v3;
    v7 = v3[1];
    v5 = v1 + 206;
    return v2 - curlx_tvdiff(v6, v7, *v5, v5[1]);
  }
  v2 = *(_DWORD *)(*a1 + 424);
  if ( !v2 )
  {
    v3 = (int *)&v12;
    v2 = a1[193];
    v4 = (__time_t *)&v12;
    goto LABEL_6;
  }
  v5 = a1 + 49;
  curlx_tvnow(&v10);
  v6 = v10;
  v7 = v11;
  return v2 - curlx_tvdiff(v6, v7, *v5, v5[1]);
}

//----- (0007C2CC) --------------------------------------------------------
signed int __fastcall sub_7C2CC(int a1, int *a2, int *a3, _DWORD *a4)
{
  int v4; // r7
  int v5; // r4
  signed int v6; // r8
  signed int v7; // r10
  char *v8; // r6
  int v9; // r5
  unsigned int v10; // r3
  const void *v11; // r1
  int v12; // r0
  int v13; // r0
  int v14; // r0
  signed int result; // r0
  int v16; // r3
  char *v17; // r11
  int v18; // r3
  unsigned __int8 *v19; // r3
  int v20; // r2
  char v21; // t1
  int v22; // r3
  int v23; // r3
  unsigned __int8 *v24; // r3
  void *v25; // r0
  unsigned __int8 *v26; // [sp+8h] [bp-1Ch]
  int v27; // [sp+Ch] [bp-18h]
  int *v28; // [sp+10h] [bp-14h]
  _DWORD *v29; // [sp+14h] [bp-10h]
  int v30; // [sp+18h] [bp-Ch]
  int v31; // [sp+24h] [bp+0h]

  v4 = *a2;
  v5 = (int)a2;
  v29 = a4;
  *a3 = 0;
  v6 = 0;
  v28 = a3;
  v7 = 1;
  *a4 = 0;
  v8 = (char *)(a2[197] + v4 + 1172);
  v9 = (int)&v8[-a2[198]];
  v30 = a1;
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_2:
      v10 = *(_DWORD *)(v5 + 788);
      if ( v10 > 0x3FFF || !v7 )
      {
        if ( v6 )
LABEL_12:
          v14 = 0;
        else
          v14 = atoi((const char *)(v4 + 1172));
        *v28 = v14;
        *(_DWORD *)(*(_DWORD *)v5 + 34208) = v14;
        *(_BYTE *)(v5 + 796) = 0;
        return v6;
      }
      if ( v6 )
        goto LABEL_12;
      v11 = *(const void **)(v5 + 756);
      if ( v11 )
      {
        memcpy(v8, v11, *(_DWORD *)(v5 + 760));
        v12 = *(_DWORD *)(v5 + 756);
        v31 = *(_DWORD *)(v5 + 760);
        Curl_cfree(v12);
        *(_DWORD *)(v5 + 756) = 0;
        *(_QWORD *)(v5 + 760) = 0LL;
        break;
      }
      v13 = Curl_read(v5, v30, v8, 0x4000 - v10, (int)&v31);
      if ( v13 < 0 )
        return v6;
      if ( !v13 )
        break;
      v7 = 0;
    }
    v16 = v31;
    if ( v31 > 0 )
      break;
    v6 = 56;
    v7 = 0;
    Curl_failf(v4, "FTP response reading failed");
  }
  v17 = v8;
  v26 = (unsigned __int8 *)v8;
  *(_DWORD *)(v4 + 72) += v31;
  *(_DWORD *)(v5 + 788) += v16;
  while ( 1 )
  {
    v8 = v17;
    v27 = v17 - (char *)v26;
    if ( v17 - (char *)v26 >= v31 )
      break;
    v18 = (unsigned __int8)*v17;
    ++v9;
    ++v17;
    if ( v18 == 10 )
    {
      if ( *(_BYTE *)(v4 + 672) )
        Curl_debug(v4, 1u, *(const void **)(v5 + 792), v9, v5);
      result = Curl_client_write((int *)v5, 2, *(const char **)(v5 + 792), v9);
      if ( result )
        return result;
      if ( v9 > 3 )
      {
        v19 = *(unsigned __int8 **)(v5 + 792);
        if ( (unsigned int)*v19 - 48 <= 9
          && (unsigned int)v19[1] - 48 <= 9
          && (unsigned int)v19[2] - 48 <= 9
          && v19[3] == 32 )
        {
          v20 = v4 + 1171;
          while ( v19 < (unsigned __int8 *)v8 )
          {
            v21 = *v19++;
            *(_BYTE *)(v20++ + 1) = v21;
          }
          *v19 = 0;
          v22 = *(_DWORD *)(v5 + 788);
          *(_DWORD *)(v5 + 792) = v8 + 1;
          *v29 = v22;
          v23 = v31;
          *(_DWORD *)(v5 + 788) = 0;
          if ( v27 + 1 == v23 )
          {
            v7 = 0;
LABEL_46:
            v9 = 0;
            *(_DWORD *)(v5 + 792) = v4 + 1172;
            *(_DWORD *)(v5 + 788) = 0;
            v8 = (char *)(v4 + 1172);
            goto LABEL_2;
          }
          v9 = v23 - (v27 + 1);
          v7 = 0;
          goto LABEL_43;
        }
      }
      *(_DWORD *)(v5 + 792) = v17;
      v9 = 0;
    }
  }
  if ( v9 == v31 && v9 > 0x2000 )
  {
    Curl_infof(v4, "Excessive FTP response line length received, %zd bytes. Stripping\n", v9);
    v24 = *(unsigned __int8 **)(v5 + 792);
    if ( (unsigned int)*v24 - 48 > 9 || (unsigned int)v24[1] - 48 > 9 || (unsigned int)v24[2] - 48 > 9 )
      goto LABEL_46;
    v9 = 4;
    goto LABEL_44;
  }
  if ( *(_DWORD *)(v5 + 788) <= 0x2000u )
    goto LABEL_2;
LABEL_43:
  if ( !v9 )
    goto LABEL_46;
LABEL_44:
  *(_QWORD *)(v5 + 760) = v9;
  v25 = (void *)Curl_cmalloc(v9);
  *(_DWORD *)(v5 + 756) = v25;
  if ( v25 )
  {
    memcpy(v25, *(const void **)(v5 + 792), *(_DWORD *)(v5 + 760));
    goto LABEL_46;
  }
  return 27;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0007C508) --------------------------------------------------------
bool __fastcall sub_7C508(const char *a1)
{
  const char *v1; // r4
  _BOOL4 result; // r0

  v1 = a1;
  if ( strchr(a1, 13) )
    result = 1;
  else
    result = strchr(v1, 10) != 0;
  return result;
}

//----- (0007C528) --------------------------------------------------------
signed int __fastcall sub_7C528(int *a1)
{
  int *v1; // r4
  int v2; // r5
  int v3; // r6
  _DWORD *v4; // r3
  const char *v5; // r0
  const char *v6; // r4

  v1 = a1;
  v2 = *a1;
  v3 = *a1 + 34048;
  v4 = *(_DWORD **)(*a1 + 34200);
  if ( !v4 )
  {
    v4 = (_DWORD *)Curl_ccalloc(24, 1);
    *(_DWORD *)(v3 + 152) = v4;
    if ( !v4 )
      return 27;
  }
  *v4 = v2 + 56;
  v5 = (const char *)v1[43];
  v4[1] = v5;
  v6 = (const char *)v1[44];
  v4[2] = v6;
  if ( sub_7C508(v5) )
    return 3;
  if ( sub_7C508(v6) )
    return 3;
  return 0;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (0007C580) --------------------------------------------------------
signed int __fastcall sub_7C580(int *a1)
{
  int *v1; // r8
  int v2; // r4
  int v3; // r5
  int v4; // r2
  signed int v6; // r0
  int v7; // r2
  int v8; // r0
  char *v9; // r1
  signed int v10; // r7
  int v11; // [sp+0h] [bp-38h]
  struct sockaddr addr; // [sp+4h] [bp-34h]

  v1 = a1;
  v2 = *a1;
  v3 = a1[54];
  v4 = Curl_timeleft((int)a1, 0, 1);
  if ( v4 < 0 )
  {
    Curl_failf(v2, "Timed out before server could connect to us", v4);
    return 28;
  }
  v6 = Curl_socket_ready(v3, -1, v4);
  v7 = v6 + 1;
  if ( v6 == -1 )
  {
    v8 = v2;
    v9 = "Error while waiting for server connect";
    goto LABEL_11;
  }
  if ( !v6 )
  {
    v8 = v2;
    v9 = "Timeout while waiting for server connect";
LABEL_11:
    Curl_failf(v8, v9, v7);
    return 30;
  }
  v11 = 16;
  if ( getsockname(v3, &addr, (socklen_t *)&v11) )
  {
    v10 = -1;
  }
  else
  {
    v11 = 16;
    v10 = accept(v3, &addr, (socklen_t *)&v11);
  }
  close(v3);
  v8 = v2;
  if ( v10 == -1 )
  {
    v9 = "Error accept()ing server connect";
    goto LABEL_11;
  }
  Curl_infof(v2, "Connection accepted from server\n");
  v1[54] = v10;
  curlx_nonblock(v10);
  return 0;
}

//----- (0007C658) --------------------------------------------------------
char *__fastcall sub_7C658(int a1)
{
  int v1; // r5
  int v2; // r4
  char *result; // r0
  const char *v4; // r0
  signed int v5; // r0

  v1 = a1;
  v2 = *(_DWORD *)a1;
  if ( *(_BYTE *)(a1 + 299) && !*(_BYTE *)(v2 + 650) )
  {
    if ( *(char ***)(a1 + 320) != &Curl_handler_ftp )
    {
      Curl_failf(*(_DWORD *)a1, "FTPS not supported!");
      return (_BYTE *)(&dword_0 + 1);
    }
    *(_BYTE *)(a1 + 296) = *(_BYTE *)(v2 + 650);
    *(_DWORD *)(a1 + 320) = &Curl_handler_ftp_proxy;
  }
  v4 = (const char *)(*(_DWORD *)(v2 + 34180) + 1);
  *(_DWORD *)(v2 + 34180) = v4;
  result = strstr(v4, ";type=");
  if ( result || (result = strstr(*(const char **)(v1 + 132), ";type=")) != 0 )
  {
    *result = 0;
    v5 = Curl_raw_toupper((unsigned __int8)result[6]);
    if ( v5 == 65 )
    {
      *(_BYTE *)(v2 + 651) = 1;
    }
    else if ( v5 == 68 )
    {
      *(_BYTE *)(v2 + 653) = 1;
    }
    else
    {
      *(_BYTE *)(v2 + 651) = 0;
    }
    result = 0;
  }
  return result;
}
// 0: using guessed type int dword_0;
// EF90C: using guessed type char *Curl_handler_ftp;
// F04B4: using guessed type char *Curl_handler_ftp_proxy;

//----- (0007C6F8) --------------------------------------------------------
signed int __fastcall sub_7C6F8(int a1, _DWORD *a2, int a3)
{
  signed int result; // r0

  if ( !a3 )
    return 0;
  *a2 = *(_DWORD *)(a1 + 212);
  if ( *(_DWORD *)(a1 + 816) )
    result = 0x10000;
  else
    result = 1;
  return result;
}

//----- (0007C714) --------------------------------------------------------
signed int __fastcall Curl_GetFTPResponse(_DWORD *a1, int *a2, int *a3)
{
  _DWORD *v3; // r9
  int *v4; // r4
  int *v5; // r5
  int v6; // r8
  signed int v7; // r6
  int v8; // r11
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  signed int v13; // r2
  signed int result; // r0
  signed int v15; // r0
  int v16; // r1
  int v17; // r2
  _DWORD *v18; // r0
  int v19; // [sp+Ch] [bp-Ch]
  int v20; // [sp+10h] [bp-8h]
  int v21; // [sp+14h] [bp-4h]
  int v22; // [sp+18h] [bp+0h]
  int v23; // [sp+1Ch] [bp+4h]
  __time_t v24; // [sp+20h] [bp+8h]
  int v25; // [sp+24h] [bp+Ch]
  __time_t v26; // [sp+28h] [bp+10h]
  int v27; // [sp+2Ch] [bp+14h]
  __time_t v28; // [sp+30h] [bp+18h]
  int v29; // [sp+34h] [bp+1Ch]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v19 = a2[53];
  v6 = *a2;
  curlx_tvnow(&v22);
  v21 = 0;
  if ( v5 )
    *v5 = 0;
  else
    v5 = &v21;
  v7 = 0;
  *v3 = 0;
  while ( !*v5 )
  {
    v8 = *(_DWORD *)(v6 + 432);
    if ( v8 )
    {
      curlx_tvnow(&v24);
      v9 = v24;
      v10 = v25;
    }
    else
    {
      v8 = *(_DWORD *)(v6 + 424);
      if ( v8 )
      {
        curlx_tvnow(&v26);
        v9 = v26;
        v10 = v27;
        v11 = v4[49];
        v12 = v4[50];
        goto LABEL_12;
      }
      v8 = v4[193];
      curlx_tvnow(&v28);
      v9 = v28;
      v10 = v29;
    }
    v11 = v22;
    v12 = v23;
LABEL_12:
    v13 = v8 - curlx_tvdiff(v9, v10, v11, v12);
    if ( v13 <= 0 )
    {
      Curl_failf(v6, "FTP response timeout");
      return 28;
    }
    if ( v13 >= 1000 )
      v13 = 1000;
    if ( v4[189] && v7 <= 1 )
      goto LABEL_35;
    v15 = Curl_socket_ready(v19, -1, v13);
    if ( v15 == -1 )
    {
      v18 = (_DWORD *)_errno(-1, v16, v17);
      Curl_failf(v6, "FTP response aborted due to select/poll error: %d", *v18);
      return 56;
    }
    if ( v15 )
    {
LABEL_35:
      result = sub_7C2CC(v19, v4, v5, &v20);
      if ( result )
        goto LABEL_32;
      if ( v20 )
      {
        v7 = 0;
      }
      else if ( v4[189] )
      {
        ++v7;
      }
      else
      {
        v7 = v20;
      }
      *v3 += v20;
    }
    else if ( Curl_pgrsUpdate(v4) )
    {
      return 42;
    }
  }
  result = 0;
LABEL_32:
  *((_BYTE *)v4 + 796) = 0;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0007C844) --------------------------------------------------------
signed int Curl_nbftpsendf(int *a1, char *a2, ...)
{
  int v2; // r4
  int v3; // r9
  size_t v4; // r0
  int v5; // r3
  size_t v6; // r10
  signed int v7; // r8
  size_t v8; // r6
  char *v9; // r5
  void *v10; // r0
  _DWORD *v11; // r4
  int v12; // r1
  __time_t v14; // [sp+8h] [bp-448h]
  int v15; // [sp+Ch] [bp-444h]
  size_t v16; // [sp+14h] [bp-43Ch]
  int **v17; // [sp+18h] [bp-438h]
  char v18[1024]; // [sp+1Ch] [bp-434h]
  va_list varg_r2; // [sp+448h] [bp-8h]

  va_start(varg_r2, a2);
  v2 = (int)a1;
  v3 = *a1;
  va_copy(v17, varg_r2);
  curl_mvsnprintf(v18, 1021, a2, (int)varg_r2);
  strcat(v18, "\r\n");
  v16 = 0;
  v4 = strlen(v18);
  v5 = *(_DWORD *)v2;
  *(_DWORD *)(v2 + 788) = 0;
  *(_DWORD *)(v2 + 792) = v5 + 1172;
  *(_BYTE *)(v2 + 796) = 1;
  v6 = v4;
  v7 = Curl_write((int *)v2, *(_DWORD *)(v2 + 212), v18, v4, (ssize_t *)&v16);
  if ( !v7 )
  {
    if ( *(_BYTE *)(*(_DWORD *)v2 + 672) )
      Curl_debug(*(_DWORD *)v2, 2u, v18, v16, v2);
    if ( v16 == v6 )
    {
      v11 = (_DWORD *)(v2 + 824);
      curlx_tvnow(&v14);
      v12 = v15;
      *v11 = v14;
      v11[1] = v12;
    }
    else
    {
      v8 = v6 - v16;
      v9 = &v18[v16];
      v10 = (void *)Curl_cmalloc(v6 - v16);
      *(_DWORD *)(v2 + 812) = v10;
      if ( v10 )
      {
        memcpy(v10, v9, v8);
        *(_DWORD *)(v2 + 816) = v8;
        *(_DWORD *)(v2 + 820) = v8;
      }
      else
      {
        v7 = 27;
        Curl_failf(v3, "out of memory");
      }
    }
  }
  return v7;
}
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);
// 7C844: using guessed type char var_434[1024];

//----- (0007C950) --------------------------------------------------------
signed int __fastcall sub_7C950(int *a1)
{
  int *v1; // r4
  char *v2; // r2
  signed int result; // r0

  v1 = a1;
  v2 = *(char **)(*(_DWORD *)(*a1 + 34200) + 4);
  if ( !v2 )
    v2 = &byte_E4496;
  result = Curl_nbftpsendf(a1, "USER %s", v2);
  if ( !result )
  {
    v1[208] = 3;
    *(_BYTE *)(*v1 + 34144) = 0;
  }
  return result;
}
// E4496: using guessed type char byte_E4496;

//----- (0007C98C) --------------------------------------------------------
signed int __fastcall sub_7C98C(int *a1)
{
  int *v1; // r4
  signed int result; // r0

  v1 = a1;
  result = Curl_nbftpsendf(a1, "PWD", 0);
  if ( !result )
    v1[208] = 9;
  return result;
}

//----- (0007C9A8) --------------------------------------------------------
signed int __fastcall sub_7C9A8(int a1)
{
  int v1; // r4
  signed int result; // r0

  v1 = a1;
  if ( !*(_BYTE *)(a1 + 220) )
    return sub_7C98C((int *)a1);
  result = Curl_nbftpsendf((int *)a1, "PBSZ %d", 0);
  if ( !result )
    *(_DWORD *)(v1 + 832) = 6;
  return result;
}

//----- (0007C9D4) --------------------------------------------------------
signed int __fastcall sub_7C9D4(int *a1, int a2)
{
  int *v2; // r6
  int v3; // r7
  int v4; // r12
  signed __int64 v5; // r2
  int v6; // r5
  signed int result; // r0
  signed int v8; // r3
  int (__fastcall *v9)(int); // r1
  signed __int64 v10; // r2
  int v11; // r0
  int v12; // r0
  char *v13; // r1
  _QWORD *v14; // r10
  __int64 v15; // r8
  int v16; // ST18_4
  signed __int64 v17; // r0
  signed __int64 v18; // r2
  char *v19; // r1
  signed __int64 v20; // [sp+10h] [bp-38h]
  int v21; // [sp+18h] [bp-30h]

  v2 = a1;
  v3 = *a1;
  v4 = *a1 + 34048;
  v5 = *(_QWORD *)(*a1 + 34192);
  v6 = *(_DWORD *)(*a1 + 34200);
  if ( !v5 )
    goto LABEL_25;
  if ( a2 )
  {
    if ( v5 < 1 )
      goto LABEL_25;
  }
  else if ( v5 < 0 )
  {
    result = Curl_nbftpsendf(a1, "SIZE %s", a1[188]);
    if ( result )
      return result;
    v8 = 23;
    goto LABEL_30;
  }
  *(_BYTE *)(v3 + 652) = 1;
  v9 = (int (__fastcall *)(int))a1[99];
  if ( v9 )
  {
    v21 = v4;
    v11 = v9(a1[100]);
    v4 = v21;
    if ( v11 )
    {
      if ( v11 == 2 )
      {
        v14 = (_QWORD *)(v21 + 144);
        v15 = 0LL;
        while ( 1 )
        {
          v20 = *v14 - v15;
          if ( v20 > 0x4000 )
            v20 = 0x4000LL;
          v16 = v4;
          v17 = (unsigned int)((int (__fastcall *)(int, signed int, _DWORD, int))v2[101])(v3 + 1172, 1, v20, v2[102]);
          v4 = v16;
          v15 += (unsigned int)v17;
          if ( !(_DWORD)v17 || v20 < v17 )
            break;
          if ( v15 >= *v14 )
            goto LABEL_9;
        }
        v12 = v3;
        v13 = "Failed to read data";
      }
      else
      {
        v12 = v3;
        v13 = "Could not seek stream";
      }
      Curl_failf(v12, v13);
      return 31;
    }
  }
LABEL_9:
  v10 = *(_QWORD *)(v3 + 440);
  if ( v10 >= 1 )
  {
    v18 = v10 - *(_QWORD *)(v4 + 144);
    *(_QWORD *)(v3 + 440) = v18;
    if ( v18 < 1 )
    {
      Curl_infof(v3, "File already completely uploaded\n");
      Curl_setup_transfer(v2, -1, -1LL, 0, 0, -1, 0);
      result = 0;
      *(_DWORD *)(v6 + 12) = 2;
      v2[208] = 0;
      return result;
    }
  }
LABEL_25:
  if ( *(_BYTE *)(v3 + 652) )
    v19 = "APPE %s";
  else
    v19 = "STOR %s";
  result = Curl_nbftpsendf(v2, v19, v2[188]);
  if ( !result )
  {
    v8 = 30;
LABEL_30:
    v2[208] = v8;
  }
  return result;
}

//----- (0007CB68) --------------------------------------------------------
signed int __fastcall sub_7CB68(char **a1, int a2)
{
  int v2; // r10
  struct sockaddr *v3; // r9
  char *v4; // r6
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r11
  size_t v8; // r0
  char *v9; // r7
  char *v10; // r0
  const char *v11; // r1
  unsigned int v12; // r8
  size_t v13; // r2
  signed int result; // r0
  char *v15; // r0
  const char *v16; // r11
  char *v17; // r0
  char *v18; // r1
  int v19; // r0
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int *v23; // r1
  int v24; // r0
  int v25; // r1
  int *v26; // r0
  int v27; // r2
  int v28; // r3
  int v29; // r0
  int *v30; // r0
  int v31; // r2
  int v32; // r3
  int v33; // r0
  int v34; // r0
  int v35; // r1
  int v36; // r2
  _DWORD *v37; // r0
  int v38; // r1
  int v39; // r2
  int *v40; // r0
  int v41; // r2
  int v42; // r3
  int v43; // r0
  int v44; // r0
  int v45; // r0
  int v46; // r1
  int v47; // r2
  int *v48; // r0
  int v49; // r2
  int v50; // r3
  int v51; // r0
  char *v52; // r1
  int v53; // r2
  int v54; // r0
  _DWORD *v55; // r0
  int v56; // r1
  int v57; // r2
  _DWORD *v58; // r0
  int v59; // r1
  int v60; // r2
  int *v61; // r0
  int v62; // r2
  int v63; // r3
  int v64; // r0
  int v65; // r0
  int v66; // r1
  int v67; // r2
  int *v68; // r0
  int v69; // r2
  int v70; // r3
  int v71; // r0
  int v72; // r0
  int v73; // r1
  int v74; // r2
  int *v75; // r0
  int v76; // r2
  int v77; // r3
  int v78; // r0
  char *v79; // r1
  _BYTE *v80; // r2
  int v81; // r3
  _BYTE *v82; // r0
  int v83; // r0
  unsigned int v84; // [sp+10h] [bp-9C8h]
  socklen_t len; // [sp+20h] [bp-9B8h]
  char v86; // [sp+24h] [bp-9B4h]
  struct sockaddr addr; // [sp+28h] [bp-9B0h]
  char v88; // [sp+A7h] [bp-931h]
  int v89; // [sp+A8h] [bp-930h]
  int v90; // [sp+ACh] [bp-92Ch]
  char v91; // [sp+1A8h] [bp-830h]
  _BYTE v92[3]; // [sp+1A9h] [bp-82Fh]
  char buf; // [sp+5A8h] [bp-430h]
  int v94; // [sp+9ACh] [bp-2Ch]

  v2 = a2;
  v3 = (struct sockaddr *)&GLOBAL_OFFSET_TABLE_;
  v4 = *a1;
  v5 = (int)a1;
  v89 = 0;
  v6 = (int)&v86;
  memset(&v90, 0, 0xFCu);
  v7 = *((_DWORD *)v4 + 189);
  *(_DWORD *)&v86 = 0;
  if ( !v7 )
  {
    v9 = 0;
LABEL_29:
    v12 = 0;
    v84 = 0;
    goto LABEL_30;
  }
  v8 = strlen((const char *)v7);
  if ( v8 <= 1 )
  {
    v9 = 0;
    goto LABEL_29;
  }
  if ( v8 <= 0xF )
    v8 = 16;
  v9 = (char *)((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(v8 + 1, 1u);
  if ( !v9 )
  {
    result = 27;
    goto LABEL_18;
  }
  if ( *(_BYTE *)v7 != 58 )
  {
    v10 = strchr((const char *)v7, 58);
    v11 = (const char *)v7;
    v12 = (unsigned int)v10;
    if ( !v10 )
    {
      strcpy(v9, (const char *)v7);
      goto LABEL_48;
    }
    v13 = (size_t)&v10[-v7];
    v7 = (unsigned int)v10;
    strncpy(v9, v11, v13);
  }
  do
  {
    v15 = strchr((const char *)v7, 58);
    v16 = v15;
    if ( !v15 )
    {
      v12 = 0;
LABEL_48:
      v84 = v12;
      goto LABEL_23;
    }
    v12 = (unsigned __int16)strtol(v15 + 1, 0, 10);
    v17 = strchr(v16, 45);
    if ( !v17 )
      goto LABEL_48;
    v84 = (unsigned __int16)strtol(v17 + 1, 0, 10);
    if ( v12 > v84 )
    {
      v84 = 0;
      v12 = 0;
    }
LABEL_23:
    if ( *v9 )
    {
      v7 = (unsigned int)&buf;
      if ( Curl_if2ip(*(_DWORD *)(*(_DWORD *)(v5 + 56) + 4), v9, &buf, 0x401u) )
        v18 = &buf;
      else
        v18 = v9;
    }
    else
    {
LABEL_30:
      v7 = (unsigned int)&addr;
      v19 = *(_DWORD *)(v5 + 212);
      len = 128;
      v20 = getsockname(v19, &addr, &len);
      if ( v20 )
      {
        v30 = (int *)_errno(v20, v21, v22);
        v33 = Curl_strerror(v5, *v30, v31, v32);
        Curl_failf((int)v4, "getsockname() failed: %s", v33);
        if ( v9 )
          (**(void (__cdecl ***)(void *))((char *)&v3->sa_family + 0xFFFFFCF0))(v9);
        goto LABEL_46;
      }
      v7 = (unsigned int)&buf;
      inet_ntop(addr.sa_family, &addr.sa_data[2], &buf, 0x401u);
      v18 = &buf;
    }
    if ( Curl_resolv((int *)v5, v18, 0, (const char **)v6) == 1 )
      Curl_wait_for_resolv((int *)v5, (_DWORD *)v6);
    v23 = *(int **)v6;
    if ( *(_DWORD *)v6 )
    {
      v6 = *v23;
      Curl_resolv_unlock((int)v4, (int)v23);
    }
    else
    {
      v6 = 0;
    }
    if ( v9 )
      (**(void (__cdecl ***)(void *))((char *)&v3->sa_family + 0xFFFFFCF0))(v9);
    if ( !v6 )
    {
      Curl_failf((int)v4, "Curl_resolv failed, we can not recover!");
LABEL_46:
      result = 30;
      continue;
    }
    while ( 1 )
    {
      if ( !*(_DWORD *)(v6 + 8) )
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 128);
      v24 = socket(*(_DWORD *)(v6 + 4), *(_DWORD *)(v6 + 8), *(_DWORD *)(v6 + 12));
      v9 = (char *)v24;
      if ( v24 != -1 )
        break;
      v26 = (int *)_errno(-1, v25, 0);
      v6 = *(_DWORD *)(v6 + 28);
      if ( !v6 )
      {
        v29 = Curl_strerror(v5, *v26, v27, v28);
        Curl_failf((int)v4, "socket failure: %s", v29);
        goto LABEL_46;
      }
    }
    v3 = &addr;
    v7 = v12;
    memcpy(&addr, *(const void **)(v6 + 24), *(_DWORD *)(v6 + 16));
    len = *(_DWORD *)(v6 + 16);
    while ( 1 )
    {
      if ( v7 > v84 )
      {
        Curl_failf((int)v4, "bind() failed, we ran out of ports!");
        goto LABEL_71;
      }
      if ( addr.sa_family == 2 )
        *(_WORD *)addr.sa_data = __rev16(v7);
      v34 = bind((int)v9, &addr, len);
      if ( !v34 )
        break;
      v37 = (_DWORD *)_errno(v34, v35, v36);
      if ( *v37 == 99 )
      {
        v40 = (int *)_errno(v37, v38, v39);
        v43 = Curl_strerror(v5, *v40, v41, v42);
        Curl_failf((int)v4, "bind(port=%i) failed: %s", v7, v43);
        v44 = *(_DWORD *)(v5 + 212);
        len = 128;
        v45 = getsockname(v44, &addr, &len);
        if ( v45 )
        {
          v48 = (int *)_errno(v45, v46, v47);
          v51 = Curl_strerror(v5, *v48, v49, v50);
          v52 = "getsockname() failed: %s";
          v53 = v51;
          v54 = (int)v4;
          goto LABEL_70;
        }
        v7 = v12;
      }
      else
      {
        v55 = (_DWORD *)_errno(v37, v38, v39);
        if ( *v55 != 98 )
        {
          v58 = (_DWORD *)_errno(v55, v56, v57);
          if ( *v58 != 13 )
          {
            v61 = (int *)_errno(v58, v59, v60);
            v64 = Curl_strerror(v5, *v61, v62, v63);
            Curl_failf((int)v4, "bind(port=%i) failed: %s", v7, v64);
            goto LABEL_71;
          }
        }
        v7 = (unsigned __int16)(v7 + 1);
      }
    }
    len = 128;
    v65 = getsockname((int)v9, &addr, &len);
    if ( v65 )
    {
      v68 = (int *)_errno(v65, v66, v67);
      v71 = Curl_strerror(v5, *v68, v69, v70);
      v52 = "getsockname() failed: %s";
      v53 = v71;
      v54 = (int)v4;
      goto LABEL_70;
    }
    v72 = listen((int)v9, 1);
    if ( v72 )
    {
      v75 = (int *)_errno(v72, v73, v74);
      v78 = Curl_strerror(v5, *v75, v76, v77);
      v52 = "socket failure: %s";
      v53 = v78;
      v54 = (int)v4;
LABEL_70:
      Curl_failf(v54, v52, v53);
LABEL_71:
      close((int)v9);
      goto LABEL_46;
    }
    Curl_printable_address(v6, (char *)&v89, 0x100u);
    while ( v2 != 2 )
    {
      if ( (*(_BYTE *)(v5 + 313) || v2) && addr.sa_family == 2 )
      {
        v6 = (unsigned __int16)__rev16(*(unsigned __int16 *)addr.sa_data);
        if ( !v2 )
        {
          result = Curl_nbftpsendf((int *)v5, "%s |%d|%s|%d|", "EPRT", 1, &v89, (unsigned __int16)v6);
          goto LABEL_17;
        }
        if ( v2 == 1 )
        {
          v4 = &v91;
          v79 = &v88;
          v80 = v92;
          while ( 1 )
          {
            v81 = (unsigned __int8)v79[1];
            v82 = v80 - 1;
            if ( !v79[1] )
              break;
            *(v80 - 1) = v81 == 46 ? 44 : (_BYTE)v81;
            v82 = v80++;
            if ( v79 == (char *)-2 )
              break;
            ++v79;
          }
          *v82 = 0;
          curl_msnprintf((int)v82, 20, ",%d,%d", (unsigned int)(unsigned __int16)v6 >> 8, (unsigned __int8)v6);
          result = Curl_nbftpsendf((int *)v5, "%s %s", "PORT", &v91);
LABEL_17:
          if ( result )
            goto LABEL_18;
          break;
        }
      }
      ++v2;
    }
    v83 = *(_DWORD *)(v5 + 216);
    *(_DWORD *)(v5 + 800) = v2;
    if ( v83 != -1 )
      close(v83);
    *(_DWORD *)(v5 + 216) = v9;
    *(_BYTE *)(v5 + 305) = 1;
    result = 0;
    *(_DWORD *)(v5 + 832) = 26;
LABEL_18:
    ;
  }
  while ( v94 != _stack_chk_guard );
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);

//----- (0007CFC8) --------------------------------------------------------
int __fastcall sub_7CFC8(int *a1)
{
  int *v1; // r4
  int result; // r0

  v1 = a1;
  if ( *(_DWORD *)(*(_DWORD *)(*a1 + 34200) + 12) != 1 || !a1[188] )
    return sub_7D22C(a1);
  result = Curl_nbftpsendf(a1, "SIZE %s");
  if ( !result )
    v1[208] = 21;
  return result;
}

//----- (0007D004) --------------------------------------------------------
int __fastcall sub_7D004(int *a1)
{
  int v1; // r2
  signed int v2; // r1

  v1 = *a1;
  if ( !*(_BYTE *)(*a1 + 662) || !a1[188] )
    return sub_7CFC8(a1);
  v2 = *(_BYTE *)(v1 + 651) ? 65 : 73;
  if ( *((unsigned __int8 *)a1 + 784) == v2 )
    return sub_7CFC8(a1);
  *(_DWORD *)(*(_DWORD *)(*a1 + 34200) + 12) = 1;
  return sub_7D390((int)a1, *(unsigned __int8 *)(v1 + 651), 17);
}

//----- (0007D050) --------------------------------------------------------
int __fastcall sub_7D050(int *a1)
{
  int *v1; // r4
  int result; // r0

  v1 = a1;
  if ( !*(_BYTE *)(*a1 + 649) && !*(_DWORD *)(*a1 + 520) || !a1[188] )
    return sub_7D004(a1);
  result = Curl_nbftpsendf(a1, "MDTM %s");
  if ( !result )
    v1[208] = 16;
  return result;
}

//----- (0007D08C) --------------------------------------------------------
int __fastcall sub_7D08C(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // r5
  _DWORD *v4; // r2
  int v5; // r4
  int v6; // r0
  _DWORD *v7; // r3
  int v8; // r1
  int i; // r1
  int result; // r0
  int v11; // r3
  int v12; // r2
  int *v13; // r0
  signed int v14; // r3

  v3 = a3;
  v4 = *(_DWORD **)a1;
  v5 = a1;
  v6 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  if ( v3 >= 0xB )
  {
    if ( v3 <= 0xC )
    {
      v7 = (_DWORD *)v4[125];
      goto LABEL_7;
    }
    if ( v3 == 13 )
    {
      v7 = (_DWORD *)v4[124];
      goto LABEL_7;
    }
  }
  v7 = (_DWORD *)v4[123];
LABEL_7:
  if ( a2 )
    v8 = 0;
  else
    v8 = *(_DWORD *)(v5 + 800) + 1;
  *(_DWORD *)(v5 + 800) = v8;
  if ( v7 )
  {
    for ( i = 0; i < *(_DWORD *)(v5 + 800); ++i )
    {
      if ( !v7 )
        goto LABEL_18;
      v7 = (_DWORD *)v7[1];
    }
    if ( v7 )
    {
      result = Curl_nbftpsendf((int *)v5, "%s", *v7);
      if ( !result )
        *(_DWORD *)(v5 + 832) = v3;
      return result;
    }
  }
LABEL_18:
  if ( v3 == 12 )
    return sub_7C9D4((int *)v5, 0);
  if ( v3 == 13 )
    return 0;
  if ( v3 != 11 )
  {
    v11 = *(unsigned __int8 *)(v5 + 777);
    if ( !*(_BYTE *)(v5 + 777) )
    {
      *(_DWORD *)(v5 + 804) = v11;
      *(_DWORD *)(v5 + 808) = (unsigned int)(v4[159] - 2) <= 0;
      if ( *(_BYTE *)(v5 + 297) )
      {
        v12 = *(_DWORD *)(v5 + 736);
        if ( v12 )
        {
          v13 = (int *)v5;
          *(_DWORD *)(v5 + 800) = v11;
LABEL_29:
          result = Curl_nbftpsendf(v13, "CWD %s", v12);
          if ( result )
            return result;
          v14 = 14;
          goto LABEL_36;
        }
      }
      if ( *(_DWORD *)(v5 + 744) )
      {
        *(_DWORD *)(v5 + 800) = 1;
        v13 = (int *)v5;
        v12 = **(_DWORD **)(v5 + 740);
        goto LABEL_29;
      }
    }
    return sub_7D050((int *)v5);
  }
  if ( *(_DWORD *)(v6 + 12) )
  {
    result = 0;
    *(_DWORD *)(v5 + 832) = 0;
    return result;
  }
  result = Curl_nbftpsendf((int *)v5, "SIZE %s", *(_DWORD *)(v5 + 752));
  if ( !result )
  {
    v14 = 22;
LABEL_36:
    *(_DWORD *)(v5 + 832) = v14;
  }
  return result;
}

//----- (0007D1A4) --------------------------------------------------------
int __fastcall sub_7D1A4(int a1)
{
  int *v1; // r4
  int result; // r0
  int v3; // r5
  signed int v4; // r6

  v1 = (int *)a1;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 34200) + 12) )
  {
    *(_DWORD *)(a1 + 832) = 11;
    result = sub_7D08C(a1, 1, 0xBu);
  }
  else if ( *(_BYTE *)(*(_DWORD *)a1 + 654) )
  {
    result = sub_7CB68((char **)a1, 0);
  }
  else
  {
    if ( !*(_BYTE *)(a1 + 312) && *(_BYTE *)(a1 + 303) )
      *(_BYTE *)(a1 + 312) = 1;
    v3 = *(unsigned __int8 *)(a1 + 312) ^ 1;
    v4 = Curl_nbftpsendf((int *)a1, "%s", &aEpsv[5 * v3]);
    if ( !v4 )
    {
      v1[200] = v3;
      v1[208] = 27;
      Curl_infof(*v1, "Connect data stream passively\n");
    }
    result = v4;
  }
  return result;
}

//----- (0007D22C) --------------------------------------------------------
int __fastcall sub_7D22C(int *a1)
{
  int *v1; // r4
  int result; // r0

  v1 = a1;
  if ( !*(_DWORD *)(*(_DWORD *)(*a1 + 34200) + 12) || !a1[188] )
    return sub_7D1A4((int)a1);
  result = Curl_nbftpsendf(a1, "REST %d", 0);
  if ( !result )
    v1[208] = 24;
  return result;
}

//----- (0007D268) --------------------------------------------------------
int __fastcall sub_7D268(int *a1, int a2)
{
  int *v2; // r8
  int v4; // r7
  const char *v5; // r5
  char *v6; // r4
  const char *v7; // r0
  char *v8; // r0
  const char *v9; // r1
  char *v10; // r3
  char *v11; // r2
  void *v12; // r7
  signed int v13; // r5
  unsigned int v14; // r2

  v2 = a1;
  if ( a2 == 17 )
    return sub_7CFC8(a1);
  if ( a2 != 18 )
  {
    if ( a2 == 19 )
    {
      v14 = 11;
    }
    else
    {
      if ( a2 != 20 )
        return 0;
      v14 = 12;
    }
    return sub_7D08C((int)a1, 1, v14);
  }
  v4 = *a1;
  if ( *(_DWORD *)(*a1 + 632) != 2 )
  {
    v6 = 0;
    goto LABEL_15;
  }
  v5 = *(const char **)(v4 + 34180);
  if ( !v5 )
  {
    v6 = 0;
    goto LABEL_15;
  }
  v6 = (char *)*(unsigned __int8 *)v5;
  if ( !*v5 )
  {
LABEL_15:
    v9 = *(const char **)(v4 + 736);
    if ( !v9 )
    {
      if ( *(_BYTE *)(v4 + 653) )
        v9 = "NLST";
      else
        v9 = "LIST";
    }
    if ( v6 )
    {
      v10 = v6;
      v11 = (char *)&unk_E49A3;
    }
    else
    {
      v11 = &byte_E4496;
      v10 = &byte_E4496;
    }
    v12 = curl_maprintf("%s%s%s", v9, v11, v10);
    if ( v12 )
    {
      v13 = Curl_nbftpsendf(v2, "%s", v12);
      if ( !v13 )
      {
        if ( v6 )
          ((void (__cdecl *)(void *))Curl_cfree)(v6);
        ((void (__cdecl *)(void *))Curl_cfree)(v12);
        v2[208] = 28;
      }
      return v13;
    }
    if ( v6 )
      ((void (__cdecl *)(void *))Curl_cfree)(v6);
    return 27;
  }
  if ( !strchr(*(const char **)(v4 + 34180), 47) )
  {
    v6 = 0;
    goto LABEL_15;
  }
  v7 = ((char *(__cdecl *)(const char *))Curl_cstrdup)(v5);
  v6 = (char *)v7;
  if ( v7 )
  {
    if ( v7[strlen(v7) - 1] != 47 )
    {
      v8 = strrchr(v6, 47);
      if ( v8 )
        v8[1] = 0;
    }
    goto LABEL_15;
  }
  return 27;
}
// E4496: using guessed type char byte_E4496;
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007D390) --------------------------------------------------------
int __fastcall sub_7D390(int a1, int a2, int a3)
{
  signed int v3; // r5
  int v4; // r4
  int v5; // r6
  int result; // r0

  if ( a2 )
    v3 = 65;
  else
    v3 = 73;
  v4 = a1;
  v5 = a3;
  if ( *(unsigned __int8 *)(a1 + 784) == v3 )
  {
    *(_DWORD *)(a1 + 832) = a3;
    result = sub_7D268((int *)a1, a3);
  }
  else
  {
    result = Curl_nbftpsendf((int *)a1, "TYPE %c", v3);
    if ( !result )
    {
      *(_DWORD *)(v4 + 832) = v5;
      *(_BYTE *)(v4 + 784) = v3;
    }
  }
  return result;
}

//----- (0007D3D0) --------------------------------------------------------
signed int __fastcall sub_7D3D0(int *a1, int a2)
{
  int v2; // r4
  int v3; // r5
  int v4; // r9
  int v5; // r6
  const char *v6; // r0
  char *v7; // r0
  int v8; // r10
  unsigned int v9; // r8
  int v10; // r3
  char *v11; // r12
  const char *v12; // r8
  const char *v13; // r6
  char *v14; // ST10_4
  int v15; // r0
  signed int result; // r0
  int v17; // r3
  int *v18; // r0
  _BYTE *v19; // r3
  unsigned int v20; // r10
  int v21; // r0
  char *v22; // r2
  unsigned int v23; // r3
  char *v24; // r1
  signed int v25; // r6
  signed int v26; // r0
  int v27; // r5
  int v28; // r7
  signed int v29; // r0
  char v30; // [sp+1Bh] [bp-1h]
  int *v31; // [sp+1Ch] [bp+0h]
  int v32; // [sp+20h] [bp+4h]
  int v33; // [sp+24h] [bp+8h]
  char s; // [sp+28h] [bp+Ch]
  char v35; // [sp+29h] [bp+Dh]
  char v36; // [sp+2Ah] [bp+Eh]
  char v37; // [sp+2Bh] [bp+Fh]
  char v38; // [sp+2Ch] [bp+10h]
  char v39; // [sp+30h] [bp+14h]
  char v40; // [sp+34h] [bp+18h]
  char v41; // [sp+8Ch] [bp+70h]
  int v42; // [sp+BCh] [bp+A0h]

  v2 = (int)a1;
  v3 = *a1;
  v4 = a2;
  v5 = a1[200];
  v6 = (const char *)(*a1 + 1176);
  v31 = 0;
  if ( v5 )
  {
    if ( v5 != 1 || a2 != 227 )
    {
      Curl_failf(v3, "Bad PASV/EPSV response: %03d", a2);
      return 13;
    }
    v11 = &v38;
    v12 = v6;
    do
    {
      v13 = v12++;
      if ( !*v13 )
        break;
      v14 = v11;
      v15 = sscanf(v13, "%d,%d,%d,%d,%d,%d", &s, v11, &v39, &v40, &v32, &v33);
      v11 = v14;
    }
    while ( v15 != 6 );
    if ( !*v13 )
    {
      Curl_failf(v3, "Couldn't interpret the 227-response");
      return 14;
    }
    if ( *(_BYTE *)(v3 + 696) )
    {
      Curl_infof(
        v3,
        "Skips %d.%d.%d.%d for data connection, uses %s instead\n",
        *(_DWORD *)&s,
        *(_DWORD *)&v38,
        *(_DWORD *)&v39,
        *(_DWORD *)&v40,
        v2 + 60);
      if ( *(_BYTE *)(v2 + 308) || (unsigned int)(*(_DWORD *)(v3 + 596) - 4) <= 3 )
        v17 = *(_DWORD *)(v2 + 140);
      else
        v17 = v2 + 60;
      curl_msnprintf((int)&v41, 48, "%s", v17);
    }
    else
    {
      curl_msnprintf((int)&v41, 48, "%d.%d.%d.%d", *(_DWORD *)&s, *(_DWORD *)&v38, *(_DWORD *)&v39, *(_DWORD *)&v40);
    }
    v9 = (unsigned __int16)(v33 + ((_WORD)v32 << 8));
  }
  else
  {
    if ( a2 != 229 )
    {
      *(_BYTE *)(v2 + 312) = 0;
      Curl_infof(v3, "disabling EPSV usage\n");
      v18 = (int *)v2;
      goto LABEL_50;
    }
    v7 = strchr(v6, 40);
    if ( !v7
      || (v8 = (int)(v7 + 1), sscanf(v7 + 1, "%c%c%c%u%c", &s, &v35, &v36, &v32, &v37) != 5)
      || s != v35
      || v36 != s
      || v37 != v36
      || !v8
      || ((v9 = (unsigned __int16)v32, !*(_BYTE *)(v2 + 308)) && (unsigned int)(*(_DWORD *)(v3 + 596) - 4) > 3 ? (v10 = v2 + 60) : (v10 = *(_DWORD *)(v2 + 140)),
          curl_msnprintf((int)&v41, 48, "%s", v10),
          !v8) )
    {
      Curl_failf(v3, "Weirdly formatted EPSV reply");
      return 13;
    }
  }
  v19 = *(_BYTE **)(v3 + 784);
  if ( v19 && *v19 )
  {
    if ( Curl_resolv((int *)v2, *(const char **)(v2 + 156), *(_DWORD *)(v2 + 164), (const char **)&v31) == 1 )
      Curl_wait_for_resolv((int *)v2, &v31);
    v20 = *(unsigned __int16 *)(v2 + 164);
    if ( !v31 )
    {
      v21 = v3;
      v22 = *(char **)(v2 + 156);
      v23 = *(unsigned __int16 *)(v2 + 164);
      v24 = "Can't resolve proxy host %s:%d";
LABEL_44:
      Curl_failf(v21, v24, v22, v23);
      return 15;
    }
  }
  else
  {
    if ( Curl_resolv((int *)v2, &v41, v9, (const char **)&v31) == 1 )
      Curl_wait_for_resolv((int *)v2, &v31);
    if ( !v31 )
    {
      v21 = v3;
      v22 = &v41;
      v23 = v9;
      v24 = "Can't resolve new host %s:%d";
      goto LABEL_44;
    }
    v20 = v9;
  }
  v25 = Curl_connecthost((int **)v2, v31, (signed int *)(v2 + 216), &v32, &v30);
  Curl_resolv_unlock(v3, (int)v31);
  if ( !v25 )
  {
    *(_BYTE *)(v2 + 305) = v30;
    if ( *(_BYTE *)(v3 + 672) )
    {
      Curl_printable_address(v32, (char *)&v42, 0x100u);
      Curl_infof(*(_DWORD *)v2, "Connecting to %s (%s) port %d\n", &v41, &v42, v20);
    }
    switch ( *(_DWORD *)(v3 + 596) )
    {
      case 0:
      case 1:
        break;
      case 4:
        v26 = Curl_SOCKS4(*(_DWORD *)(v2 + 180), &v41, v9, 1, (int *)v2, 0);
        goto LABEL_57;
      case 5:
      case 7:
        v26 = Curl_SOCKS5(*(_DWORD *)(v2 + 180), *(_DWORD *)(v2 + 184), &v41, v9, 1, v2);
        goto LABEL_57;
      case 6:
        v26 = Curl_SOCKS4(*(_DWORD *)(v2 + 180), &v41, v9, 1, (int *)v2, 1);
LABEL_57:
        v25 = v26;
        break;
      default:
        v25 = 7;
        Curl_failf(v3, "unknown proxytype option given");
        break;
    }
    if ( !*(_BYTE *)(v2 + 308)
      || !*(_BYTE *)(v2 + 299)
      || (v27 = v3 + 34048,
          v28 = *(_DWORD *)(v27 + 152),
          memset(&s, 0, 0x60u),
          *(_DWORD *)(v27 + 152) = &s,
          v29 = Curl_proxyCONNECT((int *)v2, 1, (int)&v41, v9),
          *(_DWORD *)(v27 + 152) = v28,
          (v25 = v29) == 0) )
    {
      *(_DWORD *)(v2 + 832) = 0;
    }
    return v25;
  }
  if ( *(_DWORD *)(v2 + 800) || v4 != 229 )
    return v25;
  Curl_infof(v3, "got positive EPSV response, but can't connect. Disabling EPSV\n");
  v18 = (int *)v2;
  *(_BYTE *)(v2 + 312) = 0;
  *(_BYTE *)(v3 + 33984) = 0;
LABEL_50:
  result = Curl_nbftpsendf(v18, "PASV", 0);
  if ( !result )
    ++*(_DWORD *)(v2 + 800);
  return result;
}

//----- (0007D7A8) --------------------------------------------------------
int __fastcall sub_7D7A8(int *a1)
{
  int v1; // r6
  int v2; // r1
  int v3; // r5
  size_t v4; // r3
  signed int v5; // r4
  int v6; // r2
  int v7; // r0
  _DWORD *v8; // r6
  int v9; // r1
  __int64 v10; // r0
  int v11; // r2
  signed int v12; // r10
  int v13; // r4
  int v14; // r8
  int v15; // r3
  signed int v16; // r3
  unsigned int v17; // r2
  signed int v18; // r3
  int v19; // r3
  int v20; // r2
  int v21; // r3
  int v22; // r0
  char *v23; // r2
  signed int v24; // r2
  unsigned int v25; // r3
  int v26; // r3
  int *v27; // r0
  int v28; // r0
  int v29; // r2
  unsigned __int8 *v30; // r3
  int v31; // r1
  int v32; // r0
  int v33; // r3
  int v34; // r2
  int v35; // r3
  int v36; // r3
  int v37; // r2
  int *v38; // r0
  int v39; // r3
  int v40; // r5
  int v41; // r8
  int v42; // r10
  struct tm *v43; // r0
  int v44; // r3
  int v45; // lr
  int v46; // r9
  int v47; // r2
  int v48; // r3
  int v49; // r0
  int v50; // r9
  __int64 v51; // r4
  bool v52; // zf
  int v53; // r8
  int v54; // r9
  __int64 v55; // r2
  int v56; // r10
  __int64 v57; // r2
  bool v58; // zf
  __int64 v59; // r0
  int v60; // r0
  int *v61; // r0
  char *v62; // r4
  int *v63; // r3
  int v64; // r0
  int v65; // r1
  int v66; // r5
  int v67; // r0
  __int16 v68; // r1
  char v69; // r3
  int v70; // r5
  int v71; // r8
  int v72; // r10
  int v73; // r9
  signed __int64 v74; // r4
  char *v75; // r0
  int v76; // r5
  int v77; // r3
  int v78; // r0
  int v79; // r1
  int v80; // r4
  int v81; // r0
  signed __int64 v82; // r2
  int v83; // r5
  int *v84; // r8
  int v85; // r4
  _QWORD *v86; // r1
  __time_t v88; // [sp+18h] [bp-98h]
  int v89; // [sp+1Ch] [bp-94h]
  int v90; // [sp+24h] [bp-8Ch]
  int v91; // [sp+28h] [bp-88h]
  int v92; // [sp+2Ch] [bp-84h]
  int v93; // [sp+30h] [bp-80h]
  int v94; // [sp+34h] [bp-7Ch]
  int v95; // [sp+38h] [bp-78h]
  int v96; // [sp+3Ch] [bp-74h]
  int v97; // [sp+40h] [bp-70h]
  int v98; // [sp+44h] [bp-6Ch]
  struct tm tp; // [sp+48h] [bp-68h]
  char v100; // [sp+74h] [bp-3Ch]
  char v101; // [sp+8Bh] [bp-25h]
  int v102; // [sp+8Ch] [bp-24h]

  v1 = (int)a1;
  v2 = a1[53];
  v3 = *a1;
  v91 = 0;
  v4 = a1[204];
  if ( v4 )
  {
    v5 = Curl_write(a1, v2, (const void *)(a1[203] + a1[205] - v4), v4, &tp.tm_sec);
    if ( !v5 )
    {
      v6 = *(_DWORD *)(v1 + 816);
      if ( tp.tm_sec == v6 )
      {
        v7 = *(_DWORD *)(v1 + 812);
        v8 = (_DWORD *)(v1 + 824);
        Curl_cfree(v7);
        *(v8 - 3) = 0;
        *(v8 - 1) = 0;
        *(v8 - 2) = 0;
        curlx_tvnow(&v88);
        v9 = v89;
        *v8 = v88;
        v8[1] = v9;
      }
      else
      {
        *(_DWORD *)(v1 + 816) = v6 - tp.tm_sec;
      }
    }
    goto LABEL_162;
  }
  v12 = sub_7C2CC(v2, a1, &v90, &v91);
  if ( v12 )
  {
LABEL_234:
    LODWORD(v10) = v12;
    goto LABEL_236;
  }
  v13 = v90;
  if ( !v90 )
  {
LABEL_8:
    LODWORD(v10) = 0;
    goto LABEL_236;
  }
  v14 = *(_DWORD *)(v1 + 832);
  v15 = v14 - 1;
  switch ( v14 )
  {
    case 1:
      if ( v90 != 220 )
      {
        Curl_failf(v3, "Got a %03d ftp-server response when 220 was expected", v90, v15);
        LODWORD(v10) = 8;
        goto LABEL_236;
      }
      if ( !*(_DWORD *)(v3 + 680) || (v16 = *(unsigned __int8 *)(v1 + 220), *(_BYTE *)(v1 + 220)) )
      {
        LODWORD(v10) = sub_7C950((int *)v1);
        goto LABEL_236;
      }
      *(_DWORD *)(v1 + 808) = v16;
      v17 = *(_DWORD *)(v3 + 684);
      if ( v17 <= 1 )
      {
        *(_DWORD *)(v1 + 804) = 1;
      }
      else
      {
        if ( v17 != 2 )
        {
          Curl_failf(v3, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d");
          goto LABEL_230;
        }
        *(_DWORD *)(v1 + 804) = -1;
        v16 = 1;
      }
      *(_DWORD *)(v1 + 800) = v16;
      LODWORD(v10) = Curl_nbftpsendf((int *)v1, "AUTH %s", &aSsl[4 * *(_DWORD *)(v1 + 800)]);
      if ( (_DWORD)v10 )
        goto LABEL_236;
      v18 = 2;
      goto LABEL_90;
    case 2:
      if ( v90 == 234 || v90 == 334 )
        goto LABEL_230;
      v19 = *(_DWORD *)(v1 + 808);
      if ( v19 > 0 )
      {
        if ( *(_DWORD *)(v3 + 680) > 1u )
          goto LABEL_237;
        LODWORD(v10) = sub_7C950((int *)v1);
      }
      else
      {
        v20 = *(_DWORD *)(v1 + 800);
        *(_DWORD *)(v1 + 808) = v19 + 1;
        v21 = *(_DWORD *)(v1 + 804) + v20;
        *(_DWORD *)(v1 + 800) = v21;
        LODWORD(v10) = Curl_nbftpsendf((int *)v1, "AUTH %s", &aSsl[4 * v21]);
      }
      if ( (_DWORD)v10 )
        goto LABEL_236;
      goto LABEL_8;
    case 3:
    case 4:
      v22 = *(_DWORD *)v1;
      if ( v90 == 331 && v14 == 3 )
      {
        v23 = *(char **)(*(_DWORD *)(*(_DWORD *)v1 + 34200) + 8);
        if ( !v23 )
          v23 = &byte_E4496;
        LODWORD(v10) = Curl_nbftpsendf((int *)v1, "PASS %s", v23);
        if ( !(_DWORD)v10 )
        {
          v18 = 4;
          goto LABEL_90;
        }
        goto LABEL_236;
      }
      if ( (unsigned int)(v90 - 200) <= 0x63 )
      {
LABEL_50:
        LODWORD(v10) = sub_7C9A8(v1);
        goto LABEL_236;
      }
      if ( v90 == 332 )
      {
        if ( *(_DWORD *)(v22 + 748) )
        {
          LODWORD(v10) = Curl_nbftpsendf((int *)v1, "ACCT %s");
          if ( (_DWORD)v10 )
            goto LABEL_236;
          v18 = 5;
          goto LABEL_90;
        }
        Curl_failf(v22, "ACCT requested but none available");
      }
      else
      {
        if ( *(_DWORD *)(v22 + 752) && !*(_BYTE *)(*(_DWORD *)v1 + 34144) )
        {
          LODWORD(v10) = Curl_nbftpsendf((int *)v1, "%s");
          if ( (_DWORD)v10 )
            goto LABEL_236;
          *(_BYTE *)(*(_DWORD *)v1 + 34144) = 1;
          v18 = 3;
          goto LABEL_90;
        }
        Curl_failf(v22, "Access denied: %03d", v90);
      }
      LODWORD(v10) = 67;
      goto LABEL_236;
    case 5:
      if ( v90 == 230 )
        goto LABEL_50;
      Curl_failf(*(_DWORD *)v1, "ACCT rejected by server: %03d", v90, v15);
      LODWORD(v10) = 11;
      goto LABEL_236;
    case 6:
      if ( *(_DWORD *)(v3 + 680) == 2 )
        v24 = 67;
      else
        v24 = 80;
      LODWORD(v10) = Curl_nbftpsendf((int *)v1, "PROT %c", v24, v15);
      if ( (_DWORD)v10 )
        goto LABEL_236;
      v18 = 7;
      goto LABEL_90;
    case 7:
      v25 = *(_DWORD *)(v3 + 680);
      if ( (unsigned int)(v90 - 200) > 0x63 )
      {
        if ( v25 > 2 )
          goto LABEL_237;
      }
      else
      {
        v26 = v25 - 2;
        if ( v26 )
          LOBYTE(v26) = 1;
        *(_BYTE *)(v1 + 228) = v26;
      }
      v27 = (int *)v1;
      if ( !*(_DWORD *)(v3 + 688) )
        goto LABEL_67;
      LODWORD(v10) = Curl_nbftpsendf((int *)v1, "CCC", 0);
      if ( (_DWORD)v10 )
        goto LABEL_236;
      v18 = 8;
      goto LABEL_90;
    case 8:
      if ( v90 < 500 )
      {
        Curl_failf(*(_DWORD *)v1, "Failed to clear the command channel (CCC)");
        goto LABEL_230;
      }
      v27 = (int *)v1;
LABEL_67:
      LODWORD(v10) = sub_7C98C(v27);
      goto LABEL_236;
    case 9:
      if ( v90 != 257 )
        goto def_7D85E;
      v28 = Curl_cmalloc(v91 + 1);
      v29 = v28;
      if ( v28 )
      {
        if ( *(_BYTE *)(v3 + 1176) == 34 )
        {
          v30 = (unsigned __int8 *)(v3 + 1177);
          v31 = v28 + 1;
          while ( 1 )
          {
            v32 = *v30;
            if ( !*v30 )
              goto LABEL_79;
            if ( v32 == 34 )
            {
              if ( v30[1] != 34 )
              {
                *(_BYTE *)(v31 - 1) = 0;
LABEL_79:
                *(_DWORD *)(v1 + 736) = v29;
                Curl_infof(v3, "Entry path is '%s'\n");
                *(_DWORD *)(v3 + 34140) = *(_DWORD *)(v1 + 736);
                goto def_7D85E;
              }
              *(_BYTE *)(v31 - 1) = 34;
              ++v30;
            }
            else
            {
              *(_BYTE *)(v31 - 1) = v32;
            }
            ++v30;
            ++v31;
            if ( !v30 )
              goto LABEL_79;
          }
        }
        Curl_cfree(v28);
        Curl_infof(v3, "Failed to figure out path\n");
def_7D85E:
        LODWORD(v10) = 0;
LABEL_233:
        *(_DWORD *)(v1 + 832) = 0;
      }
      else
      {
        LODWORD(v10) = 27;
      }
      goto LABEL_236;
    case 10:
    case 11:
    case 12:
    case 13:
      if ( v90 < 400 )
      {
        LODWORD(v10) = sub_7D08C(v1, 0, *(_DWORD *)(v1 + 832));
      }
      else
      {
        Curl_failf(*(_DWORD *)v1, "QUOT command failed with %03d", v90, v15);
        LODWORD(v10) = 21;
      }
      goto LABEL_236;
    case 14:
      if ( (unsigned int)(v90 - 200) > 0x63 )
      {
        if ( !*(_DWORD *)(*(_DWORD *)v1 + 636) || (v33 = *(_DWORD *)(v1 + 800)) == 0 || *(_DWORD *)(v1 + 804) )
        {
          Curl_failf(v3, "Server denied you to change to the given directory");
          *(_BYTE *)(v1 + 778) = 1;
          goto LABEL_98;
        }
        *(_DWORD *)(v1 + 804) = 1;
        LODWORD(v10) = Curl_nbftpsendf((int *)v1, "MKD %s", *(_DWORD *)(*(_DWORD *)(v1 + 740) + 4 * (v33 + 0x3FFFFFFF)));
        if ( (_DWORD)v10 )
          goto LABEL_236;
        v18 = 15;
        goto LABEL_90;
      }
      *(_DWORD *)(v1 + 804) = 0;
      v34 = *(_DWORD *)(v1 + 744);
      v35 = *(_DWORD *)(v1 + 800) + 1;
      *(_DWORD *)(v1 + 800) = v35;
      if ( v35 <= v34 )
      {
        v36 = v35 + 0x3FFFFFFF;
        v37 = *(_DWORD *)(v1 + 740);
        v38 = (int *)v1;
        goto LABEL_100;
      }
      LODWORD(v10) = sub_7D050((int *)v1);
      goto LABEL_236;
    case 15:
      if ( (unsigned int)(v90 - 200) <= 0x63 || (v39 = *(_DWORD *)(v1 + 808), *(_DWORD *)(v1 + 808) = v39 - 1, v39) )
      {
        *(_DWORD *)(v1 + 832) = 14;
        v38 = (int *)v1;
        v37 = *(_DWORD *)(v1 + 740);
        v36 = *(_DWORD *)(v1 + 800) + 0x3FFFFFFF;
LABEL_100:
        LODWORD(v10) = Curl_nbftpsendf(v38, "CWD %s", *(_DWORD *)(v37 + 4 * v36));
      }
      else
      {
        Curl_failf(v3, "Failed to MKD dir: %03d", v13);
LABEL_98:
        LODWORD(v10) = 9;
      }
      goto LABEL_236;
    case 16:
      v40 = *(_DWORD *)v1;
      v41 = *(_DWORD *)v1 + 34048;
      v42 = *(_DWORD *)(*(_DWORD *)v1 + 34200);
      if ( v90 == 213 )
      {
        if ( sscanf((const char *)(v40 + 1176), "%04d%02d%02d%02d%02d%02d", &v92, &v93, &v94, &v95, &v96, &v97) == 6 )
        {
          tp.tm_sec = time(0);
          curl_msnprintf(v40 + 1172, 16385, "%04d%02d%02d %02d:%02d:%02d GMT", v92, v93, v94, v95, v96, v97);
          *(_DWORD *)(v41 + 172) = curl_getdate((char *)(v40 + 1172));
        }
        if ( *(_BYTE *)(v40 + 662) && *(_DWORD *)(v1 + 752) && *(_BYTE *)(v40 + 649) && *(_DWORD *)(v41 + 172) >= 0 )
        {
          v98 = *(_DWORD *)(v41 + 172);
          v43 = gmtime_r((const time_t *)&v98, &tp);
          v44 = v43->tm_wday;
          v45 = v44 ? v44 - 1 : 6;
          curl_msnprintf(
            v40 + 1172,
            0x3FFF,
            "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n",
            Curl_wkday[v45],
            v43->tm_mday,
            Curl_month[v43->tm_mon],
            v43->tm_year + 1900,
            v43->tm_hour,
            v43->tm_min,
            v43->tm_sec);
          LODWORD(v10) = Curl_client_write((int *)v1, 3, (const char *)(v40 + 1172), 0);
          if ( (_DWORD)v10 )
            goto LABEL_236;
        }
      }
      else
      {
        if ( v90 == 550 )
        {
          v5 = 19;
          Curl_failf(*(_DWORD *)v1, "Given file does not exist");
LABEL_116:
          v46 = *(_DWORD *)(v40 + 520);
          if ( v46 )
          {
            v47 = *(_DWORD *)(v41 + 172);
            if ( v47 <= 0 || (v48 = *(_DWORD *)(v40 + 524), v48 <= 0) )
            {
              Curl_infof(v40, "Skipping time comparison\n");
            }
            else if ( v46 == 2 )
            {
              if ( v47 > v48 )
              {
                Curl_infof(v40, "The requested document is not old enough\n");
                *(_DWORD *)(v42 + 12) = 2;
                goto LABEL_124;
              }
            }
            else if ( v47 <= v48 )
            {
              Curl_infof(v40, "The requested document is not new enough\n");
              *(_DWORD *)(v42 + 12) = 2;
LABEL_124:
              *(_BYTE *)(v41 + 176) = 1;
              goto def_7D85E;
            }
          }
          if ( !v5 )
          {
            LODWORD(v10) = sub_7D004((int *)v1);
            goto LABEL_236;
          }
          goto LABEL_162;
        }
        Curl_infof(*(_DWORD *)v1, "unsupported MDTM reply format\n");
      }
      v5 = 0;
      goto LABEL_116;
    case 17:
    case 18:
    case 19:
    case 20:
      v49 = *(_DWORD *)v1;
      if ( (unsigned int)(v90 - 200) <= 0x63 )
      {
        if ( v90 != 200 )
          Curl_infof(v49, "Got a %03d response code instead of the assumed 200\n", v90);
        LODWORD(v10) = sub_7D268((int *)v1, v14);
      }
      else
      {
        Curl_failf(v49, "Couldn't set desired mode");
        LODWORD(v10) = 17;
      }
      goto LABEL_236;
    case 21:
    case 22:
    case 23:
      v50 = *(_DWORD *)v1;
      if ( v90 == 213 )
      {
        v10 = strtoll((const char *)(v50 + 1176), 0, 0);
        v51 = v10;
        if ( v14 == 21 )
        {
          v52 = HIDWORD(v10) == -1;
          if ( HIDWORD(v10) == -1 )
            v52 = (_DWORD)v10 == -1;
          if ( !v52 )
          {
            curl_msnprintf(v50 + 1172, 16385, "Content-Length: %lld\r\n");
            LODWORD(v10) = Curl_client_write((int *)v1, 3, (const char *)(v50 + 1172), 0);
            if ( (_DWORD)v10 )
              goto LABEL_236;
          }
LABEL_141:
          Curl_pgrsSetDownloadSize(v50, SHIDWORD(v10), v51);
          LODWORD(v10) = sub_7D22C((int *)v1);
          goto LABEL_236;
        }
      }
      else
      {
        v51 = -1LL;
        if ( v14 == 21 )
          goto LABEL_141;
      }
      if ( v14 != 22 )
      {
        *(_QWORD *)(v50 + 34192) = v51;
        LODWORD(v10) = sub_7C9D4((int *)v1, 1);
        goto LABEL_236;
      }
      Curl_pgrsSetDownloadSize(v50, SHIDWORD(v10), v51);
      v53 = *(_DWORD *)v1;
      v54 = *(_DWORD *)v1 + 34048;
      v55 = *(_QWORD *)(*(_DWORD *)v1 + 624);
      v56 = *(_DWORD *)(*(_DWORD *)v1 + 34200);
      if ( v55 && v55 < v51 )
      {
        Curl_failf(*(_DWORD *)v1, "Maximum file size exceeded");
        LODWORD(v10) = 63;
        goto LABEL_236;
      }
      *(_QWORD *)(v56 + 16) = v51;
      v57 = *(_QWORD *)(v54 + 144);
      if ( v57 )
      {
        v58 = HIDWORD(v51) == -1;
        if ( HIDWORD(v51) == -1 )
          v58 = (_DWORD)v51 == -1;
        if ( v58 )
        {
          Curl_infof(v53, "ftp server doesn't support SIZE\n");
        }
        else if ( v57 >= 0 )
        {
          if ( v51 < v57 )
          {
            v60 = v53;
            goto LABEL_158;
          }
          *(_QWORD *)(v56 + 16) = v51 - v57;
        }
        else
        {
          LODWORD(v59) = -(signed int)v57;
          HIDWORD(v59) = HIDWORD(v57) - (2 * HIDWORD(v57) + ((unsigned int)v57 > 0));
          if ( v51 < (signed __int64)__PAIR__(HIDWORD(v59), -(signed int)v57) )
          {
            v60 = v53;
LABEL_158:
            Curl_failf(v60, "Offset (%lld) was beyond file size (%lld)");
            LODWORD(v10) = 36;
            goto LABEL_236;
          }
          *(_QWORD *)(v56 + 16) = v59;
          *(_QWORD *)(v54 + 144) = v51 + v57;
        }
        if ( !*(_QWORD *)(v56 + 16) )
        {
          v5 = 0;
          Curl_setup_transfer((int *)v1, -1, -1LL, 0, 0, -1, 0);
          Curl_infof(v53, "File already completely downloaded\n");
          *(_DWORD *)(v56 + 12) = 2;
          *(_DWORD *)(v1 + 832) = 0;
LABEL_162:
          LODWORD(v10) = v5;
          goto LABEL_236;
        }
        Curl_infof(v53, "Instructs server to resume from offset %lld\n", *(_QWORD *)(v54 + 144));
        LODWORD(v10) = Curl_nbftpsendf((int *)v1, "REST %lld", *(_QWORD *)(v54 + 144));
        if ( !(_DWORD)v10 )
        {
          v18 = 25;
LABEL_90:
          *(_DWORD *)(v1 + 832) = v18;
          goto LABEL_236;
        }
      }
      else
      {
        v61 = (int *)v1;
LABEL_176:
        LODWORD(v10) = Curl_nbftpsendf(v61, "RETR %s", *(_DWORD *)(v1 + 752));
        if ( !(_DWORD)v10 )
        {
          v18 = 29;
          goto LABEL_90;
        }
      }
      goto LABEL_236;
    case 24:
    case 25:
      if ( v14 != 25 )
      {
        if ( v90 != 350 )
          goto LABEL_241;
        v62 = &v100;
        v63 = &dword_EBDD1;
        do
        {
          v64 = *v63;
          v63 += 2;
          v65 = *(v63 - 1);
          *(_DWORD *)v62 = v64;
          *((_DWORD *)v62 + 1) = v65;
          v66 = (int)(v62 + 8);
          v62 += 8;
        }
        while ( v63 != (int *)"ytes\r\n" );
        v67 = *v63;
        v68 = *((_WORD *)v63 + 2);
        v69 = *((_BYTE *)v63 + 6);
        *(_DWORD *)v66 = v67;
        *(_WORD *)(v66 + 4) = v68;
        *(_BYTE *)(v66 + 6) = v69;
        v101 = 0;
        LODWORD(v10) = Curl_client_write((int *)v1, 3, &v100, 0);
        if ( !(_DWORD)v10 )
LABEL_241:
          LODWORD(v10) = sub_7D1A4(v1);
        goto LABEL_236;
      }
      if ( v90 != 350 )
      {
        Curl_failf(*(_DWORD *)v1, "Couldn't use REST");
        LODWORD(v10) = 31;
        goto LABEL_236;
      }
      v61 = (int *)v1;
      goto LABEL_176;
    case 26:
      v70 = *(_DWORD *)v1;
      v71 = *(_DWORD *)(v1 + 800);
      if ( v90 == 200 )
      {
        Curl_infof(*(_DWORD *)v1, "Connect data stream actively\n");
        *(_DWORD *)(v1 + 832) = 0;
      }
      else
      {
        if ( !v71 )
        {
          Curl_infof(*(_DWORD *)v1, "disabling EPRT usage\n");
          *(_BYTE *)(v1 + 313) = 0;
        }
        if ( v71 == 1 )
        {
          v12 = 30;
          Curl_failf(v70, "Failed to do PORT");
        }
        else
        {
          v12 = sub_7CB68((char **)v1, v71 + 1);
        }
      }
      goto LABEL_234;
    case 27:
      LODWORD(v10) = sub_7D3D0((int *)v1, v90);
      goto LABEL_236;
    case 28:
    case 29:
      v72 = *(_DWORD *)v1;
      v73 = *(_DWORD *)(*(_DWORD *)v1 + 34200);
      if ( v90 == 150 || v90 == 125 )
      {
        v74 = *(_QWORD *)(v73 + 16);
        if ( v14 == 28 || *(_BYTE *)(v72 + 651) || v74 >= 1 )
        {
          v11 = *(_QWORD *)(v73 + 16) >> 32;
          if ( v74 >= 0 )
            goto LABEL_201;
        }
        else
        {
          v75 = strstr((const char *)(v72 + 1172), " bytes");
          v11 = (int)(v75 - 1);
          if ( v75 )
          {
            v11 -= v72 + 1172;
            v76 = (int)&v75[-v11];
            v77 = v11 - 1;
            v78 = (int)&v75[-v11];
            while ( 1 )
            {
              v79 = v76 + v77;
              if ( !v77 )
                break;
              v80 = *(unsigned __int8 *)(v78 + v77);
              if ( v80 == 40 )
                break;
              --v77;
              if ( (unsigned int)(v80 - 48) > 9 )
                goto LABEL_200;
            }
            if ( v79 )
            {
              v74 = strtoll((const char *)(v79 + 1), 0, 0);
              goto LABEL_201;
            }
          }
        }
LABEL_200:
        v74 = -1LL;
LABEL_201:
        if ( !*(_BYTE *)(v72 + 654) || (LODWORD(v10) = sub_7C580((int *)v1), !(_DWORD)v10) )
        {
          if ( *(_BYTE *)(v1 + 228) )
          {
            v81 = v72;
            goto LABEL_229;
          }
          v82 = *(_QWORD *)(v72 + 40);
          if ( v82 < v74 && v82 >= 1 )
          {
            v74 = *(_QWORD *)(v72 + 40);
            *(_QWORD *)(v72 + 24) = v82;
          }
          Curl_infof(v72, "Maxdownload = %lld\n");
          if ( v14 != 28 )
            Curl_infof(v72, "Getting file with size: %lld\n", v74);
          LODWORD(v10) = Curl_setup_transfer((int *)v1, 1, v74, 0, *(_DWORD *)v73, -1, 0);
          if ( !(_DWORD)v10 )
          {
            *(_BYTE *)(v1 + 796) = 1;
            goto LABEL_233;
          }
        }
        goto LABEL_236;
      }
      if ( v14 == 28 && v90 == 450 )
      {
        *(_DWORD *)(v73 + 12) = 2;
        goto def_7D85E;
      }
      Curl_failf(*(_DWORD *)v1, "RETR response: %03d", v90);
      if ( v14 == 29 )
      {
        if ( v13 == 550 )
          LODWORD(v10) = 78;
        else
          LODWORD(v10) = 19;
      }
      else
      {
        LODWORD(v10) = 19;
      }
LABEL_236:
      while ( v102 != _stack_chk_guard )
LABEL_237:
        LODWORD(v10) = 64;
      return v10;
    case 30:
      v83 = *(_DWORD *)v1;
      v84 = *(int **)(*(_DWORD *)v1 + 34200);
      if ( v90 < 400 )
      {
        if ( !*(_BYTE *)(v83 + 654) || (LODWORD(v10) = sub_7C580((int *)v1), !(_DWORD)v10) )
        {
          v85 = *(unsigned __int8 *)(v1 + 228);
          if ( *(_BYTE *)(v1 + 228) )
          {
            v81 = v83;
LABEL_229:
            Curl_infof(v81, "Doing the SSL/TLS handshake on the data stream\n", v11);
LABEL_230:
            LODWORD(v10) = 2;
          }
          else
          {
            v86 = (_QWORD *)*v84;
            *v86 = 0LL;
            Curl_pgrsSetUploadSize(v83, (int)v86, *(_QWORD *)(v83 + 440));
            LODWORD(v10) = Curl_setup_transfer((int *)v1, -1, -1LL, v85, v85, 1, *v84);
            *(_DWORD *)(v1 + 832) = v85;
            *(_BYTE *)(v1 + 796) = 1;
          }
        }
      }
      else
      {
        Curl_failf(*(_DWORD *)v1, "Failed FTP upload: %0d", v90);
        LODWORD(v10) = 25;
      }
      goto LABEL_236;
    default:
      goto def_7D85E;
  }
}
// E4496: using guessed type char byte_E4496;
// EBDD1: using guessed type int dword_EBDD1;
// EF850: using guessed type char *Curl_month[20];
// EF880: using guessed type char *Curl_wkday[8];
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);
// F3BF8: using guessed type int (__fastcall *Curl_cmalloc)(_DWORD);

//----- (0007E3A0) --------------------------------------------------------
int __fastcall sub_7E3A0(int *a1)
{
  int *v1; // r4
  int v2; // r5
  int v3; // r6
  int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r0
  signed int v9; // r0

  v1 = a1;
  v2 = a1[53];
  v3 = *a1;
  do
  {
    result = v1[208];
    if ( !result )
      break;
    v6 = sub_7C280(v1);
    if ( v6 <= 0 )
    {
      Curl_failf(v3, "FTP response timeout", v6);
      return 28;
    }
    v7 = v1[204];
    if ( v7 )
    {
      v8 = -1;
      v5 = v2;
    }
    else
    {
      v8 = v2;
    }
    if ( !v7 )
      v5 = -1;
    v9 = Curl_socket_ready(v8, v5, v6);
    if ( v9 == -1 )
    {
      Curl_failf(v3, "select/poll error");
      return 27;
    }
    if ( !v9 )
      return 28;
    result = sub_7D7A8(v1);
  }
  while ( !result );
  return result;
}

//----- (0007E410) --------------------------------------------------------
int __fastcall sub_7E410(int a1)
{
  int v1; // r6
  unsigned __int8 *v2; // r10
  _DWORD *v3; // r7
  int result; // r0
  int v5; // r2
  int v6; // r1
  int v7; // r2
  unsigned __int8 *v8; // r8
  int v9; // r9
  const char *v10; // r0
  __int64 v11; // r4
  int v12; // r3
  __int64 v13; // r0
  bool v14; // zf
  signed __int64 v15; // r2
  char *endptr; // [sp+10h] [bp-28h]
  char *v17; // [sp+14h] [bp-24h]

  v1 = a1;
  v2 = *(unsigned __int8 **)a1;
  v3 = *(_DWORD **)(*(_DWORD *)a1 + 34200);
  if ( v3[3] <= 1u )
  {
    v5 = v2[664];
    if ( v2[664] )
    {
      v6 = v2[651];
      v7 = 20;
      goto LABEL_6;
    }
    v3[4] = -1;
    v3[5] = -1;
    v8 = *(unsigned __int8 **)a1;
    v9 = *(_DWORD *)a1 + 34048;
    if ( !*(_BYTE *)(*(_DWORD *)a1 + 34184) || (v10 = *(const char **)(*(_DWORD *)a1 + 34188)) == 0 )
    {
      *((_DWORD *)v8 + 10) = -1;
      *((_DWORD *)v8 + 11) = -1;
      goto LABEL_30;
    }
    v11 = strtoll(v10, &endptr, v5);
    while ( endptr )
    {
      v12 = (unsigned __int8)*endptr;
      if ( !*endptr || !(*(_BYTE *)(ctype_ + v12 + 1) & 8) && v12 != 45 )
        break;
      ++endptr;
    }
    v13 = strtoll(endptr, &v17, 0);
    if ( endptr == v17 )
      goto LABEL_37;
    v14 = HIDWORD(v13) == -1;
    if ( HIDWORD(v13) == -1 )
      v14 = (_DWORD)v13 == -1;
    if ( v14 )
    {
LABEL_37:
      if ( v11 >= 0 )
      {
LABEL_28:
        *(_QWORD *)(v9 + 144) = v11;
        *(_BYTE *)(v1 + 768) = 1;
LABEL_30:
        if ( !v2[653] && *(_DWORD *)(v1 + 752) )
        {
          a1 = v1;
          v6 = v2[651];
          v7 = 19;
        }
        else
        {
          if ( v3[3] )
            goto LABEL_7;
          a1 = v1;
          v6 = 1;
          v7 = 18;
        }
LABEL_6:
        result = sub_7D390(a1, v6, v7);
        if ( result )
          return result;
LABEL_7:
        result = sub_7E3A0((int *)v1);
        if ( result )
          return result;
        goto LABEL_2;
      }
    }
    else if ( v11 >= 0 )
    {
      v15 = v13 - v11 + 1;
      goto LABEL_27;
    }
    LODWORD(v15) = -(signed int)v11;
    HIDWORD(v15) = HIDWORD(v11) - (2 * HIDWORD(v11) + ((unsigned int)v11 > 0));
LABEL_27:
    *((_QWORD *)v8 + 5) = v15;
    goto LABEL_28;
  }
LABEL_2:
  result = v3[3];
  if ( result )
    result = Curl_setup_transfer((int *)v1, -1, -1LL, 0, 0, -1, 0);
  return result;
}

//----- (0007E54C) --------------------------------------------------------
int __fastcall sub_7E54C(int a1, int a2)
{
  int v2; // r4
  int v3; // r6
  int v4; // r7
  int v5; // r5
  int v6; // r0

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 34200);
  if ( a2 )
  {
    v5 = sub_7E410(a1);
    if ( v5 )
    {
      v6 = *(_DWORD *)(v2 + 216);
      if ( v6 != -1 )
      {
        close(v6);
        *(_DWORD *)(v2 + 216) = -1;
        return v5;
      }
    }
  }
  else
  {
    v5 = 0;
  }
  if ( *(_DWORD *)(v4 + 12) )
  {
    v5 = Curl_setup_transfer((int *)v2, -1, -1LL, 0, 0, -1, 0);
  }
  else if ( !v3 )
  {
    *(_BYTE *)(v2 + 304) = 1;
  }
  *(_BYTE *)(v2 + 776) = 1;
  return v5;
}

//----- (0007E5B8) --------------------------------------------------------
signed int __fastcall sub_7E5B8(int *a1, bool *a2)
{
  bool *v2; // r5
  int *v3; // r4
  int v4; // r7
  int v5; // r6
  int v6; // r0
  int v7; // r1
  signed int result; // r0
  int v9; // r3
  int v10; // r0

  v2 = a2;
  v3 = a1;
  v4 = a1[53];
  v5 = *a1;
  v6 = sub_7C280(a1);
  *v2 = 0;
  if ( v6 > 0 )
  {
    v9 = v3[204];
    if ( v9 )
    {
      v10 = -1;
      v7 = v4;
    }
    else
    {
      v10 = v4;
    }
    if ( !v9 )
      v7 = -1;
    result = Curl_socket_ready(v10, v7, 0);
    if ( result == -1 )
    {
      Curl_failf(v5, "select/poll error");
      result = 27;
    }
    else if ( result )
    {
      result = sub_7D7A8(v3);
      *v2 = v3[208] == 0;
    }
  }
  else
  {
    Curl_failf(v5, "FTP response timeout");
    result = 28;
  }
  return result;
}

//----- (0007E62C) --------------------------------------------------------
signed int __fastcall sub_7E62C(int *a1, bool *a2)
{
  bool *v2; // r4
  int v3; // r5
  signed int result; // r0

  v2 = a2;
  v3 = (int)a1;
  result = sub_7E5B8(a1, a2);
  if ( *v2 )
    result = sub_7E54C(v3, 0);
  return result;
}

//----- (0007E648) --------------------------------------------------------
signed int __fastcall sub_7E648(int *a1, bool *a2)
{
  int v2; // r8
  int *v3; // r4
  bool *v4; // r6
  signed int result; // r0
  int v6; // r5
  int v7; // r10
  int v8; // r3
  int v9; // r1
  _DWORD *v10; // r3
  int v11; // [sp+0h] [bp-88h]
  int v12; // [sp+4h] [bp-84h]
  char s; // [sp+8h] [bp-80h]

  v2 = *a1;
  v3 = a1;
  *a2 = 0;
  v4 = a2;
  Curl_reset_reqproto((int)a1);
  result = sub_7C528(v3);
  v6 = result;
  if ( !result )
  {
    *((_BYTE *)v3 + 296) = 0;
    v3[193] = 3600000;
    if ( !*((_BYTE *)v3 + 308)
      || !*((_BYTE *)v3 + 299)
      || (v7 = *(_DWORD *)(v2 + 34200),
          memset(&s, 0, 0x60u),
          *(_DWORD *)(v2 + 34200) = &s,
          result = Curl_proxyCONNECT(v3, v6, v3[35], *((unsigned __int16 *)v3 + 84)),
          *(_DWORD *)(v2 + 34200) = v7,
          !result) )
    {
      if ( v3[12] & 8 )
      {
        result = 2;
      }
      else
      {
        v3[197] = 0;
        v8 = *v3;
        *((_BYTE *)v3 + 796) = 1;
        v3[208] = 1;
        v3[198] = v8 + 1172;
        curlx_tvnow(&v11);
        v9 = v12;
        v10 = v3 + 206;
        *v10 = v11;
        v10[1] = v9;
        if ( *(_DWORD *)(v2 + 1144) == 2 )
        {
          result = sub_7E5B8(v3, v4);
        }
        else
        {
          result = sub_7E3A0(v3);
          if ( !result )
            *v4 = 1;
        }
      }
    }
  }
  return result;
}

//----- (0007E70C) --------------------------------------------------------
signed int __fastcall sub_7E70C(int a1, bool *a2)
{
  int v2; // r4
  signed int v3; // r0
  int v4; // r7
  _DWORD *v5; // r5
  int v6; // r9
  int v7; // r2
  char *v8; // r8
  int v9; // r1
  char *v10; // r10
  int *v11; // r0
  void *v12; // r0
  _DWORD *v13; // r11
  char *v14; // r0
  _BOOL4 v15; // r2
  int v16; // r11
  int v17; // r10
  _DWORD *v18; // r11
  int v19; // r3
  void *v20; // r10
  int v21; // r1
  void *v22; // r0
  const char *v23; // r0
  int v24; // r4
  int v25; // r3
  char *v26; // r9
  const char *v27; // r0
  int v28; // r10
  const char *v29; // r11
  size_t v30; // r10
  int v31; // r6
  int v32; // r1
  int v33; // r1
  int v34; // r1
  int v35; // r3
  int v36; // r0
  _DWORD *v38; // [sp+0h] [bp-40h]
  int v39; // [sp+0h] [bp-40h]
  char *v40; // [sp+4h] [bp-3Ch]
  bool *v41; // [sp+8h] [bp-38h]
  int v42; // [sp+Ch] [bp-34h]
  int v43; // [sp+14h] [bp-2Ch]

  v2 = a1;
  *a2 = 0;
  v41 = a2;
  Curl_reset_reqproto(a1);
  v3 = sub_7C528((int *)v2);
  if ( v3 )
    return v3;
  v4 = *(_DWORD *)v2;
  v5 = (_DWORD *)(v2 + 736);
  v6 = *(_DWORD *)v2 + 34048;
  v7 = *(_DWORD *)(*(_DWORD *)v2 + 34200);
  v8 = *(char **)(*(_DWORD *)v2 + 34180);
  *(_BYTE *)(v2 + 776) = 0;
  *(_BYTE *)(v2 + 778) = 0;
  v9 = *(_DWORD *)(v4 + 632);
  v42 = v7;
  if ( v9 != 2 )
  {
    if ( v9 == 3 )
    {
      v9 = (unsigned __int8)*v8;
      if ( !*v8 )
      {
        *(_DWORD *)(v2 + 744) = v9;
        goto LABEL_38;
      }
      v38 = (_DWORD *)v3;
      v10 = strrchr(v8, 47);
      if ( !v10 )
        goto LABEL_33;
      v11 = (int *)((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(1u, 4u);
      *(_DWORD *)(v2 + 740) = v11;
      if ( !v11 )
        return 27;
      *v11 = curl_easy_unescape(*(_DWORD *)v2, v8, v10 - v8, v38);
      if ( !**(_DWORD **)(v2 + 740) )
      {
LABEL_25:
        sub_7C224((_DWORD *)(v2 + 736));
        return 27;
      }
      *(_DWORD *)(v2 + 744) = 1;
      v8 = v10 + 1;
    }
    else
    {
      *(_DWORD *)(v2 + 744) = 0;
      *(_DWORD *)(v2 + 748) = 5;
      v12 = ((void *(__cdecl *)(size_t, size_t))Curl_ccalloc)(5u, 4u);
      *(_DWORD *)(v2 + 740) = v12;
      if ( !v12 )
        return 27;
      if ( curl_strequal(v8, "/") )
      {
        v13 = *(_DWORD **)(v2 + 740);
        ++v8;
        *v13 = ((char *(__cdecl *)(const char *))Curl_cstrdup)("/");
        ++*(_DWORD *)(v2 + 744);
      }
      else
      {
        while ( 1 )
        {
          v14 = strchr(v8, 47);
          if ( !v14 )
            break;
          if ( (signed int)&v8[-*(_DWORD *)(v6 + 132)] <= 0 )
            v15 = 0;
          else
            v15 = *(_DWORD *)(v2 + 744) == 0;
          if ( v14 == v8 )
          {
            ++v8;
          }
          else
          {
            v16 = *(_DWORD *)(v2 + 744);
            v17 = *(_DWORD *)(v2 + 740);
            v40 = v14;
            *(_DWORD *)(v17 + 4 * v16) = curl_easy_unescape(*(_DWORD *)v2, &v8[-v15], v15 + v14 - v8, 0);
            v18 = *(_DWORD **)(v2 + 740);
            v19 = *(_DWORD *)(v2 + 744);
            v20 = (void *)v18[v19];
            if ( !v20 )
            {
              Curl_failf(v4, "no memory");
              goto LABEL_25;
            }
            v39 = *(_DWORD *)(v2 + 744);
            if ( sub_7C508((const char *)v18[v19]) )
            {
              ((void (__cdecl *)(void *))Curl_cfree)(v20);
              goto LABEL_37;
            }
            v21 = *(_DWORD *)(v2 + 748);
            v8 = v40 + 1;
            *(_DWORD *)(v2 + 744) = v39 + 1;
            if ( v39 + 1 >= v21 )
            {
              *(_DWORD *)(v2 + 748) = 2 * v21;
              v22 = ((void *(__cdecl *)(void *, size_t))Curl_crealloc)(v18, 8 * v21);
              if ( !v22 )
                goto LABEL_25;
              *(_DWORD *)(v2 + 740) = v22;
            }
          }
        }
      }
    }
    if ( v8 )
      goto LABEL_33;
LABEL_38:
    *(_DWORD *)(v2 + 752) = 0;
    goto LABEL_39;
  }
  v8 = *(char **)(v6 + 132);
  if ( !v8 || !*v8 || v8[strlen(*(const char **)(v6 + 132)) - 1] == 47 )
    goto LABEL_38;
LABEL_33:
  if ( !*v8 )
    goto LABEL_38;
  v23 = (const char *)curl_easy_unescape(*(_DWORD *)v2, v8, 0, 0);
  *(_DWORD *)(v2 + 752) = v23;
  if ( !v23 )
  {
    sub_7C224((_DWORD *)(v2 + 736));
    Curl_failf(v4, "no memory");
    return 27;
  }
  if ( sub_7C508(v23) )
  {
LABEL_37:
    sub_7C224((_DWORD *)(v2 + 736));
    return 3;
  }
LABEL_39:
  if ( *(_BYTE *)(v4 + 664) && !*(_DWORD *)(v2 + 752) && !*(_DWORD *)(v42 + 12) )
  {
    Curl_failf(v4, "Uploading to a URL without a file name!");
    return 3;
  }
  v25 = *(_DWORD *)(v2 + 780);
  *(_BYTE *)(v2 + 777) = 0;
  if ( v25 )
  {
    v26 = (char *)curl_easy_unescape(*(_DWORD *)v2, *(char **)(v6 + 132), 0, &v43);
    if ( v26 )
    {
      v27 = *(const char **)(v2 + 752);
      v28 = v43;
      if ( v27 )
        v27 = (const char *)strlen(v27);
      v29 = *(const char **)(v2 + 780);
      v30 = v28 - (_DWORD)v27;
      v43 = v30;
      if ( v30 == strlen(v29) && curl_strnequal(v26, v29, v30) )
      {
        Curl_infof(v4, "Request has same path as previous transfer\n");
        *(_BYTE *)(v2 + 777) = 1;
      }
      ((void (__cdecl *)(void *))Curl_cfree)(v26);
      goto LABEL_53;
    }
    goto LABEL_25;
  }
LABEL_53:
  v31 = *(_DWORD *)v2;
  *(_QWORD *)(v31 + 24) = -1LL;
  Curl_pgrsSetUploadCounter(v31, v9, 0LL);
  Curl_pgrsSetDownloadCounter(v31, v32, 0LL);
  Curl_pgrsSetUploadSize(v31, v33, 0LL);
  Curl_pgrsSetDownloadSize(v31, v34, 0LL);
  v35 = *(_DWORD *)v2;
  *(_BYTE *)(v2 + 776) = 1;
  if ( *(_BYTE *)(v35 + 662) )
    *(_DWORD *)(*(_DWORD *)(v35 + 34200) + 12) = 1;
  *v41 = 0;
  v36 = sub_7D08C(v2, 1, 0xAu);
  if ( v36
    || (*(_DWORD *)(*(_DWORD *)v2 + 1144) != 2 ? (v36 = sub_7E3A0((int *)v2), *v41 = 1) : (v36 = sub_7E5B8(
                                                                                                   (int *)v2,
                                                                                                   v41)),
        v36) )
  {
    v24 = v36;
    sub_7C224(v5);
  }
  else
  {
    if ( *v41 )
      v36 = sub_7E54C(v2, *(unsigned __int8 *)(v2 + 305));
    v24 = v36;
  }
  return v24;
}
// F3BE8: using guessed type int (__fastcall *Curl_ccalloc)(_DWORD, _DWORD);
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF0: using guessed type int (__fastcall *Curl_crealloc)(_DWORD, _DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007EAA0) --------------------------------------------------------
int __fastcall sub_7EAA0(int a1)
{
  int *v1; // r4
  _DWORD *v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r0

  v1 = (int *)a1;
  v2 = (_DWORD *)(a1 + 736);
  if ( *(_BYTE *)(a1 + 776) && !Curl_nbftpsendf((int *)a1, "QUIT", 0) )
  {
    v1[208] = 31;
    sub_7E3A0(v1);
  }
  v3 = v1[184];
  if ( v3 )
  {
    if ( *(_DWORD *)(*v1 + 34140) == v3 )
      *(_DWORD *)(*v1 + 34140) = 0;
    Curl_cfree(v1[184]);
    v1[184] = 0;
  }
  v4 = v1[189];
  if ( v4 )
  {
    Curl_cfree(v4);
    v1[189] = 0;
  }
  sub_7C224(v2);
  v5 = v1[195];
  if ( v5 )
  {
    Curl_cfree(v5);
    v1[195] = 0;
  }
  return 0;
}
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007EB30) --------------------------------------------------------
signed int Curl_ftpsendf(int *a1, char *a2, ...)
{
  char *v2; // r6
  int *v3; // r4
  size_t v4; // r7
  signed int v5; // r9
  size_t v7; // [sp+Ch] [bp-434h]
  int **v8; // [sp+10h] [bp-430h]
  char v9; // [sp+14h] [bp-42Ch]
  va_list varg_r2; // [sp+438h] [bp-8h]

  va_start(varg_r2, a2);
  v2 = &v9;
  v3 = a1;
  va_copy(v8, varg_r2);
  curl_mvsnprintf(&v9, 1021, a2, (int)varg_r2);
  strcat(&v9, "\r\n");
  v7 = 0;
  v4 = strlen(&v9);
  while ( 1 )
  {
    v5 = Curl_write(v3, v3[53], v2, v4, (ssize_t *)&v7);
    if ( v5 )
      break;
    if ( *(_BYTE *)(*v3 + 672) )
      Curl_debug(*v3, 2u, v2, v7, (int)v3);
    if ( v7 == v4 )
      break;
    v4 -= v7;
    v2 += v7;
  }
  return v5;
}

//----- (0007EBD8) --------------------------------------------------------
signed int __fastcall sub_7EBD8(int a1, unsigned int a2, int a3)
{
  int v3; // r7
  int v4; // r6
  unsigned int v5; // r8
  __int64 **v6; // r9
  int v7; // r10
  char *v8; // r4
  signed int result; // r0
  bool v10; // zf
  signed int v11; // r5
  void *v12; // r0
  char *v13; // r4
  const char *v14; // r0
  size_t v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r11
  signed int v19; // r0
  int v20; // r3
  __int64 v21; // r4
  bool v22; // zf
  __int64 v23; // r2
  signed __int64 v24; // r0
  bool v25; // zf
  __int64 v26; // r2
  int v27; // r4
  _BYTE *v28; // r7
  signed int v29; // r5
  const char *v30; // [sp+14h] [bp-44h]
  int v31; // [sp+18h] [bp-40h]
  _DWORD *v32; // [sp+1Ch] [bp-3Ch]
  int v33; // [sp+20h] [bp-38h]
  int v34; // [sp+24h] [bp-34h]
  char v35; // [sp+28h] [bp-30h]
  int v36; // [sp+2Ch] [bp-2Ch]

  v3 = *(_DWORD *)a1;
  v4 = a1;
  v5 = a2;
  v31 = *(_DWORD *)a1 + 34048;
  v6 = *(__int64 ***)(*(_DWORD *)a1 + 34200);
  v7 = a3;
  v32 = (_DWORD *)(a1 + 736);
  v8 = *(char **)(*(_DWORD *)a1 + 34180);
  if ( !v6 )
    return 0;
  if ( a2 != 23 )
  {
    if ( a2 > 0x17 )
    {
      if ( a2 == 36 )
        goto LABEL_19;
      if ( a2 > 0x24 )
      {
        if ( a2 == 63 )
          goto LABEL_19;
        v10 = a2 == 78;
      }
      else
      {
        if ( a2 == 25 )
          goto LABEL_19;
        v10 = a2 == 30;
      }
    }
    else
    {
      if ( a2 == 13 )
        goto LABEL_19;
      if ( a2 > 0xD )
      {
        if ( a2 == 17 )
          goto LABEL_19;
        v10 = a2 == 19;
      }
      else
      {
        if ( !a2 )
          goto LABEL_19;
        v10 = a2 == 9;
      }
    }
    if ( !v10 )
      goto LABEL_20;
  }
LABEL_19:
  if ( a3 )
  {
LABEL_20:
    v11 = a2;
    *(_BYTE *)(a1 + 776) = 0;
    *(_BYTE *)(a1 + 778) = 1;
    *(_BYTE *)(a1 + 296) = 1;
    goto LABEL_22;
  }
  v11 = 0;
LABEL_22:
  v12 = *(void **)(a1 + 780);
  if ( v12 )
    ((void (__cdecl *)(void *))Curl_cfree)(v12);
  v13 = (char *)curl_easy_unescape(v3, v8, 0, 0);
  if ( v13 )
  {
    v14 = *(const char **)(v4 + 752);
    if ( v14 )
      v14 = (const char *)strlen(v14);
    v30 = v14;
    v15 = strlen(v13);
    if ( *(_BYTE *)(v4 + 778) )
    {
      *(_DWORD *)(v4 + 780) = 0;
      ((void (__cdecl *)(void *))Curl_cfree)(v13);
    }
    else
    {
      v16 = v15 - (_DWORD)v30;
      if ( v16 && *(_DWORD *)(v3 + 632) != 2 )
      {
        *(_DWORD *)(v4 + 780) = v13;
        if ( v30 )
          v13[v16] = 0;
      }
      else
      {
        *(_DWORD *)(v4 + 780) = ((char *(__cdecl *)(const char *))Curl_cstrdup)(&byte_E4496);
        ((void (__cdecl *)(void *))Curl_cfree)(v13);
      }
      if ( *(_DWORD *)(v4 + 780) )
        Curl_infof(v3, "Remembering we are in dir \"%s\"\n");
    }
  }
  else
  {
    *(_DWORD *)(v4 + 780) = 0;
  }
  sub_7C224(v32);
  v17 = *(_DWORD *)(v4 + 216);
  if ( v17 != -1 )
  {
    close(v17);
    *(_DWORD *)(v4 + 216) = -1;
  }
  if ( !v6[3] && *(_BYTE *)(v4 + 776) && *(_BYTE *)(v4 + 796) )
  {
    if ( !v7 )
    {
      v18 = *(_DWORD *)(v4 + 772);
      *(_DWORD *)(v4 + 772) = 60000;
      v19 = Curl_GetFTPResponse(&v33, (int *)v4, &v34);
      v20 = v33;
      *(_DWORD *)(v4 + 772) = v18;
      v11 = v19;
      if ( !v20 && v19 == 28 )
      {
        Curl_failf(v3, "control connection looks dead");
        *(_BYTE *)(v4 + 776) = 0;
        *(_BYTE *)(v4 + 296) = 1;
        return v11;
      }
      if ( v19 )
        return v11;
      if ( !*(_BYTE *)(v4 + 768) && v34 != 226 && v34 != 250 )
      {
        Curl_failf(v3, "server did not report OK, got %d");
LABEL_63:
        v11 = 18;
        goto LABEL_75;
      }
      goto LABEL_48;
    }
    if ( v11 )
      goto LABEL_75;
    goto LABEL_55;
  }
  if ( !v11 )
  {
    if ( !v7 )
    {
LABEL_48:
      if ( *(_BYTE *)(v3 + 664) )
      {
        v21 = *(_QWORD *)(v3 + 440);
        v22 = HIDWORD(v21) == -1;
        if ( HIDWORD(v21) == -1 )
          v22 = (_DWORD)v21 == -1;
        if ( !v22 )
        {
          v23 = **v6;
          if ( v21 != v23 && !*(_BYTE *)(v3 + 489) && !v6[3] )
          {
            Curl_failf(v3, "Uploaded unaligned file size (%lld out of %lld bytes)", (_DWORD)v23);
            goto LABEL_63;
          }
        }
      }
      else
      {
        v24 = *(_QWORD *)(v3 + 24);
        v25 = HIDWORD(v24) == -1;
        if ( HIDWORD(v24) == -1 )
          v25 = (_DWORD)v24 == -1;
        if ( !v25 )
        {
          v26 = **v6;
          if ( v24 != v26 && *(_QWORD *)(v31 + 112) + v24 != v26 && *(_QWORD *)(v3 + 40) != v26 )
          {
            Curl_failf(v3, "Received only partial file: %lld bytes", (_DWORD)v26);
            goto LABEL_63;
          }
        }
        if ( !*(_BYTE *)(v4 + 768) && !**v6 && v24 >= 1 )
        {
          v11 = 19;
          Curl_failf(v3, "No data was received!");
          goto LABEL_75;
        }
      }
    }
LABEL_55:
    v11 = 0;
  }
LABEL_75:
  v6[3] = 0;
  *(_BYTE *)(v4 + 768) = 0;
  if ( v5 || v11 )
    return v11;
  if ( v7 )
    return 0;
  v27 = *(_DWORD *)(v3 + 496);
  if ( !v27 )
    return 0;
  while ( 1 )
  {
    v28 = *(_BYTE **)v27;
    if ( *(_DWORD *)v27 )
    {
      if ( *v28 == 42 )
      {
        ++v28;
        v29 = 1;
      }
      else
      {
        v29 = 0;
      }
      result = Curl_ftpsendf((int *)v4, "%s", v28);
      if ( result )
        return result;
      result = Curl_GetFTPResponse(&v35, (int *)v4, &v36);
      if ( result )
        return result;
      if ( !v29 && v36 >= 400 )
        break;
    }
    v27 = *(_DWORD *)(v27 + 4);
    if ( !v27 )
      return 0;
  }
  Curl_failf(*(_DWORD *)v4, "QUOT string not accepted: %s", v28);
  return 21;
}
// E4496: using guessed type char byte_E4496;
// F3BEC: using guessed type int (__fastcall *Curl_cstrdup)(_DWORD);
// F3BF4: using guessed type int (__fastcall *Curl_cfree)(_DWORD);

//----- (0007EF1C) --------------------------------------------------------
int __fastcall sub_7EF1C(int result, signed int a2)
{
  _DWORD *v2; // r6
  signed int v3; // r7
  signed int v4; // r10
  _DWORD *v5; // r3
  int v6; // r2
  int v7; // r8
  int v8; // r2
  int v9; // r12
  _DWORD *v10; // r4
  bool v11; // zf
  int (__fastcall *v12)(_DWORD *, int *, _DWORD); // r12
  int v13; // [sp+4h] [bp-2Ch]
  int v14; // [sp+8h] [bp-28h]
  int v15; // [sp+Ch] [bp-24h]

  v2 = (_DWORD *)result;
  if ( a2 )
  {
    a2 = 1;
    v4 = 3;
    v3 = 1;
  }
  else if ( *(_BYTE *)(result + 28) & 8 )
  {
    v3 = 3;
    v4 = 3;
  }
  else
  {
    a2 = 1;
    v3 = 1;
    v4 = 1;
  }
  v5 = *(_DWORD **)(result + 64);
  if ( !v5 )
  {
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 0;
    return result;
  }
  v6 = *(_DWORD *)(result + 16);
  result = *(_DWORD *)(result + 20);
  if ( v6 || result )
  {
    v7 = v2[3];
    v14 = v2[4];
    v8 = v7 - v6;
    v15 = result;
    result += v8;
    if ( a2 )
      v8 = 0;
    v13 = result;
    if ( a2 )
    {
      v2[4] = v8;
      v2[5] = v8;
    }
    do
    {
      while ( 1 )
      {
        v9 = v5[4];
        v10 = (_DWORD *)*v5;
        if ( (v4 & v9) == v3 )
          break;
LABEL_13:
        v5 = v10;
        if ( !v10 )
          return result;
      }
      v11 = (v9 & 0x40000) == 0;
      v12 = (int (__fastcall *)(_DWORD *, int *, _DWORD))v5[2];
      if ( v11 )
      {
        result = v12(v2, &v13, v5[3]);
        goto LABEL_13;
      }
      result = ((int (__fastcall *)(_DWORD *, int, int, _DWORD))v12)(v2, v13, v7, v5[3]);
      v5 = v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (0007F02C) --------------------------------------------------------
_DWORD *__fastcall sub_7F02C(unsigned int a1)
{
  size_t v1; // r4
  unsigned int v2; // r3
  _DWORD *result; // r0
  _DWORD *v4; // r5

  if ( a1 > 0x7FFFFFE7 )
    return 0;
  v1 = a1 + 24;
  if ( a1 + 24 <= 0x3FFFFFFE )
  {
    if ( v1 <= 0x200 )
    {
      v1 = 512;
    }
    else
    {
      v2 = 512;
      do
        v2 *= 2;
      while ( v1 > v2 );
      v1 = v2;
    }
  }
  result = sub_89108(v1);
  v4 = result;
  if ( result )
  {
    memset(result, 0, 0x18u);
    v4[1] = v1 - 24;
    v4[5] = v4 + 6;
    result = v4;
  }
  return result;
}

//----- (0007F0AC) --------------------------------------------------------
int __fastcall sub_7F0AC(int *a1)
{
  _DWORD *v1; // r7
  int v2; // r8
  char *v3; // r4
  int v4; // r9
  unsigned int v5; // r10
  unsigned int v6; // r5
  size_t v7; // r6
  char *v8; // r11
  char *v9; // r0
  signed int v10; // r3
  bool v11; // cf
  bool v12; // zf
  int v13; // r10
  int result; // r0
  int v15; // [sp+4h] [bp-34h]
  int v16; // [sp+8h] [bp-30h]
  int *v17; // [sp+Ch] [bp-2Ch]

  v1 = (_DWORD *)a1[1];
  v2 = a1[2];
  v17 = a1;
  if ( v1 )
  {
    v16 = *a1;
    while ( 1 )
    {
      v15 = v1[5] + v1[2];
      v3 = (char *)(v15 + v2);
      v4 = v1[3] - v2;
      v5 = v15 + v1[3];
      if ( v15 + v2 < v5 )
      {
        while ( 1 )
        {
          v6 = (unsigned int)(v3 + 128);
          v7 = v5 - (_DWORD)v3;
          if ( v5 > (unsigned int)(v3 + 128) )
            v7 = 128;
          v8 = (char *)memchr(v3, 13, v7);
          v9 = (char *)memchr(v3, 10, v7);
          v3 += 128;
          if ( v8 )
            break;
          if ( v9 )
            goto LABEL_16;
          if ( v5 <= v6 )
            goto LABEL_18;
        }
        v10 = (signed int)v9;
        if ( v9 )
          v10 = 1;
        v11 = 1;
        v12 = v9 == 0;
        if ( v9 )
        {
          v11 = v8 >= v9;
          v12 = v8 == v9;
        }
        if ( v12 || !v11 )
        {
          v9 = v8;
LABEL_16:
          v13 = (int)&v9[-v15];
          result = (int)&v9[v16 - v2 - v15];
          *v17 = result;
          v17[1] = (int)v1;
          v17[2] = v13;
          return result;
        }
        if ( v10 )
          goto LABEL_16;
      }
LABEL_18:
      v1 = (_DWORD *)*v1;
      *v17 = v16 + v4;
      if ( !v1 )
        break;
      v16 += v4;
      v2 = 0;
    }
  }
  return -1;
}

//----- (0007F1C0) --------------------------------------------------------
int *__fastcall sub_7F1C0(int **a1, _DWORD *a2)
{
  int **v2; // r4
  int *result; // r0
  _DWORD *v4; // r5
  int v5; // r3
  int v6; // r2

  v2 = a1;
  result = *a1;
  v4 = a2;
  if ( result )
  {
    do
    {
      v5 = *result;
      v6 = result[1];
      if ( *result )
        *(_DWORD *)(v5 + 4) = v6;
      else
        *v4 = v6;
      *(_DWORD *)result[1] = v5;
      sub_8B130(result);
      result = *v2;
    }
    while ( *v2 );
  }
  return result;
}

//----- (0007F208) --------------------------------------------------------
signed int __fastcall sub_7F208(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r3
  int v4; // r5
  _DWORD *v5; // r12
  _DWORD *v6; // r4
  unsigned int v7; // r3
  signed int result; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r6
  _DWORD *v11; // r12
  int v12; // r1
  int v13; // r2

  v3 = *(_DWORD *)(a1 + 4);
  v4 = a1;
  if ( v3 && *(_DWORD *)(v3 + 16) & 0x10 )
  {
    v5 = *(_DWORD **)(a1 + 8);
    v6 = (_DWORD *)*v5;
    if ( !(*(_DWORD *)(*v5 + 16) & 0x10) )
    {
      v5 = (_DWORD *)*v5;
      v6 = (_DWORD *)*v6;
    }
    v7 = v6[3];
    *a2 = v6;
    *a3 = *(_DWORD *)(a1 + 4);
    if ( v7 )
    {
      v9 = sub_7F02C(v7);
      v10 = v9;
      if ( v9 )
      {
        memcpy((void *)v9[5], (const void *)(v6[5] + v6[2]), v6[3]);
        v11 = *(_DWORD **)(v4 + 8);
        v12 = v6[2];
        result = 0;
        v10[3] = v6[3];
        v13 = v6[3];
        *v11 = v10;
        *(_DWORD *)(v4 + 4) = v10;
        v6[2] = v12 + v13;
        v6[3] = 0;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      result = 0;
      *(_DWORD *)(v4 + 4) = **(_DWORD **)(v4 + 8);
      *v5 = 0;
    }
  }
  else
  {
    *a3 = 0;
    result = 0;
    *a2 = 0;
  }
  return result;
}

//----- (0007F2E8) --------------------------------------------------------
int __fastcall sub_7F2E8(_DWORD *a1, unsigned int *a2, char *a3, size_t a4)
{
  unsigned int v4; // r12
  char *v5; // r7
  size_t v6; // r6
  _DWORD *v7; // r4
  int v8; // r3
  bool v9; // zf
  int result; // r0
  unsigned int v11; // r2
  size_t v12; // r5
  const void *v13; // r1

  v4 = *a2;
  v5 = a3;
  v6 = a4;
  if ( (*a2 & 0x80000000) != 0 || ~a4 < v4 || a4 + v4 > *a1 )
    return -1;
  v7 = (_DWORD *)a2[1];
  v8 = a2[2];
  v9 = v6 == 0;
  if ( v6 )
    v9 = v7 == 0;
  for ( result = !v9; result; result = v7 ? (unsigned __int8)(v6 != 0) : 0 )
  {
    v11 = v7[3];
    v12 = v6;
    if ( v8 + v6 > v11 )
      v12 = v11 - v8;
    v13 = v5;
    v5 += v12;
    result = memcmp((const void *)(v7[5] + v8 + v7[2]), v13, v12);
    v8 = result;
    if ( result )
      break;
    v6 -= v12;
    v7 = (_DWORD *)*v7;
  }
  return result;
}

//----- (0007F3A8) --------------------------------------------------------
_DWORD *__fastcall sub_7F3A8(_DWORD *result, int a2, signed int a3)
{
  unsigned int v3; // r4
  signed int v4; // r2
  unsigned int v5; // r3
  char *v6; // lr
  unsigned int v7; // r12
  _BOOL4 v8; // r3
  signed int v9; // r3
  int v10; // r2
  int v11; // [sp+0h] [bp-410h]
  char v12; // [sp+4h] [bp-40Ch]
  _DWORD v13[2]; // [sp+400h] [bp-10h]

  v3 = a3;
  if ( a3 < 0 )
    return (_DWORD *)-1;
  if ( result )
  {
    if ( a3 )
    {
      v4 = result[4] & 2;
      if ( v4 )
      {
        result = 0;
      }
      else
      {
        v5 = result[3];
        v11 = result[5] + result[2];
        if ( v3 < v5 )
        {
          v9 = 0;
          v10 = 1;
        }
        else
        {
          v6 = &v12;
          do
          {
            ++v4;
            result = (_DWORD *)*result;
            v7 = v3 - v5;
            *(_DWORD *)v6 = v5;
            v8 = v4 <= 127;
            v3 = v7;
            if ( !result )
              v8 = 0;
            if ( !v8 || !v7 || result[4] & 2 )
              return (_DWORD *)writev(a2, (const struct iovec *)&v11, v4);
            v5 = result[3];
            v6 += 8;
            *((_DWORD *)v6 - 1) = result[5] + result[2];
          }
          while ( v5 <= v7 );
          v9 = v4;
          v10 = v4 + 1;
          v3 = v7;
        }
        v13[2 * v9 - 255] = v3;
        result = (_DWORD *)writev(a2, (const struct iovec *)&v11, v10);
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (0007F4BC) --------------------------------------------------------
void __fastcall sub_7F4BC(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r6
  void **v3; // r5
  _DWORD *v4; // r7
  void *v5; // r4
  int v6; // r2
  int v7; // r3
  int v8; // r2
  _DWORD *v9; // r3
  _DWORD *v10; // r8
  void (__fastcall *v11)(_DWORD, _DWORD, _DWORD); // r3

  v2 = a1;
  v3 = (void **)a1[2];
  v4 = a2;
  v5 = *v3;
  if ( *v3 )
  {
    while ( 1 )
    {
      if ( !*((_DWORD *)v5 + 3) )
      {
        v6 = *((_DWORD *)v5 + 4);
        v7 = *((_DWORD *)v5 + 4) & 0x30;
        if ( !(v6 & 0x30) )
          break;
      }
      v3 = (void **)v5;
      v5 = *(void **)v5;
      if ( !v5 )
      {
        v8 = a2[3];
        v9 = (_DWORD *)a1[1];
        if ( v8 )
          v5 = (void *)a2[3];
        *v9 = a2;
        if ( v8 )
          a1[2] = v9;
        goto LABEL_9;
      }
    }
    while ( 1 )
    {
      v10 = *(_DWORD **)v5;
      if ( v7 )
      {
        *((_DWORD *)v5 + 4) = v6 | 0x40;
      }
      else
      {
        if ( v6 & 7 )
        {
          if ( v6 & 4 )
          {
            v11 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD))*((_DWORD *)v5 + 6);
            if ( v11 )
            {
              v11(*((_DWORD *)v5 + 5), *((_DWORD *)v5 + 1), *((_DWORD *)v5 + 7));
              v6 = *((_DWORD *)v5 + 4);
            }
          }
          if ( v6 & 1 )
          {
            if ( munmap(*((void **)v5 + 5), *((_DWORD *)v5 + 1)) == -1 )
              sub_908B8("%s: munmap failed", "evbuffer_chain_free");
            if ( close(*((_DWORD *)v5 + 6)) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v5 + 6));
            v6 = *((_DWORD *)v5 + 4);
          }
          if ( v6 & 2 && close(*((_DWORD *)v5 + 6)) == -1 )
            sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v5 + 6));
        }
        sub_8B130(v5);
      }
      if ( !v10 )
        break;
      v6 = v10[4];
      v5 = v10;
      v7 = v10[4] & 0x30;
    }
    v5 = (void *)v4[3];
    *v3 = v4;
LABEL_9:
    v2[1] = v4;
  }
  else
  {
    a1[1] = a2;
    *a1 = a2;
    v5 = (void *)a2[3];
  }
  v2[3] += v5;
}

//----- (0007F68C) --------------------------------------------------------
_DWORD *__fastcall sub_7F68C(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // r5
  _DWORD **v3; // r6
  _DWORD *v4; // r4
  int v5; // r3
  unsigned int v6; // r2
  int v8; // r3
  size_t v9; // r2
  unsigned int v10; // r0
  unsigned int v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r7
  int v14; // r3
  int v15; // r1
  void *v16; // r0
  _DWORD *v17; // r2
  int v18; // r3
  void (__fastcall *v19)(_DWORD, _DWORD, _DWORD); // r12
  void *v20; // r0

  v2 = a1;
  v3 = (_DWORD **)a1[2];
  v4 = *v3;
  if ( !*v3 )
    goto LABEL_6;
  v5 = v4[4];
  if ( v5 & 8 || v4[1] == v4[2] + v4[3] )
  {
    v3 = (_DWORD **)*v3;
    v4 = (_DWORD *)*v4;
    if ( !v4 )
      goto LABEL_6;
    v5 = v4[4];
  }
  v6 = v5 & 0x38;
  if ( v5 & 0x38 )
  {
LABEL_6:
    v4 = sub_7F02C(a2);
    if ( v4 )
      sub_7F4BC(v2, v4);
    return v4;
  }
  v8 = v5 & 8;
  if ( !v8 )
    v6 = v4[1] - v4[3] - v4[2];
  if ( v6 < a2 )
  {
    v9 = v4[3];
    if ( !v9 )
      goto LABEL_6;
    v10 = v4[1];
    if ( a2 <= v10 - v9 && v9 < v10 >> 1 && v9 <= 0x800 )
    {
      memmove((void *)v4[5], (const void *)(v4[5] + v4[2]), v9);
      v4[2] = 0;
      return v4;
    }
    if ( v8 )
      v11 = 0;
    else
      v11 = v10 - (v9 + v4[2]);
    if ( v11 < v10 >> 3 || v9 > 0x1000 || a2 <= 0x7FFFFFFE && v9 <= 0x7FFFFFFF - a2 )
    {
      v4 = (_DWORD *)*v4;
      if ( v4 && !(v4[4] & 8) && a2 <= v4[1] - v4[3] - v4[2] )
        return v4;
      goto LABEL_6;
    }
    v12 = sub_7F02C(a2 + v9);
    v13 = v12;
    if ( v12 )
    {
      v14 = v4[2];
      v15 = v4[5];
      v16 = (void *)v12[5];
      v13[3] = v4[3];
      memcpy(v16, (const void *)(v15 + v14), v4[3]);
      *v3 = v13;
      v17 = (_DWORD *)*v4;
      v18 = v4[4];
      if ( (_DWORD *)v2[1] == v4 )
        v2[1] = v13;
      *v13 = v17;
      if ( v18 & 0x30 )
      {
        v4[4] = v18 | 0x40;
        v4 = v13;
      }
      else
      {
        if ( v18 & 7 )
        {
          if ( v18 & 4 )
          {
            v19 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD))v4[6];
            if ( v19 )
            {
              v19(v4[5], v4[1], v4[7]);
              v18 = v4[4];
            }
          }
          if ( v18 & 1 )
          {
            if ( munmap((void *)v4[5], v4[1]) == -1 )
              sub_908B8("%s: munmap failed", "evbuffer_chain_free");
            if ( close(v4[6]) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v4[6]);
            v18 = v4[4];
          }
          if ( v18 & 2 && close(v4[6]) == -1 )
            sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v4[6]);
        }
        v20 = v4;
        v4 = v13;
        sub_8B130(v20);
      }
    }
    else
    {
      v4 = v12;
    }
  }
  return v4;
}

//----- (0007FA70) --------------------------------------------------------
_DWORD *sub_7FA70()
{
  _DWORD *result; // r0

  result = sub_89134(1u, 0x4Cu);
  if ( result )
  {
    result[16] = 0;
    result[2] = result;
    result[17] = result + 16;
    result[10] = 1;
  }
  return result;
}

//----- (0007FCB4) --------------------------------------------------------
signed int __fastcall sub_7FCB4(int a1, int a2)
{
  int v2; // r4
  char v3; // r2
  signed int result; // r0
  int v5; // r2
  char v6; // r3

  v2 = a1;
  if ( *(_DWORD *)(a1 + 24) )
    return -1;
  if ( a2 )
  {
    v3 = *(_BYTE *)(a1 + 28);
    result = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(v2 + 24) = a2;
    *(_BYTE *)(v2 + 28) = v3 & 0xFE;
    return result;
  }
  if ( !dword_2F8504 )
    return -1;
  v5 = dword_2F8504(1);
  if ( !v5 )
    return -1;
  v6 = *(_BYTE *)(v2 + 28);
  result = 0;
  *(_DWORD *)(v2 + 24) = v5;
  *(_BYTE *)(v2 + 28) = v6 | 1;
  return result;
}
// 2F8504: using guessed type int (__fastcall *dword_2F8504)(_DWORD);

//----- (0007FD48) --------------------------------------------------------
int __fastcall sub_7FD48(int result, int a2)
{
  int v2; // r6
  int v3; // r4
  int v4; // r1

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(result + 24) )
  {
    result = dword_2F850C(0);
    v4 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 72) = v2;
    if ( v4 )
      result = dword_2F8510(0);
  }
  else
  {
    *(_DWORD *)(result + 72) = a2;
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0007FD9C) --------------------------------------------------------
int __fastcall sub_7FD9C(int result)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = (_DWORD *)result;
  if ( !*(_DWORD *)(result + 64) )
  {
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 0;
    return result;
  }
  if ( *(_BYTE *)(result + 28) & 8 )
  {
    result = *(_BYTE *)(result + 52) & 1;
    if ( result )
      return result;
    if ( v1[6] )
      dword_2F850C(0);
    v2 = v1[18];
    ++v1[10];
    if ( v2 )
      sub_8431C(v2);
    if ( v1[6] )
      dword_2F8510(0);
    sub_8900C(v1[9], (int)(v1 + 11));
  }
  return sub_7EF1C((int)v1, 0);
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0007FE4C) --------------------------------------------------------
void __fastcall sub_7FE4C(int a1)
{
  int v1; // r2
  bool v2; // zf
  int v3; // r7
  int v4; // r1
  void *v5; // r4
  int v6; // r3
  void *v7; // r5
  void (__fastcall *v8)(_DWORD, _DWORD, _DWORD); // r12

  v1 = *(_DWORD *)(a1 + 40) - 1;
  v2 = *(_DWORD *)(a1 + 40) == 1;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 40) = v1;
  if ( v1 < 0 || v2 )
  {
    v5 = *(void **)a1;
    if ( *(_DWORD *)a1 )
    {
      while ( 1 )
      {
        v6 = *((_DWORD *)v5 + 4);
        v7 = *(void **)v5;
        if ( v6 & 0x30 )
        {
          *((_DWORD *)v5 + 4) = v6 | 0x40;
        }
        else
        {
          if ( v6 & 7 )
          {
            if ( v6 & 4 )
            {
              v8 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD))*((_DWORD *)v5 + 6);
              if ( v8 )
              {
                v8(*((_DWORD *)v5 + 5), *((_DWORD *)v5 + 1), *((_DWORD *)v5 + 7));
                v6 = *((_DWORD *)v5 + 4);
              }
            }
            if ( v6 & 1 )
            {
              if ( munmap(*((void **)v5 + 5), *((_DWORD *)v5 + 1)) == -1 )
                sub_908B8("%s: munmap failed", "evbuffer_chain_free");
              if ( close(*((_DWORD *)v5 + 6)) == -1 )
                sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v5 + 6));
              v6 = *((_DWORD *)v5 + 4);
            }
            if ( v6 & 2 && close(*((_DWORD *)v5 + 6)) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v5 + 6));
          }
          sub_8B130(v5);
        }
        if ( !v7 )
          break;
        v5 = v7;
      }
    }
    sub_7F1C0((int **)(v3 + 64), (_DWORD *)(v3 + 68));
    if ( *(_BYTE *)(v3 + 28) & 8 )
      sub_88F4C(*(_DWORD *)(v3 + 36), (int *)(v3 + 44));
    if ( *(_DWORD *)(v3 + 24) )
      dword_2F8510(0);
    if ( *(_BYTE *)(v3 + 28) & 1 && *(_DWORD *)(v3 + 24) && dword_2F8508 )
      dword_2F8508();
    sub_8B130((void *)v3);
  }
  else if ( v4 )
  {
    dword_2F8510(0);
  }
}
// 2F8508: using guessed type int (*dword_2F8508)(void);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008006C) --------------------------------------------------------
void __fastcall sub_8006C(int a1, int a2)
{
  int v2; // r4
  int v3; // r5

  v2 = a2;
  if ( *(_DWORD *)(a2 + 24) )
    dword_2F850C(0);
  v3 = *(_DWORD *)(v2 + 72);
  sub_7EF1C(v2, 1);
  sub_7FE4C(v2);
  if ( v3 )
    sub_84BEC(v3);
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);

//----- (000800C4) --------------------------------------------------------
void __fastcall sub_800C4(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  sub_7FE4C(v1);
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);

//----- (00080154) --------------------------------------------------------
int __fastcall sub_80154(int a1)
{
  int v1; // r4
  int v2; // r1
  int v3; // r4

  v1 = a1;
  if ( !*(_DWORD *)(a1 + 24) )
    return *(_DWORD *)(a1 + 12);
  dword_2F850C(0);
  v2 = *(_DWORD *)(v1 + 24);
  v3 = *(_DWORD *)(v1 + 12);
  if ( v2 )
    dword_2F8510(0);
  return v3;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008048C) --------------------------------------------------------
signed int __fastcall sub_8048C(int a1, int a2)
{
  int v2; // r6
  unsigned int v3; // r5
  unsigned int v4; // r8
  int v5; // r4
  bool v6; // zf
  int v7; // r8
  int v8; // r5
  bool v9; // zf
  signed int v10; // r5
  void *v11; // r5
  int v12; // r3
  void *v13; // r9
  void (__fastcall *v14)(_DWORD, _DWORD, _DWORD); // r12
  int v15; // r3
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r2
  int v20; // r3
  unsigned int v21; // r4
  unsigned int v22; // r1
  bool v23; // zf
  unsigned int v25; // r3
  int v26; // r1
  int v27; // r2
  int v28; // r12
  int v29; // r0
  int v30; // [sp+10h] [bp-30h]
  int v31; // [sp+14h] [bp-2Ch]

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a1 + 24);
  v5 = a2;
  v6 = v4 == 0;
  if ( v4 )
    v6 = v3 == 0;
  if ( !v6 && v3 > v4 )
  {
    v3 = *(_DWORD *)(a1 + 24);
    v4 = *(_DWORD *)(a2 + 24);
  }
  if ( v3 )
    ((void (__fastcall *)(_DWORD, unsigned int))dword_2F850C)(0, v3);
  if ( v4 != v3 && v4 )
    ((void (__fastcall *)(_DWORD, unsigned int))dword_2F850C)(0, v4);
  v7 = *(_DWORD *)(v5 + 12);
  v8 = *(_DWORD *)(v2 + 12);
  v9 = v7 == 0;
  if ( v7 )
    v9 = v2 == v5;
  if ( v9 )
  {
    v10 = 0;
  }
  else if ( *(_BYTE *)(v2 + 28) & 4 || *(_BYTE *)(v5 + 28) & 2 || sub_7F208(v5, &v30, &v31) < 0 )
  {
    v10 = -1;
  }
  else
  {
    if ( v8 )
    {
      v26 = *(_DWORD *)(v5 + 4);
      v27 = *(_DWORD *)(v5 + 8);
      v28 = *(_DWORD *)(v2 + 12);
      v29 = *(_DWORD *)(v5 + 12);
      if ( v27 == v5 )
        v27 = *(_DWORD *)(v2 + 4);
      **(_DWORD **)(v2 + 4) = *(_DWORD *)v5;
      *(_DWORD *)(v2 + 4) = v26;
      *(_DWORD *)(v2 + 8) = v27;
      *(_DWORD *)(v2 + 12) = v28 + v29;
    }
    else
    {
      v11 = *(void **)v2;
      if ( *(_DWORD *)v2 )
      {
        while ( 1 )
        {
          v12 = *((_DWORD *)v11 + 4);
          v13 = *(void **)v11;
          if ( v12 & 0x30 )
          {
            *((_DWORD *)v11 + 4) = v12 | 0x40;
          }
          else
          {
            if ( v12 & 7 )
            {
              if ( v12 & 4 )
              {
                v14 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD))*((_DWORD *)v11 + 6);
                if ( v14 )
                {
                  v14(*((_DWORD *)v11 + 5), *((_DWORD *)v11 + 1), *((_DWORD *)v11 + 7));
                  v12 = *((_DWORD *)v11 + 4);
                }
              }
              if ( v12 & 1 )
              {
                if ( munmap(*((void **)v11 + 5), *((_DWORD *)v11 + 1)) == -1 )
                  sub_908B8("%s: munmap failed", "evbuffer_chain_free");
                if ( close(*((_DWORD *)v11 + 6)) == -1 )
                  sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v11 + 6));
                v12 = *((_DWORD *)v11 + 4);
              }
              if ( v12 & 2 && close(*((_DWORD *)v11 + 6)) == -1 )
                sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v11 + 6));
            }
            sub_8B130(v11);
          }
          if ( !v13 )
            break;
          v11 = v13;
        }
      }
      v15 = *(_DWORD *)(v5 + 8);
      v16 = *(_DWORD *)(v5 + 4);
      v17 = *(_DWORD *)(v5 + 12);
      *(_DWORD *)v2 = *(_DWORD *)v5;
      if ( v15 == v5 )
        v15 = v2;
      *(_DWORD *)(v2 + 12) = v17;
      *(_DWORD *)(v2 + 4) = v16;
      *(_DWORD *)(v2 + 8) = v15;
    }
    v18 = v30;
    v19 = v31;
    v10 = 0;
    v6 = v30 == 0;
    *(_DWORD *)v5 = v30;
    if ( v6 )
    {
      *(_DWORD *)(v5 + 4) = v18;
      *(_DWORD *)(v5 + 8) = v5;
    }
    else
    {
      v18 = 0;
      *(_DWORD *)(v5 + 4) = v19;
      *(_DWORD *)(v5 + 8) = v5;
    }
    *(_DWORD *)(v5 + 12) = v18;
    v20 = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v5 + 20) += v7;
    *(_DWORD *)(v2 + 16) = v20 + v7;
    sub_7FD9C(v5);
    sub_7FD9C(v2);
  }
  v21 = *(_DWORD *)(v5 + 24);
  v22 = *(_DWORD *)(v2 + 24);
  v23 = v21 == 0;
  if ( v21 )
    v23 = v22 == 0;
  if ( v23 || v21 <= v22 )
  {
    if ( v21 == v22 )
      goto LABEL_46;
  }
  else
  {
    v25 = v21;
    v21 = *(_DWORD *)(v2 + 24);
    v22 = v25;
  }
  if ( v22 )
    dword_2F8510(0);
LABEL_46:
  if ( v21 )
    ((void (__fastcall *)(_DWORD, unsigned int))dword_2F8510)(0, v21);
  return v10;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00080B2C) --------------------------------------------------------
unsigned int __fastcall sub_80B2C(int a1, unsigned int a2)
{
  unsigned int v2; // r7
  int v3; // r5
  unsigned int v4; // r6
  unsigned int v5; // r3
  int v6; // r2
  void **v7; // r4
  unsigned int v8; // r3
  void **v9; // r7
  void (__fastcall *v10)(void *, void *, void *); // r12
  unsigned int v12; // r6
  void **i; // r4
  unsigned int v14; // r1
  void **v15; // r3
  void **v16; // r8
  bool v17; // zf
  unsigned int v18; // r3
  void (__fastcall *v19)(void *, void *, void *); // r12
  int v20; // r2
  char *v21; // r3
  char *v22; // r2

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  v4 = *(_DWORD *)(v3 + 12);
  if ( !v4 )
    goto LABEL_23;
  v5 = ((unsigned int)*(unsigned __int8 *)(v3 + 28) >> 1) & 1;
  if ( v5 )
  {
    v4 = -1;
    goto LABEL_23;
  }
  if ( v4 > v2 )
  {
    if ( v2 >= v4 )
      v2 = *(_DWORD *)(v3 + 12);
    v5 = v4 - v2;
  }
  else
  {
    v6 = *(_DWORD *)(v3 + 4);
    if ( !v6 || !(*(_DWORD *)(v6 + 16) & 0x10) )
    {
      v7 = *(void ***)v3;
      if ( *(_DWORD *)v3 )
      {
        while ( 1 )
        {
          v8 = (unsigned int)v7[4];
          v9 = (void **)*v7;
          if ( v8 & 0x30 )
          {
            v7[4] = (void *)(v8 | 0x40);
          }
          else
          {
            if ( v8 & 7 )
            {
              if ( v8 & 4 )
              {
                v10 = (void (__fastcall *)(void *, void *, void *))v7[6];
                if ( v10 )
                {
                  v10(v7[5], v7[1], v7[7]);
                  v8 = (unsigned int)v7[4];
                }
              }
              if ( v8 & 1 )
              {
                if ( munmap(v7[5], (size_t)v7[1]) == -1 )
                  sub_908B8("%s: munmap failed", "evbuffer_chain_free");
                if ( close((int)v7[6]) == -1 )
                  sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v7[6]);
                v8 = (unsigned int)v7[4];
              }
              if ( v8 & 2 && close((int)v7[6]) == -1 )
                sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v7[6]);
            }
            sub_8B130(v7);
          }
          if ( !v9 )
            break;
          v7 = v9;
        }
      }
      v2 = v4;
      *(_DWORD *)(v3 + 8) = v3;
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)(v3 + 12) = 0;
      goto LABEL_22;
    }
    v2 = *(_DWORD *)(v3 + 12);
  }
  *(_DWORD *)(v3 + 12) = v5;
  v12 = v2;
  for ( i = *(void ***)v3; ; i = v16 )
  {
    v14 = (unsigned int)i[3];
    if ( v12 < v14 )
    {
      v20 = (int)i[2];
      v21 = (char *)i[3];
      goto LABEL_55;
    }
    v15 = *(void ***)(v3 + 8);
    v12 -= v14;
    v16 = (void **)*i;
    if ( *v15 == i )
    {
      *(_DWORD *)(v3 + 8) = v3;
      v15 = (void **)v3;
    }
    v17 = i == v15;
    v18 = (unsigned int)i[4];
    if ( v17 )
      *(_DWORD *)(v3 + 8) = v3;
    if ( v18 & 0x10 )
      break;
    if ( !(v18 & 0x30) )
    {
      if ( v18 & 7 )
      {
        if ( v18 & 4 )
        {
          v19 = (void (__fastcall *)(void *, void *, void *))i[6];
          if ( v19 )
          {
            v19(i[5], i[1], i[7]);
            v18 = (unsigned int)i[4];
          }
        }
        if ( v18 & 1 )
        {
          if ( munmap(i[5], (size_t)i[1]) == -1 )
            sub_908B8("%s: munmap failed", "evbuffer_chain_free");
          if ( close((int)i[6]) == -1 )
            sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", i[6]);
          if ( (unsigned int)i[4] & 2 )
          {
LABEL_51:
            if ( close((int)i[6]) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", i[6]);
          }
        }
        else if ( v18 & 2 )
        {
          goto LABEL_51;
        }
      }
      sub_8B130(i);
      continue;
    }
    i[4] = (void *)(v18 | 0x40);
  }
  v22 = (char *)i[2];
  v21 = 0;
  i[3] = 0;
  v20 = (int)&v22[v14];
  i[2] = (void *)v20;
LABEL_55:
  *(_DWORD *)v3 = i;
  i[2] = (void *)(v20 + v12);
  i[3] = &v21[-v12];
LABEL_22:
  v4 = 0;
  *(_DWORD *)(v3 + 20) += v2;
  sub_7FD9C(v3);
LABEL_23:
  if ( *(_DWORD *)(v3 + 24) )
    dword_2F8510(0);
  return v4;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00080F04) --------------------------------------------------------
unsigned int __fastcall sub_80F04(int a1, char *a2, unsigned int a3)
{
  char *v3; // r6
  int v4; // r7
  unsigned int v5; // r5
  unsigned int v6; // r8
  _DWORD *v7; // r4
  size_t v8; // r5
  size_t v9; // r2
  int v10; // r3

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  v6 = *(_DWORD *)(v4 + 12);
  v7 = *(_DWORD **)v4;
  if ( v5 < v6 )
    v6 = v5;
  if ( v6 )
  {
    if ( *(_BYTE *)(v4 + 28) & 2 )
    {
      v6 = -1;
    }
    else
    {
      v8 = v6;
      while ( 1 )
      {
        v9 = v7[3];
        if ( v9 > v8 )
          break;
        memcpy(v3, (const void *)(v7[5] + v7[2]), v9);
        v10 = v7[3];
        v7 = (_DWORD *)*v7;
        v8 -= v10;
        v3 += v10;
        if ( !v8 )
          goto LABEL_10;
      }
      memcpy(v3, (const void *)(v7[5] + v7[2]), v8);
    }
  }
LABEL_10:
  if ( *(_DWORD *)(v4 + 24) )
    dword_2F8510(0);
  return v6;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00080FE4) --------------------------------------------------------
signed int __fastcall sub_80FE4(int a1, char *a2, unsigned int a3)
{
  char *v3; // r5
  int v4; // r4
  unsigned int v5; // r6
  signed int v6; // r0
  signed int v7; // r5

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  v6 = sub_80F04(v4, v3, v5);
  v7 = v6;
  if ( v6 > 0 && (sub_80B2C(v4, v6) & 0x80000000) != 0 )
    v7 = -1;
  if ( *(_DWORD *)(v4 + 24) )
    dword_2F8510(0);
  return v7;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00081070) --------------------------------------------------------
unsigned int __fastcall sub_81070(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // r9
  void ***v4; // r6
  void **v5; // r10
  unsigned int v6; // r1
  void **v7; // r4
  unsigned int v8; // r0
  unsigned int v9; // r12
  int v10; // r8
  _DWORD *v11; // r3
  unsigned int v12; // r5
  void *v13; // r3
  _BYTE *v14; // r3
  void *v15; // r7
  char *v16; // r7
  void **v17; // r3
  size_t v18; // r2
  signed int v19; // r8
  signed int v20; // r9
  unsigned int v21; // r10
  void **v22; // r11
  _DWORD *v23; // r5
  unsigned int v24; // r2
  void *v25; // r1
  void (__fastcall *v26)(void *, void *, void *); // r12
  _DWORD *v27; // r3
  unsigned int v29; // r3
  char *v30; // r7
  int v31; // r1
  size_t v32; // r11
  unsigned int v33; // ST00_4
  int v34; // r2
  void **v35; // r0
  void **v36; // r3
  void **v37; // [sp+4h] [bp-44h]

  v3 = a2;
  v4 = (void ***)a1;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  v5 = *v4;
  if ( (v3 & 0x80000000) != 0 )
    v3 = (unsigned int)v4[3];
  if ( !v3 )
    goto LABEL_54;
  if ( v3 > (unsigned int)v4[3] )
    goto LABEL_57;
  v6 = (unsigned int)v5[3];
  if ( v3 <= v6 )
    goto LABEL_53;
  v7 = (void **)*v5;
  v8 = v3 - v6;
  v9 = v3 - v6;
  if ( *v5 )
  {
    if ( !((unsigned int)v7[4] & 0x30) )
    {
      a3 = (unsigned int)v7[3];
      if ( v8 > a3 )
      {
        v10 = v3 - v6;
        v11 = *v5;
        do
        {
          v11 = (_DWORD *)*v11;
          v12 = v10 - a3;
          v10 -= a3;
          if ( !v11 )
            break;
          if ( v11[4] & 0x30 )
            goto LABEL_57;
          a3 = v11[3];
        }
        while ( a3 < v12 );
      }
      goto LABEL_15;
    }
LABEL_57:
    v3 = 0;
    goto LABEL_54;
  }
LABEL_15:
  v13 = v5[4];
  if ( (unsigned __int8)v13 & 0x30 )
  {
    if ( (unsigned __int8)v13 & 8 )
    {
      v29 = 0;
    }
    else
    {
      a3 = (unsigned int)v5[1];
      v29 = (unsigned int)v5[2];
    }
    if ( !((unsigned int)v5[4] & 8) )
      v29 = a3 - v6 - v29;
    if ( v29 >= v8 )
    {
      v30 = (char *)v5[5];
      v31 = (int)v5[2] + v6;
      v5[3] = (void *)v3;
      v16 = &v30[v31];
LABEL_18:
      v17 = (void **)*v4[2];
      if ( !v7 )
      {
        v19 = 0;
        v20 = 0;
LABEL_47:
        v23 = 0;
        v4[1] = v5;
LABEL_48:
        *v5 = v23;
        if ( v20 )
          goto LABEL_65;
        if ( v19 )
        {
          v27 = **v4;
          if ( v27 && v27[3] )
          {
            v4[2] = *v4;
            goto LABEL_53;
          }
LABEL_65:
          v4[2] = (void **)v4;
        }
LABEL_53:
        v3 = (unsigned int)v5[2] + (_DWORD)v5[5];
        goto LABEL_54;
      }
LABEL_19:
      v18 = (size_t)v7[3];
      if ( v9 >= v18 )
      {
        v19 = 0;
        v37 = v5;
        v20 = 0;
        v21 = v9;
        v22 = v17;
        while ( 1 )
        {
          if ( v7 == v22 )
            v20 = 1;
          v23 = *v7;
          memcpy(v16, (char *)v7[2] + (_DWORD)v7[5], v18);
          v24 = (unsigned int)v7[4];
          v25 = v7[3];
          if ( v7 == v4[2] )
            v19 = 1;
          if ( v24 & 0x30 )
            v24 |= 0x40u;
          v21 -= (unsigned int)v25;
          v16 = (char *)v25 + (_DWORD)v16;
          if ( !((unsigned int)v7[4] & 0x30) )
            break;
          v7[4] = (void *)v24;
LABEL_23:
          if ( !v23 )
          {
            v5 = v37;
            goto LABEL_47;
          }
          v18 = v23[3];
          if ( v18 > v21 )
          {
            v32 = v21;
            v5 = v37;
            v9 = v32;
            goto LABEL_67;
          }
          v7 = (void **)v23;
        }
        if ( v24 & 7 )
        {
          if ( v24 & 4 )
          {
            v26 = (void (__fastcall *)(void *, void *, void *))v7[6];
            if ( v26 )
            {
              v26(v7[5], v7[1], v7[7]);
              v24 = (unsigned int)v7[4];
            }
          }
          if ( v24 & 1 )
          {
            if ( munmap(v7[5], (size_t)v7[1]) == -1 )
              sub_908B8("%s: munmap failed", "evbuffer_chain_free");
            if ( close((int)v7[6]) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v7[6]);
            if ( !((unsigned int)v7[4] & 2) )
              goto LABEL_22;
            goto LABEL_44;
          }
          if ( v24 & 2 )
          {
LABEL_44:
            if ( close((int)v7[6]) == -1 )
              sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", v7[6]);
            goto LABEL_22;
          }
        }
LABEL_22:
        sub_8B130(v7);
        goto LABEL_23;
      }
      v19 = 0;
      v23 = v7;
      v20 = 0;
      v32 = v9;
LABEL_67:
      v33 = v9;
      memcpy(v16, (const void *)(v23[5] + v23[2]), v32);
      v34 = v23[3];
      v23[2] += v33;
      v23[3] = v34 - v32;
      goto LABEL_48;
    }
    goto LABEL_57;
  }
  v14 = v5[2];
  if ( v3 <= (_BYTE *)v5[1] - v14 )
  {
    v15 = v5[5];
    v5[3] = (void *)v3;
    v16 = &v14[v6 + (_DWORD)v15];
    goto LABEL_18;
  }
  v35 = (void **)sub_7F02C(v3);
  if ( v35 )
  {
    v36 = v4[2];
    v7 = v5;
    v35[3] = (void *)v3;
    v9 = v3;
    v16 = (char *)v35[5];
    v5 = v35;
    *v4 = v35;
    v17 = (void **)*v36;
    goto LABEL_19;
  }
  v3 = 0;
  sub_908B8("%s: out of memory", "evbuffer_pullup");
LABEL_54:
  if ( v4[6] )
    dword_2F8510(0);
  return v3;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008149C) --------------------------------------------------------
signed int __fastcall sub_8149C(int a1, char *a2, unsigned int a3)
{
  char *v3; // r9
  int v4; // r4
  unsigned int v5; // r6
  _DWORD *v6; // r5
  int v7; // r3
  unsigned int v8; // r0
  size_t v9; // r7
  _DWORD *v10; // r8
  size_t v11; // r6
  signed int v12; // r5
  int v14; // r1
  size_t v15; // r2
  int v16; // r0
  int v17; // r3
  const void *v18; // r1
  int v19; // r3
  int v20; // r2
  int v21; // r2
  int v22; // r3

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  if ( *(_BYTE *)(v4 + 28) & 4 || ~*(_DWORD *)(v4 + 12) < v5 )
    goto LABEL_29;
  v6 = *(_DWORD **)(v4 + 4);
  if ( !v6 )
  {
    v6 = sub_7F02C(v5);
    if ( !v6 )
      goto LABEL_29;
    sub_7F4BC((_DWORD *)v4, v6);
  }
  v7 = v6[4];
  v8 = v6[1];
  if ( v7 & 8 )
  {
    v9 = 0;
    goto LABEL_9;
  }
  v14 = v6[2];
  v15 = v6[3];
  v9 = v8 - v14 - v15;
  if ( v5 <= v9 )
  {
    v16 = v6[5];
    v17 = v14 + v15;
    v18 = v3;
    goto LABEL_28;
  }
  if ( !(v7 & 0x30) && v5 <= v8 - v15 && v15 < v8 >> 1 && v15 <= 0x800 )
  {
    memmove((void *)v6[5], (const void *)(v6[5] + v14), v15);
    v16 = v6[5];
    v17 = v6[3];
    v18 = v3;
    v6[2] = 0;
LABEL_28:
    memcpy((void *)(v16 + v17), v18, v5);
    v21 = *(_DWORD *)(v4 + 16);
    v22 = *(_DWORD *)(v4 + 12) + v5;
    v6[3] += v5;
    *(_DWORD *)(v4 + 12) = v22;
    *(_DWORD *)(v4 + 16) = v21 + v5;
LABEL_17:
    v12 = 0;
    sub_7FD9C(v4);
    goto LABEL_18;
  }
LABEL_9:
  if ( v8 <= 0x800 )
    v8 *= 2;
  if ( v8 < v5 )
    v8 = v5;
  v10 = sub_7F02C(v8);
  if ( v10 )
  {
    if ( v9 )
    {
      memcpy((void *)(v6[5] + v6[2] + v6[3]), v3, v9);
      v19 = *(_DWORD *)(v4 + 16);
      v20 = *(_DWORD *)(v4 + 12) + v9;
      v6[3] += v9;
      *(_DWORD *)(v4 + 12) = v20;
      *(_DWORD *)(v4 + 16) = v19 + v9;
    }
    v11 = v5 - v9;
    memcpy((void *)v10[5], &v3[v9], v11);
    v10[3] = v11;
    sub_7F4BC((_DWORD *)v4, v10);
    *(_DWORD *)(v4 + 16) += v11;
    goto LABEL_17;
  }
LABEL_29:
  v12 = -1;
LABEL_18:
  if ( *(_DWORD *)(v4 + 24) )
    dword_2F8510(0);
  return v12;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00081CD4) --------------------------------------------------------
signed int __fastcall sub_81CD4(int a1, unsigned int a2, int a3)
{
  int v3; // r3
  int v4; // r6
  unsigned int v5; // r5
  int v6; // r12
  void **v7; // r3
  void *v8; // r4
  _DWORD *v9; // r3
  unsigned int v10; // r0
  int v11; // r1
  int v12; // r1
  int v13; // r7
  signed int result; // r0
  _DWORD *v15; // r1
  int v16; // r7
  int v17; // r3
  bool v18; // zf
  signed int v19; // r8
  int v20; // r3
  void *v21; // r9
  void (__fastcall *v22)(_DWORD, _DWORD, _DWORD); // r12
  _DWORD *v23; // r0
  _DWORD *v24; // r2
  _DWORD *v25; // r3
  _DWORD *v26; // r0
  _DWORD *v27; // r3

  v3 = *(_DWORD *)(a1 + 4);
  v4 = a1;
  v5 = a2;
  if ( v3 )
  {
    v6 = *(_DWORD *)(v3 + 16) & 8;
    if ( !v6 )
    {
      v7 = *(void ***)(a1 + 8);
      v8 = *v7;
      if ( *v7 )
      {
        v9 = *v7;
        v10 = 0;
        while ( 1 )
        {
          v12 = v9[3];
          if ( v12 )
          {
            if ( !(v9[4] & 8) )
            {
              v11 = v9[1] - v12 - v9[2];
              if ( v11 )
              {
                v10 += v11;
                ++v6;
              }
            }
            if ( v10 >= v5 )
              return 0;
          }
          else
          {
            v13 = v9[1];
            ++v6;
            v9[2] = 0;
            v10 += v13;
            if ( v10 >= v5 )
              return 0;
          }
          if ( v6 == a3 )
            goto LABEL_17;
          v9 = (_DWORD *)*v9;
          if ( !v9 )
            goto LABEL_50;
        }
      }
      v6 = 0;
      v10 = 0;
LABEL_50:
      if ( v6 < a3 )
      {
        v25 = sub_7F02C(v5 - v10);
        if ( v25 )
        {
          result = 0;
          **(_DWORD **)(v4 + 4) = v25;
          *(_DWORD *)(v4 + 4) = v25;
          return result;
        }
        return -1;
      }
LABEL_17:
      v16 = *((_DWORD *)v8 + 3);
      if ( v16 )
      {
        v17 = *((_DWORD *)v8 + 4);
        v18 = (*((_DWORD *)v8 + 4) & 8) == 0;
        if ( v17 & 8 )
        {
          v16 = 0;
        }
        else
        {
          a3 = *((_DWORD *)v8 + 1);
          v17 = *((_DWORD *)v8 + 2);
        }
        v8 = *(void **)v8;
        if ( v18 )
          v16 = a3 - v16 - v17;
        if ( !v8 )
        {
          v26 = sub_7F02C(v5 - v16);
          v24 = v26;
          if ( v26 )
            goto LABEL_40;
          v19 = 0;
          goto LABEL_58;
        }
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
      while ( 1 )
      {
        v20 = *((_DWORD *)v8 + 4);
        v21 = *(void **)v8;
        if ( v20 & 0x30 )
        {
          *((_DWORD *)v8 + 4) = v20 | 0x40;
        }
        else
        {
          if ( v20 & 7 )
          {
            if ( v20 & 4 )
            {
              v22 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD))*((_DWORD *)v8 + 6);
              if ( v22 )
              {
                v22(*((_DWORD *)v8 + 5), *((_DWORD *)v8 + 1), *((_DWORD *)v8 + 7));
                v20 = *((_DWORD *)v8 + 4);
              }
            }
            if ( v20 & 1 )
            {
              if ( munmap(*((void **)v8 + 5), *((_DWORD *)v8 + 1)) == -1 )
                sub_908B8("%s: munmap failed", "evbuffer_chain_free");
              if ( close(*((_DWORD *)v8 + 6)) == -1 )
                sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v8 + 6));
              v20 = *((_DWORD *)v8 + 4);
            }
            if ( v20 & 2 )
            {
              if ( close(*((_DWORD *)v8 + 6)) == -1 )
                sub_908B8("%s: close(%d) failed", "evbuffer_chain_free", *((_DWORD *)v8 + 6));
            }
          }
          sub_8B130(v8);
        }
        if ( !v21 )
          break;
        v8 = v21;
      }
      v23 = sub_7F02C(v5 - v16);
      v24 = v23;
      if ( v23 )
      {
        if ( v19 )
        {
          *(_DWORD *)(v4 + 4) = v23;
          result = 0;
          *(_DWORD *)v4 = v24;
          *(_DWORD *)(v4 + 8) = v4;
          return result;
        }
LABEL_40:
        result = 0;
        ***(_DWORD ***)(v4 + 8) = v24;
        *(_DWORD *)(v4 + 4) = v24;
        return result;
      }
      if ( v19 )
      {
        *(_DWORD *)v4 = 0;
        result = -1;
        *(_DWORD *)(v4 + 4) = 0;
        *(_DWORD *)(v4 + 8) = v4;
        *(_DWORD *)(v4 + 12) = 0;
        return result;
      }
LABEL_58:
      v27 = *(_DWORD **)(v4 + 8);
      result = -1;
      *(_DWORD *)(v4 + 4) = *v27;
      *(_DWORD *)*v27 = v19;
      return result;
    }
  }
  v15 = sub_7F02C(a2);
  if ( v15 )
  {
    sub_7F4BC((_DWORD *)v4, v15);
    return 0;
  }
  return -1;
}

//----- (00082068) --------------------------------------------------------
signed int __fastcall sub_82068(int a1, unsigned int a2, int a3, signed int a4, _DWORD *a5, int a6)
{
  int v6; // r9
  int v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r12
  bool v10; // zf
  bool v11; // nf
  signed int result; // r0
  int v13; // r8
  unsigned int v14; // r4
  int v15; // r5
  int v16; // r9
  int v17; // r10
  _BOOL4 v18; // r11
  int v19; // r5
  unsigned int v20; // r6
  unsigned int v21; // r6
  int v22; // r5
  int v23; // r10
  int v24; // r4
  _BOOL4 v25; // r11
  int v26; // r4

  v7 = a6;
  if ( (a2 & 0x80000000) != 0 )
    return -1;
  v8 = *(_DWORD **)(a1 + 8);
  v9 = (_DWORD *)*v8;
  if ( *(_DWORD *)(*v8 + 16) & 8 || v9[1] == v9[2] + v9[3] )
  {
    v8 = (_DWORD *)*v8;
    v9 = (_DWORD *)*v9;
  }
  v10 = a2 == 0;
  v11 = (a2 & 0x80000000) != 0;
  if ( a2 )
  {
    v10 = a4 == 0;
    v11 = a4 < 0;
  }
  if ( v11 || v10 )
    result = 0;
  else
    result = 1;
  if ( !v11 && !v10 )
  {
    if ( a6 )
    {
      v13 = 0;
      result = 0;
      v14 = 0;
      do
      {
        v20 = 0;
        if ( v9[4] & 8 )
        {
          v15 = v9[2];
          v16 = v9[3];
        }
        else
        {
          v16 = v9[3];
          v15 = v9[2];
          v20 = v9[1] - v16 - v15;
          if ( v20 >= a2 - v14 )
            v20 = a2 - v14;
        }
        v14 += v20;
        ++result;
        v17 = v9[5];
        v18 = v14 < a2;
        v9 = (_DWORD *)*v9;
        *(_DWORD *)(a3 + v13) = v17 + v16 + v15;
        v19 = a3 + v13;
        if ( a4 <= result )
          v18 = 0;
        v13 += 8;
        *(_DWORD *)(v19 + 4) = v20;
      }
      while ( v18 );
    }
    else
    {
      result = 0;
      v21 = 0;
      do
      {
        v22 = 0;
        ++result;
        v23 = v9[5];
        if ( v9[4] & 8 )
        {
          v24 = v9[2];
        }
        else
        {
          v6 = v9[3];
          v24 = v9[2];
          v22 = v9[1] - v6;
        }
        if ( v9[4] & 8 )
          v6 = v9[3];
        else
          v22 -= v24;
        v21 += v22;
        v9 = (_DWORD *)*v9;
        v6 += v23 + v24;
        v25 = v21 < a2;
        *(_DWORD *)(a3 + v7) = v6;
        v26 = a3 + v7;
        v7 += 8;
        *(_DWORD *)(v26 + 4) = v22;
        if ( a4 <= result )
          v25 = 0;
      }
      while ( v25 );
    }
  }
  *a5 = v8;
  return result;
}

//----- (00082300) --------------------------------------------------------
signed int __fastcall sub_82300(int a1, int a2, signed int a3)
{
  int v3; // r7
  int v4; // r8
  signed int v5; // r6
  signed int v6; // r4
  int v7; // r0
  int v8; // r9
  ssize_t v9; // r0
  signed int v10; // r10
  _DWORD *v11; // r12
  ssize_t v12; // lr
  int v13; // r5
  int v14; // r6
  int v15; // r7
  int v16; // r4
  _DWORD *v17; // r3
  int v18; // r1
  int v19; // r4
  int v20; // r3
  _DWORD *v22; // [sp+Ch] [bp-44h]
  int v23; // [sp+10h] [bp-40h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  if ( *(_BYTE *)(v4 + 28) & 4 )
    goto LABEL_28;
  v6 = 4096;
  v23 = 4096;
  if ( ioctl(v3, 0x541Bu, &v23) >= 0 )
  {
    v6 = v23;
    if ( (unsigned int)(v23 - 1) >= 0x1000 )
      v6 = 4096;
  }
  if ( !((v5 > v6) | ((unsigned int)v5 >> 31)) )
    v6 = v5;
  if ( sub_81CD4(v4, v6, 4) == -1
    || (v7 = sub_82068(v4, v6, (int)&v23, 4, &v22, 1),
        v8 = v7,
        v9 = readv(v3, (const struct iovec *)&v23, v7),
        v10 = v9,
        v9 == -1) )
  {
LABEL_28:
    v10 = -1;
    goto LABEL_22;
  }
  if ( !v9 )
    goto LABEL_22;
  if ( v8 <= 0 )
    goto LABEL_21;
  v11 = v22;
  v12 = v9;
  v13 = 0;
  v14 = (int)v22;
  while ( 1 )
  {
    v17 = *(_DWORD **)v14;
    v18 = 0;
    v19 = 0;
    if ( *(_DWORD *)(*(_DWORD *)v14 + 16) & 8 )
    {
      v15 = v17[3];
      goto LABEL_15;
    }
    v15 = v17[3];
    v19 = v17[1] - v17[3] - v17[2];
    v18 = v19;
    if ( v19 < 0 )
      break;
LABEL_15:
    ++v13;
    v16 = v15 + v19;
    if ( v12 <= v18 )
      goto LABEL_20;
    v11 = (_DWORD *)*v11;
    v17[3] = v16;
    v12 -= v18;
    v14 = (int)v11;
    v22 = v11;
    if ( v13 == v8 )
      goto LABEL_21;
  }
  v15 = v17[3];
LABEL_20:
  v17[3] = v12 + v15;
  *(_DWORD *)(v4 + 8) = v14;
LABEL_21:
  v20 = *(_DWORD *)(v4 + 16);
  *(_DWORD *)(v4 + 12) += v9;
  *(_DWORD *)(v4 + 16) = v20 + v9;
  sub_7FD9C(v4);
LABEL_22:
  if ( *(_DWORD *)(v4 + 24) )
    dword_2F8510(0);
  return v10;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008260C) --------------------------------------------------------
signed int __fastcall sub_8260C(int a1, unsigned int *a2, unsigned int a3, int a4)
{
  unsigned int *v4; // r5
  int v5; // r1
  int v6; // r7
  unsigned int v7; // r4
  int v8; // r8
  signed int v9; // r4
  unsigned int v11; // r3
  unsigned int v12; // r3
  _DWORD *v13; // r0
  unsigned int v14; // r2
  int v15; // r12
  int v16; // r2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 24);
  v6 = a1;
  v7 = a3;
  v8 = a4;
  if ( v5 )
  {
    dword_2F850C(0);
    v5 = *(_DWORD *)(v6 + 24);
  }
  if ( !v8 )
  {
    v12 = 0;
    v13 = *(_DWORD **)v6;
    *v4 = v7;
    goto LABEL_15;
  }
  if ( v8 != 1 )
    goto LABEL_5;
  v11 = *v4;
  if ( (*v4 & 0x80000000) == 0 && ~v7 >= v11 )
  {
    v13 = (_DWORD *)v4[1];
    *v4 = v7 + v11;
    v12 = v4[2];
LABEL_15:
    if ( v13 )
    {
      v14 = v13[3];
      v15 = v12 + v7;
      if ( v14 > v12 + v7 )
      {
LABEL_22:
        v4[1] = (unsigned int)v13;
        v9 = 0;
        v4[2] = v15;
LABEL_6:
        if ( v5 )
          dword_2F8510(0);
        return v9;
      }
      while ( 1 )
      {
        v13 = (_DWORD *)*v13;
        v16 = v12 - v14;
        v12 = 0;
        v7 += v16;
        if ( !v13 )
          break;
        v14 = v13[3];
        if ( v14 > v7 )
        {
          v15 = v7;
          goto LABEL_22;
        }
      }
    }
LABEL_5:
    v9 = -1;
    *v4 = -1;
    v4[1] = 0;
    goto LABEL_6;
  }
  if ( !v5 )
    return -1;
  dword_2F8510(0);
  return -1;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00082754) --------------------------------------------------------
_DWORD *__fastcall sub_82754(_DWORD *a1, int a2, int a3, signed int a4, int *a5, _DWORD *a6)
{
  int v6; // r4
  int v7; // r1
  _DWORD *v8; // r5
  int v9; // r10
  int v10; // r9
  int v11; // r8
  int v12; // r4
  int v13; // r7
  int v14; // r6
  char *v15; // r12
  int v16; // r6
  int v17; // r4
  int v18; // r4
  int v19; // r6
  int v20; // r1
  int v21; // r2
  signed int v23; // [sp+4h] [bp-54h]
  char *v24; // [sp+8h] [bp-50h]
  int c; // [sp+Ch] [bp-4Ch]
  _DWORD *v26; // [sp+10h] [bp-48h]
  int v27; // [sp+14h] [bp-44h]
  _DWORD *v28; // [sp+18h] [bp-40h]
  _DWORD *v29; // [sp+1Ch] [bp-3Ch]
  int v30; // [sp+24h] [bp-34h]
  _DWORD *v31; // [sp+28h] [bp-30h]
  char *v32; // [sp+2Ch] [bp-2Ch]

  v6 = a2;
  v7 = *(_DWORD *)(a2 + 24);
  v28 = a1;
  v27 = v7;
  v24 = (char *)a3;
  v23 = a4;
  if ( v7 )
  {
    dword_2F850C(0);
    a3 = *(_DWORD *)(v6 + 24);
    v27 = *(_DWORD *)(v6 + 24);
  }
  if ( a5 )
  {
    v7 = a5[1];
    a3 = a5[2];
    v30 = *a5;
    v31 = (_DWORD *)v7;
    v32 = (char *)a3;
    v8 = (_DWORD *)v7;
  }
  else
  {
    v8 = *(_DWORD **)v6;
    v30 = 0;
    v32 = 0;
    v31 = v8;
  }
  if ( a6 )
    v7 = a6[1];
  else
    a3 = 0;
  if ( a6 )
    v29 = (_DWORD *)v7;
  else
    v29 = (_DWORD *)a3;
  if ( v23 > 0 )
  {
    c = (unsigned __int8)*v24;
    if ( !v8 )
    {
LABEL_21:
      v30 = -1;
      v31 = 0;
      goto LABEL_22;
    }
    v9 = v8[2];
    v10 = v8[5];
    v11 = v8[3];
    v26 = (_DWORD *)(v6 + 12);
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = (int)v32;
        v13 = v11 - (_DWORD)v32;
        v14 = (int)&v32[v9 + v10];
        v15 = (char *)memchr(&v32[v9 + v10], c, v11 - (_DWORD)v32);
        v16 = (int)&v15[-v14];
        v17 = v16 + v12;
        if ( v15 )
          break;
        if ( v8 == v29 )
          goto LABEL_21;
        v8 = (_DWORD *)*v8;
        v32 = v15;
        v31 = v8;
        v30 += v13;
        if ( !v8 )
          goto LABEL_21;
LABEL_18:
        v9 = v8[2];
        v10 = v8[5];
        v11 = v8[3];
      }
      v32 = (char *)v17;
      v18 = v17 + 1;
      v19 = v16 + v30;
      v30 = v19;
      if ( !sub_7F2E8(v26, (unsigned int *)&v30, v24, v23) )
      {
        if ( a6 && v23 + v19 > *a6 )
        {
          v30 = -1;
          v31 = 0;
        }
        break;
      }
      v30 = v19 + 1;
      v32 = (char *)v18;
      if ( v11 == v18 )
      {
        v8 = (_DWORD *)*v8;
        v32 = 0;
        v31 = v8;
        if ( !v8 )
          goto LABEL_21;
        goto LABEL_18;
      }
    }
  }
LABEL_22:
  if ( v27 )
    dword_2F8510(0);
  v20 = (int)v31;
  v21 = (int)v32;
  *v28 = v30;
  v28[1] = v20;
  v28[2] = v21;
  return v28;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00082994) --------------------------------------------------------
char **__fastcall sub_82994(char **a1, int *a2, int *a3, signed int *a4, int a5)
{
  int v5; // r11
  int *v6; // r7
  char **v7; // r8
  int *v8; // r4
  int v9; // r1
  int v10; // r2
  _DWORD *v11; // r4
  int v12; // r6
  int v13; // r11
  int v14; // r9
  size_t v15; // r2
  int v16; // r10
  char *v17; // r0
  signed int v18; // r4
  signed int v19; // r6
  int v20; // r1
  int v21; // r2
  char **result; // r0
  _DWORD *v23; // r4
  unsigned int v24; // r3
  signed int v25; // r0
  unsigned int v26; // r6
  char *v27; // r3
  int v28; // r2
  int v29; // t1
  int v30; // r3
  signed int *v31; // [sp+Ch] [bp-44h]
  char *v32; // [sp+10h] [bp-40h]
  _DWORD *v33; // [sp+14h] [bp-3Ch]
  char *v34; // [sp+18h] [bp-38h]
  char v35; // [sp+1Ch] [bp-34h]
  _DWORD *v36; // [sp+20h] [bp-30h]
  char *v37; // [sp+24h] [bp-2Ch]

  v6 = a2;
  v7 = a1;
  v8 = a3;
  v31 = a4;
  if ( a2[6] )
    dword_2F850C(0);
  if ( v8 )
  {
    v9 = v8[1];
    v10 = v8[2];
    v32 = (char *)*v8;
    v33 = (_DWORD *)v9;
    v34 = (char *)v10;
  }
  else
  {
    v30 = *v6;
    v32 = 0;
    v34 = 0;
    v33 = (_DWORD *)v30;
  }
  switch ( a5 )
  {
    case 0:
      if ( sub_7F0AC((int *)&v32) < 0 )
        goto LABEL_18;
      v23 = v33;
      v24 = (unsigned int)v34;
      if ( v33 )
      {
        v25 = 0;
        while ( 1 )
        {
          v26 = v23[3];
          if ( v26 > v24 )
            v5 = v24 - v25;
          if ( v26 > v24 )
          {
            do
            {
              v27 = &algn_E1EF2[1];
              do
              {
                v29 = (unsigned __int8)(v27++)[1];
                v28 = v29;
                if ( !v29 )
                  goto LABEL_35;
              }
              while ( *(unsigned __int8 *)(v23[5] + v23[2] + v5 + v25) != v28 );
              ++v25;
            }
            while ( v26 > v5 + v25 );
          }
          v23 = (_DWORD *)*v23;
          if ( !v23 )
            break;
          v24 = 0;
        }
      }
      else
      {
        v25 = -1;
      }
LABEL_35:
      v19 = v25;
      v18 = 1;
      goto LABEL_19;
    case 1:
      while ( 1 )
      {
        if ( sub_7F0AC((int *)&v32) < 0 )
          goto LABEL_18;
        if ( v34[v33[5] + v33[2]] == 10 )
          goto LABEL_11;
        if ( !sub_7F2E8(v6 + 3, (unsigned int *)&v32, "\r\n", 2u) )
          goto LABEL_13;
        if ( sub_8260C((int)v6, (unsigned int *)&v32, 1u, 1) < 0 )
          goto LABEL_18;
      }
    case 2:
      sub_82754(&v35, (int)v6, (int)"\r\n", 2, (int *)&v32, 0);
      v32 = *(char **)&v35;
      v33 = v36;
      v34 = v37;
      if ( *(_DWORD *)&v35 < 0 )
        goto LABEL_18;
LABEL_13:
      v18 = 1;
      v19 = 2;
      goto LABEL_19;
    case 3:
      v11 = v33;
      v12 = (int)v34;
      if ( !v33 )
        goto LABEL_18;
      v13 = (int)v32;
      break;
    default:
      goto LABEL_18;
  }
  while ( 1 )
  {
    v14 = v11[5] + v11[2];
    v15 = v11[3] - v12;
    v16 = v13 + v15;
    v17 = (char *)memchr((const void *)(v14 + v12), 10, v15);
    if ( v17 )
      break;
    v11 = (_DWORD *)*v11;
    v12 = 0;
    v13 = v16;
    v32 = (char *)v16;
    if ( !v11 )
      goto LABEL_18;
  }
  v34 = &v17[-v14];
  v32 = &v17[v13 - v12 - v14];
  v33 = v11;
  if ( (signed int)v32 >= 0 )
  {
LABEL_11:
    v18 = 1;
    v19 = 1;
    goto LABEL_19;
  }
LABEL_18:
  v18 = 0;
  v19 = 0;
LABEL_19:
  if ( v6[6] )
    dword_2F8510(0);
  if ( !v18 )
    v32 = (char *)-1;
  v20 = (int)v33;
  v21 = (int)v34;
  *v7 = v32;
  v7[1] = (char *)v20;
  v7[2] = (char *)v21;
  result = v7;
  if ( v31 )
    *v31 = v19;
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083028) --------------------------------------------------------
unsigned int __fastcall sub_83028(int a1, const char *a2, void *a3)
{
  const char *v3; // r9
  int v4; // r8
  void *v5; // r7
  _DWORD *v6; // r0
  unsigned int v7; // r1
  _DWORD *v8; // r0
  _DWORD *v9; // r4
  size_t v10; // r6
  bool v11; // zf
  int v12; // r12
  char *v13; // r0
  int v14; // r0
  bool v15; // nf
  unsigned int v16; // r5
  _DWORD *v18; // r3
  int v19; // r2
  int v20; // r1
  _DWORD *i; // r2

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  if ( !(*(_BYTE *)(v4 + 28) & 4) )
  {
    v6 = (_DWORD *)v4;
    v7 = 64;
    while ( 1 )
    {
      v8 = sub_7F68C(v6, v7);
      v9 = v8;
      if ( !v8 )
        break;
      v10 = 0;
      v11 = (v8[4] & 8) == 0;
      if ( !(v8[4] & 8) )
        v10 = v8[1];
      v12 = v8[2] + v8[3];
      v13 = (char *)(v8[5] + v12);
      if ( v11 )
        v10 -= v12;
      v14 = sub_8EE3C(v13, v10, v3, v5);
      v16 = v14;
      v15 = v14 < 0;
      v6 = (_DWORD *)v4;
      v7 = v16 + 1;
      if ( v15 || v16 == 0x7FFFFFFF )
        break;
      if ( v10 > v16 )
      {
        v18 = **(_DWORD ***)(v4 + 8);
        v19 = *(_DWORD *)(v4 + 16);
        v20 = *(_DWORD *)(v4 + 12) + v16;
        v9[3] += v16;
        *(_DWORD *)(v4 + 12) = v20;
        *(_DWORD *)(v4 + 16) = v19 + v16;
        if ( v18 )
        {
          for ( i = (_DWORD *)*v18; *v18; i = (_DWORD *)*v18 )
          {
            if ( !i[3] )
              break;
            *(_DWORD *)(v4 + 8) = v18;
            v18 = (_DWORD *)*v18;
          }
        }
        sub_7FD9C(v4);
        goto LABEL_16;
      }
    }
  }
  v16 = -1;
LABEL_16:
  if ( *(_DWORD *)(v4 + 24) )
    dword_2F8510(0);
  return v16;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008375C) --------------------------------------------------------
_DWORD *__fastcall sub_8375C(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r5
  int v4; // r7
  int v5; // r6
  _DWORD *v6; // r4
  int v7; // r1
  int v8; // r3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = sub_89134(1u, 0x14u);
  if ( v6 )
  {
    v7 = v3[6];
    if ( v7 )
    {
      dword_2F850C(0);
      v7 = v3[6];
    }
    v6[2] = v4;
    v8 = v3[16];
    v6[3] = v5;
    v6[4] = 1;
    *v6 = v8;
    if ( v8 )
      *(_DWORD *)(v8 + 4) = v6;
    else
      v3[17] = v6;
    v3[16] = v6;
    v6[1] = v3 + 16;
    if ( v7 )
      dword_2F8510(0);
  }
  return v6;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083898) --------------------------------------------------------
int __fastcall sub_83898(int a1, int *a2)
{
  int *v2; // r4
  int v3; // r5
  int v4; // r3
  _DWORD *v5; // r2

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 24) )
    dword_2F850C(0);
  v4 = *v2;
  v5 = (_DWORD *)v2[1];
  if ( *v2 )
  {
    *(_DWORD *)(v4 + 4) = v5;
    v5 = (_DWORD *)v2[1];
  }
  else
  {
    *(_DWORD *)(v3 + 68) = v5;
  }
  *v5 = v4;
  if ( *(_DWORD *)(v3 + 24) )
    dword_2F8510(0);
  sub_8B130(v2);
  return 0;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000839C0) --------------------------------------------------------
int __fastcall sub_839C0(int a1, int a2, unsigned __int16 a3)
{
  int v3; // r5
  int v4; // r6
  int v5; // r7
  int v6; // r1
  int result; // r0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
  {
    dword_2F850C(0);
    v6 = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(v3 + 16) |= v5;
    if ( v6 )
      dword_2F8510(0);
    result = 0;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a2 + 16) |= a3;
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083A34) --------------------------------------------------------
int __fastcall sub_83A34(int a1, int a2, unsigned __int16 a3)
{
  int v3; // r5
  int v4; // r6
  int v5; // r7
  int v6; // r1
  int result; // r0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 24) )
  {
    dword_2F850C(0);
    v6 = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(v3 + 16) &= ~v5;
    if ( v6 )
      dword_2F8510(0);
    result = 0;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a2 + 16) &= ~a3;
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083BEC) --------------------------------------------------------
int __fastcall sub_83BEC(int result, __int16 a2)
{
  __int16 v2; // r5
  int v3; // r4
  __int16 v4; // r3
  int v5; // r1

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(result + 260) )
    result = dword_2F850C(0);
  v4 = *(_WORD *)(v3 + 220);
  if ( !*(_WORD *)(v3 + 220) )
  {
    result = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)(v3 + 4) + 12))(v3, 2);
    v4 = *(_WORD *)(v3 + 220);
  }
  v5 = *(_DWORD *)(v3 + 260);
  *(_WORD *)(v3 + 220) = v4 | v2;
  if ( v5 )
    result = dword_2F8510(0);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083C74) --------------------------------------------------------
int __fastcall sub_83C74(int result, int a2)
{
  int v2; // r5
  int v3; // r4
  int v4; // r1

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(result + 260) )
    result = dword_2F850C(0);
  v4 = *(unsigned __int16 *)(v3 + 220) & ~v2;
  *(_WORD *)(v3 + 220) = v4;
  if ( !v4 && *(_WORD *)(v3 + 208) & 2 )
    result = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)(v3 + 4) + 8))(v3, 2);
  if ( *(_DWORD *)(v3 + 260) )
    result = dword_2F8510(0);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083D04) --------------------------------------------------------
int __fastcall sub_83D04(int a1, int a2, int a3)
{
  int v3; // r4
  int result; // r0

  v3 = a3;
  if ( (unsigned int)sub_80154(a1) >= *(_DWORD *)(a3 + 164) )
    result = sub_83BEC(v3, 1);
  else
    result = sub_83C74(v3, 1);
  return result;
}

//----- (00083D34) --------------------------------------------------------
int __fastcall sub_83D34(int result, __int16 a2)
{
  __int16 v2; // r5
  int v3; // r4
  __int16 v4; // r3
  int v5; // r1

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(result + 260) )
    result = dword_2F850C(0);
  v4 = *(_WORD *)(v3 + 222);
  if ( !*(_WORD *)(v3 + 222) )
  {
    result = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)(v3 + 4) + 12))(v3, 4);
    v4 = *(_WORD *)(v3 + 222);
  }
  v5 = *(_DWORD *)(v3 + 260);
  *(_WORD *)(v3 + 222) = v4 | v2;
  if ( v5 )
    result = dword_2F8510(0);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083DBC) --------------------------------------------------------
int __fastcall sub_83DBC(int result, int a2)
{
  int v2; // r5
  int v3; // r4
  int v4; // r1

  v2 = a2;
  v3 = result;
  if ( *(_DWORD *)(result + 260) )
    result = dword_2F850C(0);
  v4 = *(unsigned __int16 *)(v3 + 222) & ~v2;
  *(_WORD *)(v3 + 222) = v4;
  if ( !v4 && *(_WORD *)(v3 + 208) & 4 )
    result = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)(v3 + 4) + 8))(v3, 4);
  if ( *(_DWORD *)(v3 + 260) )
    result = dword_2F8510(0);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083E4C) --------------------------------------------------------
_DWORD *__fastcall sub_83E4C(_DWORD *result, int a2, int a3, int a4, int a5)
{
  int v5; // r6
  _DWORD *v6; // r4
  int v7; // r7
  int v8; // r8
  int v9; // r1

  v5 = a2;
  v6 = result;
  v7 = a3;
  v8 = a4;
  if ( result[65] )
  {
    result = (_DWORD *)dword_2F850C(0);
    v9 = v6[65];
    v6[44] = v5;
    v6[45] = v7;
    v6[46] = v8;
    v6[47] = a5;
    if ( v9 )
      result = (_DWORD *)dword_2F8510(0);
  }
  else
  {
    result[44] = a2;
    result[46] = a4;
    result[45] = a3;
    result[47] = a5;
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00083F3C) --------------------------------------------------------
int __fastcall sub_83F3C(int a1, int *a2, int *a3, int *a4)
{
  int *v4; // r5
  int v5; // r1
  _DWORD *v6; // r4
  int *v7; // r6
  int (__fastcall *v8)(_DWORD *, int); // r3
  int v9; // r5

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 260);
  v6 = (_DWORD *)a1;
  v7 = a3;
  if ( v5 )
    a1 = dword_2F850C(0);
  if ( v4 )
    a4 = v6 + 48;
  else
    v6[49] = 0;
  if ( v4 )
  {
    a1 = *v4;
    v5 = v4[1];
    *a4 = *v4;
    a4[1] = v5;
  }
  else
  {
    v6[48] = 0;
  }
  if ( v7 )
    a4 = v6 + 50;
  else
    v6[51] = 0;
  if ( v7 )
  {
    a1 = *v7;
    v5 = v7[1];
  }
  else
  {
    v6[50] = 0;
  }
  if ( v7 )
  {
    *a4 = a1;
    a4[1] = v5;
  }
  v8 = *(int (__fastcall **)(_DWORD *, int))(v6[1] + 20);
  if ( v8 )
    v9 = v8(v6, v5);
  else
    v9 = 0;
  if ( v6[65] )
    dword_2F8510(0);
  return v9;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000840BC) --------------------------------------------------------
int __fastcall sub_840BC(int a1, int a2)
{
  int v2; // r5
  int v3; // r4
  int (__fastcall *v4)(int, int); // r3
  int v5; // r0
  int v6; // r1
  int v7; // r4

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 260) )
    dword_2F850C(0);
  v4 = *(int (__fastcall **)(int, int))(*(_DWORD *)(v3 + 4) + 12);
  *(_WORD *)(v3 + 208) &= ~(_WORD)v2;
  v5 = v4(v3, v2);
  v6 = *(_DWORD *)(v3 + 260);
  v7 = v5 >> 31;
  if ( v6 )
    dword_2F8510(0);
  return v7;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008431C) --------------------------------------------------------
int __fastcall sub_8431C(int result)
{
  int v1; // r4
  int v2; // r1

  v1 = result;
  if ( *(_DWORD *)(result + 260) )
  {
    result = dword_2F850C(0);
    v2 = *(_DWORD *)(v1 + 260);
    ++*(_DWORD *)(v1 + 256);
    if ( v2 )
      result = dword_2F8510(0);
  }
  else
  {
    ++*(_DWORD *)(result + 256);
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00084438) --------------------------------------------------------
int __fastcall sub_84438(int result, int a2)
{
  int (*v2)(void); // r3
  int v3; // r4
  int v4; // r2
  char v5; // r2
  int v6; // r0
  int v7; // r2

  v2 = *(int (**)(void))(result + 184);
  v3 = result;
  if ( v2 )
  {
    v4 = *(_DWORD *)(result + 252);
    if ( v4 & 4 )
    {
      *(_WORD *)(result + 218) |= a2;
      result = _errno(result, a2, v4);
      v5 = *(_BYTE *)(v3 + 240);
      *(_DWORD *)(v3 + 224) = *(_DWORD *)result;
      if ( !(v5 & 1) )
      {
        sub_8431C(v3);
        v6 = sub_87DCC(*(_DWORD *)v3);
        result = sub_8900C(v6, v3 + 232);
      }
    }
    else
    {
      v7 = *(_DWORD *)(result + 188);
      result = v2();
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00084628) --------------------------------------------------------
int __fastcall sub_84628(int a1)
{
  int v1; // r4
  int v2; // r1
  int (__fastcall *v3)(int, signed int, int *); // r3
  int v4; // r5
  int result; // r0
  int v6; // [sp+4h] [bp-14h]

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 260);
  v6 = 0;
  if ( v2 )
    dword_2F850C(0);
  v3 = *(int (__fastcall **)(int, signed int, int *))(*(_DWORD *)(v1 + 4) + 28);
  if ( v3 )
    v4 = v3(v1, 2, &v6);
  else
    v4 = -1;
  if ( *(_DWORD *)(v1 + 260) )
    dword_2F8510(0);
  if ( v4 < 0 )
    result = 0;
  else
    result = v6;
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000846BC) --------------------------------------------------------
signed int __fastcall sub_846BC(int a1)
{
  bool v1; // zf
  int v2; // r4
  signed int result; // r0
  int v4; // r0
  void (__fastcall *v5)(int); // r3
  int v6; // r6
  int v7; // r0

  v1 = *(_DWORD *)(a1 + 256) == 1;
  v2 = a1;
  --*(_DWORD *)(a1 + 256);
  if ( v1 )
  {
    v4 = sub_84628(a1);
    v5 = *(void (__fastcall **)(int))(*(_DWORD *)(v2 + 4) + 16);
    v6 = v4;
    if ( v5 )
      v5(v2);
    sub_800C4(*(_DWORD *)(v2 + 152));
    sub_800C4(*(_DWORD *)(v2 + 156));
    v7 = *(_DWORD *)(v2 + 264);
    if ( v7 )
    {
      if ( *(_DWORD *)(v7 + 8) )
      {
        sub_86618(v2, 0);
        v7 = *(_DWORD *)(v2 + 264);
      }
      if ( sub_88504(v7 + 28) )
        sub_88C24(*(_DWORD *)(v2 + 264) + 28);
      sub_8C074(*(_DWORD *)(v2 + 264) + 28);
      sub_8B130(*(void **)(v2 + 264));
      *(_DWORD *)(v2 + 264) = 0;
    }
    sub_8C074(v2 + 8);
    sub_8C074(v2 + 80);
    if ( *(_DWORD *)(v2 + 260) )
      dword_2F8510(0);
    if ( *(_BYTE *)(v2 + 216) & 1 && *(_DWORD *)(v2 + 260) && dword_2F8508 )
      dword_2F8508();
    sub_8B130((void *)(v2 - *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4)));
    if ( v6 )
      sub_84BEC(v6);
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 260) )
      dword_2F8510(0);
    result = 0;
  }
  return result;
}
// 2F8508: using guessed type int (*dword_2F8508)(void);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00084838) --------------------------------------------------------
signed int __fastcall sub_84838(int a1, int a2, int (__fastcall *a3)(int, int))
{
  int v3; // r4
  int v4; // r1
  __int16 v5; // r3
  int (__fastcall *v6)(int, signed int, _DWORD); // r12
  char v7; // r3
  int v8; // r1
  __int16 v9; // r5
  int v10; // r6
  _DWORD *v11; // r0
  void (__fastcall *v12)(int, _DWORD, int); // r3
  int v13; // r2

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 260);
  if ( v4 )
    a1 = dword_2F850C(0);
  v5 = *(_WORD *)(v3 + 218);
  if ( v5 & 0x80 )
  {
    v6 = *(int (__fastcall **)(int, signed int, _DWORD))(v3 + 184);
    if ( v6 )
    {
      *(_WORD *)(v3 + 218) = v5 & 0xFF7F;
      a1 = v6(v3, 128, *(_DWORD *)(v3 + 188));
    }
  }
  v7 = *(_BYTE *)(v3 + 216);
  if ( *(_BYTE *)(v3 + 216) & 2 )
  {
    a3 = *(int (__fastcall **)(int, int))(v3 + 176);
    if ( a3 )
    {
      *(_BYTE *)(v3 + 216) = v7 & 0xFD;
      a1 = a3(v3, *(_DWORD *)(v3 + 188));
      v7 = *(_BYTE *)(v3 + 216);
    }
  }
  if ( v7 & 4 )
  {
    a3 = *(int (__fastcall **)(int, int))(v3 + 180);
    if ( a3 )
    {
      v8 = *(_DWORD *)(v3 + 188);
      *(_BYTE *)(v3 + 216) = v7 & 0xFB;
      a1 = a3(v3, v8);
    }
  }
  v9 = *(_WORD *)(v3 + 218);
  if ( *(_WORD *)(v3 + 218) && *(_DWORD *)(v3 + 184) )
  {
    v10 = *(_DWORD *)(v3 + 224);
    *(_WORD *)(v3 + 218) = 0;
    *(_DWORD *)(v3 + 224) = 0;
    v11 = (_DWORD *)_errno(a1, v4, a3);
    v12 = *(void (__fastcall **)(int, _DWORD, int))(v3 + 184);
    v13 = *(_DWORD *)(v3 + 188);
    *v11 = v10;
    v12(v3, v9, v13);
  }
  return sub_846BC(v3);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);

//----- (0008493C) --------------------------------------------------------
signed int __fastcall sub_8493C(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r1
  __int16 v5; // r3
  int (__fastcall *v6)(int, signed int, int); // r6
  int v7; // r1
  int v8; // r7
  char v9; // r3
  int (__fastcall *v10)(int, int); // r6
  int v11; // r1
  int v12; // r7
  int (__fastcall *v13)(int, int); // r6
  int v14; // r1
  int v15; // r7
  __int16 v16; // r6
  void (__fastcall *v17)(int, _DWORD, int); // r8
  int v18; // r10
  int v19; // r9
  _DWORD *v20; // r0
  int v21; // r1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 260);
  if ( v4 )
    a1 = dword_2F850C(0);
  v5 = *(_WORD *)(v3 + 218);
  if ( v5 & 0x80 )
  {
    v6 = *(int (__fastcall **)(int, signed int, int))(v3 + 184);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v3 + 260);
      v8 = *(_DWORD *)(v3 + 188);
      *(_WORD *)(v3 + 218) = v5 & 0xFF7F;
      if ( v7 )
        dword_2F8510(0);
      a1 = v6(v3, 128, v8);
      v4 = *(_DWORD *)(v3 + 260);
      if ( v4 )
        a1 = dword_2F850C(0);
    }
  }
  v9 = *(_BYTE *)(v3 + 216);
  if ( *(_BYTE *)(v3 + 216) & 2 )
  {
    v10 = *(int (__fastcall **)(int, int))(v3 + 176);
    if ( v10 )
    {
      v11 = *(_DWORD *)(v3 + 260);
      v12 = *(_DWORD *)(v3 + 188);
      *(_BYTE *)(v3 + 216) = v9 & 0xFD;
      if ( v11 )
        dword_2F8510(0);
      a1 = v10(v3, v12);
      v4 = *(_DWORD *)(v3 + 260);
      if ( v4 )
        a1 = dword_2F850C(0);
      v9 = *(_BYTE *)(v3 + 216);
    }
  }
  if ( v9 & 4 )
  {
    v13 = *(int (__fastcall **)(int, int))(v3 + 180);
    if ( v13 )
    {
      v14 = *(_DWORD *)(v3 + 260);
      v15 = *(_DWORD *)(v3 + 188);
      *(_BYTE *)(v3 + 216) = v9 & 0xFB;
      if ( v14 )
        dword_2F8510(0);
      a1 = v13(v3, v15);
      v4 = *(_DWORD *)(v3 + 260);
      if ( v4 )
        a1 = dword_2F850C(0);
    }
  }
  v16 = *(_WORD *)(v3 + 218);
  if ( *(_WORD *)(v3 + 218) )
  {
    v17 = *(void (__fastcall **)(int, _DWORD, int))(v3 + 184);
    if ( v17 )
    {
      v18 = *(_DWORD *)(v3 + 224);
      *(_WORD *)(v3 + 218) = 0;
      *(_DWORD *)(v3 + 224) = 0;
      v19 = *(_DWORD *)(v3 + 188);
      v20 = (_DWORD *)_errno(a1, v4, a3);
      v21 = *(_DWORD *)(v3 + 260);
      *v20 = v18;
      if ( v21 )
        dword_2F8510(0);
      v17(v3, v16, v19);
      if ( *(_DWORD *)(v3 + 260) )
        dword_2F850C(0);
    }
  }
  return sub_846BC(v3);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00084BEC) --------------------------------------------------------
signed int __fastcall sub_84BEC(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( *(_DWORD *)(a1 + 260) )
    dword_2F850C(0);
  return sub_846BC(v1);
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);

//----- (00084DA8) --------------------------------------------------------
signed int __fastcall sub_84DA8(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  int v4; // r0
  signed int v5; // r8
  int v6; // r7
  char v7; // r2
  char v9; // r3
  int v10; // r1
  int v11; // r0
  int v12; // r0
  char v13; // r3

  v2 = a1;
  v3 = a2;
  if ( *(_DWORD *)(a1 + 260) )
    return -1;
  v4 = sub_84628(a1);
  v5 = v4;
  v6 = v4;
  if ( v4 )
    v5 = 1;
  if ( !((unsigned __int8)v5 & (v3 == 0)) )
  {
    if ( v3 != 0 )
    {
      v7 = *(_BYTE *)(v2 + 216);
      *(_DWORD *)(v2 + 260) = v3;
      *(_BYTE *)(v2 + 216) = v7 & 0xFE;
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  v3 = *(_DWORD *)(v4 + 260);
  if ( !v3 )
  {
LABEL_12:
    if ( dword_2F8504 )
    {
      v12 = dword_2F8504(1);
      v3 = v12;
      if ( v12 )
      {
        v13 = *(_BYTE *)(v2 + 216);
        *(_DWORD *)(v2 + 260) = v12;
        *(_BYTE *)(v2 + 216) = v13 | 1;
LABEL_7:
        sub_7FCB4(*(_DWORD *)(v2 + 152), v3);
        sub_7FCB4(*(_DWORD *)(v2 + 156), v3);
        if ( !v5 )
          return 0;
        goto LABEL_8;
      }
    }
    return -1;
  }
  v9 = *(_BYTE *)(v2 + 216);
  v10 = *(_DWORD *)(v4 + 260);
  *(_DWORD *)(v2 + 260) = v3;
  v11 = *(_DWORD *)(v2 + 152);
  *(_BYTE *)(v2 + 216) = v9 & 0xFE;
  sub_7FCB4(v11, v10);
  sub_7FCB4(*(_DWORD *)(v2 + 156), v3);
LABEL_8:
  if ( *(_DWORD *)(v6 + 260) )
    return 0;
  sub_84DA8(v6, v3);
  return 0;
}
// 2F8504: using guessed type int (__fastcall *dword_2F8504)(_DWORD);

//----- (000851DC) --------------------------------------------------------
int __fastcall sub_851DC(int a1)
{
  int v1; // r4
  bool v2; // zf

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)a1 == 0;
  *(_BYTE *)(a1 + 48) = (*(_BYTE *)(a1 + 48) | 2) & 0xF7;
  if ( !v2 )
  {
    do
    {
      while ( 1 )
      {
        if ( !*(_DWORD *)(v1 + 260) || !dword_2F850C || !((int (*)(void))dword_2F850C)() )
        {
          sub_83D34(v1, 4);
          if ( *(_DWORD *)(v1 + 260) )
            break;
        }
        v1 = **(_DWORD **)(v1 + 264);
        if ( !v1 )
          return 0;
      }
      dword_2F8510(0);
      v1 = **(_DWORD **)(v1 + 264);
    }
    while ( v1 );
  }
  return 0;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008528C) --------------------------------------------------------
int __fastcall sub_8528C(int a1)
{
  int v1; // r4
  bool v2; // zf

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)a1 == 0;
  *(_BYTE *)(a1 + 48) = (*(_BYTE *)(a1 + 48) | 1) & 0xFB;
  if ( !v2 )
  {
    do
    {
      while ( 1 )
      {
        if ( !*(_DWORD *)(v1 + 260) || !dword_2F850C || !((int (*)(void))dword_2F850C)() )
        {
          sub_83BEC(v1, 4);
          if ( *(_DWORD *)(v1 + 260) )
            break;
        }
        v1 = **(_DWORD **)(v1 + 264);
        if ( !v1 )
          return 0;
      }
      dword_2F8510(0);
      v1 = **(_DWORD **)(v1 + 264);
    }
    while ( v1 );
  }
  return 0;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008533C) --------------------------------------------------------
int __fastcall sub_8533C(int result)
{
  int v1; // r7
  int v2; // r5
  int v3; // r0
  int v4; // r1
  int v5; // r1
  int v6; // t0
  int v7; // r4
  int v8; // r1
  char v9; // r8
  int v10; // r4
  bool v11; // zf
  bool v12; // zf

  v1 = result;
  v2 = *(_DWORD *)(result + 72);
  *(_BYTE *)(result + 48) &= 0xFDu;
  if ( v2 )
  {
    v3 = j_lrand48();
    v4 = *(_DWORD *)(v1 + 72);
    v6 = v3 / v4;
    v5 = v3 % v4;
    result = v6;
    v7 = *(_DWORD *)v1;
    v2 = *(_DWORD *)v1;
    v11 = v5 == 0;
    v8 = v5 - 1;
    if ( !v11 )
    {
      do
      {
        --v8;
        v2 = **(_DWORD **)(v2 + 264);
      }
      while ( v8 != -1 );
    }
    if ( !v2 )
    {
      v9 = 0;
      goto LABEL_22;
    }
    v10 = v2;
    v9 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v10 + 260) && dword_2F850C && (result = ((int (*)(void))dword_2F850C)()) != 0 )
      {
        v9 = 1;
LABEL_9:
        v10 = **(_DWORD **)(v10 + 264);
        if ( !v10 )
          goto LABEL_14;
      }
      else
      {
        sub_83DBC(v10, 4);
        result = 0;
        if ( !*(_DWORD *)(v10 + 260) )
          goto LABEL_9;
        result = dword_2F8510(0);
        v10 = **(_DWORD **)(v10 + 264);
        if ( !v10 )
        {
LABEL_14:
          v7 = *(_DWORD *)v1;
          v11 = *(_DWORD *)v1 == v2;
          if ( *(_DWORD *)v1 != v2 )
            v11 = v7 == 0;
          if ( !v11 )
            goto LABEL_25;
          goto LABEL_18;
        }
      }
    }
  }
  v7 = *(_DWORD *)result;
  v9 = 0;
  while ( 1 )
  {
LABEL_22:
    v12 = v7 == v2;
    if ( v7 != v2 )
      v12 = v7 == 0;
    if ( v12 )
      break;
LABEL_25:
    if ( *(_DWORD *)(v7 + 260) && dword_2F850C && (result = ((int (*)(void))dword_2F850C)()) != 0 )
    {
      v9 = 1;
    }
    else
    {
      sub_83DBC(v7, 4);
      result = 0;
      if ( *(_DWORD *)(v7 + 260) )
        result = dword_2F8510(0);
    }
    v7 = **(_DWORD **)(v7 + 264);
  }
LABEL_18:
  *(_BYTE *)(v1 + 48) = *(_BYTE *)(v1 + 48) & 0xF7 | 8 * (v9 & 1);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000854DC) --------------------------------------------------------
int __fastcall sub_854DC(int result)
{
  int v1; // r7
  int v2; // r5
  int v3; // r0
  int v4; // r1
  int v5; // r1
  int v6; // t0
  int v7; // r4
  int v8; // r1
  char v9; // r8
  int v10; // r4
  bool v11; // zf
  bool v12; // zf

  v1 = result;
  v2 = *(_DWORD *)(result + 72);
  *(_BYTE *)(result + 48) &= 0xFEu;
  if ( v2 )
  {
    v3 = j_lrand48();
    v4 = *(_DWORD *)(v1 + 72);
    v6 = v3 / v4;
    v5 = v3 % v4;
    result = v6;
    v7 = *(_DWORD *)v1;
    v2 = *(_DWORD *)v1;
    v11 = v5 == 0;
    v8 = v5 - 1;
    if ( !v11 )
    {
      do
      {
        --v8;
        v2 = **(_DWORD **)(v2 + 264);
      }
      while ( v8 != -1 );
    }
    if ( !v2 )
    {
      v9 = 0;
      goto LABEL_22;
    }
    v10 = v2;
    v9 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v10 + 260) && dword_2F850C && (result = ((int (*)(void))dword_2F850C)()) != 0 )
      {
        v9 = 1;
LABEL_9:
        v10 = **(_DWORD **)(v10 + 264);
        if ( !v10 )
          goto LABEL_14;
      }
      else
      {
        sub_83C74(v10, 4);
        result = 0;
        if ( !*(_DWORD *)(v10 + 260) )
          goto LABEL_9;
        result = dword_2F8510(0);
        v10 = **(_DWORD **)(v10 + 264);
        if ( !v10 )
        {
LABEL_14:
          v7 = *(_DWORD *)v1;
          v11 = *(_DWORD *)v1 == v2;
          if ( *(_DWORD *)v1 != v2 )
            v11 = v7 == 0;
          if ( !v11 )
            goto LABEL_25;
          goto LABEL_18;
        }
      }
    }
  }
  v7 = *(_DWORD *)result;
  v9 = 0;
  while ( 1 )
  {
LABEL_22:
    v12 = v7 == v2;
    if ( v7 != v2 )
      v12 = v7 == 0;
    if ( v12 )
      break;
LABEL_25:
    if ( *(_DWORD *)(v7 + 260) && dword_2F850C && (result = ((int (*)(void))dword_2F850C)()) != 0 )
    {
      v9 = 1;
    }
    else
    {
      sub_83C74(v7, 4);
      result = 0;
      if ( *(_DWORD *)(v7 + 260) )
        result = dword_2F8510(0);
    }
    v7 = **(_DWORD **)(v7 + 264);
  }
LABEL_18:
  *(_BYTE *)(v1 + 48) = *(_BYTE *)(v1 + 48) & 0xFB | 4 * (v9 & 1);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000856F4) --------------------------------------------------------
signed int __fastcall sub_856F4(unsigned int *a1, unsigned int *a2, unsigned int a3)
{
  unsigned int *v3; // r4
  unsigned int v4; // r5
  unsigned int v5; // r8
  unsigned int v6; // r10
  unsigned int v7; // r0
  bool v8; // cf
  unsigned int v9; // r9
  unsigned int v10; // r6
  unsigned int v11; // r8
  signed int result; // r0

  v3 = a1;
  v4 = a3 - a1[2];
  if ( (signed int)(a3 - a1[2]) <= 0 )
    return 0;
  v5 = *a1;
  v6 = a2[1];
  v7 = (v6 - *a1) / v4;
  v8 = v7 >= *a2;
  if ( v7 >= *a2 )
    v5 += *a2 * v4;
  else
    *v3 = v6;
  v9 = a2[3];
  v10 = a2[2];
  if ( v8 )
    *v3 = v5;
  v11 = v3[1];
  v3[2] = a3;
  result = 1;
  if ( (v9 - v11) / v4 >= v10 )
    v3[1] = v11 + v10 * v4;
  else
    v3[1] = v9;
  return result;
}

//----- (00085778) --------------------------------------------------------
void __fastcall sub_85778(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r3
  signed int v5; // r4
  int v6; // r0
  int v7; // [sp+0h] [bp-30h]
  int v8; // [sp+4h] [bp-2Ch]

  v3 = a3;
  if ( *(_DWORD *)(a3 + 260) )
    dword_2F850C(0);
  v4 = *(_DWORD *)(v3 + 264);
  if ( v4 && *(_DWORD *)(v4 + 24) )
  {
    sub_87CBC(*(_DWORD **)v3, (struct timeval *)&v7);
    sub_856F4(
      (unsigned int *)(*(_DWORD *)(v3 + 264) + 12),
      *(unsigned int **)(*(_DWORD *)(v3 + 264) + 24),
      (1000LL * v7 + v8 / 1000) / (unsigned __int64)*(unsigned int *)(*(_DWORD *)(*(_DWORD *)(v3 + 264) + 24) + 24));
    if ( *(_WORD *)(v3 + 220) & 2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 264) + 12) <= 0 )
      {
        v5 = 1;
LABEL_7:
        if ( *(_WORD *)(v3 + 222) & 2 )
        {
          v6 = *(_DWORD *)(v3 + 264);
          if ( *(_DWORD *)(v6 + 16) <= 0 )
          {
LABEL_18:
            sub_8AD50(v6 + 28, (_DWORD *)(*(_DWORD *)(v6 + 24) + 16));
            goto LABEL_11;
          }
          sub_83DBC(v3, 2);
        }
        if ( !v5 )
          goto LABEL_11;
        v6 = *(_DWORD *)(v3 + 264);
        goto LABEL_18;
      }
      sub_83C74(v3, 2);
    }
    v5 = 0;
    goto LABEL_7;
  }
LABEL_11:
  if ( *(_DWORD *)(v3 + 260) )
    dword_2F8510(0);
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000858E4) --------------------------------------------------------
signed int __fastcall sub_858E4(int a1, int a2, int a3)
{
  int v3; // r6
  _DWORD *v4; // r0
  signed int result; // r0
  char v6; // r3
  int v7; // [sp+0h] [bp-28h]
  int v8; // [sp+4h] [bp-24h]

  v3 = a3;
  v4 = (_DWORD *)sub_887A4(a3 + 84);
  sub_87CBC(v4, (struct timeval *)&v7);
  if ( *(_DWORD *)(v3 + 156) )
    dword_2F850C(0);
  result = sub_856F4(
             (unsigned int *)(v3 + 8),
             (unsigned int *)(v3 + 20),
             (1000LL * v7 + v8 / 1000) / (unsigned __int64)*(unsigned int *)(v3 + 44));
  v6 = *(_BYTE *)(v3 + 48);
  if ( *(_BYTE *)(v3 + 48) & 4 || *(_BYTE *)(v3 + 48) & 1 && *(_DWORD *)(v3 + 8) >= *(_DWORD *)(v3 + 76) )
  {
    result = sub_854DC(v3);
    v6 = *(_BYTE *)(v3 + 48);
  }
  if ( v6 & 8 || v6 & 2 && *(_DWORD *)(v3 + 12) >= *(_DWORD *)(v3 + 76) )
    result = sub_8533C(v3);
  if ( *(_DWORD *)(v3 + 156) )
    result = dword_2F8510(0);
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00086618) --------------------------------------------------------
int __fastcall sub_86618(int a1, int a2)
{
  int v2; // r7
  int v3; // r4
  int *v4; // r3
  _DWORD *v5; // r5
  int v6; // r2
  int v7; // r0
  int v8; // r1
  bool v9; // zf
  int v10; // r1

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 260) )
    dword_2F850C(0);
  v4 = *(int **)(v3 + 264);
  if ( v4 )
  {
    v5 = (_DWORD *)v4[2];
    if ( v5 )
    {
      if ( v5[39] )
      {
        dword_2F850C(0);
        v4 = *(int **)(v3 + 264);
      }
      v6 = *v4;
      v7 = 0;
      v8 = v5[18];
      v9 = *v4 == 0;
      v4[2] = 0;
      v10 = v8 - 1;
      v5[18] = v10;
      if ( v9 )
      {
        v4 = (int *)v4[1];
      }
      else
      {
        v7 = v4[1];
        v10 = *(_DWORD *)(v6 + 264);
      }
      if ( v9 )
      {
        v5[1] = v4;
      }
      else
      {
        *(_DWORD *)(v10 + 4) = v7;
        v4 = (int *)v4[1];
      }
      *v4 = v6;
      if ( v5[39] )
        dword_2F8510(0);
    }
  }
  if ( v2 )
  {
    sub_83C74(v3, 4);
    sub_83DBC(v3, 4);
  }
  if ( *(_DWORD *)(v3 + 260) )
    dword_2F8510(0);
  return 0;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00087268) --------------------------------------------------------
int *__fastcall sub_87268(int *result, _DWORD *a2, int a3)
{
  _DWORD *v3; // r3
  int v4; // r12
  int v5; // r2
  int v6; // r2
  bool v7; // zf
  bool v8; // zf
  int v9; // r3

  v3 = **(_DWORD ***)(result[1] + 4);
  if ( !v3 )
  {
LABEL_15:
    v8 = *result == 0;
    a2[4] = *result;
    if ( v8 )
    {
      v9 = (int)(a2 + 4);
      result[1] = (int)(a2 + 4);
    }
    else
    {
      a3 = (int)(a2 + 4);
      v9 = *result;
    }
    if ( !v8 )
      *(_DWORD *)(v9 + 20) = a3;
    *result = (int)a2;
    a2[5] = result;
    return result;
  }
  v4 = a2[14];
  while ( 1 )
  {
    v5 = v3[14];
    v7 = v5 == v4;
    a3 = v5 <= v4;
    if ( v7 )
      break;
    if ( a3 )
      goto LABEL_8;
LABEL_4:
    v3 = **(_DWORD ***)(v3[5] + 4);
    if ( !v3 )
      goto LABEL_15;
  }
  a3 = a2[15] >= v3[15];
  if ( a2[15] < v3[15] )
    goto LABEL_4;
LABEL_8:
  v6 = v3[4];
  v7 = v6 == 0;
  a2[4] = v6;
  if ( v6 )
    result = a2 + 4;
  else
    v6 = (int)(a2 + 4);
  if ( v7 )
    result[1] = v6;
  else
    *(_DWORD *)(v6 + 20) = result;
  v3[4] = a2;
  a2[5] = v3 + 4;
  return result;
}

//----- (00087330) --------------------------------------------------------
ssize_t __fastcall sub_87330(int fd, int a2, int a3)
{
  int v3; // r4
  int v4; // r7
  ssize_t result; // r0
  int v6; // r1
  char buf; // [sp+4h] [bp-41Ch]

  v3 = fd;
  v4 = a3;
  do
    result = read(v3, &buf, 0x400u);
  while ( result > 0 );
  if ( *(_DWORD *)(v4 + 264) )
  {
    dword_2F850C(0);
    v6 = *(_DWORD *)(v4 + 264);
    result = 0;
    *(_DWORD *)(v4 + 284) = 0;
    if ( v6 )
      result = dword_2F8510(0);
  }
  else
  {
    *(_DWORD *)(v4 + 284) = 0;
  }
  return result;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000873D8) --------------------------------------------------------
void __fastcall sub_873D8(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  void (__fastcall *v4)(int); // r3

  v2 = a2;
  if ( dword_2F84CC )
  {
    if ( *(_DWORD *)(a2 + 148) )
    {
      v3 = *(_DWORD *)(a2 + 260);
      if ( v3 != dword_2F84CC() )
      {
        v4 = *(void (__fastcall **)(int))(v2 + 368);
        if ( v4 )
        {
          if ( !*(_DWORD *)(v2 + 284) )
          {
            *(_DWORD *)(v2 + 284) = 1;
            v4(v2);
          }
        }
      }
    }
  }
}
// 2F84CC: using guessed type int (*dword_2F84CC)(void);

//----- (00087440) --------------------------------------------------------
int __fastcall sub_87440(_DWORD *a1, struct timeval *a2)
{
  _DWORD *v2; // r4
  struct timeval *v3; // r5
  int v4; // r3
  int v5; // r0
  signed __int64 v6; // kr00_8
  bool v7; // nf
  unsigned __int8 v8; // vf
  int v9; // r2
  bool v10; // nf
  int v11; // r2
  int v12; // r3
  int v13; // r1
  int result; // r0
  __suseconds_t v15; // r1
  int v16; // [sp+0h] [bp-20h]
  int v17; // [sp+4h] [bp-1Ch]
  struct timeval tv; // [sp+8h] [bp-18h]

  v2 = a1;
  v3 = a2;
  if ( a1[60] )
  {
    v15 = a1[61];
    v3->tv_sec = a1[60];
    v3->tv_usec = v15;
    result = 0;
  }
  else
  {
    if ( dword_2F84A4 )
    {
      v4 = clock_gettime(1, (struct timespec *)&v16);
      if ( v4 != -1 )
      {
        v4 = v16;
        v5 = v2[64];
        v6 = 274877907LL * v17;
        v8 = __OFSUB__(v16, v5);
        v7 = v16 - v5 < 0;
        v9 = v17 >> 31;
        v3->tv_sec = v16;
        if ( v7 ^ v8 )
          v4 = 0;
        v3->tv_usec = (SHIDWORD(v6) >> 6) - v9;
        if ( !(v7 ^ v8) )
        {
          gettimeofday(&tv, 0);
          v10 = tv.tv_usec - v3->tv_usec < 0;
          v11 = v16;
          v12 = tv.tv_usec - v3->tv_usec + ((char)-v10 & 0xF4000);
          v13 = tv.tv_sec - v3->tv_sec;
          if ( v10 )
            v12 += 576;
          v2[62] = v13;
          if ( v10 )
            --v13;
          v2[63] = v12;
          v4 = 0;
          if ( v10 )
            v2[62] = v13;
          v2[64] = v11;
        }
      }
    }
    else
    {
      v4 = gettimeofday(a2, (__timezone_ptr_t)dword_2F84A4);
    }
    result = v4;
  }
  return result;
}
// 2F84A4: using guessed type int dword_2F84A4;

//----- (0008753C) --------------------------------------------------------
int __fastcall sub_8753C(int a1)
{
  int v1; // r0
  ssize_t v2; // r0
  int v3; // r1
  int v4; // r2
  int result; // r0
  char v6; // [sp+4h] [bp-Ch]

  v1 = *(_DWORD *)(a1 + 292);
  v6 = 0;
  v2 = write(v1, &v6, 1u);
  if ( v2 >= 0 )
    return 0;
  result = *(_DWORD *)_errno(v2, v3, v4) - 11;
  if ( result )
    result = -1;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00087588) --------------------------------------------------------
_DWORD *__fastcall sub_87588(_DWORD *result, int a2, int a3)
{
  int v3; // r3
  int v4; // r12
  int v5; // r3
  _DWORD *v6; // r3
  bool v7; // zf
  _DWORD *v8; // r2
  unsigned int v9; // r3
  int v10; // r3
  unsigned int v11; // r4
  signed int v12; // r5
  _DWORD *v13; // r6
  int v14; // r12
  int v15; // r7
  int v16; // r8
  _BOOL4 v17; // r12
  unsigned int i; // r2
  unsigned int v19; // r2
  int v20; // r2
  signed int v21; // r12
  int v22; // r12
  int v23; // r4
  int v24; // r8
  int v25; // r7
  int v26; // r12
  int v27; // r7
  _DWORD *v28; // r4
  int v29; // r8
  int v30; // r2
  int v31; // r12
  bool v32; // zf
  int v33; // r2
  int v34; // r4
  _DWORD *v35; // r12
  int v36; // r4

  v3 = *(unsigned __int16 *)(a2 + 52);
  v4 = (signed __int16)v3;
  if ( !(a3 & (signed __int16)v3) )
    sub_9098C(1, "%s: %p(fd %d) not on queue %x", "event_queue_remove", a2, *(_DWORD *)(a2 + 24), a3);
  v7 = (v3 & 0x10) == 0;
  v5 = v3 & ~a3;
  if ( v7 )
  {
    v4 = result[31] - 1;
    result[31] = v4;
  }
  *(_WORD *)(a2 + 52) = v5;
  if ( a3 == 2 )
  {
    v6 = *(_DWORD **)(a2 + 8);
    v8 = *(_DWORD **)(a2 + 12);
    if ( v6 )
      v6[3] = v8;
    else
      result[54] = v8;
    if ( v6 )
      v8 = *(_DWORD **)(a2 + 12);
    goto LABEL_17;
  }
  if ( a3 == 8 )
  {
    v6 = *(_DWORD **)a2;
    v7 = *(_DWORD *)a2 == 0;
    --result[32];
    if ( v7 )
    {
      v4 = *(unsigned __int8 *)(a2 + 54);
      result = (_DWORD *)result[38];
    }
    v8 = *(_DWORD **)(a2 + 4);
    if ( v7 )
      a2 = (int)&result[2 * v4];
    else
      v6[1] = v8;
    if ( v7 )
      *(_DWORD *)(a2 + 4) = v8;
    else
      v8 = *(_DWORD **)(a2 + 4);
    goto LABEL_17;
  }
  if ( a3 != 1 )
    sub_9098C(1, "%s: unknown queue %x", "event_queue_remove", a3);
  v9 = *(_DWORD *)(a2 + 60);
  if ( (v9 & 0xF0000000) == 1342177280 )
  {
    v31 = (v9 >> 20) & 0xFF;
    if ( v31 < result[41] )
    {
      v6 = *(_DWORD **)(a2 + 16);
      v32 = v6 == 0;
      v33 = *(_DWORD *)(result[40] + 4 * v31);
      if ( v6 )
        v33 = *(_DWORD *)(a2 + 20);
      else
        v6 = *(_DWORD **)(a2 + 20);
      if ( v32 )
        *(_DWORD *)(v33 + 4) = v6;
      else
        v6[5] = v33;
      if ( v32 )
        v6 = *(_DWORD **)(a2 + 16);
      v8 = *(_DWORD **)(a2 + 20);
LABEL_17:
      *v8 = v6;
      return result;
    }
  }
  if ( *(_DWORD *)(a2 + 16) != -1 )
  {
    v10 = result[57];
    v11 = result[58] - 1;
    result[58] = v11;
    v12 = *(_DWORD *)(a2 + 16);
    v13 = *(_DWORD **)(v10 + 4 * v11);
    if ( v12 > 0
      && ((v14 = *(_DWORD *)(v10 + 4 * ((v12 - 1) / 2)), v15 = v13[14], v16 = *(_DWORD *)(v14 + 56), v16 == v15) ? (v17 = *(_DWORD *)(v14 + 60) > v13[15]) : (v17 = v16 > v15),
          v17) )
    {
      for ( i = (unsigned int)(v12 - 1) >> 1; ; i = (i - 1) >> 1 )
      {
        v35 = *(_DWORD **)(v10 + 4 * i);
        v36 = v35[14];
        v34 = v36 == v15 ? (unsigned __int8)(v35[15] > v13[15]) : (unsigned __int8)(v36 > v15);
        if ( !v34 )
          break;
        *(_DWORD *)(v10 + 4 * v12) = v35;
        v35[4] = v12;
        v10 = result[57];
        if ( !i )
        {
          result = 0;
          goto LABEL_67;
        }
        v15 = v13[14];
        v12 = i;
      }
      result = (_DWORD *)(4 * v12);
      i = v12;
LABEL_67:
      *(_DWORD *)((char *)result + v10) = v13;
      v13[4] = i;
    }
    else
    {
      v19 = 2 * (v12 + 1);
      if ( v11 >= v19 )
      {
        while ( 1 )
        {
          if ( v19 == v11 )
          {
            v21 = 1;
          }
          else
          {
            v22 = *(_DWORD *)(v10 + 4 * v19);
            v23 = *(_DWORD *)(v10 + 4 * v19 - 4);
            v24 = *(_DWORD *)(v22 + 56);
            v25 = *(_DWORD *)(v23 + 56);
            v21 = v24 == v25 ? (unsigned __int8)(*(_DWORD *)(v22 + 60) > *(_DWORD *)(v23 + 60)) : (unsigned __int8)(v24 > v25);
          }
          v26 = v19 - v21;
          v27 = v13[14];
          v28 = *(_DWORD **)(v10 + 4 * v26);
          v29 = 4 * v26;
          v30 = v28[14];
          v20 = v27 == v30 ? (unsigned __int8)(v13[15] > v28[15]) : (unsigned __int8)(v27 > v30);
          if ( !v20 )
            break;
          *(_DWORD *)(v10 + 4 * v12) = v28;
          v28[4] = v12;
          v11 = result[58];
          v19 = 2 * (v26 + 1);
          if ( v11 < v19 )
          {
            v10 = result[57];
            v12 = v26;
            goto LABEL_62;
          }
          v10 = result[57];
          v12 = v26;
        }
      }
      v29 = 4 * v12;
LABEL_62:
      *(_DWORD *)(v10 + v29) = v13;
      v13[4] = v12;
    }
    *(_DWORD *)(a2 + 16) = -1;
  }
  return result;
}

//----- (000878B0) --------------------------------------------------------
signed int __fastcall sub_878B0(unsigned int a1)
{
  unsigned int v1; // r4
  int *v2; // r5
  __int16 v3; // r3
  int *v4; // r7
  int v5; // r3
  signed int result; // r0
  _WORD *v7; // r3
  __int16 v8; // r3
  int v9; // r1
  int v10; // r7
  int v11; // r0
  int v12; // r1
  int v13; // r8
  void (__fastcall *v14)(int *); // r3

  v1 = a1;
  v2 = *(int **)(a1 + 28);
  if ( !v2 )
    return -1;
  if ( v2[67] == a1 )
  {
    if ( dword_2F84CC )
    {
      v10 = v2[65];
      if ( v10 != dword_2F84CC() )
      {
        v11 = v2[68];
        ++v2[69];
        if ( v11 )
        {
          v12 = v2[66];
          dword_2F8528();
        }
      }
    }
  }
  if ( !(*(_WORD *)(v1 + 48) & 8) || !*(_WORD *)(v1 + 40) )
  {
    v3 = *(_WORD *)(v1 + 52);
    if ( v3 & 1 )
      goto LABEL_22;
LABEL_5:
    if ( v3 & 8 )
      goto LABEL_23;
LABEL_6:
    v4 = (int *)(v3 & 2);
    if ( v3 & 2 )
      goto LABEL_24;
    goto LABEL_7;
  }
  v7 = *(_WORD **)(v1 + 44);
  if ( v7 )
    *v7 = 0;
  v3 = *(_WORD *)(v1 + 52);
  if ( !(v3 & 1) )
    goto LABEL_5;
LABEL_22:
  sub_87588(v2, v1, 1);
  v3 = *(_WORD *)(v1 + 52);
  if ( !(v3 & 8) )
    goto LABEL_6;
LABEL_23:
  sub_87588(v2, v1, 8);
  v8 = *(_WORD *)(v1 + 52);
  v4 = (int *)(v8 & 2);
  if ( v8 & 2 )
  {
LABEL_24:
    sub_87588(v2, v1, 2);
    v9 = *(_DWORD *)(v1 + 24);
    if ( *(_WORD *)(v1 + 48) & 6 )
      v4 = sub_8D648(v2, v9, v1);
    else
      v4 = (int *)sub_8D86C(v2, v9, v1);
    if ( v4 == (int *)((char *)&dword_0 + 1) )
    {
      if ( dword_2F84CC
        && v2[37]
        && (v13 = v2[65], v13 != dword_2F84CC())
        && (v14 = (void (__fastcall *)(int *))v2[92]) != 0
        && !v2[71] )
      {
        v2[71] = 1;
        v14(v2);
        v4 = 0;
      }
      else
      {
        v4 = 0;
      }
    }
  }
LABEL_7:
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v5 = off_F3C04[0][(v1 >> 6) % dword_F3C08]) == 0 )
LABEL_40:
      sub_25DC0(v1);
    while ( v1 != *(_DWORD *)(v5 + 4) )
    {
      v5 = *(_DWORD *)v5;
      if ( !v5 )
        goto LABEL_40;
    }
    *(_BYTE *)(v5 + 8) &= 0xFEu;
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  result = (signed int)v4;
  dword_2F84B0 = 1;
  return result;
}
// 0: using guessed type int dword_0;
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8528: using guessed type int (*dword_2F8528)(void);

//----- (00087CBC) --------------------------------------------------------
int __fastcall sub_87CBC(_DWORD *a1, struct timeval *a2)
{
  _DWORD *v2; // r4
  struct timeval *v3; // r5
  int v4; // r1
  int v5; // r2
  bool v6; // zf
  bool v7; // nf
  unsigned __int8 v8; // vf
  int v9; // r1
  int v10; // r6

  v2 = a1;
  v3 = a2;
  if ( !a1 )
  {
    v2 = (_DWORD *)dword_2F84B4;
    if ( !dword_2F84B4 )
      return gettimeofday(a2, (__timezone_ptr_t)dword_2F84B4);
  }
  if ( v2[66] )
    dword_2F850C(0);
  v4 = v2[60];
  if ( v4 )
  {
    v5 = v2[61] + v2[63];
    v8 = __OFSUB__(v5, 999999);
    v6 = v5 == 999999;
    v7 = v5 - 999999 < 0;
    v9 = v4 + v2[62];
    if ( v5 > 999999 )
      v5 -= 999424;
    v3->tv_sec = v9;
    if ( (unsigned __int8)(v7 ^ v8) | v6 )
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      v5 -= 576;
      ++v9;
    }
    if ( !((unsigned __int8)(v7 ^ v8) | v6) )
      v3->tv_sec = v9;
    v3->tv_usec = v5;
  }
  else
  {
    v10 = gettimeofday(v3, 0);
  }
  if ( v2[66] )
    dword_2F8510(0);
  return v10;
}
// 2F84B4: using guessed type int dword_2F84B4;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00087DCC) --------------------------------------------------------
int __fastcall sub_87DCC(int result)
{
  if ( result )
    result += 172;
  return result;
}

//----- (00088084) --------------------------------------------------------
signed int __fastcall sub_88084(int a1, unsigned int a2)
{
  unsigned int v2; // r4
  int v3; // r5
  _DWORD *v4; // r2
  int v5; // r3
  signed int result; // r0

  v2 = a2;
  v3 = a1;
  if ( *(_WORD *)(a2 + 52) != 128 )
    return -1;
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v4 = (_DWORD *)off_F3C04[0][(v2 >> 6) % dword_F3C08]) == 0 )
LABEL_15:
      sub_9098C(
        -559030611,
        "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBEF0,
        v2,
        *(signed __int16 *)(v2 + 48),
        *(_DWORD *)(v2 + 24),
        *(signed __int16 *)(v2 + 52));
    while ( v2 != v4[1] )
    {
      v4 = (_DWORD *)*v4;
      if ( !v4 )
        goto LABEL_15;
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  v5 = *(_DWORD *)(v3 + 156);
  result = 0;
  *(_DWORD *)(v2 + 28) = v3;
  *(_BYTE *)(v2 + 54) = v5 / 2;
  return result;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000881C4) --------------------------------------------------------
int __fastcall sub_881C4(unsigned int a1, int a2)
{
  unsigned int v2; // r4
  int v3; // r5
  _DWORD *v4; // r2
  int result; // r0

  v2 = a1;
  v3 = a2;
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v4 = (_DWORD *)off_F3C04[0][(v2 >> 6) % dword_F3C08]) == 0 )
LABEL_17:
      sub_9098C(
        -559030611,
        "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBF00,
        v2,
        *(signed __int16 *)(v2 + 48),
        *(_DWORD *)(v2 + 24),
        *(signed __int16 *)(v2 + 52));
    while ( v2 != v4[1] )
    {
      v4 = (_DWORD *)*v4;
      if ( !v4 )
        goto LABEL_17;
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  result = *(_WORD *)(v2 + 52) & 8;
  if ( *(_WORD *)(v2 + 52) & 8 || v3 < 0 || v3 >= *(_DWORD *)(*(_DWORD *)(v2 + 28) + 156) )
    return -1;
  *(_BYTE *)(v2 + 54) = v3;
  return result;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00088310) --------------------------------------------------------
int __fastcall sub_88310(unsigned int a1, char a2, int *a3)
{
  char v3; // r8
  unsigned int v4; // r4
  int *v5; // r7
  _DWORD *v6; // r12
  __int16 v7; // r3
  __int16 v8; // r5
  _DWORD *v9; // r3
  int v11; // r2
  bool v12; // zf
  bool v13; // nf
  unsigned __int8 v14; // vf
  int v15; // r1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 264) )
    dword_2F850C(0);
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v6 = (_DWORD *)off_F3C04[0][(v4 >> 6) % dword_F3C08]) == 0 )
LABEL_32:
      sub_9098C(
        -559030611,
        "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBF14,
        v4,
        *(signed __int16 *)(v4 + 48),
        *(_DWORD *)(v4 + 24),
        *(signed __int16 *)(v4 + 52));
    while ( v4 != v6[1] )
    {
      v6 = (_DWORD *)*v6;
      if ( !v6 )
        goto LABEL_32;
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  v7 = *(_WORD *)(v4 + 52);
  v8 = *(_WORD *)(v4 + 52) & 2;
  if ( v7 & 2 )
    v8 = *(_WORD *)(v4 + 48) & 0xE;
  if ( v7 & 8 )
    v8 |= *(_WORD *)(v4 + 50);
  if ( v7 & 1 )
    LOBYTE(v8) = v8 | 1;
  v9 = *(_DWORD **)(v4 + 28);
  if ( v5 && (unsigned __int8)v8 & v3 & 1 )
  {
    v11 = (*(_DWORD *)(v4 + 60) & 0xFFFFF) + v9[63];
    v14 = __OFSUB__(v11, 999999);
    v12 = v11 == 999999;
    v13 = v11 - 999999 < 0;
    v15 = v9[62] + *(_DWORD *)(v4 + 56);
    if ( v11 > 999999 )
      v11 -= 999424;
    *v5 = v15;
    if ( (unsigned __int8)(v13 ^ v14) | v12 )
    {
      v5[1] = v11;
    }
    else
    {
      v11 -= 576;
      ++v15;
    }
    if ( !((unsigned __int8)(v13 ^ v14) | v12) )
    {
      *v5 = v15;
      v5[1] = v11;
    }
  }
  if ( v9[66] )
    dword_2F8510(0);
  return (unsigned __int8)v8 & v3 & 0xF;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00088504) --------------------------------------------------------
unsigned int __fastcall sub_88504(int a1)
{
  return ((unsigned int)*(unsigned __int16 *)(a1 + 52) >> 7) & 1;
}

//----- (000887A4) --------------------------------------------------------
int __fastcall sub_887A4(unsigned int a1)
{
  unsigned int v1; // r4
  _DWORD *v2; // r2

  v1 = a1;
  if ( !dword_2F84A8 )
    return *(_DWORD *)(v1 + 28);
  if ( dword_2F84AC )
    dword_2F850C(0);
  if ( !off_F3C04[0] || (v2 = (_DWORD *)off_F3C04[0][(v1 >> 6) % dword_F3C08]) == 0 )
LABEL_10:
    sub_9098C(
      -559030611,
      "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
      &unk_EBF4C,
      v1,
      *(signed __int16 *)(v1 + 48),
      *(_DWORD *)(v1 + 24),
      *(signed __int16 *)(v1 + 52));
  while ( v1 != v2[1] )
  {
    v2 = (_DWORD *)*v2;
    if ( !v2 )
      goto LABEL_10;
  }
  if ( dword_2F84AC )
    dword_2F8510(0);
  return *(_DWORD *)(v1 + 28);
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00088C24) --------------------------------------------------------
int *__fastcall sub_88C24(unsigned int a1)
{
  unsigned int v1; // r4
  int *v2; // r5
  __int16 v3; // r3
  int *v4; // r7
  int v5; // r3
  _WORD *v7; // r3
  __int16 v8; // r3
  int v9; // r1
  int v10; // r7
  int v11; // r0
  int v12; // r1
  int v13; // r8
  void (__fastcall *v14)(int *); // r3

  v1 = a1;
  v2 = *(int **)(a1 + 28);
  if ( v2[66] )
  {
    dword_2F850C(0);
    v2 = *(int **)(v1 + 28);
    if ( !v2 )
    {
      v4 = (int *)-1;
      goto LABEL_19;
    }
  }
  if ( v1 == v2[67] )
  {
    if ( dword_2F84CC )
    {
      v10 = v2[65];
      if ( v10 != dword_2F84CC() )
      {
        v11 = v2[68];
        ++v2[69];
        if ( v11 )
        {
          v12 = v2[66];
          dword_2F8528();
        }
      }
    }
  }
  if ( !(*(_WORD *)(v1 + 48) & 8) || !*(_WORD *)(v1 + 40) )
  {
    v3 = *(_WORD *)(v1 + 52);
    if ( v3 & 1 )
      goto LABEL_26;
LABEL_6:
    if ( v3 & 8 )
      goto LABEL_27;
LABEL_7:
    v4 = (int *)(v3 & 2);
    if ( v3 & 2 )
      goto LABEL_28;
    goto LABEL_8;
  }
  v7 = *(_WORD **)(v1 + 44);
  if ( v7 )
    *v7 = 0;
  v3 = *(_WORD *)(v1 + 52);
  if ( !(v3 & 1) )
    goto LABEL_6;
LABEL_26:
  sub_87588(v2, v1, 1);
  v3 = *(_WORD *)(v1 + 52);
  if ( !(v3 & 8) )
    goto LABEL_7;
LABEL_27:
  sub_87588(v2, v1, 8);
  v8 = *(_WORD *)(v1 + 52);
  v4 = (int *)(v8 & 2);
  if ( v8 & 2 )
  {
LABEL_28:
    sub_87588(v2, v1, 2);
    v9 = *(_DWORD *)(v1 + 24);
    if ( *(_WORD *)(v1 + 48) & 6 )
      v4 = sub_8D648(v2, v9, v1);
    else
      v4 = (int *)sub_8D86C(v2, v9, v1);
    if ( v4 == (int *)((char *)&dword_0 + 1) )
    {
      if ( dword_2F84CC
        && v2[37]
        && (v13 = v2[65], v13 != dword_2F84CC())
        && (v14 = (void (__fastcall *)(int *))v2[92]) != 0
        && !v2[71] )
      {
        v2[71] = 1;
        v14(v2);
        v4 = 0;
      }
      else
      {
        v4 = 0;
      }
    }
  }
LABEL_8:
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v5 = off_F3C04[0][(v1 >> 6) % dword_F3C08]) == 0 )
LABEL_44:
      sub_25DC0(v1);
    while ( v1 != *(_DWORD *)(v5 + 4) )
    {
      v5 = *(_DWORD *)v5;
      if ( !v5 )
        goto LABEL_44;
    }
    *(_BYTE *)(v5 + 8) &= 0xFEu;
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  v2 = *(int **)(v1 + 28);
  dword_2F84B0 = 1;
LABEL_19:
  if ( v2[66] )
    dword_2F8510(0);
  return v4;
}
// 0: using guessed type int dword_0;
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8528: using guessed type int (*dword_2F8528)(void);

//----- (00088F24) --------------------------------------------------------
void *__fastcall sub_88F24(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r6
  int v5; // r5
  void *result; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  result = memset(a1, 0, 0x14u);
  v3[3] = v4;
  v3[4] = v5;
  return result;
}

//----- (00088F4C) --------------------------------------------------------
int __fastcall sub_88F4C(int result, int *a2)
{
  _DWORD *v2; // r5
  int *v3; // r4
  int v4; // r3
  _DWORD *v5; // r2
  char v6; // r3

  v2 = (_DWORD *)result;
  v3 = a2;
  if ( !result )
  {
    if ( !dword_2F84B4 )
      return result;
    v2 = (_DWORD *)(dword_2F84B4 + 172);
  }
  if ( *v2 )
    result = dword_2F850C(0);
  if ( v3[2] & 1 )
  {
    v4 = *v3;
    v5 = (_DWORD *)v3[1];
    if ( *v3 )
    {
      *(_DWORD *)(v4 + 4) = v5;
      v5 = (_DWORD *)v3[1];
    }
    else
    {
      v2[5] = v5;
    }
    *v5 = v4;
    v6 = *((_BYTE *)v3 + 8);
    --v2[1];
    *((_BYTE *)v3 + 8) = v6 & 0xFE;
  }
  if ( *v2 )
    result = dword_2F8510(0);
  return result;
}
// 2F84B4: using guessed type int dword_2F84B4;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008900C) --------------------------------------------------------
int __fastcall sub_8900C(int result, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  char v4; // r3
  _DWORD *v5; // r2
  int v6; // r2
  int (__fastcall *v7)(_DWORD *, _DWORD); // r3

  v2 = (_DWORD *)result;
  v3 = a2;
  if ( !result )
  {
    if ( !dword_2F84B4 )
      return result;
    v2 = (_DWORD *)(dword_2F84B4 + 172);
  }
  if ( *v2 )
    result = dword_2F850C(0);
  v4 = *(_BYTE *)(v3 + 8);
  if ( !(*(_BYTE *)(v3 + 8) & 1) )
  {
    v5 = (_DWORD *)v2[5];
    *(_DWORD *)v3 = 0;
    *(_BYTE *)(v3 + 8) = v4 | 1;
    *(_DWORD *)(v3 + 4) = v5;
    *v5 = v3;
    v6 = v2[1];
    v7 = (int (__fastcall *)(_DWORD *, _DWORD))v2[2];
    v2[5] = v3;
    v2[1] = v6 + 1;
    if ( v7 )
      result = v7(v2, v2[3]);
  }
  if ( *v2 )
    result = dword_2F8510(0);
  return result;
}
// 2F84B4: using guessed type int dword_2F84B4;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00089108) --------------------------------------------------------
void *__fastcall sub_89108(size_t a1)
{
  void *result; // r0

  if ( dword_2F84B8 )
    result = (void *)dword_2F84B8(a1);
  else
    result = malloc(a1);
  return result;
}
// 2F84B8: using guessed type int (__fastcall *dword_2F84B8)(_DWORD);

//----- (00089134) --------------------------------------------------------
void *__fastcall sub_89134(size_t a1, size_t a2)
{
  size_t v2; // r4
  void *v3; // r0
  void *v4; // r5

  if ( !dword_2F84B8 )
    return calloc(a1, a2);
  v2 = a2 * a1;
  v3 = (void *)dword_2F84B8(a2 * a1);
  v4 = v3;
  if ( v3 )
    memset(v3, 0, v2);
  return v4;
}
// 2F84B8: using guessed type int (__fastcall *dword_2F84B8)(_DWORD);

//----- (00089180) --------------------------------------------------------
_DWORD *sub_89180()
{
  _DWORD *result; // r0

  result = sub_89134(1u, 0x14u);
  if ( result )
  {
    result[1] = result;
    *result = 0;
  }
  return result;
}

//----- (000891A4) --------------------------------------------------------
char *__fastcall sub_891A4(const char *a1)
{
  const char *v1; // r6
  int (__fastcall *v2)(size_t); // r4
  size_t v3; // r0
  size_t v4; // r5
  void *v5; // r0
  void *v6; // r4

  v1 = a1;
  v2 = dword_2F84B8;
  if ( !dword_2F84B8 )
    return strdup(a1);
  v3 = strlen(a1);
  v4 = v3 + 1;
  v5 = (void *)v2(v3 + 1);
  v6 = v5;
  if ( v5 )
    memcpy(v5, v1, v4);
  return (char *)v6;
}
// 2F84B8: using guessed type int (__fastcall *dword_2F84B8)(_DWORD);

//----- (000891F8) --------------------------------------------------------
void *__fastcall sub_891F8(void *a1, size_t a2)
{
  void *result; // r0

  if ( dword_2F84BC )
    result = (void *)dword_2F84BC();
  else
    result = realloc(a1, a2);
  return result;
}
// 2F84BC: using guessed type int (*dword_2F84BC)(void);

//----- (00089224) --------------------------------------------------------
int __fastcall sub_89224(int a1, __int16 a2, __int16 a3)
{
  int v3; // r4
  __int16 v4; // r3
  __int16 v5; // r7
  int result; // r0
  _DWORD *v7; // r5
  int v8; // r12
  bool v9; // zf
  __int16 v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r3
  int v15; // r4
  int (__fastcall *v16)(_DWORD *); // r3
  int v17; // r9
  int v18; // r0
  int v19; // r1

  v3 = a1;
  v4 = *(_WORD *)(a1 + 52);
  v5 = a3;
  result = v4 & 8;
  if ( v4 & 8 )
  {
    *(_WORD *)(v3 + 50) |= a2;
  }
  else
  {
    v7 = *(_DWORD **)(v3 + 28);
    v8 = *(unsigned __int8 *)(v3 + 54);
    *(_WORD *)(v3 + 50) = a2;
    if ( v8 < v7[36] )
      v7[35] = 1;
    if ( *(_WORD *)(v3 + 48) & 8 )
    {
      if ( v3 == v7[67] && dword_2F84CC )
      {
        v17 = v7[65];
        if ( v17 != ((int (__fastcall *)(_DWORD))dword_2F84CC)(0) )
        {
          v18 = v7[68];
          ++v7[69];
          if ( v18 )
          {
            v19 = v7[66];
            dword_2F8528();
          }
        }
        v4 = *(_WORD *)(v3 + 52);
        result = v4 & 8;
      }
      *(_WORD *)(v3 + 40) = v5;
      *(_DWORD *)(v3 + 44) = 0;
    }
    if ( !result )
    {
      v9 = (v4 & 0x10) == 0;
      v10 = v4 | 8;
      if ( v9 )
        ++v7[31];
      v11 = v7[32];
      *(_WORD *)(v3 + 52) = v10;
      v7[32] = v11 + 1;
      v12 = *(unsigned __int8 *)(v3 + 54);
      v13 = v7[38];
      *(_DWORD *)v3 = 0;
      v14 = *(_DWORD **)(v13 + 8 * v12 + 4);
      *(_DWORD *)(v3 + 4) = v14;
      *v14 = v3;
      *(_DWORD *)(v7[38] + 8 * *(unsigned __int8 *)(v3 + 54) + 4) = v3;
    }
    if ( dword_2F84CC )
    {
      if ( v7[37] )
      {
        v15 = v7[65];
        result = dword_2F84CC();
        if ( v15 != result )
        {
          v16 = (int (__fastcall *)(_DWORD *))v7[92];
          if ( v16 )
          {
            if ( !v7[71] )
            {
              v7[71] = 1;
              result = v16(v7);
            }
          }
        }
      }
    }
  }
  return result;
}
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F8528: using guessed type int (*dword_2F8528)(void);

//----- (00089540) --------------------------------------------------------
unsigned int __fastcall sub_89540(int a1, int a2)
{
  int v2; // r5
  unsigned int v3; // r4
  int v4; // r8
  int v5; // r9
  int v6; // r6
  _DWORD *v7; // r12
  __int16 v8; // r3
  char v9; // r10
  __int16 v10; // r2
  _WORD *v11; // r3
  int v12; // r3
  __int16 v13; // r2
  __int16 v14; // r1
  unsigned int result; // r0
  unsigned int v16; // r3
  unsigned int v17; // r2
  unsigned int v18; // r10
  int v19; // r3
  int v20; // r10
  int v21; // r0
  int v22; // r1
  bool v23; // zf
  unsigned int v24; // r1
  unsigned int v25; // r12
  __int16 v26; // r2
  unsigned int v27; // r12
  int v28; // r8
  unsigned int v29; // r2
  unsigned int v30; // r12
  unsigned int v31; // r3
  _DWORD *v32; // r2
  int v33; // r0
  int v34; // r8
  int v35; // r12
  int v36; // r8
  int (__fastcall *v37)(int); // r3
  unsigned int *v38; // r3
  char v39; // [sp+10h] [bp-28h]

  v2 = a1;
  v3 = a1 + 16;
  v4 = *(_DWORD *)(a2 + 56);
  v5 = *(_DWORD *)(a2 + 60);
  v6 = *(_DWORD *)(a1 + 44);
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v7 = (_DWORD *)off_F3C04[0][(v3 >> 6) % dword_F3C08]) == 0 )
LABEL_105:
      sub_9098C(
        -559030611,
        "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBFAC,
        v3,
        *(signed __int16 *)(v2 + 64),
        *(_DWORD *)(v2 + 40),
        *(signed __int16 *)(v2 + 68));
    while ( v3 != v7[1] )
    {
      v7 = (_DWORD *)*v7;
      if ( !v7 )
        goto LABEL_105;
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  if ( *(_WORD *)(v2 + 68) & 1 || (v16 = *(_DWORD *)(v6 + 236), v17 = *(_DWORD *)(v6 + 232) + 1, v17 <= v16) )
  {
    v8 = *(_WORD *)(v2 + 64);
    if ( v3 != *(_DWORD *)(v6 + 268) )
      goto LABEL_13;
    goto LABEL_44;
  }
  if ( v16 )
    v18 = 2 * v16;
  else
    v18 = 8;
  if ( v18 < v17 )
    v18 = *(_DWORD *)(v6 + 232) + 1;
  result = (unsigned int)sub_891F8(*(void **)(v6 + 228), 4 * v18);
  if ( !result )
    return result;
  v19 = *(_DWORD *)(v6 + 268);
  *(_DWORD *)(v6 + 228) = result;
  v23 = v3 == v19;
  *(_DWORD *)(v6 + 236) = v18;
  v8 = *(_WORD *)(v2 + 64);
  if ( v23 )
  {
LABEL_44:
    if ( v8 & 8 && dword_2F84CC )
    {
      v20 = *(_DWORD *)(v6 + 260);
      if ( v20 != dword_2F84CC() )
      {
        v21 = *(_DWORD *)(v6 + 272);
        ++*(_DWORD *)(v6 + 276);
        if ( v21 )
        {
          v22 = *(_DWORD *)(v6 + 264);
          dword_2F8528();
        }
      }
      v8 = *(_WORD *)(v2 + 64);
    }
  }
LABEL_13:
  v9 = v8 & 0xE;
  if ( !(v8 & 0xE) )
  {
    v10 = *(_WORD *)(v2 + 68);
    goto LABEL_15;
  }
  v14 = *(_WORD *)(v2 + 68);
  LOBYTE(v10) = v14;
  if ( v14 & 0xA )
  {
    v9 = 0;
    goto LABEL_15;
  }
  if ( v8 & 6 )
  {
    result = sub_8D478((_DWORD *)v6, *(_DWORD *)(v2 + 40), v3);
  }
  else
  {
    if ( !(v8 & 8) )
    {
      result = 0;
LABEL_33:
      if ( v14 & 2 )
        sub_25E0C(v3, 2);
      v10 = v14 | 2;
      v9 = 0;
      if ( !(v14 & 0x10) )
        ++*(_DWORD *)(v6 + 124);
      v38 = *(unsigned int **)(v6 + 216);
      *(_WORD *)(v2 + 68) = v10;
      *(_DWORD *)(v2 + 24) = 0;
      if ( result == 1 )
        v9 = 1;
      *(_DWORD *)(v2 + 28) = v38;
      *v38 = v3;
      *(_DWORD *)(v6 + 216) = v2 + 24;
LABEL_15:
      if ( v10 & 1 )
      {
        if ( !*(_DWORD *)(v2 + 32) )
          v9 = 1;
        sub_87588((_DWORD *)v6, v3, 1);
        v10 = *(_WORD *)(v2 + 68);
      }
      if ( v10 & 8 && *(_WORD *)(v2 + 66) & 1 )
      {
        if ( *(_WORD *)(v2 + 64) & 8 )
        {
          if ( *(_WORD *)(v2 + 56) )
          {
            v11 = *(_WORD **)(v2 + 60);
            if ( v11 )
              *v11 = 0;
          }
        }
        sub_87588((_DWORD *)v6, v3, 8);
      }
      sub_87440((_DWORD *)v6, (struct timeval *)&v39);
      v13 = *(_WORD *)(v2 + 68);
      *(_DWORD *)(v2 + 72) = v4;
      *(_DWORD *)(v2 + 76) = v5 & 0xFFFFF;
      if ( v13 & 1 )
        sub_25E0C(v3, 1);
      v23 = (v13 & 0x10) == 0;
      v24 = *(_DWORD *)(v6 + 232);
      v25 = *(_DWORD *)(v6 + 236);
      v26 = v13 | 1;
      if ( v23 )
        v12 = *(_DWORD *)(v6 + 124);
      result = v24 + 1;
      if ( v23 )
        *(_DWORD *)(v6 + 124) = v12 + 1;
      *(_WORD *)(v2 + 68) = v26;
      if ( result <= v25 )
      {
        v30 = *(_DWORD *)(v6 + 228);
      }
      else
      {
        if ( v25 )
          v27 = 2 * v25;
        else
          v27 = 8;
        if ( v27 < result )
          v28 = v24 + 1;
        else
          v28 = v27;
        result = (unsigned int)sub_891F8(*(void **)(v6 + 228), 4 * v28);
        if ( !result )
        {
          v29 = *(_DWORD *)(v2 + 32);
LABEL_90:
          if ( !v29 || v9 & 1 )
          {
            if ( dword_2F84CC )
            {
              if ( *(_DWORD *)(v6 + 148) )
              {
                v36 = *(_DWORD *)(v6 + 260);
                result = dword_2F84CC();
                if ( v36 != result )
                {
                  v37 = *(int (__fastcall **)(int))(v6 + 368);
                  if ( v37 )
                  {
                    if ( !*(_DWORD *)(v6 + 284) )
                    {
                      *(_DWORD *)(v6 + 284) = 1;
                      result = v37(v6);
                    }
                  }
                }
              }
            }
          }
          goto LABEL_76;
        }
        v24 = *(_DWORD *)(v6 + 232);
        v30 = result;
        *(_DWORD *)(v6 + 228) = result;
        result = v24 + 1;
        *(_DWORD *)(v6 + 236) = v28;
      }
      *(_DWORD *)(v6 + 232) = result;
      v31 = (v24 - 1) >> 1;
      if ( v24 )
      {
        while ( 1 )
        {
          v32 = *(_DWORD **)(v30 + 4 * v31);
          v33 = *(_DWORD *)(v2 + 72);
          v34 = v32[14];
          if ( v34 == v33 )
            result = v32[15] > *(_DWORD *)(v2 + 76);
          else
            result = v34 > v33;
          if ( !result )
          {
            v31 = 4 * v24;
            goto LABEL_89;
          }
          *(_DWORD *)(v30 + 4 * v24) = v32;
          result = (v31 - 1) >> 1;
          v32[4] = v24;
          if ( !v31 )
            break;
          v30 = *(_DWORD *)(v6 + 228);
          v24 = v31;
          v31 = (v31 - 1) >> 1;
        }
        v24 = 0;
        v30 = *(_DWORD *)(v6 + 228);
      }
      else
      {
        v31 = 0;
      }
LABEL_89:
      v29 = v24;
      *(_DWORD *)(v30 + v31) = v3;
      *(_DWORD *)(v2 + 32) = v24;
      goto LABEL_90;
    }
    result = sub_8D78C((_DWORD *)v6, *(_DWORD *)(v2 + 40), (_DWORD *)v3);
  }
  if ( result != -1 )
  {
    v14 = *(_WORD *)(v2 + 68);
    goto LABEL_33;
  }
LABEL_76:
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (result = (v3 >> 6) / dword_F3C08, (v35 = off_F3C04[0][(v3 >> 6) % dword_F3C08]) == 0) )
LABEL_106:
      sub_9098C(
        -559030611,
        "%s: noting an add on a non-setup event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBFAC,
        v3,
        *(signed __int16 *)(v2 + 64),
        *(_DWORD *)(v2 + 40),
        *(signed __int16 *)(v2 + 68));
    while ( v3 != *(_DWORD *)(v35 + 4) )
    {
      v35 = *(_DWORD *)v35;
      if ( !v35 )
        goto LABEL_106;
    }
    *(_BYTE *)(v35 + 8) |= 1u;
    if ( dword_2F84AC )
      result = dword_2F8510(0);
  }
  dword_2F84B0 = 1;
  return result;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8528: using guessed type int (*dword_2F8528)(void);

//----- (00089B44) --------------------------------------------------------
signed int __fastcall sub_89B44(int a1, _DWORD *a2, _BOOL4 a3)
{
  unsigned int v3; // r4
  _DWORD *v4; // r6
  int v5; // r5
  _DWORD *v6; // r3
  __int16 v7; // r3
  int v8; // r9
  __int16 v9; // r2
  signed int v10; // r10
  int v11; // r11
  int v12; // r8
  __int16 v13; // r3
  _WORD *v14; // r3
  unsigned int v15; // r3
  _BOOL4 v16; // r12
  unsigned int v17; // r3
  _DWORD *v18; // r0
  int v19; // r3
  signed int result; // r0
  unsigned int v21; // r3
  unsigned int v22; // r2
  unsigned int v23; // r8
  int v24; // r3
  int v25; // r8
  int v26; // r0
  int v27; // r1
  int v28; // r6
  void (__fastcall *v29)(int); // r3
  int v30; // r1
  _DWORD *v31; // r3
  __int16 v32; // r3
  int v33; // r3
  bool v34; // zf
  bool v35; // nf
  unsigned __int8 v36; // vf
  int v37; // r2
  __int16 v38; // r3
  unsigned int v39; // r2
  unsigned int v40; // r1
  unsigned int v41; // r0
  unsigned int v42; // r2
  unsigned int v43; // r0
  int v44; // r3
  _BOOL4 v45; // ST14_4
  _DWORD *v46; // r0
  _DWORD *v47; // r6
  _DWORD *v48; // r2
  int v49; // r12
  int v50; // r0
  int v51; // r1
  int v52; // r1
  int v53; // r3
  int v54; // r0
  bool v55; // zf
  bool v56; // nf
  unsigned __int8 v57; // vf
  int v58; // r2
  int v59; // r2
  _BOOL4 v60; // ST14_4
  __int16 v61; // r2
  unsigned int *v62; // r3
  _BOOL4 v63; // [sp+10h] [bp-40h]
  int v64; // [sp+18h] [bp-38h]
  _BOOL4 v65; // [sp+1Ch] [bp-34h]
  _BOOL4 v66; // [sp+1Ch] [bp-34h]
  int v67; // [sp+20h] [bp-30h]
  int v68; // [sp+24h] [bp-2Ch]

  v3 = a1;
  v4 = a2;
  v65 = a3;
  v5 = *(_DWORD *)(a1 + 28);
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (a1 = (v3 >> 6) / dword_F3C08, (v6 = (_DWORD *)off_F3C04[0][(v3 >> 6) % dword_F3C08]) == 0) )
LABEL_141:
      sub_9098C(
        -559030611,
        "%s called on a non-initialized event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBFAC,
        v3,
        *(signed __int16 *)(v3 + 48),
        *(_DWORD *)(v3 + 24),
        *(signed __int16 *)(v3 + 52));
    while ( v3 != v6[1] )
    {
      v6 = (_DWORD *)*v6;
      if ( !v6 )
        goto LABEL_141;
    }
    if ( dword_2F84AC )
      a1 = dword_2F8510(0);
  }
  if ( !v4 || *(_WORD *)(v3 + 52) & 1 || (v21 = *(_DWORD *)(v5 + 236), v22 = *(_DWORD *)(v5 + 232) + 1, v22 <= v21) )
  {
    if ( *(_DWORD *)(v5 + 268) != v3 )
      goto LABEL_14;
    goto LABEL_69;
  }
  if ( v21 )
    v23 = 2 * v21;
  else
    v23 = 8;
  if ( v23 < v22 )
    v23 = *(_DWORD *)(v5 + 232) + 1;
  a1 = (int)sub_891F8(*(void **)(v5 + 228), 4 * v23);
  if ( !a1 )
    return -1;
  v24 = *(_DWORD *)(v5 + 268);
  *(_DWORD *)(v5 + 228) = a1;
  *(_DWORD *)(v5 + 236) = v23;
  if ( v24 == v3 )
  {
LABEL_69:
    if ( *(_WORD *)(v3 + 48) & 8 )
    {
      if ( dword_2F84CC )
      {
        v25 = *(_DWORD *)(v5 + 260);
        if ( v25 != ((int (__fastcall *)(int))dword_2F84CC)(a1) )
        {
          v26 = *(_DWORD *)(v5 + 272);
          ++*(_DWORD *)(v5 + 276);
          if ( v26 )
          {
            v27 = *(_DWORD *)(v5 + 264);
            dword_2F8528();
          }
        }
      }
    }
  }
LABEL_14:
  v7 = *(_WORD *)(v3 + 48);
  v8 = v7 & 0xE;
  if ( !(v7 & 0xE) )
  {
LABEL_21:
    v11 = 1;
    v10 = v8;
    goto LABEL_22;
  }
  v9 = *(_WORD *)(v3 + 52);
  if ( v9 & 0xA )
  {
    v8 = 0;
    goto LABEL_21;
  }
  if ( v7 & 6 )
  {
    v10 = sub_8D478((_DWORD *)v5, *(_DWORD *)(v3 + 24), v3);
  }
  else
  {
    v10 = v7 & 8;
    if ( !(v7 & 8) )
      goto LABEL_18;
    v10 = sub_8D78C((_DWORD *)v5, *(_DWORD *)(v3 + 24), (_DWORD *)v3);
  }
  if ( v10 == -1 )
    goto LABEL_80;
  v9 = *(_WORD *)(v3 + 52);
LABEL_18:
  if ( v9 & 2 )
    sub_25E0C(v3, 2);
  v34 = (v9 & 0x10) == 0;
  v61 = v9 | 2;
  if ( v34 )
    ++*(_DWORD *)(v5 + 124);
  v62 = *(unsigned int **)(v5 + 216);
  *(_WORD *)(v3 + 52) = v61;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = v62;
  *v62 = v3;
  *(_DWORD *)(v5 + 216) = v3 + 8;
  if ( v10 == 1 )
  {
    v11 = 1;
    v10 = 0;
    LOBYTE(v8) = 1;
    goto LABEL_22;
  }
LABEL_80:
  v11 = v10 + 1;
  LOBYTE(v8) = 0;
  if ( v10 != -1 )
    v11 = 1;
LABEL_22:
  if ( v4 )
    v12 = v11 & 1;
  else
    v12 = 0;
  if ( !v12 )
    goto LABEL_45;
  if ( *(_BYTE *)(v3 + 55) == 2 && !v65 )
  {
    v51 = v4[1];
    *(_DWORD *)(v3 + 40) = *v4;
    *(_DWORD *)(v3 + 44) = v51;
  }
  v13 = *(_WORD *)(v3 + 52);
  if ( v13 & 1 )
  {
    if ( !*(_DWORD *)(v3 + 16) )
      LOBYTE(v8) = 1;
    sub_87588((_DWORD *)v5, v3, 1);
    v13 = *(_WORD *)(v3 + 52);
  }
  if ( v13 & 8 && *(_WORD *)(v3 + 50) & 1 )
  {
    if ( *(_WORD *)(v3 + 48) & 8 )
    {
      if ( *(_WORD *)(v3 + 40) )
      {
        v14 = *(_WORD **)(v3 + 44);
        if ( v14 )
          *v14 = 0;
      }
    }
    sub_87588((_DWORD *)v5, v3, 8);
  }
  sub_87440((_DWORD *)v5, (struct timeval *)&v67);
  v15 = v4[1];
  if ( (v15 & 0xF0000000) != 1342177280 )
  {
    v16 = v65;
    if ( v65 )
    {
      v16 = 0;
LABEL_84:
      v30 = v4[1];
      v31 = (_DWORD *)(v3 + 56);
      *v31 = *v4;
      v31[1] = v30;
      goto LABEL_85;
    }
    goto LABEL_123;
  }
  v16 = (signed int)((v15 >> 20) & 0xFF) < *(_DWORD *)(v5 + 164);
  if ( v65 )
    goto LABEL_84;
  if ( (signed int)((v15 >> 20) & 0xFF) >= *(_DWORD *)(v5 + 164) )
  {
LABEL_123:
    v52 = *v4;
    v53 = v15 + v68;
    v54 = v67;
    v57 = __OFSUB__(v53, 999999);
    v55 = v53 == 999999;
    v56 = v53 - 999999 < 0;
    if ( v53 <= 999999 )
      *(_DWORD *)(v3 + 60) = v53;
    v58 = v54 + v52;
    if ( v53 > 999999 )
      v53 -= 999424;
    *(_DWORD *)(v3 + 56) = v58;
    if ( (unsigned __int8)(v56 ^ v57) | v55 )
    {
      v16 = 0;
    }
    else
    {
      v53 -= 576;
      ++v58;
    }
    if ( !((unsigned __int8)(v56 ^ v57) | v55) )
    {
      v16 = 0;
      *(_DWORD *)(v3 + 60) = v53;
      *(_DWORD *)(v3 + 56) = v58;
    }
LABEL_85:
    v32 = *(_WORD *)(v3 + 52);
    if ( v32 & 1 )
      goto LABEL_86;
    goto LABEL_97;
  }
  v33 = (v15 & 0xFFFFF) + v68;
  v36 = __OFSUB__(v33, 999999);
  v34 = v33 == 999999;
  v35 = v33 - 999999 < 0;
  if ( v33 > 999999 )
    v33 -= 999424;
  v16 = 1;
  v37 = v67 + *v4;
  if ( !((unsigned __int8)(v35 ^ v36) | v34) )
    v33 -= 576;
  *(_DWORD *)(v3 + 56) = v37;
  if ( !((unsigned __int8)(v35 ^ v36) | v34) )
    ++v37;
  *(_DWORD *)(v3 + 60) = v33;
  if ( !((unsigned __int8)(v35 ^ v36) | v34) )
    *(_DWORD *)(v3 + 56) = v37;
  *(_DWORD *)(v3 + 60) = v33 | (v4[1] >> 20 << 20);
  v32 = *(_WORD *)(v3 + 52);
  if ( v32 & 1 )
LABEL_86:
    sub_25E0C(v3, 1);
LABEL_97:
  v34 = (v32 & 0x10) == 0;
  v38 = v32 | 1;
  if ( v34 )
    ++*(_DWORD *)(v5 + 124);
  v39 = *(_DWORD *)(v3 + 60);
  *(_WORD *)(v3 + 52) = v38;
  if ( (v39 & 0xF0000000) == 1342177280 )
  {
    v59 = (v39 >> 20) & 0xFF;
    if ( v59 < *(_DWORD *)(v5 + 164) )
    {
      v60 = v16;
      sub_87268(*(int **)(*(_DWORD *)(v5 + 160) + 4 * v59), (_DWORD *)v3, v59);
      v16 = v60;
      goto LABEL_43;
    }
  }
  v40 = *(_DWORD *)(v5 + 232);
  v41 = *(_DWORD *)(v5 + 236);
  v42 = v40 + 1;
  if ( v40 + 1 <= v41 )
  {
    v47 = *(_DWORD **)(v5 + 228);
  }
  else
  {
    if ( v41 )
      v43 = 2 * v41;
    else
      v43 = 8;
    if ( v43 < v42 )
      v44 = v40 + 1;
    else
      v44 = v43;
    v64 = v44;
    v45 = v16;
    v46 = sub_891F8(*(void **)(v5 + 228), 4 * v44);
    v16 = v45;
    if ( !v46 )
      goto LABEL_43;
    v40 = *(_DWORD *)(v5 + 232);
    v47 = v46;
    *(_DWORD *)(v5 + 228) = v46;
    v42 = v40 + 1;
    *(_DWORD *)(v5 + 236) = v64;
  }
  *(_DWORD *)(v5 + 232) = v42;
  v17 = (v40 - 1) >> 1;
  if ( v40 )
  {
    v63 = v16;
    while ( 1 )
    {
      v48 = (_DWORD *)v47[v17];
      v49 = *(_DWORD *)(v3 + 56);
      v50 = v48[14];
      if ( v50 == v49 )
        v66 = v48[15] > *(_DWORD *)(v3 + 60);
      else
        v66 = v50 > v49;
      if ( !v66 )
      {
        v16 = v63;
        v17 = 4 * v40;
        goto LABEL_42;
      }
      v47[v40] = v48;
      v48[4] = v40;
      if ( !v17 )
        break;
      v47 = *(_DWORD **)(v5 + 228);
      v40 = v17;
      v17 = (v17 - 1) >> 1;
    }
    v16 = v63;
    v40 = 0;
    v47 = *(_DWORD **)(v5 + 228);
  }
  else
  {
    v17 = 0;
  }
LABEL_42:
  *(_DWORD *)((char *)v47 + v17) = v3;
  *(_DWORD *)(v3 + 16) = v40;
LABEL_43:
  if ( v16 )
  {
    v18 = *(_DWORD **)(*(_DWORD *)(v5 + 160) + 4 * ((*(_DWORD *)(v3 + 60) >> 20) & 0xFF));
    if ( *v18 != v3 )
    {
LABEL_45:
      v12 = v8 & 1;
      goto LABEL_46;
    }
    v12 = v8 & 1;
    sub_89540((int)v18, v3);
  }
  else if ( *(_DWORD *)(v3 + 16) )
  {
    goto LABEL_45;
  }
LABEL_46:
  if ( v12 & v11 )
  {
    if ( dword_2F84CC )
    {
      if ( *(_DWORD *)(v5 + 148) )
      {
        v28 = *(_DWORD *)(v5 + 260);
        if ( v28 != dword_2F84CC() )
        {
          v29 = *(void (__fastcall **)(int))(v5 + 368);
          if ( v29 )
          {
            if ( !*(_DWORD *)(v5 + 284) )
            {
              *(_DWORD *)(v5 + 284) = 1;
              v29(v5);
            }
          }
        }
      }
    }
  }
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( !off_F3C04[0] || (v19 = off_F3C04[0][(v3 >> 6) % dword_F3C08]) == 0 )
LABEL_146:
      sub_9098C(
        -559030611,
        "%s: noting an add on a non-setup event %p (events: 0x%x, fd: %d, flags: 0x%x)",
        &unk_EBFAC,
        v3,
        *(signed __int16 *)(v3 + 48),
        *(_DWORD *)(v3 + 24),
        *(signed __int16 *)(v3 + 52));
    while ( v3 != *(_DWORD *)(v19 + 4) )
    {
      v19 = *(_DWORD *)v19;
      if ( !v19 )
        goto LABEL_146;
    }
    *(_BYTE *)(v19 + 8) |= 1u;
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  result = v10;
  dword_2F84B0 = 1;
  return result;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8528: using guessed type int (*dword_2F8528)(void);

//----- (0008A33C) --------------------------------------------------------
signed int __fastcall sub_8A33C(int *a1, char a2)
{
  char v2; // r7
  int v3; // r5
  int v4; // r4
  int v5; // r2
  int v6; // r0
  int *v7; // r4
  int v8; // r3
  signed int v9; // r3
  int v10; // r4
  _BOOL4 v11; // r2
  int v12; // r1
  _DWORD *v13; // r3
  int v14; // r2
  int v15; // r3
  unsigned int v16; // r4
  unsigned int *v17; // r8
  signed int v18; // r7
  int *v19; // r1
  __int16 v20; // r3
  int v21; // r3
  unsigned int v22; // r3
  int v23; // r0
  int v24; // r12
  int v25; // r2
  int v26; // lr
  int v27; // r1
  int v28; // r3
  int v29; // lr
  _BOOL4 v30; // r3
  int v31; // r2
  void (__fastcall *v32)(int, _DWORD, int); // r9
  int v33; // r2
  __int16 v34; // r10
  int v35; // r4
  int v36; // ST04_4
  int v37; // r3
  int v38; // r0
  int v39; // r2
  int v40; // r10
  int v41; // r1
  signed int v42; // r4
  int *v43; // r8
  int v44; // r3
  _DWORD *v45; // r2
  int v46; // r1
  signed int v47; // r3
  signed int v48; // r4
  int v49; // r1
  unsigned int v51; // r12
  int v52; // r4
  int v53; // r2
  _BOOL4 v54; // r3
  int v55; // r2
  int v56; // r4
  int v57; // r0
  bool v58; // nf
  int v59; // r12
  int v60; // r2
  bool v61; // zf
  unsigned int v62; // r2
  int v63; // r3
  int v64; // t1
  int v65; // r7
  int v66; // r1
  bool v67; // cf
  int v68; // r10
  int v69; // r8
  int v70; // r9
  _DWORD *v71; // t1
  _DWORD *v72; // r3
  int v73; // r2
  int v74; // r0
  int v75; // r1
  _DWORD *v76; // r3
  int v77; // r1
  int v78; // r4
  int v79; // r2
  _BOOL4 v80; // r1
  int v81; // r3
  int v82; // r1
  int v83; // r2
  int v84; // [sp+8h] [bp-68h]
  int v85; // [sp+1Ch] [bp-54h]
  int v86; // [sp+20h] [bp-50h]
  int v87; // [sp+28h] [bp-48h]
  int v88; // [sp+30h] [bp-40h]
  int v89; // [sp+34h] [bp-3Ch]
  int v90; // [sp+38h] [bp-38h]
  int v91; // [sp+3Ch] [bp-34h]
  int v92; // [sp+40h] [bp-30h]
  int v93; // [sp+44h] [bp-2Ch]

  v2 = a2;
  v3 = (int)a1;
  v86 = *a1;
  if ( a1[66] )
    dword_2F850C(0);
  v4 = *(_DWORD *)(v3 + 148);
  if ( v4 )
  {
    sub_909C0("%s: reentrant invocation.  Only one event_base_loop can run on each event_base at once.", &unk_EBFC0);
    if ( !*(_DWORD *)(v3 + 264) )
      return -1;
    dword_2F8510(0);
    return -1;
  }
  v5 = *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 240) = 0;
  *(_DWORD *)(v3 + 148) = 1;
  if ( v5 && *(_DWORD *)(v3 + 108) )
    sub_914BC(v3);
  if ( dword_2F84CC )
    v6 = dword_2F84CC();
  else
    v6 = 1;
  *(_DWORD *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 132) = 0;
  v85 = v2 & 2;
  *(_DWORD *)(v3 + 260) = v6;
  v87 = v2 & 1;
LABEL_22:
  *(_DWORD *)(v3 + 140) = 0;
  if ( v4 || *(_DWORD *)(v3 + 136) )
    goto LABEL_110;
  if ( !dword_2F84A4 )
  {
    sub_87440((_DWORD *)v3, (struct timeval *)&v88);
    v10 = *(_DWORD *)(v3 + 220);
    if ( v88 == v10 )
      v11 = v89 >= *(_DWORD *)(v3 + 224);
    else
      v11 = v88 >= v10;
    if ( v11 )
    {
      v12 = v89;
      v13 = (_DWORD *)(v3 + 220);
      *v13 = v88;
      v13[1] = v12;
    }
    else
    {
      v55 = *(_DWORD *)(v3 + 224);
      v56 = v10 - v88;
      v57 = *(_DWORD *)(v3 + 228);
      v59 = v55 - v89;
      v58 = v55 - v89 < 0;
      v60 = *(_DWORD *)(v3 + 232);
      if ( v58 )
      {
        --v56;
        v59 += 1000000;
      }
      v61 = v60 == 0;
      if ( v60 )
        v57 -= 4;
      v62 = v60 - 1;
      if ( !v61 )
      {
        do
        {
          v64 = *(_DWORD *)(v57 + 4);
          v57 += 4;
          v63 = v64;
          v58 = *(_DWORD *)(v64 + 60) - v59 < 0;
          v65 = *(_DWORD *)(v64 + 56) - v56;
          v66 = *(_DWORD *)(v64 + 60) - v59 + ((char)-v58 & 0xF4000);
          *(_DWORD *)(v64 + 56) = v65;
          if ( v58 )
          {
            v66 += 576;
            *(_DWORD *)(v63 + 56) = v65 - 1;
          }
          v67 = v62-- >= 1;
          *(_DWORD *)(v63 + 60) = v66;
        }
        while ( v67 );
      }
      v68 = *(_DWORD *)(v3 + 164);
      if ( v68 > 0 )
      {
        v69 = 0;
        v70 = *(_DWORD *)(v3 + 160) - 4;
        do
        {
          v71 = *(_DWORD **)(v70 + 4);
          v70 += 4;
          v72 = (_DWORD *)*v71;
          if ( *v71 )
          {
            do
            {
              v73 = (v72[15] & 0xFFFFF) - v59;
              v74 = v72[14] - v56;
              v72[14] = v74;
              if ( v73 < 0 )
                --v74;
              v75 = v73;
              if ( v73 < 0 )
              {
                v75 = v73 + 1000000;
                v72[14] = v74;
              }
              v72[15] = (v69 << 20) | 0x50000000 | v75;
              v72 = (_DWORD *)v72[4];
            }
            while ( v72 );
          }
          ++v69;
        }
        while ( v69 != v68 );
      }
      v76 = (_DWORD *)(v3 + 220);
      v77 = v89;
      *v76 = v88;
      v76[1] = v77;
    }
  }
  if ( *(_DWORD *)(v3 + 128) + *(_DWORD *)(v3 + 176) || v85 )
  {
    v7 = &v88;
    v89 = 0;
    v88 = 0;
  }
  else if ( *(_DWORD *)(v3 + 232) && (v78 = **(_DWORD **)(v3 + 228)) != 0 )
  {
    if ( sub_87440((_DWORD *)v3, (struct timeval *)&v92) != -1 )
    {
      v79 = *(_DWORD *)(v78 + 56);
      if ( v79 == v92 )
        v80 = *(_DWORD *)(v78 + 60) <= v93;
      else
        v80 = v79 <= v92;
      if ( v80 )
      {
        v89 = 0;
        v7 = &v88;
        v88 = 0;
        goto LABEL_12;
      }
      v81 = v79 - v92;
      v82 = *(_DWORD *)(v78 + 60);
      v88 = v79 - v92;
      v83 = v82 - v93;
      if ( v82 - v93 < 0 )
      {
        v83 += 1000000;
        v88 = v81 - 1;
      }
      v89 = v83;
    }
    v7 = &v88;
  }
  else
  {
    v7 = 0;
  }
LABEL_12:
  if ( *(_DWORD *)(v3 + 120) <= 0 && *(_DWORD *)(v3 + 124) <= 0 && !(*(_DWORD *)(v3 + 128) + *(_DWORD *)(v3 + 176)) )
  {
    v48 = 1;
    goto LABEL_111;
  }
  sub_87440((_DWORD *)v3, (struct timeval *)(v3 + 220));
  *(_DWORD *)(v3 + 240) = 0;
  if ( (*(int (__fastcall **)(int, int *))(v86 + 16))(v3, v7) != -1 )
  {
    v8 = *(_DWORD *)(v3 + 280);
    *(_DWORD *)(v3 + 240) = 0;
    if ( !(v8 & 8) )
      sub_87440((_DWORD *)v3, (struct timeval *)(v3 + 240));
    if ( *(_DWORD *)(v3 + 232) )
    {
      sub_87440((_DWORD *)v3, (struct timeval *)&v92);
      while ( *(_DWORD *)(v3 + 232) )
      {
        v52 = **(_DWORD **)(v3 + 228);
        if ( !v52 )
          break;
        v53 = *(_DWORD *)(v52 + 56);
        v54 = v53 > v92;
        if ( v53 == v92 )
          v54 = *(_DWORD *)(v52 + 60) > v93;
        if ( v54 )
          break;
        sub_878B0(**(_DWORD **)(v3 + 228));
        sub_89224(v52, 1, 1);
      }
    }
    if ( !(*(_DWORD *)(v3 + 128) + *(_DWORD *)(v3 + 176)) )
    {
      v9 = v85;
      if ( v85 )
        v9 = 1;
      if ( v9 )
        goto LABEL_110;
      goto LABEL_21;
    }
    v14 = *(_DWORD *)(v3 + 156);
    if ( v14 <= 0 )
      goto LABEL_92;
    v84 = 0;
    while ( 1 )
    {
      v15 = *(_DWORD *)(v3 + 152);
      v16 = *(_DWORD *)(v15 + 8 * v84);
      v17 = (unsigned int *)(v15 + 8 * v84);
      if ( !v16 )
        goto LABEL_91;
      v18 = 0;
      *(_DWORD *)(v3 + 144) = v84;
      do
      {
        if ( *(_WORD *)(v16 + 48) & 0x10 )
          sub_87588((_DWORD *)v3, v16, 8);
        else
          sub_878B0(v16);
        v20 = *(_WORD *)(v16 + 52);
        *(_DWORD *)(v3 + 268) = v16;
        v61 = (v20 & 0x10) == 0;
        *(_DWORD *)(v3 + 276) = 0;
        v21 = *(unsigned __int8 *)(v16 + 55);
        if ( v61 )
          ++v18;
        if ( v21 == 1 )
        {
          v39 = *(unsigned __int16 *)(v16 + 40);
          if ( *(_WORD *)(v16 + 40) )
            v19 = &v92;
          LOWORD(v92) = *(_WORD *)(v16 + 40);
          if ( v39 )
            *(_DWORD *)(v16 + 44) = v19;
          if ( *(_DWORD *)(v3 + 264) )
          {
            dword_2F8510(0);
            v39 = (unsigned __int16)v92;
          }
          while ( v39 )
          {
            LOWORD(v92) = v39 - 1;
            *(_WORD *)(v16 + 40) = v39 - 1;
            if ( (_WORD)v39 == 1 )
              *(_DWORD *)(v16 + 44) = 0;
            (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(v16 + 64))(
              *(_DWORD *)(v16 + 24),
              *(signed __int16 *)(v16 + 50),
              *(_DWORD *)(v16 + 68));
            if ( *(_DWORD *)(v3 + 264) )
            {
              dword_2F850C(0);
              v40 = *(_DWORD *)(v3 + 136);
              if ( *(_DWORD *)(v3 + 264) )
                dword_2F8510(0);
              if ( v40 )
              {
LABEL_79:
                if ( (_WORD)v92 )
                  *(_DWORD *)(v16 + 44) = 0;
                break;
              }
            }
            else if ( *(_DWORD *)(v3 + 136) )
            {
              goto LABEL_79;
            }
            v39 = (unsigned __int16)v92;
          }
        }
        else
        {
          if ( v21 == 2 )
          {
            if ( !*(_DWORD *)(v16 + 40) && !*(_DWORD *)(v16 + 44) )
              goto LABEL_51;
            sub_87440((_DWORD *)v3, (struct timeval *)&v92);
            v22 = *(_DWORD *)(v16 + 60);
            if ( (v22 & 0xF0000000) != 1342177280 || (signed int)((v22 >> 20) & 0xFF) >= *(_DWORD *)(v3 + 164) )
            {
              v23 = *(_DWORD *)(v16 + 40);
              v24 = *(_WORD *)(v16 + 50) & 1;
              v25 = *(_DWORD *)(v16 + 44);
              if ( v24 )
              {
                v26 = *(_DWORD *)(v16 + 56);
                v24 = 0;
                v27 = v92;
                goto LABEL_44;
              }
            }
            else
            {
              v51 = *(_DWORD *)(v16 + 44);
              v25 = v51 & 0xFFFFF;
              v23 = *(_DWORD *)(v16 + 40);
              v24 = v51 >> 20 << 20;
              if ( *(_WORD *)(v16 + 50) & 1 )
              {
                v22 &= 0xFFFFFu;
                v26 = *(_DWORD *)(v16 + 56);
                v27 = v92;
LABEL_44:
                v28 = v25 + v22;
                v29 = v23 + v26;
                v90 = v29;
                if ( v28 > 999999 )
                {
                  ++v29;
                  v28 -= 1000000;
                  v90 = v29;
                }
                v91 = v28;
                if ( v29 == v27 )
                  v30 = v91 < v93;
                else
                  v30 = v29 < v27;
                if ( v30 )
                {
                  v41 = v23 + v27;
                  v90 = v41;
                  v31 = v25 + v93;
                  if ( v31 > 999999 )
                  {
                    v31 -= 1000000;
                    v90 = v41 + 1;
                  }
                }
                else
                {
                  v31 = v91;
                }
                v91 = v31 | v24;
                sub_89B44(v16, &v90, 1);
LABEL_51:
                v32 = *(void (__fastcall **)(int, _DWORD, int))(v16 + 64);
                v33 = *(_DWORD *)(v16 + 24);
                v34 = *(_WORD *)(v16 + 50);
                v35 = *(_DWORD *)(v16 + 68);
                if ( *(_DWORD *)(v3 + 264) )
                {
                  v36 = v33;
                  dword_2F8510(0);
                  v33 = v36;
                }
                v32(v33, v34, v35);
                goto LABEL_54;
              }
            }
            v26 = v92;
            v22 = v93;
            v27 = v92;
            goto LABEL_44;
          }
          if ( *(_DWORD *)(v3 + 264) )
            dword_2F8510(0);
          (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(v16 + 64))(
            *(_DWORD *)(v16 + 24),
            *(signed __int16 *)(v16 + 50),
            *(_DWORD *)(v16 + 68));
        }
LABEL_54:
        if ( *(_DWORD *)(v3 + 264) )
          dword_2F850C(0);
        v37 = *(_DWORD *)(v3 + 276);
        *(_DWORD *)(v3 + 268) = 0;
        if ( v37 )
        {
          v38 = *(_DWORD *)(v3 + 272);
          *(_DWORD *)(v3 + 276) = 0;
          if ( v38 )
            dword_2F8524();
        }
        if ( *(_DWORD *)(v3 + 136) )
        {
          v18 = -1;
          *(_DWORD *)(v3 + 144) = -1;
          goto LABEL_105;
        }
        if ( *(_DWORD *)(v3 + 140) )
          break;
        v16 = *v17;
      }
      while ( *v17 );
      if ( v18 )
        goto LABEL_93;
      v14 = *(_DWORD *)(v3 + 156);
LABEL_91:
      if ( ++v84 >= v14 )
      {
LABEL_92:
        v18 = 0;
LABEL_93:
        v42 = 16;
        do
        {
          v43 = *(int **)(v3 + 188);
          if ( !v43 )
            break;
          v44 = *v43;
          *((_BYTE *)v43 + 8) &= 0xFEu;
          v45 = (_DWORD *)v43[1];
          if ( v44 )
          {
            *(_DWORD *)(v44 + 4) = v45;
            v45 = (_DWORD *)v43[1];
          }
          else
          {
            *(_DWORD *)(v3 + 192) = v45;
          }
          *v45 = v44;
          v46 = *(_DWORD *)(v3 + 172);
          --*(_DWORD *)(v3 + 176);
          if ( v46 )
            dword_2F8510(0);
          ((void (__fastcall *)(int *, int))v43[3])(v43, v43[4]);
          if ( *(_DWORD *)(v3 + 172) )
            dword_2F850C(0);
          if ( *(_DWORD *)(v3 + 136) )
            break;
          --v42;
        }
        while ( v42 );
        *(_DWORD *)(v3 + 144) = -1;
LABEL_105:
        if ( v87 && !(*(_DWORD *)(v3 + 128) + *(_DWORD *)(v3 + 176)) )
        {
          v47 = v18;
          if ( v18 )
            v47 = 1;
          if ( v47 )
          {
LABEL_110:
            v48 = 0;
            goto LABEL_111;
          }
        }
LABEL_21:
        v4 = *(_DWORD *)(v3 + 132);
        goto LABEL_22;
      }
    }
  }
  v48 = -1;
LABEL_111:
  v49 = *(_DWORD *)(v3 + 264);
  *(_DWORD *)(v3 + 240) = 0;
  *(_DWORD *)(v3 + 148) = 0;
  if ( v49 )
    dword_2F8510(0);
  return v48;
}
// 2F84A4: using guessed type int dword_2F84A4;
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8524: using guessed type int (*dword_2F8524)(void);

//----- (0008AD50) --------------------------------------------------------
signed int __fastcall sub_8AD50(int a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r4
  signed int v4; // r5

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 264) )
    dword_2F850C(0);
  v4 = sub_89B44(v3, v2, 0);
  if ( *(_DWORD *)(*(_DWORD *)(v3 + 28) + 264) )
    dword_2F8510(0);
  return v4;
}
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008B130) --------------------------------------------------------
void __fastcall sub_8B130(void *a1)
{
  if ( dword_2F84C0 )
    dword_2F84C0();
  else
    free(a1);
}
// 2F84C0: using guessed type int (*dword_2F84C0)(void);

//----- (0008B15C) --------------------------------------------------------
signed int __fastcall sub_8B15C(int a1, unsigned int a2)
{
  int v2; // r9
  signed int v3; // r7
  void **v4; // r3
  unsigned int v5; // r6
  unsigned int v6; // t1
  double v7; // d7
  void *v8; // r0
  int v9; // r11
  _DWORD *v10; // r0
  int v11; // r10
  int v12; // r8
  _DWORD *v13; // r4
  _DWORD *v14; // r5
  int v15; // r1
  signed int result; // r0
  _DWORD *v17; // r10
  int v18; // r2
  _DWORD *v19; // r8
  _DWORD *v20; // r5
  _DWORD *v21; // r4
  _DWORD *v22; // t1
  int v23; // r1
  int v24; // [sp+4h] [bp-34h]

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 == 25 || *(_DWORD *)(a1 + 12) > a2 )
    return 0;
  v4 = &off_EBE70 + v3;
  do
  {
    v6 = (unsigned int)v4[1];
    ++v4;
    v5 = v6;
    ++v3;
    v7 = (double)v6 * 0.5;
  }
  while ( a2 >= (unsigned int)v7 && v3 <= 25 );
  v8 = sub_89108(4 * v5);
  v9 = (int)v8;
  if ( v8 )
  {
    memset(v8, 0, 4 * v5);
    v10 = *(_DWORD **)v2;
    v11 = *(_DWORD *)(v2 + 4);
    if ( v11 )
    {
      v12 = 0;
      do
      {
        v13 = (_DWORD *)v10[v12];
        if ( v13 )
        {
          do
          {
            v14 = (_DWORD *)*v13;
            v15 = (v13[1] >> 6) % v5;
            *v13 = *(_DWORD *)(v9 + 4 * v15);
            *(_DWORD *)(v9 + 4 * v15) = v13;
            v13 = v14;
          }
          while ( v14 );
          v10 = *(_DWORD **)v2;
        }
        ++v12;
      }
      while ( v12 != v11 );
    }
    if ( v10 )
      sub_8B130(v10);
    *(_DWORD *)v2 = v9;
LABEL_17:
    result = 0;
    *(_DWORD *)(v2 + 4) = v5;
    *(_DWORD *)(v2 + 16) = v3;
    *(_DWORD *)(v2 + 12) = (unsigned int)v7;
    return result;
  }
  v17 = sub_891F8(*(void **)v2, 4 * v5);
  if ( v17 )
  {
    memset(&v17[*(_DWORD *)(v2 + 4)], v9, 4 * (v5 - *(_DWORD *)(v2 + 4)));
    v24 = *(_DWORD *)(v2 + 4);
    if ( *(_DWORD *)(v2 + 4) )
    {
      v19 = v17;
      do
      {
        v20 = v19;
        v22 = (_DWORD *)*v19;
        ++v19;
        v21 = v22;
        if ( v22 )
        {
          do
          {
            v23 = (v21[1] >> 6) % v5;
            if ( v23 == v9 )
              v20 = v21;
            else
              v18 = *v21;
            if ( v23 != v9 )
            {
              *v20 = v18;
              v18 = v17[v23];
              *v21 = v18;
              v17[v23] = v21;
            }
            v21 = (_DWORD *)*v20;
          }
          while ( *v20 );
        }
        v18 = v24;
        ++v9;
      }
      while ( v9 != v24 );
    }
    *(_DWORD *)v2 = v17;
    goto LABEL_17;
  }
  return -1;
}
// EBE70: using guessed type void *;

//----- (0008B328) --------------------------------------------------------
signed int __fastcall sub_8B328(unsigned int a1, int a2, int a3, __int16 a4, int a5, int a6)
{
  int v6; // r5
  unsigned int v7; // r4
  int v8; // r9
  __int16 v9; // r10
  int v10; // r0
  int v11; // r3
  char v12; // r3
  signed int result; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r5
  char v16; // r2
  int *v17; // r7
  int v18; // r1
  unsigned int v19; // r0
  unsigned int v20; // r1

  v6 = a2;
  v7 = a1;
  v8 = a3;
  v9 = a4;
  if ( !a2 )
    v6 = dword_2F84B4;
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( off_F3C04[0] )
    {
      v10 = off_F3C04[0][(v7 >> 6) % dword_F3C08];
      if ( v10 )
      {
        if ( v7 == *(_DWORD *)(v10 + 4) )
        {
LABEL_36:
          if ( *(_BYTE *)(v10 + 8) & 1 )
            sub_9098C(
              -559030611,
              "%s called on an already added event %p (events: 0x%x, fd: %d, flags: 0x%x)",
              &unk_EBFD0,
              v7,
              *(signed __int16 *)(v7 + 48),
              *(_DWORD *)(v7 + 24),
              *(signed __int16 *)(v7 + 52));
        }
        else
        {
          while ( 1 )
          {
            v10 = *(_DWORD *)v10;
            if ( !v10 )
              break;
            if ( v7 == *(_DWORD *)(v10 + 4) )
              goto LABEL_36;
          }
        }
      }
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  *(_DWORD *)(v7 + 28) = v6;
  *(_DWORD *)(v7 + 64) = a5;
  *(_DWORD *)(v7 + 68) = a6;
  *(_DWORD *)(v7 + 24) = v8;
  *(_WORD *)(v7 + 48) = v9;
  *(_WORD *)(v7 + 50) = 0;
  *(_WORD *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_WORD *)(v7 + 52) = 128;
  if ( v9 & 8 )
  {
    if ( v9 & 6 )
    {
      sub_909C0("%s: EV_SIGNAL is not compatible with EV_READ or EV_WRITE", &unk_EBFD0);
      return -1;
    }
    *(_BYTE *)(v7 + 55) = 1;
  }
  else
  {
    v12 = v9 & 0x10;
    if ( v9 & 0x10 )
    {
      *(_DWORD *)(v7 + 40) = v9 & 8;
      v12 = 2;
    }
    *(_BYTE *)(v7 + 55) = v12;
  }
  *(_DWORD *)(v7 + 16) = -1;
  if ( v6 )
    *(_BYTE *)(v7 + 54) = *(_DWORD *)(v6 + 156) / 2;
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( off_F3C04[0] && (v11 = off_F3C04[0][(v7 >> 6) % dword_F3C08]) != 0 )
    {
      while ( v7 != *(_DWORD *)(v11 + 4) )
      {
        v11 = *(_DWORD *)v11;
        if ( !v11 )
          goto LABEL_38;
      }
      *(_BYTE *)(v11 + 8) &= 0xFEu;
    }
    else
    {
LABEL_38:
      v14 = sub_89108(0xCu);
      v15 = v14;
      if ( !v14 )
        sub_90874(1, "Out of memory in debugging code");
      v16 = *((_BYTE *)v14 + 8);
      v14[1] = v7;
      *((_BYTE *)v14 + 8) = v16 & 0xFE;
      v17 = off_F3C04[0];
      v18 = dword_F3C0C;
      if ( off_F3C04[0] && dword_F3C0C < (unsigned int)dword_F3C10 )
      {
        v19 = v7;
      }
      else
      {
        sub_8B15C((int)off_F3C04, dword_F3C0C + 1);
        v18 = dword_F3C0C;
        v17 = off_F3C04[0];
        v19 = v15[1];
      }
      dword_F3C0C = v18 + 1;
      v20 = (v19 >> 6) % dword_F3C08;
      *v15 = v17[v20];
      v17[v20] = (int)v15;
    }
    if ( dword_2F84AC )
      dword_2F8510(0);
  }
  result = 0;
  dword_2F84B0 = 1;
  return result;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// F3C0C: using guessed type int dword_F3C0C;
// F3C10: using guessed type int dword_F3C10;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84B4: using guessed type int dword_2F84B4;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008B958) --------------------------------------------------------
signed int __fastcall sub_8B958(unsigned int a1, int a2, __int16 a3, int a4, int a5)
{
  return sub_8B328(a1, dword_2F84B4, a2, a3, a4, a5);
}
// 2F84B4: using guessed type int dword_2F84B4;

//----- (0008BA94) --------------------------------------------------------
void __fastcall sub_8BA94(int **a1)
{
  int **v1; // r5
  int *i; // r4
  int v3; // r3
  int *v4; // r2
  void *v5; // r0

  v1 = a1;
  for ( i = *a1; *v1; i = *v1 )
  {
    v3 = *i;
    v4 = (int *)i[1];
    if ( *i )
    {
      *(_DWORD *)(v3 + 4) = v4;
      v4 = (int *)i[1];
    }
    else
    {
      v1[1] = v4;
    }
    *v4 = v3;
    v5 = (void *)i[2];
    if ( v5 )
      sub_8B130(v5);
    sub_8B130(i);
  }
  sub_8B130(v1);
}

//----- (0008BB58) --------------------------------------------------------
signed int __fastcall sub_8BB58(int a1, size_t a2)
{
  int v2; // r4
  size_t v3; // r5
  int v4; // r6
  int v5; // r2
  _DWORD *v6; // r0
  _DWORD *v7; // r3

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 128) + *(_DWORD *)(a1 + 176);
  if ( v4 || a2 - 1 > 0xFE )
    return -1;
  v5 = *(_DWORD *)(a1 + 156);
  if ( v5 != a2 )
  {
    if ( v5 )
    {
      sub_8B130(*(void **)(a1 + 152));
      *(_DWORD *)(v2 + 156) = 0;
    }
    v6 = sub_89134(v3, 8u);
    *(_DWORD *)(v2 + 152) = v6;
    if ( v6 )
    {
      *(_DWORD *)(v2 + 156) = v3;
      v7 = v6;
      do
      {
        *v7 = 0;
        v7[1] = v7;
        v7 += 2;
      }
      while ( v7 != &v6[2 * v3] );
    }
    else
    {
      v4 = -1;
      sub_908B8("%s: calloc", &unk_EC000);
    }
  }
  return v4;
}

//----- (0008BC2C) --------------------------------------------------------
signed int __fastcall sub_8BC2C(int a1, int a2, int a3, int a4, int a5, int *a6)
{
  char v6; // r6
  int v7; // r5
  int v8; // r9
  int v9; // r10
  int v10; // r8
  int *v11; // r7
  _DWORD *v12; // r0
  void *v13; // r4
  signed int result; // r0
  signed int v15; // r5
  int v16; // [sp+8h] [bp-28h]
  int v17; // [sp+Ch] [bp-24h]

  v6 = a3;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  v10 = a4;
  v11 = a6;
  if ( a3 & 0x18 )
    return -1;
  v12 = sub_89134(1u, 0x50u);
  v13 = v12;
  if ( !v12 )
    return -1;
  v12[18] = v10;
  v12[19] = a5;
  if ( v7 == 1 )
  {
    if ( !a6 )
    {
      v17 = 0;
      v16 = 0;
      v11 = &v16;
    }
    sub_8B328((unsigned int)v12, v8, -1, 0, (int)sub_8C55C, (int)v12);
    goto LABEL_6;
  }
  if ( !(v6 & 6) )
  {
    sub_8B130(v12);
    return -1;
  }
  sub_8B328((unsigned int)v12, v8, v9, v7 & 6, (int)sub_8C55C, (int)v12);
LABEL_6:
  result = sub_8AD50((int)v13, v11);
  v15 = result;
  if ( result )
  {
    sub_8B130(v13);
    result = v15;
  }
  return result;
}

//----- (0008BD94) --------------------------------------------------------
signed int __fastcall sub_8BD94(int *a1)
{
  return sub_8BC2C(dword_2F84B4, -1, 1, (int)sub_8725C, dword_2F84B4, a1);
}
// 8725C: using guessed type int sub_8725C();
// 2F84B4: using guessed type int dword_2F84B4;

//----- (0008C074) --------------------------------------------------------
void __fastcall sub_8C074(unsigned int a1)
{
  unsigned int v1; // r4
  int v2; // r2
  unsigned int v3; // r1
  int *v4; // r3
  int *v5; // r2
  int v6; // lr

  v1 = a1;
  if ( dword_2F84A8 )
  {
    if ( dword_2F84AC )
      dword_2F850C(0);
    if ( off_F3C04[0] )
    {
      v2 = off_F3C04[0][(v1 >> 6) % dword_F3C08];
      if ( v2 )
      {
        while ( v1 != *(_DWORD *)(v2 + 4) )
        {
          v2 = *(_DWORD *)v2;
          if ( !v2 )
            goto LABEL_10;
        }
        if ( *(_BYTE *)(v2 + 8) & 1 )
          sub_9098C(
            -559030611,
            "%s called on an already added event %p (events: 0x%x, fd: %d, flags: 0x%x)",
            &unk_EC028,
            v1,
            *(signed __int16 *)(v1 + 48),
            *(_DWORD *)(v1 + 24),
            *(signed __int16 *)(v1 + 52));
      }
    }
LABEL_10:
    if ( dword_2F84AC )
      dword_2F8510(0);
    if ( dword_2F84A8 )
    {
      if ( dword_2F84AC )
        dword_2F850C(0);
      if ( off_F3C04[0] )
      {
        v3 = (v1 >> 6) % dword_F3C08;
        v4 = (int *)off_F3C04[0][v3];
        if ( v4 )
        {
          if ( v1 == v4[1] )
          {
            v5 = (int *)off_F3C04[0][v3];
            v4 = &off_F3C04[0][v3];
LABEL_25:
            v6 = dword_F3C0C;
            *v4 = *v5;
            *v5 = 0;
            dword_F3C0C = v6 - 1;
            sub_8B130(v5);
          }
          else
          {
            while ( 1 )
            {
              v5 = (int *)*v4;
              if ( !*v4 )
                break;
              if ( v1 == v5[1] )
                goto LABEL_25;
              v4 = (int *)*v4;
            }
          }
        }
      }
      if ( dword_2F84AC )
        dword_2F8510(0);
    }
  }
  *(_WORD *)(v1 + 52) &= 0xFF7Fu;
  dword_2F84B0 = 1;
}
// F3C04: using guessed type int *off_F3C04[4];
// F3C08: using guessed type int dword_F3C08;
// F3C0C: using guessed type int dword_F3C0C;
// 2F84A8: using guessed type int dword_2F84A8;
// 2F84AC: using guessed type int dword_2F84AC;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0008C2B8) --------------------------------------------------------
void __fastcall sub_8C2B8(char *a1)
{
  char *v1; // r5
  int v2; // r0
  unsigned int v3; // r0
  unsigned int v4; // r4
  unsigned int v5; // r0
  int v6; // r6
  unsigned int *v7; // r7
  unsigned int v8; // r0
  unsigned int v9; // r4
  void *v10; // r0
  int v11; // r3
  int v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r4
  void (__fastcall *v15)(char *); // r3
  void *v16; // r0

  v1 = a1;
  if ( a1 )
  {
    if ( a1 != (char *)dword_2F84B4 )
      goto LABEL_3;
  }
  else
  {
    v1 = (char *)dword_2F84B4;
  }
  dword_2F84B4 = 0;
  if ( !v1 )
  {
    sub_909C0("%s: no base to free", &unk_EC040);
    return;
  }
LABEL_3:
  if ( *((_DWORD *)v1 + 72) != -1 )
  {
    sub_88C24((unsigned int)(v1 + 296));
    j_close(*((_DWORD *)v1 + 72));
    v2 = *((_DWORD *)v1 + 73);
    if ( v2 != -1 )
      j_close(v2);
    *((_DWORD *)v1 + 72) = -1;
    *((_DWORD *)v1 + 73) = -1;
    sub_8C074((unsigned int)(v1 + 296));
  }
  v3 = *((_DWORD *)v1 + 53);
  if ( v3 )
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 8);
      if ( !(*(_WORD *)(v3 + 52) & 0x10) )
        sub_88C24(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  while ( *((_DWORD *)v1 + 58) )
  {
    v5 = **((_DWORD **)v1 + 57);
    if ( !v5 )
      break;
    sub_88C24(v5);
  }
  if ( *((_DWORD *)v1 + 41) > 0 )
  {
    v6 = 0;
    do
    {
      v7 = *(unsigned int **)(*((_DWORD *)v1 + 40) + 4 * v6);
      sub_88C24((unsigned int)(v7 + 4));
      sub_8C074((unsigned int)(v7 + 4));
      v8 = *v7;
      if ( *v7 )
      {
        do
        {
          while ( 1 )
          {
            v9 = *(_DWORD *)(v8 + 16);
            if ( !(*(_WORD *)(v8 + 52) & 0x10) )
              break;
            v8 = *(_DWORD *)(v8 + 16);
            if ( !v9 )
              goto LABEL_23;
          }
          sub_88C24(v8);
          v8 = v9;
        }
        while ( v9 );
      }
LABEL_23:
      ++v6;
      sub_8B130(v7);
    }
    while ( *((_DWORD *)v1 + 41) > v6 );
  }
  v10 = (void *)*((_DWORD *)v1 + 40);
  if ( v10 )
    sub_8B130(v10);
  v11 = *((_DWORD *)v1 + 39);
  if ( v11 > 0 )
  {
    v12 = 0;
    do
    {
      v13 = *(_DWORD *)(*((_DWORD *)v1 + 38) + 8 * v12);
      if ( v13 )
      {
        do
        {
          while ( 1 )
          {
            v14 = *(_DWORD *)v13;
            if ( !(*(_WORD *)(v13 + 52) & 0x10) )
              break;
            v13 = *(_DWORD *)v13;
            if ( !v14 )
              goto LABEL_34;
          }
          sub_88C24(v13);
          v13 = v14;
        }
        while ( v14 );
LABEL_34:
        v11 = *((_DWORD *)v1 + 39);
      }
      ++v12;
    }
    while ( v11 > v12 );
  }
  if ( *(_DWORD *)v1 )
  {
    v15 = *(void (__fastcall **)(char *))(*(_DWORD *)v1 + 20);
    if ( v15 )
      v15(v1);
  }
  v16 = (void *)*((_DWORD *)v1 + 57);
  if ( v16 )
    sub_8B130(v16);
  sub_8B130(*((void **)v1 + 38));
  sub_8D474(v1 + 196);
  sub_8D410((int)(v1 + 204));
  sub_8D9CC((void **)v1 + 2);
  if ( *((_DWORD *)v1 + 66) && dword_2F8508 )
    dword_2F8508();
  if ( *((_DWORD *)v1 + 68) )
    dword_2F8520();
  sub_8B130(v1);
}
// 2F8508: invalid function type has been ignored
// 8D474: using guessed type int __fastcall sub_8D474(_DWORD);
// 2F84B4: using guessed type int dword_2F84B4;
// 2F8508: using guessed type int (*dword_2F8508)(void);
// 2F8520: using guessed type int (*dword_2F8520)(void);

//----- (0008C55C) --------------------------------------------------------
void __fastcall sub_8C55C(int a1, int a2, int a3)
{
  void *v3; // r4

  v3 = (void *)a3;
  (*(void (__fastcall **)(int, int, _DWORD))(a3 + 72))(a1, a2, *(_DWORD *)(a3 + 76));
  sub_8C074((unsigned int)v3);
  sub_8B130(v3);
}

//----- (0008C5A0) --------------------------------------------------------
signed int __fastcall sub_8C5A0(int *a1)
{
  int v1; // r4
  int v2; // r5
  int v4; // r0
  int v5; // r0

  v1 = (int)a1;
  if ( !a1 )
    return -1;
  if ( a1[72] >= 0 )
    return 0;
  if ( !(*(_DWORD *)(*a1 + 28) & 4)
    || (pipe(a1 + 72) < 0 ? sub_908B8("%s: pipe", &unk_EC050) : (sub_8E8D8(*(_DWORD *)(v1 + 288)),
                                                                 sub_8E8D8(*(_DWORD *)(v1 + 292))),
        v4 = *(_DWORD *)(v1 + 288),
        v4 < 0) )
  {
    v2 = j_socketpair(1, 1, 0, (int *)(v1 + 288));
    if ( v2 == -1 )
    {
      sub_90944(-1, "%s: socketpair", &unk_EC050);
      return v2;
    }
    sub_8E8D8(*(_DWORD *)(v1 + 288));
    sub_8E8D8(*(_DWORD *)(v1 + 292));
    v4 = *(_DWORD *)(v1 + 288);
  }
  sub_8E834(v4);
  v5 = *(_DWORD *)(v1 + 292);
  *(_DWORD *)(v1 + 368) = sub_8753C;
  if ( v5 > 0 )
    sub_8E834(v5);
  sub_8B328(v1 + 296, v1, *(_DWORD *)(v1 + 288), 18, (int)sub_87330, v1);
  *(_WORD *)(v1 + 348) |= 0x10u;
  sub_881C4(v1 + 296, 0);
  return sub_8AD50(v1 + 296, 0);
}

//----- (0008C714) --------------------------------------------------------
_DWORD **__fastcall sub_8C714(int a1)
{
  int v1; // r7
  _DWORD **v2; // r5
  int v3; // r9
  unsigned int v4; // r9
  char **v5; // r6
  char ***v6; // r8
  _DWORD *v7; // r11
  const char *v8; // r4
  const char *v9; // r0
  char **v10; // t1
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v15; // r0
  char *v16; // r4
  int v17; // r3
  char **v18; // t1
  int v19; // r0
  void *v20; // [sp+0h] [bp-80h]
  struct timespec tp; // [sp+Ch] [bp-74h]
  char v22; // [sp+14h] [bp-6Ch]
  char v23; // [sp+1Bh] [bp-65h]
  unsigned __int8 v24; // [sp+1Ch] [bp-64h]

  v1 = a1;
  v20 = &_stack_chk_guard;
  dword_2F84B0 = 1;
  v2 = (_DWORD **)sub_89134(1u, 0x174u);
  if ( !v2 )
  {
    sub_908B8("%s: calloc", &unk_EC070);
    return 0;
  }
  if ( !dword_2F84C8 )
  {
    v19 = clock_gettime(1, &tp);
    dword_2F84C8 = 1;
    if ( !v19 )
      dword_2F84A4 = 1;
  }
  sub_87440(v2, (struct timeval *)(v2 + 55));
  v2[57] = 0;
  v2[58] = 0;
  v2[59] = 0;
  v2[53] = 0;
  v2[24] = (_DWORD *)-1;
  v2[54] = v2 + 53;
  v2[25] = (_DWORD *)-1;
  v2[72] = (_DWORD *)-1;
  v2[73] = (_DWORD *)-1;
  memset(v2 + 43, 0, 0x18u);
  v2[46] = v2;
  v2[48] = v2 + 47;
  v2[45] = sub_873D8;
  if ( v1 )
  {
    v2[70] = *(_DWORD **)(v1 + 16);
    sub_8D3F0(v2 + 49);
    sub_8D400(v2 + 51);
    sub_8D958(v2 + 2);
    v3 = *(_DWORD *)(v1 + 16);
    v2[1] = 0;
    v4 = ((v3 ^ 2u) >> 1) & 1;
  }
  else
  {
    v4 = 1;
    sub_8D3F0(v2 + 49);
    sub_8D400(v2 + 51);
    sub_8D958(v2 + 2);
    v2[1] = 0;
  }
  v5 = off_F3C18[0];
  if ( !off_F3C18[0] )
  {
LABEL_38:
    sub_909C0("%s: no event mechanism available", &unk_EC070);
    *v2 = 0;
    sub_8C2B8((char *)v2);
    return 0;
  }
  v6 = off_F3C1C;
  while ( v1 )
  {
    v7 = *(_DWORD **)v1;
    v8 = *v5;
    if ( !*(_DWORD *)v1 )
    {
LABEL_12:
      if ( *(_DWORD *)(v1 + 12) != (*(_DWORD *)(v1 + 12) & (unsigned int)v5[7]) )
        goto LABEL_13;
      break;
    }
    while ( 1 )
    {
      v9 = (const char *)v7[2];
      if ( v9 )
      {
        if ( !strcmp(v9, v8) )
          break;
      }
      v7 = (_DWORD *)*v7;
      if ( !v7 )
        goto LABEL_12;
    }
LABEL_13:
    v10 = *v6;
    ++v6;
    v5 = v10;
    v11 = (int)v2[1];
    if ( !v10 )
      goto LABEL_37;
LABEL_14:
    if ( v11 )
      goto LABEL_15;
  }
  if ( v4 )
  {
    sub_8ED8C(&v22, 0x40u, "EVENT_NO%s", *v5, v20);
    v15 = v24;
    if ( v24 )
    {
      v16 = &v23;
      do
      {
        (v16++)[1] = sub_90468(v15);
        v15 = (unsigned __int8)v16[1];
      }
      while ( v16[1] );
    }
    if ( sub_90550(&v22) )
      goto LABEL_13;
  }
  v17 = (int)*(v6 - 1);
  *v2 = (_DWORD *)v17;
  v11 = (*(int (__fastcall **)(_DWORD **))(v17 + 4))(v2);
  v2[1] = (_DWORD *)v11;
  v18 = *v6;
  ++v6;
  v5 = v18;
  if ( v18 )
    goto LABEL_14;
LABEL_37:
  if ( !v11 )
    goto LABEL_38;
LABEL_15:
  if ( sub_90550("EVENT_SHOW_METHOD") )
    sub_909F8("libevent using: %s", **v2);
  if ( sub_8BB58((int)v2, 1u) >= 0 )
  {
    if ( !dword_2F850C || v1 && *(_DWORD *)(v1 + 16) & 1 )
      return v2;
    v12 = dword_2F8504 ? dword_2F8504(1) : 0;
    v2[66] = (_DWORD *)v12;
    v2[43] = (_DWORD *)v12;
    v13 = dword_2F851C ? dword_2F851C(0) : dword_2F851C;
    v2[68] = (_DWORD *)v13;
    if ( sub_8C5A0((int *)v2) >= 0 )
      return v2;
    sub_909C0("%s: Unable to make base notifiable.", &unk_EC070);
  }
  sub_8C2B8((char *)v2);
  return 0;
}
// F3C18: using guessed type char **off_F3C18[3];
// F3C1C: using guessed type char **off_F3C1C[2];
// 2F84A4: using guessed type int dword_2F84A4;
// 2F84B0: using guessed type int dword_2F84B0;
// 2F84C8: using guessed type int dword_2F84C8;
// 2F8504: using guessed type int (__fastcall *dword_2F8504)(_DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F851C: using guessed type int (__fastcall *dword_2F851C)(_DWORD);

//----- (0008CAF4) --------------------------------------------------------
_DWORD **__fastcall sub_8CAF4(int a1, int a2, int a3, int a4)
{
  _DWORD **result; // r0
  int v5; // [sp+0h] [bp-8h]

  v5 = a4;
  result = sub_8C714(0);
  if ( !result )
    sub_9098C(1, "%s: Unable to construct event_base", &unk_EC08C, 0, v5);
  dword_2F84B4 = (int)result;
  return result;
}
// 2F84B4: using guessed type int dword_2F84B4;

//----- (0008D18C) --------------------------------------------------------
int __fastcall sub_8D18C(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = a1;
  dword_2F84AC = (int)sub_8E1D8((_DWORD *)dword_2F84AC, 0, a1);
  if ( dword_2F84AC )
  {
    if ( sub_91B58(v1) < 0 )
      result = -1;
    else
      result = sub_906A8() >> 31;
  }
  else
  {
    sub_908B8("Couldn't allocate %s", "_event_debug_map_lock");
    result = -1;
  }
  return result;
}
// 2F84AC: using guessed type int dword_2F84AC;

//----- (0008D29C) --------------------------------------------------------
char *__fastcall sub_8D29C(_DWORD *a1, int a2, __int16 a3, _DWORD *a4)
{
  _DWORD *v4; // r4
  int v5; // r7
  signed int v6; // r5
  _DWORD *v7; // r1
  _BYTE *v8; // r6
  char *result; // r0
  size_t v10; // r1
  int v11; // r6
  __int16 v12; // ST04_2
  _DWORD *v13; // ST00_4

  v4 = a1;
  v5 = a2;
  if ( *a4 )
    return (char *)(*a1 + 8 * (*a4 + 0x1FFFFFFF));
  v6 = a1[1];
  if ( v6 != a1[2] )
  {
    v7 = (_DWORD *)*a1;
LABEL_4:
    v8 = &v7[2 * v6];
    v4[1] = v6 + 1;
    *a4 = v6 + 1;
    result = (char *)&v7[2 * v6];
    v8[3] = 0;
    v8[4] = 0;
    v8[5] = 0;
    v8[6] = 0;
    v8[7] = 0;
    v7[2 * v6] = v5;
    *((_WORD *)v8 + 2) = a3;
    return result;
  }
  if ( v6 <= 63 )
  {
    v10 = 512;
    v11 = 64;
  }
  else
  {
    v10 = 16 * v6;
    v11 = 2 * v6;
  }
  v12 = a3;
  v13 = a4;
  result = (char *)sub_891F8((void *)*a1, v10);
  a3 = v12;
  a4 = v13;
  if ( result )
  {
    v6 = v4[1];
    v7 = result;
    *v4 = result;
    v4[2] = v11;
    goto LABEL_4;
  }
  return result;
}

//----- (0008D368) --------------------------------------------------------
signed int __fastcall sub_8D368(_DWORD *a1, signed int a2)
{
  _DWORD *v2; // r5
  signed int v3; // r4
  size_t v4; // r1
  char *v5; // r6

  v2 = a1;
  v3 = a1[1];
  if ( v3 > a2 )
    return 0;
  if ( v3 )
    goto LABEL_6;
  if ( a2 > 31 )
  {
    v3 = 32;
    do
LABEL_6:
      v3 *= 2;
    while ( a2 >= v3 );
    v4 = 4 * v3;
    goto LABEL_8;
  }
  v4 = 128;
  v3 = 32;
LABEL_8:
  v5 = (char *)sub_891F8((void *)*a1, v4);
  if ( !v5 )
    return -1;
  memset(&v5[4 * v2[1]], 0, 4 * (v3 - v2[1]));
  v2[1] = v3;
  *v2 = v5;
  return 0;
}

//----- (0008D3F0) --------------------------------------------------------
_DWORD *__fastcall sub_8D3F0(_DWORD *result)
{
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (0008D400) --------------------------------------------------------
_DWORD *__fastcall sub_8D400(_DWORD *result)
{
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (0008D410) --------------------------------------------------------
void __fastcall sub_8D410(int a1)
{
  int v1; // r5
  _DWORD *v2; // r3
  int v3; // r2
  int v4; // r4
  void *v5; // r0

  v1 = a1;
  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 > 0 )
    {
      v4 = 0;
      do
      {
        v5 = (void *)v2[v4++];
        if ( v5 )
        {
          sub_8B130(v5);
          v2 = *(_DWORD **)v1;
          v3 = *(_DWORD *)(v1 + 4);
        }
      }
      while ( v3 > v4 );
    }
    sub_8B130(v2);
    *(_DWORD *)v1 = 0;
  }
  *(_DWORD *)(v1 + 4) = 0;
}

//----- (0008D478) --------------------------------------------------------
signed int __fastcall sub_8D478(_DWORD *a1, signed int a2, int a3)
{
  signed int v3; // r9
  _DWORD *v4; // r8
  int v5; // r10
  int v6; // r5
  signed int result; // r0
  int v8; // r6
  int v9; // r4
  int v10; // r7
  int v11; // r6
  signed int v12; // r2
  bool v13; // nf
  unsigned __int8 v14; // vf
  int v15; // r2
  int v16; // r3

  v3 = a2;
  v4 = a1;
  v5 = *a1;
  v6 = a3;
  if ( a2 < 0 )
    return 0;
  if ( a2 >= a1[50] && sub_8D368(a1 + 49, a2) == -1 )
    return -1;
  v8 = v4[49];
  v9 = *(_DWORD *)(v8 + 4 * v3);
  if ( !v9 )
  {
    *(_DWORD *)(v8 + 4 * v3) = sub_89134(1u, *(_DWORD *)(v5 + 32) + 12);
    v15 = v4[49];
    v16 = *(_DWORD *)(v15 + 4 * v3);
    if ( !v16 )
      return -1;
    *(_DWORD *)v16 = 0;
    *(_DWORD *)(v16 + 4) = v16;
    *(_WORD *)(v16 + 8) = 0;
    *(_WORD *)(v16 + 10) = 0;
    v9 = *(_DWORD *)(v15 + 4 * v3);
  }
  v10 = *(unsigned __int16 *)(v9 + 8);
  v11 = *(unsigned __int16 *)(v9 + 10);
  if ( *(_WORD *)(v9 + 8) )
    v12 = 2;
  else
    v12 = 0;
  LOWORD(result) = *(_WORD *)(v6 + 48) & 2;
  if ( *(_WORD *)(v9 + 10) )
    v12 |= 4u;
  result = (unsigned __int16)result;
  if ( *(_WORD *)(v9 + 10) )
    v12 = (unsigned __int16)v12;
  if ( result )
  {
    if ( ++v10 == 1 )
      result = 2;
    else
      result = 0;
  }
  if ( *(_WORD *)(v6 + 48) & 4 )
  {
    if ( ++v11 == 1 )
      result |= 4u;
  }
  v14 = __OFSUB__(v10, 0x10000);
  v13 = v10 - 0x10000 < 0;
  if ( v10 < 0x10000 )
  {
    v14 = __OFSUB__(v11, 0x10000);
    v13 = v11 - 0x10000 < 0;
  }
  if ( !(v13 ^ v14) )
  {
    sub_909C0("Too many events reading or writing on fd %d", v3, v12);
    return -1;
  }
  if ( !dword_2F84A8
    || !*(_DWORD *)v9
    || !((*(unsigned __int16 *)(v6 + 48) ^ *(unsigned __int16 *)(*(_DWORD *)v9 + 48)) & 0x20) )
  {
    if ( result )
    {
      if ( (*(int (__fastcall **)(_DWORD *, _DWORD, signed int, _DWORD, int))(v5 + 8))(
             v4,
             *(_DWORD *)(v6 + 24),
             v12,
             (signed __int16)(result | *(_WORD *)(v6 + 48) & 0x20),
             v9 + 12) == -1 )
        return -1;
      result = 1;
    }
    *(_WORD *)(v9 + 8) = v10;
    *(_WORD *)(v9 + 10) = v11;
    *(_DWORD *)(v6 + 32) = 0;
    *(_DWORD *)(v6 + 36) = *(_DWORD *)(v9 + 4);
    **(_DWORD **)(v9 + 4) = v6;
    *(_DWORD *)(v9 + 4) = v6 + 32;
    return result;
  }
  sub_909C0("Tried to mix edge-triggered and non-edge-triggered events on fd %d", v3, v12);
  return -1;
}
// 2F84A8: using guessed type int dword_2F84A8;

//----- (0008D648) --------------------------------------------------------
int *__fastcall sub_8D648(int *result, int a2, int a3)
{
  int v3; // r12
  int v4; // r4
  int v5; // r5
  __int16 v6; // r1
  int v7; // r7
  int v8; // r6
  int v9; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r1

  v3 = *result;
  if ( a2 < 0 )
    result = 0;
  v4 = a3;
  if ( a2 >= 0 )
  {
    if ( a2 < result[50] )
    {
      v5 = *(_DWORD *)(result[49] + 4 * a2);
      v6 = *(_WORD *)(a3 + 48);
      v7 = *(unsigned __int16 *)(v5 + 8);
      v8 = *(unsigned __int16 *)(v5 + 10);
      v9 = v6 & 2;
      if ( v6 & 2 )
      {
        if ( --v7 )
          v9 = 0;
        else
          v9 = 2;
      }
      if ( !(v6 & 4) || (--v8, v8) )
      {
        if ( !v9 )
        {
          result = 0;
LABEL_13:
          *(_WORD *)(v5 + 8) = v7;
          *(_WORD *)(v5 + 10) = v8;
          v10 = *(_DWORD *)(v4 + 32);
          v11 = *(_DWORD *)(v4 + 36);
          if ( v10 )
            *(_DWORD *)(v10 + 36) = v11;
          else
            *(_DWORD *)(v5 + 4) = v11;
          if ( !v10 )
            v10 = *(_DWORD *)(v4 + 32);
          **(_DWORD **)(v4 + 36) = v10;
          return result;
        }
      }
      v12 = *(_DWORD *)(a3 + 24);
      if ( (*(int (__cdecl **)(int *))(v3 + 12))(result) != -1 )
      {
        result = &dword_0 + 1;
        goto LABEL_13;
      }
    }
    result = (int *)-1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0008D734) --------------------------------------------------------
int __fastcall sub_8D734(int result, int a2, unsigned __int16 a3)
{
  unsigned __int16 v3; // r5
  int i; // r4

  v3 = a3;
  for ( i = **(_DWORD **)(*(_DWORD *)(result + 196) + 4 * a2); i; i = *(_DWORD *)(i + 32) )
  {
    while ( !(v3 & *(_WORD *)(i + 48)) )
    {
      i = *(_DWORD *)(i + 32);
      if ( !i )
        return result;
    }
    result = sub_89224(i, v3 & *(_WORD *)(i + 48), 1);
  }
  return result;
}

//----- (0008D78C) --------------------------------------------------------
signed int __fastcall sub_8D78C(_DWORD *a1, signed int a2, _DWORD *a3)
{
  _DWORD *v3; // r6
  signed int v4; // r7
  _DWORD *v5; // r5
  int v6; // r9
  int v7; // r8
  _DWORD *v8; // r4
  signed int result; // r0
  int v10; // r2
  _DWORD *v11; // r3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1[5];
  if ( a1[52] <= a2 && sub_8D368(a1 + 51, a2) == -1 )
    return -1;
  v7 = v3[51];
  v8 = *(_DWORD **)(v7 + 4 * v4);
  if ( !v8 )
  {
    *(_DWORD *)(v7 + 4 * v4) = sub_89134(1u, *(_DWORD *)(v3[5] + 32) + 8);
    v10 = v3[51];
    v11 = *(_DWORD **)(v10 + 4 * v4);
    if ( !v11 )
      return -1;
    *v11 = 0;
    v11[1] = v11;
    v8 = *(_DWORD **)(v10 + 4 * v4);
  }
  if ( *v8 || (*(int (__fastcall **)(_DWORD *, _DWORD))(v6 + 8))(v3, v5[6]) != -1 )
  {
    v5[8] = 0;
    result = 1;
    v5[9] = v8[1];
    *(_DWORD *)v8[1] = v5;
    v8[1] = v5 + 8;
    return result;
  }
  return -1;
}

//----- (0008D86C) --------------------------------------------------------
signed int __fastcall sub_8D86C(_DWORD *a1, int a2, int a3)
{
  int v3; // r4
  _DWORD *v4; // r5
  int v5; // r3
  signed int result; // r0
  int v7; // r1

  v3 = a3;
  if ( a1[52] <= a2 )
    return -1;
  v4 = *(_DWORD **)(a1[51] + 4 * a2);
  if ( *v4 == **(_DWORD **)(v4[1] + 4) )
  {
    v7 = *(_DWORD *)(a3 + 24);
    if ( (*(int (__cdecl **)(_DWORD *))(a1[5] + 12))(a1) == -1 )
      return -1;
  }
  v5 = *(_DWORD *)(v3 + 32);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 36) = *(_DWORD *)(v3 + 36);
  }
  else
  {
    v4[1] = *(_DWORD *)(v3 + 36);
    v5 = *(_DWORD *)(v3 + 32);
  }
  result = 1;
  **(_DWORD **)(v3 + 36) = v5;
  return result;
}

//----- (0008D908) --------------------------------------------------------
int __fastcall sub_8D908(int result, int a2, __int16 a3)
{
  int v3; // r4
  __int16 v4; // r5

  v3 = **(_DWORD **)(*(_DWORD *)(result + 204) + 4 * a2);
  if ( v3 )
  {
    v4 = a3;
    do
    {
      result = sub_89224(v3, 8, v4);
      v3 = *(_DWORD *)(v3 + 32);
    }
    while ( v3 );
  }
  return result;
}

//----- (0008D944) --------------------------------------------------------
int __fastcall sub_8D944(_DWORD *a1, int a2)
{
  int result; // r0

  result = *(_DWORD *)(*a1 + 4 * a2);
  if ( result )
    result += 12;
  return result;
}

//----- (0008D958) --------------------------------------------------------
_DWORD *__fastcall sub_8D958(_DWORD *result)
{
  *result = 0;
  result[2] = 0;
  result[1] = 0;
  return result;
}

//----- (0008D96C) --------------------------------------------------------
int *__fastcall sub_8D96C(int *result, int a2)
{
  int v2; // r4
  int v3; // r3
  int v4; // r4
  char v5; // r2
  int v6; // r12
  bool v7; // zf
  int v8; // r2
  _DWORD *v9; // r2

  v2 = result[1];
  if ( v2 > 0 )
  {
    v3 = *result;
    v4 = *result + 8 * v2;
    do
    {
      v5 = *(_BYTE *)(v3 + 6);
      v3 += 8;
      v6 = *(_DWORD *)(a2 + 196);
      v7 = (v5 & 8) == 0;
      v8 = *(_DWORD *)(v3 - 8);
      if ( v7 )
        v8 = *(_DWORD *)(v6 + 4 * v8);
      else
        v6 = *(_DWORD *)(a2 + 204);
      if ( v7 )
        v9 = (_DWORD *)(v8 + 12);
      else
        v9 = *(_DWORD **)(v6 + 4 * v8);
      if ( !v7 )
        v9 += 2;
      *v9 = 0;
    }
    while ( v3 != v4 );
  }
  result[1] = 0;
  return result;
}

//----- (0008D9CC) --------------------------------------------------------
void __fastcall sub_8D9CC(void **a1)
{
  void **v1; // r4
  void *v2; // r0

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    sub_8B130(v2);
  *v1 = 0;
  v1[2] = 0;
  v1[1] = 0;
}

//----- (0008D9F8) --------------------------------------------------------
signed int __fastcall sub_8D9F8(int a1, int a2, __int16 a3, char a4, _DWORD *a5)
{
  char v5; // r4
  char *v6; // r0
  char v7; // r1
  char *v8; // r2
  signed int result; // r0

  v5 = a4;
  v6 = sub_8D29C((_DWORD *)(a1 + 8), a2, a3, a5);
  v8 = v6;
  if ( !v6 )
    return -1;
  if ( v5 & 0xA )
    v7 = v5 & 0x38;
  if ( v5 & 0xA )
    v6[6] = v7 | 1;
  if ( !(v5 & 4) )
    return 0;
  result = 0;
  v8[7] = v5 & 0x38 | 1;
  return result;
}

//----- (0008DA5C) --------------------------------------------------------
int __fastcall sub_8DA5C(int a1, int a2, __int16 a3, char a4, _DWORD *a5)
{
  char v5; // r4
  char *v6; // r0
  char *v7; // r2
  int result; // r0

  v5 = a4;
  v6 = sub_8D29C((_DWORD *)(a1 + 8), a2, a3, a5);
  v7 = v6;
  if ( !v6 )
    return -1;
  if ( v5 & 0xA )
  {
    if ( *((_WORD *)v6 + 2) & 0xA || !(v6[6] & 1) )
      v6[6] = 2;
    else
      v6[6] = 0;
  }
  result = v5 & 4;
  if ( v5 & 4 )
  {
    result = *((_WORD *)v7 + 2) & 4;
    if ( !(*((_WORD *)v7 + 2) & 4) && v7[7] & 1 )
    {
      v7[7] = v7[4] & 4;
    }
    else
    {
      result = 0;
      v7[7] = 2;
    }
  }
  return result;
}

//----- (0008DAFC) --------------------------------------------------------
int **__fastcall sub_8DAFC(int **result)
{
  int *v1; // r1
  int *v2; // r3
  int *v3; // r4
  int **v4; // r12
  int v5; // r4
  int *v6; // r3
  int *v7; // t1
  int i; // r3
  int *v9; // r12
  int v10; // r12
  int *v11; // r3
  int *v12; // t1
  int j; // r3

  v1 = result[53];
  if ( v1 )
  {
    v2 = result[53];
    do
    {
      *((_WORD *)v2 + 26) &= 0xCFFFu;
      v2 = (int *)v2[2];
    }
    while ( v2 );
  }
  v3 = result[50];
  if ( (signed int)v3 > 0 )
  {
    v4 = (int **)result[49];
    v5 = (int)&v4[(_DWORD)v3];
    do
    {
      v7 = *v4;
      ++v4;
      v6 = v7;
      if ( v7 )
      {
        for ( i = *v6; i; i = *(_DWORD *)(i + 32) )
          *(_WORD *)(i + 52) |= 0x2000u;
      }
    }
    while ( v4 != (int **)v5 );
  }
  v9 = result[52];
  if ( (signed int)v9 <= 0 )
    goto LABEL_21;
  result = (int **)result[51];
  v10 = (int)&result[(_DWORD)v9];
  do
  {
    v12 = *result;
    ++result;
    v11 = v12;
    if ( v12 )
    {
      for ( j = *v11; j; j = *(_DWORD *)(j + 32) )
        *(_WORD *)(j + 52) |= 0x1000u;
    }
  }
  while ( result != (int **)v10 );
  while ( v1 )
  {
    v1 = (int *)v1[2];
LABEL_21:
    ;
  }
  return result;
}

//----- (0008DBDC) --------------------------------------------------------
int (__fastcall *__fastcall sub_8DBDC(int a1, _DWORD *a2))(_DWORD, _DWORD)
{
  int v2; // r3
  int (__fastcall *result)(_DWORD, _DWORD); // r0

  v2 = a2[2];
  if ( dword_2F84CC && v2 == 1 )
    a2[1] = 0;
  a2[2] = v2 - 1;
  if ( dword_2F84E4 )
    result = (int (__fastcall *)(_DWORD, _DWORD))dword_2F84E4(a1, a2[3]);
  else
    result = dword_2F84E4;
  return result;
}
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F84E4: using guessed type int (__fastcall *dword_2F84E4)(_DWORD, _DWORD);

//----- (0008DC3C) --------------------------------------------------------
int __fastcall sub_8DC3C(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  int v3; // r3
  int v4; // r1
  int v5; // r0
  int (*v6)(void); // r3
  bool v7; // zf
  int v8; // r6

  v2 = a2;
  v3 = a2[2];
  if ( dword_2F84CC && v3 == 1 )
    a2[1] = 0;
  v4 = a2[3];
  v2[2] = v3 - 1;
  v5 = dword_2F84F8(a1, v4);
  v6 = dword_2F84CC;
  v7 = dword_2F84CC == 0;
  ++v2[2];
  v8 = v5;
  if ( !v7 )
    v2[1] = v6();
  return v8;
}
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F84F8: using guessed type int (__fastcall *dword_2F84F8)(_DWORD, _DWORD);

//----- (0008DCB8) --------------------------------------------------------
void __fastcall sub_8DCB8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  if ( dword_2F84DC )
    dword_2F84DC(a1[3], *a1 | 1);
  v1[3] = 0;
  v1[2] = -100;
  sub_8B130(v1);
}
// 2F84DC: using guessed type int (__fastcall *dword_2F84DC)(_DWORD, _DWORD);

//----- (0008DD04) --------------------------------------------------------
_DWORD *__fastcall sub_8DD04(int a1)
{
  int v1; // r6
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  int v4; // r5

  v1 = a1;
  v2 = sub_89108(0x10u);
  v3 = v2;
  if ( !v2 )
    return v2;
  if ( dword_2F84D8 )
  {
    v4 = dword_2F84D8(v1 | 1);
    v3[3] = v4;
    if ( !v4 )
    {
      sub_8B130(v3);
      return (_DWORD *)v4;
    }
  }
  else
  {
    v2[3] = dword_2F84D8;
  }
  v4 = (int)v3;
  *v3 = v1;
  v3[2] = 0;
  v3[1] = 0;
  return (_DWORD *)v4;
}
// 2F84D8: using guessed type int (__fastcall *dword_2F84D8)(_DWORD);

//----- (0008DD84) --------------------------------------------------------
int (*__fastcall sub_8DD84(int a1, int a2))(void)
{
  int v2; // r4
  int (*v3)(void); // r3

  v2 = a2;
  if ( dword_2F84E0 )
  {
    v3 = (int (*)(void))dword_2F84E0(a1, *(_DWORD *)(a2 + 12));
    if ( v3 )
      return v3;
  }
  ++*(_DWORD *)(v2 + 8);
  v3 = dword_2F84CC;
  if ( !dword_2F84CC )
    return v3;
  *(_DWORD *)(v2 + 4) = dword_2F84CC();
  return 0;
}
// 2F84CC: using guessed type int (*dword_2F84CC)(void);
// 2F84E0: using guessed type int (__fastcall *dword_2F84E0)(_DWORD, _DWORD);

//----- (0008E1D8) --------------------------------------------------------
_DWORD *__fastcall sub_8E1D8(_DWORD *a1, int a2, int a3)
{
  int v3; // r7
  _DWORD *v4; // r6
  int v5; // r5
  int v6; // r4
  _DWORD *v7; // r0

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    if ( !dword_2F8514 )
      return (_DWORD *)dword_2F8504(a2);
    v6 = dword_2F84D8(a2 | 1);
    v4[3] = v6;
    if ( v6 )
      return v4;
    v4[2] = -200;
    sub_8B130(v4);
    return (_DWORD *)v6;
  }
  if ( dword_2F84D8 )
  {
    if ( a2 & 1 )
    {
      v7 = sub_89108(0x10u);
      if ( v7 )
      {
        v6 = (int)v7;
        v7[3] = v4;
        *v7 = v5;
        v7[2] = v3;
        v7[1] = v3;
      }
      else
      {
        v6 = 0;
        dword_2F84DC(v4, v5);
      }
      return (_DWORD *)v6;
    }
    ((void (*)(void))dword_2F84DC)();
  }
  return sub_8DD04(v5);
}
// 2F84D8: using guessed type int (__fastcall *dword_2F84D8)(_DWORD);
// 2F84DC: using guessed type int (__fastcall *dword_2F84DC)(_DWORD, _DWORD);
// 2F8504: using guessed type int (__fastcall *dword_2F8504)(_DWORD);
// 2F8514: using guessed type int dword_2F8514;

//----- (0008E2C4) --------------------------------------------------------
unsigned int __fastcall sub_8E2C4(const char *a1)
{
  const char *v1; // r4
  unsigned int result; // r0
  _BYTE *v3; // [sp+4h] [bp-Ch]

  v1 = a1;
  v3 = 0;
  result = strtol(a1, &v3, 10);
  if ( result >= 0x10000 || !*v1 || !v3 )
    return -1;
  if ( *v3 )
    result = -1;
  return result;
}

//----- (0008E320) --------------------------------------------------------
void sub_8E320()
{
  int v0; // r0
  int v1; // r8
  int v2; // r0
  signed int v3; // r3
  struct addrinfo *v4; // [sp+0h] [bp-40h]
  struct addrinfo *pai; // [sp+4h] [bp-3Ch]
  struct addrinfo req; // [sp+8h] [bp-38h]

  v4 = 0;
  pai = 0;
  req.ai_family = 0;
  req.ai_socktype = 0;
  req.ai_protocol = 0;
  req.ai_addrlen = 0;
  req.ai_addr = 0;
  req.ai_canonname = 0;
  req.ai_next = 0;
  req.ai_flags = 12;
  v0 = getaddrinfo("1.2.3.4", "80", &req, &v4);
  req.ai_socktype = 1;
  v1 = v0;
  v2 = getaddrinfo("1.2.3.4", "80", &req, &pai);
  v3 = v1;
  if ( v1 )
    v3 = 1;
  if ( v2 )
    v3 = 0;
  if ( v3 )
    dword_2F852C = 1;
  if ( pai && !pai->ai_protocol )
    dword_2F8530 = 1;
  if ( v4 )
    freeaddrinfo(v4);
  if ( pai )
    freeaddrinfo(pai);
  dword_2F8534 = 1;
}
// 2F852C: using guessed type int dword_2F852C;
// 2F8530: using guessed type int dword_2F8530;
// 2F8534: using guessed type int dword_2F8534;

//----- (0008E43C) --------------------------------------------------------
int *__fastcall sub_8E43C(int *result, int *a2)
{
  int v2; // r3
  int v3; // r3

  if ( !*a2 )
  {
    v2 = *result;
    if ( !*result )
      return result;
    if ( v2 == 2 )
    {
      *a2 = 17;
    }
    else
    {
      if ( v2 != 1 )
        return result;
      *a2 = 6;
    }
  }
  if ( !*result )
  {
    v3 = *a2;
    if ( *a2 )
    {
      if ( v3 == 17 )
      {
        *result = 2;
      }
      else if ( v3 == 6 )
      {
        *result = 1;
      }
    }
  }
  return result;
}

//----- (0008E4AC) --------------------------------------------------------
int __fastcall sub_8E4AC(const char *a1, int a2, unsigned __int16 a3)
{
  bool v3; // zf
  int v4; // r1
  int v5; // r0

  v3 = (a2 & 0x40) == 0;
  v4 = a2 | 0x80000;
  if ( v3 )
    v5 = open(a1, v4);
  else
    v5 = open(a1, v4, a3);
  return v5 | (v5 >> 31);
}

//----- (0008E834) --------------------------------------------------------
int __fastcall sub_8E834(int a1)
{
  int v1; // r5
  int v2; // r0
  int v3; // r4

  v1 = a1;
  v2 = fcntl(a1, 3, 0);
  if ( v2 < 0 )
  {
    v3 = -1;
    sub_908B8("fcntl(%d, F_GETFL)", v1);
  }
  else
  {
    v3 = fcntl(v1, 4, v2 | 0x800);
    if ( v3 == -1 )
      sub_908B8("fcntl(%d, F_SETFL)", v1);
    else
      v3 = 0;
  }
  return v3;
}

//----- (0008E8D8) --------------------------------------------------------
int __fastcall sub_8E8D8(int a1)
{
  int v1; // r5
  int v2; // r0
  int v3; // r4

  v1 = a1;
  v2 = fcntl(a1, 1, 0);
  if ( v2 < 0 )
  {
    v3 = -1;
    sub_908B8("fcntl(%d, F_GETFD)", v1);
  }
  else
  {
    v3 = fcntl(v1, 2, v2 | 1);
    if ( v3 == -1 )
      sub_908B8("fcntl(%d, F_SETFD)", v1);
    else
      v3 = 0;
  }
  return v3;
}

//----- (0008EAC4) --------------------------------------------------------
void __fastcall sub_8EAC4(struct addrinfo *a1)
{
  struct addrinfo *v1; // r4
  sockaddr *v2; // r0
  addrinfo *v3; // r5
  struct addrinfo *v4; // r0

  v1 = a1;
  if ( a1->ai_flags >= 0 )
  {
    freeaddrinfo(a1);
  }
  else
  {
    do
    {
      v2 = v1->ai_addr;
      v3 = v1->ai_next;
      if ( v2 )
        sub_8B130(v2);
      v4 = v1;
      v1 = v3;
      sub_8B130(v4);
    }
    while ( v3 );
  }
}

//----- (0008EB0C) --------------------------------------------------------
struct addrinfo *__fastcall sub_8EB0C(unsigned __int16 *a1, size_t a2, _DWORD *a3)
{
  _DWORD *v3; // r5
  unsigned __int16 *v4; // r7
  size_t v5; // r6
  struct addrinfo *result; // r0
  struct addrinfo *v7; // r4
  int v8; // r1
  int v9; // r2
  int v10; // r0
  int v11; // r1
  int v12; // r3
  int v13; // r2
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  struct addrinfo *v18; // r5
  int v19; // r0
  struct addrinfo *v20; // r4
  int v21; // [sp+0h] [bp-38h]
  int v22; // [sp+4h] [bp-34h]
  int v23; // [sp+8h] [bp-30h]
  int v24; // [sp+Ch] [bp-2Ch]
  int v25; // [sp+10h] [bp-28h]
  int v26; // [sp+14h] [bp-24h]
  int v27; // [sp+18h] [bp-20h]
  int v28; // [sp+1Ch] [bp-1Ch]

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( a3[2] || a3[3] )
  {
    result = (struct addrinfo *)sub_89134(1u, a2 + 32);
    v7 = result;
    if ( result )
    {
      result->ai_canonname = (char *)&result[1];
      memcpy(&result[1], v4, v5);
      v8 = v3[2];
      result = v7;
      v9 = v3[3];
      v7->ai_family = *v4;
      v7->ai_addrlen = v5;
      v7->ai_socktype = v8;
      v7->ai_protocol = v9;
      v7->ai_flags = 2147483648;
    }
  }
  else
  {
    v10 = *a3;
    v11 = a3[1];
    v12 = a3[3];
    v13 = a3[2];
    v21 = v10;
    v22 = v11;
    v23 = v13;
    v24 = v12;
    v14 = v3[4];
    v15 = v3[5];
    v16 = v3[6];
    v17 = v3[7];
    v23 = 1;
    v24 = 6;
    v25 = v14;
    v26 = v15;
    v27 = v16;
    v28 = v17;
    result = (struct addrinfo *)sub_8EB0C(v4, v5, &v21);
    v18 = result;
    if ( result )
    {
      v23 = 2;
      v24 = 17;
      v19 = sub_8EB0C(v4, v5, &v21);
      v20 = (struct addrinfo *)v19;
      if ( v19 )
      {
        v18->ai_next = (addrinfo *)v19;
        result = v18;
      }
      else
      {
        sub_8EAC4(v18);
        result = v20;
      }
    }
  }
  return result;
}

//----- (0008ED8C) --------------------------------------------------------
char *sub_8ED8C(char *result, size_t a2, const char *a3, ...)
{
  char *v3; // r5
  int v4; // r4
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a3);
  v3 = result;
  if ( !a2 )
    result = 0;
  if ( a2 )
  {
    v4 = (int)&v3[a2];
    result = (char *)vsnprintf(result, a2, a3, varg_r3);
    *(_BYTE *)(v4 - 1) = 0;
  }
  return result;
}

//----- (0008EDD4) --------------------------------------------------------
char *__fastcall sub_8EDD4(unsigned int *a1, char *a2, size_t a3)
{
  char *v3; // r4
  size_t v4; // r5
  unsigned int v5; // r3
  char *v6; // r0
  char *result; // r0

  v3 = a2;
  v4 = a3;
  v5 = bswap32(*a1);
  v6 = sub_8ED8C(a2, a3, "%d.%d.%d.%d", v5 >> 24, (v5 >> 16) & 0xFF, (unsigned __int16)v5 >> 8, (unsigned __int8)v5);
  if ( (v4 <= (unsigned int)v6) | ((unsigned int)v6 >> 31) )
    result = 0;
  else
    result = v3;
  return result;
}

//----- (0008EE3C) --------------------------------------------------------
int __fastcall sub_8EE3C(char *a1, size_t a2, const char *a3, void *a4)
{
  int result; // r0
  int v5; // r4

  if ( !a2 )
    return 0;
  v5 = (int)&a1[a2];
  result = vsnprintf(a1, a2, a3, a4);
  *(_BYTE *)(v5 - 1) = 0;
  return result;
}

//----- (0008EE68) --------------------------------------------------------
char *__fastcall sub_8EE68(int a1, unsigned __int8 *a2, char *a3, size_t a4)
{
  size_t v4; // r10
  __int16 *v5; // r2
  unsigned __int8 *v6; // r3
  __int16 v7; // r12
  signed int v8; // r5
  int v9; // r2
  signed int v10; // r6
  signed int v11; // r11
  int v12; // r1
  __int16 *v13; // r0
  signed int v14; // r2
  int v15; // t1
  char *v17; // r5
  signed int v18; // r4
  char *v19; // r0
  char *v20; // r2
  signed int v21; // r3
  int v22; // t1
  char *v23; // r3
  char *v24; // [sp+14h] [bp-84h]
  char v25; // [sp+1Ah] [bp-7Eh]
  unsigned __int16 v26; // [sp+1Ch] [bp-7Ch]
  __int16 v27; // [sp+1Eh] [bp-7Ah]
  __int16 v28; // [sp+20h] [bp-78h]
  __int16 v29; // [sp+22h] [bp-76h]
  __int16 v30; // [sp+24h] [bp-74h]
  unsigned __int16 v31; // [sp+26h] [bp-72h]
  __int16 v32; // [sp+28h] [bp-70h]
  __int16 v33; // [sp+2Ah] [bp-6Eh]
  char v34[64]; // [sp+2Ch] [bp-6Ch]
  unsigned __int16 v35[1]; // [sp+70h] [bp-28h]

  v4 = a4;
  v24 = a3;
  if ( a1 != 2 )
  {
    if ( a1 != 10 )
      return 0;
    v5 = (__int16 *)&v25;
    v6 = a2;
    do
    {
      v7 = *v6;
      v6 += 2;
      v5[1] = *(v6 - 1) + (v7 << 8);
      ++v5;
    }
    while ( v5 != &v33 );
    if ( !v26 && !v27 && !v28 && !v29 && !v30 )
    {
      if ( v31 )
      {
        if ( v31 == 0xFFFF )
        {
          sub_8ED8C(v34, 0x40u, "::%x:%d.%d.%d.%d", 0xFFFF, a2[12], a2[13], a2[14], a2[15]);
          goto LABEL_26;
        }
      }
      else if ( v32 && v33 )
      {
        sub_8ED8C(v34, 0x40u, "::%d.%d.%d.%d", a2[12], a2[13], a2[14], a2[15]);
LABEL_26:
        if ( v4 < strlen(v34) )
          return 0;
        goto LABEL_46;
      }
    }
    v8 = 0;
    v9 = v26;
    v10 = 0;
    v11 = -1;
    while ( 1 )
    {
      if ( v9 )
      {
        ++v8;
      }
      else
      {
        v12 = v8 + 1;
        if ( v8 + 1 > 7 || v35[v12 - 42] )
        {
          v14 = 1;
        }
        else
        {
          v13 = (__int16 *)(&v26 + v12);
          v14 = 1;
          do
          {
            ++v14;
            ++v12;
            if ( v14 == 8 - v8 )
              break;
            v15 = (unsigned __int16)v13[1];
            ++v13;
          }
          while ( !v15 );
        }
        if ( v14 > v10 )
        {
          v11 = v8;
          v10 = v14;
        }
        v8 = v12;
      }
      if ( v8 > 7 )
        break;
      v9 = v35[v8 - 42];
    }
    if ( v10 <= 1 )
      v11 = -1;
    v17 = v34;
    v18 = 0;
    if ( !v26 && !v11 )
      goto LABEL_38;
LABEL_33:
    sub_8ED8C(v17, v34 - v17 + 64, "%x");
    v19 = &v17[strlen(v17)];
    if ( v18 == 7 )
    {
      v23 = v19;
    }
    else
    {
      ++v18;
      v17 = v19 + 1;
      *v19 = 58;
      while ( v18 != 8 )
      {
        if ( v35[v18 - 42] || v11 != v18 )
          goto LABEL_33;
LABEL_38:
        if ( !v11 )
          *v17++ = 58;
        v20 = (char *)&v35[v11 - 43];
        ++v17;
        v21 = v11;
        *(v17 - 1) = 58;
        do
        {
          v22 = *((unsigned __int16 *)v20 + 1);
          v20 += 2;
          if ( v22 )
            break;
          ++v21;
        }
        while ( v21 != 8 );
        v18 = v21;
      }
      v23 = v17;
    }
    *v23 = 0;
    if ( v4 < strlen(v34) )
      return 0;
LABEL_46:
    strlcpy(v24, v34, v4);
    return v24;
  }
  return sub_8EDD4((unsigned int *)a2, a3, a4);
}
// 25A0C: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 8EE68: using guessed type char var_6C[64];

//----- (0008F1AC) --------------------------------------------------------
signed int __fastcall sub_8F1AC(int a1, const char *a2, _DWORD *a3)
{
  char *v3; // r4
  _DWORD *v4; // r5
  char *v5; // r0
  char *v6; // r6
  int v7; // r1
  unsigned __int8 *v8; // r3
  unsigned int v9; // t1
  unsigned int v10; // r8
  signed int result; // r0
  signed int v12; // r10
  signed int v13; // r7
  signed int v14; // r11
  signed int v15; // r3
  unsigned int v16; // r2
  _BOOL4 v17; // r2
  _BOOL4 v18; // r3
  int v19; // r2
  bool v20; // zf
  signed int v21; // r3
  int v22; // r2
  int v23; // r10
  __int16 *v24; // r3
  __int16 v25; // t1
  signed int v26; // ST10_4
  unsigned int v27; // r0
  char *v28; // r2
  char *v29; // r1
  char v30; // [sp+1Fh] [bp-49h]
  unsigned int v31; // [sp+20h] [bp-48h]
  unsigned int v32; // [sp+24h] [bp-44h]
  unsigned int v33; // [sp+28h] [bp-40h]
  char *endptr; // [sp+2Ch] [bp-3Ch]
  unsigned int v35; // [sp+30h] [bp-38h]
  __int16 v36; // [sp+3Ch] [bp-2Ch]
  __int16 v37; // [sp+3Eh] [bp-2Ah]
  char v38; // [sp+40h] [bp-28h]

  v3 = (char *)a2;
  v4 = a3;
  if ( a1 == 2 )
  {
    if ( sscanf(a2, "%d.%d.%d.%d%c", &v32, &v33, &endptr, &v35, &v31) == 4
      && v32 <= 0xFF
      && v33 <= 0xFF
      && (unsigned int)endptr <= 0xFF
      && v35 <= 0xFF )
    {
      result = 1;
      *v4 = bswap32((v33 << 16) | (v32 << 24) | v35 | ((_DWORD)endptr << 8));
      return result;
    }
    return 0;
  }
  if ( a1 != 10 )
    goto LABEL_66;
  v5 = strchr(a2, 46);
  v6 = v5;
  if ( v5 == v3 )
    return 0;
  if ( v5 )
  {
    v7 = (int)(v5 - 1);
    if ( v3 <= v5 - 1 && dword_EC0A8[(unsigned int)(unsigned __int8)*(v5 - 1) >> 5] & (1 << (*(v5 - 1) & 0x1F)) )
    {
      v8 = (unsigned __int8 *)(v5 - 2);
      do
      {
        v7 = (int)v8;
        if ( v8 == (unsigned __int8 *)(v3 - 1) )
          break;
        v9 = *v8--;
      }
      while ( dword_EC0A8[v9 >> 5] & (1 << (v9 & 0x1F)) );
    }
    v10 = v7 + 1;
    if ( sscanf((const char *)(v7 + 1), "%d.%d.%d.%d%c", &v31, &v32, &v33, &endptr, &v30) != 4
      || v31 > 0xFF
      || v32 > 0xFF
      || v33 > 0xFF
      || (unsigned int)endptr > 0xFF )
    {
      return 0;
    }
    v36 = v32 | ((_WORD)v31 << 8);
    v12 = 2;
    v37 = (unsigned __int16)endptr | ((_WORD)v33 << 8);
  }
  else
  {
    v12 = 0;
    v10 = (unsigned int)&v3[strlen(v3)];
  }
  if ( v10 <= (unsigned int)v3 )
  {
    v14 = -1;
    v18 = 0;
    goto LABEL_43;
  }
  v13 = 0;
  v14 = -1;
  v15 = 1;
  do
  {
    while ( 1 )
    {
      v16 = (unsigned __int8)*v3;
      if ( !(dword_EC0A8[(v16 >> 5) + 8] & (v15 << (v16 & 0x1F))) )
        break;
      v26 = v15;
      v27 = strtol(v3, &endptr, 16);
      v28 = endptr;
      v15 = v26;
      if ( endptr > v3 + 4 )
        return 0;
      if ( v3 == endptr )
        return 0;
      if ( v27 > 0x10000 )
        return 0;
      ++v12;
      v29 = &v38 + 2 * v13++;
      *((_WORD *)v29 - 8) = v27;
      if ( *v28 != 58 && (char *)v10 != v28 )
        return 0;
      v3 = v28 + 1;
LABEL_63:
      if ( v10 <= (unsigned int)v3 )
        goto LABEL_38;
      if ( v13 > 7 )
        return 0;
    }
    if ( v16 != 58 )
      return 0;
    if ( v13 > 0 )
      v17 = v14 == -1;
    else
      v17 = 0;
    if ( v17 )
    {
      ++v3;
      v14 = v13;
      goto LABEL_63;
    }
    if ( v13 || v3[1] != 58 || v14 != -1 )
      return 0;
    v3 += 2;
    v14 = 0;
  }
  while ( v10 > (unsigned int)v3 );
LABEL_38:
  if ( v12 > 8 )
    return 0;
  v18 = v14 != -1;
  v19 = v12 == 8 ? (unsigned __int8)(v14 != -1) : 0;
  if ( v19 )
    return 0;
LABEL_43:
  v20 = v12 == 7;
  if ( v12 <= 7 )
    v20 = v14 == -1;
  if ( v20 )
    return 0;
  if ( v18 )
  {
    if ( v6 )
      v21 = 2;
    else
      v21 = 0;
    v22 = v12 - v21 - v14;
    if ( v22 >= 0 )
    {
      v23 = 8 - v12;
      memmove((char *)&v35 + 2 * (v14 + v23), (char *)&v35 + 2 * v14, 2 * v22);
      memset((char *)&v35 + 2 * v14, 0, 2 * v23);
      goto LABEL_54;
    }
LABEL_66:
    result = -1;
  }
  else
  {
LABEL_54:
    v24 = (__int16 *)((char *)&endptr + 2);
    do
    {
      v25 = v24[1];
      ++v24;
      v4 = (_DWORD *)((char *)v4 + 2);
      *((_BYTE *)v4 - 1) = v25;
      *((_BYTE *)v4 - 2) = HIBYTE(v25);
    }
    while ( v24 != &v37 );
    result = 1;
  }
  return result;
}

//----- (0008F56C) --------------------------------------------------------
signed int __fastcall sub_8F56C(__int64 a1, int *a2, struct addrinfo **a3, signed int *a4)
{
  int v4; // r8
  signed int v5; // r6
  const char *v6; // r5
  int *v7; // r7
  struct addrinfo **v8; // r9
  signed int v9; // r12
  int v11; // r3
  int v12; // r0
  int v13; // r12
  bool v14; // zf
  __int16 v15; // r6
  size_t v16; // r1
  struct addrinfo *v17; // r0
  int v18; // r3
  struct addrinfo *v19; // r5
  struct addrinfo *v20; // r0
  struct addrinfo *i; // r2
  char v22[6]; // [sp+0h] [bp-48h]
  int v23; // [sp+8h] [bp-40h]
  int v24; // [sp+Ch] [bp-3Ch]
  int v25; // [sp+10h] [bp-38h]
  int v26; // [sp+14h] [bp-34h]
  int v27; // [sp+18h] [bp-30h]

  v4 = 1 - a1;
  v5 = HIDWORD(a1);
  if ( (unsigned int)a1 > 1 )
    v4 = 0;
  v6 = (const char *)a1;
  v7 = a2;
  v8 = a3;
  if ( !a1 )
    return 8;
  v11 = a2[1];
  if ( v11 & 0xFFFFFFFD && v11 != 10 )
    return 5;
  sub_8E43C(a2 + 2, a2 + 3);
  v12 = v7[3];
  if ( v12 != 6 && v12 != 17 && v12 )
    getprotobynumber(v12);
  if ( v5 )
  {
    v5 = sub_8E2C4((const char *)v5);
    if ( v5 < 0 )
      return 8;
  }
  if ( v4 )
  {
    v5 = (unsigned __int16)v5;
    if ( v7[1] == 2 )
    {
      v19 = 0;
    }
    else
    {
      *(_DWORD *)&v22[4] = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      strcpy(v22, "\n");
      v18 = *v7;
      *(_DWORD *)&v22[2] = (unsigned __int16)__rev16(v5);
      if ( !(v18 & 1) )
        HIBYTE(v26) = 1;
      v19 = sub_8EB0C((unsigned __int16 *)v22, 0x1Cu, v7);
      if ( !v19 )
        return 6;
      if ( v7[1] == 10 )
      {
LABEL_37:
        *v8 = v19;
        return 0;
      }
    }
    *(_DWORD *)&v22[4] = 0;
    v23 = 0;
    v24 = 0;
    *(_WORD *)v22 = 2;
    v14 = (*v7 & 1) == 0;
    *(_DWORD *)&v22[2] = (unsigned __int16)__rev16(v5);
    if ( v14 )
      *(_DWORD *)&v22[4] = 16777343;
    v20 = sub_8EB0C((unsigned __int16 *)v22, 0x10u, v7);
    if ( v20 )
    {
      for ( i = v20; i->ai_next; i = i->ai_next )
        ;
      i->ai_next = v19;
      v19 = v20;
      goto LABEL_37;
    }
    if ( v19 )
      sub_8EAC4(v19);
    return 6;
  }
  v13 = v7[1];
  v14 = v13 == 10;
  if ( v13 != 10 )
    v14 = v13 == 0;
  if ( v14 )
  {
    *(_DWORD *)v22 = 0;
    *(_DWORD *)&v22[4] = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    if ( sub_8F1AC(10, v6, &v23) == 1 )
    {
      strcpy(v22, "\n");
      v15 = __rev16(v5);
      v16 = 28;
      goto LABEL_26;
    }
    v13 = v7[1];
  }
  if ( v13 & 0xFFFFFFFD
    || (*(_DWORD *)v22 = 0, *(_DWORD *)&v22[4] = 0, v23 = 0, v24 = 0, sub_8F1AC(2, v6, &v22[4]) != 1) )
  {
    if ( !(*v7 & 4) )
    {
      *a4 = v5;
      return -90002;
    }
    return 8;
  }
  *(_WORD *)v22 = 2;
  v15 = __rev16(v5);
  v16 = 16;
LABEL_26:
  *(_WORD *)&v22[2] = v15;
  v17 = sub_8EB0C((unsigned __int16 *)v22, v16, v7);
  *v8 = v17;
  if ( v17 )
    v9 = 0;
  else
    v9 = 6;
  return v9;
}

//----- (0008F820) --------------------------------------------------------
int __fastcall sub_8F820(char *name, char *service, socklen_t a3, struct addrinfo **a4)
{
  int *v4; // lr
  struct addrinfo **v5; // r5
  char *v6; // r7
  const char *v7; // r6
  int v8; // r1
  int v9; // r2
  int v10; // r3
  sockaddr *v11; // r1
  char *v12; // r2
  addrinfo *v13; // r3
  signed int v14; // r8
  int v15; // r6
  int result; // r0
  struct addrinfo *v17; // r4
  struct addrinfo *v18; // r11
  int v19; // r3
  int v20; // r0
  int v21; // r1
  socklen_t v22; // r0
  sockaddr *v23; // r1
  char *v24; // r2
  addrinfo *v25; // r3
  struct addrinfo *v26; // r2
  unsigned int v27; // r8
  struct addrinfo **v28; // r4
  char *v29; // r3
  int v30; // r1
  __int64 v31; // r0
  int v32; // [sp+Ch] [bp-4Ch]
  struct addrinfo req; // [sp+10h] [bp-48h]

  v4 = (int *)a3;
  v5 = a4;
  v6 = name;
  v7 = service;
  v32 = -1;
  if ( a3 )
  {
    v8 = *(_DWORD *)(a3 + 4);
    v9 = *(_DWORD *)(a3 + 8);
    v10 = v4[3];
    req.ai_flags = *v4;
    req.ai_family = v8;
    req.ai_socktype = v9;
    req.ai_protocol = v10;
    v11 = (sockaddr *)v4[5];
    v12 = (char *)v4[6];
    v13 = (addrinfo *)v4[7];
    req.ai_addrlen = v4[4];
    req.ai_addr = v11;
    req.ai_canonname = v12;
    req.ai_next = v13;
  }
  else
  {
    req.ai_flags = a3;
    req.ai_family = a3;
    req.ai_socktype = a3;
    req.ai_protocol = a3;
    req.ai_addrlen = a3;
    req.ai_addr = (sockaddr *)a3;
    req.ai_canonname = (char *)a3;
    req.ai_next = (addrinfo *)a3;
  }
  if ( !dword_2F8534 )
    sub_8E320();
  if ( dword_2F852C && v7 && !req.ai_socktype && (v32 = sub_8E2C4(v7), v32 >= 0) )
  {
    if ( !v6 )
    {
      LODWORD(v31) = 0;
      return sub_8F56C(v31, &req.ai_flags, v5, &v32);
    }
    v7 = (const char *)req.ai_socktype;
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
  if ( !dword_2F8534 )
    sub_8E320();
  if ( dword_2F8530 )
    sub_8E43C(&req.ai_socktype, &req.ai_protocol);
  req.ai_flags &= 0x7FFFFFFFu;
  v15 = getaddrinfo(v6, v7, &req, v5);
  if ( v14 )
  {
    v26 = *v5;
    if ( *v5 )
    {
      v27 = (unsigned __int16)v32;
      v28 = v5;
      do
      {
        v29 = v26->ai_canonname;
        if ( v29 && ((v30 = *(unsigned __int16 *)v29, v30 == 2) || v30 == 10) )
        {
          *((_WORD *)v29 + 1) = __rev16(v27);
        }
        else
        {
          *v28 = v26->ai_next;
          v26->ai_next = 0;
          freeaddrinfo(v26);
        }
        v28 = &(*v28)->ai_next;
        v26 = *v28;
      }
      while ( *v28 );
    }
  }
  if ( !dword_2F8534 )
    sub_8E320();
  if ( !dword_2F8530 )
    return v15;
  v17 = *v5;
  if ( !*v5 )
    return v15;
  while ( 1 )
  {
    while ( 1 )
    {
      sub_8E43C(&v17->ai_socktype, &v17->ai_protocol);
      if ( !v17->ai_socktype && !v17->ai_protocol )
        break;
      v17 = v17->ai_next;
      if ( !v17 )
        return v15;
    }
    v18 = (struct addrinfo *)sub_89108(0x20u);
    if ( !v18 )
      break;
    v19 = v17->ai_protocol;
    v20 = v17->ai_flags;
    v21 = v17->ai_family;
    v18->ai_socktype = v17->ai_socktype;
    v18->ai_protocol = v19;
    v18->ai_flags = v20;
    v18->ai_family = v21;
    v22 = v17->ai_addrlen;
    v23 = v17->ai_addr;
    v24 = v17->ai_canonname;
    v18->ai_next = v17->ai_next;
    v18->ai_addrlen = v22;
    v18->ai_addr = v23;
    v18->ai_canonname = v24;
    v25 = v17->ai_next;
    v17->ai_socktype = 1;
    v17->ai_protocol = 6;
    v18->ai_socktype = 2;
    v18->ai_protocol = 17;
    v18->ai_next = v25;
    v17->ai_next = v18;
    v17 = v18;
  }
  sub_8EAC4(*v5);
  result = 6;
  *v5 = 0;
  return result;
}
// 2F852C: using guessed type int dword_2F852C;
// 2F8530: using guessed type int dword_2F8530;
// 2F8534: using guessed type int dword_2F8534;

//----- (0008FBC8) --------------------------------------------------------
int sub_8FBC8()
{
  int v0; // r0
  int v1; // r4
  int v2; // r0
  int v3; // r4
  unsigned int v5; // r3
  unsigned int v6; // r3
  int v7; // [sp+0h] [bp-18h]
  socklen_t len; // [sp+4h] [bp-14h]
  __int16 v9; // [sp+8h] [bp-10h]
  __int16 v10; // [sp+Ah] [bp-Eh]
  int v11; // [sp+Ch] [bp-Ch]
  int v12; // [sp+10h] [bp-8h]
  int v13; // [sp+14h] [bp-4h]
  int v14; // [sp+18h] [bp+0h]
  unsigned int v15; // [sp+1Ch] [bp+4h]
  int v16; // [sp+20h] [bp+8h]
  int v17; // [sp+24h] [bp+Ch]
  int v18; // [sp+28h] [bp+10h]
  int v19; // [sp+2Ch] [bp+14h]
  int v20; // [sp+30h] [bp+18h]
  int v21; // [sp+34h] [bp+1Ch]
  char v22; // [sp+38h] [bp+20h]
  struct sockaddr addr; // [sp+3Ch] [bp+24h]
  int v24; // [sp+4Ch] [bp+34h]
  int v25; // [sp+50h] [bp+38h]
  int v26; // [sp+54h] [bp+3Ch]
  struct sockaddr s1; // [sp+58h] [bp+40h]
  int v28; // [sp+68h] [bp+50h]
  int v29; // [sp+6Ch] [bp+54h]
  int v30; // [sp+70h] [bp+58h]
  char v31; // [sp+74h] [bp+5Ch]

  len = 28;
  v11 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v12 = 0;
  v13 = 0;
  v9 = 2;
  v7 = 16;
  v10 = 13568;
  sub_8F1AC(2, "18.244.0.188", &v11);
  *(_DWORD *)&addr.sa_data[2] = 0;
  *(_DWORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[10] = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  addr.sa_family = 10;
  *(_WORD *)addr.sa_data = 13568;
  sub_8F1AC(10, "2001:4860:b002::68", &addr.sa_data[6]);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  *(_DWORD *)&s1.sa_family = 0;
  *(_DWORD *)&s1.sa_data[2] = 0;
  *(_DWORD *)&s1.sa_data[6] = 0;
  *(_DWORD *)&s1.sa_data[10] = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v0 = socket(2, 2, 17);
  v1 = v0;
  if ( v0 >= 0 )
  {
    if ( !connect(v0, (const struct sockaddr *)&v9, 0x10u)
      && !getsockname(v1, (struct sockaddr *)&v14, (socklen_t *)&v7) )
    {
      v5 = bswap32(v15);
      if ( v5 && (v6 = v5 >> 24, v6 != 127) && (v6 & 0xF0) != 224 )
      {
        dword_2F853C = 1;
      }
      else
      {
        sub_8EDD4(&v15, &v31, 0x80u);
        sub_909C0("Got a strange local ipv4 address %s", &v31);
      }
    }
    close(v1);
  }
  v2 = socket(10, 2, 17);
  v3 = v2;
  if ( v2 >= 0 )
  {
    if ( !connect(v2, &addr, 0x1Cu) && !getsockname(v3, &s1, &len) )
    {
      if ( !memcmp(&s1.sa_data[6], &v18, 8u) || (unsigned __int8)s1.sa_data[6] == 254 && (s1.sa_data[7] & 0xC0) == 128 )
      {
        sub_8EE68(10, (unsigned __int8 *)&s1.sa_data[6], &v31, 0x80u);
        sub_909C0("Got a strange local ipv6 address %s", &v31);
      }
      else
      {
        dword_2F8540 = 1;
      }
    }
    close(v3);
  }
  return 0;
}
// 2F853C: using guessed type int dword_2F853C;
// 2F8540: using guessed type int dword_2F8540;

//----- (00090468) --------------------------------------------------------
int __fastcall sub_90468(int a1)
{
  return *((unsigned __int8 *)&dword_EC0A8[133] + a1);
}

//----- (00090550) --------------------------------------------------------
char *__fastcall sub_90550(const char *a1)
{
  const char *v1; // r4
  char *result; // r0

  v1 = a1;
  if ( issetugid() )
    result = 0;
  else
    result = getenv(v1);
  return result;
}
// 25A24: using guessed type int issetugid(void);

//----- (00090604) --------------------------------------------------------
int __fastcall sub_90604(_DWORD *a1)
{
  signed int v1; // r3
  int result; // r0

  v1 = a1[1];
  if ( v1 > 1000000 || *a1 > 2147482 )
    result = -1;
  else
    result = (v1 + 999) / 1000 + 1000 * *a1;
  return result;
}

//----- (000906A8) --------------------------------------------------------
int sub_906A8()
{
  return 0;
}

//----- (000906C0) --------------------------------------------------------
int __fastcall sub_906C0(int a1, int a2, const char *a3, void *a4)
{
  int v4; // r7
  int v5; // r6
  size_t v6; // r0
  const char *v8; // r2
  char v9[1020]; // [sp+4h] [bp-41Ch]

  v4 = a2;
  v5 = a1;
  if ( a3 )
    sub_8EE3C(v9, 0x400u, a3, a4);
  else
    v9[0] = 0;
  if ( v4 )
  {
    v6 = strlen(v9);
    if ( v6 <= 0x3FC )
      sub_8ED8C(&v9[v6], 1024 - v6, ": %s", v4);
  }
  if ( dword_2F8544 )
    return dword_2F8544(v5, v9);
  switch ( v5 )
  {
    case 0:
      v8 = "debug";
      break;
    case 1:
      v8 = "msg";
      break;
    case 2:
      v8 = "warn";
      break;
    case 3:
      v8 = "err";
      break;
    default:
      v8 = "???";
      break;
  }
  return fprintf((FILE *)((char *)&_sF + 168), "[%s] %s\n", v8, v9);
}
// 2F8544: using guessed type int (__fastcall *dword_2F8544)(_DWORD, _DWORD);
// 906C0: using guessed type char var_41C[1020];

//----- (0009081C) --------------------------------------------------------
void __fastcall __noreturn sub_9081C(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( dword_2F8548 )
  {
    dword_2F8548();
    exit(v1);
  }
  if ( a1 != -559030611 )
    exit(a1);
  abort();
}
// 2F8548: using guessed type int (*dword_2F8548)(void);

//----- (00090874) --------------------------------------------------------
void __noreturn sub_90874(int a1, const char *a2, ...)
{
  int v2; // r5
  const char *v3; // r4
  int *v4; // r0
  char *v5; // r0
  int varg_r2; // [sp+18h] [bp-8h]
  va_list varg_r2a; // [sp+18h] [bp-8h]
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(varg_r3, _DWORD);
  v2 = a1;
  v3 = a2;
  v4 = (int *)_errno(a1, a2, varg_r2);
  v5 = strerror(*v4);
  sub_906C0(3, (int)v5, v3, varg_r2a);
  sub_9081C(v2);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000908B8) --------------------------------------------------------
int sub_908B8(const char *a1, ...)
{
  const char *v1; // r4
  int *v2; // r0
  char *v3; // r0
  int varg_r1; // [sp+14h] [bp-Ch]
  va_list varg_r1a; // [sp+14h] [bp-Ch]
  int varg_r2; // [sp+18h] [bp-8h]
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a1);
  va_start(varg_r1a, a1);
  varg_r1 = va_arg(varg_r3, _DWORD);
  varg_r2 = va_arg(varg_r3, _DWORD);
  v1 = a1;
  v2 = (int *)_errno(a1, varg_r1, varg_r2);
  v3 = strerror(*v2);
  return sub_906C0(2, (int)v3, v1, varg_r1a);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00090900) --------------------------------------------------------
void __noreturn sub_90900(int a1, int a2, const char *a3, ...)
{
  int v3; // r5
  const char *v4; // r4
  int *v5; // r0
  char *v6; // r0
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a3);
  v3 = a1;
  v4 = a3;
  v5 = (int *)_errno(a1, a2, a3);
  v6 = strerror(*v5);
  sub_906C0(3, (int)v6, v4, varg_r3);
  sub_9081C(v3);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00090944) --------------------------------------------------------
int sub_90944(int a1, const char *a2, ...)
{
  const char *v2; // r4
  int *v3; // r0
  char *v4; // r0
  int varg_r2; // [sp+18h] [bp-8h]
  va_list varg_r2a; // [sp+18h] [bp-8h]
  va_list varg_r3; // [sp+1Ch] [bp-4h]

  va_start(varg_r3, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(varg_r3, _DWORD);
  v2 = a2;
  v3 = (int *)_errno(a1, a2, varg_r2);
  v4 = strerror(*v3);
  return sub_906C0(2, (int)v4, v2, varg_r2a);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (0009098C) --------------------------------------------------------
void __noreturn sub_9098C(int a1, const char *a2, ...)
{
  int v2; // r4
  va_list varg_r2; // [sp+18h] [bp-8h]

  va_start(varg_r2, a2);
  v2 = a1;
  sub_906C0(3, 0, a2, varg_r2);
  sub_9081C(v2);
}

//----- (000909C0) --------------------------------------------------------
int sub_909C0(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch]

  va_start(varg_r1, a1);
  return sub_906C0(2, 0, a1, varg_r1);
}

//----- (000909F8) --------------------------------------------------------
int sub_909F8(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch]

  va_start(varg_r1, a1);
  return sub_906C0(1, 0, a1, varg_r1);
}

//----- (00090A7C) --------------------------------------------------------
void __fastcall sub_90A7C(_DWORD *a1)
{
  _DWORD *v1; // r4
  void *v2; // r0
  void *v3; // r0

  v1 = (_DWORD *)a1[1];
  sub_91A0C(a1);
  v2 = (void *)v1[3];
  if ( v2 )
    sub_8B130(v2);
  v3 = (void *)v1[4];
  if ( v3 )
    sub_8B130(v3);
  memset(v1, 0, 0x14u);
  sub_8B130(v1);
}

//----- (00090AC4) --------------------------------------------------------
signed int __fastcall sub_90AC4(int a1, int a2, int a3, char a4, _DWORD *a5)
{
  char v5; // r5
  int v6; // r6
  int v7; // r4
  signed int v8; // r3
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r1
  signed int result; // r0
  size_t v13; // r1
  int v14; // r7
  _DWORD *v15; // r0

  v5 = a4;
  v6 = a2;
  v7 = *(_DWORD *)(a1 + 4);
  if ( !(a4 & 6) )
    return 0;
  v8 = *(_DWORD *)v7;
  if ( *(_DWORD *)(v7 + 4) + 1 < *(_DWORD *)v7 )
  {
    v9 = *(_DWORD **)(v7 + 12);
    goto LABEL_4;
  }
  if ( v8 <= 31 )
  {
    v13 = 256;
    v14 = 32;
  }
  else
  {
    v13 = 16 * v8;
    v14 = 2 * v8;
  }
  v15 = sub_891F8(*(void **)(v7 + 12), v13);
  if ( v15 )
  {
    v9 = v15;
    *(_DWORD *)(v7 + 12) = v15;
    *(_DWORD *)v7 = v14;
    *(_DWORD *)(v7 + 8) = 1;
LABEL_4:
    if ( *a5 - 1 < 0 )
    {
      v11 = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 4) = v11 + 1;
      v10 = (int)&v9[2 * v11];
      *(_WORD *)(v10 + 4) = 0;
      v9[2 * v11] = v6;
      *a5 = v11 + 1;
    }
    else
    {
      v10 = (int)&v9[2 * (*a5 - 1)];
    }
    *(_WORD *)(v10 + 6) = 0;
    if ( v5 & 4 )
      *(_WORD *)(v10 + 4) |= 4u;
    if ( v5 & 2 )
    {
      result = 0;
      *(_WORD *)(v10 + 4) |= 1u;
      return result;
    }
    return 0;
  }
  sub_908B8("realloc");
  return -1;
}

//----- (00090BB8) --------------------------------------------------------
signed int __fastcall sub_90BB8(int a1, int a2, int a3, char a4, int *a5)
{
  int v5; // r7
  int v6; // r2
  int v7; // r5
  int v8; // r1
  int v9; // r6
  int v10; // r12
  signed int v11; // r4
  int v12; // r3
  int *v13; // r3
  int v14; // lr
  int v15; // r3

  v6 = *(_DWORD *)(a1 + 4);
  if ( a4 & 6 )
  {
    v7 = *a5;
    v8 = *a5 - 1;
    if ( v8 < 0 )
      return -1;
    v9 = *(_DWORD *)(v6 + 12);
    v10 = v9 + 8 * v8;
    if ( a4 & 2 )
    {
      v11 = 65534;
      v5 = *(unsigned __int16 *)(v10 + 4);
    }
    else
    {
      v11 = *(unsigned __int16 *)(v10 + 4);
    }
    if ( a4 & 2 )
    {
      v11 &= v5;
      *(_WORD *)(v10 + 4) = v11;
    }
    if ( a4 & 4 )
    {
      v11 &= 0xFFFBu;
      *(_WORD *)(v10 + 4) = v11;
    }
    if ( !v11 )
    {
      v12 = *(_DWORD *)(v6 + 4) - 1;
      *a5 = 0;
      *(_DWORD *)(v6 + 4) = v12;
      if ( v8 != v12 )
      {
        v13 = (int *)(v9 + 8 * v12);
        v14 = *v13;
        v15 = v13[1];
        *(_DWORD *)(v9 + 8 * v8) = v14;
        *(_DWORD *)(v10 + 4) = v15;
        *(_DWORD *)sub_8D944((_DWORD *)(a1 + 196), *(_DWORD *)(*(_DWORD *)(v6 + 12) + 8 * v8)) = v7;
        return 0;
      }
    }
  }
  return 0;
}

//----- (00090C78) --------------------------------------------------------
void *__fastcall sub_90C78(int a1)
{
  int v1; // r5
  void *v2; // r4

  v1 = a1;
  v2 = sub_89134(1u, 0x14u);
  if ( v2 )
    sub_91554(v1);
  return v2;
}

//----- (00090CA4) --------------------------------------------------------
signed int __fastcall sub_90CA4(int a1, _DWORD *a2)
{
  int v2; // r4
  int v3; // r7
  _DWORD *v4; // r6
  signed int v5; // r5
  void *v6; // r0
  struct pollfd *v7; // r8
  signed int v8; // r4
  int v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r6
  bool v13; // zf
  signed int v14; // r6
  int v16; // r1
  int v17; // r4
  int v18; // r1
  int v19; // r1
  __int16 v20; // r2
  char v21; // r3
  unsigned __int16 v22; // r2

  v2 = *(_DWORD *)(a1 + 4);
  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(v2 + 4);
  if ( *(_DWORD *)(a1 + 264) )
  {
    if ( *(_DWORD *)(v2 + 8) )
    {
      v6 = sub_891F8(*(void **)(v2 + 16), 8 * *(_DWORD *)v2);
      if ( !v6 )
      {
        sub_908B8("realloc");
        return -1;
      }
      *(_DWORD *)(v2 + 16) = v6;
      *(_DWORD *)(v2 + 8) = 0;
    }
    else
    {
      v6 = *(void **)(v2 + 16);
    }
    memcpy(v6, *(const void **)(v2 + 12), 8 * v5);
    v7 = *(struct pollfd **)(v2 + 16);
  }
  else
  {
    v7 = *(struct pollfd **)(v2 + 12);
  }
  if ( v4 )
  {
    v8 = sub_90604(v4);
    if ( v8 < 0 )
      v8 = 0x7FFFFFFF;
  }
  else
  {
    v8 = -1;
  }
  if ( *(_DWORD *)(v3 + 264) )
    dword_2F8510(0);
  v9 = poll(v7, v5, v8);
  v11 = *(_DWORD *)(v3 + 264);
  v12 = v9;
  if ( v11 )
    v9 = dword_2F850C(0);
  if ( v12 != -1 )
  {
    v13 = v5 == 0;
    if ( v5 )
      v13 = v12 == 0;
    v14 = v13 != 0;
    if ( !v13 )
    {
      v16 = lrand48() % v5;
      v17 = v16;
      if ( v5 > 0 )
      {
        while ( 1 )
        {
          if ( ++v17 == v5 )
          {
            v17 = 0;
            v18 = 0;
          }
          else
          {
            v18 = v17;
          }
          v19 = (int)&v7[v18];
          v20 = *(_WORD *)(v19 + 6);
          v21 = *(_WORD *)(v19 + 6);
          if ( !v20 )
            goto LABEL_36;
          if ( v20 & 0x18 )
            v21 = v20 | 5;
          v22 = v21 & 1;
          if ( !(v21 & 1) )
            break;
          v22 = 2;
          if ( v21 & 4 )
            goto LABEL_34;
LABEL_35:
          sub_8D734(v3, *(_DWORD *)v19, v22);
LABEL_36:
          if ( ++v14 == v5 )
            return 0;
        }
        if ( !(v21 & 4) )
          goto LABEL_36;
LABEL_34:
        v22 |= 4u;
        goto LABEL_35;
      }
    }
    return 0;
  }
  if ( *(_DWORD *)_errno(v9, v11, v10) == 4 )
    return 0;
  sub_908B8("poll");
  return -1;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (00090E84) --------------------------------------------------------
int __fastcall sub_90E84(int a1, int a2, int a3, char a4)
{
  _DWORD *v4; // r2

  v4 = *(_DWORD **)(a1 + 4);
  if ( *v4 >= a2 )
  {
    if ( a4 & 2 )
      *(_DWORD *)(v4[3] + 4 * (a2 >> 5)) &= ~(1 << (a2 & 0x1F));
    if ( a4 & 4 )
      *(_DWORD *)(v4[4] + 4 * (a2 >> 5)) &= ~(1 << (a2 & 0x1F));
  }
  return 0;
}

//----- (00090EF0) --------------------------------------------------------
void __fastcall sub_90EF0(void *s)
{
  _DWORD *v1; // r4
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0

  v1 = s;
  v2 = (void *)*((_DWORD *)s + 3);
  if ( v2 )
    sub_8B130(v2);
  v3 = (void *)v1[4];
  if ( v3 )
    sub_8B130(v3);
  v4 = (void *)v1[5];
  if ( v4 )
    sub_8B130(v4);
  v5 = (void *)v1[6];
  if ( v5 )
    sub_8B130(v5);
  memset(v1, 0, 0x1Cu);
  sub_8B130(v1);
}

//----- (00090F54) --------------------------------------------------------
void __fastcall sub_90F54(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  sub_91A0C(a1);
  sub_90EF0((void *)v1[1]);
}

//----- (00090F6C) --------------------------------------------------------
signed int __fastcall sub_90F6C(int a1, size_t a2)
{
  int v2; // r4
  size_t v3; // r5
  void *v4; // r0
  void *v5; // r0
  int v6; // r3
  int v7; // lr
  signed int result; // r0

  v2 = a1;
  v3 = a2;
  v4 = sub_891F8(*(void **)(a1 + 12), a2);
  if ( v4 && (*(_DWORD *)(v2 + 12) = v4, (v5 = sub_891F8(*(void **)(v2 + 16), v3)) != 0) )
  {
    v6 = *(_DWORD *)(v2 + 4);
    v7 = *(_DWORD *)(v2 + 12);
    *(_DWORD *)(v2 + 16) = v5;
    *(_DWORD *)(v2 + 8) = 1;
    memset((void *)(v7 + v6), 0, v3 - v6);
    memset((void *)(*(_DWORD *)(v2 + 16) + *(_DWORD *)(v2 + 4)), 0, v3 - *(_DWORD *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = v3;
    result = 0;
  }
  else
  {
    sub_908B8("malloc");
    result = -1;
  }
  return result;
}

//----- (00091000) --------------------------------------------------------
int __fastcall sub_91000(int a1, int a2, int a3, char a4)
{
  int v4; // r4
  _DWORD *v5; // r5
  char v6; // r6
  signed int v7; // r3
  unsigned int v8; // r12
  signed int v9; // r1
  int i; // r12
  int result; // r0

  v4 = a2;
  v5 = *(_DWORD **)(a1 + 4);
  v6 = a4;
  if ( *v5 < a2 )
  {
    v7 = v5[1];
    v8 = (unsigned int)(a2 + 32) >> 5;
    if ( v7 < 4 )
      v9 = 4;
    else
      v9 = v5[1];
    for ( i = 4 * v8; v9 < i; v9 *= 2 )
      ;
    if ( v9 != v7 && sub_90F6C(*(_DWORD *)(a1 + 4), v9) )
      return -1;
    *v5 = v4;
  }
  if ( v6 & 2 )
    *(_DWORD *)(v5[3] + 4 * (v4 >> 5)) |= 1 << (v4 & 0x1F);
  result = v6 & 4;
  if ( v6 & 4 )
  {
    result = 0;
    *(_DWORD *)(v5[4] + 4 * (v4 >> 5)) |= 1 << (v4 & 0x1F);
  }
  return result;
}

//----- (000910D0) --------------------------------------------------------
void *__fastcall sub_910D0(int a1)
{
  int v1; // r5
  void *v2; // r0
  void *v3; // r4

  v1 = a1;
  v2 = sub_89134(1u, 0x1Cu);
  v3 = v2;
  if ( v2 )
  {
    if ( !sub_90F6C((int)v2, 8u) )
    {
      sub_91554(v1);
      return v3;
    }
    sub_90EF0(v3);
  }
  return 0;
}

//----- (0009111C) --------------------------------------------------------
signed int __fastcall sub_9111C(int a1, struct timeval *a2)
{
  size_t v2; // r5
  signed int v3; // r9
  int v4; // r8
  int v5; // r6
  struct timeval *timeout; // r4
  void *v7; // r0
  void *v8; // r0
  int v9; // r7
  int v10; // r0
  int v11; // r2
  int v12; // r1
  int v13; // r4
  int v14; // r1
  signed int v15; // r3
  int v16; // r4
  bool v17; // zf
  bool v18; // nf
  unsigned __int8 v19; // vf
  int v20; // r2

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 4);
  timeout = a2;
  if ( *(_DWORD *)(v5 + 8) )
  {
    v2 = *(_DWORD *)(v5 + 4);
    v7 = sub_891F8(*(void **)(v5 + 20), *(_DWORD *)(v5 + 4));
    if ( !v7 )
      return -1;
    *(_DWORD *)(v5 + 20) = v7;
    v8 = sub_891F8(*(void **)(v5 + 24), v2);
    if ( !v8 )
      return -1;
    *(_DWORD *)(v5 + 24) = v8;
    *(_DWORD *)(v5 + 8) = 0;
  }
  memcpy(*(void **)(v5 + 20), *(const void **)(v5 + 12), *(_DWORD *)(v5 + 4));
  memcpy(*(void **)(v5 + 24), *(const void **)(v5 + 16), *(_DWORD *)(v5 + 4));
  v9 = *(_DWORD *)v5 + 1;
  if ( *(_DWORD *)(v4 + 264) )
    dword_2F8510(0);
  v10 = select(v9, *(fd_set **)(v5 + 20), *(fd_set **)(v5 + 24), 0, timeout);
  v12 = *(_DWORD *)(v4 + 264);
  v13 = v10;
  if ( v12 )
    v10 = dword_2F850C(0);
  if ( v13 != -1 )
  {
    v14 = lrand48() % v9;
    if ( v9 > 0 )
    {
      v2 = 0;
      v3 = 1;
    }
    v16 = v14;
    if ( v9 > 0 )
    {
      while ( 1 )
      {
        v19 = __OFSUB__(v9, ++v16);
        v17 = v9 == v16;
        v18 = v9 - v16 < 0;
        if ( v9 <= v16 )
        {
          v16 = 0;
        }
        else
        {
          v14 = v16 >> 5;
          LOBYTE(v15) = v16 & 0x1F;
        }
        if ( (unsigned __int8)(v18 ^ v19) | v17 )
        {
          v14 = v16;
          v15 = 1;
        }
        else
        {
          v15 = v3 << v15;
        }
        v20 = v15 & *(_DWORD *)(*(_DWORD *)(v5 + 20) + 4 * v14);
        if ( !v20 )
          break;
        LOWORD(v20) = 2;
        if ( v15 & *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * v14) )
          goto LABEL_21;
LABEL_22:
        sub_8D734(v4, v16, v20);
LABEL_23:
        if ( ++v2 == v9 )
          return 0;
      }
      v14 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * v14);
      if ( !(v15 & v14) )
        goto LABEL_23;
LABEL_21:
      LOWORD(v20) = v20 | 4;
      goto LABEL_22;
    }
    return 0;
  }
  if ( *(_DWORD *)_errno(v10, v12, v11) == 4 )
    return 0;
  sub_908B8("select");
  return -1;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (000912E0) --------------------------------------------------------
_DWORD *__fastcall sub_912E0(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  ssize_t v5; // r0
  int v6; // r1
  int v7; // r2
  _DWORD *result; // r0
  char v9; // [sp+7h] [bp-11h]

  v3 = a1;
  v4 = *(_DWORD *)_errno(a1, a2, a3);
  if ( !dword_2F854C )
    return (_DWORD *)sub_909C0("%s: received signal %d, but have no base configured", "evsig_handler", v3);
  v9 = v3;
  v5 = send(dword_F3C44, &v9, 1u, 0);
  result = (_DWORD *)_errno(v5, v6, v7);
  *result = v4;
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F3C44: using guessed type int dword_F3C44;
// 2F854C: using guessed type int dword_2F854C;

//----- (00091368) --------------------------------------------------------
_DWORD *__fastcall sub_91368(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r6
  _DWORD *result; // r0
  int v6; // r1
  int v7; // r2
  int *v8; // r3
  unsigned int v9; // r12
  unsigned int v10; // t1
  bool v11; // zf
  int *v12; // r5
  int v13; // r4
  __int16 v14; // r2
  int v15; // t1
  int v16; // r1
  int v17; // [sp+0h] [bp-98h]
  _DWORD v18[1]; // [sp+80h] [bp-18h]

  v3 = a1;
  v4 = a3;
  memset(&v17, 0, 0x80u);
  while ( 1 )
  {
    result = (_DWORD *)recv(v3, &byte_2F8550, 0x400u, 0);
    if ( result == (_DWORD *)-1 )
      break;
    if ( !result )
      goto LABEL_14;
    if ( (signed int)result > 0 )
    {
      v8 = (int *)((char *)&dword_2F854C + 3);
      do
      {
        v10 = *((unsigned __int8 *)v8 + 1);
        v8 = (int *)((char *)v8 + 1);
        v9 = v10;
        if ( v10 <= 0x1F )
          ++v18[v9 - 32];
      }
      while ( v8 != (_DWORD *)((char *)result + (_DWORD)&dword_2F854C + 3) );
    }
  }
  result = (_DWORD *)_errno(-1, v6, v7);
  v11 = *result == 11;
  if ( *result != 11 )
    v11 = *result == 4;
  if ( !v11 )
    sub_90900(1, v3, "%s: recv", "evsig_cb");
LABEL_14:
  if ( *(_DWORD *)(v4 + 264) )
    result = (_DWORD *)dword_2F850C(0);
  v12 = &v17 - 1;
  v13 = 0;
  do
  {
    while ( 1 )
    {
      v15 = v12[1];
      ++v12;
      v14 = v15;
      if ( v15 )
        break;
      if ( ++v13 == 32 )
        goto LABEL_20;
    }
    v16 = v13++;
    result = (_DWORD *)sub_8D908(v4, v16, v14);
  }
  while ( v13 != 32 );
LABEL_20:
  if ( *(_DWORD *)(v4 + 264) )
    result = (_DWORD *)dword_2F8510(0);
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F854C: using guessed type int dword_2F854C;
// 2F8550: using guessed type char byte_2F8550;

//----- (000914BC) --------------------------------------------------------
int __fastcall sub_914BC(int result)
{
  int v1; // r5
  int v2; // r2
  int v3; // r1
  int v4; // r2

  v1 = result;
  if ( dword_2F8950 )
  {
    dword_2F850C(0);
    result = *(_DWORD *)(v1 + 108);
    v2 = *(_DWORD *)(v1 + 96);
    dword_2F854C = v1;
    dword_2F8954 = result;
    dword_F3C44 = v2;
    if ( dword_2F8950 )
      result = dword_2F8510(0);
  }
  else
  {
    v3 = *(_DWORD *)(result + 108);
    v4 = *(_DWORD *)(result + 96);
    dword_2F854C = result;
    dword_2F8954 = v3;
    dword_F3C44 = v4;
  }
  return result;
}
// 3F8: using guessed type Elf32_Sym stru_3F8;
// F3C44: using guessed type int dword_F3C44;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F854C: using guessed type int dword_2F854C;
// 2F8950: using guessed type int dword_2F8950;
// 2F8954: using guessed type int dword_2F8954;

//----- (00091554) --------------------------------------------------------
int __fastcall sub_91554(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = a1;
  if ( j_socketpair(1, 1, 0, (int *)(a1 + 96)) == -1 )
    sub_90900(1, -1, "%s: socketpair", "evsig_init");
  sub_8E8D8(*(_DWORD *)(v1 + 96));
  sub_8E8D8(*(_DWORD *)(v1 + 100));
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 116) = 0;
  sub_8E834(*(_DWORD *)(v1 + 96));
  sub_8E834(*(_DWORD *)(v1 + 100));
  sub_8B328(v1 + 24, v1, *(_DWORD *)(v1 + 100), 18, (int)sub_91368, v1);
  *(_WORD *)(v1 + 76) |= 0x10u;
  sub_881C4(v1 + 24, 0);
  result = 0;
  *(_DWORD *)(v1 + 20) = &off_EF98C;
  return result;
}
// EF98C: using guessed type char *off_EF98C;

//----- (00091630) --------------------------------------------------------
int __fastcall sub_91630(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r4
  int v5; // r8
  char *v6; // r6
  int v7; // r3
  struct sigaction *v8; // r2
  int v9; // r6
  int v11; // r7
  char *v12; // r9
  int v13; // [sp+0h] [bp-30h]
  int v14; // [sp+4h] [bp-2Ch]
  int v15; // [sp+8h] [bp-28h]
  int v16; // [sp+Ch] [bp-24h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( *(_DWORD *)(a1 + 116) <= a2 )
  {
    v11 = a2 + 1;
    v12 = (char *)sub_891F8(*(void **)(a1 + 112), 4 * (a2 + 1));
    if ( !v12 )
    {
      v9 = -1;
      sub_908B8("realloc");
      return v9;
    }
    v6 = v12;
    memset(&v12[4 * *(_DWORD *)(v3 + 116)], 0, 4 * (v11 - *(_DWORD *)(v3 + 116)));
    *(_DWORD *)(v3 + 116) = v11;
    *(_DWORD *)(v3 + 112) = v12;
  }
  else
  {
    v6 = *(char **)(a1 + 112);
  }
  *(_DWORD *)&v6[4 * v4] = sub_89108(0x10u);
  v7 = *(_DWORD *)(v3 + 112);
  if ( *(_DWORD *)(v7 + 4 * v4) )
  {
    v13 = v5;
    v16 = 0;
    v8 = *(struct sigaction **)(v7 + 4 * v4);
    v14 = -1;
    v15 = 0x10000000;
    v9 = sigaction(v4, (const struct sigaction *)&v13, v8);
    if ( v9 == -1 )
    {
      sub_908B8("sigaction");
      sub_8B130(*(void **)(*(_DWORD *)(v3 + 112) + 4 * v4));
      *(_DWORD *)(*(_DWORD *)(v3 + 112) + 4 * v4) = 0;
    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    v9 = -1;
    sub_908B8("malloc");
  }
  return v9;
}

//----- (0009174C) --------------------------------------------------------
signed int __fastcall sub_9174C(int a1, int a2)
{
  int v2; // r6
  int v3; // r4
  int v4; // r12
  int v5; // r2
  bool v6; // zf
  signed int result; // r0
  int v8; // r1
  int v9; // r3
  int v10; // r3
  int v11; // r3

  v2 = a2;
  v3 = a1;
  if ( dword_2F8950 )
    dword_2F850C(0);
  if ( dword_2F854C != v3 && dword_2F8954 )
  {
    v10 = **(_DWORD **)v3;
    sub_909C0(
      "Added a signal to event base %p with signals already added to event_base %p.  Only one can have signals at a time "
      "with the %s backend.  The base with the most recently added signal or the most recent event_base_loop() call gets "
      "preference; do not rely on this behavior in future Libevent versions.",
      v3);
  }
  v4 = *(_DWORD *)(v3 + 96);
  v5 = *(_DWORD *)(v3 + 108) + 1;
  dword_2F854C = v3;
  v6 = dword_2F8950 == 0;
  dword_F3C44 = v4;
  dword_2F8954 = v5;
  *(_DWORD *)(v3 + 108) = v5;
  if ( !v6 )
    dword_2F8510(0);
  if ( sub_91630(v3, v2, (int)sub_912E0) == -1 )
    goto LABEL_21;
  if ( *(_DWORD *)(v3 + 104) )
    return 0;
  result = sub_8AD50(v3 + 24, 0);
  if ( result )
  {
LABEL_21:
    if ( dword_2F8950 )
    {
      dword_2F850C(0);
      v8 = dword_2F8950;
      v9 = *(_DWORD *)(v3 + 108);
      --dword_2F8954;
      *(_DWORD *)(v3 + 108) = v9 - 1;
      if ( v8 )
        dword_2F8510(0);
      result = -1;
    }
    else
    {
      result = -1;
      v11 = *(_DWORD *)(v3 + 108);
      --dword_2F8954;
      *(_DWORD *)(v3 + 108) = v11 - 1;
    }
  }
  else
  {
    *(_DWORD *)(v3 + 104) = 1;
  }
  return result;
}
// 3F8: using guessed type Elf32_Sym stru_3F8;
// F3C44: using guessed type int dword_F3C44;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F854C: using guessed type int dword_2F854C;
// 2F8950: using guessed type int dword_2F8950;
// 2F8954: using guessed type int dword_2F8954;

//----- (0009190C) --------------------------------------------------------
signed int __fastcall sub_9190C(int a1, int a2)
{
  signed int v2; // r4
  int v3; // r3
  struct sigaction *v4; // r5

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 112);
  v4 = *(struct sigaction **)(v3 + 4 * a2);
  *(_DWORD *)(v3 + 4 * a2) = 0;
  if ( sigaction(a2, v4, 0) == -1 )
  {
    v2 = -1;
    sub_908B8("sigaction");
  }
  sub_8B130(v4);
  return v2;
}

//----- (00091964) --------------------------------------------------------
signed int __fastcall sub_91964(int a1, int a2)
{
  int v2; // r7
  int v3; // r5
  int v4; // r3
  int v5; // r2
  signed int result; // r0
  int v7; // r3

  v2 = a2;
  v3 = a1;
  if ( dword_2F8950 )
  {
    dword_2F850C(0);
    v4 = dword_2F8950;
    v5 = *(_DWORD *)(v3 + 108);
    --dword_2F8954;
    *(_DWORD *)(v3 + 108) = v5 - 1;
    if ( v4 )
      dword_2F8510(0);
    result = sub_9190C(v3, v2);
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 108);
    --dword_2F8954;
    *(_DWORD *)(a1 + 108) = v7 - 1;
    result = sub_9190C(a1, a2);
  }
  return result;
}
// 3F8: using guessed type Elf32_Sym stru_3F8;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F8950: using guessed type int dword_2F8950;
// 2F8954: using guessed type int dword_2F8954;

//----- (00091A0C) --------------------------------------------------------
void __fastcall sub_91A0C(_DWORD *a1)
{
  _DWORD *v1; // r5
  int v2; // r4
  unsigned int v3; // r0
  int v4; // r4
  int v5; // r1
  int v6; // r0
  int v7; // r0
  void *v8; // r0

  v1 = a1;
  v2 = (int)(a1 + 6);
  if ( a1[26] )
  {
    sub_88C24((unsigned int)(a1 + 6));
    v1[26] = 0;
  }
  v3 = v2;
  v4 = 0;
  sub_8C074(v3);
  do
  {
    if ( v1[29] > v4 && *(_DWORD *)(v1[28] + 4 * v4) )
      sub_9190C((int)v1, v4);
    ++v4;
  }
  while ( v4 != 32 );
  v5 = dword_2F8950;
  if ( dword_2F8950 )
  {
    dword_2F850C(0);
    v5 = dword_2F8950;
  }
  if ( v1 == (_DWORD *)dword_2F854C )
  {
    dword_2F854C = 0;
    dword_2F8954 = 0;
    dword_F3C44 = -1;
  }
  if ( v5 )
    dword_2F8510(0);
  v6 = v1[24];
  if ( v6 != -1 )
  {
    j_close(v6);
    v1[24] = -1;
  }
  v7 = v1[25];
  if ( v7 != -1 )
  {
    j_close(v7);
    v1[25] = -1;
  }
  v8 = (void *)v1[28];
  v1[29] = 0;
  if ( v8 )
  {
    sub_8B130(v8);
    v1[28] = 0;
  }
}
// 3F8: using guessed type Elf32_Sym stru_3F8;
// F3C44: using guessed type int dword_F3C44;
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);
// 2F854C: using guessed type int dword_2F854C;
// 2F8950: using guessed type int dword_2F8950;
// 2F8954: using guessed type int dword_2F8954;

//----- (00091B58) --------------------------------------------------------
signed int __fastcall sub_91B58(int a1)
{
  dword_2F8950 = (int)sub_8E1D8((_DWORD *)dword_2F8950, 0, a1);
  if ( dword_2F8950 )
    return 0;
  sub_908B8("Couldn't allocate %s", "evsig_base_lock");
  return -1;
}
// 3F8: using guessed type Elf32_Sym stru_3F8;
// 2F8950: using guessed type int dword_2F8950;

//----- (00091BB0) --------------------------------------------------------
void __fastcall sub_91BB0(_DWORD *a1)
{
  int v1; // r4
  int v2; // r0

  v1 = a1[1];
  sub_91A0C(a1);
  if ( *(_DWORD *)v1 )
    sub_8B130(*(void **)v1);
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 >= 0 )
    close(v2);
  *(_BYTE *)v1 = 0;
  *(_BYTE *)(v1 + 1) = 0;
  *(_BYTE *)(v1 + 2) = 0;
  *(_BYTE *)(v1 + 3) = 0;
  *(_BYTE *)(v1 + 4) = 0;
  *(_BYTE *)(v1 + 5) = 0;
  *(_BYTE *)(v1 + 6) = 0;
  *(_BYTE *)(v1 + 7) = 0;
  *(_BYTE *)(v1 + 8) = 0;
  *(_BYTE *)(v1 + 9) = 0;
  *(_BYTE *)(v1 + 10) = 0;
  *(_BYTE *)(v1 + 11) = 0;
  sub_8B130((void *)v1);
}

//----- (00091C24) --------------------------------------------------------
int __fastcall sub_91C24(int *a1, int a2)
{
  int *v2; // r4
  int *v3; // r7
  unsigned int v4; // r6
  int v5; // r12
  int v6; // r6
  int v7; // r5
  int v9; // r3
  int v10; // lr
  int v11; // r0
  int v12; // r1
  int v13; // r2
  _DWORD *v14; // r0
  int v15; // r1
  int v16; // r2
  _DWORD *v17; // r0
  int v18; // r1
  int v19; // r2
  _DWORD *v20; // r0
  const char *v21; // r1
  int v22; // lr
  const char *v23; // r7
  int v24; // r12
  const char *v25; // r0
  int v26; // r3
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  int v29; // [sp+18h] [bp-28h]
  int v30; // [sp+1Ch] [bp-24h]
  int v31; // [sp+20h] [bp-20h]
  int v32; // [sp+24h] [bp-1Ch]

  v2 = (int *)a2;
  v3 = a1;
  if ( *(_BYTE *)(a2 + 6) & 1 )
  {
    v4 = *(unsigned __int16 *)(a2 + 4);
    if ( *(_BYTE *)(a2 + 7) & 1 )
    {
      v5 = 5;
    }
    else if ( *(_BYTE *)(a2 + 7) & 2 )
    {
      v5 = 1;
    }
    else if ( v4 & 4 )
    {
      v5 = 5;
    }
    else
    {
      v5 = 1;
    }
    goto LABEL_7;
  }
  if ( *(_BYTE *)(a2 + 7) & 1 )
  {
    v4 = *(unsigned __int16 *)(a2 + 4);
    if ( *(_BYTE *)(a2 + 6) & 2 )
      v5 = 4;
    else
      v5 = (v4 >> 1) & 1 | 4;
LABEL_7:
    if ( (*(_BYTE *)(a2 + 7) | *(_BYTE *)(a2 + 6)) & 0x20 )
      v5 |= 0x80000000;
    if ( v4 )
      v6 = 3;
    else
      v6 = 1;
    if ( !v5 )
      return 0;
    goto LABEL_28;
  }
  if ( *(_BYTE *)(a2 + 6) & 2 )
  {
    if ( *(_BYTE *)(a2 + 7) & 2 )
    {
      v5 = 5;
      v6 = 2;
    }
    else
    {
      v26 = *(_WORD *)(a2 + 4) & 4;
      if ( v26 )
        v5 = 4;
      else
        v5 = 1;
      if ( v26 )
        v6 = 3;
      else
        v6 = 2;
    }
  }
  else
  {
    if ( !(*(_BYTE *)(a2 + 7) & 2) )
      return 0;
    v9 = *(_WORD *)(a2 + 4) & 2;
    if ( v9 )
      v5 = 1;
    else
      v5 = 4;
    if ( v9 )
      v6 = 3;
    else
      v6 = 2;
  }
LABEL_28:
  v10 = *(_DWORD *)a2;
  v11 = *a1;
  v29 = v5;
  v31 = v10;
  v30 = 0;
  v32 = 0;
  v7 = sub_922AC(v11, v6, v10, (int)&v29);
  if ( v7 != -1 )
    return 0;
  if ( v6 == 3 )
  {
    v27 = (_DWORD *)_errno(-1, v12, v13);
    v21 = "MOD";
    if ( *v27 == 2 )
    {
      v7 = sub_922AC(*v3, 1, *v2, (int)&v29);
      if ( v7 == -1 )
      {
        sub_908B8("Epoll MOD(%d) on %d retried as ADD; that failed too", v29, *v2);
        return v7;
      }
      return 0;
    }
  }
  else
  {
    if ( v6 != 1 )
    {
      v14 = (_DWORD *)_errno(-1, v12, v13);
      if ( *v14 != 2 )
      {
        v17 = (_DWORD *)_errno(v14, v15, v16);
        if ( *v17 != 9 )
        {
          v20 = (_DWORD *)_errno(v17, v18, v19);
          v21 = "DEL";
          if ( *v20 != 1 )
            goto LABEL_34;
        }
      }
      return 0;
    }
    v28 = (_DWORD *)_errno(-1, v12, v13);
    v21 = "ADD";
    if ( *v28 == 17 )
    {
      v7 = sub_922AC(*v3, 3, *v2, (int)&v29);
      if ( v7 == -1 )
      {
        sub_908B8("Epoll ADD(%d) on %d retried as MOD; that failed too", v29, *v2);
        return v7;
      }
      return 0;
    }
  }
LABEL_34:
  v22 = *((unsigned __int8 *)v2 + 6);
  if ( (v22 & 3) == 1 )
  {
    v23 = "add";
  }
  else if ( (v22 & 3) == 2 )
  {
    v23 = "del";
  }
  else
  {
    v23 = "none";
    if ( v22 & 3 )
      v23 = "???";
  }
  v24 = *((unsigned __int8 *)v2 + 7);
  if ( (v24 & 3) == 1 )
  {
    v25 = "add";
  }
  else if ( (v24 & 3) == 2 )
  {
    v25 = "del";
  }
  else if ( v24 & 3 )
  {
    v25 = "???";
  }
  else
  {
    v25 = "none";
  }
  sub_908B8(
    "Epoll %s(%d) on fd %d failed.  Old events were %d; read change was %d (%s); write change was %d (%s)",
    v21,
    v29,
    *v2,
    *((signed __int16 *)v2 + 2),
    v22,
    v23,
    v24,
    v25);
  return v7;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (00091F34) --------------------------------------------------------
int __fastcall sub_91F34(int a1, int a2, __int16 a3, char a4)
{
  int *v4; // r0
  int v6; // [sp+0h] [bp-10h]
  __int16 v7; // [sp+4h] [bp-Ch]
  char v8; // [sp+6h] [bp-Ah]
  char v9; // [sp+7h] [bp-9h]

  v4 = (int *)(*(_DWORD *)(a1 + 4) + 8);
  v7 = a3;
  v9 = 0;
  v8 = 0;
  if ( a4 & 4 )
    v9 = 2;
  v6 = a2;
  if ( a4 & 2 )
    v8 = 2;
  return sub_91C24(v4, (int)&v6);
}

//----- (00091F84) --------------------------------------------------------
int __fastcall sub_91F84(int a1, int a2, __int16 a3, char a4)
{
  char v4; // r12
  int v5; // r0
  int *v6; // r0
  int v8; // [sp+0h] [bp-10h]
  __int16 v9; // [sp+4h] [bp-Ch]
  char v10; // [sp+6h] [bp-Ah]
  char v11; // [sp+7h] [bp-9h]

  v4 = a4;
  v5 = *(_DWORD *)(a1 + 4);
  v9 = a3;
  v11 = 0;
  v6 = (int *)(v5 + 8);
  v10 = 0;
  if ( a4 & 4 )
    v11 = a4 & 0x20 | 1;
  v8 = a2;
  if ( a4 & 2 )
    a4 &= 0x20u;
  if ( v4 & 2 )
    v10 = a4 | 1;
  return sub_91C24(v6, (int)&v8);
}

//----- (00091FDC) --------------------------------------------------------
signed int __fastcall sub_91FDC(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r7
  int *v4; // r9
  unsigned int v5; // r0
  int v6; // r6
  int v7; // r8
  int *v8; // r6
  int v9; // r4
  int v10; // r1
  int v11; // r0
  int v12; // r2
  int v13; // r1
  signed int v14; // r8
  int *v15; // r4
  int v16; // r6
  int v17; // r3
  signed __int16 v18; // r2
  unsigned __int16 v19; // r2
  signed int result; // r0
  void *v21; // r0
  int v22; // r8

  v2 = a1;
  v3 = a1[1];
  v4 = *(int **)v3;
  if ( a2 )
  {
    v5 = sub_90604(a2);
    v6 = v2[1];
    v7 = v5;
    if ( v5 > 0x200B20 )
      v7 = 2100000;
  }
  else
  {
    v6 = a1[1];
    v7 = -1;
  }
  if ( v2[3] > 0 )
  {
    v8 = (int *)(v6 + 8);
    v9 = 0;
    do
    {
      v10 = v2[2] + 8 * v9++;
      sub_91C24(v8, v10);
    }
    while ( v9 < v2[3] );
  }
  sub_8D96C(v2 + 2, (int)v2);
  if ( v2[66] )
    dword_2F8510(0);
  v11 = sub_922DC(*(_DWORD *)(v3 + 8), (int)v4, *(_DWORD *)(v3 + 4), v7);
  v13 = v2[66];
  v14 = v11;
  if ( v13 )
    v11 = dword_2F850C(0);
  if ( v14 != -1 )
  {
    if ( v14 > 0 )
    {
      v15 = v4;
      v16 = 0;
      do
      {
        v17 = *v15;
        if ( *v15 & 0x18 )
        {
          v19 = 38;
        }
        else
        {
          v18 = v17 & 1;
          if ( !(v17 & 1) )
          {
            if ( !(v17 & 4) )
              goto LABEL_23;
            goto LABEL_33;
          }
          if ( v17 & 4 )
          {
            v18 = 2;
LABEL_33:
            v19 = v18 | 0x24;
            goto LABEL_22;
          }
          v19 = 34;
        }
LABEL_22:
        sub_8D734((int)v2, v15[2], v19);
LABEL_23:
        ++v16;
        v15 += 4;
      }
      while ( v16 != v14 );
    }
    if ( *(_DWORD *)(v3 + 4) == v14 && v14 < 4096 )
    {
      v21 = sub_891F8(*(void **)v3, 32 * v14);
      v22 = 2 * v14;
      if ( v21 )
      {
        *(_DWORD *)v3 = v21;
        result = 0;
        *(_DWORD *)(v3 + 4) = v22;
        return result;
      }
    }
    return 0;
  }
  if ( *(_DWORD *)_errno(v11, v13, v12) == 4 )
    return 0;
  sub_908B8("epoll_wait");
  return -1;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 2F850C: using guessed type int (__fastcall *dword_2F850C)(_DWORD);
// 2F8510: using guessed type int (__fastcall *dword_2F8510)(_DWORD);

//----- (0009219C) --------------------------------------------------------
void *__fastcall sub_9219C(_DWORD *a1)
{
  _DWORD *v1; // r6
  int v2; // r0
  int v3; // r1
  int v4; // r2
  int v5; // r7
  _DWORD *v6; // r0
  _DWORD *v7; // r5
  void *v8; // r4
  int v9; // r3

  v1 = a1;
  v2 = sub_922A0(32000);
  v5 = v2;
  if ( v2 != -1 )
  {
    sub_8E8D8(v2);
    v6 = sub_89134(1u, 0xCu);
    v7 = v6;
    if ( v6 )
    {
      v6[2] = v5;
      v8 = sub_89134(0x20u, 0x10u);
      *v7 = v8;
      if ( v8 )
      {
        v9 = v1[70];
        v7[1] = 32;
        if ( v9 & 0x10 || !(v9 & 2) && sub_90550("EVENT_EPOLL_USE_CHANGELIST") )
          *v1 = &off_F04EC;
        v8 = v7;
        sub_91554((int)v1);
      }
      else
      {
        sub_8B130(v7);
        close(v5);
      }
    }
    else
    {
      v8 = 0;
      close(v5);
    }
    return v8;
  }
  if ( *(_DWORD *)_errno(-1, v3, v4) == 38 )
    return 0;
  sub_908B8("epoll_create");
  return 0;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// F04EC: using guessed type char *off_F04EC;

//----- (000922A0) --------------------------------------------------------
int __fastcall sub_922A0(int a1)
{
  return syscall(250, a1);
}

//----- (000922AC) --------------------------------------------------------
int __fastcall sub_922AC(int a1, int a2, int a3, int a4)
{
  return syscall(251, a1, a2, a3, a4);
}

//----- (000922DC) --------------------------------------------------------
int __fastcall sub_922DC(int a1, int a2, int a3, int a4)
{
  return syscall(252, a1, a2, a3, a4);
}

//----- (0009230C) --------------------------------------------------------
signed int __fastcall _cxa_guard_acquire(unsigned int *a1)
{
  unsigned int *v1; // r5
  int v2; // r4
  unsigned int v3; // r3
  bool v4; // zf
  unsigned int v5; // r1
  unsigned int v7; // r2
  bool v8; // zf
  unsigned int v9; // r1

  v1 = a1;
  v2 = *a1 & 1;
  if ( v2 )
    return 0;
  while ( 1 )
  {
    __dmb(0xFu);
    do
    {
      v3 = __ldrex(v1);
      v4 = v3 == 0;
      if ( v3 )
        break;
      v5 = __strex(0x100u, v1);
      v4 = v5 == 0;
    }
    while ( v5 );
    __dmb(0xFu);
    if ( v4 )
      return 1;
    if ( v3 == 1 )
      return v2;
    if ( v3 == 256 )
    {
      __dmb(0xFu);
      do
      {
        v7 = __ldrex(v1);
        v8 = v7 == 256;
        if ( v7 != 256 )
          break;
        v9 = __strex(0x10100u, v1);
        v8 = v9 == 0;
      }
      while ( v9 );
      __dmb(0xFu);
      if ( v8 )
        goto LABEL_23;
      if ( v7 == 1 )
        return v2;
      if ( v7 )
LABEL_23:
        syscall(240, v1, 0, 65792, 0);
    }
    else
    {
      syscall(240, v1, 0, v3, 0);
    }
  }
}

//----- (000923A8) --------------------------------------------------------
unsigned int *__fastcall _cxa_guard_abort(unsigned int *result, int a2, int a3, int a4)
{
  unsigned int v4; // r1

  __dmb(0xFu);
  do
    v4 = __ldrex(result);
  while ( __strex(0, result) );
  __dmb(0xFu);
  if ( v4 & 0x10000 )
    result = (unsigned int *)syscall(240, result, 1, 0x7FFFFFFF, a4);
  return result;
}

//----- (000923E8) --------------------------------------------------------
unsigned int *__fastcall _cxa_guard_release(unsigned int *result)
{
  unsigned int v1; // r1

  __dmb(0xFu);
  do
    v1 = __ldrex(result);
  while ( __strex(1u, result) );
  __dmb(0xFu);
  if ( v1 & 0x10000 )
    result = (unsigned int *)syscall(240, result, 1, 0x7FFFFFFF);
  return result;
}

//----- (00092428) --------------------------------------------------------
unsigned __int8 *__fastcall sub_92428(unsigned __int8 *result, _DWORD *a2)
{
  int v2; // r4
  unsigned int v3; // r3
  int v4; // r2
  int v5; // t1
  int v6; // r5

  v2 = 0;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v6 = (v5 & 0x7F) << v3;
    v3 += 7;
    v2 |= v6;
  }
  while ( v5 & 0x80 );
  if ( v3 <= 0x1F && v4 << 25 < 0 )
    v2 |= -1 << v3;
  *a2 = v2;
  return result;
}

//----- (00092458) --------------------------------------------------------
unsigned __int8 *__fastcall sub_92458(int a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  int v4; // r6
  unsigned __int8 *v5; // r8
  unsigned __int8 *result; // r0
  int v7; // r4
  unsigned __int8 *v8; // ST04_4
  int *v9; // ST00_4
  int v10; // r7
  char v11; // t1
  int v12; // r1
  _DWORD *v13; // r0
  int v14; // t1
  int v15; // [sp+Ch] [bp-1Ch]

  v4 = a1;
  v5 = a2;
  if ( a1 == 80 )
  {
    v13 = (_DWORD *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    v14 = *v13;
    result = (unsigned __int8 *)(v13 + 1);
    *a4 = v14;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        result = a3 + 4;
        v7 = *(_DWORD *)a3;
        break;
      case 1:
        v7 = 0;
        result = a3;
        v10 = 0;
        do
        {
          v11 = *result++;
          v12 = (v11 & 0x7F) << v10;
          v10 += 7;
          v7 |= v12;
        }
        while ( v11 & 0x80 );
        break;
      case 2:
        result = a3 + 2;
        v7 = *(unsigned __int16 *)a3;
        break;
      case 4:
      case 0xC:
        result = a3 + 8;
        v7 = *(_DWORD *)a3;
        break;
      case 9:
        v8 = a3;
        v9 = a4;
        result = sub_92428(a3, &v15);
        v7 = v15;
        a3 = v8;
        a4 = v9;
        break;
      case 0xA:
        result = a3 + 2;
        v7 = *(signed __int16 *)a3;
        break;
      default:
        abort();
        return result;
    }
    if ( v7 )
    {
      if ( (v4 & 0x70) != 16 )
        a3 = v5;
      v7 += (int)a3;
      if ( v4 << 24 < 0 )
        v7 = *(_DWORD *)v7;
    }
    *a4 = v7;
  }
  return result;
}

//----- (00092508) --------------------------------------------------------
int __fastcall __noreturn sub_92508(int a1)
{
  int v1; // r3

  if ( a1 == 255 )
    return 0;
  v1 = a1 & 0x70;
  if ( v1 == 32 )
    j__Unwind_GetTextRelBase();
  if ( (a1 & 0x70u) <= 0x20 )
  {
    if ( a1 & 0x70 && v1 != 16 )
LABEL_11:
      abort();
    return 0;
  }
  if ( v1 != 64 )
  {
    if ( v1 != 80 )
    {
      if ( v1 == 48 )
        j__Unwind_GetDataRelBase();
      goto LABEL_11;
    }
    return 0;
  }
  return j__Unwind_GetRegionStart();
}

//----- (00092554) --------------------------------------------------------
char *__fastcall sub_92554(int a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r5
  int v4; // r6
  unsigned __int8 *v5; // r4
  int v6; // r5
  int v7; // r3
  char *v8; // r0
  int v9; // r2
  int v10; // r3
  char v11; // t1
  int v12; // r4
  char v13; // r2
  int v14; // r4
  char *result; // r0
  int v16; // r3
  char v17; // t1
  int v18; // r5

  v3 = a2;
  v4 = a3;
  if ( a1 )
    a1 = Unwind_GetRegionStart();
  *(_DWORD *)v4 = a1;
  v5 = v3 + 1;
  v6 = *v3;
  if ( v6 != 255 )
    sub_92508(v6);
  *(_DWORD *)(v4 + 4) = a1;
  v7 = *v5;
  v8 = (char *)(v5 + 1);
  *(_BYTE *)(v4 + 20) = v7;
  if ( v7 == 255 )
  {
    *(_DWORD *)(v4 + 12) = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    *(_BYTE *)(v4 + 20) = -112;
    do
    {
      v11 = *v8++;
      v12 = (v11 & 0x7F) << v10;
      v10 += 7;
      v9 |= v12;
    }
    while ( v11 & 0x80 );
    *(_DWORD *)(v4 + 12) = &v8[v9];
  }
  v13 = *v8;
  v14 = 0;
  result = v8 + 1;
  v16 = 0;
  *(_BYTE *)(v4 + 21) = v13;
  do
  {
    v17 = *result++;
    v18 = (v17 & 0x7F) << v16;
    v16 += 7;
    v14 |= v18;
  }
  while ( v17 & 0x80 );
  *(_DWORD *)(v4 + 16) = &result[v14];
  return result;
}

//----- (000929FC) --------------------------------------------------------
int __fastcall _cxa_get_exception_ptr(int a1)
{
  return *(_DWORD *)(a1 + 36);
}

//----- (00092A00) --------------------------------------------------------
int __fastcall _cxa_begin_catch(int a1)
{
  int v1; // r4
  int *v2; // r0
  int v3; // r2
  int v4; // r3
  int result; // r0
  int v6; // r5
  int v7; // r5
  int v8; // r1
  int v9; // r0
  int v10; // r4

  v1 = a1;
  v2 = _cxa_get_globals();
  v3 = v1 - 32;
  v4 = *v2;
  if ( *(_BYTE *)v1 != 71
    || *(_BYTE *)(v1 + 1) != 78
    || *(_BYTE *)(v1 + 2) != 85
    || *(_BYTE *)(v1 + 3) != 67
    || *(_BYTE *)(v1 + 4) != 67
    || *(_BYTE *)(v1 + 5) != 43
    || *(_BYTE *)(v1 + 6) != 43
    || *(unsigned __int8 *)(v1 + 7) > 1u )
  {
    if ( v4 )
      std::terminate();
    *v2 = v3;
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)(v1 - 12);
    if ( v6 < 0 )
      v7 = 1 - v6;
    else
      v7 = v6 + 1;
    v8 = v2[1];
    *(_DWORD *)(v1 - 12) = v7;
    v2[1] = v8 - 1;
    if ( v3 != v4 )
    {
      *(_DWORD *)(v1 - 16) = v4;
      *v2 = v3;
    }
    v9 = v1;
    v10 = *(_DWORD *)(v1 + 36);
    Unwind_Complete(v9);
    result = v10;
  }
  return result;
}
// CF224: using guessed type int __fastcall Unwind_Complete(_DWORD);

//----- (00092A8C) --------------------------------------------------------
int _cxa_end_catch()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r2
  int result; // r0
  int v3; // r1
  int v4; // r1

  v0 = _cxa_get_globals_fast();
  v1 = v0;
  result = *v0;
  if ( result )
  {
    if ( *(_BYTE *)(result + 32) != 71
      || *(_BYTE *)(result + 33) != 78
      || *(_BYTE *)(result + 34) != 85
      || *(_BYTE *)(result + 35) != 67
      || *(_BYTE *)(result + 36) != 67
      || *(_BYTE *)(result + 37) != 43
      || *(_BYTE *)(result + 38) != 43
      || *(unsigned __int8 *)(result + 39) > 1u )
    {
      *v1 = 0;
      return j__Unwind_DeleteException(result + 32);
    }
    v3 = *(_DWORD *)(result + 20);
    if ( v3 < 0 )
    {
      v4 = v3 + 1;
      if ( !v4 )
        *v1 = *(_DWORD *)(result + 16);
      goto LABEL_14;
    }
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 == -1 )
        std::terminate();
LABEL_14:
      *(_DWORD *)(result + 20) = v4;
      return result;
    }
    *v1 = *(_DWORD *)(result + 16);
    result = j__Unwind_DeleteException(result + 32);
  }
  return result;
}

//----- (00092B18) --------------------------------------------------------
bool std::uncaught_exception(void)
{
  return _cxa_get_globals()[1] != 0;
}

//----- (00092B28) --------------------------------------------------------
void *__fastcall operator new(unsigned int a1)
{
  unsigned int v1; // r4
  void *result; // r0
  _DWORD *v3; // r0

  if ( a1 )
    v1 = a1;
  else
    v1 = 1;
  for ( result = malloc(v1); !result; result = malloc(v1) )
  {
    if ( !dword_2FD878 )
    {
      v3 = (_DWORD *)_cxa_allocate_exception(4);
      *v3 = &off_F0678;
      _cxa_throw((int)v3, (int)&`typeinfo for'std::bad_alloc, (int)std::bad_alloc::~bad_alloc);
    }
    ((void (*)(void))dword_2FD878)();
  }
  return result;
}
// F0660: using guessed type void *`typeinfo for'std::bad_alloc;
// F0678: using guessed type void *off_F0678;
// 2FD878: using guessed type int dword_2FD878;

//----- (00092B90) --------------------------------------------------------
bool __fastcall sub_92B90(_BYTE *a1)
{
  _BOOL4 result; // r0

  if ( *a1 != 71 || a1[1] != 78 || a1[2] != 85 || a1[3] != 67 || a1[4] != 67 || a1[5] != 43 || a1[6] != 43 )
    result = 0;
  else
    result = (unsigned __int8)a1[7] <= 1u;
  return result;
}

//----- (00092BCC) --------------------------------------------------------
void __fastcall __noreturn sub_92BCC(int a1)
{
  void (**v1)(void); // r4

  v1 = (void (**)(void))a1;
  if ( a1 )
  {
    _cxa_begin_catch(a1);
    if ( sub_92B90(v1) )
      __cxxabiv1::__terminate(*(v1 - 5));
  }
  std::terminate();
}

//----- (00092BEC) --------------------------------------------------------
void __fastcall __noreturn _cxa_call_unexpected(_BYTE *a1)
{
  _DWORD *v1; // r7
  void (*v2)(void); // r8
  int v3; // r0
  int v4; // r5
  int v5; // r6
  int v6; // r10
  int v7; // r7

  v1 = a1;
  if ( sub_92B90(a1) )
  {
    v2 = (void (*)(void))*(v1 - 6);
    v3 = (int)v1;
    v4 = *(v1 - 5);
    v5 = v1[10];
    v6 = v1[12];
    v7 = v1[13];
    _cxa_begin_catch(v3);
    __cxxabiv1::__unexpected(v2);
  }
  _cxa_begin_catch((int)v1);
  std::unexpected();
}

//----- (00092CF8) --------------------------------------------------------
int __fastcall sub_92CF8(int a1)
{
  int v1; // r4

  v1 = a1;
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      pthread_key_delete(*(_DWORD *)a1);
    *(_BYTE *)(v1 + 4) = 0;
  }
  return v1;
}

//----- (00092D14) --------------------------------------------------------
void __fastcall sub_92D14(int *a1)
{
  int *v1; // r5
  int v2; // r0
  int v3; // r4

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( v2 )
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)(v2 + 16);
        Unwind_DeleteException(v2 + 32);
        if ( !v3 )
          break;
        v2 = v3;
      }
    }
    j_free(v1);
  }
}

//----- (00092D3C) --------------------------------------------------------
void *_cxa_get_globals_fast()
{
  void *result; // r0

  if ( byte_2F895C )
    result = pthread_getspecific(dword_2F8958);
  else
    result = &unk_2F8960;
  return result;
}
// 2F8958: using guessed type int dword_2F8958;
// 2F895C: using guessed type char byte_2F895C;

//----- (00092D68) --------------------------------------------------------
_DWORD *_cxa_get_globals()
{
  _DWORD *v0; // r4
  _DWORD *v2; // r0

  v0 = &unk_2F8960;
  if ( byte_2F895C )
  {
    v0 = pthread_getspecific(dword_2F8958);
    if ( !v0 )
    {
      v2 = malloc(0xCu);
      v0 = v2;
      if ( !v2 || pthread_setspecific(dword_2F8958, v2) )
        std::terminate();
      *v0 = 0;
      v0[1] = 0;
      v0[2] = 0;
    }
  }
  return v0;
}
// 2F8958: using guessed type int dword_2F8958;
// 2F895C: using guessed type char byte_2F895C;

//----- (00092DC4) --------------------------------------------------------
__cxxabiv1::__si_class_type_info *__fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(__cxxabiv1::__si_class_type_info *this)
{
  __cxxabiv1::__si_class_type_info *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F0518;
  __cxxabiv1::__class_type_info::~__class_type_info(this);
  return v1;
}
// F0518: using guessed type void *off_F0518;

//----- (00092DE0) --------------------------------------------------------
__cxxabiv1::__si_class_type_info *__fastcall __cxxabiv1::__si_class_type_info::~__si_class_type_info(__cxxabiv1::__si_class_type_info *this)
{
  __cxxabiv1::__si_class_type_info *v1; // r4

  v1 = this;
  __cxxabiv1::__si_class_type_info::~__si_class_type_info(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00092DF4) --------------------------------------------------------
int __fastcall __cxxabiv1::__si_class_type_info::__do_find_public_src(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r6
  int result; // r0

  v5 = a1;
  if ( a5 == a3 && sub_C1FA8(a1, a4) )
    result = 6;
  else
    result = (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(v5 + 8) + 32))(*(_DWORD *)(v5 + 8));
  return result;
}

//----- (00092E28) --------------------------------------------------------
int __fastcall __cxxabiv1::__si_class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int v8; // r8
  int v9; // r7
  int v10; // r10
  int v11; // r11
  _BOOL4 v12; // r4
  signed int v13; // r6
  int result; // r0

  v8 = a2;
  v9 = a4;
  v10 = a3;
  v11 = a1;
  v12 = sub_C1FA8(a1, a4);
  if ( !v12 )
  {
    if ( a5 != a7 || !sub_C1FA8(v11, a6) )
      return (*(int (__cdecl **)(_DWORD, int, int, int))(**(_DWORD **)(v11 + 8) + 28))(
               *(_DWORD *)(v11 + 8),
               v8,
               v10,
               v9);
    a8[2] = v10;
    return v12;
  }
  *a8 = a5;
  a8[1] = v10;
  if ( v8 < 0 )
  {
    if ( v8 != -2 )
      return 0;
    v12 = 0;
    a8[3] = 1;
    return v12;
  }
  if ( a7 == a5 + v8 )
    v13 = 6;
  else
    v13 = 1;
  result = 0;
  a8[3] = v13;
  return result;
}

//----- (00092EB8) --------------------------------------------------------
int __fastcall __cxxabiv1::__si_class_type_info::__do_upcast(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r7
  int result; // r0

  v4 = a1;
  result = __cxxabiv1::__class_type_info::__do_upcast(a1, a2, a3, a4);
  if ( !result )
    result = (*(int (**)(void))(**(_DWORD **)(v4 + 8) + 24))();
  return result;
}

//----- (00092EDC) --------------------------------------------------------
signed int __fastcall __cxxabiv1::__class_type_info::__do_upcast(int a1, int a2, int *a3)
{
  int *v3; // r5
  void (*v4)(void); // r6
  int v5; // r2
  int v6; // r3
  bool v7; // zf
  signed int result; // r0
  int v9; // [sp+0h] [bp-28h]
  int v10; // [sp+4h] [bp-24h]
  int v11; // [sp+8h] [bp-20h]
  int v12; // [sp+Ch] [bp-1Ch]

  v3 = a3;
  v4 = *(void (**)(void))(*(_DWORD *)a1 + 24);
  v5 = *a3;
  v9 = 0;
  v10 = 0;
  v12 = 0;
  v11 = 16;
  v4();
  v6 = v10 & 6;
  v7 = v6 == 6;
  if ( v6 == 6 )
  {
    v6 = v9;
    result = 1;
  }
  else
  {
    result = 0;
  }
  if ( v7 )
    *v3 = v6;
  return result;
}

//----- (00092F10) --------------------------------------------------------
signed int __fastcall __cxxabiv1::__class_type_info::__do_find_public_src(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // r0

  if ( a5 == a3 )
    result = 6;
  else
    result = 1;
  return result;
}

//----- (00092F1C) --------------------------------------------------------
__cxxabiv1::__class_type_info *__fastcall __cxxabiv1::__class_type_info::~__class_type_info(__cxxabiv1::__class_type_info *this)
{
  __cxxabiv1::__class_type_info *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F0558;
  sub_C1F74(this);
  return v1;
}
// F0558: using guessed type void *off_F0558;

//----- (00092F38) --------------------------------------------------------
__cxxabiv1::__class_type_info *__fastcall __cxxabiv1::__class_type_info::~__class_type_info(__cxxabiv1::__class_type_info *this)
{
  __cxxabiv1::__class_type_info *v1; // r4

  v1 = this;
  __cxxabiv1::__class_type_info::~__class_type_info(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00092F4C) --------------------------------------------------------
bool __fastcall __cxxabiv1::__class_type_info::__do_upcast(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r5
  _DWORD *v5; // r4
  _BOOL4 result; // r0

  v4 = a3;
  v5 = a4;
  result = sub_C1FA8(a1, a2);
  if ( result )
  {
    *v5 = v4;
    v5[3] = 8;
    v5[1] = 6;
  }
  return result;
}

//----- (00092F64) --------------------------------------------------------
int __fastcall __cxxabiv1::__class_type_info::__do_catch(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r6
  unsigned int v5; // r4
  int v6; // r7
  int v7; // r5
  int result; // r0

  v4 = a3;
  v5 = a4;
  v6 = a1;
  v7 = a2;
  result = sub_C1FA8(a1, a2);
  if ( !result && v5 <= 3 )
    result = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v7 + 20))(v7, v6, v4);
  return result;
}

//----- (00092F88) --------------------------------------------------------
int __fastcall __cxxabiv1::__class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  int v8; // r7
  int v9; // r6
  int v11; // ST04_4
  _BOOL4 v12; // r0

  v8 = a3;
  v9 = a1;
  if ( a5 == a7 && (v11 = a4, v12 = sub_C1FA8(a1, a6), a4 = v11, v12) )
  {
    a8[2] = v8;
  }
  else if ( sub_C1FA8(v9, a4) )
  {
    *a8 = a5;
    a8[1] = v8;
    a8[3] = 1;
  }
  return 0;
}

//----- (0009300C) --------------------------------------------------------
void __fastcall __noreturn _cxa_throw(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r8
  int v5; // r9
  _DWORD *v6; // r0
  void *v7; // r2
  void *v8; // r3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = _cxa_get_globals();
  v7 = __cxxabiv1::__unexpected_handler;
  v8 = __cxxabiv1::__terminate_handler;
  ++v6[1];
  *(_DWORD *)(v3 - 120) = v4;
  *(_DWORD *)(v3 - 128) = 1;
  *(_DWORD *)(v3 - 112) = v7;
  *(_DWORD *)(v3 - 108) = v8;
  *(_BYTE *)(v3 - 88) = 71;
  *(_DWORD *)(v3 - 80) = sub_92FC8;
  *(_BYTE *)(v3 - 85) = 67;
  *(_BYTE *)(v3 - 84) = 67;
  *(_BYTE *)(v3 - 83) = 43;
  *(_BYTE *)(v3 - 82) = 43;
  *(_DWORD *)(v3 - 116) = v5;
  *(_BYTE *)(v3 - 87) = 78;
  *(_BYTE *)(v3 - 86) = 85;
  *(_BYTE *)(v3 - 81) = 0;
  __Unwind_RaiseException(v3 - 88, (int)sub_92FC8 + 1, 67, 43);
  _cxa_begin_catch(v3 - 88);
  std::terminate();
}
// 92FC8: using guessed type int sub_92FC8();
// F3C4C: using guessed type void *__cxxabiv1::__terminate_handler;
// F3C50: using guessed type void *__cxxabiv1::__unexpected_handler;

//----- (000930A0) --------------------------------------------------------
void __noreturn _cxa_rethrow()
{
  int *v0; // r0
  int v1; // r1
  int v2; // r3
  int v3; // r2

  v0 = _cxa_get_globals();
  v2 = *v0;
  ++v0[1];
  if ( v2 )
  {
    if ( *(_BYTE *)(v2 + 32) != 71
      || *(_BYTE *)(v2 + 33) != 78
      || *(_BYTE *)(v2 + 34) != 85
      || *(_BYTE *)(v2 + 35) != 67
      || *(_BYTE *)(v2 + 36) != 67
      || *(_BYTE *)(v2 + 37) != 43
      || *(_BYTE *)(v2 + 38) != 43
      || *(unsigned __int8 *)(v2 + 39) > 1u )
    {
      v3 = 0;
      *v0 = 0;
    }
    else
    {
      v3 = -*(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v3;
    }
    __Unwind_Resume_or_Rethrow(v2 + 32, v1, v3, v2);
  }
  std::terminate();
}

//----- (00093110) --------------------------------------------------------
int __fastcall std::exception::~exception(int result)
{
  *(_DWORD *)result = &off_F0608;
  return result;
}
// F0608: using guessed type void *;

//----- (00093120) --------------------------------------------------------
std::bad_exception *__fastcall std::bad_exception::~bad_exception(std::bad_exception *this)
{
  std::bad_exception *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F05A8;
  std::exception::~exception((int)this);
  return v1;
}
// F05A8: using guessed type void *;

//----- (0009313C) --------------------------------------------------------
int __fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(int result)
{
  *(_DWORD *)result = &off_F05D8;
  return result;
}
// F05D8: using guessed type void *;

//----- (0009314C) --------------------------------------------------------
int __fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(int result)
{
  *(_DWORD *)result = &off_F05F0;
  return result;
}
// F05F0: using guessed type void *;

//----- (0009315C) --------------------------------------------------------
const char *__fastcall std::exception::what(std::exception *this)
{
  return "std::exception";
}

//----- (00093168) --------------------------------------------------------
const char *__fastcall std::bad_exception::what(std::bad_exception *this)
{
  return "std::bad_exception";
}

//----- (00093174) --------------------------------------------------------
std::exception *__fastcall std::exception::~exception(std::exception *this)
{
  std::exception *v1; // r4

  v1 = this;
  std::exception::~exception((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (00093188) --------------------------------------------------------
std::bad_exception *__fastcall std::bad_exception::~bad_exception(std::bad_exception *this)
{
  std::bad_exception *v1; // r4

  v1 = this;
  std::bad_exception::~bad_exception(this);
  operator delete((void *)v1);
  return v1;
}

//----- (0009319C) --------------------------------------------------------
__cxxabiv1::__forced_unwind *__fastcall __cxxabiv1::__forced_unwind::~__forced_unwind(__cxxabiv1::__forced_unwind *this)
{
  __cxxabiv1::__forced_unwind *v1; // r4

  v1 = this;
  __cxxabiv1::__forced_unwind::~__forced_unwind((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (000931B0) --------------------------------------------------------
__cxxabiv1::__foreign_exception *__fastcall __cxxabiv1::__foreign_exception::~__foreign_exception(__cxxabiv1::__foreign_exception *this)
{
  __cxxabiv1::__foreign_exception *v1; // r4

  v1 = this;
  __cxxabiv1::__foreign_exception::~__foreign_exception((int)this);
  operator delete((void *)v1);
  return v1;
}

//----- (000931C4) --------------------------------------------------------
void __fastcall operator delete(void *ptr)
{
  if ( ptr )
    j_free(ptr);
}

//----- (000931CC) --------------------------------------------------------
void __fastcall __noreturn _cxa_end_cleanup(int a1, int a2, int a3, int a4)
{
  int v4; // r0
  int v5; // [sp+0h] [bp-10h]
  int v6; // [sp+4h] [bp-Ch]
  int v7; // [sp+8h] [bp-8h]

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v4 = _gnu_end_cleanup();
  __Unwind_Resume(v4, v5, v6, v7);
}

//----- (000931D8) --------------------------------------------------------
int __fastcall _cxa_type_match(_BYTE *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r5
  _DWORD *v5; // r6
  void **v6; // r4
  signed int v7; // r8
  int result; // r0
  unsigned int v9; // r3
  int *v10; // r0
  int *v11; // [sp+4h] [bp-1Ch]

  v4 = a2;
  v5 = a4;
  if ( *a1 != 71 || a1[1] != 78 || a1[2] != 85 || a1[3] != 67 )
    goto LABEL_26;
  if ( a1[4] == 70 && a1[5] == 79 && a1[6] == 82 && !a1[7] )
  {
    v11 = (int *)(unsigned __int8)a1[7];
    v6 = &`typeinfo for'__cxxabiv1::__forced_unwind;
    goto LABEL_3;
  }
  if ( a1[4] != 67 || a1[5] != 43 || a1[6] != 43 || (v9 = (unsigned __int8)a1[7], v9 > 1) )
  {
LABEL_26:
    v11 = 0;
    v6 = &`typeinfo for'__cxxabiv1::__foreign_exception;
    goto LABEL_3;
  }
  if ( v9 == 1 )
  {
    v10 = (int *)*((_DWORD *)a1 - 8);
    v6 = (void **)*(v10 - 30);
  }
  else
  {
    v6 = (void **)*((_DWORD *)a1 - 8);
    v10 = (int *)(a1 + 88);
  }
  v11 = v10;
LABEL_3:
  v7 = 1;
  if ( (*((int (__cdecl **)())*v6 + 2))() )
  {
    v7 = 2;
    v11 = (int *)*v11;
  }
  result = (*(int (__fastcall **)(int, void **, int **, signed int))(*(_DWORD *)v4 + 16))(v4, v6, &v11, 1);
  if ( result )
  {
    result = v7;
    *v5 = v11;
  }
  return result;
}
// F058C: using guessed type void *`typeinfo for'__cxxabiv1::__forced_unwind;
// F05C4: using guessed type void *`typeinfo for'__cxxabiv1::__foreign_exception;

//----- (00093290) --------------------------------------------------------
signed int __fastcall _cxa_begin_cleanup(_BYTE *a1)
{
  _BYTE *v1; // r4
  _DWORD *v2; // r0
  int v3; // r2
  int v5; // r3

  v1 = a1;
  v2 = _cxa_get_globals();
  v3 = (int)(v1 - 32);
  if ( *v1 != 71
    || v1[1] != 78
    || v1[2] != 85
    || v1[3] != 67
    || v1[4] != 67
    || v1[5] != 43
    || v1[6] != 43
    || (unsigned __int8)v1[7] > 1u )
  {
    if ( v2[2] )
      std::terminate();
    v2[2] = v3;
    return 1;
  }
  v5 = *((_DWORD *)v1 - 1) + 1;
  *((_DWORD *)v1 - 1) = v5;
  if ( v5 != 1 )
    return 1;
  *((_DWORD *)v1 - 2) = v2[2];
  v2[2] = v3;
  return 1;
}

//----- (000932F4) --------------------------------------------------------
int _gnu_end_cleanup()
{
  _DWORD *v0; // r0
  int v1; // r3
  int result; // r0
  int v3; // r2

  v0 = _cxa_get_globals();
  v1 = v0[2];
  if ( !v1 )
    std::terminate();
  if ( *(_BYTE *)(v1 + 32) != 71
    || *(_BYTE *)(v1 + 33) != 78
    || *(_BYTE *)(v1 + 34) != 85
    || *(_BYTE *)(v1 + 35) != 67
    || *(_BYTE *)(v1 + 36) != 67
    || *(_BYTE *)(v1 + 37) != 43
    || *(_BYTE *)(v1 + 38) != 43
    || *(unsigned __int8 *)(v1 + 39) > 1u )
  {
    v0[2] = 0;
    return v1 + 32;
  }
  v3 = *(_DWORD *)(v1 + 28) - 1;
  *(_DWORD *)(v1 + 28) = v3;
  if ( v3 )
    return v1 + 32;
  v0[2] = *(_DWORD *)(v1 + 24);
  result = v1 + 32;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

//----- (00093364) --------------------------------------------------------
void __fastcall __noreturn __cxxabiv1::__terminate(void (*a1)(void))
{
  ((void (__cdecl *)(void (*)(void)))a1)(a1);
  abort();
}

//----- (0009338C) --------------------------------------------------------
void __noreturn std::terminate(void)
{
  __cxxabiv1::__terminate((void (*)(void))__cxxabiv1::__terminate_handler);
}
// F3C4C: using guessed type void *__cxxabiv1::__terminate_handler;

//----- (000933A0) --------------------------------------------------------
void __fastcall __noreturn __cxxabiv1::__unexpected(void (*a1)(void))
{
  ((void (__cdecl *)(void (*)(void)))a1)(a1);
  std::terminate();
}

//----- (000933A8) --------------------------------------------------------
void __noreturn std::unexpected(void)
{
  __cxxabiv1::__unexpected((void (*)(void))__cxxabiv1::__unexpected_handler);
}
// F3C50: using guessed type void *__cxxabiv1::__unexpected_handler;

//----- (000933BC) --------------------------------------------------------
void *__fastcall std::set_terminate(void (*a1)(void))
{
  void *v1; // r2

  v1 = __cxxabiv1::__terminate_handler;
  __cxxabiv1::__terminate_handler = a1;
  return v1;
}
// F3C4C: using guessed type void *__cxxabiv1::__terminate_handler;

//----- (000933D0) --------------------------------------------------------
void *__fastcall std::set_unexpected(void (*a1)(void))
{
  void *v1; // r2

  v1 = __cxxabiv1::__unexpected_handler;
  __cxxabiv1::__unexpected_handler = a1;
  return v1;
}
// F3C50: using guessed type void *__cxxabiv1::__unexpected_handler;

//----- (000933E4) --------------------------------------------------------
void *__fastcall operator new[](unsigned int a1)
{
  return operator new(a1);
}

//----- (000933F8) --------------------------------------------------------
const char *sub_933F8()
{
  return "__gnu_cxx::__concurrence_lock_error";
}

//----- (00093404) --------------------------------------------------------
const char *sub_93404()
{
  return "__gnu_cxx::__concurrence_unlock_error";
}

//----- (00093410) --------------------------------------------------------
_DWORD *__fastcall sub_93410(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0650;
  std::exception::~exception((int)a1);
  return v1;
}
// F0650: using guessed type void *off_F0650;

//----- (00093428) --------------------------------------------------------
_DWORD *__fastcall sub_93428(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0638;
  std::exception::~exception((int)a1);
  return v1;
}
// F0638: using guessed type void *off_F0638;

//----- (00093440) --------------------------------------------------------
void *__fastcall sub_93440(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0650;
  std::exception::~exception((int)a1);
  operator delete(v1);
  return v1;
}
// F0650: using guessed type void *off_F0650;

//----- (00093460) --------------------------------------------------------
void *__fastcall sub_93460(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0638;
  std::exception::~exception((int)a1);
  operator delete(v1);
  return v1;
}
// F0638: using guessed type void *off_F0638;

//----- (00093480) --------------------------------------------------------
void __noreturn sub_93480()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F0638;
  _cxa_throw((int)v0, (int)&`typeinfo for'__gnu_cxx::__concurrence_lock_error, (int)sub_93428);
}
// F0618: using guessed type int *`typeinfo for'__gnu_cxx::__concurrence_lock_error;
// F0638: using guessed type void *off_F0638;

//----- (000934A8) --------------------------------------------------------
void __noreturn sub_934A8()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F0650;
  _cxa_throw((int)v0, (int)&`typeinfo for'__gnu_cxx::__concurrence_unlock_error, (int)sub_93410);
}
// F0624: using guessed type int *`typeinfo for'__gnu_cxx::__concurrence_unlock_error;
// F0650: using guessed type void *off_F0650;

//----- (000934D0) --------------------------------------------------------
int __fastcall _cxa_allocate_exception(int a1)
{
  unsigned int v1; // r5
  char *v2; // r4
  int v4; // r3
  unsigned int v5; // r2

  v1 = a1 + 128;
  v2 = (char *)malloc(a1 + 128);
  if ( !v2 )
  {
    if ( pthread_mutex_lock((pthread_mutex_t *)&dword_2F9870) )
      sub_93480();
    if ( v1 > 0x200 )
LABEL_6:
      std::terminate();
    v4 = 0;
    v5 = dword_2F9874;
    while ( v5 & 1 )
    {
      ++v4;
      v5 >>= 1;
      if ( v4 == 32 )
        goto LABEL_6;
    }
    v2 = (char *)&unk_2F9878 + 512 * v4;
    dword_2F9874 |= 1 << v4;
    if ( pthread_mutex_unlock((pthread_mutex_t *)&dword_2F9870) )
      sub_934A8();
  }
  memset(v2, 0, 0x80u);
  return (int)(v2 + 128);
}
// 2F9870: using guessed type int dword_2F9870;
// 2F9874: using guessed type int dword_2F9874;

//----- (00093568) --------------------------------------------------------
void __fastcall _cxa_free_exception(unsigned int a1)
{
  unsigned int v1; // r4

  if ( a1 >= (unsigned int)&unk_2F9878 && a1 < (unsigned int)&dword_2FD878 )
  {
    v1 = (a1 - (unsigned int)&unk_2F9878) >> 9;
    if ( pthread_mutex_lock((pthread_mutex_t *)&dword_2F9870) )
      sub_93480();
    dword_2F9874 &= ~(1 << v1);
    if ( pthread_mutex_unlock((pthread_mutex_t *)&dword_2F9870) )
      sub_934A8();
  }
  else
  {
    j_free((void *)(a1 - 128));
  }
}
// 2F9870: using guessed type int dword_2F9870;
// 2F9874: using guessed type int dword_2F9874;
// 2FD878: using guessed type int dword_2FD878;

//----- (000935D8) --------------------------------------------------------
char *_cxa_allocate_dependent_exception()
{
  char *v0; // r4
  int v2; // r0
  unsigned int v3; // r3

  v0 = (char *)malloc(0x78u);
  if ( !v0 )
  {
    v2 = pthread_mutex_lock((pthread_mutex_t *)&dword_2F9870);
    if ( v2 )
      sub_93480();
    v3 = dword_2F896C;
    while ( v3 & 1 )
    {
      ++v2;
      v3 >>= 1;
      if ( v2 == 32 )
        std::terminate();
    }
    dword_2F896C |= 1 << v2;
    v0 = (char *)&unk_2F8970 + 120 * v2;
    if ( pthread_mutex_unlock((pthread_mutex_t *)&dword_2F9870) )
      sub_934A8();
  }
  memset(v0, 0, 0x78u);
  return v0;
}
// 2F896C: using guessed type int dword_2F896C;
// 2F9870: using guessed type int dword_2F9870;

//----- (00093664) --------------------------------------------------------
void __fastcall _cxa_free_dependent_exception(int *a1)
{
  unsigned int v1; // r4

  if ( a1 >= (int *)&unk_2F8970 && a1 < &dword_2F9870 )
  {
    v1 = ((char *)a1 - (char *)&unk_2F8970) / 0x78u;
    if ( pthread_mutex_lock((pthread_mutex_t *)&dword_2F9870) )
      sub_93480();
    dword_2F896C &= ~(1 << v1);
    if ( pthread_mutex_unlock((pthread_mutex_t *)&dword_2F9870) )
      sub_934A8();
  }
  else
  {
    j_free(a1);
  }
}
// 2F896C: using guessed type int dword_2F896C;
// 2F9870: using guessed type int dword_2F9870;

//----- (000936DC) --------------------------------------------------------
int sub_936DC()
{
  return j___cxa_atexit();
}

//----- (000936E8) --------------------------------------------------------
int __fastcall std::set_new_handler(void (*a1)(void))
{
  int v1; // r2

  v1 = dword_2FD878;
  dword_2FD878 = (int)a1;
  return v1;
}
// 2FD878: using guessed type int dword_2FD878;

//----- (000936F8) --------------------------------------------------------
void __noreturn _cxa_pure_virtual()
{
  write(2, "pure virtual method called\n", 0x1Bu);
  std::terminate();
}

//----- (00093710) --------------------------------------------------------
void __noreturn _cxa_deleted_virtual()
{
  write(2, "deleted virtual method called\n", 0x1Eu);
  std::terminate();
}

//----- (00093728) --------------------------------------------------------
const char *__fastcall std::bad_alloc::what(std::bad_alloc *this)
{
  return "std::bad_alloc";
}

//----- (00093734) --------------------------------------------------------
std::bad_alloc *__fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  std::bad_alloc *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F0678;
  std::exception::~exception((int)this);
  return v1;
}
// F0678: using guessed type void *off_F0678;

//----- (00093750) --------------------------------------------------------
std::bad_alloc *__fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  std::bad_alloc *v1; // r4

  v1 = this;
  std::bad_alloc::~bad_alloc(this);
  operator delete((void *)v1);
  return v1;
}

//----- (00093764) --------------------------------------------------------
int __fastcall sub_93764(int result)
{
  int v1; // r11
  unsigned int v2; // r8
  unsigned int v3; // r2

  v1 = result;
  __dmb(0xFu);
  do
    v2 = __ldrex((unsigned int *)&unk_2FE060);
  while ( __strex(v2 + 1, (unsigned int *)&unk_2FE060) );
  __dmb(0xFu);
  if ( !v2 )
  {
    byte_F3C48 = 1;
    dword_2FE040 = 0;
    dword_2FE038 = (int)&off_F0818;
    *(_DWORD *)algn_2FE03C = 0;
    dword_2FE044 = 0;
    dword_2FE048 = 0;
    dword_2FE04C = 0;
    dword_2FE050 = 0;
    sub_A93A8(algn_2FE054);
    dword_2FE038 = (int)&off_F15E8;
    dword_2FE05C = -1;
    dword_2FE058 = (int)&_sF + 84;
    dword_2FDEF4 = (int)&off_F0818;
    unk_2FDEF8 = 0;
    dword_2FDEFC = 0;
    dword_2FDF00 = 0;
    dword_2FDF04 = 0;
    dword_2FDF08 = 0;
    dword_2FDF0C = 0;
    sub_A93A8(&unk_2FDF10);
    dword_2FDF14 = (int)&_sF;
    dword_2FDEF4 = (int)&off_F15E8;
    dword_2FDF18 = -1;
    dword_2FDD48 = (int)&off_F0818;
    *(_DWORD *)algn_2FDD4C = 0;
    dword_2FDD50 = 0;
    dword_2FDD54 = 0;
    dword_2FDD58 = 0;
    dword_2FDD5C = 0;
    dword_2FDD60 = 0;
    sub_A93A8(algn_2FDD64);
    dword_2FDD48 = (int)&off_F15E8;
    dword_2FDD6C = -1;
    dword_2FDD68 = (int)&_sF + 168;
    sub_95C00(dword_2FDDDC);
    dword_2FDE4C = 0;
    byte_2FDE50 = 0;
    byte_2FDE51 = 0;
    dword_2FDE54 = 0;
    dword_2FDE58 = 0;
    dword_2FDE5C = 0;
    dword_2FDE60 = 0;
    unk_2FDDD8 = &off_F1DB4;
    dword_2FDDDC[0] = (unsigned int *)&off_F1DC8;
    sub_941F4(dword_2FDDDC, (unsigned int)&dword_2FE038);
    sub_95C00(&dword_2FDE6C);
    dword_2FDEDC = 0;
    byte_2FDEE0 = 0;
    byte_2FDEE1 = 0;
    dword_2FDEE4 = 0;
    dword_2FDEE8 = 0;
    dword_2FDEEC = 0;
    dword_2FDEF0 = 0;
    dword_2FDE68 = 0;
    dword_2FDE6C = (int)&off_F0F90;
    dword_2FDE64 = (int)&off_F0F7C;
    sub_941F4((unsigned int **)&dword_2FDE6C, (unsigned int)&dword_2FDEF4);
    sub_95C00(dword_2FD8A8);
    unk_2FD8A4 = &off_F1DB4;
    dword_2FD8A8[0] = (unsigned int *)&off_F1DC8;
    dword_2FD918 = 0;
    byte_2FD91C = 0;
    byte_2FD91D = 0;
    dword_2FD920 = 0;
    dword_2FD924 = 0;
    dword_2FD928 = 0;
    dword_2FD92C = 0;
    sub_941F4(dword_2FD8A8, (unsigned int)&dword_2FDD48);
    sub_95C00(dword_2FDF20);
    unk_2FDF1C = &off_F1DB4;
    dword_2FDF20[0] = (unsigned int *)&off_F1DC8;
    dword_2FDF90 = 0;
    byte_2FDF94 = 0;
    byte_2FDF95 = 0;
    dword_2FDF98 = 0;
    dword_2FDF9C = 0;
    dword_2FDFA0 = 0;
    dword_2FDFA4 = 0;
    sub_941F4(dword_2FDF20, (unsigned int)&dword_2FDD48);
    dword_2FD918 = (int)&unk_2FDDD8;
    dword_2FDEDC = (int)&unk_2FDDD8;
    dword_2FD8B4 |= 0x2000u;
    dword_2FDC2C = 0;
    dword_2FDC24 = (int)&off_F0858;
    unk_2FDC28 = 0;
    dword_2FDC30 = 0;
    dword_2FDC34 = 0;
    dword_2FDC38 = 0;
    dword_2FDC3C = 0;
    sub_A93A8(&unk_2FDC40);
    dword_2FDC44 = (int)&_sF + 84;
    dword_2FDC48 = -1;
    dword_2FDC24 = (int)&off_F1628;
    dword_2FD87C = (int)&off_F0858;
    unk_2FD880 = 0;
    dword_2FD884 = 0;
    dword_2FD888 = 0;
    dword_2FD88C = 0;
    dword_2FD890 = 0;
    dword_2FD894 = 0;
    sub_A93A8(&unk_2FD898);
    dword_2FD87C = (int)&off_F1628;
    dword_2FD89C = (int)&_sF;
    dword_2FD8A0 = -1;
    dword_2FD930 = (int)&off_F0858;
    *(_DWORD *)algn_2FD934 = 0;
    dword_2FD938 = 0;
    dword_2FD93C = 0;
    dword_2FD940 = 0;
    dword_2FD944 = 0;
    dword_2FD948 = 0;
    sub_A93A8(algn_2FD94C);
    dword_2FD954 = -1;
    dword_2FD930 = (int)&off_F1628;
    dword_2FD950 = (int)&_sF + 168;
    sub_95C00(dword_2FD95C);
    dword_2FD9CC = 0;
    dword_2FD9D0 = 0;
    byte_2FD9D4 = 0;
    dword_2FD9D8 = 0;
    dword_2FD9DC = 0;
    dword_2FD9E0 = 0;
    dword_2FD9E4 = 0;
    unk_2FD958 = &off_F1DE4;
    dword_2FD95C[0] = (unsigned int *)&off_F1DF8;
    sub_94624(dword_2FD95C, (unsigned int)&dword_2FDC24);
    sub_95C00(&dword_2FDCBC);
    dword_2FDD2C = 0;
    dword_2FDD30 = 0;
    byte_2FDD34 = 0;
    dword_2FDD38 = 0;
    dword_2FDD3C = 0;
    dword_2FDD40 = 0;
    dword_2FDD44 = 0;
    dword_2FDCB8 = 0;
    dword_2FDCBC = (int)&off_F0FC0;
    dword_2FDCB4 = (int)&off_F0FAC;
    sub_94624((unsigned int **)&dword_2FDCBC, (unsigned int)&dword_2FD87C);
    sub_95C00(dword_2FDFAC);
    unk_2FDFA8 = &off_F1DE4;
    dword_2FDFAC[0] = (unsigned int *)&off_F1DF8;
    dword_2FE01C = 0;
    dword_2FE020 = 0;
    byte_2FE024 = 0;
    dword_2FE028 = 0;
    dword_2FE02C = 0;
    dword_2FE030 = 0;
    dword_2FE034 = 0;
    sub_94624(dword_2FDFAC, (unsigned int)&dword_2FD930);
    sub_95C00(dword_2FDB2C);
    unk_2FDB28 = &off_F1DE4;
    dword_2FDB2C[0] = (unsigned int *)&off_F1DF8;
    dword_2FDB9C = 0;
    dword_2FDBA0 = 0;
    byte_2FDBA4 = 0;
    dword_2FDBA8 = 0;
    dword_2FDBAC = 0;
    dword_2FDBB0 = 0;
    dword_2FDBB4 = 0;
    sub_94624(dword_2FDB2C, (unsigned int)&dword_2FD930);
    dword_2FDD2C = (int)&unk_2FD958;
    dword_2FE01C = (int)&unk_2FD958;
    dword_2FDFB8 |= 0x2000u;
    __dmb(0xFu);
    do
      v3 = __ldrex((unsigned int *)&unk_2FE060);
    while ( __strex(v3 + 1, (unsigned int *)&unk_2FE060) );
    result = v1;
    __dmb(0xFu);
  }
  return result;
}
// 78: using guessed type int dword_78;
// 7C: using guessed type int;
// F0818: using guessed type void *;
// F0858: using guessed type void *;
// F0F7C: using guessed type void *off_F0F7C;
// F0F90: using guessed type void *off_F0F90;
// F0FAC: using guessed type void *off_F0FAC;
// F0FC0: using guessed type void *off_F0FC0;
// F15E8: using guessed type void *;
// F1628: using guessed type void *;
// F1DB4: using guessed type void *off_F1DB4;
// F1DC8: using guessed type void *off_F1DC8;
// F1DE4: using guessed type void *off_F1DE4;
// F1DF8: using guessed type void *off_F1DF8;
// F3C48: using guessed type char byte_F3C48;
// 2FD87C: using guessed type int dword_2FD87C;
// 2FD884: using guessed type int dword_2FD884;
// 2FD888: using guessed type int dword_2FD888;
// 2FD88C: using guessed type int dword_2FD88C;
// 2FD890: using guessed type int dword_2FD890;
// 2FD894: using guessed type int dword_2FD894;
// 2FD89C: using guessed type int dword_2FD89C;
// 2FD8A0: using guessed type int dword_2FD8A0;
// 2FD8B4: using guessed type int dword_2FD8B4;
// 2FD918: using guessed type int dword_2FD918;
// 2FD91C: using guessed type char byte_2FD91C;
// 2FD91D: using guessed type char byte_2FD91D;
// 2FD920: using guessed type int dword_2FD920;
// 2FD924: using guessed type int dword_2FD924;
// 2FD928: using guessed type int dword_2FD928;
// 2FD92C: using guessed type int dword_2FD92C;
// 2FD930: using guessed type int dword_2FD930;
// 2FD938: using guessed type int dword_2FD938;
// 2FD93C: using guessed type int dword_2FD93C;
// 2FD940: using guessed type int dword_2FD940;
// 2FD944: using guessed type int dword_2FD944;
// 2FD948: using guessed type int dword_2FD948;
// 2FD950: using guessed type int dword_2FD950;
// 2FD954: using guessed type int dword_2FD954;
// 2FD9CC: using guessed type int dword_2FD9CC;
// 2FD9D0: using guessed type int dword_2FD9D0;
// 2FD9D4: using guessed type char byte_2FD9D4;
// 2FD9D8: using guessed type int dword_2FD9D8;
// 2FD9DC: using guessed type int dword_2FD9DC;
// 2FD9E0: using guessed type int dword_2FD9E0;
// 2FD9E4: using guessed type int dword_2FD9E4;
// 2FDB9C: using guessed type int dword_2FDB9C;
// 2FDBA0: using guessed type int dword_2FDBA0;
// 2FDBA4: using guessed type char byte_2FDBA4;
// 2FDBA8: using guessed type int dword_2FDBA8;
// 2FDBAC: using guessed type int dword_2FDBAC;
// 2FDBB0: using guessed type int dword_2FDBB0;
// 2FDBB4: using guessed type int dword_2FDBB4;
// 2FDC24: using guessed type int dword_2FDC24;
// 2FDC2C: using guessed type int dword_2FDC2C;
// 2FDC30: using guessed type int dword_2FDC30;
// 2FDC34: using guessed type int dword_2FDC34;
// 2FDC38: using guessed type int dword_2FDC38;
// 2FDC3C: using guessed type int dword_2FDC3C;
// 2FDC44: using guessed type int dword_2FDC44;
// 2FDC48: using guessed type int dword_2FDC48;
// 2FDCB4: using guessed type int dword_2FDCB4;
// 2FDCB8: using guessed type int dword_2FDCB8;
// 2FDCBC: using guessed type int dword_2FDCBC;
// 2FDD2C: using guessed type int dword_2FDD2C;
// 2FDD30: using guessed type int dword_2FDD30;
// 2FDD34: using guessed type char byte_2FDD34;
// 2FDD38: using guessed type int dword_2FDD38;
// 2FDD3C: using guessed type int dword_2FDD3C;
// 2FDD40: using guessed type int dword_2FDD40;
// 2FDD44: using guessed type int dword_2FDD44;
// 2FDD48: using guessed type int dword_2FDD48;
// 2FDD50: using guessed type int dword_2FDD50;
// 2FDD54: using guessed type int dword_2FDD54;
// 2FDD58: using guessed type int dword_2FDD58;
// 2FDD5C: using guessed type int dword_2FDD5C;
// 2FDD60: using guessed type int dword_2FDD60;
// 2FDD68: using guessed type int dword_2FDD68;
// 2FDD6C: using guessed type int dword_2FDD6C;
// 2FDE4C: using guessed type int dword_2FDE4C;
// 2FDE50: using guessed type char byte_2FDE50;
// 2FDE51: using guessed type char byte_2FDE51;
// 2FDE54: using guessed type int dword_2FDE54;
// 2FDE58: using guessed type int dword_2FDE58;
// 2FDE5C: using guessed type int dword_2FDE5C;
// 2FDE60: using guessed type int dword_2FDE60;
// 2FDE64: using guessed type int dword_2FDE64;
// 2FDE68: using guessed type int dword_2FDE68;
// 2FDE6C: using guessed type int dword_2FDE6C;
// 2FDEDC: using guessed type int dword_2FDEDC;
// 2FDEE0: using guessed type char byte_2FDEE0;
// 2FDEE1: using guessed type char byte_2FDEE1;
// 2FDEE4: using guessed type int dword_2FDEE4;
// 2FDEE8: using guessed type int dword_2FDEE8;
// 2FDEEC: using guessed type int dword_2FDEEC;
// 2FDEF0: using guessed type int dword_2FDEF0;
// 2FDEF4: using guessed type int dword_2FDEF4;
// 2FDEFC: using guessed type int dword_2FDEFC;
// 2FDF00: using guessed type int dword_2FDF00;
// 2FDF04: using guessed type int dword_2FDF04;
// 2FDF08: using guessed type int dword_2FDF08;
// 2FDF0C: using guessed type int dword_2FDF0C;
// 2FDF14: using guessed type int dword_2FDF14;
// 2FDF18: using guessed type int dword_2FDF18;
// 2FDF90: using guessed type int dword_2FDF90;
// 2FDF94: using guessed type char byte_2FDF94;
// 2FDF95: using guessed type char byte_2FDF95;
// 2FDF98: using guessed type int dword_2FDF98;
// 2FDF9C: using guessed type int dword_2FDF9C;
// 2FDFA0: using guessed type int dword_2FDFA0;
// 2FDFA4: using guessed type int dword_2FDFA4;
// 2FDFB8: using guessed type int dword_2FDFB8;
// 2FE01C: using guessed type int dword_2FE01C;
// 2FE020: using guessed type int dword_2FE020;
// 2FE024: using guessed type char byte_2FE024;
// 2FE028: using guessed type int dword_2FE028;
// 2FE02C: using guessed type int dword_2FE02C;
// 2FE030: using guessed type int dword_2FE030;
// 2FE034: using guessed type int dword_2FE034;
// 2FE038: using guessed type int dword_2FE038;
// 2FE040: using guessed type int dword_2FE040;
// 2FE044: using guessed type int dword_2FE044;
// 2FE048: using guessed type int dword_2FE048;
// 2FE04C: using guessed type int dword_2FE04C;
// 2FE050: using guessed type int dword_2FE050;
// 2FE058: using guessed type int dword_2FE058;
// 2FE05C: using guessed type int dword_2FE05C;

//----- (00093C90) --------------------------------------------------------
int __fastcall sub_93C90(int a1)
{
  int v1; // r5
  unsigned int v2; // r2

  v1 = a1;
  __dmb(0xFu);
  do
    v2 = __ldrex((unsigned int *)&unk_2FE060);
  while ( __strex(v2 - 1, (unsigned int *)&unk_2FE060) );
  __dmb(0xFu);
  if ( v2 == 2 )
  {
    sub_B66B0(&unk_2FDDD8);
    sub_B66B0(&unk_2FD8A4);
    sub_B66B0(&unk_2FDF1C);
    sub_B7E9C(&unk_2FD958);
    sub_B7E9C(&unk_2FDFA8);
    sub_B7E9C(&unk_2FDB28);
  }
  return v1;
}

//----- (00093EF4) --------------------------------------------------------
_DWORD *__fastcall sub_93EF4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0690;
  sub_95E1C(a1);
  return v1;
}
// F0690: using guessed type void *off_F0690;

//----- (00093F0C) --------------------------------------------------------
_DWORD *__fastcall sub_93F0C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F06A0;
  sub_95E1C(a1);
  return v1;
}
// F06A0: using guessed type void *;

//----- (00093F24) --------------------------------------------------------
void *__fastcall sub_93F24(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0690;
  sub_95E1C(a1);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;

//----- (00093F44) --------------------------------------------------------
void *__fastcall sub_93F44(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F06A0;
  sub_95E1C(a1);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;

//----- (00093F84) --------------------------------------------------------
_DWORD *__fastcall sub_93F84(_DWORD *result, int a2)
{
  int v2; // r3

  if ( !result[30] )
    a2 |= 1u;
  v2 = result[4];
  result[5] = a2;
  if ( a2 & v2 )
    sub_BFDD4("basic_ios::clear");
  return result;
}

//----- (00094010) --------------------------------------------------------
int __fastcall sub_94010(_DWORD *a1, int a2)
{
  int v2; // r4

  v2 = a1[30];
  a1[30] = a2;
  sub_93F84(a1, 0);
  return v2;
}

//----- (00094138) --------------------------------------------------------
_DWORD *__fastcall sub_94138(_DWORD *a1, int a2)
{
  _DWORD *v2; // r5
  int v3; // r4
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2;
  if ( sub_98F80(a2) )
    v2[31] = sub_97BC0(v3);
  else
    v2[31] = 0;
  if ( sub_990A0(v3) )
    v2[32] = sub_98454(v3);
  else
    v2[32] = 0;
  result = sub_990E4(v3);
  if ( result )
  {
    result = (_DWORD *)sub_98498(v3);
    v2[33] = result;
  }
  else
  {
    v2[33] = 0;
  }
  return result;
}

//----- (000941F4) --------------------------------------------------------
_DWORD *__fastcall sub_941F4(unsigned int **a1, unsigned int a2)
{
  unsigned int **v2; // r4
  unsigned int v3; // r5
  _DWORD *result; // r0
  bool v5; // cf
  int v6; // r5

  v2 = a1;
  v3 = a2;
  sub_A7CDC(a1);
  result = sub_94138(v2, (int)(v2 + 27));
  v2[30] = (unsigned int *)v3;
  v5 = v3 <= 1;
  v6 = 1 - v3;
  *((_BYTE *)v2 + 116) = 0;
  if ( !v5 )
    v6 = 0;
  *((_BYTE *)v2 + 117) = 0;
  v2[5] = (unsigned int *)v6;
  v2[28] = 0;
  v2[4] = 0;
  return result;
}

//----- (00094410) --------------------------------------------------------
_DWORD *__fastcall sub_94410(_DWORD *result, int a2)
{
  int v2; // r3

  if ( !result[31] )
    a2 |= 1u;
  v2 = result[4];
  result[5] = a2;
  if ( a2 & v2 )
    sub_BFDD4("basic_ios::clear");
  return result;
}

//----- (0009449C) --------------------------------------------------------
int __fastcall sub_9449C(_DWORD *a1, int a2)
{
  int v2; // r4

  v2 = a1[31];
  a1[31] = a2;
  sub_94410(a1, 0);
  return v2;
}

//----- (00094564) --------------------------------------------------------
_DWORD *__fastcall sub_94564(_DWORD *a1, int a2)
{
  _DWORD *v2; // r5
  int v3; // r4
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2;
  if ( sub_AF1B0(a2) )
    v2[32] = sub_ADE94(v3);
  else
    v2[32] = 0;
  if ( sub_AF2D0(v3) )
    v2[33] = sub_AE684(v3);
  else
    v2[33] = 0;
  result = sub_AF314(v3);
  if ( result )
  {
    result = (_DWORD *)sub_AE6C8(v3);
    v2[34] = result;
  }
  else
  {
    v2[34] = 0;
  }
  return result;
}

//----- (00094624) --------------------------------------------------------
_DWORD *__fastcall sub_94624(unsigned int **a1, unsigned int a2)
{
  unsigned int **v2; // r4
  unsigned int v3; // r5
  _DWORD *result; // r0
  bool v5; // cf
  int v6; // r5

  v2 = a1;
  v3 = a2;
  sub_A7CDC(a1);
  result = sub_94564(v2, (int)(v2 + 27));
  v2[31] = (unsigned int *)v3;
  v5 = v3 <= 1;
  v6 = 1 - v3;
  v2[29] = 0;
  if ( !v5 )
    v6 = 0;
  *((_BYTE *)v2 + 120) = 0;
  v2[5] = (unsigned int *)v6;
  v2[28] = 0;
  v2[4] = 0;
  return result;
}

//----- (000947F4) --------------------------------------------------------
int __fastcall sub_947F4(int result, _DWORD *a2)
{
  int v2; // r3
  int v3; // r2
  int v4; // r2

  v2 = *(_DWORD *)(result + 12);
  v3 = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(result + 12) = v3;
  if ( v3 )
    *(_DWORD *)(v3 + 4) = result;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(result + 4);
  if ( *a2 == result )
  {
    *a2 = v2;
  }
  else
  {
    v4 = *(_DWORD *)(result + 4);
    if ( *(_DWORD *)(v4 + 8) == result )
      *(_DWORD *)(v4 + 8) = v2;
    else
      *(_DWORD *)(v4 + 12) = v2;
  }
  *(_DWORD *)(v2 + 8) = result;
  *(_DWORD *)(result + 4) = v2;
  return result;
}

//----- (00094820) --------------------------------------------------------
int __fastcall sub_94820(int result, _DWORD *a2)
{
  int v2; // r3
  int v3; // r2
  int v4; // r2

  v2 = *(_DWORD *)(result + 8);
  v3 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(result + 8) = v3;
  if ( v3 )
    *(_DWORD *)(v3 + 4) = result;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(result + 4);
  if ( *a2 == result )
  {
    *a2 = v2;
  }
  else
  {
    v4 = *(_DWORD *)(result + 4);
    if ( *(_DWORD *)(v4 + 12) == result )
      *(_DWORD *)(v4 + 12) = v2;
    else
      *(_DWORD *)(v4 + 8) = v2;
  }
  *(_DWORD *)(v2 + 12) = result;
  *(_DWORD *)(result + 4) = v2;
  return result;
}

//----- (0009484C) --------------------------------------------------------
int __fastcall sub_9484C(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r2
  int v4; // r3
  int v5; // r2
  bool v6; // zf

  if ( !*a1 )
  {
    v1 = *(_DWORD **)(a1[1] + 4);
    if ( v1 == a1 )
      return v1[3];
  }
  v2 = a1[2];
  if ( v2 )
  {
    while ( *(_DWORD *)(v2 + 12) )
      v2 = *(_DWORD *)(v2 + 12);
    return v2;
  }
  v4 = a1[1];
  if ( a1 != *(_DWORD **)(v4 + 8) )
    return a1[1];
  do
  {
    v5 = *(_DWORD *)(v4 + 4);
    v6 = *(_DWORD *)(v5 + 8) == v4;
    v4 = *(_DWORD *)(v4 + 4);
  }
  while ( v6 );
  return v5;
}

//----- (00094888) --------------------------------------------------------
int __fastcall sub_94888(int a1)
{
  int v1; // r2
  int v3; // r3
  int v4; // r2

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 )
  {
    while ( *(_DWORD *)(v1 + 8) )
      v1 = *(_DWORD *)(v1 + 8);
    return v1;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( a1 != *(_DWORD *)(v3 + 12) )
    return *(_DWORD *)(a1 + 4);
  while ( 1 )
  {
    v4 = *(_DWORD *)(v3 + 4);
    if ( *(_DWORD *)(v4 + 12) != v3 )
      break;
    v3 = *(_DWORD *)(v3 + 4);
  }
  if ( v4 == *(_DWORD *)(v3 + 12) )
    v4 = v3;
  return v4;
}

//----- (000948C0) --------------------------------------------------------
int __fastcall sub_948C0(int a1)
{
  int v1; // r2
  int v3; // r3
  int v4; // r2

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 )
  {
    while ( *(_DWORD *)(v1 + 8) )
      v1 = *(_DWORD *)(v1 + 8);
    return v1;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( a1 != *(_DWORD *)(v3 + 12) )
    return *(_DWORD *)(a1 + 4);
  while ( 1 )
  {
    v4 = *(_DWORD *)(v3 + 4);
    if ( *(_DWORD *)(v4 + 12) != v3 )
      break;
    v3 = *(_DWORD *)(v3 + 4);
  }
  if ( v4 == *(_DWORD *)(v3 + 12) )
    v4 = v3;
  return v4;
}

//----- (00094908) --------------------------------------------------------
int __fastcall sub_94908(int result, int *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // r7
  _DWORD *v5; // r8
  int *v6; // r6
  int *v7; // r3
  int *v8; // r4
  int *v9; // r5
  int *v10; // r2
  int v11; // r1

  v4 = a4;
  v5 = a4 + 1;
  v6 = a2;
  a2[1] = (int)a3;
  a2[2] = 0;
  a2[3] = 0;
  *a2 = 0;
  if ( result )
  {
    a3[2] = a2;
    if ( a3 == a4 )
    {
      a4[1] = a2;
      a4[3] = a2;
    }
    else if ( (_DWORD *)a4[2] == a3 )
    {
      a4[2] = a2;
    }
  }
  else
  {
    a3[3] = a2;
    if ( (_DWORD *)a4[3] == a3 )
      a4[3] = a2;
  }
  v7 = (int *)a4[1];
LABEL_7:
  if ( v6 != v7 )
  {
    do
    {
      v8 = (int *)v6[1];
      if ( *v8 )
        break;
      v9 = (int *)v8[1];
      v10 = (int *)v9[2];
      if ( v8 == v10 )
      {
        v10 = (int *)v9[3];
        if ( !v10 || (v11 = *v10) != 0 )
        {
          if ( (int *)v8[3] == v6 )
          {
            sub_947F4(v6[1], v5);
            v6 = v8;
            v8 = (int *)v8[1];
          }
          *v8 = 1;
          *v9 = 0;
          result = sub_94820((int)v9, v5);
          v7 = (int *)v4[1];
          goto LABEL_7;
        }
      }
      else if ( !v10 || (v11 = *v10) != 0 )
      {
        if ( (int *)v8[2] == v6 )
        {
          sub_94820(v6[1], v5);
          v6 = v8;
          v8 = (int *)v8[1];
        }
        *v8 = 1;
        *v9 = 0;
        result = sub_947F4((int)v9, v5);
        v7 = (int *)v4[1];
        goto LABEL_7;
      }
      v6 = (int *)v8[1];
      *v8 = 1;
      *v10 = 1;
      *v9 = v11;
    }
    while ( v9 != v7 );
  }
  *v7 = 1;
  return result;
}

//----- (000949D8) --------------------------------------------------------
int *__fastcall sub_949D8(int *a1, _DWORD *a2)
{
  _DWORD *v2; // r2
  int *v3; // r10
  _DWORD *v4; // r9
  int *v5; // r1
  int *i; // r4
  int *v7; // r3
  int *v8; // r6
  int *v9; // r2
  int v10; // r2
  int v11; // r1
  int v12; // r2
  int v13; // r0
  int v14; // r1
  _DWORD *v15; // r3
  _DWORD *v16; // r3
  int *v17; // r3
  int *v18; // r5
  int *v20; // r3
  _DWORD *v21; // r1
  _DWORD *v22; // r1
  int v23; // r3
  _DWORD *v24; // r2
  int *v25; // r2
  int v26; // r3
  _DWORD *v27; // r0
  _DWORD *v28; // r1
  _DWORD *v29; // r2
  int *v30; // r3

  v2 = (_DWORD *)a1[2];
  v3 = a1;
  v4 = a2;
  if ( v2 )
  {
    v5 = (int *)a1[3];
    if ( v5 )
    {
      for ( i = (int *)a1[3]; i[2]; i = (int *)i[2] )
        ;
      v7 = i;
      v8 = (int *)i[3];
      if ( i != a1 )
      {
        v2[1] = i;
        i[2] = (int)v2;
        if ( v5 != i )
        {
          i = (int *)i[1];
          v9 = i;
          if ( v8 )
          {
            v8[1] = (int)i;
            v9 = (int *)v7[1];
          }
          v9[2] = (int)v8;
          v7[3] = (int)v5;
          *(_DWORD *)(a1[3] + 4) = v7;
        }
        if ( (int *)v4[1] == a1 )
        {
          v4[1] = v7;
          v11 = a1[1];
        }
        else
        {
          v10 = a1[1];
          if ( *(int **)(v10 + 8) == a1 )
            *(_DWORD *)(v10 + 8) = v7;
          else
            *(_DWORD *)(v10 + 12) = v7;
          v11 = v10;
        }
        v12 = *v7;
        v13 = *a1;
        v7[1] = v11;
        v14 = v12;
        *v7 = v13;
        *v3 = v12;
        goto LABEL_17;
      }
      v2 = (_DWORD *)i[3];
    }
  }
  else
  {
    v2 = (_DWORD *)a1[3];
  }
  i = (int *)a1[1];
  if ( v2 )
    v2[1] = i;
  if ( (int *)v4[1] == a1 )
  {
    v4[1] = v2;
  }
  else
  {
    v23 = a1[1];
    if ( *(int **)(v23 + 8) == a1 )
      *(_DWORD *)(v23 + 8) = v2;
    else
      *(_DWORD *)(v23 + 12) = v2;
  }
  if ( (int *)v4[2] == a1 )
  {
    v28 = v2;
    if ( a1[3] )
    {
      while ( v28[2] )
        v28 = (_DWORD *)v28[2];
      v4[2] = v28;
    }
    else
    {
      v4[2] = a1[1];
    }
  }
  if ( (int *)v4[3] == a1 )
  {
    v26 = a1[2];
    v27 = v2;
    if ( v26 )
    {
      while ( v27[3] )
        v27 = (_DWORD *)v27[3];
      v14 = *v3;
      v8 = v2;
      v4[3] = v27;
    }
    else
    {
      v8 = v2;
      v14 = *v3;
      v4[3] = v3[1];
    }
  }
  else
  {
    v8 = v2;
    v14 = *a1;
  }
LABEL_17:
  if ( !v14 )
    return v3;
  while ( 1 )
  {
    if ( (int *)v4[1] == v8 )
      goto LABEL_34;
    if ( v8 && *v8 != 1 )
      goto LABEL_35;
    v18 = (int *)i[2];
    if ( v18 != v8 )
      break;
    v20 = (int *)i[3];
    if ( !*v20 )
    {
      *v20 = 1;
      *i = 0;
      sub_947F4((int)i, v4 + 1);
      v20 = (int *)i[3];
    }
    v21 = (_DWORD *)v20[2];
    if ( v21 && *v21 != 1 )
    {
      v29 = (_DWORD *)v20[3];
      if ( v29 && *v29 != 1 )
      {
        v22 = (_DWORD *)v20[3];
LABEL_31:
        *v20 = *i;
        *i = 1;
LABEL_32:
        *v22 = 1;
      }
      else
      {
        *v21 = 1;
        *v20 = 0;
        sub_94820((int)v20, v4 + 1);
        v30 = (int *)i[3];
        v22 = (_DWORD *)v30[3];
        *v30 = *i;
        *i = 1;
        if ( v22 )
          goto LABEL_32;
      }
      sub_947F4((int)i, v4 + 1);
      v8 = v18;
LABEL_34:
      if ( !v8 )
        return v3;
LABEL_35:
      *v8 = 1;
      return v3;
    }
    v22 = (_DWORD *)v20[3];
    if ( v22 && *v22 != 1 )
      goto LABEL_31;
    *v20 = 0;
    v17 = (int *)i[1];
LABEL_24:
    v8 = i;
    i = v17;
  }
  if ( !*v18 )
  {
    *v18 = 1;
    *i = 0;
    sub_94820((int)i, v4 + 1);
    v18 = (int *)i[2];
  }
  v15 = (_DWORD *)v18[3];
  if ( !v15 || *v15 == 1 )
  {
    v16 = (_DWORD *)v18[2];
    if ( v16 && *v16 != 1 )
      goto LABEL_44;
    v17 = (int *)i[1];
    *v18 = 0;
    goto LABEL_24;
  }
  v24 = (_DWORD *)v18[2];
  if ( v24 && *v24 != 1 )
  {
    v16 = (_DWORD *)v18[2];
LABEL_44:
    *v18 = *i;
    *i = 1;
LABEL_45:
    *v16 = 1;
  }
  else
  {
    *v15 = 1;
    *v18 = 0;
    sub_947F4((int)v18, v4 + 1);
    v25 = (int *)i[2];
    v16 = (_DWORD *)v25[2];
    *v25 = *i;
    *i = 1;
    if ( v16 )
      goto LABEL_45;
  }
  sub_94820((int)i, v4 + 1);
  if ( v8 )
    goto LABEL_35;
  return v3;
}

//----- (00094CBC) --------------------------------------------------------
_DWORD *__fastcall sub_94CBC(_DWORD *result, int a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a2 + 4);
  *result = a2;
  result[1] = v2;
  **(_DWORD **)(a2 + 4) = result;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (00094CCC) --------------------------------------------------------
int *__fastcall sub_94CCC(int *result)
{
  int v1; // r3
  int *v2; // r2

  v1 = *result;
  v2 = (int *)result[1];
  *v2 = *result;
  *(_DWORD *)(v1 + 4) = v2;
  return result;
}

//----- (00094CD8) --------------------------------------------------------
int __fastcall sub_94CD8(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00094CDC) --------------------------------------------------------
int __fastcall sub_94CDC(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00094CE0) --------------------------------------------------------
std::exception *__fastcall sub_94CE0(std::exception *this)
{
  int v1; // r2
  std::exception *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = *((_DWORD *)this + 1);
  v2 = this;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F07A8;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  std::exception::~exception((int)v2);
  return v2;
}
// F07A8: using guessed type void *off_F07A8;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00094D38) --------------------------------------------------------
std::exception *__fastcall sub_94D38(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}

//----- (00094D4C) --------------------------------------------------------
std::exception *__fastcall sub_94D4C(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0720;
  sub_94CE0(a1);
  return v1;
}
// F0720: using guessed type void *;

//----- (00094D64) --------------------------------------------------------
std::exception *__fastcall sub_94D64(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0720;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}
// F0720: using guessed type void *off_F0720;

//----- (00094D84) --------------------------------------------------------
std::exception *__fastcall sub_94D84(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0750;
  sub_94CE0(a1);
  return v1;
}
// F0750: using guessed type void *;

//----- (00094D9C) --------------------------------------------------------
std::exception *__fastcall sub_94D9C(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0750;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}
// F0750: using guessed type void *off_F0750;

//----- (00094DBC) --------------------------------------------------------
std::exception *__fastcall sub_94DBC(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07D8;
  sub_94CE0(a1);
  return v1;
}
// F07D8: using guessed type void *off_F07D8;

//----- (00094DD4) --------------------------------------------------------
std::exception *__fastcall sub_94DD4(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07D8;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}
// F07D8: using guessed type void *off_F07D8;

//----- (00094DF4) --------------------------------------------------------
std::exception *__fastcall sub_94DF4(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07C0;
  sub_94CE0(a1);
  return v1;
}
// F07C0: using guessed type void *off_F07C0;

//----- (00094E0C) --------------------------------------------------------
std::exception *__fastcall sub_94E0C(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07C0;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}
// F07C0: using guessed type void *off_F07C0;

//----- (00094E2C) --------------------------------------------------------
std::exception *__fastcall sub_94E2C(std::exception *this)
{
  int v1; // r2
  std::exception *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = *((_DWORD *)this + 1);
  v2 = this;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F06D8;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  std::exception::~exception((int)v2);
  return v2;
}
// F06D8: using guessed type void *off_F06D8;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00094E84) --------------------------------------------------------
std::exception *__fastcall sub_94E84(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}

//----- (00094E98) --------------------------------------------------------
std::exception *__fastcall sub_94E98(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07F0;
  sub_94E2C(a1);
  return v1;
}
// F07F0: using guessed type void *;

//----- (00094EB0) --------------------------------------------------------
std::exception *__fastcall sub_94EB0(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F07F0;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}
// F07F0: using guessed type void *off_F07F0;

//----- (00094ED0) --------------------------------------------------------
std::exception *__fastcall sub_94ED0(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F06F0;
  sub_94E2C(a1);
  return v1;
}
// F06F0: using guessed type void *;

//----- (00094EE8) --------------------------------------------------------
std::exception *__fastcall sub_94EE8(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F06F0;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}
// F06F0: using guessed type void *off_F06F0;

//----- (00094F08) --------------------------------------------------------
std::exception *__fastcall sub_94F08(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0708;
  sub_94E2C(a1);
  return v1;
}
// F0708: using guessed type void *;

//----- (00094F20) --------------------------------------------------------
std::exception *__fastcall sub_94F20(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0708;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}
// F0708: using guessed type void *off_F0708;

//----- (00094F40) --------------------------------------------------------
_DWORD *__fastcall sub_94F40(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4

  v2 = a1;
  *a1 = &off_F07A8;
  sub_C16AC(a1 + 1, a2);
  return v2;
}
// F07A8: using guessed type void *;

//----- (00094F64) --------------------------------------------------------
_DWORD *__fastcall sub_94F64(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94F40(a1, a2);
  result = v2;
  *v2 = &off_F0720;
  return result;
}
// F0720: using guessed type void *off_F0720;

//----- (00094F7C) --------------------------------------------------------
_DWORD *__fastcall sub_94F7C(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94F40(a1, a2);
  result = v2;
  *v2 = &off_F0750;
  return result;
}
// F0750: using guessed type void *off_F0750;

//----- (00094F94) --------------------------------------------------------
_DWORD *__fastcall sub_94F94(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94F40(a1, a2);
  result = v2;
  *v2 = &off_F07D8;
  return result;
}
// F07D8: using guessed type void *off_F07D8;

//----- (00094FAC) --------------------------------------------------------
_DWORD *__fastcall sub_94FAC(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94F40(a1, a2);
  result = v2;
  *v2 = &off_F07C0;
  return result;
}
// F07C0: using guessed type void *;

//----- (00094FC4) --------------------------------------------------------
_DWORD *__fastcall sub_94FC4(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4

  v2 = a1;
  *a1 = &off_F06D8;
  sub_C16AC(a1 + 1, a2);
  return v2;
}
// F06D8: using guessed type void *;

//----- (00094FE8) --------------------------------------------------------
_DWORD *__fastcall sub_94FE8(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94FC4(a1, a2);
  result = v2;
  *v2 = &off_F07F0;
  return result;
}
// F07F0: using guessed type void *off_F07F0;

//----- (00095000) --------------------------------------------------------
_DWORD *__fastcall sub_95000(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94FC4(a1, a2);
  result = v2;
  *v2 = &off_F06F0;
  return result;
}
// F06F0: using guessed type void *off_F06F0;

//----- (00095018) --------------------------------------------------------
_DWORD *__fastcall sub_95018(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4
  _DWORD *result; // r0

  v2 = a1;
  sub_94FC4(a1, a2);
  result = v2;
  *v2 = &off_F0708;
  return result;
}
// F0708: using guessed type void *off_F0708;

//----- (00095038) --------------------------------------------------------
int __fastcall sub_95038(int result)
{
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)result = -1LL;
  return result;
}

//----- (00095050) --------------------------------------------------------
int __fastcall sub_95050(int result)
{
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)result = -1LL;
  return result;
}

//----- (00095074) --------------------------------------------------------
int sub_95074()
{
  return 0;
}

//----- (00095078) --------------------------------------------------------
int sub_95078()
{
  return 0;
}

//----- (0009507C) --------------------------------------------------------
signed int sub_9507C()
{
  return -1;
}

//----- (00095084) --------------------------------------------------------
int __fastcall sub_95084(int a1)
{
  int v1; // r4
  int result; // r0
  unsigned __int8 *v3; // r3

  v1 = a1;
  result = (*(int (**)(void))(*(_DWORD *)a1 + 36))();
  if ( result != -1 )
  {
    v3 = *(unsigned __int8 **)(v1 + 8);
    result = *v3;
    *(_DWORD *)(v1 + 8) = v3 + 1;
  }
  return result;
}

//----- (0009509C) --------------------------------------------------------
signed int sub_9509C()
{
  return -1;
}

//----- (000950A4) --------------------------------------------------------
signed int sub_950A4()
{
  return -1;
}

//----- (000950B4) --------------------------------------------------------
int __fastcall sub_950B4(int result)
{
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)result = -1LL;
  return result;
}

//----- (000950CC) --------------------------------------------------------
int __fastcall sub_950CC(int result)
{
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)result = -1LL;
  return result;
}

//----- (000950F0) --------------------------------------------------------
int sub_950F0()
{
  return 0;
}

//----- (000950F4) --------------------------------------------------------
int sub_950F4()
{
  return 0;
}

//----- (000950F8) --------------------------------------------------------
signed int sub_950F8()
{
  return -1;
}

//----- (00095100) --------------------------------------------------------
signed int sub_95100()
{
  return -1;
}

//----- (00095108) --------------------------------------------------------
signed int sub_95108()
{
  return -1;
}

//----- (00095110) --------------------------------------------------------
int __fastcall sub_95110(_DWORD *a1, _BYTE *a2, int a3)
{
  int v3; // r8
  _DWORD *v4; // r4
  _BYTE *v5; // r7
  int v6; // r5
  const void *v7; // r3
  const void *v8; // r1
  int v9; // r3
  int v10; // r0
  size_t v11; // r6

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v7 = (const void *)v4[2];
      v8 = v7;
      v9 = v4[3] - (_DWORD)v7;
      if ( v9 )
      {
        if ( v3 - v6 >= v9 )
          v11 = v9;
        else
          v11 = v3 - v6;
        v6 += v11;
        memcpy(v5, v8, v11);
        v4[2] += v11;
        if ( v3 <= v6 )
          return v6;
        v5 += v11;
      }
      v10 = (*(int (__fastcall **)(_DWORD *))(*v4 + 40))(v4);
      if ( v10 != -1 )
      {
        ++v6;
        *v5++ = v10;
        if ( v3 > v6 )
          continue;
      }
      return v6;
    }
  }
  return v6;
}

//----- (00095174) --------------------------------------------------------
int __fastcall sub_95174(_DWORD *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r8
  _DWORD *v4; // r4
  unsigned __int8 *v5; // r7
  int v6; // r5
  void *v7; // r3
  void *v8; // r0
  int v9; // r3
  int v10; // r1
  size_t v11; // r6

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v7 = (void *)v4[5];
      v8 = v7;
      v9 = v4[6] - (_DWORD)v7;
      if ( v9 )
      {
        if ( v3 - v6 >= v9 )
          v11 = v9;
        else
          v11 = v3 - v6;
        v6 += v11;
        memcpy(v8, v5, v11);
        v4[5] += v11;
        if ( v3 <= v6 )
          return v6;
        v5 += v11;
      }
      v10 = *v5++;
      if ( (*(int (__fastcall **)(_DWORD *, int))(*v4 + 52))(v4, v10) != -1 && v3 > ++v6 )
        continue;
      return v6;
    }
  }
  return v6;
}

//----- (000951D4) --------------------------------------------------------
int __fastcall sub_951D4(int a1)
{
  int v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0818;
  sub_AB620((unsigned int **)(a1 + 28));
  return v1;
}
// F0818: using guessed type void *off_F0818;

//----- (000951F0) --------------------------------------------------------
int __fastcall sub_951F0(int a1)
{
  int v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0858;
  sub_AB620((unsigned int **)(a1 + 28));
  return v1;
}
// F0858: using guessed type void *off_F0858;

//----- (0009520C) --------------------------------------------------------
unsigned int **__fastcall sub_9520C(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  *a1 = (unsigned int *)&off_F0818;
  sub_AB620(a1 + 7);
  operator delete(v1);
  return v1;
}
// F0818: using guessed type void *off_F0818;

//----- (0009522C) --------------------------------------------------------
unsigned int **__fastcall sub_9522C(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  *a1 = (unsigned int *)&off_F0858;
  sub_AB620(a1 + 7);
  operator delete(v1);
  return v1;
}
// F0858: using guessed type void *off_F0858;

//----- (0009524C) --------------------------------------------------------
int __fastcall sub_9524C(int a1, wchar_t *a2, int a3)
{
  int v3; // r8
  int v4; // r4
  wchar_t *v5; // r7
  int v6; // r5
  int v7; // r3
  int v8; // r0
  int v9; // r6
  size_t v10; // r2
  int v11; // r6

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v7 = (*(_DWORD *)(v4 + 12) - *(_DWORD *)(v4 + 8)) >> 2;
      if ( v7 )
      {
        if ( v3 - v6 >= v7 )
          v9 = (*(_DWORD *)(v4 + 12) - *(_DWORD *)(v4 + 8)) >> 2;
        else
          v9 = v3 - v6;
        v6 += v9;
        v10 = v9;
        v11 = 4 * v9;
        wmemcpy(v5, *(const wchar_t **)(v4 + 8), v10);
        *(_DWORD *)(v4 + 8) += v11;
        if ( v3 <= v6 )
          return v6;
        v5 = (wchar_t *)((char *)v5 + v11);
      }
      v8 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 40))(v4);
      if ( v8 != -1 )
      {
        ++v6;
        *(_DWORD *)v5 = v8;
        v5 += 2;
        if ( v3 > v6 )
          continue;
      }
      return v6;
    }
  }
  return v6;
}

//----- (000952B4) --------------------------------------------------------
int __fastcall sub_952B4(int a1, const wchar_t *a2, int a3)
{
  int v3; // r8
  int v4; // r4
  const wchar_t *v5; // r7
  int v6; // r5
  int v7; // r3
  int v8; // r1
  int v9; // r6
  size_t v10; // r2
  int v11; // r6

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v7 = (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 20)) >> 2;
      if ( v7 )
      {
        if ( v3 - v6 >= v7 )
          v9 = (*(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 20)) >> 2;
        else
          v9 = v3 - v6;
        v6 += v9;
        v10 = v9;
        v11 = 4 * v9;
        wmemcpy(*(wchar_t **)(v4 + 20), v5, v10);
        *(_DWORD *)(v4 + 20) += v11;
        if ( v3 <= v6 )
          return v6;
        v5 = (const wchar_t *)((char *)v5 + v11);
      }
      v8 = *(_DWORD *)v5;
      v5 += 2;
      if ( (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 52))(v4, v8) != -1 && v3 > ++v6 )
        continue;
      return v6;
    }
  }
  return v6;
}

//----- (00095318) --------------------------------------------------------
int __fastcall sub_95318(int a1)
{
  int v1; // r4
  int result; // r0
  int *v3; // r3

  v1 = a1;
  result = (*(int (**)(void))(*(_DWORD *)a1 + 36))();
  if ( result != -1 )
  {
    v3 = *(int **)(v1 + 8);
    result = *v3;
    *(_DWORD *)(v1 + 8) = v3 + 1;
  }
  return result;
}

//----- (000955C4) --------------------------------------------------------
unsigned int **__fastcall sub_955C4(unsigned int **a1, int a2, unsigned int **a3)
{
  unsigned int **v3; // r7
  int v4; // r4
  unsigned int **v5; // r6
  unsigned int **v6; // r5

  v3 = (unsigned int **)(a2 + 28);
  v4 = a2;
  v5 = a3;
  v6 = a1;
  sub_AB164(a1, (unsigned int **)(a2 + 28));
  (*(void (__fastcall **)(int, unsigned int **))(*(_DWORD *)v4 + 8))(v4, v5);
  sub_AB5C4(v3, v5);
  return v6;
}

//----- (0009567C) --------------------------------------------------------
int __fastcall sub_9567C(int a1, int a2, int a3)
{
  int v3; // r2
  int result; // r0

  v3 = (a2 - a3) >> 2;
  if ( v3 )
    result = v3;
  else
    result = (*(int (**)(void))(*(_DWORD *)a1 + 28))();
  return result;
}

//----- (0009586C) --------------------------------------------------------
unsigned int **__fastcall sub_9586C(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F1E38;
  sub_BC1E0((int)a1);
  sub_A9768(v1 + 9, v2, v3);
  *v1 = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 7);
  return v1;
}
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *;

//----- (000958C8) --------------------------------------------------------
unsigned int **__fastcall sub_958C8(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  sub_9586C(a1);
  operator delete(v1);
  return v1;
}

//----- (000958DC) --------------------------------------------------------
unsigned int **__fastcall sub_958DC(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F2030;
  sub_BDFB0((int)a1);
  sub_A9768(v1 + 9, v2, v3);
  *v1 = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 7);
  return v1;
}
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *;

//----- (00095938) --------------------------------------------------------
unsigned int **__fastcall sub_95938(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  sub_958DC(a1);
  operator delete(v1);
  return v1;
}

//----- (00095A2C) --------------------------------------------------------
_DWORD *__fastcall sub_95A2C(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // r7
  int v5; // r6
  _DWORD *v6; // r4
  int v7; // r8
  _DWORD *result; // r0
  int v9; // r2

  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = a4;
  sub_BBEAC(a1);
  *v6 = &off_F08A8;
  sub_A966C(v6 + 9, v4, v5);
  if ( !sub_A9714(v6 + 9) )
    return v6;
  v6[11] = v5;
  v6[16] = v7;
  sub_BBF60(v6);
  v9 = v6[15];
  result = v6;
  *((_BYTE *)v6 + 69) = 0;
  *((_BYTE *)v6 + 70) = 0;
  v6[1] = v9;
  v6[2] = v9;
  v6[3] = v9;
  v6[5] = 0;
  v6[4] = 0;
  v6[6] = 0;
  return result;
}
// F08A8: using guessed type void *;

//----- (00095B84) --------------------------------------------------------
_DWORD *__fastcall sub_95B84(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // r7
  int v5; // r6
  _DWORD *v6; // r4
  int v7; // r8
  _DWORD *result; // r0
  int v9; // r2

  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = a4;
  sub_BDC64(a1);
  *v6 = &off_F08E8;
  sub_A966C(v6 + 9, v4, v5);
  if ( !sub_A9714(v6 + 9) )
    return v6;
  v6[11] = v5;
  v6[16] = v7;
  sub_BDD18(v6);
  v9 = v6[15];
  result = v6;
  *((_BYTE *)v6 + 69) = 0;
  *((_BYTE *)v6 + 70) = 0;
  v6[1] = v9;
  v6[2] = v9;
  v6[3] = v9;
  v6[5] = 0;
  v6[4] = 0;
  v6[6] = 0;
  return result;
}
// F08E8: using guessed type void *;

//----- (00095C00) --------------------------------------------------------
_DWORD *__fastcall sub_95C00(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r5
  _DWORD *v3; // r3
  int v4; // r0

  v1 = a1;
  v2 = (int)(a1 + 9);
  v3 = a1 + 11;
  v4 = (int)(a1 + 27);
  v1[1] = 0;
  *v1 = &off_F0940;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0;
  do
  {
    *(v3 - 2) = 0;
    v3 += 2;
    *(v3 - 3) = 0;
  }
  while ( v3 != (_DWORD *)v4 );
  v1[26] = v2;
  v1[25] = 8;
  sub_A93A8(v3);
  return v1;
}
// F0940: using guessed type void *;

//----- (00095C70) --------------------------------------------------------
_DWORD *__fastcall sub_95C70(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r6
  int v5; // r5
  _DWORD *result; // r0

  v3 = a1;
  v4 = a3;
  v5 = a2;
  result = operator new(0x10u);
  *result = *(_DWORD *)(v3 + 24);
  result[1] = v5;
  result[2] = v4;
  result[3] = 0;
  *(_DWORD *)(v3 + 24) = result;
  return result;
}

//----- (00095DA8) --------------------------------------------------------
int __fastcall sub_95DA8(int result, int a2)
{
  int v2; // r5
  int **v3; // r4
  int i; // r6

  v2 = result;
  v3 = *(int ***)(result + 24);
  for ( i = a2; v3; v3 = (int **)*v3 )
    result = ((int (__fastcall *)(int, int, int *))v3[1])(i, v2, v3[2]);
  return result;
}

//----- (00095DDC) --------------------------------------------------------
void __fastcall sub_95DDC(int a1)
{
  int v1; // r5
  _DWORD *v2; // r0
  unsigned int *v3; // r3
  unsigned int v4; // r2
  _DWORD *v5; // r4

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 24);
  if ( v2 )
  {
    v3 = v2 + 3;
    __dmb(0xFu);
    while ( 1 )
    {
      do
        v4 = __ldrex(v3);
      while ( __strex(v4 - 1, v3) );
      __dmb(0xFu);
      if ( v4 )
        break;
      v5 = (_DWORD *)*v2;
      operator delete(v2);
      if ( !v5 )
        break;
      v2 = v5;
      __dmb(0xFu);
      v3 = v5 + 3;
    }
  }
  *(_DWORD *)(v1 + 24) = 0;
}

//----- (00095E1C) --------------------------------------------------------
int __fastcall sub_95E1C(_DWORD *a1)
{
  int v1; // r4
  void *v2; // r0

  v1 = (int)a1;
  *a1 = &off_F0940;
  sub_95DA8((int)a1, 0);
  sub_95DDC(v1);
  v2 = *(void **)(v1 + 104);
  if ( v2 != (void *)(v1 + 36) )
  {
    if ( v2 )
      operator delete[](v2);
    *(_DWORD *)(v1 + 104) = 0;
  }
  sub_AB620((unsigned int **)(v1 + 108));
  return v1;
}
// F0940: using guessed type void *off_F0940;

//----- (00095E58) --------------------------------------------------------
void *__fastcall sub_95E58(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_95E1C(a1);
  operator delete(v1);
  return v1;
}

//----- (00095E6C) --------------------------------------------------------
int __fastcall sub_95E6C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 17);
}

//----- (00095E74) --------------------------------------------------------
int __fastcall sub_95E74(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 18);
}

//----- (00095E7C) --------------------------------------------------------
int __fastcall sub_95E7C(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 44);
}

//----- (00095E84) --------------------------------------------------------
int __fastcall sub_95E84(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 24) << 24);
}

//----- (00095EB4) --------------------------------------------------------
int __fastcall sub_95EB4(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 24) << 24);
}

//----- (00095EE4) --------------------------------------------------------
int __fastcall sub_95EE4(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 17);
}

//----- (00095EEC) --------------------------------------------------------
int __fastcall sub_95EEC(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 18);
}

//----- (00095EF4) --------------------------------------------------------
int __fastcall sub_95EF4(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 44);
}

//----- (00095EFC) --------------------------------------------------------
int __fastcall sub_95EFC(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 48) >> 24) << 24);
}

//----- (00095F2C) --------------------------------------------------------
int __fastcall sub_95F2C(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 52) >> 24) << 24);
}

//----- (00095F5C) --------------------------------------------------------
int __fastcall sub_95F5C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 36);
}

//----- (00095F64) --------------------------------------------------------
int __fastcall sub_95F64(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + 37);
}

//----- (00095F6C) --------------------------------------------------------
int sub_95F6C()
{
  return 0;
}

//----- (00095F70) --------------------------------------------------------
int sub_95F70()
{
  return 0;
}

//----- (00095F78) --------------------------------------------------------
int __fastcall sub_95F78(int a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int result; // r0
  int v4; // t1

  result = 0;
  if ( a2 < a3 )
  {
    do
    {
      v4 = *a2++;
      result = v4 + __ROR4__(result, 25);
    }
    while ( a2 != a3 );
  }
  return result;
}

//----- (00095F90) --------------------------------------------------------
_DWORD *__fastcall sub_95F90(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C00;
  sub_AB124(a1);
  return v1;
}
// F0C00: using guessed type void *off_F0C00;

//----- (00095FA8) --------------------------------------------------------
_DWORD *__fastcall sub_95FA8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C18;
  sub_AB124(a1);
  return v1;
}
// F0C18: using guessed type void *off_F0C18;

//----- (00095FC0) --------------------------------------------------------
_DWORD *__fastcall sub_95FC0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0A10;
  sub_AB124(a1);
  return v1;
}
// F0A10: using guessed type void *off_F0A10;

//----- (00095FD8) --------------------------------------------------------
_DWORD *__fastcall sub_95FD8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0A50;
  sub_AB124(a1);
  return v1;
}
// F0A50: using guessed type void *off_F0A50;

//----- (00095FF0) --------------------------------------------------------
_DWORD *__fastcall sub_95FF0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0A80;
  sub_AB124(a1);
  return v1;
}
// F0A80: using guessed type void *off_F0A80;

//----- (00096008) --------------------------------------------------------
_DWORD *__fastcall sub_96008(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C30;
  sub_AB124(a1);
  return v1;
}
// F0C30: using guessed type void *off_F0C30;

//----- (00096020) --------------------------------------------------------
_DWORD *__fastcall sub_96020(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C30;
  sub_AB124(a1);
  return v1;
}
// F0C30: using guessed type void *off_F0C30;

//----- (00096038) --------------------------------------------------------
_DWORD *__fastcall sub_96038(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C60;
  sub_AB124(a1);
  return v1;
}
// F0C60: using guessed type void *off_F0C60;

//----- (00096050) --------------------------------------------------------
_DWORD *__fastcall sub_96050(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0C60;
  sub_AB124(a1);
  return v1;
}
// F0C60: using guessed type void *off_F0C60;

//----- (00096068) --------------------------------------------------------
_DWORD *__fastcall sub_96068(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0D00;
  sub_AB124(a1);
  return v1;
}
// F0D00: using guessed type void *;

//----- (00096080) --------------------------------------------------------
_DWORD *__fastcall sub_96080(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0B30;
  sub_AB124(a1);
  return v1;
}
// F0B30: using guessed type void *;

//----- (00096098) --------------------------------------------------------
void **__fastcall sub_96098(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (000960B0) --------------------------------------------------------
void **__fastcall sub_960B0(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 20));
  return v2;
}

//----- (000960C8) --------------------------------------------------------
void **__fastcall sub_960C8(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (000960E0) --------------------------------------------------------
void **__fastcall sub_960E0(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 36));
  return v2;
}

//----- (000960F8) --------------------------------------------------------
void **__fastcall sub_960F8(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (00096110) --------------------------------------------------------
void **__fastcall sub_96110(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 20));
  return v2;
}

//----- (00096128) --------------------------------------------------------
void **__fastcall sub_96128(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (00096140) --------------------------------------------------------
void **__fastcall sub_96140(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 36));
  return v2;
}

//----- (00096158) --------------------------------------------------------
void **__fastcall sub_96158(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (00096170) --------------------------------------------------------
void **__fastcall sub_96170(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 20));
  return v2;
}

//----- (00096188) --------------------------------------------------------
void **__fastcall sub_96188(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (000961A0) --------------------------------------------------------
_DWORD *__fastcall sub_961A0(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0

  v1 = *(unsigned __int8 *)(a1 + 67);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F0CD0;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[5];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[7];
    if ( v5 )
      operator delete[](v5);
    v6 = (void *)v2[9];
    if ( v6 )
      operator delete[](v6);
  }
  sub_AB124(v2);
  return v2;
}
// F0CD0: using guessed type void *off_F0CD0;

//----- (000961E0) --------------------------------------------------------
_DWORD *__fastcall sub_961E0(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0

  v1 = *(unsigned __int8 *)(a1 + 67);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F0CE0;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[5];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[7];
    if ( v5 )
      operator delete[](v5);
    v6 = (void *)v2[9];
    if ( v6 )
      operator delete[](v6);
  }
  sub_AB124(v2);
  return v2;
}
// F0CE0: using guessed type void *off_F0CE0;

//----- (00096220) --------------------------------------------------------
_DWORD *__fastcall sub_96220(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0

  v1 = *(unsigned __int8 *)(a1 + 100);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F0CF0;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[5];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[7];
    if ( v5 )
      operator delete[](v5);
  }
  sub_AB124(v2);
  return v2;
}
// F0CF0: using guessed type void *off_F0CF0;

//----- (00096258) --------------------------------------------------------
void *__fastcall sub_96258(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_961A0(a1);
  operator delete(v1);
  return v1;
}

//----- (0009626C) --------------------------------------------------------
void *__fastcall sub_9626C(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_961E0(a1);
  operator delete(v1);
  return v1;
}

//----- (00096280) --------------------------------------------------------
void *__fastcall sub_96280(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C00;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C00: using guessed type void *off_F0C00;

//----- (000962A0) --------------------------------------------------------
void *__fastcall sub_962A0(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C18;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C18: using guessed type void *off_F0C18;

//----- (000962C0) --------------------------------------------------------
void *__fastcall sub_962C0(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_96220(a1);
  operator delete(v1);
  return v1;
}

//----- (000962D4) --------------------------------------------------------
void *__fastcall sub_962D4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0A10;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0A10: using guessed type void *off_F0A10;

//----- (000962F4) --------------------------------------------------------
void *__fastcall sub_962F4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0A50;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0A50: using guessed type void *off_F0A50;

//----- (00096314) --------------------------------------------------------
void *__fastcall sub_96314(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_95FF0(a1);
  operator delete(v1);
  return v1;
}

//----- (00096328) --------------------------------------------------------
void *__fastcall sub_96328(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C30;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C30: using guessed type void *off_F0C30;

//----- (00096348) --------------------------------------------------------
void *__fastcall sub_96348(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C30;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C30: using guessed type void *off_F0C30;

//----- (00096368) --------------------------------------------------------
void *__fastcall sub_96368(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C60;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C60: using guessed type void *off_F0C60;

//----- (00096388) --------------------------------------------------------
void *__fastcall sub_96388(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0C60;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0C60: using guessed type void *off_F0C60;

//----- (000963A8) --------------------------------------------------------
void *__fastcall sub_963A8(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0D00;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0D00: using guessed type void *off_F0D00;

//----- (000963C8) --------------------------------------------------------
void *__fastcall sub_963C8(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0B30;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F0B30: using guessed type void *off_F0B30;

//----- (000963E8) --------------------------------------------------------
_DWORD *__fastcall sub_963E8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0B10;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F0B10: using guessed type void *off_F0B10;

//----- (00096414) --------------------------------------------------------
void *__fastcall sub_96414(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_963E8(a1);
  operator delete(v1);
  return v1;
}

//----- (00096428) --------------------------------------------------------
_DWORD *__fastcall sub_96428(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0CB0;
  sub_963E8(a1);
  return v1;
}
// F0CB0: using guessed type void *;

//----- (00096440) --------------------------------------------------------
void *__fastcall sub_96440(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0CB0;
  sub_963E8(a1);
  operator delete(v1);
  return v1;
}
// F0CB0: using guessed type void *off_F0CB0;

//----- (00096460) --------------------------------------------------------
_DWORD *__fastcall sub_96460(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0980;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F0980: using guessed type void *off_F0980;

//----- (0009648C) --------------------------------------------------------
_DWORD *__fastcall sub_9648C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0B90;
  sub_C2BB0(a1);
  return v1;
}
// F0B90: using guessed type void *;

//----- (000964A4) --------------------------------------------------------
void *__fastcall sub_964A4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0B90;
  sub_C2BB0(a1);
  operator delete(v1);
  return v1;
}
// F0B90: using guessed type void *off_F0B90;

//----- (000964C4) --------------------------------------------------------
_DWORD *__fastcall sub_964C4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0BC8;
  sub_C2B6C(a1);
  return v1;
}
// F0BC8: using guessed type void *;

//----- (000964DC) --------------------------------------------------------
void *__fastcall sub_964DC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0BC8;
  sub_C2B6C(a1);
  operator delete(v1);
  return v1;
}
// F0BC8: using guessed type void *off_F0BC8;

//----- (000964FC) --------------------------------------------------------
_DWORD *__fastcall sub_964FC(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F09E8;
  sub_C2958(a1);
  return v1;
}
// F09E8: using guessed type void *;

//----- (00096514) --------------------------------------------------------
void *__fastcall sub_96514(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F09E8;
  sub_C2958(a1);
  operator delete(v1);
  return v1;
}
// F09E8: using guessed type void *off_F09E8;

//----- (00096534) --------------------------------------------------------
_DWORD *__fastcall sub_96534(_DWORD *a1)
{
  _DWORD *v1; // r4
  char *v2; // r5
  int v3; // r0

  v1 = a1;
  v2 = (char *)a1[4];
  *a1 = &off_F0A90;
  if ( v2 != sub_AB4DC() && v2 )
    operator delete[](v2);
  v3 = v1[2];
  if ( v3 )
    (*(void (**)(void))(*(_DWORD *)v3 + 4))();
  sub_A8038(v1 + 3);
  sub_AB124(v1);
  return v1;
}
// F0A90: using guessed type void *off_F0A90;

//----- (0009657C) --------------------------------------------------------
void *__fastcall sub_9657C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_96534(a1);
  operator delete(v1);
  return v1;
}

//----- (00096590) --------------------------------------------------------
_DWORD *__fastcall sub_96590(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0B60;
  sub_A02F0(a1);
  return v1;
}
// F0B60: using guessed type void *;

//----- (000965A8) --------------------------------------------------------
void *__fastcall sub_965A8(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F0B60;
  sub_A02F0(a1);
  operator delete(v1);
  return v1;
}
// F0B60: using guessed type void *off_F0B60;

//----- (000965C8) --------------------------------------------------------
signed int __fastcall sub_965C8(int a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5)
{
  _BYTE *v5; // r5
  int v6; // r6
  const char *v7; // r10
  const char *v8; // r11
  const char *v9; // r4
  const char *v10; // r5
  int v11; // r8
  int v12; // r7
  size_t v13; // r5
  size_t v14; // r0
  int v15; // r9
  signed int v16; // r4

  v5 = a4;
  v6 = a1;
  v7 = (const char *)sub_C1994(a2, a3);
  v8 = (const char *)sub_C1994(v5, a5);
  v9 = v8;
  v10 = v7;
  v11 = (int)&v8[*((_DWORD *)v8 - 3)];
  v12 = (int)&v7[*((_DWORD *)v7 - 3)];
  while ( 1 )
  {
    v15 = sub_AAAF4(v6, v10, v9);
    if ( v15 || (v13 = (size_t)&v10[strlen(v10)], v14 = (size_t)&v9[strlen(v9)], v14 - v11 <= 0 && v13 - v12 <= 0) )
    {
      v16 = v15;
      goto LABEL_8;
    }
    if ( v13 - v12 <= 0 )
    {
      v16 = -1;
      goto LABEL_8;
    }
    if ( v14 - v11 <= 0 )
      break;
    v10 = (const char *)(v13 + 1);
    v9 = (const char *)(v14 + 1);
  }
  v16 = 1;
LABEL_8:
  sub_C0AC4((unsigned int *)v8 - 3);
  sub_C0AC4((unsigned int *)v7 - 3);
  return v16;
}

//----- (0009667C) --------------------------------------------------------
int __fastcall sub_9667C(int a1, int a2)
{
  int v2; // r4
  int v3; // r5

  v2 = a1;
  v3 = a2;
  sub_AA9D0(a1);
  return (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 24))(v2, v3);
}

//----- (00096694) --------------------------------------------------------
_DWORD *__fastcall sub_96694(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0980;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F0980: using guessed type void *off_F0980;

//----- (000966C0) --------------------------------------------------------
_DWORD *__fastcall sub_966C0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0980;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  operator delete(v1);
  return v1;
}
// F0980: using guessed type void *off_F0980;

//----- (000966F0) --------------------------------------------------------
_DWORD *__fastcall sub_966F0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0980;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  operator delete(v1);
  return v1;
}
// F0980: using guessed type void *off_F0980;

//----- (00096720) --------------------------------------------------------
unsigned int *__fastcall sub_96720(unsigned int *a1, int a2, _BYTE *a3, _BYTE *a4)
{
  _BYTE *v4; // r7
  unsigned int *v5; // r4
  _BYTE *v6; // r5
  int v7; // r9
  unsigned int v8; // r7
  int v9; // r11
  char *v10; // r6
  const char *v11; // r5
  unsigned int v12; // r3
  int v13; // r2
  int v14; // r8
  unsigned int v15; // r3
  size_t v16; // r0
  size_t v17; // r0
  const char *v19; // [sp+0h] [bp-38h]

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  *a1 = (unsigned int)&unk_2FEF48;
  v19 = (const char *)sub_C1994(a3, a4);
  v8 = 2 * (v4 - v6);
  v9 = (int)&v19[*((_DWORD *)v19 - 3)];
  v10 = (char *)operator new[](v8);
  v11 = v19;
  while ( 1 )
  {
    v16 = sub_AAB0C(v7, v10, v11, v8);
    if ( v8 <= v16 )
    {
      v8 = v16 + 1;
      if ( v10 )
        operator delete[](v10);
      v10 = (char *)operator new[](v8);
      v16 = sub_AAB0C(v7, v10, v11, v8);
    }
    sub_C13F8(v5, (unsigned int)v10, v16);
    v17 = (size_t)&v11[strlen(v11)];
    if ( v17 == v9 )
      break;
    v12 = *v5;
    v11 = (const char *)(v17 + 1);
    v13 = *(_DWORD *)(*v5 - 12);
    v14 = v13 + 1;
    if ( (unsigned int)(v13 + 1) > *(_DWORD *)(*v5 - 8) || *(_DWORD *)(v12 - 4) > 0 )
    {
      sub_C1264(v5, v13 + 1);
      v12 = *v5;
      v13 = *(_DWORD *)(*v5 - 12);
    }
    *(_BYTE *)(v12 + v13) = 0;
    v15 = *v5;
    if ( (int *)(*v5 - 12) != &dword_2FEF3C )
    {
      *(_DWORD *)(v15 - 12) = v14;
      *(_DWORD *)(v15 - 4) = 0;
      *(_BYTE *)(v15 + v14) = 0;
    }
  }
  if ( v10 )
    operator delete[](v10);
  sub_C0AC4((unsigned int *)v19 - 3);
  return v5;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00096850) --------------------------------------------------------
int sub_96850(char arg, char *a2, int a3, const char *a4, ...)
{
  char *v4; // r4
  char *v5; // r0
  const char *v6; // r7
  int v7; // r4
  unsigned int v9; // r8
  void *v10; // r5
  const char *varg_r3; // [sp+24h] [bp-4h]
  va_list arga; // [sp+28h] [bp+0h]

  va_start(arga, a4);
  varg_r3 = a4;
  v4 = a2;
  v5 = setlocale(1, 0);
  v6 = v5;
  if ( !v5 || !strcmp(v5, "C") )
    return vsprintf(v4, varg_r3, arga);
  v9 = strlen(v6) + 1;
  v10 = operator new[](v9);
  memcpy(v10, v6, v9);
  setlocale(1, "C");
  v7 = vsprintf(v4, varg_r3, arga);
  if ( v10 )
  {
    setlocale(1, (const char *)v10);
    operator delete[](v10);
  }
  return v7;
}

//----- (000968D8) --------------------------------------------------------
int __fastcall sub_968D8(int a1, const void *a2, int a3, void *a4)
{
  int v4; // r4
  int v5; // r6
  const void *v6; // r7
  int result; // r0

  v4 = a1;
  v5 = a3;
  v6 = a2;
  if ( *(_BYTE *)(a1 + 28) == 1 )
  {
    memcpy(a4, a2, a3 - (_DWORD)a2);
    result = v5;
  }
  else
  {
    if ( !*(_BYTE *)(a1 + 28) )
      sub_AA9D0(a1);
    result = (*(int (__fastcall **)(int, const void *, int))(*(_DWORD *)v4 + 28))(v4, v6, v5);
  }
  return result;
}

//----- (000974CC) --------------------------------------------------------
int __fastcall sub_974CC(_DWORD *a1, int a2, int a3)
{
  int v3; // r4

  a1[2] = a2;
  a1[1] = a3 != 0;
  *a1 = &off_F0A90;
  v3 = (int)a1;
  a1[4] = sub_AB4DC();
  sub_A80BC(v3);
  return v3;
}
// F0A90: using guessed type void *;

//----- (00097950) --------------------------------------------------------
_DWORD *__fastcall sub_97950(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4

  a1[1] = a2 != 0;
  v2 = a1;
  *a1 = &off_F0B10;
  a1[2] = sub_AB4B8();
  return v2;
}
// F0B10: using guessed type void *;

//----- (00097BC0) --------------------------------------------------------
int __fastcall sub_97BC0(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEE9C);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::ctype<char>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F152C: using guessed type int *`typeinfo for'std::ctype<char>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00097D78) --------------------------------------------------------
_DWORD *__fastcall sub_97D78(_DWORD *a1, int a2, _DWORD *a3, signed int a4, _DWORD *a5, unsigned int *a6, int *a7, int a8, int a9, unsigned int *a10, int a11, unsigned int *a12)
{
  signed int v12; // r5
  _DWORD *v13; // r10
  _DWORD *v14; // r4
  signed int v15; // r6
  unsigned int *v16; // r0
  unsigned int *v17; // r11
  int v18; // r7
  unsigned int *v19; // r8
  unsigned int *v20; // r12
  signed int v21; // r9
  signed int v22; // r3
  _DWORD *result; // r0
  signed int v24; // r9
  signed int v25; // r1
  int v26; // r9
  unsigned int *v27; // r3
  int v28; // r3
  unsigned int v29; // r3
  unsigned __int8 *v30; // r3
  unsigned __int8 *v31; // r3
  unsigned __int8 *v32; // r3
  unsigned int *v33; // ST04_4
  bool v34; // zf
  int *v35; // r3
  unsigned int *v36; // ST04_4
  unsigned int *v37; // ST04_4
  unsigned int *v38; // ST04_4
  _DWORD *v39; // [sp+Ch] [bp-34h]

  v39 = a1;
  v13 = a5;
  v14 = a3;
  v15 = a4;
  v16 = (unsigned int *)sub_97BC0(a11 + 108);
  if ( a10 == (unsigned int *)((char *)&dword_0 + 2) )
    v12 = 10;
  v17 = v16;
  if ( a10 != (unsigned int *)((char *)&dword_0 + 2) )
  {
    if ( a10 == (unsigned int *)byte_4 )
      v12 = 1000;
    else
      v12 = 1;
  }
  v18 = 0;
  v19 = 0;
  v20 = a6;
  while ( 1 )
  {
    if ( v14 )
    {
      if ( v15 != -1 )
        goto LABEL_10;
      v31 = (unsigned __int8 *)v14[2];
      if ( (unsigned int)v31 < v14[3] )
      {
        v15 = *v31;
LABEL_10:
        v21 = 0;
        goto LABEL_11;
      }
      v37 = v20;
      v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v14 + 36))(v14);
      v20 = v37;
      v15 = (signed int)v16;
      if ( v16 != (unsigned int *)-1 )
        goto LABEL_10;
      v21 = 1;
      v14 = 0;
    }
    else
    {
      v21 = 1;
    }
LABEL_11:
    if ( v13 )
    {
      if ( v20 != (unsigned int *)-1 )
        goto LABEL_13;
      v30 = (unsigned __int8 *)v13[2];
      if ( (unsigned int)v30 < v13[3] )
      {
        v20 = (unsigned int *)*v30;
LABEL_13:
        v22 = 0;
        goto LABEL_14;
      }
      v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v13 + 36))(v13);
      v20 = v16;
      if ( v16 != (unsigned int *)-1 )
        goto LABEL_13;
      v22 = 1;
      v13 = 0;
    }
    else
    {
      v22 = 1;
    }
LABEL_14:
    if ( v22 == v21 )
      break;
    v16 = a10;
    if ( v19 == a10 )
      goto LABEL_16;
    v24 = 255;
    v25 = 255;
    if ( v14 )
    {
      v16 = (unsigned int *)(v15 + 1);
      if ( v15 != -1 )
        goto LABEL_21;
      v32 = (unsigned __int8 *)v14[2];
      if ( (unsigned int)v32 < v14[3] )
      {
        v15 = *v32;
LABEL_21:
        v25 = (unsigned __int8)v15;
        v24 = (unsigned __int8)v15;
        goto LABEL_22;
      }
      v38 = v20;
      v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *, signed int))(*v14 + 36))(v14, 255);
      v20 = v38;
      v15 = (signed int)v16;
      if ( v16 != (unsigned int *)-1 )
        goto LABEL_21;
      v24 = 255;
      v14 = 0;
      v25 = 255;
    }
LABEL_22:
    v26 = (int)v17 + v24;
    v27 = (unsigned int *)*(unsigned __int8 *)(v26 + 285);
    if ( !*(_BYTE *)(v26 + 285) )
    {
      v33 = v20;
      v16 = (unsigned int *)(*(int (__fastcall **)(unsigned int *, signed int, signed int))(*v17 + 32))(v17, v25, 42);
      v20 = v33;
      if ( v16 == (unsigned int *)&word_2A )
        goto LABEL_39;
      v27 = v16;
      *(_BYTE *)(v26 + 285) = (_BYTE)v16;
    }
    v28 = (int)(v27 - 12);
    if ( (unsigned __int8)v28 > 9u )
      goto LABEL_39;
    v16 = (unsigned int *)a9;
    v18 = v28 + 10 * v18;
    if ( v12 * v18 > a9 || a8 >= v12 * v18 + v12 )
      goto LABEL_39;
    v12 /= 10;
    if ( v14 )
    {
      v29 = v14[2];
      if ( v29 >= v14[3] )
      {
        v36 = v20;
        v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v14 + 40))(v14);
        v20 = v36;
      }
      else
      {
        v14[2] = v29 + 1;
      }
      v15 = -1;
    }
    v19 = (unsigned int *)((char *)v19 + 1);
  }
  if ( v19 == a10 )
  {
LABEL_16:
    *a7 = v18;
    goto LABEL_17;
  }
LABEL_39:
  v34 = v19 == (unsigned int *)((char *)&dword_0 + 2);
  if ( v19 == (unsigned int *)((char *)&dword_0 + 2) )
    v34 = a10 == (unsigned int *)byte_4;
  if ( v34 )
    v18 -= 100;
  else
    v16 = a12;
  if ( v34 )
    v35 = a7;
  else
    v35 = (int *)*v16;
  if ( v34 )
    *v35 = v18;
  else
    *v16 = (unsigned int)v35 | 4;
LABEL_17:
  result = v39;
  *v39 = v14;
  v39[1] = v15;
  return result;
}
// 0: using guessed type int dword_0;
// 2A: using guessed type __int16;

//----- (00097F4C) --------------------------------------------------------
_DWORD *__fastcall sub_97F4C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r5
  int v10; // r8
  int v11; // r1
  _DWORD *v12; // r4
  int v13; // r6
  int v14; // r3
  signed int v15; // r8
  int v16; // r3
  bool v17; // zf
  _DWORD *result; // r0
  unsigned __int8 *v19; // r3
  char v20; // [sp+20h] [bp-38h]
  int v21; // [sp+24h] [bp-34h]
  _DWORD *v22; // [sp+28h] [bp-30h]
  int v23; // [sp+2Ch] [bp-2Ch]
  int v24; // [sp+30h] [bp-28h]
  int v25; // [sp+34h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v22 = a3;
  v23 = a4;
  sub_97BC0(a7 + 108);
  v25 = 0;
  sub_97D78(&v20, v10, v22, v23, a5, a6, &v24, 0, 9999, (unsigned int *)byte_4, a7, (unsigned int *)&v25);
  v11 = v21;
  v22 = *(_DWORD **)&v20;
  v23 = v21;
  v12 = *(_DWORD **)&v20;
  v13 = v21;
  if ( v25 )
  {
    *a8 |= 4u;
  }
  else
  {
    v11 = a9;
    if ( v24 >= 0 )
      v14 = v24 - 1900;
    else
      v14 = v24 + 100;
    *(_DWORD *)(a9 + 20) = v14;
  }
  if ( v12 )
  {
    if ( v13 == -1 )
    {
      v19 = (unsigned __int8 *)v12[2];
      if ( (unsigned int)v19 >= v12[3] )
      {
        v13 = (*(int (__fastcall **)(_DWORD *, int))(*v12 + 36))(v12, v11);
        if ( v13 == -1 )
        {
          v15 = 1;
          v12 = 0;
          goto LABEL_9;
        }
      }
      else
      {
        v13 = *v19;
      }
    }
    v15 = 0;
  }
  else
  {
    v15 = 1;
  }
LABEL_9:
  v16 = !a5 || a6 == (unsigned int *)-1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v17 = v16 == v15;
  result = v9;
  *v9 = v12;
  if ( v16 == v15 )
    v16 = *a8;
  v9[1] = v13;
  if ( v17 )
    *a8 = v16 | 2;
  return result;
}

//----- (00098048) --------------------------------------------------------
int __fastcall sub_98048(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0C8);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::codecvt<char,char,mbstate_t>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0F18: using guessed type int *`typeinfo for'std::codecvt<char,char,mbstate_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000980D8) --------------------------------------------------------
int __fastcall sub_980D8(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0B4);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::numpunct<char>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0E40: using guessed type int *`typeinfo for'std::numpunct<char>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (0009811C) --------------------------------------------------------
void *__fastcall sub_9811C(int a1, int a2)
{
  int v2; // r4
  int v3; // r10
  int v4; // r5
  char *v5; // r2
  unsigned int v6; // r0
  char *v7; // r3
  bool v8; // zf
  _BYTE *v9; // r6
  void *v10; // r0
  int v11; // r3
  int v12; // r2
  char *v13; // r2
  unsigned int v14; // r0
  char *v15; // r3
  _BYTE *v16; // r9
  void *v17; // r0
  int v18; // r3
  char *v19; // r2
  unsigned int v20; // r0
  char *v21; // r3
  _BYTE *v22; // r8
  void *v23; // r0
  int v24; // r3
  int v25; // r0
  _BYTE *v26; // r5
  char *v27; // r7
  char *v28; // r11
  void *v29; // r4
  char *v30; // r7
  char *v31; // r10
  unsigned int *v33; // r3
  signed int v34; // r2
  unsigned int *v35; // r2
  signed int v36; // r1
  unsigned int *v37; // r3
  signed int v38; // r2
  unsigned int *v39; // r2
  signed int v40; // r1
  unsigned int *v41; // r3
  signed int v42; // r2
  unsigned int *v43; // r2
  signed int v44; // r1
  void *v45; // [sp+8h] [bp-40h]
  int v46; // [sp+Ch] [bp-3Ch]
  void *v47; // [sp+10h] [bp-38h]
  int v48; // [sp+14h] [bp-34h]
  void *v49; // [sp+18h] [bp-30h]
  int v50; // [sp+1Ch] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 100) = 1;
  v3 = a2;
  v4 = sub_980D8(a2);
  (*(void (__fastcall **)(void **, int))(*(_DWORD *)v4 + 16))(&v45, v4);
  v5 = (char *)v45;
  v7 = (char *)v45 - 12;
  v6 = *((_DWORD *)v45 - 3);
  v8 = (char *)v45 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v6;
  if ( !v8 )
  {
    v39 = (unsigned int *)(v5 - 4);
    __dmb(0xFu);
    do
      v40 = __ldrex(v39);
    while ( __strex(v40 - 1, v39) );
    __dmb(0xFu);
    if ( v40 <= 0 )
      operator delete(v7);
    v6 = *(_DWORD *)(v2 + 12);
  }
  v9 = operator new[](v6);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 16))(&v46, v4);
  sub_C0440(&v46, v9, *(_DWORD *)(v2 + 12), 0);
  v10 = (void *)(v46 - 12);
  if ( (int *)(v46 - 12) != &dword_2FEF3C )
  {
    v41 = (unsigned int *)(v46 - 4);
    __dmb(0xFu);
    do
      v42 = __ldrex(v41);
    while ( __strex(v42 - 1, v41) );
    __dmb(0xFu);
    if ( v42 <= 0 )
      operator delete(v10);
  }
  v11 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v9;
  if ( v11 )
    LOBYTE(v11) = (char)*v9 > 0;
  v12 = *(_DWORD *)v4;
  *(_BYTE *)(v2 + 16) = v11;
  (*(void (__fastcall **)(void **, int))(v12 + 20))(&v47, v4);
  v13 = (char *)v47;
  v15 = (char *)v47 - 12;
  v14 = *((_DWORD *)v47 - 3);
  v8 = (char *)v47 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 24) = v14;
  if ( !v8 )
  {
    v43 = (unsigned int *)(v13 - 4);
    __dmb(0xFu);
    do
      v44 = __ldrex(v43);
    while ( __strex(v44 - 1, v43) );
    __dmb(0xFu);
    if ( v44 <= 0 )
      operator delete(v15);
    v14 = *(_DWORD *)(v2 + 24);
  }
  v16 = operator new[](v14);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 20))(&v48, v4);
  sub_C0440(&v48, v16, *(_DWORD *)(v2 + 24), 0);
  v17 = (void *)(v48 - 12);
  if ( (int *)(v48 - 12) != &dword_2FEF3C )
  {
    v37 = (unsigned int *)(v48 - 4);
    __dmb(0xFu);
    do
      v38 = __ldrex(v37);
    while ( __strex(v38 - 1, v37) );
    __dmb(0xFu);
    if ( v38 <= 0 )
      operator delete(v17);
  }
  v18 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 20) = v16;
  (*(void (**)(void))(v18 + 24))();
  v19 = (char *)v49;
  v21 = (char *)v49 - 12;
  v20 = *((_DWORD *)v49 - 3);
  v8 = (char *)v49 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 32) = v20;
  if ( !v8 )
  {
    v35 = (unsigned int *)(v19 - 4);
    __dmb(0xFu);
    do
      v36 = __ldrex(v35);
    while ( __strex(v36 - 1, v35) );
    __dmb(0xFu);
    if ( v36 <= 0 )
      operator delete(v21);
    v20 = *(_DWORD *)(v2 + 32);
  }
  v22 = operator new[](v20);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 24))(&v50, v4);
  sub_C0440(&v50, v22, *(_DWORD *)(v2 + 32), 0);
  v23 = (void *)(v50 - 12);
  if ( (int *)(v50 - 12) != &dword_2FEF3C )
  {
    v33 = (unsigned int *)(v50 - 4);
    __dmb(0xFu);
    do
      v34 = __ldrex(v33);
    while ( __strex(v34 - 1, v33) );
    __dmb(0xFu);
    if ( v34 <= 0 )
      operator delete(v23);
  }
  v24 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 28) = v22;
  *(_BYTE *)(v2 + 36) = (*(int (__fastcall **)(int))(v24 + 8))(v4);
  *(_BYTE *)(v2 + 37) = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 12))(v4);
  v25 = sub_97BC0(v3);
  v26 = (_BYTE *)v25;
  v27 = off_F3C58[0];
  v28 = off_F3C58[0] + 36;
  if ( *(_BYTE *)(v25 + 28) == 1 )
  {
    memcpy((void *)(v2 + 38), off_F3C58[0], 0x24u);
  }
  else
  {
    if ( !*(_BYTE *)(v25 + 28) )
      sub_AA9D0(v25);
    (*(void (__fastcall **)(_BYTE *, char *, char *, int))(*(_DWORD *)v26 + 28))(v26, v27, v28, v2 + 38);
  }
  v29 = (void *)(v2 + 74);
  v30 = off_F3C54[0];
  v31 = off_F3C54[0] + 26;
  if ( v26[28] == 1 )
    return memcpy(v29, off_F3C54[0], 0x1Au);
  if ( !v26[28] )
    sub_AA9D0((int)v26);
  return (void *)(*(int (__fastcall **)(_BYTE *, char *, char *, void *))(*(_DWORD *)v26 + 28))(v26, v30, v31, v29);
}
// F3C54: using guessed type char *off_F3C54[17];
// F3C58: using guessed type char *off_F3C58[16];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00098454) --------------------------------------------------------
int __fastcall sub_98454(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0AC);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0D38: using guessed type int *`typeinfo for'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00098498) --------------------------------------------------------
int __fastcall sub_98498(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0B0);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0E70: using guessed type int *`typeinfo for'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000984DC) --------------------------------------------------------
int __fastcall sub_984DC(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0C0);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::moneypunct<char,true>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0E20: using guessed type int *`typeinfo for'std::moneypunct<char,true>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00098520) --------------------------------------------------------
void *__fastcall sub_98520(int a1, int a2)
{
  int v2; // r5
  int v3; // r10
  int v4; // r4
  int v5; // r0
  void (__fastcall *v6)(void **, int); // r3
  char *v7; // r2
  unsigned int v8; // r0
  char *v9; // r3
  bool v10; // zf
  _BYTE *v11; // r7
  void *v12; // r0
  int v13; // r3
  int v14; // r2
  char *v15; // r2
  unsigned int v16; // r0
  char *v17; // r3
  void *v18; // r0
  int v19; // r3
  char *v20; // r2
  unsigned int v21; // r0
  char *v22; // r3
  _BYTE *v23; // r9
  void *v24; // r0
  int v25; // r3
  char *v26; // r2
  unsigned int v27; // r0
  char *v28; // r3
  _BYTE *v29; // r8
  void *v30; // r0
  int v31; // r3
  int v32; // r0
  int v33; // r2
  int v34; // r0
  int v35; // r0
  int v36; // r4
  void *v37; // r5
  char *v38; // r6
  char *v39; // r10
  unsigned int *v41; // r2
  signed int v42; // r1
  unsigned int *v43; // r3
  signed int v44; // r2
  unsigned int *v45; // r2
  signed int v46; // r1
  unsigned int *v47; // r3
  signed int v48; // r2
  unsigned int *v49; // r2
  signed int v50; // r1
  unsigned int *v51; // r3
  signed int v52; // r2
  unsigned int *v53; // r2
  signed int v54; // r1
  unsigned int *v55; // r3
  signed int v56; // r2
  _BYTE *v57; // [sp+4h] [bp-5Ch]
  void *v58; // [sp+8h] [bp-58h]
  int v59; // [sp+Ch] [bp-54h]
  void *v60; // [sp+10h] [bp-50h]
  int v61; // [sp+14h] [bp-4Ch]
  void *v62; // [sp+18h] [bp-48h]
  int v63; // [sp+1Ch] [bp-44h]
  void *v64; // [sp+20h] [bp-40h]
  int v65; // [sp+24h] [bp-3Ch]
  int v66; // [sp+28h] [bp-38h]
  int v67; // [sp+2Ch] [bp-34h]
  int v68; // [sp+30h] [bp-30h]
  int v69; // [sp+34h] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 67) = 1;
  v3 = a2;
  v4 = sub_984DC(a2);
  *(_BYTE *)(v2 + 17) = (*(int (**)(void))(*(_DWORD *)v4 + 8))();
  *(_BYTE *)(v2 + 18) = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 12))(v4);
  v5 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 32))(v4);
  v6 = *(void (__fastcall **)(void **, int))(*(_DWORD *)v4 + 16);
  *(_DWORD *)(v2 + 44) = v5;
  v6(&v58, v4);
  v7 = (char *)v58;
  v9 = (char *)v58 - 12;
  v8 = *((_DWORD *)v58 - 3);
  v10 = (char *)v58 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v8;
  if ( !v10 )
  {
    v41 = (unsigned int *)(v7 - 4);
    __dmb(0xFu);
    do
      v42 = __ldrex(v41);
    while ( __strex(v42 - 1, v41) );
    __dmb(0xFu);
    if ( v42 <= 0 )
      operator delete(v9);
    v8 = *(_DWORD *)(v2 + 12);
  }
  v11 = operator new[](v8);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 16))(&v59, v4);
  sub_C0440(&v59, v11, *(_DWORD *)(v2 + 12), 0);
  v12 = (void *)(v59 - 12);
  if ( (int *)(v59 - 12) != &dword_2FEF3C )
  {
    v51 = (unsigned int *)(v59 - 4);
    __dmb(0xFu);
    do
      v52 = __ldrex(v51);
    while ( __strex(v52 - 1, v51) );
    __dmb(0xFu);
    if ( v52 <= 0 )
      operator delete(v12);
  }
  v13 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v11;
  if ( v13 )
    LOBYTE(v13) = (char)*v11 > 0;
  v14 = *(_DWORD *)v4;
  *(_BYTE *)(v2 + 16) = v13;
  (*(void (__fastcall **)(void **, int))(v14 + 20))(&v60, v4);
  v15 = (char *)v60;
  v17 = (char *)v60 - 12;
  v16 = *((_DWORD *)v60 - 3);
  v10 = (char *)v60 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 24) = v16;
  if ( !v10 )
  {
    v49 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v50 = __ldrex(v49);
    while ( __strex(v50 - 1, v49) );
    __dmb(0xFu);
    if ( v50 <= 0 )
      operator delete(v17);
    v16 = *(_DWORD *)(v2 + 24);
  }
  v57 = operator new[](v16);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 20))(&v61, v4);
  sub_C0440(&v61, v57, *(_DWORD *)(v2 + 24), 0);
  v18 = (void *)(v61 - 12);
  if ( (int *)(v61 - 12) != &dword_2FEF3C )
  {
    v47 = (unsigned int *)(v61 - 4);
    __dmb(0xFu);
    do
      v48 = __ldrex(v47);
    while ( __strex(v48 - 1, v47) );
    __dmb(0xFu);
    if ( v48 <= 0 )
      operator delete(v18);
  }
  v19 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 20) = v57;
  (*(void (__fastcall **)(void **, int))(v19 + 24))(&v62, v4);
  v20 = (char *)v62;
  v22 = (char *)v62 - 12;
  v21 = *((_DWORD *)v62 - 3);
  v10 = (char *)v62 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 32) = v21;
  if ( !v10 )
  {
    v45 = (unsigned int *)(v20 - 4);
    __dmb(0xFu);
    do
      v46 = __ldrex(v45);
    while ( __strex(v46 - 1, v45) );
    __dmb(0xFu);
    if ( v46 <= 0 )
      operator delete(v22);
    v21 = *(_DWORD *)(v2 + 32);
  }
  v23 = operator new[](v21);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 24))(&v63, v4);
  sub_C0440(&v63, v23, *(_DWORD *)(v2 + 32), 0);
  v24 = (void *)(v63 - 12);
  if ( (int *)(v63 - 12) != &dword_2FEF3C )
  {
    v55 = (unsigned int *)(v63 - 4);
    __dmb(0xFu);
    do
      v56 = __ldrex(v55);
    while ( __strex(v56 - 1, v55) );
    __dmb(0xFu);
    if ( v56 <= 0 )
      operator delete(v24);
  }
  v25 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 28) = v23;
  (*(void (__fastcall **)(void **, int))(v25 + 28))(&v64, v4);
  v26 = (char *)v64;
  v28 = (char *)v64 - 12;
  v27 = *((_DWORD *)v64 - 3);
  v10 = (char *)v64 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 40) = v27;
  if ( !v10 )
  {
    v53 = (unsigned int *)(v26 - 4);
    __dmb(0xFu);
    do
      v54 = __ldrex(v53);
    while ( __strex(v54 - 1, v53) );
    __dmb(0xFu);
    if ( v54 <= 0 )
      operator delete(v28);
    v27 = *(_DWORD *)(v2 + 40);
  }
  v29 = operator new[](v27);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 28))(&v65, v4);
  sub_C0440(&v65, v29, *(_DWORD *)(v2 + 40), 0);
  v30 = (void *)(v65 - 12);
  if ( (int *)(v65 - 12) != &dword_2FEF3C )
  {
    v43 = (unsigned int *)(v65 - 4);
    __dmb(0xFu);
    do
      v44 = __ldrex(v43);
    while ( __strex(v44 - 1, v43) );
    __dmb(0xFu);
    if ( v44 <= 0 )
      operator delete(v30);
  }
  v31 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 36) = v29;
  v32 = (*(int (__fastcall **)(int))(v31 + 36))(v4);
  *(_DWORD *)(v2 + 48) = v32;
  v33 = *(_DWORD *)v4;
  v67 = v32;
  v66 = v32;
  v34 = (*(int (__fastcall **)(int))(v33 + 40))(v4);
  *(_DWORD *)(v2 + 52) = v34;
  v69 = v34;
  v68 = v34;
  v35 = sub_97BC0(v3);
  v36 = v35;
  v37 = (void *)(v2 + 56);
  v38 = off_F3C5C[0];
  v39 = off_F3C5C[0] + 11;
  if ( *(_BYTE *)(v35 + 28) == 1 )
    return memcpy(v37, off_F3C5C[0], 0xBu);
  if ( !*(_BYTE *)(v35 + 28) )
    sub_AA9D0(v35);
  return (void *)(*(int (__fastcall **)(int, char *, char *, void *))(*(_DWORD *)v36 + 28))(v36, v38, v39, v37);
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00098910) --------------------------------------------------------
int __fastcall sub_98910(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0C4);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::moneypunct<char,false>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0D90: using guessed type int *`typeinfo for'std::moneypunct<char,false>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00098954) --------------------------------------------------------
void *__fastcall sub_98954(int a1, int a2)
{
  int v2; // r5
  int v3; // r10
  int v4; // r4
  int v5; // r0
  void (__fastcall *v6)(void **, int); // r3
  char *v7; // r2
  unsigned int v8; // r0
  char *v9; // r3
  bool v10; // zf
  _BYTE *v11; // r7
  void *v12; // r0
  int v13; // r3
  int v14; // r2
  char *v15; // r2
  unsigned int v16; // r0
  char *v17; // r3
  void *v18; // r0
  int v19; // r3
  char *v20; // r2
  unsigned int v21; // r0
  char *v22; // r3
  _BYTE *v23; // r9
  void *v24; // r0
  int v25; // r3
  char *v26; // r2
  unsigned int v27; // r0
  char *v28; // r3
  _BYTE *v29; // r8
  void *v30; // r0
  int v31; // r3
  int v32; // r0
  int v33; // r2
  int v34; // r0
  int v35; // r0
  int v36; // r4
  void *v37; // r5
  char *v38; // r6
  char *v39; // r10
  unsigned int *v41; // r2
  signed int v42; // r1
  unsigned int *v43; // r3
  signed int v44; // r2
  unsigned int *v45; // r2
  signed int v46; // r1
  unsigned int *v47; // r3
  signed int v48; // r2
  unsigned int *v49; // r2
  signed int v50; // r1
  unsigned int *v51; // r3
  signed int v52; // r2
  unsigned int *v53; // r2
  signed int v54; // r1
  unsigned int *v55; // r3
  signed int v56; // r2
  _BYTE *v57; // [sp+4h] [bp-5Ch]
  void *v58; // [sp+8h] [bp-58h]
  int v59; // [sp+Ch] [bp-54h]
  void *v60; // [sp+10h] [bp-50h]
  int v61; // [sp+14h] [bp-4Ch]
  void *v62; // [sp+18h] [bp-48h]
  int v63; // [sp+1Ch] [bp-44h]
  void *v64; // [sp+20h] [bp-40h]
  int v65; // [sp+24h] [bp-3Ch]
  int v66; // [sp+28h] [bp-38h]
  int v67; // [sp+2Ch] [bp-34h]
  int v68; // [sp+30h] [bp-30h]
  int v69; // [sp+34h] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 67) = 1;
  v3 = a2;
  v4 = sub_98910(a2);
  *(_BYTE *)(v2 + 17) = (*(int (**)(void))(*(_DWORD *)v4 + 8))();
  *(_BYTE *)(v2 + 18) = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 12))(v4);
  v5 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 32))(v4);
  v6 = *(void (__fastcall **)(void **, int))(*(_DWORD *)v4 + 16);
  *(_DWORD *)(v2 + 44) = v5;
  v6(&v58, v4);
  v7 = (char *)v58;
  v9 = (char *)v58 - 12;
  v8 = *((_DWORD *)v58 - 3);
  v10 = (char *)v58 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v8;
  if ( !v10 )
  {
    v41 = (unsigned int *)(v7 - 4);
    __dmb(0xFu);
    do
      v42 = __ldrex(v41);
    while ( __strex(v42 - 1, v41) );
    __dmb(0xFu);
    if ( v42 <= 0 )
      operator delete(v9);
    v8 = *(_DWORD *)(v2 + 12);
  }
  v11 = operator new[](v8);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 16))(&v59, v4);
  sub_C0440(&v59, v11, *(_DWORD *)(v2 + 12), 0);
  v12 = (void *)(v59 - 12);
  if ( (int *)(v59 - 12) != &dword_2FEF3C )
  {
    v51 = (unsigned int *)(v59 - 4);
    __dmb(0xFu);
    do
      v52 = __ldrex(v51);
    while ( __strex(v52 - 1, v51) );
    __dmb(0xFu);
    if ( v52 <= 0 )
      operator delete(v12);
  }
  v13 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v11;
  if ( v13 )
    LOBYTE(v13) = (char)*v11 > 0;
  v14 = *(_DWORD *)v4;
  *(_BYTE *)(v2 + 16) = v13;
  (*(void (__fastcall **)(void **, int))(v14 + 20))(&v60, v4);
  v15 = (char *)v60;
  v17 = (char *)v60 - 12;
  v16 = *((_DWORD *)v60 - 3);
  v10 = (char *)v60 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 24) = v16;
  if ( !v10 )
  {
    v49 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v50 = __ldrex(v49);
    while ( __strex(v50 - 1, v49) );
    __dmb(0xFu);
    if ( v50 <= 0 )
      operator delete(v17);
    v16 = *(_DWORD *)(v2 + 24);
  }
  v57 = operator new[](v16);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 20))(&v61, v4);
  sub_C0440(&v61, v57, *(_DWORD *)(v2 + 24), 0);
  v18 = (void *)(v61 - 12);
  if ( (int *)(v61 - 12) != &dword_2FEF3C )
  {
    v47 = (unsigned int *)(v61 - 4);
    __dmb(0xFu);
    do
      v48 = __ldrex(v47);
    while ( __strex(v48 - 1, v47) );
    __dmb(0xFu);
    if ( v48 <= 0 )
      operator delete(v18);
  }
  v19 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 20) = v57;
  (*(void (__fastcall **)(void **, int))(v19 + 24))(&v62, v4);
  v20 = (char *)v62;
  v22 = (char *)v62 - 12;
  v21 = *((_DWORD *)v62 - 3);
  v10 = (char *)v62 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 32) = v21;
  if ( !v10 )
  {
    v45 = (unsigned int *)(v20 - 4);
    __dmb(0xFu);
    do
      v46 = __ldrex(v45);
    while ( __strex(v46 - 1, v45) );
    __dmb(0xFu);
    if ( v46 <= 0 )
      operator delete(v22);
    v21 = *(_DWORD *)(v2 + 32);
  }
  v23 = operator new[](v21);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 24))(&v63, v4);
  sub_C0440(&v63, v23, *(_DWORD *)(v2 + 32), 0);
  v24 = (void *)(v63 - 12);
  if ( (int *)(v63 - 12) != &dword_2FEF3C )
  {
    v55 = (unsigned int *)(v63 - 4);
    __dmb(0xFu);
    do
      v56 = __ldrex(v55);
    while ( __strex(v56 - 1, v55) );
    __dmb(0xFu);
    if ( v56 <= 0 )
      operator delete(v24);
  }
  v25 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 28) = v23;
  (*(void (__fastcall **)(void **, int))(v25 + 28))(&v64, v4);
  v26 = (char *)v64;
  v28 = (char *)v64 - 12;
  v27 = *((_DWORD *)v64 - 3);
  v10 = (char *)v64 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 40) = v27;
  if ( !v10 )
  {
    v53 = (unsigned int *)(v26 - 4);
    __dmb(0xFu);
    do
      v54 = __ldrex(v53);
    while ( __strex(v54 - 1, v53) );
    __dmb(0xFu);
    if ( v54 <= 0 )
      operator delete(v28);
    v27 = *(_DWORD *)(v2 + 40);
  }
  v29 = operator new[](v27);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 28))(&v65, v4);
  sub_C0440(&v65, v29, *(_DWORD *)(v2 + 40), 0);
  v30 = (void *)(v65 - 12);
  if ( (int *)(v65 - 12) != &dword_2FEF3C )
  {
    v43 = (unsigned int *)(v65 - 4);
    __dmb(0xFu);
    do
      v44 = __ldrex(v43);
    while ( __strex(v44 - 1, v43) );
    __dmb(0xFu);
    if ( v44 <= 0 )
      operator delete(v30);
  }
  v31 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 36) = v29;
  v32 = (*(int (__fastcall **)(int))(v31 + 36))(v4);
  *(_DWORD *)(v2 + 48) = v32;
  v33 = *(_DWORD *)v4;
  v67 = v32;
  v66 = v32;
  v34 = (*(int (__fastcall **)(int))(v33 + 40))(v4);
  *(_DWORD *)(v2 + 52) = v34;
  v69 = v34;
  v68 = v34;
  v35 = sub_97BC0(v3);
  v36 = v35;
  v37 = (void *)(v2 + 56);
  v38 = off_F3C5C[0];
  v39 = off_F3C5C[0] + 11;
  if ( *(_BYTE *)(v35 + 28) == 1 )
    return memcpy(v37, off_F3C5C[0], 0xBu);
  if ( !*(_BYTE *)(v35 + 28) )
    sub_AA9D0(v35);
  return (void *)(*(int (__fastcall **)(int, char *, char *, void *))(*(_DWORD *)v36 + 28))(v36, v38, v39, v37);
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (00098DCC) --------------------------------------------------------
int __fastcall sub_98DCC(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0A8);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::__timepunct<char>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0E14: using guessed type int *`typeinfo for'std::__timepunct<char>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00098E10) --------------------------------------------------------
int __fastcall sub_98E10(int a1, int a2, int a3, char a4, int a5, int a6, const struct tm *a7, char a8, char a9)
{
  int v9; // r5
  _BYTE *v10; // r4
  int v11; // r10
  char v12; // r0
  char v13; // r4
  size_t v14; // r8
  int result; // r0
  int v16; // [sp+8h] [bp-B0h]
  char v17; // [sp+Ch] [bp-ACh]
  char v18; // [sp+14h] [bp-A4h]
  char v19; // [sp+15h] [bp-A3h]
  char v20; // [sp+16h] [bp-A2h]
  char v21; // [sp+17h] [bp-A1h]
  char v22; // [sp+18h] [bp-A0h]

  v9 = a1;
  v16 = a3;
  v17 = a4;
  v10 = (_BYTE *)sub_97BC0(a5 + 108);
  v11 = sub_98DCC(a5 + 108);
  if ( v10[28] )
  {
    v12 = v10[66];
  }
  else
  {
    sub_AA9D0((int)v10);
    v12 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v10 + 24))(v10, 37);
  }
  v18 = v12;
  if ( a9 )
  {
    v19 = a9;
    v20 = a8;
    v21 = 0;
  }
  else
  {
    v19 = a8;
    v20 = 0;
  }
  sub_A8048(v11, &v22, 0x80u, &v18, a7);
  v13 = v17;
  v14 = strlen(&v22);
  if ( !v17 && v14 != (*(int (__fastcall **)(int, char *, size_t))(*(_DWORD *)v16 + 48))(v16, &v22, v14) )
    v13 = 1;
  result = v9;
  *(_DWORD *)v9 = v16;
  *(_BYTE *)(v9 + 4) = v13;
  return result;
}

//----- (00098F80) --------------------------------------------------------
_DWORD *__fastcall sub_98F80(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEE9C);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::ctype<char>,
                          0) != 0);
  return result;
}
// F152C: using guessed type int *`typeinfo for'std::ctype<char>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00098FCC) --------------------------------------------------------
_DWORD *__fastcall sub_98FCC(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0C8);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::codecvt<char,char,mbstate_t>,
                          0) != 0);
  return result;
}
// F0F18: using guessed type int *`typeinfo for'std::codecvt<char,char,mbstate_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000990A0) --------------------------------------------------------
_DWORD *__fastcall sub_990A0(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0AC);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>,
                          0) != 0);
  return result;
}
// F0D38: using guessed type int *`typeinfo for'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000990E4) --------------------------------------------------------
_DWORD *__fastcall sub_990E4(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0B0);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>,
                          0) != 0);
  return result;
}
// F0E70: using guessed type int *`typeinfo for'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (00099304) --------------------------------------------------------
_BYTE *__fastcall sub_99304(_BYTE *result, char a2, unsigned __int8 *a3, int a4, int a5, char *a6)
{
  int v6; // r12
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r7
  int v10; // r6
  char *v11; // r4
  bool v12; // cf
  char *v13; // r3
  _BYTE *v14; // r5
  char v15; // t1
  int v16; // r3
  int v17; // r9
  unsigned __int8 v18; // r8
  int v19; // r3
  char *v20; // r4
  char v21; // t1
  int v22; // r8
  int v23; // r12
  int v24; // r8
  char v25; // r5
  int v26; // t1
  int v27; // r3
  char *v28; // r2
  char v29; // t1
  int v30; // r5

  v6 = 0;
  v7 = a4 - 1;
  v8 = *a3;
  v9 = 0;
  v10 = a5;
  v11 = a6;
  while ( (signed int)&v11[-a5] > v8 && (char)v8 > 0 )
  {
    v12 = v9 >= v7;
    v11 -= v8;
    if ( v9 >= v7 )
      ++v6;
    else
      ++v9;
    if ( !v12 )
      v8 = a3[v9];
  }
  if ( v11 != (char *)a5 )
  {
    v13 = (char *)a5;
    v14 = result;
    do
    {
      v15 = *v13++;
      *v14++ = v15;
    }
    while ( v13 != v11 );
    v16 = (int)&v13[-a5];
    result += v16;
    v10 = a5 + v16;
  }
  while ( 1 )
  {
    v12 = v6-- != 0;
    if ( !v12 )
      break;
    while ( 1 )
    {
      *result = a2;
      v17 = (int)(result + 1);
      v18 = a3[v9];
      if ( !a3[v9] )
        break;
      LOBYTE(v19) = a3[v9];
      v20 = (char *)v10;
      do
      {
        v21 = *v20++;
        v19 = (unsigned __int8)(v19 - 1);
        (result++)[1] = v21;
      }
      while ( v19 );
      v12 = v6-- != 0;
      v22 = (unsigned __int8)(v18 - 1) + 1;
      result = (_BYTE *)(v17 + v22);
      v10 += v22;
      if ( !v12 )
        goto LABEL_20;
    }
    ++result;
  }
LABEL_20:
  v23 = (int)&a3[v9];
  while ( 1 )
  {
    v12 = v9-- != 0;
    if ( !v12 )
      break;
    while ( 1 )
    {
      *result = a2;
      v24 = (int)(result + 1);
      v26 = *(unsigned __int8 *)(v23-- - 1);
      v25 = v26;
      if ( !v26 )
        break;
      LOBYTE(v27) = v25;
      v28 = (char *)v10;
      do
      {
        v29 = *v28++;
        v27 = (unsigned __int8)(v27 - 1);
        (result++)[1] = v29;
      }
      while ( v27 );
      v12 = v9-- != 0;
      v30 = (unsigned __int8)(v25 - 1) + 1;
      result = (_BYTE *)(v24 + v30);
      v10 += v30;
      if ( !v12 )
        return result;
    }
    ++result;
  }
  return result;
}

//----- (000993E4) --------------------------------------------------------
_BYTE *__fastcall sub_993E4(int a1, unsigned __int8 *a2, int a3, char a4, char *a5, _BYTE *a6, int a7, _DWORD *a8)
{
  _BYTE *v8; // r0
  int v9; // r6
  _BYTE *result; // r0

  if ( a5 )
  {
    v8 = sub_99304(a6, a4, a2, a3, a7, a5);
    v9 = v8 - a6;
    memcpy(v8, a5, *a8 - (_DWORD)&a5[-a7]);
    result = (_BYTE *)(*a8 - (_DWORD)&a5[-a7] + v9);
  }
  else
  {
    result = (_BYTE *)(sub_99304(a6, a4, a2, a3, a7, (char *)(a7 + *a8)) - a6);
  }
  *a8 = result;
  return result;
}

//----- (0009943C) --------------------------------------------------------
_BYTE *__fastcall sub_9943C(int a1, unsigned __int8 *a2, int a3, char a4, int a5, _BYTE *a6, int a7, _DWORD *a8)
{
  _BYTE *result; // r0

  result = (_BYTE *)(sub_99304(a6, a4, a2, a3, a7, (char *)(*a8 + a7)) - a6);
  *a8 = result;
  return result;
}

//----- (00099464) --------------------------------------------------------
int *__fastcall sub_99464(int *a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned __int8 **a7)
{
  int *v7; // r8
  int v8; // r10
  int v9; // r0
  int v10; // r4
  int v11; // r6
  int v12; // r5
  _BYTE *v13; // r5
  int v14; // r0
  unsigned int v15; // r0
  int v16; // r1
  int v17; // r3
  unsigned __int8 *v18; // r4
  size_t v19; // r4
  int v20; // r3
  signed int v21; // r9
  _BYTE *v22; // r0
  _BYTE *v23; // r0
  _DWORD *v24; // r3
  unsigned int v25; // r2
  int v26; // r3
  int v27; // r2
  unsigned int v28; // ST1C_4
  unsigned int v29; // r9
  signed int v30; // r4
  bool v31; // cf
  signed int v32; // r1
  unsigned int *v33; // r1
  unsigned int v34; // r3
  int v35; // r0
  int v36; // r1
  char *v38; // r2
  unsigned int *v39; // r0
  unsigned int *v40; // r6
  unsigned int v41; // [sp+10h] [bp-60h]
  int v42; // [sp+14h] [bp-5Ch]
  int v43; // [sp+18h] [bp-58h]
  _BYTE *v44; // [sp+1Ch] [bp-54h]
  unsigned int v45; // [sp+1Ch] [bp-54h]
  char *v46; // [sp+24h] [bp-4Ch]
  int v47; // [sp+28h] [bp-48h]
  signed int v48; // [sp+2Ch] [bp-44h]
  int v49; // [sp+30h] [bp-40h]
  int v50; // [sp+34h] [bp-3Ch]
  int v51; // [sp+3Ch] [bp-34h]
  _DWORD *v52; // [sp+40h] [bp-30h]
  unsigned int *v53; // [sp+44h] [bp-2Ch]

  v7 = a1;
  v49 = a3;
  v50 = a4;
  v42 = a3;
  v43 = (unsigned __int8)a4;
  v8 = sub_97BC0((int)(a5 + 27));
  v9 = sub_AB850((int *)&unk_2FE0C0);
  v10 = *(_DWORD *)(a5[27] + 12);
  v11 = *(_DWORD *)(v10 + 4 * v9);
  v12 = v9;
  if ( !v11 )
  {
    v39 = (unsigned int *)operator new(0x44u);
    v39[1] = 0;
    v39[2] = 0;
    v39[3] = 0;
    *v39 = (unsigned int)&off_F0CE0;
    v40 = v39;
    *((_BYTE *)v39 + 16) = 0;
    *((_BYTE *)v39 + 17) = 0;
    *((_BYTE *)v39 + 18) = 0;
    v39[5] = 0;
    v39[6] = 0;
    v39[7] = 0;
    v39[8] = 0;
    v39[9] = 0;
    v39[10] = 0;
    v39[11] = 0;
    *((_BYTE *)v39 + 48) = 0;
    *((_BYTE *)v39 + 49) = 0;
    *((_BYTE *)v39 + 50) = 0;
    *((_BYTE *)v39 + 51) = 0;
    *((_BYTE *)v39 + 52) = 0;
    *((_BYTE *)v39 + 53) = 0;
    *((_BYTE *)v39 + 54) = 0;
    *((_BYTE *)v39 + 55) = 0;
    *((_BYTE *)v39 + 67) = 0;
    sub_98520((int)v39, (int)(a5 + 27));
    sub_AB778(a5[27], v40, v12);
    v11 = *(_DWORD *)(v10 + 4 * v12);
  }
  v13 = *a7;
  if ( **a7 == *(unsigned __int8 *)(v11 + 56) )
  {
    v38 = *(char **)(v11 + 36);
    v14 = *((_DWORD *)v13 - 3);
    v51 = *(_DWORD *)(v11 + 52);
    v46 = v38;
    v41 = *(_DWORD *)(v11 + 40);
    if ( !v14 )
      goto LABEL_44;
    ++v13;
  }
  else
  {
    v46 = *(char **)(v11 + 28);
    v14 = *((_DWORD *)v13 - 3);
    v41 = *(_DWORD *)(v11 + 32);
    v51 = *(_DWORD *)(v11 + 48);
  }
  v15 = (unsigned int)&v13[v14];
  if ( (unsigned int)v13 < v15 )
  {
    v16 = *(_DWORD *)(v8 + 24);
    if ( *(_BYTE *)(v16 + (unsigned __int8)*v13) & 4 )
    {
      v17 = (int)(v13 + 1);
      while ( 1 )
      {
        v18 = (unsigned __int8 *)v17;
        if ( v17 == v15 )
          break;
        ++v17;
        if ( !(*(_BYTE *)(v16 + *v18) & 4) )
        {
          v19 = v18 - v13;
          goto LABEL_10;
        }
      }
      v19 = v17 - (_DWORD)v13;
LABEL_10:
      if ( !v19 )
        goto LABEL_44;
      v52 = &unk_2FEF48;
      sub_C1264(&v52, 2 * v19);
      v20 = *(_DWORD *)(v11 + 44);
      v21 = v19 - v20;
      if ( (signed int)(v19 - v20) > 0 )
      {
        v21 &= ~(v20 >> 32);
        if ( v20 < 0 )
          v21 = v19;
        if ( *(_DWORD *)(v11 + 12) )
        {
          sub_C0DB8((int *)&v52, 0, *(v52 - 3), 2 * v21, 0);
          v22 = v52;
          if ( *(v52 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v52);
            v22 = v52;
          }
          v23 = sub_99304(
                  v22,
                  *(_BYTE *)(v11 + 18),
                  *(unsigned __int8 **)(v11 + 8),
                  *(_DWORD *)(v11 + 12),
                  (int)v13,
                  &v13[v21]);
          v24 = v52;
          v44 = v23;
          if ( *(v52 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v52);
            v24 = v52;
          }
          v25 = *(v24 - 3);
          if ( v44 - (_BYTE *)v24 > v25 )
            sub_BFC08("basic_string::erase");
          sub_C0AFC((int *)&v52, v44 - (_BYTE *)v24, v25 - (v44 - (_BYTE *)v24), 0);
          v20 = *(_DWORD *)(v11 + 44);
        }
        else
        {
          sub_C0F20((int *)&v52, v13, v21);
          v20 = *(_DWORD *)(v11 + 44);
        }
      }
      if ( v20 > 0 )
      {
        sub_C15D0((int *)&v52, *(_BYTE *)(v11 + 17));
        if ( v21 < 0 )
        {
          sub_C1500((int *)&v52, -v21, *(unsigned __int8 *)(v11 + 57));
          sub_C13F8((unsigned int *)&v52, (unsigned int)v13, v19);
        }
        else
        {
          sub_C13F8((unsigned int *)&v52, (unsigned int)&v13[v21], *(_DWORD *)(v11 + 44));
        }
      }
      v26 = a5[3] & 0x200;
      v47 = a5[3] & 0xB0;
      v27 = *(v52 - 3) + v41;
      if ( v26 )
        v26 = *(_DWORD *)(v11 + 24);
      v28 = v27 + v26;
      v53 = (unsigned int *)&unk_2FEF48;
      sub_C1264(&v53, 2 * (v27 + v26));
      v29 = a5[2];
      v30 = 1;
      v31 = v28 >= v29;
      v45 = v29 - v28;
      v32 = !v31;
      if ( v47 != 16 )
        v32 = 0;
      v48 = v32;
      while ( 1 )
      {
        switch ( *((unsigned __int8 *)&v51 + v30 - 1) )
        {
          case 0u:
            if ( !v48 )
              goto def_99616;
            goto LABEL_54;
          case 1u:
            if ( v48 )
LABEL_54:
              sub_C1500((int *)&v53, v45, a6);
            else
              sub_C15D0((int *)&v53, a6);
            goto def_99616;
          case 2u:
            if ( a5[3] & 0x200 )
              sub_C13F8((unsigned int *)&v53, *(_DWORD *)(v11 + 20), *(_DWORD *)(v11 + 24));
            goto def_99616;
          case 3u:
            if ( v41 )
            {
              sub_C15D0((int *)&v53, *v46);
def_99616:
              if ( v30 == 4 )
              {
                if ( v41 > 1 )
                  sub_C13F8((unsigned int *)&v53, (unsigned int)(v46 + 1), v41 - 1);
LABEL_35:
                v33 = v53;
                v34 = *(v53 - 3);
                if ( v29 > v34 )
                {
                  if ( v47 == 32 )
                    sub_C1500((int *)&v53, v29 - v34, a6);
                  else
                    sub_C0DB8((int *)&v53, 0, 0, v29 - v34, a6);
                  v33 = v53;
                }
                else
                {
                  v29 = *(v53 - 3);
                }
                if ( !v43 )
                {
                  v35 = (*(int (**)(void))(*(_DWORD *)v42 + 48))();
                  v33 = v53;
                  if ( v29 != v35 )
                    LOBYTE(v43) = 1;
                }
                sub_C0AC4(v33 - 3);
                sub_C0AC4(v52 - 3);
                goto LABEL_44;
              }
            }
            else if ( v30 == 4 )
            {
              goto LABEL_35;
            }
            ++v30;
            break;
          case 4u:
            sub_C12E4((int *)&v53, (_BYTE **)&v52);
            goto def_99616;
          default:
            goto def_99616;
        }
      }
    }
  }
LABEL_44:
  v49 = v42;
  LOBYTE(v50) = v43;
  v36 = v50;
  a5[2] = 0;
  *v7 = v42;
  v7[1] = v36;
  return v7;
}
// F0CE0: using guessed type void *off_F0CE0;

//----- (00099824) --------------------------------------------------------
int *__fastcall sub_99824(int *a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned __int8 **a7)
{
  int *v7; // r8
  int v8; // r10
  int v9; // r0
  int v10; // r4
  int v11; // r6
  int v12; // r5
  _BYTE *v13; // r5
  int v14; // r0
  unsigned int v15; // r0
  int v16; // r1
  int v17; // r3
  unsigned __int8 *v18; // r4
  size_t v19; // r4
  int v20; // r3
  signed int v21; // r9
  _BYTE *v22; // r0
  _BYTE *v23; // r0
  _DWORD *v24; // r3
  unsigned int v25; // r2
  int v26; // r3
  int v27; // r2
  unsigned int v28; // ST1C_4
  unsigned int v29; // r9
  signed int v30; // r4
  bool v31; // cf
  signed int v32; // r1
  unsigned int *v33; // r1
  unsigned int v34; // r3
  int v35; // r0
  int v36; // r1
  char *v38; // r2
  unsigned int *v39; // r0
  unsigned int *v40; // r6
  unsigned int v41; // [sp+10h] [bp-60h]
  int v42; // [sp+14h] [bp-5Ch]
  int v43; // [sp+18h] [bp-58h]
  _BYTE *v44; // [sp+1Ch] [bp-54h]
  unsigned int v45; // [sp+1Ch] [bp-54h]
  char *v46; // [sp+24h] [bp-4Ch]
  int v47; // [sp+28h] [bp-48h]
  signed int v48; // [sp+2Ch] [bp-44h]
  int v49; // [sp+30h] [bp-40h]
  int v50; // [sp+34h] [bp-3Ch]
  int v51; // [sp+3Ch] [bp-34h]
  _DWORD *v52; // [sp+40h] [bp-30h]
  unsigned int *v53; // [sp+44h] [bp-2Ch]

  v7 = a1;
  v49 = a3;
  v50 = a4;
  v42 = a3;
  v43 = (unsigned __int8)a4;
  v8 = sub_97BC0((int)(a5 + 27));
  v9 = sub_AB850((int *)&unk_2FE0C4);
  v10 = *(_DWORD *)(a5[27] + 12);
  v11 = *(_DWORD *)(v10 + 4 * v9);
  v12 = v9;
  if ( !v11 )
  {
    v39 = (unsigned int *)operator new(0x44u);
    v39[1] = 0;
    v39[2] = 0;
    v39[3] = 0;
    *v39 = (unsigned int)&off_F0CD0;
    v40 = v39;
    *((_BYTE *)v39 + 16) = 0;
    *((_BYTE *)v39 + 17) = 0;
    *((_BYTE *)v39 + 18) = 0;
    v39[5] = 0;
    v39[6] = 0;
    v39[7] = 0;
    v39[8] = 0;
    v39[9] = 0;
    v39[10] = 0;
    v39[11] = 0;
    *((_BYTE *)v39 + 48) = 0;
    *((_BYTE *)v39 + 49) = 0;
    *((_BYTE *)v39 + 50) = 0;
    *((_BYTE *)v39 + 51) = 0;
    *((_BYTE *)v39 + 52) = 0;
    *((_BYTE *)v39 + 53) = 0;
    *((_BYTE *)v39 + 54) = 0;
    *((_BYTE *)v39 + 55) = 0;
    *((_BYTE *)v39 + 67) = 0;
    sub_98954((int)v39, (int)(a5 + 27));
    sub_AB778(a5[27], v40, v12);
    v11 = *(_DWORD *)(v10 + 4 * v12);
  }
  v13 = *a7;
  if ( **a7 == *(unsigned __int8 *)(v11 + 56) )
  {
    v38 = *(char **)(v11 + 36);
    v14 = *((_DWORD *)v13 - 3);
    v51 = *(_DWORD *)(v11 + 52);
    v46 = v38;
    v41 = *(_DWORD *)(v11 + 40);
    if ( !v14 )
      goto LABEL_44;
    ++v13;
  }
  else
  {
    v46 = *(char **)(v11 + 28);
    v14 = *((_DWORD *)v13 - 3);
    v41 = *(_DWORD *)(v11 + 32);
    v51 = *(_DWORD *)(v11 + 48);
  }
  v15 = (unsigned int)&v13[v14];
  if ( (unsigned int)v13 < v15 )
  {
    v16 = *(_DWORD *)(v8 + 24);
    if ( *(_BYTE *)(v16 + (unsigned __int8)*v13) & 4 )
    {
      v17 = (int)(v13 + 1);
      while ( 1 )
      {
        v18 = (unsigned __int8 *)v17;
        if ( v17 == v15 )
          break;
        ++v17;
        if ( !(*(_BYTE *)(v16 + *v18) & 4) )
        {
          v19 = v18 - v13;
          goto LABEL_10;
        }
      }
      v19 = v17 - (_DWORD)v13;
LABEL_10:
      if ( !v19 )
        goto LABEL_44;
      v52 = &unk_2FEF48;
      sub_C1264(&v52, 2 * v19);
      v20 = *(_DWORD *)(v11 + 44);
      v21 = v19 - v20;
      if ( (signed int)(v19 - v20) > 0 )
      {
        v21 &= ~(v20 >> 32);
        if ( v20 < 0 )
          v21 = v19;
        if ( *(_DWORD *)(v11 + 12) )
        {
          sub_C0DB8((int *)&v52, 0, *(v52 - 3), 2 * v21, 0);
          v22 = v52;
          if ( *(v52 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v52);
            v22 = v52;
          }
          v23 = sub_99304(
                  v22,
                  *(_BYTE *)(v11 + 18),
                  *(unsigned __int8 **)(v11 + 8),
                  *(_DWORD *)(v11 + 12),
                  (int)v13,
                  &v13[v21]);
          v24 = v52;
          v44 = v23;
          if ( *(v52 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v52);
            v24 = v52;
          }
          v25 = *(v24 - 3);
          if ( v44 - (_BYTE *)v24 > v25 )
            sub_BFC08("basic_string::erase");
          sub_C0AFC((int *)&v52, v44 - (_BYTE *)v24, v25 - (v44 - (_BYTE *)v24), 0);
          v20 = *(_DWORD *)(v11 + 44);
        }
        else
        {
          sub_C0F20((int *)&v52, v13, v21);
          v20 = *(_DWORD *)(v11 + 44);
        }
      }
      if ( v20 > 0 )
      {
        sub_C15D0((int *)&v52, *(_BYTE *)(v11 + 17));
        if ( v21 < 0 )
        {
          sub_C1500((int *)&v52, -v21, *(unsigned __int8 *)(v11 + 57));
          sub_C13F8((unsigned int *)&v52, (unsigned int)v13, v19);
        }
        else
        {
          sub_C13F8((unsigned int *)&v52, (unsigned int)&v13[v21], *(_DWORD *)(v11 + 44));
        }
      }
      v26 = a5[3] & 0x200;
      v47 = a5[3] & 0xB0;
      v27 = *(v52 - 3) + v41;
      if ( v26 )
        v26 = *(_DWORD *)(v11 + 24);
      v28 = v27 + v26;
      v53 = (unsigned int *)&unk_2FEF48;
      sub_C1264(&v53, 2 * (v27 + v26));
      v29 = a5[2];
      v30 = 1;
      v31 = v28 >= v29;
      v45 = v29 - v28;
      v32 = !v31;
      if ( v47 != 16 )
        v32 = 0;
      v48 = v32;
      while ( 1 )
      {
        switch ( *((unsigned __int8 *)&v51 + v30 - 1) )
        {
          case 0u:
            if ( !v48 )
              goto def_999D6;
            goto LABEL_54;
          case 1u:
            if ( v48 )
LABEL_54:
              sub_C1500((int *)&v53, v45, a6);
            else
              sub_C15D0((int *)&v53, a6);
            goto def_999D6;
          case 2u:
            if ( a5[3] & 0x200 )
              sub_C13F8((unsigned int *)&v53, *(_DWORD *)(v11 + 20), *(_DWORD *)(v11 + 24));
            goto def_999D6;
          case 3u:
            if ( v41 )
            {
              sub_C15D0((int *)&v53, *v46);
def_999D6:
              if ( v30 == 4 )
              {
                if ( v41 > 1 )
                  sub_C13F8((unsigned int *)&v53, (unsigned int)(v46 + 1), v41 - 1);
LABEL_35:
                v33 = v53;
                v34 = *(v53 - 3);
                if ( v29 > v34 )
                {
                  if ( v47 == 32 )
                    sub_C1500((int *)&v53, v29 - v34, a6);
                  else
                    sub_C0DB8((int *)&v53, 0, 0, v29 - v34, a6);
                  v33 = v53;
                }
                else
                {
                  v29 = *(v53 - 3);
                }
                if ( !v43 )
                {
                  v35 = (*(int (**)(void))(*(_DWORD *)v42 + 48))();
                  v33 = v53;
                  if ( v29 != v35 )
                    LOBYTE(v43) = 1;
                }
                sub_C0AC4(v33 - 3);
                sub_C0AC4(v52 - 3);
                goto LABEL_44;
              }
            }
            else if ( v30 == 4 )
            {
              goto LABEL_35;
            }
            ++v30;
            break;
          case 4u:
            sub_C12E4((int *)&v53, (_BYTE **)&v52);
            goto def_999D6;
          default:
            goto def_999D6;
        }
      }
    }
  }
LABEL_44:
  v49 = v42;
  LOBYTE(v50) = v43;
  v36 = v50;
  a5[2] = 0;
  *v7 = v42;
  v7[1] = v36;
  return v7;
}
// F0CD0: using guessed type void *off_F0CD0;

//----- (00099BE4) --------------------------------------------------------
int *__fastcall sub_99BE4(int *a1, int a2, int a3, int a4, unsigned __int8 a5, int a6, unsigned __int8 a7, int a8, int a9, int a10)
{
  int *v10; // r8
  _BYTE *v11; // r5
  int v12; // r11
  void *v13; // r10
  char *v14; // r11
  char *v15; // r0
  unsigned int *v17; // r2
  signed int v18; // r3
  int v19; // [sp+4h] [bp-14Ch]
  char v20[324]; // [sp+10h] [bp-140h]
  int v21; // [sp+154h] [bp+4h]
  int v22; // [sp+158h] [bp+8h]
  int v23; // [sp+15Ch] [bp+Ch]
  int *v24; // [sp+160h] [bp+10h]
  int *v25; // [sp+164h] [bp+14h]
  int v26; // [sp+168h] [bp+18h]
  int v27; // [sp+16Ch] [bp+1Ch]
  int v28; // [sp+174h] [bp+24h]
  int v29; // [sp+178h] [bp+28h]
  void *dest; // [sp+17Ch] [bp+2Ch]

  v25 = &v26;
  v10 = a1;
  v23 = a2;
  v26 = a3;
  v27 = a4;
  v22 = a5;
  v21 = a7;
  sub_AB164((unsigned int **)&v29, (unsigned int **)(a6 + 108));
  v11 = (_BYTE *)sub_97BC0((int)&v29);
  dest = (void *)sub_AB4B8();
  v12 = sub_96850((unsigned int)&dest, v20, 0, "%.*Lf", 0, v19, a9, a10);
  v24 = &v28;
  sub_C0AA8(&dest, v12, 0);
  v13 = dest;
  v14 = &v20[v12];
  if ( *((_DWORD *)dest - 1) >= 0 )
  {
    sub_C0BF4((int *)&dest);
    v13 = dest;
  }
  if ( v11[28] == 1 )
  {
    memcpy(v13, v20, v14 - v20);
  }
  else
  {
    if ( !v11[28] )
      sub_AA9D0((int)v11);
    (*(void (__fastcall **)(_BYTE *, char *, char *, void *))(*(_DWORD *)v11 + 28))(v11, v20, v14, v13);
  }
  if ( v22 )
    sub_99464(v10, v23, *v25, v25[1], (_DWORD *)a6, v21, (unsigned __int8 **)&dest);
  else
    sub_99824(v10, v23, *v25, v25[1], (_DWORD *)a6, v21, (unsigned __int8 **)&dest);
  v15 = (char *)dest - 12;
  if ( (char *)dest - 12 != (char *)&dword_2FEF3C )
  {
    v17 = (unsigned int *)((char *)dest - 4);
    __dmb(0xFu);
    do
      v18 = __ldrex(v17);
    while ( __strex(v18 - 1, v17) );
    __dmb(0xFu);
    if ( v18 <= 0 )
      operator delete(v15);
  }
  sub_AB620((unsigned int **)&v29);
  return v10;
}
// 2FEF3C: using guessed type int dword_2FEF3C;
// 99BE4: using guessed type char var_174[324];

//----- (00099D44) --------------------------------------------------------
int *__fastcall sub_99D44(int *a1, int a2, int a3, int a4, char a5, _DWORD *a6, unsigned __int8 a7, unsigned __int8 **a8)
{
  int *v8; // r5

  v8 = a1;
  if ( a5 )
    sub_99464(a1, a2, a3, a4, a6, a7, a8);
  else
    sub_99824(a1, a2, a3, a4, a6, a7, a8);
  return v8;
}

//----- (00099D7C) --------------------------------------------------------
void *__fastcall sub_99D7C(int a1, int c, void *dest, void *src, int a5, size_t n)
{
  int v6; // r9
  _BYTE *v7; // r4
  unsigned __int8 *v8; // r8
  int v9; // r6
  size_t v10; // r7
  signed int v11; // r6
  int v13; // r0
  _BYTE *v14; // r6
  int v15; // r0
  int v16; // r3
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r3
  int v21; // r0

  v6 = c;
  v7 = dest;
  v8 = (unsigned __int8 *)src;
  v9 = *(_DWORD *)(a1 + 12) & 0xB0;
  v10 = a5 - n;
  if ( v9 != 32 )
  {
    if ( v9 != 16 )
      goto LABEL_3;
    v13 = sub_97BC0(a1 + 108);
    v14 = (_BYTE *)v13;
    if ( *(_BYTE *)(v13 + 28) )
      v15 = *(unsigned __int8 *)(v13 + 74);
    else
      v15 = sub_9667C(v13, 45);
    v16 = *v8;
    if ( v16 == v15 )
    {
      LOBYTE(v16) = v15;
    }
    else
    {
      if ( v14[28] )
      {
        v17 = (unsigned __int8)v14[72];
      }
      else
      {
        sub_AA9D0((int)v14);
        v17 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v14 + 24))(v14, 43);
        v16 = *v8;
      }
      if ( v17 != v16 )
      {
        if ( v14[28] )
        {
          v18 = (unsigned __int8)v14[77];
        }
        else
        {
          sub_AA9D0((int)v14);
          v18 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v14 + 24))(v14, 48);
          v16 = *v8;
        }
        if ( v18 == v16 && (signed int)n > 1 )
        {
          v19 = v14[28] ? (unsigned __int8)v14[149] : sub_9667C((int)v14, 120);
          v20 = v8[1];
          if ( v20 == v19
            || (!v14[28] ? (v21 = sub_9667C((int)v14, 88), v20 = v8[1]) : (v21 = (unsigned __int8)v14[117]), v20 == v21) )
          {
            v11 = 2;
            *v7 = *v8;
            v7[1] = v8[1];
            v7 += 2;
            goto LABEL_4;
          }
        }
LABEL_3:
        v11 = 0;
LABEL_4:
        memset(v7, v6, v10);
        return j_memcpy(&v7[v10], &v8[v11], n - v11);
      }
    }
    *v7++ = v16;
    v11 = 1;
    goto LABEL_4;
  }
  memcpy(dest, src, n);
  return j_memset(&v7[n], v6, a5 - n);
}

//----- (00099E90) --------------------------------------------------------
void *__fastcall sub_99E90(int a1, int a2, int a3, int a4, void *dest, void *src, int a7)
{
  int v7; // r5
  void *result; // r0

  v7 = a3;
  result = sub_99D7C(a4, a2, dest, src, a3, *(_DWORD *)a7);
  *(_DWORD *)a7 = v7;
  return result;
}

//----- (00099EB0) --------------------------------------------------------
int __fastcall sub_99EB0(int a1, unsigned int a2, int a3, __int16 a4, char a5)
{
  _BYTE *v5; // r4
  _BYTE *v6; // r7
  unsigned int v7; // r5
  bool v9; // zf
  _BYTE *v10; // r3
  signed int v11; // r4
  int v12; // r2
  int v13; // r4
  _BYTE *v14; // r3
  int v15; // r4

  if ( a5 )
  {
    v5 = (_BYTE *)(a1 - 1);
    do
    {
      v6 = v5;
      v7 = a2 % 0xA;
      a2 /= 0xAu;
      *v5-- = *(_BYTE *)(a3 + v7 + 4);
    }
    while ( a2 );
  }
  else if ( (a4 & 0x4A) == 64 )
  {
    v14 = (_BYTE *)(a1 - 1);
    do
    {
      v15 = a2 & 7;
      a2 >>= 3;
      v6 = v14;
      *v14-- = *(_BYTE *)(v15 + a3 + 4);
    }
    while ( a2 );
  }
  else
  {
    v9 = (a4 & 0x4000) == 0;
    v10 = (_BYTE *)(a1 - 1);
    if ( v9 )
      v11 = 4;
    else
      v11 = 20;
    v12 = a3 + v11;
    do
    {
      v13 = a2 & 0xF;
      a2 >>= 4;
      v6 = v10;
      *v10-- = *(_BYTE *)(v12 + v13);
    }
    while ( a2 );
  }
  return a1 - (_DWORD)v6;
}

//----- (00099F28) --------------------------------------------------------
int __fastcall sub_99F28(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, signed int a7)
{
  int v7; // r6
  int v8; // r0
  int v9; // r9
  int v10; // r5
  int v11; // r8
  unsigned int v12; // r9
  int v13; // r10
  bool v14; // zf
  signed int v15; // r8
  int v16; // r3
  unsigned int v17; // r1
  int v18; // r3
  int v19; // r0
  int v20; // r2
  int v21; // r3
  char *src; // r12
  int v23; // r2
  int v24; // r5
  int v25; // r8
  int (__fastcall *v26)(int, char *, int); // r4
  int v27; // r0
  int result; // r0
  char v29; // r2
  char v30; // r3
  unsigned __int8 *v31; // r1
  int v32; // r2
  char v33; // r2
  unsigned int *v34; // r0
  unsigned int *v35; // r5
  char v36; // r1
  char v37; // r2
  char dest; // [sp+10h] [bp-20h]
  char v39; // [sp+12h] [bp-1Eh]
  int v40; // [sp+24h] [bp-Ch]
  char *v41; // [sp+34h] [bp+4h]
  int v42; // [sp+38h] [bp+8h]
  int v43; // [sp+3Ch] [bp+Ch]
  int v44; // [sp+40h] [bp+10h]
  int v45; // [sp+44h] [bp+14h]
  int v46; // [sp+4Ch] [bp+1Ch]

  v7 = a1;
  v43 = a2;
  v44 = a3;
  v45 = a4;
  v42 = a6;
  v8 = sub_AB850((int *)&unk_2FE0B4);
  v9 = *(_DWORD *)(a5[27] + 12);
  v10 = *(_DWORD *)(v9 + 4 * v8);
  v11 = v8;
  if ( !v10 )
  {
    v34 = (unsigned int *)operator new(0x68u);
    v34[1] = 0;
    v34[2] = 0;
    v34[3] = 0;
    *v34 = (unsigned int)&off_F0CF0;
    v35 = v34;
    *((_BYTE *)v34 + 16) = 0;
    v34[5] = 0;
    v34[6] = 0;
    v34[7] = 0;
    v34[8] = 0;
    *((_BYTE *)v34 + 36) = 0;
    *((_BYTE *)v34 + 37) = 0;
    *((_BYTE *)v34 + 100) = 0;
    sub_9811C((int)v34, (int)(a5 + 27));
    sub_AB778(a5[27], v35, v11);
    v10 = *(_DWORD *)(v9 + 4 * v11);
  }
  v12 = a5[3];
  v13 = a5[3] & 0x4A;
  v14 = v13 == 8;
  if ( v13 != 8 )
    v14 = v13 == 64;
  v15 = !v14;
  v16 = v15 ^ 1;
  if ( a7 > 0 )
    v16 |= 1u;
  if ( v16 )
    v17 = a7;
  else
    v17 = -a7;
  v18 = a5[3];
  v41 = &dest;
  v19 = sub_99EB0((int)&v40, v17, v10 + 38, v18, v15);
  v20 = *(unsigned __int8 *)(v10 + 16);
  v21 = v19;
  v46 = v19;
  src = &v41[20 - v19];
  if ( v20 )
  {
    v30 = *(_BYTE *)(v10 + 37);
    v31 = *(unsigned __int8 **)(v10 + 8);
    v32 = *(_DWORD *)(v10 + 12);
    v41 = &v39;
    sub_9943C(v43, v31, v32, v30, (int)a5, &v39, (int)src, &v46);
    v21 = v46;
    src = v41;
  }
  if ( v15 )
  {
    if ( a7 < 0 )
    {
      v33 = *(_BYTE *)(v10 + 38);
      ++v21;
      --src;
      v46 = v21;
      *src = v33;
    }
    else if ( v12 & 0x800 )
    {
      v29 = *(_BYTE *)(v10 + 39);
      ++v21;
      --src;
      v46 = v21;
      *src = v29;
    }
  }
  else if ( v12 & 0x200 && a7 )
  {
    if ( v13 == 64 )
    {
      v37 = *(_BYTE *)(v10 + 42);
      ++v21;
      --src;
      v46 = v21;
      *src = v37;
    }
    else
    {
      src -= 2;
      v21 += 2;
      v36 = *(_BYTE *)(((v12 >> 14) & 1) + v10 + 38 + 2);
      v46 = v21;
      src[1] = v36;
      *src = *(_BYTE *)(v10 + 42);
    }
  }
  v23 = a5[2];
  if ( v23 > v21 )
  {
    sub_99E90(v43, v42, v23, (int)a5, &dest, src, (int)&v46);
    v21 = v46;
    src = &dest;
  }
  v24 = (unsigned __int8)v45;
  v25 = v44;
  a5[2] = 0;
  if ( !v24 )
  {
    v26 = *(int (__fastcall **)(int, char *, int))(*(_DWORD *)v25 + 48);
    v41 = (char *)v21;
    v27 = v26(v25, src, v21);
    if ( (char *)v27 != v41 )
      LOBYTE(v24) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v25;
  *(_BYTE *)(v7 + 4) = v24;
  return result;
}
// F0CF0: using guessed type void *off_F0CF0;

//----- (0009A150) --------------------------------------------------------
int __fastcall sub_9A150(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, signed int a7)
{
  int v7; // r7

  v7 = a1;
  sub_99F28(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (0009A178) --------------------------------------------------------
int __fastcall sub_9A178(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned int a7)
{
  int v7; // r5
  int v8; // r0
  int v9; // r9
  int v10; // r6
  int v11; // r8
  unsigned int v12; // r9
  unsigned int v13; // r2
  int v14; // r10
  bool v15; // zf
  int v16; // r3
  signed int v17; // r8
  int v18; // r1
  int v19; // r0
  int v20; // r2
  int v21; // r3
  char *src; // r12
  int v23; // r2
  int v24; // r6
  int v25; // r8
  int (__fastcall *v26)(int, char *, int); // r4
  int v27; // r0
  int result; // r0
  char v29; // r3
  unsigned __int8 *v30; // r1
  int v31; // r2
  unsigned int *v32; // r0
  unsigned int *v33; // r6
  char v34; // r1
  char v35; // r2
  char dest; // [sp+10h] [bp-20h]
  char v37; // [sp+12h] [bp-1Eh]
  char v38; // [sp+24h] [bp-Ch]
  char *v39; // [sp+34h] [bp+4h]
  int v40; // [sp+38h] [bp+8h]
  int v41; // [sp+3Ch] [bp+Ch]
  int v42; // [sp+40h] [bp+10h]
  int v43; // [sp+44h] [bp+14h]
  int v44; // [sp+4Ch] [bp+1Ch]

  v7 = a1;
  v41 = a2;
  v42 = a3;
  v43 = a4;
  v40 = a6;
  v8 = sub_AB850((int *)&unk_2FE0B4);
  v9 = *(_DWORD *)(a5[27] + 12);
  v10 = *(_DWORD *)(v9 + 4 * v8);
  v11 = v8;
  if ( !v10 )
  {
    v32 = (unsigned int *)operator new(0x68u);
    v32[1] = 0;
    v32[2] = 0;
    v32[3] = 0;
    *v32 = (unsigned int)&off_F0CF0;
    v33 = v32;
    *((_BYTE *)v32 + 16) = 0;
    v32[5] = 0;
    v32[6] = 0;
    v32[7] = 0;
    v32[8] = 0;
    *((_BYTE *)v32 + 36) = 0;
    *((_BYTE *)v32 + 37) = 0;
    *((_BYTE *)v32 + 100) = 0;
    sub_9811C((int)v32, (int)(a5 + 27));
    sub_AB778(a5[27], v33, v11);
    v10 = *(_DWORD *)(v9 + 4 * v11);
  }
  v12 = a5[3];
  v13 = a7;
  v14 = a5[3] & 0x4A;
  v15 = v14 == 8;
  if ( v14 != 8 )
    v15 = v14 == 64;
  v16 = a5[3];
  v17 = !v15;
  if ( a7 )
    v18 = 0;
  else
    v18 = v17 & 1;
  if ( v18 )
    v13 = 0;
  v39 = &dest;
  v19 = sub_99EB0((int)&v38, v13, v10 + 38, v16, v17);
  v20 = *(unsigned __int8 *)(v10 + 16);
  v21 = v19;
  v44 = v19;
  src = &v39[20 - v19];
  if ( v20 )
  {
    v29 = *(_BYTE *)(v10 + 37);
    v30 = *(unsigned __int8 **)(v10 + 8);
    v31 = *(_DWORD *)(v10 + 12);
    v39 = &v37;
    sub_9943C(v41, v30, v31, v29, (int)a5, &v37, (int)src, &v44);
    v21 = v44;
    src = v39;
  }
  if ( !v17 && v12 & 0x200 && a7 )
  {
    if ( v14 == 64 )
    {
      v35 = *(_BYTE *)(v10 + 42);
      ++v21;
      --src;
      v44 = v21;
      *src = v35;
    }
    else
    {
      src -= 2;
      v21 += 2;
      v34 = *(_BYTE *)(((v12 >> 14) & 1) + v10 + 38 + 2);
      v44 = v21;
      src[1] = v34;
      *src = *(_BYTE *)(v10 + 42);
    }
  }
  v23 = a5[2];
  if ( v23 > v21 )
  {
    sub_99E90(v41, v40, v23, (int)a5, &dest, src, (int)&v44);
    v21 = v44;
    src = &dest;
  }
  v24 = (unsigned __int8)v43;
  v25 = v42;
  a5[2] = 0;
  if ( !v24 )
  {
    v26 = *(int (__fastcall **)(int, char *, int))(*(_DWORD *)v25 + 48);
    v39 = (char *)v21;
    v27 = v26(v25, src, v21);
    if ( (char *)v27 != v39 )
      LOBYTE(v24) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v25;
  *(_BYTE *)(v7 + 4) = v24;
  return result;
}
// F0CF0: using guessed type void *off_F0CF0;

//----- (0009A364) --------------------------------------------------------
int __fastcall sub_9A364(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned int a7)
{
  int v7; // r7

  v7 = a1;
  sub_9A178(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (0009A38C) --------------------------------------------------------
_DWORD *__fastcall sub_9A38C(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned int a7)
{
  _DWORD *v7; // r6
  int v8; // r7
  int v9; // ST14_4
  int v10; // r0
  char v11; // r1
  char v13; // [sp+18h] [bp-28h]
  char v14; // [sp+1Ch] [bp-24h]

  v7 = a1;
  v8 = a5[3];
  v9 = a4;
  a5[3] = v8 & 0xFFFFBFB5 | 0x208;
  sub_9A178((int)&v13, a2, a3, a4, a5, a6, a7);
  v10 = *(_DWORD *)&v13;
  v11 = v14;
  a5[3] = v8;
  LOBYTE(v9) = v11;
  *v7 = v10;
  v7[1] = v9;
  return v7;
}

//----- (0009A3F0) --------------------------------------------------------
int __fastcall sub_9A3F0(int a1, int a2, unsigned __int64 a3, int a4, __int16 a5, char a6)
{
  int v6; // r9
  unsigned __int64 v7; // r4
  _BYTE *v8; // r6
  _BYTE *v9; // r7
  _BYTE *v11; // r3
  signed int v12; // r2
  char v13; // r1
  _BYTE *v14; // r3
  int v15; // r0

  v6 = a1;
  v7 = a3;
  if ( a6 )
  {
    v8 = (_BYTE *)(a1 - 1);
    do
    {
      v9 = v8;
      *v8-- = *(_BYTE *)(a4 + v7 % 0xA + 4);
      v7 /= 0xAuLL;
    }
    while ( v7 );
  }
  else if ( (a5 & 0x4A) == 64 )
  {
    v14 = (_BYTE *)(a1 - 1);
    do
    {
      v15 = (v7 & 7) + a4;
      v9 = v14;
      v7 >>= 3;
      *v14-- = *(_BYTE *)(v15 + 4);
    }
    while ( v7 );
  }
  else
  {
    v11 = (_BYTE *)(a1 - 1);
    if ( a5 & 0x4000 )
      v12 = 20;
    else
      v12 = 4;
    do
    {
      v13 = *(_BYTE *)(a4 + v12 + (v7 & 0xF));
      v9 = v11;
      v7 >>= 4;
      *v11-- = v13;
    }
    while ( v7 );
  }
  return v6 - (_DWORD)v9;
}

//----- (0009A4A0) --------------------------------------------------------
int __fastcall sub_9A4A0(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned __int64 a7)
{
  int v7; // r5
  int v8; // r0
  int v9; // r9
  int v10; // r6
  int v11; // r8
  unsigned int v12; // r9
  int v13; // r10
  bool v14; // zf
  signed int v15; // r8
  int v16; // r3
  unsigned __int64 v17; // r2
  int v18; // r0
  int v19; // r2
  char *v20; // r3
  char *src; // r12
  int v22; // r2
  int v23; // r6
  int v24; // r8
  int (__fastcall *v25)(int, char *, char *); // r4
  int v26; // r0
  int result; // r0
  char v28; // r3
  unsigned __int8 *v29; // r1
  int v30; // r2
  unsigned int *v31; // r0
  unsigned int *v32; // r6
  char v33; // r1
  char v34; // r2
  char dest[2]; // [sp+10h] [bp-30h]
  char v36; // [sp+12h] [bp-2Eh]
  int v37; // [sp+38h] [bp-8h]
  char *v38; // [sp+40h] [bp+0h]
  int v39; // [sp+44h] [bp+4h]
  int v40; // [sp+48h] [bp+8h]
  int v41; // [sp+4Ch] [bp+Ch]
  int v42; // [sp+50h] [bp+10h]
  int v43; // [sp+54h] [bp+14h]
  char *v44; // [sp+5Ch] [bp+1Ch]

  v7 = a1;
  v40 = a2;
  v42 = a3;
  v43 = a4;
  v39 = a6;
  v8 = sub_AB850((int *)&unk_2FE0B4);
  v9 = *(_DWORD *)(a5[27] + 12);
  v10 = *(_DWORD *)(v9 + 4 * v8);
  v11 = v8;
  if ( !v10 )
  {
    v31 = (unsigned int *)operator new(0x68u);
    v31[1] = 0;
    v31[2] = 0;
    v31[3] = 0;
    *v31 = (unsigned int)&off_F0CF0;
    v32 = v31;
    *((_BYTE *)v31 + 16) = 0;
    v31[5] = 0;
    v31[6] = 0;
    v31[7] = 0;
    v31[8] = 0;
    *((_BYTE *)v31 + 36) = 0;
    *((_BYTE *)v31 + 37) = 0;
    *((_BYTE *)v31 + 100) = 0;
    sub_9811C((int)v31, (int)(a5 + 27));
    sub_AB778(a5[27], v32, v11);
    v10 = *(_DWORD *)(v9 + 4 * v11);
  }
  v12 = a5[3];
  v13 = a5[3] & 0x4A;
  v14 = v13 == 8;
  if ( v13 != 8 )
    v14 = v13 == 64;
  v15 = !v14;
  if ( a7 )
    v16 = 0;
  else
    v16 = v15 & 1;
  v41 = v10 + 38;
  if ( v16 )
    v17 = 0LL;
  else
    v17 = a7;
  v18 = sub_9A3F0((int)&v37, v41, v17, v41, v12, v15);
  v19 = *(unsigned __int8 *)(v10 + 16);
  v20 = (char *)v18;
  v44 = (char *)v18;
  src = &dest[40 - v18];
  if ( v19 )
  {
    v28 = *(_BYTE *)(v10 + 37);
    v29 = *(unsigned __int8 **)(v10 + 8);
    v30 = *(_DWORD *)(v10 + 12);
    v38 = &v36;
    sub_9943C(v40, v29, v30, v28, (int)a5, &v36, (int)src, &v44);
    v20 = v44;
    src = v38;
  }
  if ( !v15 && v12 & 0x200 && a7 )
  {
    if ( v13 == 64 )
    {
      v34 = *(_BYTE *)(v10 + 42);
      ++v20;
      --src;
      v44 = v20;
      *src = v34;
    }
    else
    {
      src -= 2;
      v20 += 2;
      v33 = *(_BYTE *)(((v12 >> 14) & 1) + v41 + 2);
      v44 = v20;
      src[1] = v33;
      *src = *(_BYTE *)(v10 + 42);
    }
  }
  v22 = a5[2];
  if ( v22 > (signed int)v20 )
  {
    sub_99E90(v40, v39, v22, (int)a5, dest, src, (int)&v44);
    v20 = v44;
    src = dest;
  }
  v23 = (unsigned __int8)v43;
  v24 = v42;
  a5[2] = 0;
  if ( !v23 )
  {
    v25 = *(int (__fastcall **)(int, char *, char *))(*(_DWORD *)v24 + 48);
    v38 = v20;
    v26 = v25(v24, src, v20);
    if ( (char *)v26 != v38 )
      LOBYTE(v23) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v24;
  *(_BYTE *)(v7 + 4) = v23;
  return result;
}
// F0CF0: using guessed type void *off_F0CF0;
// 9A4A0: using guessed type char var_54[2];

//----- (0009A694) --------------------------------------------------------
int __fastcall sub_9A694(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned __int64 a7)
{
  int v7; // r8

  v7 = a1;
  sub_9A4A0(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (0009A6C4) --------------------------------------------------------
int __fastcall sub_9A6C4(int a1, int *a2)
{
  int *v2; // r6
  int v3; // r0
  int v4; // r7
  int v5; // r5
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r4

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FE0C0);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x44u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F0CE0;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    *((_BYTE *)v7 + 17) = 0;
    *((_BYTE *)v7 + 18) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    *((_BYTE *)v7 + 48) = 0;
    *((_BYTE *)v7 + 49) = 0;
    *((_BYTE *)v7 + 50) = 0;
    *((_BYTE *)v7 + 51) = 0;
    *((_BYTE *)v7 + 52) = 0;
    *((_BYTE *)v7 + 53) = 0;
    *((_BYTE *)v7 + 54) = 0;
    *((_BYTE *)v7 + 55) = 0;
    *((_BYTE *)v7 + 67) = 0;
    sub_98520((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F0CE0: using guessed type void *off_F0CE0;

//----- (0009A76C) --------------------------------------------------------
_DWORD **__fastcall sub_9A76C(_DWORD **a1)
{
  _DWORD **v1; // r4
  _DWORD *v2; // r0
  unsigned int v3; // r2

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v3 = v2[2];
    if ( v3 >= v2[3] )
      (*(void (**)(void))(*v2 + 40))();
    else
      v2[2] = v3 + 1;
    v1[1] = (_DWORD *)-1;
  }
  return v1;
}

//----- (0009A794) --------------------------------------------------------
int __fastcall sub_9A794(int a1, int *a2)
{
  int *v2; // r6
  int v3; // r0
  int v4; // r7
  int v5; // r5
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r4

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FE0C4);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x44u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F0CD0;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    *((_BYTE *)v7 + 17) = 0;
    *((_BYTE *)v7 + 18) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    *((_BYTE *)v7 + 48) = 0;
    *((_BYTE *)v7 + 49) = 0;
    *((_BYTE *)v7 + 50) = 0;
    *((_BYTE *)v7 + 51) = 0;
    *((_BYTE *)v7 + 52) = 0;
    *((_BYTE *)v7 + 53) = 0;
    *((_BYTE *)v7 + 54) = 0;
    *((_BYTE *)v7 + 55) = 0;
    *((_BYTE *)v7 + 67) = 0;
    sub_98954((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F0CD0: using guessed type void *off_F0CD0;

//----- (0009A83C) --------------------------------------------------------
int __fastcall sub_9A83C(int a1, int *a2)
{
  int *v2; // r5
  int v3; // r0
  int v4; // r6
  int v5; // r4
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r7

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FE0B4);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x68u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F0CF0;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    *((_BYTE *)v7 + 36) = 0;
    *((_BYTE *)v7 + 37) = 0;
    *((_BYTE *)v7 + 100) = 0;
    sub_9811C((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F0CF0: using guessed type void *off_F0CF0;

//----- (0009A8C0) --------------------------------------------------------
int *__fastcall sub_9A8C0(int *a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, unsigned __int8 a7)
{
  int *v7; // r5
  int v8; // r8
  int v9; // r10
  int v10; // r11
  int v11; // r1
  _DWORD *v13; // r0
  int v14; // r9
  int v15; // r2
  void *v16; // r0
  int v17; // r0
  int v18; // r0
  int (__fastcall *v19)(int, int, int); // r3
  int v20; // r0
  char s; // [sp+10h] [bp+0h]
  int c; // [sp+14h] [bp+4h]
  int v23; // [sp+18h] [bp+8h]
  int v24; // [sp+1Ch] [bp+Ch]
  int v25; // [sp+20h] [bp+10h]
  int v26; // [sp+24h] [bp+14h]
  int v27; // [sp+28h] [bp+18h]
  char v28; // [sp+2Ch] [bp+1Ch]

  v7 = a1;
  v8 = a3;
  v25 = a3;
  v26 = a4;
  v9 = a5[3];
  v10 = (unsigned __int8)a4;
  if ( !(v9 & 1) )
  {
    sub_99F28((int)&v27, a2, v25, v26, a5, a6, a7);
    v8 = v27;
    LOBYTE(v10) = v28;
    goto LABEL_3;
  }
  c = a6;
  v13 = (_DWORD *)sub_9A83C((int)&v27, a5 + 27);
  if ( a7 )
  {
    v14 = v13[6];
    v15 = a5[2];
    v23 = v13[5];
    if ( v14 < v15 )
      goto LABEL_6;
LABEL_13:
    a5[2] = 0;
    if ( !v10 && v14 != (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, v23, v14) )
      LOBYTE(v10) = 1;
    goto LABEL_3;
  }
  v14 = v13[8];
  v15 = a5[2];
  v23 = v13[7];
  if ( v14 >= v15 )
    goto LABEL_13;
LABEL_6:
  v24 = v15 - v14;
  v16 = memset(&s, a6, v15 - v14);
  a5[2] = 0;
  if ( (v9 & 0xB0) != 32 )
  {
    if ( v10 )
      goto LABEL_3;
    v17 = (*(int (__fastcall **)(int, void *, int))(*(_DWORD *)v8 + 48))(v8, v16, v24);
    if ( v24 == v17 )
    {
      v18 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, v23, v14);
      LOBYTE(v10) = v14 - v18;
      if ( v14 != v18 )
        LOBYTE(v10) = 1;
      goto LABEL_3;
    }
LABEL_22:
    LOBYTE(v10) = 1;
    goto LABEL_3;
  }
  if ( v10 )
    goto LABEL_3;
  v19 = *(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48);
  c = (int)v16;
  if ( v14 != v19(v8, v23, v14) )
    goto LABEL_22;
  v20 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, c, v24);
  LOBYTE(v10) = v24 - v20;
  if ( v24 != v20 )
    LOBYTE(v10) = 1;
LABEL_3:
  v25 = v8;
  LOBYTE(v26) = v10;
  v11 = v26;
  *v7 = v8;
  v7[1] = v11;
  return v7;
}

//----- (0009AA20) --------------------------------------------------------
int __fastcall sub_9AA20(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, signed __int64 a7)
{
  int v7; // r5
  int v8; // r0
  unsigned int v9; // r9
  int v10; // r10
  bool v11; // zf
  signed int v12; // r8
  int v13; // r6
  int v14; // r3
  unsigned __int64 v15; // r2
  int v16; // r0
  int v17; // r2
  char *v18; // r3
  char *src; // r12
  int v20; // r2
  int v21; // r6
  int v22; // r8
  int (__fastcall *v23)(int, char *, char *); // r4
  int v24; // r0
  int result; // r0
  char v26; // r2
  char v27; // r3
  unsigned __int8 *v28; // r1
  int v29; // r2
  char v30; // r2
  char v31; // r1
  char v32; // r2
  char dest[2]; // [sp+10h] [bp-30h]
  char v34; // [sp+12h] [bp-2Eh]
  int v35; // [sp+38h] [bp-8h]
  char *v36; // [sp+40h] [bp+0h]
  int v37; // [sp+44h] [bp+4h]
  int v38; // [sp+48h] [bp+8h]
  int v39; // [sp+4Ch] [bp+Ch]
  int v40; // [sp+50h] [bp+10h]
  int v41; // [sp+54h] [bp+14h]
  int v42; // [sp+58h] [bp+18h]
  char *v43; // [sp+5Ch] [bp+1Ch]

  v7 = a1;
  v40 = a3;
  v41 = a4;
  v38 = a2;
  v37 = a6;
  v8 = sub_9A83C((int)&v42, a5 + 27);
  v9 = a5[3];
  v10 = a5[3] & 0x4A;
  v11 = v10 == 8;
  if ( v10 != 8 )
    v11 = v10 == 64;
  v12 = !v11;
  v13 = v8;
  v39 = v8 + 38;
  v14 = v12 ^ 1;
  if ( a7 >= 1 )
    v14 |= 1u;
  if ( v14 )
  {
    v15 = a7;
  }
  else
  {
    LODWORD(v15) = -(signed int)a7;
    HIDWORD(v15) = HIDWORD(a7) - (2 * HIDWORD(a7) + ((unsigned int)a7 > 0));
  }
  v16 = sub_9A3F0((int)&v35, HIDWORD(a7) - ((unsigned int)a7 < 1), v15, v39, v9, v12);
  v17 = *(unsigned __int8 *)(v13 + 16);
  v18 = (char *)v16;
  v43 = (char *)v16;
  src = &dest[40 - v16];
  if ( v17 )
  {
    v27 = *(_BYTE *)(v13 + 37);
    v28 = *(unsigned __int8 **)(v13 + 8);
    v29 = *(_DWORD *)(v13 + 12);
    v36 = &v34;
    sub_9943C(v38, v28, v29, v27, (int)a5, &v34, (int)src, &v43);
    v18 = v43;
    src = v36;
  }
  if ( v12 )
  {
    if ( a7 < 0 )
    {
      v30 = *(_BYTE *)(v13 + 38);
      ++v18;
      --src;
      v43 = v18;
      *src = v30;
    }
    else if ( v9 & 0x800 )
    {
      v26 = *(_BYTE *)(v13 + 39);
      ++v18;
      --src;
      v43 = v18;
      *src = v26;
    }
  }
  else if ( v9 & 0x200 && a7 )
  {
    if ( v10 == 64 )
    {
      v32 = *(_BYTE *)(v13 + 42);
      ++v18;
      --src;
      v43 = v18;
      *src = v32;
    }
    else
    {
      src -= 2;
      v18 += 2;
      v31 = *(_BYTE *)(((v9 >> 14) & 1) + v39 + 2);
      v43 = v18;
      src[1] = v31;
      *src = *(_BYTE *)(v13 + 42);
    }
  }
  v20 = a5[2];
  if ( v20 > (signed int)v18 )
  {
    sub_99E90(v38, v37, v20, (int)a5, dest, src, (int)&v43);
    v18 = v43;
    src = dest;
  }
  v21 = (unsigned __int8)v41;
  v22 = v40;
  a5[2] = 0;
  if ( !v21 )
  {
    v23 = *(int (__fastcall **)(int, char *, char *))(*(_DWORD *)v22 + 48);
    v36 = v18;
    v24 = v23(v22, src, v18);
    if ( (char *)v24 != v36 )
      LOBYTE(v21) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v22;
  *(_BYTE *)(v7 + 4) = v21;
  return result;
}
// 9AA20: using guessed type char var_54[2];

//----- (0009ABE0) --------------------------------------------------------
int __fastcall sub_9ABE0(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 a6, signed __int64 a7)
{
  int v7; // r8

  v7 = a1;
  sub_9AA20(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (0009AC10) --------------------------------------------------------
#error "9AE06: call analysis failed (funcsize=193)"

//----- (0009AE28) --------------------------------------------------------
int __fastcall sub_9AE28(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // r6
  double v7; // ST00_8

  v6 = a1;
  LODWORD(v7) = a5;
  HIDWORD(v7) = a6;
  sub_9AC10(a1, a2, a3, a4, v7);
  return v6;
}

//----- (0009AE58) --------------------------------------------------------
#error "9B04E: call analysis failed (funcsize=193)"

//----- (0009B070) --------------------------------------------------------
int __fastcall sub_9B070(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // r6
  double v7; // ST00_8

  v6 = a1;
  LODWORD(v7) = a5;
  HIDWORD(v7) = a6;
  sub_9AE58(a1, a2, a3, a4, v7);
  return v6;
}

//----- (0009B0A0) --------------------------------------------------------
int __fastcall sub_9B0A0(_DWORD **a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  int v3; // r3
  int result; // r0
  unsigned __int8 *v5; // r3
  int v6; // r3

  v1 = a1;
  v2 = *a1;
  if ( !v2 )
    return -1;
  v3 = v1[1];
  if ( v3 != -1 )
    return v3;
  v5 = (unsigned __int8 *)v2[2];
  if ( (unsigned int)v5 < v2[3] )
  {
    v6 = *v5;
LABEL_6:
    v1[1] = v6;
    return v6;
  }
  result = (*(int (**)(void))(*v2 + 36))();
  v6 = result;
  if ( result != -1 )
    goto LABEL_6;
  *v1 = 0;
  return result;
}

//----- (0009B0DC) --------------------------------------------------------
bool __fastcall sub_9B0DC(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r0
  signed int v4; // r5
  _DWORD *v5; // r0
  signed int v6; // r0
  unsigned __int8 *v8; // r3
  int v9; // r0
  unsigned __int8 *v10; // r2
  int v11; // r0
  _DWORD *v12; // ST04_4
  _DWORD *v13; // [sp+4h] [bp-14h]

  v2 = a1;
  v3 = *a1;
  if ( v3 )
  {
    if ( v2[1] != -1 )
    {
      v4 = 0;
      goto LABEL_5;
    }
    v8 = (unsigned __int8 *)v3[2];
    if ( (unsigned int)v8 < v3[3] )
    {
      v9 = *v8;
LABEL_12:
      v2[1] = v9;
      v4 = 0;
      goto LABEL_5;
    }
    v12 = a2;
    v9 = (*(int (**)(void))(*v3 + 36))();
    a2 = v12;
    if ( v9 != -1 )
      goto LABEL_12;
    v4 = 1;
    *v2 = 0;
  }
  else
  {
    v4 = 1;
  }
LABEL_5:
  v5 = (_DWORD *)*a2;
  if ( *a2 )
  {
    if ( a2[1] == -1 )
    {
      v10 = (unsigned __int8 *)v5[2];
      if ( (unsigned int)v10 >= v5[3] )
      {
        v13 = a2;
        v11 = (*(int (**)(void))(*v5 + 36))();
        a2 = v13;
        if ( v11 == -1 )
        {
          v6 = 1;
          *v13 = 0;
          return (unsigned int)(v6 - v4) <= 0;
        }
      }
      else
      {
        v11 = *v10;
      }
      a2[1] = v11;
      v6 = 0;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 1;
  }
  return (unsigned int)(v6 - v4) <= 0;
}

//----- (0009B15C) --------------------------------------------------------
_DWORD *__fastcall sub_9B15C(_DWORD *a1, int a2, _DWORD *a3, int a4, int a5, int a6, _DWORD *a7, int a8, int a9, int a10, _DWORD *a11)
{
  int v11; // r8
  int v12; // r6
  int v13; // r10
  int v14; // r5
  _DWORD *v15; // r1
  _DWORD *v16; // r4
  unsigned __int8 v18; // r0
  int v19; // r9
  unsigned int v20; // r4
  int v21; // r6
  int v22; // r8
  unsigned __int8 *v23; // t1
  int v24; // r6
  int v25; // r8
  int *v26; // r10
  unsigned int v27; // r5
  size_t v28; // r9
  int v29; // t1
  size_t v30; // r0
  unsigned int v31; // r2
  unsigned int v32; // r5
  int v33; // r10
  int v34; // r9
  signed int v35; // r3
  unsigned __int8 *v36; // r2
  int v37; // r0
  unsigned int v38; // r4
  int v39; // r5
  int v40; // r9
  size_t v41; // r6
  int v42; // r8
  int v43; // t1
  int v44; // [sp+14h] [bp+0h]
  int v45; // [sp+18h] [bp+4h]
  _DWORD *v46; // [sp+1Ch] [bp+8h]
  _DWORD **v47; // [sp+20h] [bp+Ch]
  _DWORD *v48; // [sp+24h] [bp+10h]
  int v49; // [sp+28h] [bp+14h]

  v46 = a1;
  v48 = a3;
  v49 = a4;
  v11 = a9;
  v47 = &v48;
  v12 = a8;
  v13 = sub_97BC0(a10 + 108);
  v14 = sub_9B0DC(&v48, &a5);
  if ( v14 )
    goto LABEL_2;
  v18 = sub_9B0A0(&v48);
  if ( !v11 )
    goto LABEL_2;
  v19 = v12 - 4;
  v45 = v12;
  v20 = 0;
  v21 = v11;
  v22 = v18;
  do
  {
    while ( 1 )
    {
      v23 = *(unsigned __int8 **)(v19 + 4);
      v19 += 4;
      if ( *v23 == v22 || v22 == (*(int (**)(void))(*(_DWORD *)v13 + 8))() )
        break;
      if ( ++v14 == v21 )
        goto LABEL_10;
    }
    *(&v44 + v20++) = v14++;
  }
  while ( v14 != v21 );
LABEL_10:
  v24 = v45;
  v25 = 0;
  if ( v20 > 1 )
  {
LABEL_11:
    v26 = &v44;
    v27 = 1;
    v28 = strlen(*(const char **)(v24 + 4 * v44));
    do
    {
      v29 = v26[1];
      ++v26;
      ++v27;
      v30 = strlen(*(const char **)(v24 + 4 * v29));
      if ( v28 >= v30 )
        v28 = v30;
    }
    while ( v27 < v20 );
    if ( v48 )
    {
      v31 = v48[2];
      if ( v31 >= v48[3] )
        (*(void (**)(void))(*v48 + 40))();
      else
        v48[2] = v31 + 1;
      v49 = -1;
    }
    if ( ++v25 >= v28 || sub_9B0DC(&v48, &a5) )
      goto LABEL_2;
    v32 = 0;
    while ( 1 )
    {
      v33 = 4 * v32;
      v34 = *(unsigned __int8 *)(*(_DWORD *)(v24 + 4 * *(&v44 + v32)) + v25);
      if ( v48 )
      {
        if ( v49 == -1 )
        {
          v36 = (unsigned __int8 *)v48[2];
          if ( (unsigned int)v36 >= v48[3] )
          {
            v37 = (*(int (**)(void))(*v48 + 36))();
            if ( v37 == -1 )
            {
              v35 = 255;
              v48 = 0;
              goto LABEL_22;
            }
          }
          else
          {
            v37 = *v36;
          }
          v49 = v37;
          v35 = (unsigned __int8)v37;
        }
        else
        {
          v35 = (unsigned __int8)v49;
        }
      }
      else
      {
        v35 = 255;
      }
LABEL_22:
      if ( v34 == v35 )
        ++v32;
      else
        --v20;
      if ( v34 != v35 )
        *(int *)((char *)&v44 + v33) = *(&v44 + v20);
      if ( v20 <= v32 )
      {
        if ( v20 <= 1 )
          break;
        goto LABEL_11;
      }
    }
  }
  if ( v20 != 1 )
    goto LABEL_2;
  v38 = v25 + 1;
  sub_9A76C(&v48);
  v39 = v44;
  v40 = *(_DWORD *)(v24 + 4 * v44);
  v41 = strlen(*(const char **)(v24 + 4 * v44));
  if ( v25 + 1 < v41 )
  {
    v42 = v25 + v40;
    do
    {
      if ( sub_9B0DC(&v48, &a5) )
        break;
      v43 = *(unsigned __int8 *)(v42++ + 1);
      if ( v43 != (unsigned __int8)sub_9B0A0(&v48) )
        break;
      ++v38;
      sub_9A76C(&v48);
    }
    while ( v38 < v41 );
  }
  if ( v38 != v41 )
LABEL_2:
    *a11 |= 4u;
  else
    *a7 = v39;
  v15 = v47[1];
  v16 = v46;
  *v46 = *v47;
  v16[1] = v15;
  return v16;
}

//----- (0009B33C) --------------------------------------------------------
_DWORD *__fastcall sub_9B33C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int *a7, int a8, unsigned int a9, int a10, _DWORD *a11)
{
  int v11; // r9
  int v12; // r10
  unsigned int v13; // r5
  unsigned int v14; // r4
  unsigned int v15; // r8
  _DWORD **v16; // r5
  _DWORD *v17; // r0
  signed int v18; // r10
  signed int v19; // r3
  signed int v20; // r11
  unsigned int v21; // r3
  int v22; // r10
  _DWORD *v23; // r1
  int v24; // r2
  int v25; // r0
  _DWORD *v26; // r12
  int v27; // r0
  int v28; // r1
  _DWORD *v29; // r0
  unsigned int v30; // r2
  unsigned __int8 *v31; // r2
  int v32; // r0
  _DWORD *v33; // r1
  _DWORD *v34; // r4
  unsigned __int8 *v36; // r2
  int v37; // r0
  int v38; // r3
  unsigned __int8 *v39; // r2
  int v40; // r0
  int v41; // r11
  int v42; // r8
  int v43; // r9
  unsigned __int8 *v44; // t1
  int v45; // r10
  unsigned int v46; // [sp+14h] [bp+0h]
  int v47; // [sp+18h] [bp+4h]
  _DWORD *v48; // [sp+1Ch] [bp+8h]
  _DWORD **v49; // [sp+20h] [bp+Ch]
  _DWORD *v50; // [sp+24h] [bp+10h]
  int v51; // [sp+28h] [bp+14h]

  v48 = a1;
  v50 = a3;
  v51 = a4;
  v49 = &v50;
  v11 = a8;
  v12 = sub_97BC0(a10 + 108);
  v13 = sub_9B0DC(&v50, &a5);
  if ( v13 || (v41 = (unsigned __int8)sub_9B0A0(&v50), !(2 * a9)) )
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
  }
  else
  {
    v42 = v11 - 4;
    v47 = v11;
    v14 = 0;
    v43 = 2 * a9;
    do
    {
      while ( 1 )
      {
        v44 = *(unsigned __int8 **)(v42 + 4);
        v42 += 4;
        if ( *v44 == v41 || v41 == (*(int (**)(void))(*(_DWORD *)v12 + 8))() )
          break;
        if ( ++v13 == v43 )
          goto LABEL_56;
      }
      *(&v46 + v14++) = v13++;
    }
    while ( v13 != v43 );
LABEL_56:
    v11 = v47;
    v15 = v14;
    v16 = (_DWORD **)v14;
    if ( v14 )
    {
      sub_9A76C(&v50);
      v45 = 0;
      v16 = &a5;
      do
      {
        (&a5)[v45] = (_DWORD *)strlen(*(const char **)(v11 + 4 * *(unsigned int *)((char *)&v46 + v45 * 4)));
        ++v45;
      }
      while ( v14 != v45 );
      v15 = 1;
    }
  }
  v17 = v50;
  while ( 1 )
  {
    if ( v17 )
    {
      if ( v51 != -1 )
      {
        v18 = 0;
        goto LABEL_8;
      }
      v39 = (unsigned __int8 *)v17[2];
      if ( (unsigned int)v39 < v17[3] )
      {
        v40 = *v39;
LABEL_49:
        v51 = v40;
        v18 = 0;
        goto LABEL_8;
      }
      v40 = (*(int (**)(void))(*v17 + 36))();
      if ( v40 != -1 )
        goto LABEL_49;
      v18 = 1;
      v50 = 0;
    }
    else
    {
      v18 = 1;
    }
LABEL_8:
    if ( !a5 )
    {
      v19 = 1;
      goto LABEL_12;
    }
    if ( a6 != -1 )
    {
      v19 = 0;
      goto LABEL_12;
    }
    v36 = (unsigned __int8 *)a5[2];
    if ( (unsigned int)v36 < a5[3] )
    {
      v37 = *v36;
      goto LABEL_41;
    }
    v37 = (*(int (**)(void))(*a5 + 36))();
    if ( v37 == -1 )
    {
      v19 = 1;
      a5 = 0;
LABEL_12:
      if ( v19 == v18 )
        break;
      goto LABEL_13;
    }
LABEL_41:
    a6 = v37;
    if ( !v18 )
      break;
LABEL_13:
    if ( !v50 )
    {
      v20 = 255;
      goto LABEL_17;
    }
    if ( v51 != -1 )
    {
      v20 = (unsigned __int8)v51;
      goto LABEL_17;
    }
    v31 = (unsigned __int8 *)v50[2];
    if ( (unsigned int)v31 < v50[3] )
    {
      v32 = *v31;
      goto LABEL_36;
    }
    v32 = (*(int (**)(void))(*v50 + 36))();
    if ( v32 == -1 )
    {
      v20 = 255;
      v50 = 0;
LABEL_17:
      if ( !v14 )
        goto LABEL_37;
      goto LABEL_18;
    }
LABEL_36:
    v51 = v32;
    v20 = (unsigned __int8)v32;
    if ( !v14 )
      goto LABEL_37;
LABEL_18:
    v21 = 0;
    v22 = 0;
    do
    {
      v23 = v16[v21];
      v24 = 4 * v21;
      v25 = *(&v46 + v21);
      v26 = &v16[v21];
      if ( v15 >= (unsigned int)v23 )
      {
        ++v22;
        ++v21;
      }
      v27 = *(_DWORD *)(v11 + 4 * v25);
      if ( v15 < (unsigned int)v23 )
      {
        v28 = *(unsigned __int8 *)(v27 + v15);
        if ( v28 == v20 )
          ++v21;
        else
          --v14;
        if ( v28 != v20 )
        {
          v29 = v16[v14];
          *(unsigned int *)((char *)&v46 + v24) = *(&v46 + v14);
          *v26 = v29;
        }
      }
    }
    while ( v14 > v21 );
    if ( v14 == v22 )
      break;
    v17 = v50;
    if ( v50 )
    {
      v30 = v50[2];
      if ( v30 >= v50[3] )
      {
        (*(void (**)(void))(*v50 + 40))();
        v17 = v50;
      }
      else
      {
        v50[2] = v30 + 1;
      }
      v51 = -1;
    }
    ++v15;
  }
  if ( v14 != 1 )
  {
    if ( v14 == 2 && ((_DWORD *)v15 == *v16 || (_DWORD *)v15 == v16[1]) )
      goto LABEL_44;
LABEL_37:
    *a11 |= 4u;
    goto LABEL_38;
  }
  if ( (_DWORD *)v15 != *v16 )
    goto LABEL_37;
LABEL_44:
  v38 = v46;
  if ( a9 <= v46 )
    v38 = v46 - a9;
  *a7 = v38;
LABEL_38:
  v33 = v49[1];
  v34 = v48;
  *v48 = *v49;
  v34[1] = v33;
  return v34;
}

//----- (0009B5B8) --------------------------------------------------------
_DWORD *__fastcall sub_9B5B8(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r6
  int v10; // r10
  int v11; // r4
  _DWORD *v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  int v17; // r3
  _DWORD *v18; // r4
  int v19; // r5
  signed int v20; // r7
  int v21; // r3
  bool v22; // zf
  _DWORD *result; // r0
  unsigned __int8 *v24; // r3
  char v25; // [sp+20h] [bp-70h]
  int v26; // [sp+24h] [bp-6Ch]
  _DWORD *v27; // [sp+28h] [bp-68h]
  int v28; // [sp+2Ch] [bp-64h]
  int v29; // [sp+30h] [bp-60h]
  int v30; // [sp+34h] [bp-5Ch]
  int v31; // [sp+38h] [bp-58h]
  int v32; // [sp+3Ch] [bp-54h]
  int v33; // [sp+40h] [bp-50h]
  int v34; // [sp+44h] [bp-4Ch]
  int v35; // [sp+48h] [bp-48h]
  int v36; // [sp+4Ch] [bp-44h]
  int v37; // [sp+50h] [bp-40h]
  int v38; // [sp+54h] [bp-3Ch]
  int v39; // [sp+58h] [bp-38h]
  int v40; // [sp+5Ch] [bp-34h]
  int v41; // [sp+60h] [bp-30h]
  int v42; // [sp+64h] [bp-2Ch]
  int v43; // [sp+68h] [bp-28h]
  int v44; // [sp+6Ch] [bp-24h]

  v9 = a1;
  v10 = a2;
  v27 = a3;
  v28 = a4;
  v11 = sub_98DCC(a7 + 108);
  sub_97BC0(a7 + 108);
  v12 = *(_DWORD **)(v11 + 8);
  v13 = v12[20];
  v14 = v12[18];
  v15 = v12[19];
  v33 = v13;
  v16 = *(_DWORD *)(v11 + 8);
  v32 = v15;
  v31 = v14;
  v34 = *(_DWORD *)(v16 + 84);
  v35 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 88);
  v36 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 92);
  v37 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 96);
  v38 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 44);
  v39 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 48);
  v40 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 52);
  v41 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 56);
  v42 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 60);
  v17 = *(_DWORD *)(v11 + 8);
  v30 = 0;
  v43 = *(_DWORD *)(v17 + 64);
  v44 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 68);
  sub_9B33C(&v25, v10, v27, v28, a5, a6, &v29, (int)&v31, 7u, a7, &v30);
  v27 = *(_DWORD **)&v25;
  v28 = v26;
  v18 = *(_DWORD **)&v25;
  v19 = v26;
  if ( v30 )
    *a8 |= 4u;
  else
    *(_DWORD *)(a9 + 24) = v29;
  if ( v18 )
  {
    if ( v19 == -1 )
    {
      v24 = (unsigned __int8 *)v18[2];
      if ( (unsigned int)v24 >= v18[3] )
      {
        v19 = (*(int (__fastcall **)(_DWORD *))(*v18 + 36))(v18);
        if ( v19 == -1 )
        {
          v20 = 1;
          v18 = 0;
          goto LABEL_6;
        }
      }
      else
      {
        v19 = *v24;
      }
    }
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
LABEL_6:
  v21 = !a5 || a6 == -1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v22 = v21 == v20;
  result = v9;
  *v9 = v18;
  if ( v21 == v20 )
    v21 = *a8;
  v9[1] = v19;
  if ( v22 )
    *a8 = v21 | 2;
  return result;
}

//----- (0009B6FC) --------------------------------------------------------
_DWORD *__fastcall sub_9B6FC(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r6
  int v10; // r10
  int v11; // r4
  _DWORD *v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  _DWORD *v17; // r4
  int v18; // r5
  signed int v19; // r8
  int v20; // r3
  bool v21; // zf
  _DWORD *result; // r0
  unsigned __int8 *v23; // r3
  char v24; // [sp+20h] [bp-98h]
  int v25; // [sp+24h] [bp-94h]
  _DWORD *v26; // [sp+28h] [bp-90h]
  int v27; // [sp+2Ch] [bp-8Ch]
  int v28; // [sp+30h] [bp-88h]
  int v29; // [sp+34h] [bp-84h]
  int v30; // [sp+38h] [bp-80h]
  int v31; // [sp+3Ch] [bp-7Ch]
  int v32; // [sp+40h] [bp-78h]
  int v33; // [sp+44h] [bp-74h]
  int v34; // [sp+48h] [bp-70h]
  int v35; // [sp+4Ch] [bp-6Ch]
  int v36; // [sp+50h] [bp-68h]
  int v37; // [sp+54h] [bp-64h]
  int v38; // [sp+58h] [bp-60h]
  int v39; // [sp+5Ch] [bp-5Ch]
  int v40; // [sp+60h] [bp-58h]
  int v41; // [sp+64h] [bp-54h]
  int v42; // [sp+68h] [bp-50h]
  int v43; // [sp+6Ch] [bp-4Ch]
  int v44; // [sp+70h] [bp-48h]
  int v45; // [sp+74h] [bp-44h]
  int v46; // [sp+78h] [bp-40h]
  int v47; // [sp+7Ch] [bp-3Ch]
  int v48; // [sp+80h] [bp-38h]
  int v49; // [sp+84h] [bp-34h]
  int v50; // [sp+88h] [bp-30h]
  int v51; // [sp+8Ch] [bp-2Ch]
  int v52; // [sp+90h] [bp-28h]
  int v53; // [sp+94h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v26 = a3;
  v27 = a4;
  v11 = sub_98DCC(a7 + 108);
  sub_97BC0(a7 + 108);
  v12 = *(_DWORD **)(v11 + 8);
  v13 = v12[39];
  v14 = v12[37];
  v15 = v12[38];
  v32 = v13;
  v16 = *(_DWORD *)(v11 + 8);
  v31 = v15;
  v30 = v14;
  v33 = *(_DWORD *)(v16 + 160);
  v34 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 164);
  v35 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 168);
  v36 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 172);
  v37 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 176);
  v38 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 180);
  v39 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 184);
  v40 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 188);
  v41 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 192);
  v42 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 100);
  v43 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 104);
  v44 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 108);
  v45 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 112);
  v46 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 116);
  v47 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 120);
  v48 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 124);
  v49 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 128);
  v50 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 132);
  v51 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 136);
  v52 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 140);
  v53 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 144);
  v29 = 0;
  sub_9B33C(&v24, v10, v26, v27, a5, a6, &v28, (int)&v30, 0xCu, a7, &v29);
  v26 = *(_DWORD **)&v24;
  v27 = v25;
  v17 = *(_DWORD **)&v24;
  v18 = v25;
  if ( v29 )
    *a8 |= 4u;
  else
    *(_DWORD *)(a9 + 16) = v28;
  if ( v17 )
  {
    if ( v18 == -1 )
    {
      v23 = (unsigned __int8 *)v17[2];
      if ( (unsigned int)v23 >= v17[3] )
      {
        v18 = (*(int (__fastcall **)(_DWORD *))(*v17 + 36))(v17);
        if ( v18 == -1 )
        {
          v19 = 1;
          v17 = 0;
          goto LABEL_6;
        }
      }
      else
      {
        v18 = *v23;
      }
    }
    v19 = 0;
  }
  else
  {
    v19 = 1;
  }
LABEL_6:
  v20 = !a5 || a6 == -1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v21 = v20 == v19;
  result = v9;
  *v9 = v17;
  if ( v20 == v19 )
    v20 = *a8;
  v9[1] = v18;
  if ( v21 )
    *a8 = v20 | 2;
  return result;
}

//----- (0009B8A4) --------------------------------------------------------
_DWORD *__fastcall sub_9B8A4(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, _DWORD *a8, int *a9, const char *a10)
{
  int v10; // r4
  const char *v11; // r11
  int v12; // r7
  int v13; // r5
  size_t v14; // r4
  size_t v15; // r10
  signed int v16; // r9
  signed int v17; // r3
  _BOOL4 v18; // r2
  int v19; // r8
  int v20; // r2
  int v21; // r9
  int v22; // r8
  int v23; // r2
  bool v24; // zf
  int v25; // r9
  int v26; // r1
  int v28; // r9
  signed int v29; // r3
  unsigned __int8 *v30; // r3
  int v31; // r0
  unsigned __int8 *v32; // r3
  int v33; // r0
  int v34; // r0
  unsigned __int8 *v35; // r3
  int v36; // r0
  int v37; // r0
  int v38; // r0
  int v39; // r9
  int v40; // r2
  int v41; // r9
  int v42; // r2
  _DWORD **v43; // r0
  int v44; // r3
  _DWORD *v45; // r0
  unsigned int *v46; // r1
  int *v47; // r2
  int v48; // r2
  _DWORD *v49; // r3
  int v50; // lr
  int v51; // r3
  _DWORD *v52; // r3
  int v53; // r3
  int v54; // r0
  int v55; // r3
  int v56; // r0
  const char *v57; // r1
  int v58; // r0
  char *v59; // r2
  int v60; // r3
  _DWORD *v61; // r3
  _DWORD *v62; // r3
  int v63; // r0
  int v64; // r0
  int v65; // ST28_4
  int v66; // ST28_4
  _DWORD *v67; // [sp+0h] [bp-C0h]
  unsigned int *v68; // [sp+4h] [bp-BCh]
  _DWORD *v69; // [sp+8h] [bp-B8h]
  int v70; // [sp+14h] [bp-ACh]
  int v71; // [sp+18h] [bp-A8h]
  int v72; // [sp+30h] [bp-90h]
  _DWORD *v73; // [sp+34h] [bp-8Ch]
  _DWORD *v74; // [sp+50h] [bp-70h]
  int v75; // [sp+54h] [bp-6Ch]
  _DWORD *v76; // [sp+58h] [bp-68h]
  int v77; // [sp+5Ch] [bp-64h]
  int v78; // [sp+60h] [bp-60h]
  int v79; // [sp+64h] [bp-5Ch]
  int v80; // [sp+68h] [bp-58h]
  int v81; // [sp+6Ch] [bp-54h]
  int v82; // [sp+70h] [bp-50h]
  int v83; // [sp+74h] [bp-4Ch]
  int v84; // [sp+78h] [bp-48h]
  int v85; // [sp+7Ch] [bp-44h]
  int v86; // [sp+80h] [bp-40h]
  int v87; // [sp+84h] [bp-3Ch]
  int v88; // [sp+88h] [bp-38h]
  int v89; // [sp+8Ch] [bp-34h]
  int v90; // [sp+90h] [bp-30h]
  int v91; // [sp+94h] [bp-2Ch]

  v73 = a1;
  v10 = a7 + 108;
  v76 = a3;
  v77 = a4;
  v72 = a2;
  v11 = a10;
  v12 = sub_98DCC(a7 + 108);
  v13 = sub_97BC0(v10);
  v14 = 0;
  v78 = 0;
  v15 = strlen(v11);
  while ( 1 )
  {
    if ( v76 )
    {
      if ( v77 != -1 )
      {
        v16 = 0;
        goto LABEL_6;
      }
      v30 = (unsigned __int8 *)v76[2];
      if ( (unsigned int)v30 < v76[3] )
      {
        v31 = *v30;
LABEL_36:
        v77 = v31;
        v16 = 0;
        goto LABEL_6;
      }
      v31 = (*(int (**)(void))(*v76 + 36))();
      if ( v31 != -1 )
        goto LABEL_36;
      v16 = 1;
      v76 = 0;
    }
    else
    {
      v16 = 1;
    }
LABEL_6:
    if ( a5 )
    {
      if ( a6 == (unsigned int *)-1 )
      {
        v32 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v32 >= a5[3] )
        {
          v33 = (*(int (**)(void))(*a5 + 36))();
          if ( v33 == -1 )
          {
            a5 = 0;
            v17 = 1;
            goto LABEL_10;
          }
        }
        else
        {
          v33 = *v32;
        }
        a6 = (unsigned int *)v33;
        v17 = 0;
      }
      else
      {
        v17 = 0;
      }
    }
    else
    {
      v17 = 1;
    }
LABEL_10:
    if ( v16 == v17 )
      break;
    v18 = v14 < v15;
    if ( v78 )
      v18 = 0;
    if ( !v18 )
      break;
    v19 = v13 + (unsigned __int8)v11[v14];
    v20 = *(unsigned __int8 *)(v19 + 285);
    if ( *(_BYTE *)(v19 + 285) )
      goto LABEL_15;
    v34 = (*(int (__fastcall **)(int))(*(_DWORD *)v13 + 32))(v13);
    if ( !v34 )
    {
LABEL_27:
      v28 = (unsigned __int8)v11[v14];
      if ( v76 )
      {
        if ( v77 == -1 )
        {
          v35 = (unsigned __int8 *)v76[2];
          if ( (unsigned int)v35 >= v76[3] )
          {
            v36 = (*(int (**)(void))(*v76 + 36))();
            if ( v36 == -1 )
            {
              v76 = 0;
              v29 = 255;
              goto LABEL_31;
            }
          }
          else
          {
            v36 = *v35;
          }
          v77 = v36;
          if ( v28 != (unsigned __int8)v36 )
          {
LABEL_32:
            v78 |= 4u;
            goto LABEL_33;
          }
        }
        else
        {
          v29 = (unsigned __int8)v77;
LABEL_31:
          if ( v28 != v29 )
            goto LABEL_32;
        }
LABEL_45:
        sub_9A76C(&v76);
        goto LABEL_33;
      }
      v29 = 255;
      goto LABEL_31;
    }
    v20 = v34;
    *(_BYTE *)(v19 + 285) = v34;
LABEL_15:
    if ( v20 != 37 )
      goto LABEL_27;
    v21 = v14 + 1;
    v22 = v13 + (unsigned __int8)v11[v14 + 1];
    v23 = *(unsigned __int8 *)(v22 + 285);
    if ( !*(_BYTE *)(v22 + 285) )
    {
      v37 = (*(int (__fastcall **)(int))(*(_DWORD *)v13 + 32))(v13);
      v23 = v37;
      if ( !v37 )
        goto LABEL_47;
      *(_BYTE *)(v22 + 285) = v37;
    }
    v24 = v23 == 69;
    if ( v23 != 69 )
      v24 = v23 == 79;
    v79 = 0;
    if ( v24 )
    {
      v14 += 2;
      v25 = v13 + (unsigned __int8)v11[v14];
      v23 = *(unsigned __int8 *)(v25 + 285);
      if ( !*(_BYTE *)(v25 + 285) )
      {
        v38 = (*(int (__fastcall **)(int))(*(_DWORD *)v13 + 32))(v13);
        v23 = v38;
        if ( !v38 )
        {
def_9B9A2:
          v21 = v14;
LABEL_47:
          v14 = v21;
          v78 |= 4u;
          goto LABEL_33;
        }
        *(_BYTE *)(v25 + 285) = v38;
      }
    }
    else
    {
      ++v14;
    }
    switch ( v23 )
    {
      case 65:
        v62 = *(_DWORD **)(v12 + 8);
        v80 = v62[11];
        v48 = 7;
        v81 = v62[12];
        v82 = v62[13];
        v83 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 56);
        v84 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 60);
        v85 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 64);
        v70 = a7;
        v67 = a5;
        v68 = a6;
        v86 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 68);
        v69 = a9 + 6;
        goto LABEL_69;
      case 66:
        v48 = 12;
        v61 = *(_DWORD **)(v12 + 8);
        v50 = (int)(a9 + 4);
        v80 = v61[25];
        v81 = v61[26];
        v82 = v61[27];
        v83 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 112);
        v84 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 116);
        v85 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 120);
        v86 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 124);
        v87 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 128);
        v88 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 132);
        v89 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 136);
        v90 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 140);
        v51 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 144);
        goto LABEL_68;
      case 67:
      case 89:
      case 121:
        sub_97D78(&v74, v72, v76, v77, a5, a6, &v79, 0, 9999, (unsigned int *)byte_4, a7, (unsigned int *)&v78);
        v76 = v74;
        v77 = v75;
        if ( !v78 )
        {
          if ( v79 >= 0 )
            v60 = v79 - 1900;
          else
            v60 = v79 + 100;
          a9[5] = v60;
        }
        break;
      case 68:
        v58 = v13;
        v57 = "%m/%d/%y";
        v59 = algn_E2D2D;
        goto LABEL_85;
      case 72:
        sub_97D78(
          &v74,
          v72,
          v76,
          v77,
          a5,
          a6,
          a9 + 2,
          0,
          23,
          (unsigned int *)((char *)&dword_0 + 2),
          a7,
          (unsigned int *)&v78);
        goto LABEL_65;
      case 73:
        sub_97D78(
          &v74,
          v72,
          v76,
          v77,
          a5,
          a6,
          a9 + 2,
          1,
          12,
          (unsigned int *)((char *)&dword_0 + 2),
          a7,
          (unsigned int *)&v78);
        goto LABEL_65;
      case 77:
        sub_97D78(
          &v74,
          v72,
          v76,
          v77,
          a5,
          a6,
          a9 + 1,
          0,
          59,
          (unsigned int *)((char *)&dword_0 + 2),
          a7,
          (unsigned int *)&v78);
        goto LABEL_65;
      case 82:
        v58 = v13;
        v57 = "%H:%M";
        v59 = algn_E2D36;
        goto LABEL_85;
      case 83:
        sub_97D78(
          &v74,
          v72,
          v76,
          v77,
          a5,
          a6,
          a9,
          0,
          61,
          (unsigned int *)((char *)&dword_0 + 2),
          a7,
          (unsigned int *)&v78);
        v76 = v74;
        v77 = v75;
        break;
      case 84:
        v57 = "%H:%M:%S";
        v58 = v13;
        v59 = algn_E2D41;
LABEL_85:
        sub_968D8(v58, v57, (int)v59, &v80);
        sub_9B8A4(&v74, v72, v76, v77, a5, a6, a7, &v78, a9, &v80);
        v76 = v74;
        v77 = v75;
        break;
      case 88:
        sub_9B8A4(&v74, v72, v76, v77, a5, a6, a7, &v78, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 16));
        v76 = v74;
        v77 = v75;
        break;
      case 90:
        if ( !(*(_BYTE *)(*(_DWORD *)(v13 + 24) + (unsigned __int8)sub_9B0A0(&v76)) & 1) )
          goto LABEL_32;
        sub_9B15C(&v74, v72, v76, v77, (int)a5, (int)a6, &v80, (int)off_F3C60, 14, a7, &v78);
        v76 = v74;
        v77 = v75;
        if ( !sub_9B0DC(&v76, &a5) && !v78 && !v80 )
        {
          v53 = (unsigned __int8)sub_9B0A0(&v76);
          if ( *(_BYTE *)(v13 + 28) )
          {
            v54 = *(unsigned __int8 *)(v13 + 74);
          }
          else
          {
            v65 = v53;
            v54 = sub_9667C(v13, 45);
            v53 = v65;
          }
          if ( v53 == v54
            || ((v55 = (unsigned __int8)sub_9B0A0(&v76), !*(_BYTE *)(v13 + 28)) ? (v66 = v55,
                                                                                   v56 = sub_9667C(v13, 43),
                                                                                   v55 = v66) : (v56 = *(unsigned __int8 *)(v13 + 72)),
                v55 == v56) )
          {
            sub_97D78(
              &v74,
              v72,
              v76,
              v77,
              a5,
              a6,
              &v80,
              0,
              23,
              (unsigned int *)((char *)&dword_0 + 2),
              a7,
              (unsigned int *)&v78);
            v76 = v74;
            v77 = v75;
            sub_97D78(
              &v74,
              v72,
              v74,
              v75,
              a5,
              a6,
              &v80,
              0,
              59,
              (unsigned int *)((char *)&dword_0 + 2),
              a7,
              (unsigned int *)&v78);
            v76 = v74;
            v77 = v75;
          }
        }
        break;
      case 97:
        v52 = *(_DWORD **)(v12 + 8);
        v80 = v52[18];
        v81 = v52[19];
        v82 = v52[20];
        v83 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 84);
        v84 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 88);
        v85 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 92);
        v86 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 96);
        sub_9B15C(&v74, v72, v76, v77, (int)a5, (int)a6, a9 + 6, (int)&v80, 7, a7, &v78);
        goto LABEL_70;
      case 98:
      case 104:
        v48 = 12;
        v49 = *(_DWORD **)(v12 + 8);
        v50 = (int)(a9 + 4);
        v80 = v49[37];
        v81 = v49[38];
        v82 = v49[39];
        v83 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 160);
        v84 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 164);
        v85 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 168);
        v86 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 172);
        v87 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 176);
        v88 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 180);
        v89 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 184);
        v90 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 188);
        v51 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 192);
LABEL_68:
        v91 = v51;
        v69 = (_DWORD *)v50;
        v70 = a7;
        v67 = a5;
        v68 = a6;
LABEL_69:
        sub_9B15C(&v74, v72, v76, v77, (int)v67, (int)v68, v69, (int)&v80, v48, v70, &v78);
LABEL_70:
        v76 = v74;
        v77 = v75;
        break;
      case 99:
        sub_9B8A4(&v74, v72, v76, v77, a5, a6, a7, &v78, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 24));
        v76 = v74;
        v77 = v75;
        break;
      case 100:
        v44 = 1;
        v45 = a5;
        v46 = a6;
        v71 = a7;
        v47 = a9 + 3;
        goto LABEL_64;
      case 101:
        if ( *(_BYTE *)(*(_DWORD *)(v13 + 24) + (unsigned __int8)sub_9B0A0(&v76)) & 8 )
        {
          v43 = sub_9A76C(&v76);
          sub_97D78(
            &v74,
            v72,
            *v43,
            (signed int)v43[1],
            a5,
            a6,
            a9 + 3,
            1,
            9,
            (unsigned int *)((char *)&dword_0 + 1),
            a7,
            (unsigned int *)&v78);
          v76 = v74;
          v77 = v75;
        }
        else
        {
          v44 = 10;
          v45 = a5;
          v46 = a6;
          v71 = a7;
          v47 = a9 + 3;
LABEL_64:
          sub_97D78(
            &v74,
            v72,
            v76,
            v77,
            v45,
            v46,
            v47,
            v44,
            31,
            (unsigned int *)((char *)&dword_0 + 2),
            v71,
            (unsigned int *)&v78);
LABEL_65:
          v76 = v74;
          v77 = v75;
        }
        break;
      case 109:
        sub_97D78(
          &v74,
          v72,
          v76,
          v77,
          a5,
          a6,
          &v79,
          1,
          12,
          (unsigned int *)((char *)&dword_0 + 2),
          a7,
          (unsigned int *)&v78);
        v76 = v74;
        v77 = v75;
        if ( !v78 )
          a9[4] = v79 - 1;
        break;
      case 110:
        v41 = v13 + (unsigned __int8)sub_9B0A0(&v76);
        v42 = *(unsigned __int8 *)(v41 + 285);
        if ( *(_BYTE *)(v41 + 285) )
          goto LABEL_57;
        v63 = (*(int (__fastcall **)(int))(*(_DWORD *)v13 + 32))(v13);
        if ( v63 )
        {
          v42 = v63;
          *(_BYTE *)(v41 + 285) = v63;
LABEL_57:
          if ( v42 == 10 )
            goto LABEL_45;
        }
        goto LABEL_32;
      case 116:
        v39 = v13 + (unsigned __int8)sub_9B0A0(&v76);
        v40 = *(unsigned __int8 *)(v39 + 285);
        if ( *(_BYTE *)(v39 + 285) )
          goto LABEL_54;
        v64 = (*(int (__fastcall **)(int))(*(_DWORD *)v13 + 32))(v13);
        if ( v64 )
        {
          v40 = v64;
          *(_BYTE *)(v39 + 285) = v64;
LABEL_54:
          if ( v40 == 9 )
            goto LABEL_45;
        }
        goto LABEL_32;
      case 120:
        sub_9B8A4(&v74, v72, v76, v77, a5, a6, a7, &v78, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 8));
        v76 = v74;
        v77 = v75;
        break;
      default:
        goto def_9B9A2;
    }
LABEL_33:
    ++v14;
  }
  if ( v78 || v14 != v15 )
    *a8 |= 4u;
  v26 = v77;
  *v73 = v76;
  v73[1] = v26;
  return v73;
}
// 0: using guessed type int dword_0;
// F3C60: using guessed type char *off_F3C60[14];

//----- (0009C16C) --------------------------------------------------------
_DWORD *__fastcall sub_9C16C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int *a9)
{
  _DWORD *v9; // r5
  int v10; // r9
  int v11; // r0
  int v12; // r4
  int v13; // r6
  signed int v14; // r7
  int v15; // r3
  bool v16; // zf
  _DWORD *result; // r0
  unsigned __int8 *v18; // r3
  char v19; // [sp+18h] [bp-30h]
  int v20; // [sp+1Ch] [bp-2Ch]
  _DWORD *v21; // [sp+20h] [bp-28h]
  int v22; // [sp+24h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v21 = a3;
  v22 = a4;
  v11 = sub_98DCC(a7 + 108);
  sub_9B8A4(&v19, v10, v21, v22, a5, a6, a7, a8, a9, *(const char **)(*(_DWORD *)(v11 + 8) + 16));
  v21 = *(_DWORD **)&v19;
  v22 = v20;
  v12 = *(_DWORD *)&v19;
  v13 = v20;
  if ( *(_DWORD *)&v19 )
  {
    if ( v22 == -1 )
    {
      v18 = (unsigned __int8 *)v21[2];
      if ( (unsigned int)v18 >= v21[3] )
      {
        v13 = (*(int (__fastcall **)(_DWORD *))(*v21 + 36))(v21);
        if ( v13 == -1 )
        {
          v14 = 1;
          v12 = 0;
          goto LABEL_4;
        }
      }
      else
      {
        v13 = *v18;
      }
    }
    v14 = 0;
  }
  else
  {
    v14 = 1;
  }
LABEL_4:
  v15 = !a5 || a6 == (unsigned int *)-1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v16 = v14 == v15;
  result = v9;
  *v9 = v12;
  if ( v14 == v15 )
    v15 = *a8;
  v9[1] = v13;
  if ( v16 )
    *a8 = v15 | 2;
  return result;
}

//----- (0009C22C) --------------------------------------------------------
_DWORD *__fastcall sub_9C22C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int *a9)
{
  _DWORD *v9; // r5
  int v10; // r9
  int v11; // r0
  int v12; // r4
  int v13; // r6
  signed int v14; // r7
  int v15; // r3
  bool v16; // zf
  _DWORD *result; // r0
  unsigned __int8 *v18; // r3
  char v19; // [sp+18h] [bp-30h]
  int v20; // [sp+1Ch] [bp-2Ch]
  _DWORD *v21; // [sp+20h] [bp-28h]
  int v22; // [sp+24h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v21 = a3;
  v22 = a4;
  v11 = sub_98DCC(a7 + 108);
  sub_9B8A4(&v19, v10, v21, v22, a5, a6, a7, a8, a9, *(const char **)(*(_DWORD *)(v11 + 8) + 8));
  v21 = *(_DWORD **)&v19;
  v22 = v20;
  v12 = *(_DWORD *)&v19;
  v13 = v20;
  if ( *(_DWORD *)&v19 )
  {
    if ( v22 == -1 )
    {
      v18 = (unsigned __int8 *)v21[2];
      if ( (unsigned int)v18 >= v21[3] )
      {
        v13 = (*(int (__fastcall **)(_DWORD *))(*v21 + 36))(v21);
        if ( v13 == -1 )
        {
          v14 = 1;
          v12 = 0;
          goto LABEL_4;
        }
      }
      else
      {
        v13 = *v18;
      }
    }
    v14 = 0;
  }
  else
  {
    v14 = 1;
  }
LABEL_4:
  v15 = !a5 || a6 == (unsigned int *)-1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v16 = v14 == v15;
  result = v9;
  *v9 = v12;
  if ( v14 == v15 )
    v15 = *a8;
  v9[1] = v13;
  if ( v16 )
    *a8 = v15 | 2;
  return result;
}

//----- (0009C2EC) --------------------------------------------------------
_DWORD *__fastcall sub_9C2EC(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int *v9; // r4
  int v10; // r11
  int v11; // r0
  int v12; // r9
  int v13; // r3
  char *v14; // r6
  signed int v15; // r7
  _DWORD *v16; // r0
  signed int v17; // r5
  _DWORD *v18; // r0
  signed int v19; // r3
  int v20; // r3
  int v21; // r2
  _DWORD *v22; // r0
  signed int v23; // r5
  _DWORD *v24; // r0
  signed int v25; // r3
  signed int v26; // r5
  int v27; // r1
  char *v28; // r0
  _BYTE *v29; // r3
  int v30; // r1
  int v31; // r5
  char v32; // r7
  _DWORD *v33; // r3
  unsigned int v34; // r3
  unsigned int *v35; // r3
  int v36; // r1
  _BOOL4 v38; // r3
  int v39; // r3
  int v40; // r5
  unsigned int i; // r4
  signed int v42; // r0
  unsigned int v43; // r2
  _DWORD *v44; // r3
  _BYTE *v45; // r3
  char v46; // r1
  unsigned __int8 *v47; // r3
  int v48; // r0
  signed int v49; // r3
  unsigned int v50; // r3
  unsigned __int8 *v51; // r3
  int v52; // r0
  unsigned __int8 *v53; // r3
  int v54; // r0
  unsigned __int8 *v55; // r3
  int v56; // r0
  unsigned __int8 *v57; // r3
  int v58; // r0
  unsigned __int8 *v59; // r3
  int v60; // r0
  int v61; // r10
  int v62; // r5
  _DWORD *v63; // r0
  signed int v64; // r7
  _DWORD *v65; // r0
  signed int v66; // r3
  unsigned int v67; // r3
  unsigned __int8 *v68; // r3
  int v69; // r0
  unsigned __int8 *v70; // r3
  int v71; // r0
  unsigned __int8 v72; // r0
  int v73; // t1
  void *s; // [sp+8h] [bp-80h]
  int v75; // [sp+Ch] [bp-7Ch]
  int v76; // [sp+14h] [bp-74h]
  signed int v77; // [sp+20h] [bp-68h]
  unsigned int v78; // [sp+28h] [bp-60h]
  char v79; // [sp+2Ch] [bp-5Ch]
  signed int v80; // [sp+30h] [bp-58h]
  _DWORD *v81; // [sp+34h] [bp-54h]
  _BOOL4 v82; // [sp+3Ch] [bp-4Ch]
  _DWORD *v83; // [sp+40h] [bp-48h]
  int v84; // [sp+44h] [bp-44h]
  char v85; // [sp+4Ch] [bp-3Ch]
  _DWORD *v86; // [sp+54h] [bp-34h]
  char *v87; // [sp+58h] [bp-30h]
  int v88; // [sp+5Ch] [bp-2Ch]

  v81 = a1;
  v9 = (int *)(a7 + 108);
  v83 = a3;
  v84 = a4;
  v10 = sub_97BC0(a7 + 108);
  v11 = sub_9A6C4((int)&v85, v9);
  v12 = v11;
  v76 = v11 + 56;
  if ( *(_DWORD *)(v11 + 32) )
    v82 = *(_DWORD *)(v11 + 40) != 0;
  else
    v82 = 0;
  v13 = *(unsigned __int8 *)(v11 + 16);
  v86 = &unk_2FEF48;
  if ( v13 )
    sub_C1264(&v86, 0x20u);
  v87 = (char *)&unk_2FEF48;
  sub_C1264(&v87, 0x20u);
  v14 = 0;
  v75 = 0;
  v77 = 0;
  v88 = *(_DWORD *)(v12 + 52);
  v79 = 0;
  v78 = 0;
  v80 = 0;
  s = (void *)(v12 + 57);
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v88 + v75) )
    {
      case 0u:
        goto LABEL_9;
      case 1u:
        if ( sub_9B0DC(&v83, &a5) || !(*(_BYTE *)(*(_DWORD *)(v10 + 24) + (unsigned __int8)sub_9B0A0(&v83)) & 8) )
        {
          v15 = 0;
          if ( v75 == 3 )
            goto LABEL_65;
LABEL_10:
          v16 = v83;
LABEL_11:
          if ( v16 )
          {
            if ( v84 != -1 )
            {
              v17 = 0;
              goto LABEL_15;
            }
            v51 = (unsigned __int8 *)v16[2];
            if ( (unsigned int)v51 >= v16[3] )
            {
              v52 = (*(int (**)(void))(*v16 + 36))();
              if ( v52 == -1 )
              {
                v83 = 0;
                v17 = 1;
                goto LABEL_15;
              }
            }
            else
            {
              v52 = *v51;
            }
            v84 = v52;
            v17 = 0;
            v18 = a5;
            if ( a5 )
              goto LABEL_16;
LABEL_118:
            v19 = 1;
            goto LABEL_19;
          }
          while ( 1 )
          {
            v17 = 1;
LABEL_15:
            v18 = a5;
            if ( !a5 )
              goto LABEL_118;
LABEL_16:
            if ( a6 != -1 )
              break;
            v47 = (unsigned __int8 *)v18[2];
            if ( (unsigned int)v47 >= v18[3] )
            {
              v48 = (*(int (**)(void))(*v18 + 36))();
              if ( v48 == -1 )
              {
                a5 = 0;
                v19 = 1;
LABEL_19:
                if ( v19 == v17 )
                  goto LABEL_20;
                goto LABEL_106;
              }
            }
            else
            {
              v48 = *v47;
            }
            a6 = v48;
            if ( !v17 )
              goto LABEL_20;
LABEL_106:
            if ( v83 )
            {
              if ( v84 == -1 )
              {
                v59 = (unsigned __int8 *)v83[2];
                if ( (unsigned int)v59 >= v83[3] )
                {
                  v60 = (*(int (**)(void))(*v83 + 36))();
                  if ( v60 == -1 )
                  {
                    v83 = 0;
                    v49 = 255;
                    goto LABEL_110;
                  }
                }
                else
                {
                  v60 = *v59;
                }
                v84 = v60;
                v49 = (unsigned __int8)v60;
              }
              else
              {
                v49 = (unsigned __int8)v84;
              }
            }
            else
            {
              v49 = 255;
            }
LABEL_110:
            if ( !(*(_BYTE *)(*(_DWORD *)(v10 + 24) + v49) & 8) )
              goto LABEL_20;
            v16 = v83;
            if ( v83 )
            {
              v50 = v83[2];
              if ( v50 >= v83[3] )
              {
                (*(void (**)(void))(*v83 + 40))();
                v16 = v83;
              }
              else
              {
                v83[2] = v50 + 1;
              }
              v84 = -1;
              goto LABEL_11;
            }
          }
          v19 = 0;
          goto LABEL_19;
        }
        sub_9A76C(&v83);
LABEL_9:
        v15 = 1;
        if ( v75 != 3 )
          goto LABEL_10;
LABEL_65:
        if ( v78 > 1 )
          v39 = v15 & 1;
        else
          v39 = 0;
LABEL_68:
        if ( !v39 )
        {
          if ( v15 )
            goto LABEL_75;
          goto LABEL_52;
        }
        if ( v80 )
          v40 = *(_DWORD *)(v12 + 36);
        else
          v40 = *(_DWORD *)(v12 + 28);
        for ( i = 1; !sub_9B0DC(&v83, &a5) && i < v78; ++i )
        {
          v72 = sub_9B0A0(&v83);
          v73 = *(unsigned __int8 *)(v40++ + 1);
          if ( v73 != v72 )
            goto LABEL_52;
          sub_9A76C(&v83);
        }
        if ( i != v78 )
          goto LABEL_52;
LABEL_75:
        if ( *((_DWORD *)v87 - 3) > 1u )
        {
          v42 = sub_C0768((int *)&v87, 48, 0);
          if ( v42 )
          {
            v44 = (_DWORD *)(v42 + 1);
            if ( v42 == -1 )
              v44 = v87;
            else
              v43 = v42;
            if ( v42 == -1 )
              v43 = *(v44 - 3) - 1;
            sub_C0D44((int *)&v87, 0, v43);
          }
        }
        if ( v80 )
        {
          v45 = v87;
          if ( *((_DWORD *)v87 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v87);
            v45 = v87;
          }
          if ( *v45 != 48 )
          {
            if ( *((_DWORD *)v45 - 1) >= 0 )
              sub_C0BF4((int *)&v87);
            sub_C0DB8((int *)&v87, 0, 0, 1u, 0x2Du);
            *((_DWORD *)v87 - 1) = -1;
          }
        }
        if ( *(v86 - 3) )
        {
          v46 = (char)v14;
          if ( v77 )
            v46 = v79;
          sub_C15D0((int *)&v86, v46);
          if ( !sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v86) )
            *a8 |= 4u;
        }
        if ( v77 && *(char **)(v12 + 44) != v14 )
        {
LABEL_52:
          *a8 |= 4u;
          goto LABEL_53;
        }
        sub_C0480(a9, (int *)&v87);
LABEL_53:
        if ( sub_9B0DC(&v83, &a5) )
          *a8 |= 2u;
        v35 = (unsigned int *)v87;
        v36 = v84;
        *v81 = v83;
        v81[1] = v36;
        sub_C0AC4(v35 - 3);
        sub_C0AC4(v86 - 3);
        return v81;
      case 2u:
        if ( *(_DWORD *)(a7 + 12) & 0x200 )
          goto LABEL_142;
        v38 = v75 == 0;
        if ( v78 > 1 )
          v38 = 1;
        if ( v38 )
          goto LABEL_142;
        if ( v75 == 1 )
        {
          if ( v82 || (unsigned __int8)v88 == 3 )
            goto LABEL_142;
          if ( BYTE2(v88) == 1 )
          {
            v61 = *(_DWORD *)(v12 + 24);
            v62 = 0;
            v63 = v83;
LABEL_143:
            if ( !v63 )
              goto LABEL_162;
            while ( 2 )
            {
              if ( v84 != -1 )
              {
                v64 = 0;
                goto LABEL_147;
              }
              v70 = (unsigned __int8 *)v63[2];
              if ( (unsigned int)v70 < v63[3] )
              {
                v71 = *v70;
                goto LABEL_171;
              }
              v71 = (*(int (**)(void))(*v63 + 36))();
              if ( v71 == -1 )
              {
                v83 = 0;
                v64 = 1;
              }
              else
              {
LABEL_171:
                v84 = v71;
                v64 = 0;
              }
LABEL_147:
              v65 = a5;
              if ( a5 )
              {
LABEL_148:
                if ( a6 != -1 )
                {
                  v66 = 0;
                  goto LABEL_151;
                }
                v68 = (unsigned __int8 *)v65[2];
                if ( (unsigned int)v68 < v65[3] )
                {
                  v69 = *v68;
                  goto LABEL_168;
                }
                v69 = (*(int (**)(void))(*v65 + 36))();
                if ( v69 == -1 )
                {
                  a5 = 0;
                  v66 = 1;
                }
                else
                {
LABEL_168:
                  a6 = v69;
                  v66 = 0;
                }
LABEL_151:
                if ( v66 != v64 )
                {
LABEL_152:
                  if ( v62 != v61 )
                  {
                    if ( *(unsigned __int8 *)(*(_DWORD *)(v12 + 20) + v62) != (unsigned __int8)sub_9B0A0(&v83) )
                      goto LABEL_154;
                    v63 = v83;
                    if ( v83 )
                    {
                      v67 = v83[2];
                      if ( v67 >= v83[3] )
                      {
                        (*(void (**)(void))(*v83 + 40))();
                        v63 = v83;
                      }
                      else
                      {
                        v83[2] = v67 + 1;
                      }
                      v84 = -1;
                    }
                    ++v62;
                    if ( v63 )
                      continue;
LABEL_162:
                    v65 = a5;
                    v64 = 1;
                    if ( a5 )
                      goto LABEL_148;
                    goto LABEL_163;
                  }
def_9C3A6:
                  v15 = 1;
                  goto LABEL_20;
                }
              }
              else
              {
LABEL_163:
                if ( v64 != 1 )
                  goto LABEL_152;
              }
              break;
            }
            if ( v62 != v61 )
            {
LABEL_154:
              if ( v62 || *(_DWORD *)(a7 + 12) & 0x200 )
                goto LABEL_52;
            }
            goto def_9C3A6;
          }
          v20 = 2;
        }
        else
        {
          if ( v75 != 2 )
            goto def_9C3A6;
          if ( HIBYTE(v88) == 4 || v82 && HIBYTE(v88) == 3 )
          {
LABEL_142:
            v61 = *(_DWORD *)(v12 + 24);
            v62 = 0;
            v63 = v83;
            goto LABEL_143;
          }
          v20 = 3;
        }
        goto LABEL_24;
      case 3u:
        if ( *(_DWORD *)(v12 + 32)
          && !sub_9B0DC(&v83, &a5)
          && **(unsigned __int8 **)(v12 + 28) == (unsigned __int8)sub_9B0A0(&v83) )
        {
          v78 = *(_DWORD *)(v12 + 32);
          sub_9A76C(&v83);
          goto def_9C3A6;
        }
        if ( !*(_DWORD *)(v12 + 40)
          || sub_9B0DC(&v83, &a5)
          || **(unsigned __int8 **)(v12 + 36) != (unsigned __int8)sub_9B0A0(&v83) )
        {
          if ( !*(_DWORD *)(v12 + 32) || *(_DWORD *)(v12 + 40) )
          {
            v15 = !v82;
          }
          else
          {
            v80 = 1;
            v15 = 1;
          }
        }
        else
        {
          v78 = *(_DWORD *)(v12 + 40);
          sub_9A76C(&v83);
          v15 = 1;
          v80 = 1;
        }
        goto LABEL_20;
      case 4u:
        v22 = v83;
        if ( v83 )
          goto LABEL_26;
        while ( 2 )
        {
          v24 = a5;
          v23 = 1;
          if ( !a5 )
          {
LABEL_49:
            if ( v23 != 1 )
              goto LABEL_34;
LABEL_50:
            v15 = 1;
            goto LABEL_51;
          }
LABEL_30:
          if ( a6 != -1 )
          {
            v25 = 0;
            goto LABEL_33;
          }
          v53 = (unsigned __int8 *)v24[2];
          if ( (unsigned int)v53 < v24[3] )
          {
            v54 = *v53;
LABEL_121:
            a6 = v54;
            v25 = 0;
            goto LABEL_33;
          }
          v54 = (*(int (**)(void))(*v24 + 36))();
          if ( v54 != -1 )
            goto LABEL_121;
          a5 = 0;
          v25 = 1;
LABEL_33:
          if ( v25 == v23 )
            goto LABEL_50;
LABEL_34:
          if ( !v83 )
          {
            v27 = 255;
            v26 = 255;
            goto LABEL_38;
          }
          if ( v84 != -1 )
          {
            v26 = (unsigned __int8)v84;
            v27 = (unsigned __int8)v84;
            goto LABEL_38;
          }
          v57 = (unsigned __int8 *)v83[2];
          if ( (unsigned int)v57 >= v83[3] )
          {
            v58 = (*(int (**)(void))(*v83 + 36))();
            if ( v58 == -1 )
            {
              v83 = 0;
              v27 = 255;
              v26 = 255;
LABEL_38:
              v28 = (char *)memchr(s, v27, 0xAu);
              if ( v28 )
                goto LABEL_39;
              goto LABEL_128;
            }
          }
          else
          {
            v58 = *v57;
          }
          v26 = (unsigned __int8)v58;
          v84 = v58;
          v28 = (char *)memchr(s, (unsigned __int8)v58, 0xAu);
          if ( v28 )
          {
LABEL_39:
            v29 = v87;
            v30 = *((_DWORD *)v87 - 3);
            v31 = v30 + 1;
            v32 = off_F3C5C[0][(unsigned int)&v28[-v76]];
            if ( (unsigned int)(v30 + 1) > *((_DWORD *)v87 - 2) || *((_DWORD *)v87 - 1) > 0 )
            {
              sub_C1264(&v87, v30 + 1);
              v29 = v87;
              v30 = *((_DWORD *)v87 - 3);
            }
            v29[v30] = v32;
            ++v14;
            v33 = v87;
            if ( v87 - 12 != (char *)&dword_2FEF3C )
            {
              *((_DWORD *)v87 - 1) = 0;
              *(v33 - 3) = v31;
              *((_BYTE *)v33 + v31) = 0;
            }
            goto LABEL_44;
          }
LABEL_128:
          if ( *(unsigned __int8 *)(v12 + 17) == v26 && !v77 )
          {
            if ( *(_DWORD *)(v12 + 44) <= 0 )
              goto LABEL_50;
            v79 = (char)v14;
            v14 = v28;
            v77 = 1;
LABEL_44:
            v22 = v83;
            if ( !v83 )
              continue;
            v34 = v83[2];
            if ( v34 >= v83[3] )
            {
              (*(void (**)(void))(*v83 + 40))();
              v22 = v83;
            }
            else
            {
              v83[2] = v34 + 1;
            }
            v84 = -1;
            if ( !v22 )
              continue;
LABEL_26:
            if ( v84 != -1 )
            {
              v23 = 0;
              goto LABEL_29;
            }
            v55 = (unsigned __int8 *)v22[2];
            if ( (unsigned int)v55 < v22[3] )
            {
              v56 = *v55;
              goto LABEL_124;
            }
            v56 = (*(int (**)(void))(*v22 + 36))();
            if ( v56 == -1 )
            {
              v83 = 0;
              v23 = 1;
            }
            else
            {
LABEL_124:
              v84 = v56;
              v23 = 0;
            }
LABEL_29:
            v24 = a5;
            if ( !a5 )
              goto LABEL_49;
            goto LABEL_30;
          }
          break;
        }
        if ( !*(_BYTE *)(v12 + 16) || *(unsigned __int8 *)(v12 + 18) != v26 || v77 )
          goto LABEL_50;
        if ( v14 )
        {
          sub_C15D0((int *)&v86, (char)v14);
          v14 = 0;
          goto LABEL_44;
        }
        v15 = 0;
LABEL_51:
        if ( !*((_DWORD *)v87 - 3) )
          goto LABEL_52;
LABEL_20:
        v20 = v75 + 1;
        if ( v75 + 1 <= 3 )
          v21 = v15 & 1;
        else
          v21 = 0;
        if ( !v21 )
        {
          if ( v78 > 1 )
            v39 = v15 & 1;
          else
            v39 = 0;
          goto LABEL_68;
        }
LABEL_24:
        v75 = v20;
        continue;
      default:
        goto def_9C3A6;
    }
  }
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009CA58) --------------------------------------------------------
_DWORD *__fastcall sub_9CA58(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int *v9; // r4
  int v10; // r11
  int v11; // r0
  int v12; // r9
  int v13; // r3
  char *v14; // r6
  signed int v15; // r7
  _DWORD *v16; // r0
  signed int v17; // r5
  _DWORD *v18; // r0
  signed int v19; // r3
  int v20; // r3
  int v21; // r2
  _DWORD *v22; // r0
  signed int v23; // r5
  _DWORD *v24; // r0
  signed int v25; // r3
  signed int v26; // r5
  int v27; // r1
  char *v28; // r0
  _BYTE *v29; // r3
  int v30; // r1
  int v31; // r5
  char v32; // r7
  _DWORD *v33; // r3
  unsigned int v34; // r3
  unsigned int *v35; // r3
  int v36; // r1
  _BOOL4 v38; // r3
  int v39; // r3
  int v40; // r5
  unsigned int i; // r4
  signed int v42; // r0
  unsigned int v43; // r2
  _DWORD *v44; // r3
  _BYTE *v45; // r3
  char v46; // r1
  unsigned __int8 *v47; // r3
  int v48; // r0
  signed int v49; // r3
  unsigned int v50; // r3
  unsigned __int8 *v51; // r3
  int v52; // r0
  unsigned __int8 *v53; // r3
  int v54; // r0
  unsigned __int8 *v55; // r3
  int v56; // r0
  unsigned __int8 *v57; // r3
  int v58; // r0
  unsigned __int8 *v59; // r3
  int v60; // r0
  int v61; // r10
  int v62; // r5
  _DWORD *v63; // r0
  signed int v64; // r7
  _DWORD *v65; // r0
  signed int v66; // r3
  unsigned int v67; // r3
  unsigned __int8 *v68; // r3
  int v69; // r0
  unsigned __int8 *v70; // r3
  int v71; // r0
  unsigned __int8 v72; // r0
  int v73; // t1
  void *s; // [sp+8h] [bp-80h]
  int v75; // [sp+Ch] [bp-7Ch]
  int v76; // [sp+14h] [bp-74h]
  signed int v77; // [sp+20h] [bp-68h]
  unsigned int v78; // [sp+28h] [bp-60h]
  char v79; // [sp+2Ch] [bp-5Ch]
  signed int v80; // [sp+30h] [bp-58h]
  _DWORD *v81; // [sp+34h] [bp-54h]
  _BOOL4 v82; // [sp+3Ch] [bp-4Ch]
  _DWORD *v83; // [sp+40h] [bp-48h]
  int v84; // [sp+44h] [bp-44h]
  char v85; // [sp+4Ch] [bp-3Ch]
  _DWORD *v86; // [sp+54h] [bp-34h]
  char *v87; // [sp+58h] [bp-30h]
  int v88; // [sp+5Ch] [bp-2Ch]

  v81 = a1;
  v9 = (int *)(a7 + 108);
  v83 = a3;
  v84 = a4;
  v10 = sub_97BC0(a7 + 108);
  v11 = sub_9A794((int)&v85, v9);
  v12 = v11;
  v76 = v11 + 56;
  if ( *(_DWORD *)(v11 + 32) )
    v82 = *(_DWORD *)(v11 + 40) != 0;
  else
    v82 = 0;
  v13 = *(unsigned __int8 *)(v11 + 16);
  v86 = &unk_2FEF48;
  if ( v13 )
    sub_C1264(&v86, 0x20u);
  v87 = (char *)&unk_2FEF48;
  sub_C1264(&v87, 0x20u);
  v14 = 0;
  v75 = 0;
  v77 = 0;
  v88 = *(_DWORD *)(v12 + 52);
  v79 = 0;
  v78 = 0;
  v80 = 0;
  s = (void *)(v12 + 57);
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v88 + v75) )
    {
      case 0u:
        goto LABEL_9;
      case 1u:
        if ( sub_9B0DC(&v83, &a5) || !(*(_BYTE *)(*(_DWORD *)(v10 + 24) + (unsigned __int8)sub_9B0A0(&v83)) & 8) )
        {
          v15 = 0;
          if ( v75 == 3 )
            goto LABEL_65;
LABEL_10:
          v16 = v83;
LABEL_11:
          if ( v16 )
          {
            if ( v84 != -1 )
            {
              v17 = 0;
              goto LABEL_15;
            }
            v51 = (unsigned __int8 *)v16[2];
            if ( (unsigned int)v51 >= v16[3] )
            {
              v52 = (*(int (**)(void))(*v16 + 36))();
              if ( v52 == -1 )
              {
                v83 = 0;
                v17 = 1;
                goto LABEL_15;
              }
            }
            else
            {
              v52 = *v51;
            }
            v84 = v52;
            v17 = 0;
            v18 = a5;
            if ( a5 )
              goto LABEL_16;
LABEL_118:
            v19 = 1;
            goto LABEL_19;
          }
          while ( 1 )
          {
            v17 = 1;
LABEL_15:
            v18 = a5;
            if ( !a5 )
              goto LABEL_118;
LABEL_16:
            if ( a6 != -1 )
              break;
            v47 = (unsigned __int8 *)v18[2];
            if ( (unsigned int)v47 >= v18[3] )
            {
              v48 = (*(int (**)(void))(*v18 + 36))();
              if ( v48 == -1 )
              {
                a5 = 0;
                v19 = 1;
LABEL_19:
                if ( v19 == v17 )
                  goto LABEL_20;
                goto LABEL_106;
              }
            }
            else
            {
              v48 = *v47;
            }
            a6 = v48;
            if ( !v17 )
              goto LABEL_20;
LABEL_106:
            if ( v83 )
            {
              if ( v84 == -1 )
              {
                v59 = (unsigned __int8 *)v83[2];
                if ( (unsigned int)v59 >= v83[3] )
                {
                  v60 = (*(int (**)(void))(*v83 + 36))();
                  if ( v60 == -1 )
                  {
                    v83 = 0;
                    v49 = 255;
                    goto LABEL_110;
                  }
                }
                else
                {
                  v60 = *v59;
                }
                v84 = v60;
                v49 = (unsigned __int8)v60;
              }
              else
              {
                v49 = (unsigned __int8)v84;
              }
            }
            else
            {
              v49 = 255;
            }
LABEL_110:
            if ( !(*(_BYTE *)(*(_DWORD *)(v10 + 24) + v49) & 8) )
              goto LABEL_20;
            v16 = v83;
            if ( v83 )
            {
              v50 = v83[2];
              if ( v50 >= v83[3] )
              {
                (*(void (**)(void))(*v83 + 40))();
                v16 = v83;
              }
              else
              {
                v83[2] = v50 + 1;
              }
              v84 = -1;
              goto LABEL_11;
            }
          }
          v19 = 0;
          goto LABEL_19;
        }
        sub_9A76C(&v83);
LABEL_9:
        v15 = 1;
        if ( v75 != 3 )
          goto LABEL_10;
LABEL_65:
        if ( v78 > 1 )
          v39 = v15 & 1;
        else
          v39 = 0;
LABEL_68:
        if ( !v39 )
        {
          if ( v15 )
            goto LABEL_75;
          goto LABEL_52;
        }
        if ( v80 )
          v40 = *(_DWORD *)(v12 + 36);
        else
          v40 = *(_DWORD *)(v12 + 28);
        for ( i = 1; !sub_9B0DC(&v83, &a5) && i < v78; ++i )
        {
          v72 = sub_9B0A0(&v83);
          v73 = *(unsigned __int8 *)(v40++ + 1);
          if ( v73 != v72 )
            goto LABEL_52;
          sub_9A76C(&v83);
        }
        if ( i != v78 )
          goto LABEL_52;
LABEL_75:
        if ( *((_DWORD *)v87 - 3) > 1u )
        {
          v42 = sub_C0768((int *)&v87, 48, 0);
          if ( v42 )
          {
            v44 = (_DWORD *)(v42 + 1);
            if ( v42 == -1 )
              v44 = v87;
            else
              v43 = v42;
            if ( v42 == -1 )
              v43 = *(v44 - 3) - 1;
            sub_C0D44((int *)&v87, 0, v43);
          }
        }
        if ( v80 )
        {
          v45 = v87;
          if ( *((_DWORD *)v87 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v87);
            v45 = v87;
          }
          if ( *v45 != 48 )
          {
            if ( *((_DWORD *)v45 - 1) >= 0 )
              sub_C0BF4((int *)&v87);
            sub_C0DB8((int *)&v87, 0, 0, 1u, 0x2Du);
            *((_DWORD *)v87 - 1) = -1;
          }
        }
        if ( *(v86 - 3) )
        {
          v46 = (char)v14;
          if ( v77 )
            v46 = v79;
          sub_C15D0((int *)&v86, v46);
          if ( !sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v86) )
            *a8 |= 4u;
        }
        if ( v77 && *(char **)(v12 + 44) != v14 )
        {
LABEL_52:
          *a8 |= 4u;
          goto LABEL_53;
        }
        sub_C0480(a9, (int *)&v87);
LABEL_53:
        if ( sub_9B0DC(&v83, &a5) )
          *a8 |= 2u;
        v35 = (unsigned int *)v87;
        v36 = v84;
        *v81 = v83;
        v81[1] = v36;
        sub_C0AC4(v35 - 3);
        sub_C0AC4(v86 - 3);
        return v81;
      case 2u:
        if ( *(_DWORD *)(a7 + 12) & 0x200 )
          goto LABEL_142;
        v38 = v75 == 0;
        if ( v78 > 1 )
          v38 = 1;
        if ( v38 )
          goto LABEL_142;
        if ( v75 == 1 )
        {
          if ( v82 || (unsigned __int8)v88 == 3 )
            goto LABEL_142;
          if ( BYTE2(v88) == 1 )
          {
            v61 = *(_DWORD *)(v12 + 24);
            v62 = 0;
            v63 = v83;
LABEL_143:
            if ( !v63 )
              goto LABEL_162;
            while ( 2 )
            {
              if ( v84 != -1 )
              {
                v64 = 0;
                goto LABEL_147;
              }
              v70 = (unsigned __int8 *)v63[2];
              if ( (unsigned int)v70 < v63[3] )
              {
                v71 = *v70;
                goto LABEL_171;
              }
              v71 = (*(int (**)(void))(*v63 + 36))();
              if ( v71 == -1 )
              {
                v83 = 0;
                v64 = 1;
              }
              else
              {
LABEL_171:
                v84 = v71;
                v64 = 0;
              }
LABEL_147:
              v65 = a5;
              if ( a5 )
              {
LABEL_148:
                if ( a6 != -1 )
                {
                  v66 = 0;
                  goto LABEL_151;
                }
                v68 = (unsigned __int8 *)v65[2];
                if ( (unsigned int)v68 < v65[3] )
                {
                  v69 = *v68;
                  goto LABEL_168;
                }
                v69 = (*(int (**)(void))(*v65 + 36))();
                if ( v69 == -1 )
                {
                  a5 = 0;
                  v66 = 1;
                }
                else
                {
LABEL_168:
                  a6 = v69;
                  v66 = 0;
                }
LABEL_151:
                if ( v66 != v64 )
                {
LABEL_152:
                  if ( v62 != v61 )
                  {
                    if ( *(unsigned __int8 *)(*(_DWORD *)(v12 + 20) + v62) != (unsigned __int8)sub_9B0A0(&v83) )
                      goto LABEL_154;
                    v63 = v83;
                    if ( v83 )
                    {
                      v67 = v83[2];
                      if ( v67 >= v83[3] )
                      {
                        (*(void (**)(void))(*v83 + 40))();
                        v63 = v83;
                      }
                      else
                      {
                        v83[2] = v67 + 1;
                      }
                      v84 = -1;
                    }
                    ++v62;
                    if ( v63 )
                      continue;
LABEL_162:
                    v65 = a5;
                    v64 = 1;
                    if ( a5 )
                      goto LABEL_148;
                    goto LABEL_163;
                  }
def_9CB12:
                  v15 = 1;
                  goto LABEL_20;
                }
              }
              else
              {
LABEL_163:
                if ( v64 != 1 )
                  goto LABEL_152;
              }
              break;
            }
            if ( v62 != v61 )
            {
LABEL_154:
              if ( v62 || *(_DWORD *)(a7 + 12) & 0x200 )
                goto LABEL_52;
            }
            goto def_9CB12;
          }
          v20 = 2;
        }
        else
        {
          if ( v75 != 2 )
            goto def_9CB12;
          if ( HIBYTE(v88) == 4 || v82 && HIBYTE(v88) == 3 )
          {
LABEL_142:
            v61 = *(_DWORD *)(v12 + 24);
            v62 = 0;
            v63 = v83;
            goto LABEL_143;
          }
          v20 = 3;
        }
        goto LABEL_24;
      case 3u:
        if ( *(_DWORD *)(v12 + 32)
          && !sub_9B0DC(&v83, &a5)
          && **(unsigned __int8 **)(v12 + 28) == (unsigned __int8)sub_9B0A0(&v83) )
        {
          v78 = *(_DWORD *)(v12 + 32);
          sub_9A76C(&v83);
          goto def_9CB12;
        }
        if ( !*(_DWORD *)(v12 + 40)
          || sub_9B0DC(&v83, &a5)
          || **(unsigned __int8 **)(v12 + 36) != (unsigned __int8)sub_9B0A0(&v83) )
        {
          if ( !*(_DWORD *)(v12 + 32) || *(_DWORD *)(v12 + 40) )
          {
            v15 = !v82;
          }
          else
          {
            v80 = 1;
            v15 = 1;
          }
        }
        else
        {
          v78 = *(_DWORD *)(v12 + 40);
          sub_9A76C(&v83);
          v15 = 1;
          v80 = 1;
        }
        goto LABEL_20;
      case 4u:
        v22 = v83;
        if ( v83 )
          goto LABEL_26;
        while ( 2 )
        {
          v24 = a5;
          v23 = 1;
          if ( !a5 )
          {
LABEL_49:
            if ( v23 != 1 )
              goto LABEL_34;
LABEL_50:
            v15 = 1;
            goto LABEL_51;
          }
LABEL_30:
          if ( a6 != -1 )
          {
            v25 = 0;
            goto LABEL_33;
          }
          v53 = (unsigned __int8 *)v24[2];
          if ( (unsigned int)v53 < v24[3] )
          {
            v54 = *v53;
LABEL_121:
            a6 = v54;
            v25 = 0;
            goto LABEL_33;
          }
          v54 = (*(int (**)(void))(*v24 + 36))();
          if ( v54 != -1 )
            goto LABEL_121;
          a5 = 0;
          v25 = 1;
LABEL_33:
          if ( v25 == v23 )
            goto LABEL_50;
LABEL_34:
          if ( !v83 )
          {
            v27 = 255;
            v26 = 255;
            goto LABEL_38;
          }
          if ( v84 != -1 )
          {
            v26 = (unsigned __int8)v84;
            v27 = (unsigned __int8)v84;
            goto LABEL_38;
          }
          v57 = (unsigned __int8 *)v83[2];
          if ( (unsigned int)v57 >= v83[3] )
          {
            v58 = (*(int (**)(void))(*v83 + 36))();
            if ( v58 == -1 )
            {
              v83 = 0;
              v27 = 255;
              v26 = 255;
LABEL_38:
              v28 = (char *)memchr(s, v27, 0xAu);
              if ( v28 )
                goto LABEL_39;
              goto LABEL_128;
            }
          }
          else
          {
            v58 = *v57;
          }
          v26 = (unsigned __int8)v58;
          v84 = v58;
          v28 = (char *)memchr(s, (unsigned __int8)v58, 0xAu);
          if ( v28 )
          {
LABEL_39:
            v29 = v87;
            v30 = *((_DWORD *)v87 - 3);
            v31 = v30 + 1;
            v32 = off_F3C5C[0][(unsigned int)&v28[-v76]];
            if ( (unsigned int)(v30 + 1) > *((_DWORD *)v87 - 2) || *((_DWORD *)v87 - 1) > 0 )
            {
              sub_C1264(&v87, v30 + 1);
              v29 = v87;
              v30 = *((_DWORD *)v87 - 3);
            }
            v29[v30] = v32;
            ++v14;
            v33 = v87;
            if ( v87 - 12 != (char *)&dword_2FEF3C )
            {
              *((_DWORD *)v87 - 1) = 0;
              *(v33 - 3) = v31;
              *((_BYTE *)v33 + v31) = 0;
            }
            goto LABEL_44;
          }
LABEL_128:
          if ( *(unsigned __int8 *)(v12 + 17) == v26 && !v77 )
          {
            if ( *(_DWORD *)(v12 + 44) <= 0 )
              goto LABEL_50;
            v79 = (char)v14;
            v14 = v28;
            v77 = 1;
LABEL_44:
            v22 = v83;
            if ( !v83 )
              continue;
            v34 = v83[2];
            if ( v34 >= v83[3] )
            {
              (*(void (**)(void))(*v83 + 40))();
              v22 = v83;
            }
            else
            {
              v83[2] = v34 + 1;
            }
            v84 = -1;
            if ( !v22 )
              continue;
LABEL_26:
            if ( v84 != -1 )
            {
              v23 = 0;
              goto LABEL_29;
            }
            v55 = (unsigned __int8 *)v22[2];
            if ( (unsigned int)v55 < v22[3] )
            {
              v56 = *v55;
              goto LABEL_124;
            }
            v56 = (*(int (**)(void))(*v22 + 36))();
            if ( v56 == -1 )
            {
              v83 = 0;
              v23 = 1;
            }
            else
            {
LABEL_124:
              v84 = v56;
              v23 = 0;
            }
LABEL_29:
            v24 = a5;
            if ( !a5 )
              goto LABEL_49;
            goto LABEL_30;
          }
          break;
        }
        if ( !*(_BYTE *)(v12 + 16) || *(unsigned __int8 *)(v12 + 18) != v26 || v77 )
          goto LABEL_50;
        if ( v14 )
        {
          sub_C15D0((int *)&v86, (char)v14);
          v14 = 0;
          goto LABEL_44;
        }
        v15 = 0;
LABEL_51:
        if ( !*((_DWORD *)v87 - 3) )
          goto LABEL_52;
LABEL_20:
        v20 = v75 + 1;
        if ( v75 + 1 <= 3 )
          v21 = v15 & 1;
        else
          v21 = 0;
        if ( !v21 )
        {
          if ( v78 > 1 )
            v39 = v15 & 1;
          else
            v39 = 0;
          goto LABEL_68;
        }
LABEL_24:
        v75 = v20;
        continue;
      default:
        goto def_9CB12;
    }
  }
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009D1C4) --------------------------------------------------------
_DWORD *__fastcall sub_9D1C4(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, char a7, int a8, _DWORD *a9, double *a10)
{
  _DWORD *v10; // r5
  const char *v11; // r10
  const char *v12; // r2
  int v13; // r1
  char *v14; // r3
  bool v15; // zf
  unsigned int *v17; // r2
  signed int v18; // r1
  char v19; // [sp+18h] [bp-38h]
  int v20; // [sp+1Ch] [bp-34h]
  _DWORD *v21; // [sp+20h] [bp-30h]
  int v22; // [sp+24h] [bp-2Ch]
  const char *v23; // [sp+28h] [bp-28h]
  int v24; // [sp+2Ch] [bp-24h]

  v10 = a1;
  v21 = a3;
  v22 = a4;
  v23 = (const char *)&unk_2FEF48;
  if ( a7 )
    sub_9C2EC(&v19, a2, a3, a4, a5, a6, a8, a9, (int *)&v23);
  else
    sub_9CA58(&v19, a2, a3, a4, a5, a6, a8, a9, (int *)&v23);
  v11 = v23;
  v21 = *(_DWORD **)&v19;
  v22 = v20;
  v24 = sub_AB4B8();
  std::__convert_to_v<long double>(v11, a10, a9);
  v12 = v23;
  v13 = v22;
  v14 = (char *)(v23 - 12);
  v15 = v23 - 12 == (const char *)&dword_2FEF3C;
  *v10 = v21;
  v10[1] = v13;
  if ( !v15 )
  {
    v17 = (unsigned int *)(v12 - 4);
    __dmb(0xFu);
    do
      v18 = __ldrex(v17);
    while ( __strex(v18 - 1, v17) );
    __dmb(0xFu);
    if ( v18 <= 0 )
      operator delete(v14);
  }
  return v10;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009D28C) --------------------------------------------------------
_DWORD *__fastcall sub_9D28C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, char a7, int a8, _DWORD *a9, int *a10)
{
  _DWORD *v10; // r5
  int v11; // r7
  _BYTE *v12; // r10
  char *v13; // r3
  size_t v14; // r7
  void *v15; // r8
  void *v16; // r11
  char *v17; // r7
  int v18; // r1
  char *v19; // r2
  unsigned int *v21; // r3
  signed int v22; // r1
  char v23; // [sp+18h] [bp-40h]
  int v24; // [sp+1Ch] [bp-3Ch]
  _DWORD *v25; // [sp+20h] [bp-38h]
  int v26; // [sp+24h] [bp-34h]
  void *src; // [sp+2Ch] [bp-2Ch]

  v10 = a1;
  v11 = a2;
  v25 = a3;
  v26 = a4;
  src = &unk_2FEF48;
  v12 = (_BYTE *)sub_97BC0(a8 + 108);
  if ( a7 )
    sub_9C2EC(&v23, v11, v25, v26, a5, a6, a8, a9, (int *)&src);
  else
    sub_9CA58(&v23, v11, v25, v26, a5, a6, a8, a9, (int *)&src);
  v13 = (char *)src;
  v14 = *((_DWORD *)src - 3);
  v25 = *(_DWORD **)&v23;
  v26 = v24;
  if ( v14 )
  {
    sub_C1588(a10, v14, 0);
    v15 = (void *)*a10;
    v16 = src;
    v17 = (char *)src + v14;
    if ( *(_DWORD *)(*a10 - 4) >= 0 )
    {
      sub_C0BF4(a10);
      v15 = (void *)*a10;
    }
    if ( v12[28] == 1 )
    {
      memcpy(v15, v16, v17 - (_BYTE *)v16);
      v13 = (char *)src;
    }
    else
    {
      if ( !v12[28] )
        sub_AA9D0((int)v12);
      (*(void (__fastcall **)(_BYTE *, void *, char *, void *))(*(_DWORD *)v12 + 28))(v12, v16, v17, v15);
      v13 = (char *)src;
    }
  }
  v18 = v26;
  v19 = v13 - 12;
  *v10 = v25;
  v10[1] = v18;
  if ( v13 - 12 != (char *)&dword_2FEF3C )
  {
    v21 = (unsigned int *)(v13 - 4);
    __dmb(0xFu);
    do
      v22 = __ldrex(v21);
    while ( __strex(v22 - 1, v21) );
    __dmb(0xFu);
    if ( v22 <= 0 )
      operator delete(v19);
  }
  return v10;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009D3C8) --------------------------------------------------------
_DWORD *__fastcall sub_9D3C8(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int v9; // r4
  int *v10; // r8
  int v11; // r5
  _BOOL4 v12; // r9
  signed int v13; // r2
  int v14; // r7
  signed int v15; // r6
  _DWORD *v16; // r0
  unsigned int v17; // r3
  unsigned __int8 *v18; // r3
  int v19; // r0
  signed int v20; // r4
  signed int v21; // r3
  unsigned int *v22; // r4
  int v23; // r1
  unsigned __int8 *v25; // r3
  int v26; // r0
  unsigned __int8 v27; // r0
  unsigned int v28; // r3
  unsigned __int8 v29; // r0
  char v30; // r1
  int v31; // r3
  void *v32; // r0
  _DWORD *v33; // r0
  unsigned int v34; // r3
  unsigned __int8 *v35; // r3
  int v36; // r0
  int v37; // r4
  int v38; // r3
  unsigned __int8 *v39; // r3
  int v40; // r0
  _DWORD **v41; // r0
  unsigned __int8 v42; // r0
  unsigned int v43; // r0
  char v44; // r1
  unsigned __int8 v45; // r0
  int v46; // r3
  unsigned int v47; // r7
  int v48; // r1
  char v49; // r1
  int v50; // ST04_4
  _DWORD **v51; // r0
  unsigned __int8 v52; // r0
  int i; // r0
  _DWORD *v54; // r0
  unsigned int v55; // r1
  unsigned __int8 *v56; // r1
  int v57; // r0
  signed int v58; // r6
  signed int v59; // r3
  unsigned __int8 *v60; // r1
  int v61; // r0
  signed int v62; // [sp+8h] [bp-10h]
  int v63; // [sp+Ch] [bp-Ch]
  _DWORD *v64; // [sp+10h] [bp-8h]
  _DWORD *v65; // [sp+18h] [bp+0h]
  int v66; // [sp+1Ch] [bp+4h]
  char v67; // [sp+24h] [bp+Ch]
  unsigned int *v68; // [sp+2Ch] [bp+14h]

  v9 = 0;
  v64 = a1;
  v65 = a3;
  v66 = a4;
  v10 = a9;
  v11 = sub_9A83C((int)&v67, (int *)(a7 + 108));
  v12 = sub_9B0DC(&v65, &a5);
  if ( v12 )
  {
LABEL_2:
    v13 = *(unsigned __int8 *)(v11 + 16);
    v14 = 0;
    v15 = 0;
    v12 = 1;
    goto LABEL_3;
  }
  v45 = sub_9B0A0(&v65);
  v46 = v45;
  v47 = *(unsigned __int8 *)(v11 + 75) - v45;
  v48 = v47 + (v47 <= 0) + v45 - *(unsigned __int8 *)(v11 + 75);
  if ( v48 || *(unsigned __int8 *)(v11 + 74) == v45 )
  {
    v13 = *(unsigned __int8 *)(v11 + 16);
    if ( *(_BYTE *)(v11 + 16) && *(unsigned __int8 *)(v11 + 37) == v45 )
    {
      v13 = 1;
    }
    else if ( *(unsigned __int8 *)(v11 + 36) != v45 )
    {
      if ( v48 )
        v49 = 43;
      else
        v49 = 45;
      v50 = v45;
      sub_C15D0(v10, v49);
      v51 = sub_9A76C(&v65);
      v9 = v50;
      if ( sub_9B0DC(v51, &a5) )
        goto LABEL_2;
      v52 = sub_9B0A0(&v65);
      v13 = *(unsigned __int8 *)(v11 + 16);
      v46 = v52;
    }
  }
  else
  {
    v13 = *(unsigned __int8 *)(v11 + 16);
  }
  v14 = 0;
  v15 = 0;
  for ( i = v46; ; i = (unsigned __int8)i )
  {
    if ( v13 && *(unsigned __int8 *)(v11 + 37) == i )
    {
      v9 = i;
      v68 = (unsigned int *)&unk_2FEF48;
      goto LABEL_99;
    }
    if ( *(unsigned __int8 *)(v11 + 36) == i )
      break;
    v9 = *(unsigned __int8 *)(v11 + 78);
    if ( v9 != i )
      break;
    if ( !v15 )
      sub_C15D0(v10, 48);
    v54 = v65;
    ++v14;
    if ( !v65 )
    {
LABEL_134:
      v58 = 1;
      goto LABEL_125;
    }
    v55 = v65[2];
    if ( v55 >= v65[3] )
    {
      (*(void (**)(void))(*v65 + 40))();
      v54 = v65;
      v66 = -1;
      if ( !v65 )
        goto LABEL_134;
    }
    else
    {
      v66 = -1;
      v65[2] = v55 + 1;
    }
    v56 = (unsigned __int8 *)v54[2];
    if ( (unsigned int)v56 < v54[3] )
    {
      v57 = *v56;
LABEL_124:
      v58 = 0;
      v66 = v57;
      goto LABEL_125;
    }
    v57 = (*(int (**)(void))(*v54 + 36))();
    if ( v57 != -1 )
      goto LABEL_124;
    v58 = 1;
    v65 = 0;
LABEL_125:
    if ( !a5 )
    {
      v59 = 1;
      goto LABEL_129;
    }
    if ( a6 != -1 )
    {
      v59 = 0;
      goto LABEL_129;
    }
    v60 = (unsigned __int8 *)a5[2];
    if ( (unsigned int)v60 >= a5[3] )
    {
      v61 = (*(int (**)(void))(*a5 + 36))();
      if ( v61 == -1 )
      {
        v59 = 1;
        a5 = 0;
LABEL_129:
        if ( v58 == v59 )
          goto LABEL_130;
        goto LABEL_138;
      }
    }
    else
    {
      v61 = *v60;
    }
    a6 = v61;
    if ( !v58 )
    {
LABEL_130:
      v12 = 1;
      v13 = *(unsigned __int8 *)(v11 + 16);
      v15 = 1;
      goto LABEL_3;
    }
LABEL_138:
    v15 = 1;
    LOBYTE(i) = sub_9B0A0(&v65);
    v13 = *(unsigned __int8 *)(v11 + 16);
  }
  v9 = i;
LABEL_3:
  v68 = (unsigned int *)&unk_2FEF48;
  if ( v13 )
LABEL_99:
    sub_C1264(&v68, 0x20u);
  v63 = *(unsigned __int8 *)(v11 + 100);
  if ( !*(_BYTE *)(v11 + 100) )
  {
    if ( !v12 )
    {
      v62 = 0;
      while ( 2 )
      {
        if ( (unsigned __int8)(v9 - 48) <= 9u )
        {
LABEL_8:
          sub_C15D0(v10, v9);
          v15 = 1;
          break;
        }
LABEL_32:
        if ( *(unsigned __int8 *)(v11 + 36) == v9 && (v62 ^ 1) & !v12 & 0xFF )
        {
          sub_C15D0(v10, 46);
          v12 = 0;
          v62 = 1;
        }
        else
        {
          if ( *(unsigned __int8 *)(v11 + 92) != v9 && *(unsigned __int8 *)(v11 + 98) != v9 || !(v15 & !v12) )
            goto LABEL_20;
          sub_C15D0(v10, 101);
          if ( v65 )
          {
            v28 = v65[2];
            if ( v28 >= v65[3] )
              (*(void (**)(void))(*v65 + 40))();
            else
              v65[2] = v28 + 1;
            v66 = -1;
          }
          if ( sub_9B0DC(&v65, &a5) )
            goto LABEL_141;
          v29 = sub_9B0A0(&v65);
          v9 = v29;
          if ( *(unsigned __int8 *)(v11 + 75) == v29 )
          {
            v30 = 43;
          }
          else
          {
            if ( *(unsigned __int8 *)(v11 + 74) != v29 )
            {
              v12 = 1;
              v15 = 1;
              continue;
            }
            v30 = 45;
          }
          sub_C15D0(v10, v30);
          v12 = 1;
          v15 = 1;
        }
        break;
      }
      v16 = v65;
      if ( !v65 )
        goto LABEL_165;
      v17 = v65[2];
      if ( v17 < v65[3] )
      {
        v66 = -1;
        v65[2] = v17 + 1;
        goto LABEL_12;
      }
      (*(void (**)(void))(*v65 + 40))();
      v16 = v65;
      v66 = -1;
      if ( !v65 )
      {
LABEL_165:
        v20 = 1;
        goto LABEL_15;
      }
LABEL_12:
      v18 = (unsigned __int8 *)v16[2];
      if ( (unsigned int)v18 < v16[3] )
      {
        v19 = *v18;
LABEL_14:
        v20 = 0;
        v66 = v19;
        goto LABEL_15;
      }
      v19 = (*(int (**)(void))(*v16 + 36))();
      if ( v19 != -1 )
        goto LABEL_14;
      v20 = 1;
      v65 = 0;
LABEL_15:
      if ( a5 )
      {
        if ( a6 == -1 )
        {
          v25 = (unsigned __int8 *)a5[2];
          if ( (unsigned int)v25 >= a5[3] )
          {
            v26 = (*(int (**)(void))(*a5 + 36))();
            if ( v26 == -1 )
            {
              v21 = 1;
              a5 = 0;
              goto LABEL_19;
            }
          }
          else
          {
            v26 = *v25;
          }
          a6 = v26;
          if ( !v20 )
            goto LABEL_20;
        }
        else
        {
          v21 = 0;
LABEL_19:
          if ( v21 == v20 )
            goto LABEL_20;
        }
        v27 = sub_9B0A0(&v65);
        v9 = v27;
        if ( (unsigned __int8)(v27 - 48) <= 9u )
          goto LABEL_8;
        goto LABEL_32;
      }
      v21 = 1;
      goto LABEL_19;
    }
LABEL_132:
    v12 = 0;
    v62 = 0;
    goto LABEL_20;
  }
  if ( v12 )
    goto LABEL_132;
  v31 = *(unsigned __int8 *)(v11 + 16);
  v62 = 0;
  while ( 2 )
  {
    if ( !v31 )
      goto LABEL_53;
LABEL_52:
    if ( *(unsigned __int8 *)(v11 + 37) == v9 )
    {
      if ( !(!v12 & (v62 ^ 1) & 0xFF) )
        goto LABEL_20;
      if ( !v14 )
      {
        sub_C0AFC(v10, 0, *(_DWORD *)(*v10 - 12), 0);
        goto LABEL_132;
      }
      sub_C15D0((int *)&v68, v14);
      v12 = 0;
      v62 = 0;
      v14 = 0;
      goto LABEL_56;
    }
LABEL_53:
    if ( *(unsigned __int8 *)(v11 + 36) == v9 )
    {
      if ( !(!v12 & (v62 ^ 1) & 0xFF) )
        goto LABEL_20;
      if ( *(v68 - 3) )
        sub_C15D0((int *)&v68, v14);
      sub_C15D0(v10, 46);
      v12 = 0;
      v62 = 1;
      goto LABEL_56;
    }
    v32 = memchr((const void *)(v11 + 78), v9, 0xAu);
    if ( v32 )
    {
      sub_C15D0(v10, (_BYTE)v32 - (v11 + 78) + 48);
      ++v14;
      v15 = 1;
      goto LABEL_56;
    }
    if ( *(unsigned __int8 *)(v11 + 92) != v9 && *(unsigned __int8 *)(v11 + 98) != v9 || !(v15 & !v12) )
      goto LABEL_20;
    if ( *(v68 - 3) && !v62 )
      sub_C15D0((int *)&v68, v14);
    sub_C15D0(v10, 101);
    v41 = sub_9A76C(&v65);
    if ( !sub_9B0DC(v41, &a5) )
    {
      v42 = sub_9B0A0(&v65);
      v9 = v42;
      v43 = *(unsigned __int8 *)(v11 + 75) - v42;
      if ( v43 > 0 && *(unsigned __int8 *)(v11 + 74) != v9 )
      {
        v12 = 1;
        v31 = *(unsigned __int8 *)(v11 + 16);
        v15 = 1;
        continue;
      }
      v31 = *(unsigned __int8 *)(v11 + 16);
      if ( *(_BYTE *)(v11 + 16) && *(unsigned __int8 *)(v11 + 37) == v9 )
      {
        v12 = 1;
        v15 = 1;
        goto LABEL_52;
      }
      if ( *(unsigned __int8 *)(v11 + 36) == v9 )
      {
        v12 = 1;
        v15 = 1;
        continue;
      }
      if ( v43 <= 0 )
        v44 = 43;
      else
        v44 = 45;
      sub_C15D0(v10, v44);
      v12 = 1;
      v15 = 1;
LABEL_56:
      v33 = v65;
      if ( !v65 )
        goto LABEL_166;
      v34 = v65[2];
      if ( v34 < v65[3] )
      {
        v65[2] = v34 + 1;
        v66 = -1;
        goto LABEL_59;
      }
      (*(void (**)(void))(*v65 + 40))();
      v33 = v65;
      v66 = -1;
      if ( !v65 )
      {
LABEL_166:
        v37 = v63;
        goto LABEL_62;
      }
LABEL_59:
      v35 = (unsigned __int8 *)v33[2];
      if ( (unsigned int)v35 < v33[3] )
      {
        v36 = *v35;
LABEL_61:
        v37 = 0;
        v66 = v36;
        goto LABEL_62;
      }
      v36 = (*(int (**)(void))(*v33 + 36))();
      if ( v36 != -1 )
        goto LABEL_61;
      v37 = v63;
      v65 = 0;
LABEL_62:
      if ( a5 )
      {
        if ( a6 == -1 )
        {
          v39 = (unsigned __int8 *)a5[2];
          if ( (unsigned int)v39 >= a5[3] )
          {
            v40 = (*(int (**)(void))(*a5 + 36))();
            if ( v40 == -1 )
            {
              v38 = v63;
              a5 = 0;
              goto LABEL_66;
            }
          }
          else
          {
            v40 = *v39;
          }
          a6 = v40;
          v38 = 0;
        }
        else
        {
          v38 = 0;
        }
      }
      else
      {
        v38 = v63;
      }
LABEL_66:
      if ( v38 == v37 )
        goto LABEL_20;
      v9 = (unsigned __int8)sub_9B0A0(&v65);
      v31 = *(unsigned __int8 *)(v11 + 16);
      continue;
    }
    break;
  }
LABEL_141:
  v12 = 1;
LABEL_20:
  v22 = v68;
  if ( *(v68 - 3) )
  {
    if ( !v12 & (v62 ^ 1) & 0xFF )
    {
      sub_C15D0((int *)&v68, v14);
      v22 = v68;
    }
    if ( !sub_C303C(*(_DWORD *)(v11 + 8), *(_DWORD *)(v11 + 12), (unsigned __int8 **)&v68) )
      *a8 = 4;
  }
  v23 = v66;
  *v64 = v65;
  v64[1] = v23;
  sub_C0AC4(v22 - 3);
  return v64;
}

//----- (0009D980) --------------------------------------------------------
_DWORD *__fastcall sub_9D980(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, int *a8, float *a9)
{
  _DWORD *v9; // r6
  int v10; // r11
  const char *v11; // r8
  signed int v12; // r8
  int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  unsigned __int8 *v19; // r3
  int v20; // r0
  unsigned int *v21; // r2
  signed int v22; // r1
  char v23; // [sp+18h] [bp-40h]
  int v24; // [sp+1Ch] [bp-3Ch]
  _DWORD *v25; // [sp+20h] [bp-38h]
  int v26; // [sp+24h] [bp-34h]
  const char *v27; // [sp+28h] [bp-30h]
  int v28; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v27 = (const char *)&unk_2FEF48;
  v25 = a3;
  v26 = a4;
  sub_C1264(&v27, 0x20u);
  sub_9D3C8(&v23, v10, v25, v26, a5, a6, a7, a8, (int *)&v27);
  v11 = v27;
  v25 = *(_DWORD **)&v23;
  v26 = v24;
  v28 = sub_AB4B8();
  std::__convert_to_v<float>(v11, a9, a8);
  if ( v25 )
  {
    if ( v26 == -1 )
    {
      v19 = (unsigned __int8 *)v25[2];
      if ( (unsigned int)v19 >= v25[3] )
      {
        v20 = (*(int (**)(void))(*v25 + 36))();
        if ( v20 == -1 )
        {
          v12 = 1;
          v25 = 0;
          goto LABEL_5;
        }
      }
      else
      {
        v20 = *v19;
      }
      v26 = v20;
      v12 = 0;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 1;
  }
LABEL_5:
  v13 = !a5 || a6 == -1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v14 = v13 == v12;
  v15 = v27;
  v16 = v26;
  if ( v13 == v12 )
    v13 = *a8 | 2;
  *v9 = v25;
  v9[1] = v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v21 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v22 = __ldrex(v21);
    while ( __strex(v22 - 1, v21) );
    __dmb(0xFu);
    if ( v22 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009DAC0) --------------------------------------------------------
_DWORD *__fastcall sub_9DAC0(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, int *a8, double *a9)
{
  _DWORD *v9; // r6
  int v10; // r11
  const char *v11; // r8
  signed int v12; // r8
  int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  unsigned __int8 *v19; // r3
  int v20; // r0
  unsigned int *v21; // r2
  signed int v22; // r1
  char v23; // [sp+18h] [bp-40h]
  int v24; // [sp+1Ch] [bp-3Ch]
  _DWORD *v25; // [sp+20h] [bp-38h]
  int v26; // [sp+24h] [bp-34h]
  const char *v27; // [sp+28h] [bp-30h]
  int v28; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v27 = (const char *)&unk_2FEF48;
  v25 = a3;
  v26 = a4;
  sub_C1264(&v27, 0x20u);
  sub_9D3C8(&v23, v10, v25, v26, a5, a6, a7, a8, (int *)&v27);
  v11 = v27;
  v25 = *(_DWORD **)&v23;
  v26 = v24;
  v28 = sub_AB4B8();
  std::__convert_to_v<double>(v11, a9, a8);
  if ( v25 )
  {
    if ( v26 == -1 )
    {
      v19 = (unsigned __int8 *)v25[2];
      if ( (unsigned int)v19 >= v25[3] )
      {
        v20 = (*(int (**)(void))(*v25 + 36))();
        if ( v20 == -1 )
        {
          v12 = 1;
          v25 = 0;
          goto LABEL_5;
        }
      }
      else
      {
        v20 = *v19;
      }
      v26 = v20;
      v12 = 0;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 1;
  }
LABEL_5:
  v13 = !a5 || a6 == -1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v14 = v13 == v12;
  v15 = v27;
  v16 = v26;
  if ( v13 == v12 )
    v13 = *a8 | 2;
  *v9 = v25;
  v9[1] = v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v21 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v22 = __ldrex(v21);
    while ( __strex(v22 - 1, v21) );
    __dmb(0xFu);
    if ( v22 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009DC00) --------------------------------------------------------
_DWORD *__fastcall sub_9DC00(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, int *a8, double *a9)
{
  _DWORD *v9; // r6
  int v10; // r11
  const char *v11; // r8
  signed int v12; // r8
  int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  unsigned __int8 *v19; // r3
  int v20; // r0
  unsigned int *v21; // r2
  signed int v22; // r1
  char v23; // [sp+18h] [bp-40h]
  int v24; // [sp+1Ch] [bp-3Ch]
  _DWORD *v25; // [sp+20h] [bp-38h]
  int v26; // [sp+24h] [bp-34h]
  const char *v27; // [sp+28h] [bp-30h]
  int v28; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v27 = (const char *)&unk_2FEF48;
  v25 = a3;
  v26 = a4;
  sub_C1264(&v27, 0x20u);
  sub_9D3C8(&v23, v10, v25, v26, a5, a6, a7, a8, (int *)&v27);
  v11 = v27;
  v25 = *(_DWORD **)&v23;
  v26 = v24;
  v28 = sub_AB4B8();
  std::__convert_to_v<long double>(v11, a9, a8);
  if ( v25 )
  {
    if ( v26 == -1 )
    {
      v19 = (unsigned __int8 *)v25[2];
      if ( (unsigned int)v19 >= v25[3] )
      {
        v20 = (*(int (**)(void))(*v25 + 36))();
        if ( v20 == -1 )
        {
          v12 = 1;
          v25 = 0;
          goto LABEL_5;
        }
      }
      else
      {
        v20 = *v19;
      }
      v26 = v20;
      v12 = 0;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 1;
  }
LABEL_5:
  v13 = !a5 || a6 == -1 && a5[2] >= a5[3] && (*(int (**)(void))(*a5 + 36))() == -1;
  v14 = v13 == v12;
  v15 = v27;
  v16 = v26;
  if ( v13 == v12 )
    v13 = *a8 | 2;
  *v9 = v25;
  v9[1] = v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v21 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v22 = __ldrex(v21);
    while ( __strex(v22 - 1, v21) );
    __dmb(0xFu);
    if ( v22 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (0009DD40) --------------------------------------------------------
_DWORD *__fastcall sub_9DD40(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned int *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  unsigned __int8 v14; // r0
  unsigned int v15; // r4
  unsigned int v16; // r7
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r5
  size_t v20; // r9
  int v21; // r10
  unsigned int v22; // r0
  unsigned int v23; // r6
  signed int v24; // r7
  int v25; // r4
  unsigned int v26; // r6
  _DWORD *v27; // r0
  unsigned int v28; // r3
  unsigned __int8 *v29; // r3
  int v30; // r0
  signed int v31; // r4
  signed int v32; // r3
  signed int v33; // r4
  _DWORD *v34; // r3
  int v35; // r2
  int v36; // r1
  unsigned __int8 *v38; // r3
  int v39; // r0
  signed int v40; // r0
  char *v41; // r0
  int v42; // r4
  unsigned int v43; // r6
  _DWORD *v44; // r0
  unsigned int v45; // r3
  unsigned __int8 *v46; // r3
  int v47; // r0
  int v48; // r4
  int v49; // r3
  unsigned __int8 *v50; // r3
  int v51; // r0
  signed int v52; // r10
  int v53; // r5
  int v54; // r9
  signed int v55; // r6
  unsigned int v56; // r2
  int v57; // r6
  unsigned __int8 v58; // r0
  int v59; // [sp+0h] [bp-68h]
  unsigned int v60; // [sp+4h] [bp-64h]
  unsigned int v61; // [sp+Ch] [bp-5Ch]
  unsigned int v62; // [sp+10h] [bp-58h]
  int v63; // [sp+14h] [bp-54h]
  _DWORD *v64; // [sp+1Ch] [bp-4Ch]
  char v65; // [sp+20h] [bp-48h]
  int v66; // [sp+24h] [bp-44h]
  _DWORD *v67; // [sp+28h] [bp-40h]
  int v68; // [sp+2Ch] [bp-3Ch]
  char v69; // [sp+34h] [bp-34h]
  _DWORD *v70; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v64 = a1;
  v67 = a3;
  v68 = a4;
  v10 = sub_9A83C((int)&v69, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v61 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v61 = v13;
  }
  if ( sub_9B0DC(&v67, &a5) )
  {
    v15 = 0;
    v66 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v67);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v12 + 74) - v14;
    v66 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v12 + 74);
    if ( !v66 && *(unsigned __int8 *)(v12 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_107;
    }
    v17 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_107;
    }
    if ( *(unsigned __int8 *)(v12 + 36) == v14 )
    {
LABEL_107:
      v52 = v61;
      v53 = v11;
      v54 = 0;
      v55 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v12 + 37) == v15 || *(unsigned __int8 *)(v12 + 36) == v15 )
        {
LABEL_146:
          v61 = v52;
          v19 = 0;
          v65 = v55;
          v59 = v54;
          goto LABEL_12;
        }
        if ( *(unsigned __int8 *)(v12 + 78) == v15 )
        {
          v57 = v55 ^ 1;
          if ( v52 == 10 )
            v57 |= 1u;
          if ( v57 )
          {
            if ( v53 )
            {
              if ( v52 == 8 )
                v54 = 0;
              else
                ++v54;
              v55 = 1;
            }
            else
            {
              v54 = 0;
              v55 = 1;
              v52 = 8;
            }
            goto LABEL_118;
          }
        }
        else if ( !v55 )
        {
          goto LABEL_146;
        }
        if ( *(unsigned __int8 *)(v12 + 76) != v15 && *(unsigned __int8 *)(v12 + 77) != v15 )
        {
          v61 = v52;
          v59 = v54;
          v19 = 0;
          v65 = 1;
          goto LABEL_12;
        }
        if ( v53 )
        {
          if ( v52 != 16 )
          {
            v61 = v52;
            v59 = v54;
            v19 = 0;
            v65 = 1;
            goto LABEL_13;
          }
          v54 = 0;
          v55 = 0;
        }
        else
        {
          v54 = 0;
          v55 = 0;
          v52 = 16;
        }
LABEL_118:
        if ( v67 )
        {
          v56 = v67[2];
          if ( v56 >= v67[3] )
            (*(void (__cdecl **)(_DWORD *))(*v67 + 40))(v67);
          else
            v67[2] = v56 + 1;
          v68 = -1;
        }
        if ( sub_9B0DC(&v67, &a5) )
        {
          v61 = v52;
          v19 = 1;
          v65 = v55;
          v59 = v54;
          v17 = *(unsigned __int8 *)(v12 + 16);
          if ( v52 != 16 )
            goto LABEL_13;
          goto LABEL_124;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v67);
        if ( !v55 )
        {
          v61 = v52;
          v19 = 0;
          v65 = 0;
          v59 = v54;
          v17 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v17 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v18 = sub_9A76C(&v67);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v58 = sub_9B0A0(&v67);
      v17 = *(unsigned __int8 *)(v12 + 16);
      v15 = v58;
      goto LABEL_107;
    }
  }
  v17 = *(unsigned __int8 *)(v12 + 16);
  v59 = 0;
  v65 = 0;
  v19 = 1;
LABEL_12:
  if ( v61 == 16 )
LABEL_124:
    v20 = 22;
  else
LABEL_13:
    v20 = v61;
  v70 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v70, 0x20u);
  v21 = v12 + 78;
  if ( v66 )
    v22 = 2147483648;
  else
    v22 = 0x7FFFFFFF;
  v62 = v22;
  v63 = *(unsigned __int8 *)(v12 + 100);
  v60 = v22 / v61;
  if ( !*(_BYTE *)(v12 + 100) )
  {
    if ( !v19 )
    {
      v23 = 0;
      v24 = 0;
      while ( 1 )
      {
        if ( v20 > 0xA )
        {
          if ( (unsigned __int8)(v15 - 48) > 9u )
          {
            if ( v15 - 97 > 5 )
            {
              if ( v15 - 65 > 5 )
                goto LABEL_70;
              v25 = v15 - 55;
            }
            else
            {
              v25 = v15 - 87;
            }
          }
          else
          {
            v25 = v15 - 48;
          }
        }
        else
        {
          if ( v15 <= 0x2F || v15 >= (unsigned __int8)(v20 + 48) )
            goto LABEL_70;
          v25 = v15 - 48;
        }
        if ( v60 >= v23 )
        {
          v26 = v61 * v23;
          ++v59;
          if ( v62 - v25 < v26 )
            LOBYTE(v24) = v24 | 1;
          v23 = v26 + v25;
          v24 = (unsigned __int8)v24;
        }
        else
        {
          v24 = 1;
        }
        v27 = v67;
        if ( !v67 )
          break;
        v28 = v67[2];
        if ( v28 >= v67[3] )
        {
          (*(void (**)(void))(*v67 + 40))();
          v27 = v67;
          v68 = -1;
          if ( !v67 )
            break;
        }
        else
        {
          v68 = -1;
          v67[2] = v28 + 1;
        }
        v29 = (unsigned __int8 *)v27[2];
        if ( (unsigned int)v29 < v27[3] )
        {
          v30 = *v29;
LABEL_36:
          v31 = 0;
          v68 = v30;
          goto LABEL_37;
        }
        v30 = (*(int (**)(void))(*v27 + 36))();
        if ( v30 != -1 )
          goto LABEL_36;
        v31 = 1;
        v67 = 0;
LABEL_37:
        if ( !a5 )
        {
          v32 = 1;
          goto LABEL_41;
        }
        if ( a6 != -1 )
        {
          v32 = 0;
          goto LABEL_41;
        }
        v38 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v38 >= a5[3] )
        {
          v39 = (*(int (**)(void))(*a5 + 36))();
          if ( v39 == -1 )
          {
            v32 = 1;
            a5 = 0;
LABEL_41:
            if ( v32 == v31 )
              goto LABEL_42;
            goto LABEL_69;
          }
        }
        else
        {
          v39 = *v38;
        }
        a6 = v39;
        if ( !v31 )
          goto LABEL_42;
LABEL_69:
        v15 = (unsigned __int8)sub_9B0A0(&v67);
      }
      v31 = 1;
      goto LABEL_37;
    }
    v23 = *(unsigned __int8 *)(v12 + 100);
    v24 = *(unsigned __int8 *)(v12 + 100);
    v33 = *(unsigned __int8 *)(v12 + 100);
LABEL_43:
    v34 = v70;
    if ( *(v70 - 3) )
      goto LABEL_71;
    goto LABEL_44;
  }
  if ( v19 )
  {
    v23 = 0;
    v24 = 0;
    v33 = 0;
    goto LABEL_43;
  }
  v23 = 0;
  v24 = 0;
  while ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v15 )
  {
    if ( !v59 )
    {
      v33 = 1;
      goto LABEL_43;
    }
    sub_C15D0((int *)&v70, v59);
    v59 = 0;
LABEL_86:
    v44 = v67;
    if ( !v67 )
      goto LABEL_99;
    v45 = v67[2];
    if ( v45 >= v67[3] )
    {
      (*(void (**)(void))(*v67 + 40))();
      v44 = v67;
      v68 = -1;
      if ( !v67 )
      {
LABEL_99:
        v48 = v63;
        goto LABEL_92;
      }
    }
    else
    {
      v68 = -1;
      v67[2] = v45 + 1;
    }
    v46 = (unsigned __int8 *)v44[2];
    if ( (unsigned int)v46 < v44[3] )
    {
      v47 = *v46;
LABEL_91:
      v48 = 0;
      v68 = v47;
      goto LABEL_92;
    }
    v47 = (*(int (**)(void))(*v44 + 36))();
    if ( v47 != -1 )
      goto LABEL_91;
    v48 = v63;
    v67 = 0;
LABEL_92:
    if ( a5 )
    {
      if ( a6 != -1 )
      {
        v49 = 0;
        goto LABEL_96;
      }
      v50 = (unsigned __int8 *)a5[2];
      if ( (unsigned int)v50 < a5[3] )
      {
        v51 = *v50;
LABEL_102:
        a6 = v51;
        v49 = 0;
        goto LABEL_96;
      }
      v51 = (*(int (**)(void))(*a5 + 36))();
      if ( v51 != -1 )
        goto LABEL_102;
      v49 = v63;
      a5 = 0;
    }
    else
    {
      v49 = v63;
    }
LABEL_96:
    if ( v49 == v48 )
    {
LABEL_42:
      v33 = 0;
      v19 = 1;
      goto LABEL_43;
    }
    v15 = (unsigned __int8)sub_9B0A0(&v67);
  }
  if ( *(unsigned __int8 *)(v12 + 36) != v15 )
  {
    v41 = (char *)memchr((const void *)(v12 + 78), v15, v20);
    if ( v41 )
    {
      v42 = (int)&v41[-v21];
      if ( (signed int)&v41[-v21] > 15 )
        v42 -= 6;
      if ( v60 >= v23 )
      {
        v43 = v61 * v23;
        ++v59;
        if ( v62 - v42 < v43 )
          LOBYTE(v24) = v24 | 1;
        v23 = v43 + v42;
        v24 = (unsigned __int8)v24;
      }
      else
      {
        v24 = 1;
      }
      goto LABEL_86;
    }
  }
LABEL_70:
  v34 = v70;
  v33 = 0;
  if ( !*(v70 - 3) )
    goto LABEL_44;
LABEL_71:
  sub_C15D0((int *)&v70, v59);
  v40 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v70);
  v34 = v70;
  if ( !v40 )
    *a8 = 4;
LABEL_44:
  if ( v59 )
    v35 = 0;
  else
    v35 = ((unsigned __int8)v65 ^ 1) & 1;
  if ( v35 && !*(v34 - 3) || v33 )
  {
    *a9 = 0;
    *a8 = 4;
  }
  else if ( v24 )
  {
    if ( v66 )
      *a9 = 2147483648;
    else
      *a9 = 0x7FFFFFFF;
    *a8 = 4;
  }
  else
  {
    if ( v66 )
      v23 = -v23;
    *a9 = v23;
  }
  if ( v19 )
    *a8 |= 2u;
  v36 = v68;
  *v64 = v67;
  v64[1] = v36;
  sub_C0AC4(v34 - 3);
  return v64;
}

//----- (0009E2A8) --------------------------------------------------------
_DWORD *__fastcall sub_9E2A8(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned int *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9DD40(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (0009E2E4) --------------------------------------------------------
_DWORD *__fastcall sub_9E2E4(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, signed int *a8, _BYTE *a9)
{
  _DWORD *v9; // r10
  int v10; // r0
  unsigned int v11; // r5
  signed int v12; // r12
  int v13; // r2
  _DWORD *v14; // r8
  _BOOL4 v15; // r4
  _BOOL4 v16; // r6
  int v17; // r7
  int v18; // r9
  signed int v19; // r1
  unsigned int v20; // r0
  unsigned int v21; // r4
  _BOOL4 v22; // r3
  signed int *v23; // r2
  unsigned __int8 *v24; // r7
  int v25; // r0
  unsigned __int8 *v26; // r9
  int v27; // r0
  unsigned __int8 *v28; // r1
  int v29; // r0
  int v30; // r1
  signed int v32; // r7
  signed int v33; // r7
  signed int *v34; // r2
  int v35; // ST28_4
  signed int v36; // ST2C_4
  int v37; // ST28_4
  signed int v38; // ST2C_4
  int v39; // ST28_4
  signed int v40; // ST2C_4
  int v41; // ST28_4
  signed int v42; // ST2C_4
  _BOOL4 v43; // [sp+1Ch] [bp-1Ch]
  char v44; // [sp+30h] [bp-8h]
  int v45; // [sp+34h] [bp-4h]
  _DWORD *v46; // [sp+38h] [bp+0h]
  int v47; // [sp+3Ch] [bp+4h]
  unsigned int v48; // [sp+44h] [bp+Ch]

  v9 = a1;
  v46 = a3;
  v47 = a4;
  if ( !(*(_DWORD *)(a7 + 12) & 1) )
  {
    v48 = -1;
    sub_9DD40(&v44, a2, v46, v47, a5, a6, a7, a8, &v48);
    v46 = *(_DWORD **)&v44;
    v47 = v45;
    if ( v48 <= 1 )
    {
      *a9 = v48 & 1;
    }
    else
    {
      *a9 = 1;
      *a8 = 4;
      if ( sub_9B0DC(&v46, &a5) )
        *a8 |= 2u;
    }
    goto LABEL_53;
  }
  v10 = sub_9A83C((int)&v48, (int *)(a7 + 108));
  v11 = 0;
  v12 = -1;
  v13 = 1;
  v43 = 1;
  v14 = (_DWORD *)v10;
  v15 = *(_DWORD *)(v10 + 32) <= 0u;
  v16 = *(_DWORD *)(v10 + 24) <= 0u;
LABEL_6:
  v17 = !v16 || !v15;
  if ( !v17 )
  {
LABEL_35:
    v22 = v43;
    goto LABEL_36;
  }
  while ( 1 )
  {
    if ( v46 )
    {
      if ( v47 != -1 )
      {
        v18 = 0;
        goto LABEL_11;
      }
      v26 = (unsigned __int8 *)v46[2];
      if ( (unsigned int)v26 < v46[3] )
      {
        v27 = *v26;
LABEL_47:
        v47 = v27;
        v18 = 0;
        goto LABEL_11;
      }
      v39 = v13;
      v40 = v12;
      v27 = (*(int (**)(void))(*v46 + 36))();
      v13 = v39;
      v12 = v40;
      if ( v27 != -1 )
        goto LABEL_47;
      v18 = v17;
      v46 = 0;
    }
    else
    {
      v18 = v17;
    }
LABEL_11:
    if ( !a5 )
      goto LABEL_15;
    if ( a6 != -1 )
    {
      v17 = 0;
      goto LABEL_15;
    }
    v28 = (unsigned __int8 *)a5[2];
    if ( (unsigned int)v28 >= a5[3] )
    {
      v37 = v13;
      v38 = v12;
      v29 = (*(int (**)(void))(*a5 + 36))();
      v12 = v38;
      v13 = v37;
      if ( v29 == -1 )
      {
        a5 = 0;
LABEL_15:
        if ( v18 == v17 )
          goto LABEL_51;
        goto LABEL_16;
      }
    }
    else
    {
      v29 = *v28;
    }
    a6 = v29;
    if ( !v18 )
    {
LABEL_51:
      v22 = v43;
      v17 = 1;
      goto LABEL_36;
    }
LABEL_16:
    if ( v46 )
    {
      if ( v47 != -1 )
      {
        v19 = (unsigned __int8)v47;
        goto LABEL_20;
      }
      v24 = (unsigned __int8 *)v46[2];
      if ( (unsigned int)v24 < v46[3] )
      {
        v25 = *v24;
LABEL_44:
        v47 = v25;
        v19 = (unsigned __int8)v25;
        goto LABEL_20;
      }
      v41 = v13;
      v42 = v12;
      v25 = (*(int (**)(void))(*v46 + 36))();
      v13 = v41;
      v12 = v42;
      if ( v25 != -1 )
        goto LABEL_44;
      v19 = 255;
      v46 = 0;
    }
    else
    {
      v19 = 255;
    }
LABEL_20:
    if ( !v15 )
    {
      v20 = *(unsigned __int8 *)(v14[7] + v11) - v19;
      v13 = v20 + (v20 <= 0) + v19 - *(unsigned __int8 *)(v14[7] + v11);
    }
    if ( (v13 ^ 1) & v16 )
    {
      v22 = v43;
LABEL_62:
      v17 = 0;
      goto LABEL_38;
    }
    if ( !v16 )
      v43 = (unsigned int)*(unsigned __int8 *)(v14[5] + v11) - v19 <= 0;
    if ( v15 && !v43 )
      break;
    if ( !v43 & (v13 ^ 1) )
    {
      v22 = 0;
      goto LABEL_62;
    }
    ++v11;
    if ( v46 )
    {
      v21 = v46[2];
      if ( v21 >= v46[3] )
      {
        v35 = v13;
        v36 = v12;
        (*(void (**)(void))(*v46 + 40))();
        v12 = v36;
        v13 = v35;
      }
      else
      {
        v46[2] = v21 + 1;
      }
      v47 = v12;
    }
    v15 = 1;
    if ( v13 )
      v15 = v11 >= v14[8];
    v16 = 1;
    if ( !v43 )
      goto LABEL_6;
    v16 = v11 >= v14[6];
    v17 = !v16 || !v15;
    if ( !v17 )
      goto LABEL_35;
  }
  v22 = 0;
  v17 = 0;
LABEL_36:
  if ( v13 && v11 == v14[8] && v11 )
  {
    *a9 = 0;
    if ( v22 && v14[6] == v11 )
    {
      *a8 = 4;
    }
    else
    {
      if ( v17 )
        v32 = 2;
      else
        v32 = 0;
      *a8 = v32;
    }
  }
  else
  {
LABEL_38:
    if ( v22 && v14[6] == v11 && v11 )
    {
      if ( v17 )
        v33 = 2;
      else
        v33 = 0;
      v34 = a8;
      *a9 = 1;
      *v34 = v33;
    }
    else
    {
      *a9 = 0;
      v23 = a8;
      *a8 = 4;
      if ( v17 )
        *v23 = 6;
    }
  }
LABEL_53:
  v30 = v47;
  *v9 = v46;
  v9[1] = v30;
  return v9;
}

//----- (0009E59C) --------------------------------------------------------
_DWORD *__fastcall sub_9E59C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int16 *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  unsigned __int8 v14; // r0
  unsigned int v15; // r4
  unsigned int v16; // r7
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r5
  size_t v20; // r9
  int v21; // r10
  unsigned int v22; // r6
  signed int v23; // r7
  int v24; // r4
  int v25; // r6
  _DWORD *v26; // r0
  unsigned int v27; // r3
  unsigned __int8 *v28; // r3
  int v29; // r0
  signed int v30; // r4
  signed int v31; // r3
  signed int v32; // r4
  _DWORD *v33; // r3
  int v34; // r2
  signed __int16 v35; // r1
  int v36; // r1
  unsigned __int8 *v38; // r3
  int v39; // r0
  signed int v40; // r0
  char *v41; // r0
  int v42; // r4
  int v43; // r6
  _DWORD *v44; // r0
  unsigned int v45; // r3
  unsigned __int8 *v46; // r3
  int v47; // r0
  int v48; // r4
  int v49; // r3
  unsigned __int8 *v50; // r3
  int v51; // r0
  signed int v52; // r10
  int v53; // r5
  int v54; // r9
  signed int v55; // r6
  unsigned int v56; // r2
  int v57; // r6
  unsigned __int8 v58; // r0
  int v59; // [sp+4h] [bp-64h]
  unsigned int v60; // [sp+8h] [bp-60h]
  signed int v61; // [sp+10h] [bp-58h]
  int v62; // [sp+14h] [bp-54h]
  _DWORD *v63; // [sp+1Ch] [bp-4Ch]
  char v64; // [sp+20h] [bp-48h]
  int v65; // [sp+24h] [bp-44h]
  _DWORD *v66; // [sp+28h] [bp-40h]
  int v67; // [sp+2Ch] [bp-3Ch]
  char v68; // [sp+34h] [bp-34h]
  _DWORD *v69; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v63 = a1;
  v66 = a3;
  v67 = a4;
  v10 = sub_9A83C((int)&v68, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v61 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v61 = v13;
  }
  if ( sub_9B0DC(&v66, &a5) )
  {
    v15 = 0;
    v65 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v66);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v12 + 74) - v14;
    v65 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v12 + 74);
    if ( !v65 && *(unsigned __int8 *)(v12 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_103;
    }
    v17 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_103;
    }
    if ( *(unsigned __int8 *)(v12 + 36) == v14 )
    {
LABEL_103:
      v52 = v61;
      v53 = v11;
      v54 = 0;
      v55 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v12 + 37) == v15 || *(unsigned __int8 *)(v12 + 36) == v15 )
        {
LABEL_141:
          v61 = v52;
          v19 = 0;
          v64 = v55;
          v59 = v54;
          goto LABEL_12;
        }
        if ( *(unsigned __int8 *)(v12 + 78) == v15 )
        {
          v57 = v55 ^ 1;
          if ( v52 == 10 )
            v57 |= 1u;
          if ( v57 )
          {
            if ( v53 )
            {
              if ( v52 == 8 )
                v54 = 0;
              else
                ++v54;
              v55 = 1;
            }
            else
            {
              v54 = 0;
              v55 = 1;
              v52 = 8;
            }
            goto LABEL_114;
          }
        }
        else if ( !v55 )
        {
          goto LABEL_141;
        }
        if ( *(unsigned __int8 *)(v12 + 76) != v15 && *(unsigned __int8 *)(v12 + 77) != v15 )
        {
          v61 = v52;
          v59 = v54;
          v19 = 0;
          v64 = 1;
          goto LABEL_12;
        }
        if ( v53 )
        {
          if ( v52 != 16 )
          {
            v61 = v52;
            v59 = v54;
            v19 = 0;
            v64 = 1;
            goto LABEL_13;
          }
          v54 = 0;
          v55 = 0;
        }
        else
        {
          v54 = 0;
          v55 = 0;
          v52 = 16;
        }
LABEL_114:
        if ( v66 )
        {
          v56 = v66[2];
          if ( v56 >= v66[3] )
            (*(void (**)(void))(*v66 + 40))();
          else
            v66[2] = v56 + 1;
          v67 = -1;
        }
        if ( sub_9B0DC(&v66, &a5) )
        {
          v61 = v52;
          v19 = 1;
          v64 = v55;
          v59 = v54;
          v17 = *(unsigned __int8 *)(v12 + 16);
          if ( v52 != 16 )
            goto LABEL_13;
          goto LABEL_120;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v66);
        if ( !v55 )
        {
          v61 = v52;
          v19 = 0;
          v64 = 0;
          v59 = v54;
          v17 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v17 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v18 = sub_9A76C(&v66);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v58 = sub_9B0A0(&v66);
      v17 = *(unsigned __int8 *)(v12 + 16);
      v15 = v58;
      goto LABEL_103;
    }
  }
  v17 = *(unsigned __int8 *)(v12 + 16);
  v59 = 0;
  v64 = 0;
  v19 = 1;
LABEL_12:
  if ( v61 == 16 )
LABEL_120:
    v20 = 22;
  else
LABEL_13:
    v20 = v61;
  v69 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v69, 0x20u);
  v21 = v12 + 78;
  v62 = *(unsigned __int8 *)(v12 + 100);
  v60 = (unsigned __int16)(0xFFFF / v61);
  if ( !*(_BYTE *)(v12 + 100) )
  {
    if ( !v19 )
    {
      v22 = 0;
      v23 = 0;
      while ( 1 )
      {
        if ( v20 > 0xA )
        {
          if ( (unsigned __int8)(v15 - 48) > 9u )
          {
            if ( v15 - 97 > 5 )
            {
              if ( v15 - 65 > 5 )
                goto LABEL_66;
              v24 = v15 - 55;
            }
            else
            {
              v24 = v15 - 87;
            }
          }
          else
          {
            v24 = v15 - 48;
          }
        }
        else
        {
          if ( v15 <= 0x2F || (unsigned __int8)(v20 + 48) <= v15 )
            goto LABEL_66;
          v24 = v15 - 48;
        }
        if ( v60 >= v22 )
        {
          ++v59;
          v25 = (unsigned __int16)(v61 * v22);
          if ( v25 > 0xFFFF - v24 )
            LOBYTE(v23) = v23 | 1;
          v23 = (unsigned __int8)v23;
          v22 = (unsigned __int16)(v25 + v24);
        }
        else
        {
          v23 = 1;
        }
        v26 = v66;
        if ( !v66 )
          break;
        v27 = v66[2];
        if ( v27 >= v66[3] )
        {
          (*(void (**)(void))(*v66 + 40))();
          v26 = v66;
          v67 = -1;
          if ( !v66 )
            break;
        }
        else
        {
          v67 = -1;
          v66[2] = v27 + 1;
        }
        v28 = (unsigned __int8 *)v26[2];
        if ( (unsigned int)v28 < v26[3] )
        {
          v29 = *v28;
LABEL_33:
          v30 = 0;
          v67 = v29;
          goto LABEL_34;
        }
        v29 = (*(int (**)(void))(*v26 + 36))();
        if ( v29 != -1 )
          goto LABEL_33;
        v30 = 1;
        v66 = 0;
LABEL_34:
        if ( !a5 )
        {
          v31 = 1;
          goto LABEL_38;
        }
        if ( a6 != -1 )
        {
          v31 = 0;
          goto LABEL_38;
        }
        v38 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v38 >= a5[3] )
        {
          v39 = (*(int (**)(void))(*a5 + 36))();
          if ( v39 == -1 )
          {
            v31 = 1;
            a5 = 0;
LABEL_38:
            if ( v30 == v31 )
              goto LABEL_39;
            goto LABEL_65;
          }
        }
        else
        {
          v39 = *v38;
        }
        a6 = v39;
        if ( !v30 )
          goto LABEL_39;
LABEL_65:
        v15 = (unsigned __int8)sub_9B0A0(&v66);
      }
      v30 = 1;
      goto LABEL_34;
    }
    v22 = 0;
    v23 = 0;
    v32 = 0;
LABEL_40:
    v33 = v69;
    if ( *(v69 - 3) )
      goto LABEL_67;
    goto LABEL_41;
  }
  if ( v19 )
  {
    v22 = 0;
    v23 = 0;
    v32 = 0;
    goto LABEL_40;
  }
  v22 = 0;
  v23 = 0;
  while ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v15 )
  {
    if ( !v59 )
    {
      v32 = 1;
      goto LABEL_40;
    }
    sub_C15D0((int *)&v69, v59);
    v59 = 0;
LABEL_82:
    v44 = v66;
    if ( !v66 )
      goto LABEL_95;
    v45 = v66[2];
    if ( v45 >= v66[3] )
    {
      (*(void (**)(void))(*v66 + 40))();
      v44 = v66;
      v67 = -1;
      if ( !v66 )
      {
LABEL_95:
        v48 = v62;
        goto LABEL_88;
      }
    }
    else
    {
      v67 = -1;
      v66[2] = v45 + 1;
    }
    v46 = (unsigned __int8 *)v44[2];
    if ( (unsigned int)v46 < v44[3] )
    {
      v47 = *v46;
LABEL_87:
      v48 = 0;
      v67 = v47;
      goto LABEL_88;
    }
    v47 = (*(int (**)(void))(*v44 + 36))();
    if ( v47 != -1 )
      goto LABEL_87;
    v48 = v62;
    v66 = 0;
LABEL_88:
    if ( a5 )
    {
      if ( a6 != -1 )
      {
        v49 = 0;
        goto LABEL_92;
      }
      v50 = (unsigned __int8 *)a5[2];
      if ( (unsigned int)v50 < a5[3] )
      {
        v51 = *v50;
LABEL_98:
        a6 = v51;
        v49 = 0;
        goto LABEL_92;
      }
      v51 = (*(int (**)(void))(*a5 + 36))();
      if ( v51 != -1 )
        goto LABEL_98;
      v49 = v62;
      a5 = 0;
    }
    else
    {
      v49 = v62;
    }
LABEL_92:
    if ( v49 == v48 )
    {
LABEL_39:
      v32 = 0;
      v19 = 1;
      goto LABEL_40;
    }
    v15 = (unsigned __int8)sub_9B0A0(&v66);
  }
  if ( *(unsigned __int8 *)(v12 + 36) != v15 )
  {
    v41 = (char *)memchr((const void *)(v12 + 78), v15, v20);
    if ( v41 )
    {
      v42 = (int)&v41[-v21];
      if ( (signed int)&v41[-v21] > 15 )
        v42 -= 6;
      if ( v60 >= v22 )
      {
        ++v59;
        v43 = (unsigned __int16)(v61 * v22);
        if ( v43 > 0xFFFF - v42 )
          LOBYTE(v23) = v23 | 1;
        v23 = (unsigned __int8)v23;
        v22 = (unsigned __int16)(v43 + v42);
      }
      else
      {
        v23 = 1;
      }
      goto LABEL_82;
    }
  }
LABEL_66:
  v33 = v69;
  v32 = 0;
  if ( !*(v69 - 3) )
    goto LABEL_41;
LABEL_67:
  sub_C15D0((int *)&v69, v59);
  v40 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v69);
  v33 = v69;
  if ( !v40 )
    *a8 = 4;
LABEL_41:
  if ( v59 )
    v34 = 0;
  else
    v34 = ((unsigned __int8)v64 ^ 1) & 1;
  if ( v34 && !*(v33 - 3) || v32 )
  {
    v35 = 0;
    goto LABEL_47;
  }
  if ( v23 )
  {
    v35 = -1;
LABEL_47:
    *a9 = v35;
    *a8 = 4;
  }
  else
  {
    if ( v65 )
      v22 = -v22;
    *a9 = v22;
  }
  if ( v19 )
    *a8 |= 2u;
  v36 = v67;
  *v63 = v66;
  v63[1] = v36;
  sub_C0AC4(v33 - 3);
  return v63;
}

//----- (0009EAE8) --------------------------------------------------------
_DWORD *__fastcall sub_9EAE8(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int16 *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9E59C(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (0009EB24) --------------------------------------------------------
_DWORD *__fastcall sub_9EB24(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  unsigned __int8 v14; // r0
  unsigned int v15; // r4
  unsigned int v16; // r7
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r5
  size_t v20; // r9
  unsigned int v21; // r6
  signed int v22; // r7
  int v23; // r4
  unsigned int v24; // r6
  _DWORD *v25; // r0
  unsigned int v26; // r3
  unsigned __int8 *v27; // r3
  int v28; // r0
  signed int v29; // r4
  signed int v30; // r3
  signed int v31; // r4
  _DWORD *v32; // r3
  int v33; // r2
  signed int v34; // r1
  int v35; // r1
  unsigned __int8 *v37; // r3
  int v38; // r0
  signed int v39; // r0
  char *v40; // r0
  int v41; // r4
  unsigned int v42; // r6
  _DWORD *v43; // r0
  unsigned int v44; // r3
  unsigned __int8 *v45; // r3
  int v46; // r0
  int v47; // r4
  int v48; // r3
  unsigned __int8 *v49; // r3
  int v50; // r0
  signed int v51; // r10
  int v52; // r5
  int v53; // r9
  signed int v54; // r6
  unsigned int v55; // r2
  int v56; // r6
  unsigned __int8 v57; // r0
  int v58; // [sp+4h] [bp-64h]
  unsigned int v59; // [sp+8h] [bp-60h]
  unsigned int v60; // [sp+10h] [bp-58h]
  int v61; // [sp+14h] [bp-54h]
  _DWORD *v62; // [sp+1Ch] [bp-4Ch]
  char v63; // [sp+20h] [bp-48h]
  int v64; // [sp+24h] [bp-44h]
  _DWORD *v65; // [sp+28h] [bp-40h]
  int v66; // [sp+2Ch] [bp-3Ch]
  char v67; // [sp+34h] [bp-34h]
  _DWORD *v68; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v62 = a1;
  v65 = a3;
  v66 = a4;
  v10 = sub_9A83C((int)&v67, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v60 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v60 = v13;
  }
  if ( sub_9B0DC(&v65, &a5) )
  {
    v15 = 0;
    v64 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v65);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v12 + 74) - v14;
    v64 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v12 + 74);
    if ( !v64 && *(unsigned __int8 *)(v12 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_103;
    }
    v17 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_103;
    }
    if ( *(unsigned __int8 *)(v12 + 36) == v14 )
    {
LABEL_103:
      v51 = v60;
      v52 = v11;
      v53 = 0;
      v54 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v12 + 37) == v15 || *(unsigned __int8 *)(v12 + 36) == v15 )
        {
LABEL_141:
          v60 = v51;
          v19 = 0;
          v63 = v54;
          v58 = v53;
          goto LABEL_12;
        }
        if ( *(unsigned __int8 *)(v12 + 78) == v15 )
        {
          v56 = v54 ^ 1;
          if ( v51 == 10 )
            v56 |= 1u;
          if ( v56 )
          {
            if ( v52 )
            {
              if ( v51 == 8 )
                v53 = 0;
              else
                ++v53;
              v54 = 1;
            }
            else
            {
              v53 = 0;
              v54 = 1;
              v51 = 8;
            }
            goto LABEL_114;
          }
        }
        else if ( !v54 )
        {
          goto LABEL_141;
        }
        if ( *(unsigned __int8 *)(v12 + 76) != v15 && *(unsigned __int8 *)(v12 + 77) != v15 )
        {
          v60 = v51;
          v58 = v53;
          v19 = 0;
          v63 = 1;
          goto LABEL_12;
        }
        if ( v52 )
        {
          if ( v51 != 16 )
          {
            v60 = v51;
            v58 = v53;
            v19 = 0;
            v63 = 1;
            goto LABEL_13;
          }
          v53 = 0;
          v54 = 0;
        }
        else
        {
          v53 = 0;
          v54 = 0;
          v51 = 16;
        }
LABEL_114:
        if ( v65 )
        {
          v55 = v65[2];
          if ( v55 >= v65[3] )
            (*(void (**)(void))(*v65 + 40))();
          else
            v65[2] = v55 + 1;
          v66 = -1;
        }
        if ( sub_9B0DC(&v65, &a5) )
        {
          v60 = v51;
          v19 = 1;
          v63 = v54;
          v58 = v53;
          v17 = *(unsigned __int8 *)(v12 + 16);
          if ( v51 != 16 )
            goto LABEL_13;
          goto LABEL_120;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v65);
        if ( !v54 )
        {
          v60 = v51;
          v19 = 0;
          v63 = 0;
          v58 = v53;
          v17 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v17 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v18 = sub_9A76C(&v65);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v57 = sub_9B0A0(&v65);
      v17 = *(unsigned __int8 *)(v12 + 16);
      v15 = v57;
      goto LABEL_103;
    }
  }
  v17 = *(unsigned __int8 *)(v12 + 16);
  v58 = 0;
  v63 = 0;
  v19 = 1;
LABEL_12:
  if ( v60 == 16 )
LABEL_120:
    v20 = 22;
  else
LABEL_13:
    v20 = v60;
  v68 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v68, 0x20u);
  v61 = *(unsigned __int8 *)(v12 + 100);
  v59 = 0xFFFFFFFF / v60;
  if ( !*(_BYTE *)(v12 + 100) )
  {
    if ( !v19 )
    {
      v21 = 0;
      v22 = 0;
      while ( 1 )
      {
        if ( v20 > 0xA )
        {
          if ( (unsigned __int8)(v15 - 48) > 9u )
          {
            if ( v15 - 97 > 5 )
            {
              if ( v15 - 65 > 5 )
                goto LABEL_66;
              v23 = v15 - 55;
            }
            else
            {
              v23 = v15 - 87;
            }
          }
          else
          {
            v23 = v15 - 48;
          }
        }
        else
        {
          if ( v15 <= 0x2F || (unsigned __int8)(v20 + 48) <= v15 )
            goto LABEL_66;
          v23 = v15 - 48;
        }
        if ( v59 >= v21 )
        {
          v24 = v60 * v21;
          ++v58;
          if ( ~v23 < v24 )
            LOBYTE(v22) = v22 | 1;
          v21 = v24 + v23;
          v22 = (unsigned __int8)v22;
        }
        else
        {
          v22 = 1;
        }
        v25 = v65;
        if ( !v65 )
          break;
        v26 = v65[2];
        if ( v26 >= v65[3] )
        {
          (*(void (**)(void))(*v65 + 40))();
          v25 = v65;
          v66 = -1;
          if ( !v65 )
            break;
        }
        else
        {
          v66 = -1;
          v65[2] = v26 + 1;
        }
        v27 = (unsigned __int8 *)v25[2];
        if ( (unsigned int)v27 < v25[3] )
        {
          v28 = *v27;
LABEL_33:
          v29 = 0;
          v66 = v28;
          goto LABEL_34;
        }
        v28 = (*(int (**)(void))(*v25 + 36))();
        if ( v28 != -1 )
          goto LABEL_33;
        v29 = 1;
        v65 = 0;
LABEL_34:
        if ( !a5 )
        {
          v30 = 1;
          goto LABEL_38;
        }
        if ( a6 != -1 )
        {
          v30 = 0;
          goto LABEL_38;
        }
        v37 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v37 >= a5[3] )
        {
          v38 = (*(int (**)(void))(*a5 + 36))();
          if ( v38 == -1 )
          {
            v30 = 1;
            a5 = 0;
LABEL_38:
            if ( v29 == v30 )
              goto LABEL_39;
            goto LABEL_65;
          }
        }
        else
        {
          v38 = *v37;
        }
        a6 = v38;
        if ( !v29 )
          goto LABEL_39;
LABEL_65:
        v15 = (unsigned __int8)sub_9B0A0(&v65);
      }
      v29 = 1;
      goto LABEL_34;
    }
    v21 = 0;
    v22 = 0;
    v31 = 0;
LABEL_40:
    v32 = v68;
    if ( *(v68 - 3) )
      goto LABEL_67;
    goto LABEL_41;
  }
  if ( v19 )
  {
    v21 = 0;
    v22 = 0;
    v31 = 0;
    goto LABEL_40;
  }
  v21 = 0;
  v22 = 0;
  while ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v15 )
  {
    if ( !v58 )
    {
      v31 = 1;
      goto LABEL_40;
    }
    sub_C15D0((int *)&v68, v58);
    v58 = 0;
LABEL_82:
    v43 = v65;
    if ( !v65 )
      goto LABEL_95;
    v44 = v65[2];
    if ( v44 >= v65[3] )
    {
      (*(void (**)(void))(*v65 + 40))();
      v43 = v65;
      v66 = -1;
      if ( !v65 )
      {
LABEL_95:
        v47 = v61;
        goto LABEL_88;
      }
    }
    else
    {
      v66 = -1;
      v65[2] = v44 + 1;
    }
    v45 = (unsigned __int8 *)v43[2];
    if ( (unsigned int)v45 < v43[3] )
    {
      v46 = *v45;
LABEL_87:
      v47 = 0;
      v66 = v46;
      goto LABEL_88;
    }
    v46 = (*(int (**)(void))(*v43 + 36))();
    if ( v46 != -1 )
      goto LABEL_87;
    v47 = v61;
    v65 = 0;
LABEL_88:
    if ( a5 )
    {
      if ( a6 != -1 )
      {
        v48 = 0;
        goto LABEL_92;
      }
      v49 = (unsigned __int8 *)a5[2];
      if ( (unsigned int)v49 < a5[3] )
      {
        v50 = *v49;
LABEL_98:
        a6 = v50;
        v48 = 0;
        goto LABEL_92;
      }
      v50 = (*(int (**)(void))(*a5 + 36))();
      if ( v50 != -1 )
        goto LABEL_98;
      v48 = v61;
      a5 = 0;
    }
    else
    {
      v48 = v61;
    }
LABEL_92:
    if ( v48 == v47 )
    {
LABEL_39:
      v31 = 0;
      v19 = 1;
      goto LABEL_40;
    }
    v15 = (unsigned __int8)sub_9B0A0(&v65);
  }
  if ( *(unsigned __int8 *)(v12 + 36) != v15 )
  {
    v40 = (char *)memchr((const void *)(v12 + 78), v15, v20);
    if ( v40 )
    {
      v41 = (int)&v40[-v12 - 78];
      if ( v41 > 15 )
        v41 -= 6;
      if ( v59 >= v21 )
      {
        v42 = v60 * v21;
        ++v58;
        if ( ~v41 < v42 )
          LOBYTE(v22) = v22 | 1;
        v21 = v42 + v41;
        v22 = (unsigned __int8)v22;
      }
      else
      {
        v22 = 1;
      }
      goto LABEL_82;
    }
  }
LABEL_66:
  v32 = v68;
  v31 = 0;
  if ( !*(v68 - 3) )
    goto LABEL_41;
LABEL_67:
  sub_C15D0((int *)&v68, v58);
  v39 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v68);
  v32 = v68;
  if ( !v39 )
    *a8 = 4;
LABEL_41:
  if ( v58 )
    v33 = 0;
  else
    v33 = ((unsigned __int8)v63 ^ 1) & 1;
  if ( v33 && !*(v32 - 3) || v31 )
  {
    v34 = 0;
    goto LABEL_47;
  }
  if ( v22 )
  {
    v34 = -1;
LABEL_47:
    *a9 = v34;
    *a8 = 4;
  }
  else
  {
    if ( v64 )
      v21 = -v21;
    *a9 = v21;
  }
  if ( v19 )
    *a8 |= 2u;
  v35 = v66;
  *v62 = v65;
  v62[1] = v35;
  sub_C0AC4(v32 - 3);
  return v62;
}

//----- (0009F058) --------------------------------------------------------
_DWORD *__fastcall sub_9F058(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9EB24(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (0009F094) --------------------------------------------------------
_DWORD *__fastcall sub_9F094(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  unsigned __int8 v14; // r0
  unsigned int v15; // r4
  unsigned int v16; // r7
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r5
  size_t v20; // r9
  unsigned int v21; // r6
  signed int v22; // r7
  int v23; // r4
  unsigned int v24; // r6
  _DWORD *v25; // r0
  unsigned int v26; // r3
  unsigned __int8 *v27; // r3
  int v28; // r0
  signed int v29; // r4
  signed int v30; // r3
  signed int v31; // r4
  _DWORD *v32; // r3
  int v33; // r2
  signed int v34; // r1
  int v35; // r1
  unsigned __int8 *v37; // r3
  int v38; // r0
  signed int v39; // r0
  char *v40; // r0
  int v41; // r4
  unsigned int v42; // r6
  _DWORD *v43; // r0
  unsigned int v44; // r3
  unsigned __int8 *v45; // r3
  int v46; // r0
  int v47; // r4
  int v48; // r3
  unsigned __int8 *v49; // r3
  int v50; // r0
  signed int v51; // r10
  int v52; // r5
  int v53; // r9
  signed int v54; // r6
  unsigned int v55; // r2
  int v56; // r6
  unsigned __int8 v57; // r0
  int v58; // [sp+4h] [bp-64h]
  unsigned int v59; // [sp+8h] [bp-60h]
  unsigned int v60; // [sp+10h] [bp-58h]
  int v61; // [sp+14h] [bp-54h]
  _DWORD *v62; // [sp+1Ch] [bp-4Ch]
  char v63; // [sp+20h] [bp-48h]
  int v64; // [sp+24h] [bp-44h]
  _DWORD *v65; // [sp+28h] [bp-40h]
  int v66; // [sp+2Ch] [bp-3Ch]
  char v67; // [sp+34h] [bp-34h]
  _DWORD *v68; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v62 = a1;
  v65 = a3;
  v66 = a4;
  v10 = sub_9A83C((int)&v67, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v60 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v60 = v13;
  }
  if ( sub_9B0DC(&v65, &a5) )
  {
    v15 = 0;
    v64 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v65);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v12 + 74) - v14;
    v64 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v12 + 74);
    if ( !v64 && *(unsigned __int8 *)(v12 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_103;
    }
    v17 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_103;
    }
    if ( *(unsigned __int8 *)(v12 + 36) == v14 )
    {
LABEL_103:
      v51 = v60;
      v52 = v11;
      v53 = 0;
      v54 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v12 + 37) == v15 || *(unsigned __int8 *)(v12 + 36) == v15 )
        {
LABEL_141:
          v60 = v51;
          v19 = 0;
          v63 = v54;
          v58 = v53;
          goto LABEL_12;
        }
        if ( *(unsigned __int8 *)(v12 + 78) == v15 )
        {
          v56 = v54 ^ 1;
          if ( v51 == 10 )
            v56 |= 1u;
          if ( v56 )
          {
            if ( v52 )
            {
              if ( v51 == 8 )
                v53 = 0;
              else
                ++v53;
              v54 = 1;
            }
            else
            {
              v53 = 0;
              v54 = 1;
              v51 = 8;
            }
            goto LABEL_114;
          }
        }
        else if ( !v54 )
        {
          goto LABEL_141;
        }
        if ( *(unsigned __int8 *)(v12 + 76) != v15 && *(unsigned __int8 *)(v12 + 77) != v15 )
        {
          v60 = v51;
          v58 = v53;
          v19 = 0;
          v63 = 1;
          goto LABEL_12;
        }
        if ( v52 )
        {
          if ( v51 != 16 )
          {
            v60 = v51;
            v58 = v53;
            v19 = 0;
            v63 = 1;
            goto LABEL_13;
          }
          v53 = 0;
          v54 = 0;
        }
        else
        {
          v53 = 0;
          v54 = 0;
          v51 = 16;
        }
LABEL_114:
        if ( v65 )
        {
          v55 = v65[2];
          if ( v55 >= v65[3] )
            (*(void (**)(void))(*v65 + 40))();
          else
            v65[2] = v55 + 1;
          v66 = -1;
        }
        if ( sub_9B0DC(&v65, &a5) )
        {
          v60 = v51;
          v19 = 1;
          v63 = v54;
          v58 = v53;
          v17 = *(unsigned __int8 *)(v12 + 16);
          if ( v51 != 16 )
            goto LABEL_13;
          goto LABEL_120;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v65);
        if ( !v54 )
        {
          v60 = v51;
          v19 = 0;
          v63 = 0;
          v58 = v53;
          v17 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v17 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v18 = sub_9A76C(&v65);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v57 = sub_9B0A0(&v65);
      v17 = *(unsigned __int8 *)(v12 + 16);
      v15 = v57;
      goto LABEL_103;
    }
  }
  v17 = *(unsigned __int8 *)(v12 + 16);
  v58 = 0;
  v63 = 0;
  v19 = 1;
LABEL_12:
  if ( v60 == 16 )
LABEL_120:
    v20 = 22;
  else
LABEL_13:
    v20 = v60;
  v68 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v68, 0x20u);
  v61 = *(unsigned __int8 *)(v12 + 100);
  v59 = 0xFFFFFFFF / v60;
  if ( !*(_BYTE *)(v12 + 100) )
  {
    if ( !v19 )
    {
      v21 = 0;
      v22 = 0;
      while ( 1 )
      {
        if ( v20 > 0xA )
        {
          if ( (unsigned __int8)(v15 - 48) > 9u )
          {
            if ( v15 - 97 > 5 )
            {
              if ( v15 - 65 > 5 )
                goto LABEL_66;
              v23 = v15 - 55;
            }
            else
            {
              v23 = v15 - 87;
            }
          }
          else
          {
            v23 = v15 - 48;
          }
        }
        else
        {
          if ( v15 <= 0x2F || (unsigned __int8)(v20 + 48) <= v15 )
            goto LABEL_66;
          v23 = v15 - 48;
        }
        if ( v59 >= v21 )
        {
          v24 = v60 * v21;
          ++v58;
          if ( ~v23 < v24 )
            LOBYTE(v22) = v22 | 1;
          v21 = v24 + v23;
          v22 = (unsigned __int8)v22;
        }
        else
        {
          v22 = 1;
        }
        v25 = v65;
        if ( !v65 )
          break;
        v26 = v65[2];
        if ( v26 >= v65[3] )
        {
          (*(void (**)(void))(*v65 + 40))();
          v25 = v65;
          v66 = -1;
          if ( !v65 )
            break;
        }
        else
        {
          v66 = -1;
          v65[2] = v26 + 1;
        }
        v27 = (unsigned __int8 *)v25[2];
        if ( (unsigned int)v27 < v25[3] )
        {
          v28 = *v27;
LABEL_33:
          v29 = 0;
          v66 = v28;
          goto LABEL_34;
        }
        v28 = (*(int (**)(void))(*v25 + 36))();
        if ( v28 != -1 )
          goto LABEL_33;
        v29 = 1;
        v65 = 0;
LABEL_34:
        if ( !a5 )
        {
          v30 = 1;
          goto LABEL_38;
        }
        if ( a6 != -1 )
        {
          v30 = 0;
          goto LABEL_38;
        }
        v37 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v37 >= a5[3] )
        {
          v38 = (*(int (**)(void))(*a5 + 36))();
          if ( v38 == -1 )
          {
            v30 = 1;
            a5 = 0;
LABEL_38:
            if ( v29 == v30 )
              goto LABEL_39;
            goto LABEL_65;
          }
        }
        else
        {
          v38 = *v37;
        }
        a6 = v38;
        if ( !v29 )
          goto LABEL_39;
LABEL_65:
        v15 = (unsigned __int8)sub_9B0A0(&v65);
      }
      v29 = 1;
      goto LABEL_34;
    }
    v21 = 0;
    v22 = 0;
    v31 = 0;
LABEL_40:
    v32 = v68;
    if ( *(v68 - 3) )
      goto LABEL_67;
    goto LABEL_41;
  }
  if ( v19 )
  {
    v21 = 0;
    v22 = 0;
    v31 = 0;
    goto LABEL_40;
  }
  v21 = 0;
  v22 = 0;
  while ( *(_BYTE *)(v12 + 16) && *(unsigned __int8 *)(v12 + 37) == v15 )
  {
    if ( !v58 )
    {
      v31 = 1;
      goto LABEL_40;
    }
    sub_C15D0((int *)&v68, v58);
    v58 = 0;
LABEL_82:
    v43 = v65;
    if ( !v65 )
      goto LABEL_95;
    v44 = v65[2];
    if ( v44 >= v65[3] )
    {
      (*(void (**)(void))(*v65 + 40))();
      v43 = v65;
      v66 = -1;
      if ( !v65 )
      {
LABEL_95:
        v47 = v61;
        goto LABEL_88;
      }
    }
    else
    {
      v66 = -1;
      v65[2] = v44 + 1;
    }
    v45 = (unsigned __int8 *)v43[2];
    if ( (unsigned int)v45 < v43[3] )
    {
      v46 = *v45;
LABEL_87:
      v47 = 0;
      v66 = v46;
      goto LABEL_88;
    }
    v46 = (*(int (**)(void))(*v43 + 36))();
    if ( v46 != -1 )
      goto LABEL_87;
    v47 = v61;
    v65 = 0;
LABEL_88:
    if ( a5 )
    {
      if ( a6 != -1 )
      {
        v48 = 0;
        goto LABEL_92;
      }
      v49 = (unsigned __int8 *)a5[2];
      if ( (unsigned int)v49 < a5[3] )
      {
        v50 = *v49;
LABEL_98:
        a6 = v50;
        v48 = 0;
        goto LABEL_92;
      }
      v50 = (*(int (**)(void))(*a5 + 36))();
      if ( v50 != -1 )
        goto LABEL_98;
      v48 = v61;
      a5 = 0;
    }
    else
    {
      v48 = v61;
    }
LABEL_92:
    if ( v48 == v47 )
    {
LABEL_39:
      v31 = 0;
      v19 = 1;
      goto LABEL_40;
    }
    v15 = (unsigned __int8)sub_9B0A0(&v65);
  }
  if ( *(unsigned __int8 *)(v12 + 36) != v15 )
  {
    v40 = (char *)memchr((const void *)(v12 + 78), v15, v20);
    if ( v40 )
    {
      v41 = (int)&v40[-v12 - 78];
      if ( v41 > 15 )
        v41 -= 6;
      if ( v59 >= v21 )
      {
        v42 = v60 * v21;
        ++v58;
        if ( ~v41 < v42 )
          LOBYTE(v22) = v22 | 1;
        v21 = v42 + v41;
        v22 = (unsigned __int8)v22;
      }
      else
      {
        v22 = 1;
      }
      goto LABEL_82;
    }
  }
LABEL_66:
  v32 = v68;
  v31 = 0;
  if ( !*(v68 - 3) )
    goto LABEL_41;
LABEL_67:
  sub_C15D0((int *)&v68, v58);
  v39 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v68);
  v32 = v68;
  if ( !v39 )
    *a8 = 4;
LABEL_41:
  if ( v58 )
    v33 = 0;
  else
    v33 = ((unsigned __int8)v63 ^ 1) & 1;
  if ( v33 && !*(v32 - 3) || v31 )
  {
    v34 = 0;
    goto LABEL_47;
  }
  if ( v22 )
  {
    v34 = -1;
LABEL_47:
    *a9 = v34;
    *a8 = 4;
  }
  else
  {
    if ( v64 )
      v21 = -v21;
    *a9 = v21;
  }
  if ( v19 )
    *a8 |= 2u;
  v35 = v66;
  *v62 = v65;
  v62[1] = v35;
  sub_C0AC4(v32 - 3);
  return v62;
}

//----- (0009F5C8) --------------------------------------------------------
_DWORD *__fastcall sub_9F5C8(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9F094(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (0009F604) --------------------------------------------------------
_DWORD *__fastcall sub_9F604(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  _DWORD *v9; // r6
  int v10; // r9
  int v11; // r0
  int v12; // r1
  int v13; // r3
  _DWORD *result; // r0
  char v15; // [sp+18h] [bp-14h]
  int v16; // [sp+1Ch] [bp-10h]
  _DWORD *v17; // [sp+20h] [bp-Ch]
  int v18; // [sp+24h] [bp-8h]
  int v19; // [sp+2Ch] [bp+0h]

  v9 = a1;
  v10 = *(_DWORD *)(a7 + 12);
  v17 = a3;
  v18 = a4;
  *(_DWORD *)(a7 + 12) = v10 & 0xFFFFFFB5 | 8;
  sub_9F094(&v15, a2, a3, a4, a5, a6, a7, a8, &v19);
  v11 = *(_DWORD *)&v15;
  v12 = v16;
  v13 = v19;
  *(_DWORD *)(a7 + 12) = v10;
  *v9 = v11;
  v9[1] = v12;
  result = v9;
  *a9 = v13;
  return result;
}

//----- (0009F668) --------------------------------------------------------
_DWORD *__fastcall sub_9F668(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned __int64 *a9)
{
  signed int v9; // r7
  int v10; // r4
  int v11; // r0
  int v12; // r5
  int v13; // r6
  unsigned __int8 v14; // r0
  unsigned int v15; // r11
  unsigned int v16; // r2
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r4
  size_t v20; // r9
  signed int v21; // r5
  char *v22; // r0
  __int64 v23; // r10
  _DWORD *v24; // r0
  unsigned int v25; // r3
  unsigned __int8 *v26; // r3
  int v27; // r0
  int v28; // r10
  int v29; // r3
  signed int v30; // r7
  _DWORD *v31; // lr
  int v32; // r3
  int v33; // r1
  unsigned __int8 *v35; // r3
  int v36; // r0
  signed int v37; // r0
  int v38; // r11
  __int64 v39; // r10
  _DWORD *v40; // r0
  unsigned int v41; // r3
  unsigned __int8 *v42; // r3
  int v43; // r0
  signed int v44; // r10
  signed int v45; // r3
  unsigned __int8 *v46; // r3
  int v47; // r0
  int v48; // r4
  int v49; // r9
  signed int v50; // r5
  unsigned int v51; // r2
  unsigned __int64 v52; // r2
  int v53; // r5
  unsigned __int8 v54; // r0
  unsigned __int64 v55; // [sp+0h] [bp-80h]
  int v56; // [sp+14h] [bp-6Ch]
  unsigned __int64 v57; // [sp+18h] [bp-68h]
  unsigned __int64 v58; // [sp+20h] [bp-60h]
  int v59; // [sp+2Ch] [bp-54h]
  _DWORD *v60; // [sp+34h] [bp-4Ch]
  char v61; // [sp+38h] [bp-48h]
  int v62; // [sp+3Ch] [bp-44h]
  _DWORD *v63; // [sp+40h] [bp-40h]
  int v64; // [sp+44h] [bp-3Ch]
  char v65; // [sp+4Ch] [bp-34h]
  _DWORD *v66; // [sp+54h] [bp-2Ch]

  v10 = a7;
  v60 = a1;
  v63 = a3;
  v64 = a4;
  v11 = sub_9A83C((int)&v65, (int *)(a7 + 108));
  v12 = *(_DWORD *)(v10 + 12) & 0x4A;
  if ( v12 == 64 )
    v9 = 8;
  v13 = v11;
  if ( v12 != 64 )
  {
    if ( v12 == 8 )
      v9 = 16;
    else
      v9 = 10;
  }
  if ( sub_9B0DC(&v63, &a5) )
  {
    v15 = 0;
    v62 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v63);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v13 + 74) - v14;
    v62 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v13 + 74);
    if ( !v62 && *(unsigned __int8 *)(v13 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v13 + 16);
      goto LABEL_107;
    }
    v17 = *(unsigned __int8 *)(v13 + 16);
    if ( *(_BYTE *)(v13 + 16) && *(unsigned __int8 *)(v13 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_107;
    }
    if ( *(unsigned __int8 *)(v13 + 36) == v14 )
    {
LABEL_107:
      v48 = v12;
      v49 = 0;
      v50 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v13 + 37) == v15 || *(unsigned __int8 *)(v13 + 36) == v15 )
        {
LABEL_145:
          v61 = v50;
          v19 = 0;
          v56 = v49;
          goto LABEL_13;
        }
        if ( *(unsigned __int8 *)(v13 + 78) == v15 )
        {
          v53 = v50 ^ 1;
          if ( v9 == 10 )
            v53 |= 1u;
          if ( v53 )
          {
            if ( v48 )
            {
              if ( v9 == 8 )
                v49 = 0;
              else
                ++v49;
              v50 = 1;
            }
            else
            {
              v49 = 0;
              v50 = 1;
              v9 = 8;
            }
            goto LABEL_118;
          }
        }
        else if ( !v50 )
        {
          goto LABEL_145;
        }
        if ( *(unsigned __int8 *)(v13 + 76) != v15 && *(unsigned __int8 *)(v13 + 77) != v15 )
        {
          v56 = v49;
          v19 = 0;
          v61 = 1;
          goto LABEL_13;
        }
        if ( v48 )
        {
          if ( v9 != 16 )
          {
            v56 = v49;
            v19 = 0;
            v61 = 1;
            goto LABEL_14;
          }
          v49 = 0;
          v50 = 0;
        }
        else
        {
          v49 = 0;
          v50 = 0;
          v9 = 16;
        }
LABEL_118:
        if ( v63 )
        {
          v51 = v63[2];
          if ( v51 >= v63[3] )
            (*(void (**)(void))(*v63 + 40))();
          else
            v63[2] = v51 + 1;
          v64 = -1;
        }
        if ( sub_9B0DC(&v63, &a5) )
        {
          v61 = v50;
          v56 = v49;
          v19 = 1;
          v17 = *(unsigned __int8 *)(v13 + 16);
          if ( v9 != 16 )
            goto LABEL_14;
          goto LABEL_124;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v63);
        if ( !v50 )
        {
          v61 = 0;
          v19 = 0;
          v56 = v49;
          v17 = *(unsigned __int8 *)(v13 + 16);
          goto LABEL_13;
        }
        v17 = *(unsigned __int8 *)(v13 + 16);
      }
    }
    v18 = sub_9A76C(&v63);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v54 = sub_9B0A0(&v63);
      v17 = *(unsigned __int8 *)(v13 + 16);
      v15 = v54;
      goto LABEL_107;
    }
  }
  v17 = *(unsigned __int8 *)(v13 + 16);
  v19 = 1;
  v56 = 0;
  v61 = 0;
LABEL_13:
  if ( v9 == 16 )
LABEL_124:
    v20 = 22;
  else
LABEL_14:
    v20 = v9;
  v66 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v66, 0x20u);
  if ( v62 )
    v58 = 0x8000000000000000LL;
  else
    v58 = 0x7FFFFFFFFFFFFFFFLL;
  v59 = *(unsigned __int8 *)(v13 + 100);
  v57 = v58 / v9;
  if ( !*(_BYTE *)(v13 + 100) )
  {
    if ( v19 )
    {
      v21 = 0;
      v55 = 0LL;
      v30 = 0;
      goto LABEL_45;
    }
    v21 = 0;
    v55 = 0LL;
    if ( v20 > 0xA )
      goto LABEL_93;
LABEL_73:
    if ( v15 <= 0x2F || v15 >= (unsigned __int8)(v20 + 48) )
    {
LABEL_68:
      v31 = v66;
      v30 = 0;
      if ( !*(v66 - 3) )
        goto LABEL_46;
      goto LABEL_69;
    }
    v38 = v15 - 48;
    while ( 1 )
    {
      if ( v57 >= v55 )
      {
        v39 = v38;
        ++v56;
        if ( v58 - v39 < v9 * v55 )
          LOBYTE(v21) = v21 | 1;
        v55 = v39 + v9 * v55;
        v21 = (unsigned __int8)v21;
      }
      else
      {
        v21 = 1;
      }
      v40 = v63;
      if ( !v63 )
        break;
      v41 = v63[2];
      if ( v41 >= v63[3] )
      {
        (*(void (**)(void))(*v63 + 40))();
        v40 = v63;
        v64 = -1;
        if ( !v63 )
          break;
      }
      else
      {
        v64 = -1;
        v63[2] = v41 + 1;
      }
      v42 = (unsigned __int8 *)v40[2];
      if ( (unsigned int)v42 < v40[3] )
      {
        v43 = *v42;
LABEL_86:
        v44 = 0;
        v64 = v43;
        goto LABEL_87;
      }
      v43 = (*(int (**)(void))(*v40 + 36))();
      if ( v43 != -1 )
        goto LABEL_86;
      v44 = 1;
      v63 = 0;
LABEL_87:
      if ( a5 )
      {
        if ( a6 != -1 )
        {
          v45 = 0;
          goto LABEL_91;
        }
        v46 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v46 < a5[3] )
        {
          v47 = *v46;
LABEL_103:
          a6 = v47;
          v45 = 0;
          goto LABEL_91;
        }
        v47 = (*(int (**)(void))(*a5 + 36))();
        if ( v47 != -1 )
          goto LABEL_103;
        v45 = 1;
        a5 = 0;
      }
      else
      {
        v45 = 1;
      }
LABEL_91:
      if ( v45 == v44 )
      {
LABEL_44:
        v30 = 0;
        v19 = 1;
        goto LABEL_45;
      }
      v15 = (unsigned __int8)sub_9B0A0(&v63);
      if ( v20 <= 0xA )
        goto LABEL_73;
LABEL_93:
      if ( (unsigned __int8)(v15 - 48) > 9u )
      {
        if ( v15 - 97 > 5 )
        {
          if ( v15 - 65 > 5 )
            goto LABEL_68;
          v38 = v15 - 55;
        }
        else
        {
          v38 = v15 - 87;
        }
      }
      else
      {
        v38 = v15 - 48;
      }
    }
    v44 = 1;
    goto LABEL_87;
  }
  if ( v19 )
  {
    v21 = 0;
    v30 = 0;
    v55 = 0LL;
    goto LABEL_45;
  }
  v21 = 0;
  v55 = 0LL;
  while ( !*(_BYTE *)(v13 + 16) || *(unsigned __int8 *)(v13 + 37) != v15 )
  {
    if ( *(unsigned __int8 *)(v13 + 36) == v15 )
      goto LABEL_68;
    v22 = (char *)memchr((const void *)(v13 + 78), v15, v20);
    if ( !v22 )
      goto LABEL_68;
    LODWORD(v23) = &v22[-v13 - 78];
    if ( (signed int)v23 > 15 )
      LODWORD(v23) = v23 - 6;
    if ( v57 >= v55 )
    {
      v23 = (signed int)v23;
      ++v56;
      if ( v58 - (signed int)v23 < v9 * v55 )
        LOBYTE(v21) = v21 | 1;
      v55 = v23 + v9 * v55;
      v21 = (unsigned __int8)v21;
    }
    else
    {
      v21 = 1;
    }
LABEL_33:
    v24 = v63;
    if ( !v63 )
      goto LABEL_61;
    v25 = v63[2];
    if ( v25 >= v63[3] )
    {
      (*(void (**)(void))(*v63 + 40))();
      v24 = v63;
      v64 = -1;
      if ( !v63 )
      {
LABEL_61:
        v28 = v59;
        goto LABEL_39;
      }
    }
    else
    {
      v64 = -1;
      v63[2] = v25 + 1;
    }
    v26 = (unsigned __int8 *)v24[2];
    if ( (unsigned int)v26 < v24[3] )
    {
      v27 = *v26;
LABEL_38:
      v28 = 0;
      v64 = v27;
      goto LABEL_39;
    }
    v27 = (*(int (**)(void))(*v24 + 36))();
    if ( v27 != -1 )
      goto LABEL_38;
    v28 = v59;
    v63 = 0;
LABEL_39:
    if ( !a5 )
    {
      v29 = v59;
      goto LABEL_43;
    }
    if ( a6 != -1 )
    {
      v29 = 0;
      goto LABEL_43;
    }
    v35 = (unsigned __int8 *)a5[2];
    if ( (unsigned int)v35 >= a5[3] )
    {
      v36 = (*(int (**)(void))(*a5 + 36))();
      if ( v36 == -1 )
      {
        a5 = 0;
        v29 = v59;
LABEL_43:
        if ( v29 == v28 )
          goto LABEL_44;
        goto LABEL_65;
      }
    }
    else
    {
      v36 = *v35;
    }
    a6 = v36;
    if ( !v28 )
      goto LABEL_44;
LABEL_65:
    v15 = (unsigned __int8)sub_9B0A0(&v63);
  }
  if ( v56 )
  {
    sub_C15D0((int *)&v66, v56);
    v56 = 0;
    goto LABEL_33;
  }
  v30 = 1;
LABEL_45:
  v31 = v66;
  if ( *(v66 - 3) )
  {
LABEL_69:
    sub_C15D0((int *)&v66, v56);
    v37 = sub_C303C(*(_DWORD *)(v13 + 8), *(_DWORD *)(v13 + 12), (unsigned __int8 **)&v66);
    v31 = v66;
    if ( !v37 )
      *a8 = 4;
  }
LABEL_46:
  if ( v56 )
    v32 = 0;
  else
    v32 = ((unsigned __int8)v61 ^ 1) & 1;
  if ( v32 && !*(v31 - 3) || v30 )
  {
    *a9 = 0LL;
    *a8 = 4;
  }
  else if ( v21 )
  {
    if ( v62 )
      *a9 = 0x8000000000000000LL;
    else
      *a9 = 0x7FFFFFFFFFFFFFFFLL;
    *a8 = 4;
  }
  else
  {
    v52 = v55;
    if ( v62 )
    {
      LODWORD(v52) = -(signed int)v55;
      HIDWORD(v52) = HIDWORD(v55) - (2 * HIDWORD(v55) + ((unsigned int)v55 > 0));
    }
    *a9 = v52;
  }
  if ( v19 )
    *a8 |= 2u;
  v33 = v64;
  *v60 = v63;
  v60[1] = v33;
  sub_C0AC4(v31 - 3);
  return v60;
}

//----- (0009FC80) --------------------------------------------------------
_DWORD *__fastcall sub_9FC80(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned __int64 *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9F668(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (0009FCBC) --------------------------------------------------------
_DWORD *__fastcall sub_9FCBC(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int64 *a9)
{
  signed int v9; // r7
  int v10; // r4
  int v11; // r0
  int v12; // r4
  int v13; // r9
  unsigned __int8 v14; // r0
  unsigned int v15; // r5
  unsigned int v16; // lr
  signed int v17; // r3
  _DWORD **v18; // r0
  signed int v19; // r6
  size_t v20; // r11
  signed int v21; // r7
  int v22; // r5
  __int64 v23; // r4
  _DWORD *v24; // r0
  unsigned int v25; // r3
  unsigned __int8 *v26; // r3
  int v27; // r0
  signed int v28; // r4
  signed int v29; // r3
  signed int v30; // r4
  _DWORD *v31; // r5
  int v32; // r3
  signed __int64 v33; // r2
  int v34; // r1
  unsigned __int8 *v36; // r3
  int v37; // r0
  signed int v38; // r0
  char *v39; // r0
  __int64 v40; // r0
  _DWORD *v41; // r0
  unsigned int v42; // r3
  unsigned __int8 *v43; // r3
  int v44; // r0
  int v45; // r4
  int v46; // r3
  unsigned __int8 *v47; // r3
  int v48; // r0
  int v49; // r6
  int v50; // r10
  signed int v51; // r4
  unsigned int v52; // r2
  signed __int64 v53; // r2
  int v54; // r4
  unsigned __int8 v55; // r0
  unsigned __int64 v56; // [sp+0h] [bp-78h]
  __int64 v57; // [sp+8h] [bp-70h]
  int v58; // [sp+14h] [bp-64h]
  unsigned __int64 v59; // [sp+18h] [bp-60h]
  int v60; // [sp+24h] [bp-54h]
  _DWORD *v61; // [sp+2Ch] [bp-4Ch]
  char v62; // [sp+30h] [bp-48h]
  int v63; // [sp+34h] [bp-44h]
  _DWORD *v64; // [sp+38h] [bp-40h]
  int v65; // [sp+3Ch] [bp-3Ch]
  char v66; // [sp+44h] [bp-34h]
  _DWORD *v67; // [sp+4Ch] [bp-2Ch]

  v10 = a7;
  v61 = a1;
  v64 = a3;
  v65 = a4;
  v11 = sub_9A83C((int)&v66, (int *)(a7 + 108));
  v12 = *(_DWORD *)(v10 + 12) & 0x4A;
  if ( v12 == 64 )
    v9 = 8;
  v13 = v11;
  if ( v12 != 64 )
  {
    if ( v12 == 8 )
      v9 = 16;
    else
      v9 = 10;
  }
  if ( sub_9B0DC(&v64, &a5) )
  {
    v15 = 0;
    v63 = 0;
  }
  else
  {
    v14 = sub_9B0A0(&v64);
    v15 = v14;
    v16 = *(unsigned __int8 *)(v13 + 74) - v14;
    v63 = v16 + (v16 <= 0) + v14 - *(unsigned __int8 *)(v13 + 74);
    if ( !v63 && *(unsigned __int8 *)(v13 + 75) != v14 )
    {
      v17 = *(unsigned __int8 *)(v13 + 16);
      goto LABEL_104;
    }
    v17 = *(unsigned __int8 *)(v13 + 16);
    if ( *(_BYTE *)(v13 + 16) && *(unsigned __int8 *)(v13 + 37) == v14 )
    {
      v17 = 1;
      goto LABEL_104;
    }
    if ( *(unsigned __int8 *)(v13 + 36) == v14 )
    {
LABEL_104:
      v49 = v12;
      v50 = 0;
      v51 = 0;
      while ( 1 )
      {
        if ( v17 && *(unsigned __int8 *)(v13 + 37) == v15 || *(unsigned __int8 *)(v13 + 36) == v15 )
        {
LABEL_141:
          v62 = v51;
          v19 = 0;
          v58 = v50;
          goto LABEL_13;
        }
        if ( *(unsigned __int8 *)(v13 + 78) == v15 )
        {
          v54 = v51 ^ 1;
          if ( v9 == 10 )
            v54 |= 1u;
          if ( v54 )
          {
            if ( v49 )
            {
              if ( v9 == 8 )
                v50 = 0;
              else
                ++v50;
              v51 = 1;
            }
            else
            {
              v50 = 0;
              v51 = 1;
              v9 = 8;
            }
            goto LABEL_115;
          }
        }
        else if ( !v51 )
        {
          goto LABEL_141;
        }
        if ( *(unsigned __int8 *)(v13 + 76) != v15 && *(unsigned __int8 *)(v13 + 77) != v15 )
        {
          v58 = v50;
          v19 = 0;
          v62 = 1;
          goto LABEL_13;
        }
        if ( v49 )
        {
          if ( v9 != 16 )
          {
            v58 = v50;
            v19 = 0;
            v62 = 1;
            goto LABEL_14;
          }
          v50 = 0;
          v51 = 0;
        }
        else
        {
          v50 = 0;
          v51 = 0;
          v9 = 16;
        }
LABEL_115:
        if ( v64 )
        {
          v52 = v64[2];
          if ( v52 >= v64[3] )
            (*(void (**)(void))(*v64 + 40))();
          else
            v64[2] = v52 + 1;
          v65 = -1;
        }
        if ( sub_9B0DC(&v64, &a5) )
        {
          v62 = v51;
          v58 = v50;
          v19 = 1;
          v17 = *(unsigned __int8 *)(v13 + 16);
          if ( v9 != 16 )
            goto LABEL_14;
          goto LABEL_121;
        }
        v15 = (unsigned __int8)sub_9B0A0(&v64);
        if ( !v51 )
        {
          v62 = 0;
          v19 = 0;
          v58 = v50;
          v17 = *(unsigned __int8 *)(v13 + 16);
          goto LABEL_13;
        }
        v17 = *(unsigned __int8 *)(v13 + 16);
      }
    }
    v18 = sub_9A76C(&v64);
    if ( !sub_9B0DC(v18, &a5) )
    {
      v55 = sub_9B0A0(&v64);
      v17 = *(unsigned __int8 *)(v13 + 16);
      v15 = v55;
      goto LABEL_104;
    }
  }
  v17 = *(unsigned __int8 *)(v13 + 16);
  v19 = 1;
  v58 = 0;
  v62 = 0;
LABEL_13:
  if ( v9 == 16 )
LABEL_121:
    v20 = 22;
  else
LABEL_14:
    v20 = v9;
  v67 = &unk_2FEF48;
  if ( v17 )
    sub_C1264(&v67, 0x20u);
  v57 = v9;
  v60 = *(unsigned __int8 *)(v13 + 100);
  v59 = 0xFFFFFFFFFFFFFFFFLL / v9;
  if ( !*(_BYTE *)(v13 + 100) )
  {
    if ( !v19 )
    {
      v21 = 0;
      v56 = 0LL;
      while ( 1 )
      {
        if ( v20 > 0xA )
        {
          if ( (unsigned __int8)(v15 - 48) > 9u )
          {
            if ( v15 - 97 > 5 )
            {
              if ( v15 - 65 > 5 )
                goto LABEL_67;
              v22 = v15 - 55;
            }
            else
            {
              v22 = v15 - 87;
            }
          }
          else
          {
            v22 = v15 - 48;
          }
        }
        else
        {
          if ( v15 <= 0x2F || (unsigned __int8)(v20 + 48) <= v15 )
            goto LABEL_67;
          v22 = v15 - 48;
        }
        if ( v59 >= v56 )
        {
          v23 = v22;
          ++v58;
          if ( ~v23 < v57 * v56 )
            LOBYTE(v21) = v21 | 1;
          v56 = v23 + v57 * v56;
          v21 = (unsigned __int8)v21;
        }
        else
        {
          v21 = 1;
        }
        v24 = v64;
        if ( !v64 )
          break;
        v25 = v64[2];
        if ( v25 >= v64[3] )
        {
          (*(void (**)(void))(*v64 + 40))();
          v24 = v64;
          v65 = -1;
          if ( !v64 )
            break;
        }
        else
        {
          v65 = -1;
          v64[2] = v25 + 1;
        }
        v26 = (unsigned __int8 *)v24[2];
        if ( (unsigned int)v26 < v24[3] )
        {
          v27 = *v26;
LABEL_34:
          v28 = 0;
          v65 = v27;
          goto LABEL_35;
        }
        v27 = (*(int (**)(void))(*v24 + 36))();
        if ( v27 != -1 )
          goto LABEL_34;
        v28 = 1;
        v64 = 0;
LABEL_35:
        if ( !a5 )
        {
          v29 = 1;
          goto LABEL_39;
        }
        if ( a6 != -1 )
        {
          v29 = 0;
          goto LABEL_39;
        }
        v36 = (unsigned __int8 *)a5[2];
        if ( (unsigned int)v36 >= a5[3] )
        {
          v37 = (*(int (**)(void))(*a5 + 36))();
          if ( v37 == -1 )
          {
            v29 = 1;
            a5 = 0;
LABEL_39:
            if ( v28 == v29 )
              goto LABEL_40;
            goto LABEL_66;
          }
        }
        else
        {
          v37 = *v36;
        }
        a6 = v37;
        if ( !v28 )
          goto LABEL_40;
LABEL_66:
        v15 = (unsigned __int8)sub_9B0A0(&v64);
      }
      v28 = 1;
      goto LABEL_35;
    }
    v21 = 0;
    v56 = 0LL;
    v30 = 0;
LABEL_41:
    v31 = v67;
    if ( *(v67 - 3) )
      goto LABEL_68;
    goto LABEL_42;
  }
  if ( v19 )
  {
    v21 = 0;
    v30 = 0;
    v56 = 0LL;
    goto LABEL_41;
  }
  v21 = 0;
  v56 = 0LL;
  while ( *(_BYTE *)(v13 + 16) && *(unsigned __int8 *)(v13 + 37) == v15 )
  {
    if ( !v58 )
    {
      v30 = 1;
      goto LABEL_41;
    }
    sub_C15D0((int *)&v67, v58);
    v58 = 0;
LABEL_83:
    v41 = v64;
    if ( !v64 )
      goto LABEL_96;
    v42 = v64[2];
    if ( v42 >= v64[3] )
    {
      (*(void (**)(void))(*v64 + 40))();
      v41 = v64;
      v65 = -1;
      if ( !v64 )
      {
LABEL_96:
        v45 = v60;
        goto LABEL_89;
      }
    }
    else
    {
      v65 = -1;
      v64[2] = v42 + 1;
    }
    v43 = (unsigned __int8 *)v41[2];
    if ( (unsigned int)v43 < v41[3] )
    {
      v44 = *v43;
LABEL_88:
      v45 = 0;
      v65 = v44;
      goto LABEL_89;
    }
    v44 = (*(int (**)(void))(*v41 + 36))();
    if ( v44 != -1 )
      goto LABEL_88;
    v45 = v60;
    v64 = 0;
LABEL_89:
    if ( a5 )
    {
      if ( a6 != -1 )
      {
        v46 = 0;
        goto LABEL_93;
      }
      v47 = (unsigned __int8 *)a5[2];
      if ( (unsigned int)v47 < a5[3] )
      {
        v48 = *v47;
LABEL_99:
        a6 = v48;
        v46 = 0;
        goto LABEL_93;
      }
      v48 = (*(int (**)(void))(*a5 + 36))();
      if ( v48 != -1 )
        goto LABEL_99;
      v46 = v60;
      a5 = 0;
    }
    else
    {
      v46 = v60;
    }
LABEL_93:
    if ( v46 == v45 )
    {
LABEL_40:
      v30 = 0;
      v19 = 1;
      goto LABEL_41;
    }
    v15 = (unsigned __int8)sub_9B0A0(&v64);
  }
  if ( *(unsigned __int8 *)(v13 + 36) != v15 )
  {
    v39 = (char *)memchr((const void *)(v13 + 78), v15, v20);
    if ( v39 )
    {
      LODWORD(v40) = &v39[-v13 - 78];
      if ( (signed int)v40 > 15 )
        LODWORD(v40) = v40 - 6;
      if ( v59 >= v56 )
      {
        v40 = (signed int)v40;
        ++v58;
        if ( ~(signed __int64)(signed int)v40 < v57 * v56 )
          LOBYTE(v21) = v21 | 1;
        v56 = v40 + v57 * v56;
        v21 = (unsigned __int8)v21;
      }
      else
      {
        v21 = 1;
      }
      goto LABEL_83;
    }
  }
LABEL_67:
  v31 = v67;
  v30 = 0;
  if ( !*(v67 - 3) )
    goto LABEL_42;
LABEL_68:
  sub_C15D0((int *)&v67, v58);
  v38 = sub_C303C(*(_DWORD *)(v13 + 8), *(_DWORD *)(v13 + 12), (unsigned __int8 **)&v67);
  v31 = v67;
  if ( !v38 )
    *a8 = 4;
LABEL_42:
  if ( v58 )
    v32 = 0;
  else
    v32 = ((unsigned __int8)v62 ^ 1) & 1;
  if ( v32 && !*(v31 - 3) || v30 )
  {
    v33 = 0LL;
    goto LABEL_48;
  }
  if ( v21 )
  {
    v33 = -1LL;
LABEL_48:
    *a9 = v33;
    *a8 = 4;
  }
  else
  {
    v53 = v56;
    if ( v63 )
    {
      LODWORD(v53) = -(signed int)v56;
      HIDWORD(v53) = HIDWORD(v56) - (2 * HIDWORD(v56) + ((unsigned int)v56 > 0));
    }
    *a9 = v53;
  }
  if ( v19 )
    *a8 |= 2u;
  v34 = v65;
  *v61 = v64;
  v61[1] = v34;
  sub_C0AC4(v31 - 3);
  return v61;
}

//----- (000A0260) --------------------------------------------------------
_DWORD *__fastcall sub_A0260(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int64 *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_9FCBC(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000A029C) --------------------------------------------------------
signed int __fastcall sub_A029C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  signed int result; // r0

  result = 3;
  *a5 = a3;
  *a8 = a6;
  return result;
}

//----- (000A02B0) --------------------------------------------------------
signed int __fastcall sub_A02B0(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // r0

  result = 3;
  *a5 = a3;
  return result;
}

//----- (000A02B8) --------------------------------------------------------
signed int __fastcall sub_A02B8(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  signed int result; // r0

  result = 3;
  *a5 = a3;
  *a8 = a6;
  return result;
}

//----- (000A02CC) --------------------------------------------------------
signed int sub_A02CC()
{
  return 1;
}

//----- (000A02D0) --------------------------------------------------------
signed int sub_A02D0()
{
  return 1;
}

//----- (000A02D4) --------------------------------------------------------
unsigned int __fastcall sub_A02D4(int a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int result; // r0
  unsigned int v6; // r3

  result = a5;
  v6 = a4 - a3;
  if ( v6 < a5 )
    result = v6;
  return result;
}

//----- (000A02E0) --------------------------------------------------------
signed int sub_A02E0()
{
  return 1;
}

//----- (000A02E4) --------------------------------------------------------
signed int __fastcall sub_A02E4(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  signed int result; // r0

  result = 3;
  *a5 = a3;
  return result;
}

//----- (000A02EC) --------------------------------------------------------
int sub_A02EC()
{
  return 0;
}

//----- (000A02F0) --------------------------------------------------------
_DWORD *__fastcall sub_A02F0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0EF0;
  sub_A8038(a1 + 2);
  *v1 = &off_F0B30;
  sub_AB124(v1);
  return v1;
}
// F0B30: using guessed type void *off_F0B30;
// F0EF0: using guessed type void *off_F0EF0;

//----- (000A0338) --------------------------------------------------------
void *__fastcall sub_A0338(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_A02F0(a1);
  operator delete(v1);
  return v1;
}

//----- (000A034C) --------------------------------------------------------
_DWORD *__fastcall sub_A034C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F0F30;
  sub_A8038(a1 + 2);
  *v1 = &off_F1A28;
  sub_AB124(v1);
  return v1;
}
// F0F30: using guessed type void *off_F0F30;
// F1A28: using guessed type void *;

//----- (000A0394) --------------------------------------------------------
void *__fastcall sub_A0394(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_A034C(a1);
  operator delete(v1);
  return v1;
}

//----- (000A03A8) --------------------------------------------------------
_DWORD *__fastcall sub_A03A8(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4

  v2 = a1;
  a1[1] = a2 != 0;
  *a1 = &off_F0EF0;
  a1[2] = sub_AB4B8();
  return v2;
}
// F0EF0: using guessed type void *;

//----- (000A0410) --------------------------------------------------------
_DWORD *__fastcall sub_A0410(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4

  v2 = a1;
  a1[1] = a2 != 0;
  *a1 = &off_F0F30;
  a1[2] = sub_AB4B8();
  return v2;
}
// F0F30: using guessed type void *;

//----- (000A0478) --------------------------------------------------------
_DWORD *__fastcall sub_A0478(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F0F7C;
  a1[2] = &off_F0690;
  sub_95E1C(a1 + 2);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0F7C: using guessed type void *off_F0F7C;

//----- (000A04A4) --------------------------------------------------------
_DWORD *__fastcall sub_A04A4(_DWORD *a1)
{
  return sub_A0478((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A04B0) --------------------------------------------------------
_DWORD *__fastcall sub_A04B0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F0FAC;
  a1[2] = &off_F06A0;
  sub_95E1C(a1 + 2);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0FAC: using guessed type void *off_F0FAC;

//----- (000A04DC) --------------------------------------------------------
_DWORD *__fastcall sub_A04DC(_DWORD *a1)
{
  return sub_A04B0((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A04E8) --------------------------------------------------------
void *__fastcall sub_A04E8(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F0F7C;
  a1[2] = &off_F0690;
  sub_95E1C(a1 + 2);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0F7C: using guessed type void *off_F0F7C;

//----- (000A051C) --------------------------------------------------------
void *__fastcall sub_A051C(_DWORD *a1)
{
  return sub_A04E8((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A0528) --------------------------------------------------------
void *__fastcall sub_A0528(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F0FAC;
  a1[2] = &off_F06A0;
  sub_95E1C(a1 + 2);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0FAC: using guessed type void *off_F0FAC;

//----- (000A055C) --------------------------------------------------------
void *__fastcall sub_A055C(_DWORD *a1)
{
  return sub_A0528((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A0718) --------------------------------------------------------
_BYTE *__fastcall sub_A0718(_BYTE *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r3
  signed int v5; // r1
  _BYTE *v6; // r6
  int v7; // r7
  _DWORD *v8; // r3
  int v9; // r5
  _DWORD *v10; // r0
  int v11; // r5
  unsigned __int8 *v12; // r2
  int v13; // r0
  int v14; // r7
  _BYTE *result; // r0
  unsigned int v16; // r3
  unsigned int v17; // r2
  _BYTE *v18; // r3
  int v19; // r0

  v3 = a2;
  v4 = *a2;
  v5 = 0;
  *a1 = 0;
  v6 = a1;
  v7 = a3;
  v8 = (_DWORD *)((char *)v3 + *(_DWORD *)(v4 - 12));
  v9 = v8[5];
  if ( v9 )
    goto LABEL_15;
  v10 = (_DWORD *)v8[28];
  if ( v10 )
  {
    sub_B66B0(v10);
    v8 = (_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12));
  }
  if ( !v7 && v8[3] & 0x1000 )
  {
    v11 = v8[30];
    v12 = *(unsigned __int8 **)(v11 + 8);
    if ( (unsigned int)v12 >= *(_DWORD *)(v11 + 12) )
    {
      v13 = sub_25E54(v8[30]);
      v8 = (_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12));
    }
    else
    {
      v13 = *v12;
    }
    v14 = v8[31];
    if ( !v14 )
      sub_BFA38();
    if ( v13 == -1 )
    {
LABEL_25:
      v9 = v8[5];
      v5 = 2;
      goto LABEL_15;
    }
    if ( *(_BYTE *)(*(_DWORD *)(v14 + 24) + (unsigned __int8)v13) & 8 )
    {
      while ( 1 )
      {
        v16 = *(_DWORD *)(v11 + 8);
        v17 = *(_DWORD *)(v11 + 12);
        if ( v16 >= v17 )
        {
          if ( sub_25E48(v11) == -1 )
            goto LABEL_24;
          v18 = *(_BYTE **)(v11 + 8);
          v17 = *(_DWORD *)(v11 + 12);
        }
        else
        {
          v18 = (_BYTE *)(v16 + 1);
          *(_DWORD *)(v11 + 8) = v18;
        }
        if ( (unsigned int)v18 >= v17 )
        {
          v19 = sub_25E54(v11);
          if ( v19 == -1 )
          {
LABEL_24:
            v8 = (_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12));
            goto LABEL_25;
          }
        }
        else
        {
          LOBYTE(v19) = *v18;
        }
        if ( !(*(_BYTE *)(*(_DWORD *)(v14 + 24) + (unsigned __int8)v19) & 8) )
        {
          v8 = (_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12));
          break;
        }
      }
    }
  }
  v9 = v8[5];
  if ( !v9 )
  {
    result = v6;
    *v6 = 1;
    return result;
  }
  v5 = 0;
LABEL_15:
  sub_93F84(v8, v5 | 4 | v9);
  return v6;
}

//----- (000A0C4C) --------------------------------------------------------
_DWORD *__fastcall sub_A0C4C(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  _DWORD *v4; // r5
  _BYTE *v5; // r8
  int v6; // r7
  int v7; // r9
  signed int v8; // r3
  int v9; // r6
  unsigned __int8 *v10; // r3
  int v11; // r0
  unsigned __int8 *v12; // r4
  unsigned int v13; // r3
  bool v14; // cf
  unsigned __int8 v16; // [sp+4h] [bp-24h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  a1[1] = 0;
  v7 = a4;
  sub_A0718(&v16, a1, 1);
  v8 = v16;
  if ( !v16 )
    goto LABEL_15;
  v9 = *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 120);
  v10 = *(unsigned __int8 **)(v9 + 8);
  if ( (unsigned int)v10 >= *(_DWORD *)(v9 + 12) )
    goto LABEL_24;
  v11 = *v10;
  while ( v4[1] + 1 < v6 )
  {
    if ( v11 == -1 )
      goto LABEL_14;
    if ( v11 == v7 )
      goto LABEL_21;
    *v5++ = v11;
    v12 = *(unsigned __int8 **)(v9 + 8);
    v13 = *(_DWORD *)(v9 + 12);
    v14 = (unsigned int)v12 >= v13;
    if ( (unsigned int)v12 < v13 )
      ++v12;
    ++v4[1];
    if ( v14 )
    {
      v11 = sub_25E48(v9);
      if ( v11 != -1 )
      {
        v12 = *(unsigned __int8 **)(v9 + 8);
        v13 = *(_DWORD *)(v9 + 12);
        goto LABEL_10;
      }
    }
    else
    {
      *(_DWORD *)(v9 + 8) = v12;
LABEL_10:
      if ( (unsigned int)v12 >= v13 )
LABEL_24:
        v11 = sub_25E54(v9);
      else
        v11 = *v12;
    }
  }
  if ( v11 == -1 )
  {
LABEL_14:
    v8 = 2;
    goto LABEL_15;
  }
LABEL_21:
  v8 = 0;
LABEL_15:
  if ( v6 > 0 )
    *v5 = 0;
  if ( !v4[1] )
  {
    v8 |= 4u;
    goto LABEL_19;
  }
  if ( !v8 )
    return v4;
LABEL_19:
  sub_93F84((_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12)), *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 20) | v8);
  return v4;
}

//----- (000A0DB4) --------------------------------------------------------
_DWORD *__fastcall sub_A0DB4(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // r7
  _DWORD *v4; // r4
  int v5; // r8
  signed int v6; // r3
  int v7; // r3
  int v9; // r5
  char *v10; // r3
  char v11; // r1
  int v12; // r6
  _BYTE *v13; // r2
  unsigned int v14; // r6
  bool v15; // cf
  char v16; // [sp+4h] [bp-1Ch]

  v3 = a1;
  a1[1] = 0;
  v4 = a2;
  v5 = a3;
  sub_A0718(&v16, a1, 1);
  if ( v16 )
  {
    v9 = *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 120);
    v10 = *(char **)(v9 + 8);
    if ( (unsigned int)v10 >= *(_DWORD *)(v9 + 12) )
      goto LABEL_17;
LABEL_7:
    v11 = *v10;
    v12 = (unsigned __int8)*v10;
    while ( v5 != v12 )
    {
      v13 = (_BYTE *)v4[5];
      if ( (unsigned int)v13 >= v4[6] )
      {
        if ( (*(int (__fastcall **)(_DWORD *))(*v4 + 52))(v4) == -1 )
        {
          if ( v12 != -1 )
            break;
LABEL_18:
          if ( !v3[1] )
          {
            v6 = 2;
            goto LABEL_3;
          }
          v7 = 2;
          goto LABEL_4;
        }
      }
      else
      {
        *v13 = v11;
        ++v4[5];
      }
      v10 = *(char **)(v9 + 8);
      v14 = *(_DWORD *)(v9 + 12);
      v15 = (unsigned int)v10 >= v14;
      if ( (unsigned int)v10 < v14 )
        ++v10;
      ++v3[1];
      if ( v15 )
      {
        if ( sub_25E48(v9) == -1 )
          goto LABEL_18;
        v10 = *(char **)(v9 + 8);
        v14 = *(_DWORD *)(v9 + 12);
      }
      else
      {
        *(_DWORD *)(v9 + 8) = v10;
      }
      if ( v14 > (unsigned int)v10 )
        goto LABEL_7;
LABEL_17:
      v12 = sub_25E54(v9);
      v11 = v12;
      if ( v12 == -1 )
        goto LABEL_18;
    }
  }
  v6 = v3[1];
  if ( !v6 )
  {
LABEL_3:
    v7 = v6 | 4;
LABEL_4:
    sub_93F84((_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12)), *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | v7);
  }
  return v3;
}

//----- (000A0F18) --------------------------------------------------------
_DWORD *__fastcall sub_A0F18(_DWORD *a1)
{
  _DWORD *v1; // r4
  _DWORD *result; // r0
  int v3; // r0
  unsigned int v4; // r3
  char v5; // [sp+4h] [bp-Ch]

  a1[1] = 0;
  v1 = a1;
  sub_A0718(&v5, a1, 1);
  if ( !v5 )
    return v1;
  v3 = *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 120);
  v4 = *(_DWORD *)(v3 + 8);
  if ( v4 >= *(_DWORD *)(v3 + 12) )
  {
    if ( sub_25E48(v3) == -1 )
    {
      sub_93F84(
        (_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12)),
        *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 20) | 2);
      return v1;
    }
  }
  else
  {
    *(_DWORD *)(v3 + 8) = v4 + 1;
  }
  result = v1;
  v1[1] = 1;
  return result;
}

//----- (000A2468) --------------------------------------------------------
_BYTE *__fastcall sub_A2468(_BYTE *a1, _DWORD *a2, int a3)
{
  int v3; // r3
  _DWORD *v4; // r6
  _BYTE *v5; // r7
  signed int v6; // r1
  int v7; // r4
  int v8; // r0
  int v9; // r3
  int v10; // r4
  int *v11; // r3
  int v12; // r5
  int v13; // r8
  _BYTE *result; // r0
  int *v15; // r3
  int v16; // r0
  int *v17; // r3

  v3 = *a2;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  *a1 = 0;
  v7 = a3;
  v8 = (int)v4 + *(_DWORD *)(v3 - 12);
  v9 = *(_DWORD *)(v8 + 20);
  if ( v9 )
    goto LABEL_12;
  if ( *(_DWORD *)(v8 + 112) )
  {
    sub_B7E9C(*(_DWORD **)(v8 + 112));
    v8 = (int)v4 + *(_DWORD *)(*v4 - 12);
  }
  if ( !v7 && *(_DWORD *)(v8 + 12) & 0x1000 )
  {
    v10 = *(_DWORD *)(v8 + 124);
    v11 = *(int **)(v10 + 8);
    if ( (unsigned int)v11 >= *(_DWORD *)(v10 + 12) )
    {
      v12 = sub_25E6C(*(_DWORD *)(v8 + 124));
      v8 = (int)v4 + *(_DWORD *)(*v4 - 12);
    }
    else
    {
      v12 = *v11;
    }
    v13 = *(_DWORD *)(v8 + 128);
    if ( !v13 )
      sub_BFA38();
    if ( v12 == -1 )
      goto LABEL_11;
    while ( (*(int (__fastcall **)(int, signed int, int))(*(_DWORD *)v13 + 8))(v13, 8, v12) )
    {
      v15 = *(int **)(v10 + 8);
      if ( (unsigned int)v15 >= *(_DWORD *)(v10 + 12) )
      {
        v16 = sub_25E60(v10);
      }
      else
      {
        v16 = *v15;
        *(_DWORD *)(v10 + 8) = v15 + 1;
      }
      if ( v16 != -1 )
      {
        v17 = *(int **)(v10 + 8);
        v12 = (unsigned int)v17 >= *(_DWORD *)(v10 + 12) ? sub_25E6C(v10) : *v17;
        if ( v12 != -1 )
          continue;
      }
      v8 = (int)v4 + *(_DWORD *)(*v4 - 12);
      goto LABEL_11;
    }
    v8 = (int)v4 + *(_DWORD *)(*v4 - 12);
    if ( v12 == -1 )
    {
LABEL_11:
      v9 = *(_DWORD *)(v8 + 20);
      v6 = 2;
LABEL_12:
      sub_94410((_DWORD *)v8, v6 | 4 | v9);
      return v5;
    }
  }
  v9 = *(_DWORD *)(v8 + 20);
  if ( v9 )
  {
    v6 = 0;
    goto LABEL_12;
  }
  result = v5;
  *v5 = 1;
  return result;
}

//----- (000A29B0) --------------------------------------------------------
_DWORD *__fastcall sub_A29B0(_DWORD *a1, int *a2, int a3, int a4)
{
  _DWORD *v4; // r6
  int *v5; // r8
  int v6; // r7
  int v7; // r9
  signed int v8; // r3
  int v9; // r4
  int *v10; // r3
  int v11; // r0
  int *v12; // r5
  unsigned int v13; // r2
  int *v14; // r5
  unsigned __int8 v16; // [sp+4h] [bp-24h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  a1[1] = 0;
  v7 = a4;
  sub_A2468(&v16, a1, 1);
  v8 = v16;
  if ( v16 )
  {
    v9 = *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 124);
    v10 = *(int **)(v9 + 8);
    if ( (unsigned int)v10 >= *(_DWORD *)(v9 + 12) )
      goto LABEL_23;
    v11 = *v10;
    while ( v4[1] + 1 < v6 )
    {
      if ( v11 == -1 )
        goto LABEL_13;
      if ( v7 == v11 )
        goto LABEL_20;
      v12 = *(int **)(v9 + 8);
      v13 = *(_DWORD *)(v9 + 12);
      *v5 = v11;
      ++v5;
      ++v4[1];
      if ( (unsigned int)v12 >= v13 )
      {
        v11 = sub_25E60(v9);
      }
      else
      {
        v11 = *v12;
        *(_DWORD *)(v9 + 8) = v12 + 1;
      }
      if ( v11 != -1 )
      {
        v14 = *(int **)(v9 + 8);
        if ( (unsigned int)v14 >= *(_DWORD *)(v9 + 12) )
LABEL_23:
          v11 = sub_25E6C(v9);
        else
          v11 = *v14;
      }
    }
    if ( v11 == -1 )
    {
LABEL_13:
      v8 = 2;
      goto LABEL_14;
    }
LABEL_20:
    v8 = 0;
  }
LABEL_14:
  if ( v6 > 0 )
    *v5 = 0;
  if ( !v4[1] )
  {
    v8 |= 4u;
LABEL_18:
    sub_94410((_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12)), *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 20) | v8);
    return v4;
  }
  if ( v8 )
    goto LABEL_18;
  return v4;
}

//----- (000A2B04) --------------------------------------------------------
_DWORD *__fastcall sub_A2B04(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // r7
  _DWORD *v4; // r6
  int v5; // r8
  signed int v6; // r3
  int v7; // r3
  int v9; // r4
  int *v10; // r3
  int *v11; // r3
  int *v12; // r3
  unsigned int v13; // r1
  int v14; // r0
  int i; // r5
  char v16; // [sp+4h] [bp-1Ch]

  v3 = a1;
  a1[1] = 0;
  v4 = a2;
  v5 = a3;
  sub_A2468(&v16, a1, 1);
  if ( v16 )
  {
    v9 = *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 124);
    v10 = *(int **)(v9 + 8);
    if ( (unsigned int)v10 < *(_DWORD *)(v9 + 12) )
      goto LABEL_16;
LABEL_21:
    for ( i = sub_25E6C(v9); i != -1; i = *v10 )
    {
      if ( v5 == i )
        goto LABEL_2;
      v11 = (int *)v4[5];
      if ( (unsigned int)v11 >= v4[6] )
      {
        if ( (*(int (__fastcall **)(_DWORD *, int))(*v4 + 52))(v4, i) == -1 )
        {
          if ( i != -1 )
            goto LABEL_2;
          break;
        }
      }
      else
      {
        *v11 = i;
        v4[5] = v11 + 1;
      }
      v12 = *(int **)(v9 + 8);
      v13 = *(_DWORD *)(v9 + 12);
      ++v3[1];
      if ( (unsigned int)v12 >= v13 )
      {
        v14 = sub_25E60(v9);
      }
      else
      {
        v14 = *v12;
        *(_DWORD *)(v9 + 8) = v12 + 1;
      }
      if ( v14 == -1 )
        break;
      v10 = *(int **)(v9 + 8);
      if ( (unsigned int)v10 >= *(_DWORD *)(v9 + 12) )
        goto LABEL_21;
LABEL_16:
      ;
    }
    if ( !v3[1] )
    {
      v6 = 2;
      goto LABEL_3;
    }
    v7 = 2;
    goto LABEL_4;
  }
LABEL_2:
  v6 = v3[1];
  if ( !v6 )
  {
LABEL_3:
    v7 = v6 | 4;
LABEL_4:
    sub_94410((_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12)), *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | v7);
  }
  return v3;
}

//----- (000A2C50) --------------------------------------------------------
_DWORD *__fastcall sub_A2C50(_DWORD *a1)
{
  _DWORD *v1; // r4
  _DWORD *result; // r0
  int v3; // r3
  int *v4; // r2
  int v5; // r0
  char v6; // [sp+4h] [bp-Ch]

  a1[1] = 0;
  v1 = a1;
  sub_A2468(&v6, a1, 1);
  if ( !v6 )
    return v1;
  v3 = *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 124);
  v4 = *(int **)(v3 + 8);
  if ( (unsigned int)v4 >= *(_DWORD *)(v3 + 12) )
  {
    v5 = sub_25E60(*(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 124));
  }
  else
  {
    v5 = *v4;
    *(_DWORD *)(v3 + 8) = v4 + 1;
  }
  if ( v5 == -1 )
  {
    sub_94410((_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12)), *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 20) | 2);
    result = v1;
  }
  else
  {
    result = v1;
    v1[1] = 1;
  }
  return result;
}

//----- (000A4190) --------------------------------------------------------
int __fastcall sub_A4190(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r0

  if ( !(a1[8] & 8) )
    return -1;
  v1 = a1[5];
  if ( !v1 )
    return a1[3] - a1[2];
  v2 = a1[3];
  if ( v1 > v2 )
    a1[3] = v1;
  v3 = a1[2];
  if ( v1 <= v2 )
    v1 = v2;
  return v1 - v3;
}

//----- (000A41BC) --------------------------------------------------------
signed int __fastcall sub_A41BC(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned __int8 *v2; // r2
  signed int result; // r0

  if ( a1[8] & 8
    && ((v1 = a1[5]) == 0 ? (v1 = a1[3]) : v1 <= a1[3] ? (v1 = a1[3]) : (a1[3] = v1),
        v2 = (unsigned __int8 *)a1[2],
        (unsigned int)v2 < v1) )
  {
    result = *v2;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (000A41E4) --------------------------------------------------------
signed int __fastcall sub_A41E4(int a1, int a2)
{
  unsigned int v2; // r2
  int v3; // r3
  unsigned int v4; // r12
  int v5; // r0
  signed int result; // r0

  v2 = *(_DWORD *)(a1 + 8);
  v3 = a1;
  if ( *(_DWORD *)(a1 + 4) >= v2 )
    return -1;
  if ( a2 != -1 )
  {
    v4 = *(unsigned __int8 *)(v2 - 1) - (unsigned __int8)a2;
    v5 = v4 + (v4 <= 0) + (unsigned __int8)a2 - *(unsigned __int8 *)(v2 - 1);
    if ( (*(_DWORD *)(v3 + 32) >> 4) & 1 | v5 )
    {
      *(_DWORD *)(v3 + 8) = v2 - 1;
      if ( !v5 )
        *(_BYTE *)(v2 - 1) = a2;
      return a2;
    }
    return -1;
  }
  result = 0;
  *(_DWORD *)(v3 + 8) = v2 - 1;
  return result;
}

//----- (000A4234) --------------------------------------------------------
signed int __fastcall sub_A4234(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r0

  if ( !(a1[8] & 8) )
    return -1;
  v1 = a1[5];
  if ( !v1 )
    return (a1[3] - a1[2]) >> 2;
  v2 = a1[3];
  if ( v1 > v2 )
    a1[3] = v1;
  v3 = a1[2];
  if ( v1 <= v2 )
    v1 = v2;
  return (signed int)(v1 - v3) >> 2;
}

//----- (000A4264) --------------------------------------------------------
signed int __fastcall sub_A4264(_DWORD *a1, int a2)
{
  unsigned int v2; // r3
  _BOOL4 v4; // r2

  v2 = a1[2];
  if ( a1[1] >= v2 )
    return -1;
  if ( a2 == -1 )
  {
    a2 = 0;
    a1[2] = v2 - 4;
    return a2;
  }
  v4 = (unsigned int)(*(_DWORD *)(v2 - 4) - a2) <= 0;
  if ( !((a1[8] >> 4) & 1 | v4) )
    return -1;
  a1[2] = v2 - 4;
  if ( !v4 )
    *(_DWORD *)(v2 - 4) = a2;
  return a2;
}

//----- (000A42B0) --------------------------------------------------------
signed int __fastcall sub_A42B0(_DWORD *a1)
{
  signed int result; // r0
  unsigned int v2; // r3
  signed int *v3; // r2

  if ( a1[8] & 8
    && ((v2 = a1[5]) == 0 ? (v2 = a1[3]) : v2 <= a1[3] ? (v2 = a1[3]) : (a1[3] = v2),
        v3 = (signed int *)a1[2],
        (unsigned int)v3 < v2) )
  {
    result = *v3;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (000A42D8) --------------------------------------------------------
int __fastcall sub_A42D8(int a1)
{
  int v1; // r2
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 36);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)v2 = &off_F0818;
  sub_AB620((unsigned int **)(v2 + 28));
  return v2;
}
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4340) --------------------------------------------------------
int __fastcall sub_A4340(int a1)
{
  int v1; // r2
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 36);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)v2 = &off_F0858;
  sub_AB620((unsigned int **)(v2 + 28));
  return v2;
}
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *;

//----- (000A43A8) --------------------------------------------------------
unsigned int **__fastcall sub_A43A8(unsigned int **a1)
{
  unsigned int *v1; // r2
  unsigned int **v2; // r4
  unsigned int *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = a1[9];
  v2 = a1;
  v3 = v1 - 3;
  *v2 = (unsigned int *)&off_F1000;
  if ( v1 - 3 != (unsigned int *)&dword_2FEF3C )
  {
    v5 = v1 - 1;
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *v2 = (unsigned int *)&off_F0818;
  sub_AB620(v2 + 7);
  operator delete(v2);
  return v2;
}
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4418) --------------------------------------------------------
unsigned int **__fastcall sub_A4418(unsigned int **a1)
{
  unsigned int *v1; // r2
  unsigned int **v2; // r4
  unsigned int *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = a1[9];
  v2 = a1;
  v3 = v1 - 3;
  *v2 = (unsigned int *)&off_F11F8;
  if ( v1 - 3 != (unsigned int *)&unk_2FEF24 )
  {
    v5 = v1 - 1;
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *v2 = (unsigned int *)&off_F0858;
  sub_AB620(v2 + 7);
  operator delete(v2);
  return v2;
}
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;

//----- (000A4488) --------------------------------------------------------
int __fastcall sub_A4488(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 40);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F12D4;
  *(_DWORD *)(v2 + 44) = &off_F12E8;
  *(_DWORD *)(v2 + 4) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 4) = &off_F0858;
  sub_AB620((unsigned int **)(v2 + 32));
  *(_DWORD *)v2 = &off_F129C;
  *(_DWORD *)(v2 + 44) = &off_F06A0;
  sub_95E1C((_DWORD *)(v2 + 44));
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F129C: using guessed type void *off_F129C;
// F12D4: using guessed type void *off_F12D4;
// F12E8: using guessed type void *off_F12E8;

//----- (000A4528) --------------------------------------------------------
int __fastcall sub_A4528(_DWORD *a1)
{
  return sub_A4488((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A4534) --------------------------------------------------------
int __fastcall sub_A4534(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 40);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F10DC;
  *(_DWORD *)(v2 + 44) = &off_F10F0;
  *(_DWORD *)(v2 + 4) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 4) = &off_F0818;
  sub_AB620((unsigned int **)(v2 + 32));
  *(_DWORD *)v2 = &off_F10A4;
  *(_DWORD *)(v2 + 44) = &off_F0690;
  sub_95E1C((_DWORD *)(v2 + 44));
  return v2;
}
// F0690: using guessed type void *;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *;
// F10A4: using guessed type void *off_F10A4;
// F10DC: using guessed type void *off_F10DC;
// F10F0: using guessed type void *off_F10F0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A45D4) --------------------------------------------------------
int __fastcall sub_A45D4(_DWORD *a1)
{
  return sub_A4534((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A45E0) --------------------------------------------------------
int __fastcall sub_A45E0(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 44);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F107C;
  *(_DWORD *)(v2 + 48) = &off_F1090;
  *(_DWORD *)(v2 + 8) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 8) = &off_F0818;
  sub_AB620((unsigned int **)(v2 + 36));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_F1044;
  *(_DWORD *)(v2 + 48) = &off_F0690;
  sub_95E1C((_DWORD *)(v2 + 48));
  return v2;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F1044: using guessed type void *off_F1044;
// F107C: using guessed type void *off_F107C;
// F1090: using guessed type void *off_F1090;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4684) --------------------------------------------------------
int __fastcall sub_A4684(_DWORD *a1)
{
  return sub_A45E0((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A4690) --------------------------------------------------------
int __fastcall sub_A4690(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 44);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F1274;
  *(_DWORD *)(v2 + 48) = &off_F1288;
  *(_DWORD *)(v2 + 8) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 8) = &off_F0858;
  sub_AB620((unsigned int **)(v2 + 36));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_F123C;
  *(_DWORD *)(v2 + 48) = &off_F06A0;
  sub_95E1C((_DWORD *)(v2 + 48));
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F123C: using guessed type void *off_F123C;
// F1274: using guessed type void *off_F1274;
// F1288: using guessed type void *off_F1288;

//----- (000A4734) --------------------------------------------------------
int __fastcall sub_A4734(_DWORD *a1)
{
  return sub_A4690((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A4740) --------------------------------------------------------
void *__fastcall sub_A4740(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[10];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F10DC;
  *((_DWORD *)v2 + 11) = &off_F10F0;
  *((_DWORD *)v2 + 1) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 1) = &off_F0818;
  sub_AB620((unsigned int **)v2 + 8);
  *(_DWORD *)v2 = &off_F10A4;
  *((_DWORD *)v2 + 11) = &off_F0690;
  sub_95E1C((_DWORD *)v2 + 11);
  operator delete(v2);
  return v2;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F10A4: using guessed type void *off_F10A4;
// F10DC: using guessed type void *off_F10DC;
// F10F0: using guessed type void *off_F10F0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A47E4) --------------------------------------------------------
void *__fastcall sub_A47E4(_DWORD *a1)
{
  return sub_A4740((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A47F0) --------------------------------------------------------
void *__fastcall sub_A47F0(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[10];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F12D4;
  *((_DWORD *)v2 + 11) = &off_F12E8;
  *((_DWORD *)v2 + 1) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 1) = &off_F0858;
  sub_AB620((unsigned int **)v2 + 8);
  *(_DWORD *)v2 = &off_F129C;
  *((_DWORD *)v2 + 11) = &off_F06A0;
  sub_95E1C((_DWORD *)v2 + 11);
  operator delete(v2);
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F129C: using guessed type void *off_F129C;
// F12D4: using guessed type void *off_F12D4;
// F12E8: using guessed type void *off_F12E8;

//----- (000A4894) --------------------------------------------------------
void *__fastcall sub_A4894(_DWORD *a1)
{
  return sub_A47F0((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A48A0) --------------------------------------------------------
void *__fastcall sub_A48A0(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[11];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F107C;
  *((_DWORD *)v2 + 12) = &off_F1090;
  *((_DWORD *)v2 + 2) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 2) = &off_F0818;
  sub_AB620((unsigned int **)v2 + 9);
  *((_DWORD *)v2 + 1) = 0;
  *(_DWORD *)v2 = &off_F1044;
  *((_DWORD *)v2 + 12) = &off_F0690;
  sub_95E1C((_DWORD *)v2 + 12);
  operator delete(v2);
  return v2;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F1044: using guessed type void *off_F1044;
// F107C: using guessed type void *off_F107C;
// F1090: using guessed type void *off_F1090;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4948) --------------------------------------------------------
void *__fastcall sub_A4948(_DWORD *a1)
{
  return sub_A48A0((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A4954) --------------------------------------------------------
void *__fastcall sub_A4954(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[11];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F1274;
  *((_DWORD *)v2 + 12) = &off_F1288;
  *((_DWORD *)v2 + 2) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 2) = &off_F0858;
  sub_AB620((unsigned int **)v2 + 9);
  *((_DWORD *)v2 + 1) = 0;
  *(_DWORD *)v2 = &off_F123C;
  *((_DWORD *)v2 + 12) = &off_F06A0;
  sub_95E1C((_DWORD *)v2 + 12);
  operator delete(v2);
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F123C: using guessed type void *off_F123C;
// F1274: using guessed type void *off_F1274;
// F1288: using guessed type void *off_F1288;

//----- (000A49FC) --------------------------------------------------------
void *__fastcall sub_A49FC(_DWORD *a1)
{
  return sub_A4954((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A4A08) --------------------------------------------------------
int __fastcall sub_A4A08(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 48);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F11BC;
  *(_DWORD *)(v2 + 52) = &off_F11E4;
  *(_DWORD *)(v2 + 8) = &off_F11D0;
  *(_DWORD *)(v2 + 12) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 12) = &off_F0818;
  sub_AB620((unsigned int **)(v2 + 40));
  *(_DWORD *)(v2 + 8) = &off_F1104;
  *(_DWORD *)v2 = &off_F112C;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 52) = &off_F0690;
  sub_95E1C((_DWORD *)(v2 + 52));
  return v2;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F1104: using guessed type void *off_F1104;
// F112C: using guessed type void *off_F112C;
// F11BC: using guessed type void *off_F11BC;
// F11D0: using guessed type void *off_F11D0;
// F11E4: using guessed type void *off_F11E4;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4AC4) --------------------------------------------------------
int __fastcall sub_A4AC4(_DWORD *a1)
{
  return sub_A4A08((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A4AD0) --------------------------------------------------------
int __fastcall sub_A4AD0(int a1)
{
  int v1; // r1
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = *(_DWORD *)(a1 + 48);
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F13B4;
  *(_DWORD *)(v2 + 52) = &off_F13DC;
  *(_DWORD *)(v2 + 8) = &off_F13C8;
  *(_DWORD *)(v2 + 12) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *(_DWORD *)(v2 + 12) = &off_F0858;
  sub_AB620((unsigned int **)(v2 + 40));
  *(_DWORD *)(v2 + 8) = &off_F12FC;
  *(_DWORD *)v2 = &off_F1324;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 52) = &off_F06A0;
  sub_95E1C((_DWORD *)(v2 + 52));
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F12FC: using guessed type void *off_F12FC;
// F1324: using guessed type void *off_F1324;
// F13B4: using guessed type void *off_F13B4;
// F13C8: using guessed type void *off_F13C8;
// F13DC: using guessed type void *off_F13DC;

//----- (000A4B8C) --------------------------------------------------------
int __fastcall sub_A4B8C(_DWORD *a1)
{
  return sub_A4AD0((int)a1 + *(_DWORD *)(*a1 - 12));
}

//----- (000A4B98) --------------------------------------------------------
void *__fastcall sub_A4B98(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[12];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F11BC;
  *((_DWORD *)v2 + 13) = &off_F11E4;
  *((_DWORD *)v2 + 2) = &off_F11D0;
  *((_DWORD *)v2 + 3) = &off_F1000;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 3) = &off_F0818;
  sub_AB620((unsigned int **)v2 + 10);
  *((_DWORD *)v2 + 2) = &off_F1104;
  *(_DWORD *)v2 = &off_F112C;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 13) = &off_F0690;
  sub_95E1C((_DWORD *)v2 + 13);
  operator delete(v2);
  return v2;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F1104: using guessed type void *off_F1104;
// F112C: using guessed type void *off_F112C;
// F11BC: using guessed type void *off_F11BC;
// F11D0: using guessed type void *off_F11D0;
// F11E4: using guessed type void *off_F11E4;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4C5C) --------------------------------------------------------
void *__fastcall sub_A4C5C(_DWORD *a1)
{
  return sub_A4B98((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A4C68) --------------------------------------------------------
void *__fastcall sub_A4C68(_DWORD *a1)
{
  int v1; // r1
  void *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r1
  signed int v6; // r3

  v1 = a1[12];
  v2 = a1;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F13B4;
  *((_DWORD *)v2 + 13) = &off_F13DC;
  *((_DWORD *)v2 + 2) = &off_F13C8;
  *((_DWORD *)v2 + 3) = &off_F11F8;
  if ( (_UNKNOWN *)(v1 - 12) != &unk_2FEF24 )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  *((_DWORD *)v2 + 3) = &off_F0858;
  sub_AB620((unsigned int **)v2 + 10);
  *((_DWORD *)v2 + 2) = &off_F12FC;
  *(_DWORD *)v2 = &off_F1324;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 13) = &off_F06A0;
  sub_95E1C((_DWORD *)v2 + 13);
  operator delete(v2);
  return v2;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F11F8: using guessed type void *off_F11F8;
// F12FC: using guessed type void *off_F12FC;
// F1324: using guessed type void *off_F1324;
// F13B4: using guessed type void *off_F13B4;
// F13C8: using guessed type void *off_F13C8;
// F13DC: using guessed type void *off_F13DC;

//----- (000A4D2C) --------------------------------------------------------
void *__fastcall sub_A4D2C(_DWORD *a1)
{
  return sub_A4C68((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000A4D80) --------------------------------------------------------
_DWORD *__fastcall sub_A4D80(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  _BYTE *v3; // r3
  _BYTE *v4; // r0
  char *v5; // r0
  unsigned int *v7; // r3
  signed int v8; // r2
  unsigned int *v9; // r3
  char *v10; // [sp+Ch] [bp-14h]

  v2 = a1;
  v3 = *(_BYTE **)(a2 + 20);
  *a1 = &unk_2FEF48;
  if ( !v3 )
  {
    sub_C1700(a1, (_DWORD *)(a2 + 36));
    return v2;
  }
  v4 = *(_BYTE **)(a2 + 16);
  if ( (unsigned int)v3 > *(_DWORD *)(a2 + 12) )
  {
    v10 = (char *)sub_C1870(v4, v3);
    sub_C1700(v2, &v10);
    v5 = v10 - 12;
    if ( v10 - 12 == (char *)&dword_2FEF3C )
      return v2;
    v7 = (unsigned int *)(v10 - 4);
    __dmb(0xFu);
    do
      v8 = __ldrex(v7);
    while ( __strex(v8 - 1, v7) );
  }
  else
  {
    v10 = (char *)sub_C1870(v4, *(_BYTE **)(a2 + 12));
    sub_C1700(v2, &v10);
    v5 = v10 - 12;
    if ( v10 - 12 == (char *)&dword_2FEF3C )
      return v2;
    v9 = (unsigned int *)(v10 - 4);
    __dmb(0xFu);
    do
      v8 = __ldrex(v9);
    while ( __strex(v8 - 1, v9) );
  }
  __dmb(0xFu);
  if ( v8 <= 0 )
    operator delete(v5);
  return v2;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A4E70) --------------------------------------------------------
_DWORD *__fastcall sub_A4E70(_DWORD *result, int a2, int a3, int a4, signed __int64 a5)
{
  signed __int64 v5; // r4

  v5 = a5;
  result[6] = a3;
  result[5] = a2;
  for ( result[4] = a2; v5 > 0x7FFFFFFF; a2 += 0x7FFFFFFF )
    v5 -= 0x7FFFFFFFLL;
  result[5] = v5 + a2;
  return result;
}

//----- (000A4EB0) --------------------------------------------------------
_DWORD *__fastcall sub_A4EB0(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  _DWORD *v4; // r4
  _DWORD *result; // r0
  bool v6; // zf
  int v7; // r7
  int v8; // r6
  int v9; // r5

  v4 = a1;
  result = (_DWORD *)a1[9];
  v6 = a2 == (_DWORD)result;
  v7 = (v4[8] >> 3) & 1;
  v8 = v4[8] & 0x10;
  v9 = *(result - 3) + a2;
  if ( (_DWORD *)a2 == result )
    result = (_DWORD *)(a2 + *(result - 2));
  else
    v9 += a3;
  if ( !v6 )
  {
    a3 = 0;
    result = (_DWORD *)v9;
  }
  if ( v7 )
  {
    v4[1] = a2;
    v4[2] = a3 + a2;
    v4[3] = v9;
  }
  if ( v8 )
  {
    result = sub_A4E70(v4, a2, (int)result, 0, a4);
    if ( !v7 )
    {
      v4[1] = v9;
      v4[2] = v9;
      v4[3] = v9;
    }
  }
  return result;
}

//----- (000A4F20) --------------------------------------------------------
_DWORD *__fastcall sub_A4F20(_DWORD *a1, signed int a2, int a3)
{
  signed int v3; // r3
  int v4; // r5
  int v5; // r6
  _DWORD *v6; // r4

  v3 = a2;
  if ( a2 )
    v3 = 1;
  v4 = a3;
  if ( a3 < 0 )
    v3 = 0;
  v5 = a2;
  v6 = a1;
  if ( v3 )
  {
    sub_C0AFC(a1 + 9, 0, *(_DWORD *)(a1[9] - 12), 0);
    sub_A4EB0(v6, v5, v4, 0);
  }
  return v6;
}

//----- (000A4F58) --------------------------------------------------------
signed int __fastcall sub_A4F58(_DWORD *a1, signed int a2)
{
  _DWORD *v2; // r4
  signed int v3; // r5
  unsigned int v4; // r1
  _BYTE *v5; // r3
  _BYTE *v6; // r2
  int v7; // r0
  bool v8; // zf
  unsigned int v9; // r0
  _BYTE *v10; // r1
  _BYTE *v11; // r3
  int v12; // r2
  int v13; // r9
  _DWORD *v14; // r3
  char *v15; // r0
  unsigned int *v16; // r3
  signed int v17; // r2
  signed int result; // r0
  char *v19; // [sp+4h] [bp-24h]

  v2 = a1;
  v3 = a2;
  if ( !(a1[8] & 0x10) )
    return -1;
  if ( a2 == -1 )
    return 0;
  v4 = 1073741820;
  v5 = (_BYTE *)a1[5];
  v6 = (_BYTE *)a1[6];
  v7 = *(_DWORD *)(a1[9] - 8);
  v8 = v5 == v6;
  if ( v5 >= v6 )
    v8 = v7 == 1073741820;
  if ( v8 )
    return -1;
  if ( v5 < v6 )
  {
    *v5 = v3;
  }
  else
  {
    v9 = 2 * v7;
    if ( v9 >= 0x200 )
    {
      if ( v9 <= 0x3FFFFFFC )
        v4 = v9;
    }
    else
    {
      v4 = 512;
    }
    v19 = (char *)&unk_2FEF48;
    sub_C1264(&v19, v4);
    v10 = (_BYTE *)v2[4];
    if ( v10 )
      sub_C0F20((int *)&v19, v10, v2[6] - (_DWORD)v10);
    v11 = v19;
    v12 = *((_DWORD *)v19 - 3);
    v13 = v12 + 1;
    if ( (unsigned int)(v12 + 1) > *((_DWORD *)v19 - 2) || *((_DWORD *)v19 - 1) > 0 )
    {
      sub_C1264(&v19, v12 + 1);
      v11 = v19;
      v12 = *((_DWORD *)v19 - 3);
    }
    v11[v12] = v3;
    v14 = v19;
    if ( v19 - 12 != (char *)&dword_2FEF3C )
    {
      *((_DWORD *)v19 - 3) = v13;
      *(v14 - 1) = 0;
      *((_BYTE *)v14 + v13) = 0;
    }
    sub_C0480(v2 + 9, (int *)&v19);
    sub_A4EB0(v2, v2[9], v2[2] - v2[1], v2[5] - v2[4]);
    v15 = v19 - 12;
    if ( v19 - 12 != (char *)&dword_2FEF3C )
    {
      v16 = (unsigned int *)(v19 - 4);
      __dmb(0xFu);
      do
        v17 = __ldrex(v16);
      while ( __strex(v17 - 1, v16) );
      __dmb(0xFu);
      if ( v17 <= 0 )
        operator delete(v15);
    }
  }
  result = v3;
  ++v2[5];
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000A5150) --------------------------------------------------------
signed __int64 *__fastcall sub_A5150(int a1, _DWORD *a2, signed __int64 a3, int a4, unsigned __int8 a5)
{
  int v5; // r7
  int v6; // r9
  _BOOL4 v7; // r5
  _BOOL4 v8; // r12
  signed __int64 *v9; // r6
  int v10; // r7
  int v11; // r5
  int v12; // r0
  _BOOL4 v13; // r4
  int v14; // r12
  unsigned int v15; // r8
  signed __int64 v16; // r8
  int v17; // r4

  v5 = a2[8];
  v6 = a2[8] & 8;
  *(_QWORD *)a1 = -1LL;
  v7 = (a5 & v5 & 8) != 0;
  v8 = (v5 & 0x10 & a5) != 0;
  v9 = (signed __int64 *)a1;
  v10 = v8 && v7;
  *(_DWORD *)(a1 + 8) = 0;
  if ( v8 && v7 )
  {
    v10 = a4 - 1;
    if ( a4 != 1 )
      v10 = 1;
  }
  if ( a5 & 0x10 )
    v11 = 0;
  else
    v11 = v7;
  if ( v11 )
    v12 = a2[1];
  else
    v12 = a2[4];
  v13 = a3 == 0;
  if ( v12 )
    v13 = 1;
  if ( !v13 )
    return v9;
  if ( a5 & 8 )
    v14 = 0;
  else
    v14 = v8;
  if ( v14 | v11 || v10 )
  {
    v15 = a2[5];
    if ( v15 && v15 > a2[3] )
    {
      if ( !v6 )
      {
        a2[1] = v15;
        a2[2] = v15;
      }
      a2[3] = v15;
    }
    if ( a4 == 1 )
    {
      v16 = a3 + (signed int)(v15 - v12);
      a3 += a2[2] - v12;
    }
    else
    {
      if ( a4 == 2 )
        a3 += a2[3] - v12;
      v16 = a3;
    }
    if ( v11 | v10 && a3 >= 0 && a2[3] - v12 >= a3 )
    {
      v17 = a2[1];
      *v9 = a3;
      a2[2] = a3 + v17;
    }
    if ( v10 | v14 && v16 >= 0 && a2[3] - v12 >= v16 )
    {
      sub_A4E70(a2, a2[4], a2[6], a2[4], v16);
      *v9 = v16;
    }
    return v9;
  }
  return v9;
}

//----- (000A52B0) --------------------------------------------------------
int __fastcall sub_A52B0(int a1, _DWORD *a2, signed __int64 a3, int a4, int a5, int a6)
{
  int v6; // r5
  int v7; // r6
  int v8; // r12
  _BOOL4 v9; // r0
  _BOOL4 v10; // r7
  signed __int64 v11; // r4
  int v12; // r3
  unsigned int v13; // r8
  signed __int64 v15; // [sp+20h] [bp-8h]

  v6 = a2[8];
  v7 = a1;
  v8 = a2[8] & 8;
  v15 = a3;
  v9 = ((unsigned __int8)a6 & v6 & 8) != 0;
  v10 = (v6 & 0x10 & (unsigned __int8)a6) != 0;
  *(_QWORD *)v7 = -1LL;
  v11 = a3;
  *(_DWORD *)(v7 + 8) = 0;
  if ( (a6 & v8) != 0 )
  {
    v12 = a2[1];
    if ( v12 )
      goto LABEL_3;
  }
  else
  {
    v12 = a2[4];
    if ( v12 )
      goto LABEL_3;
  }
  if ( v15 )
    return v7;
LABEL_3:
  if ( v10 || v9 )
  {
    v13 = a2[5];
    if ( v13 && v13 > a2[3] )
    {
      if ( !v8 )
      {
        a2[1] = v13;
        a2[2] = v13;
      }
      a2[3] = v13;
    }
    if ( v11 >= 0 && a2[3] - v12 >= v11 )
    {
      if ( (a6 & v8) != 0 )
      {
        a2[2] = a2[1] + v11;
        if ( !v10 )
          goto LABEL_13;
      }
      else if ( !v10 )
      {
LABEL_13:
        *(_QWORD *)v7 = v15;
        *(_DWORD *)(v7 + 8) = a4;
        return v7;
      }
      sub_A4E70(a2, a2[4], a2[6], a2[4], v11);
      goto LABEL_13;
    }
  }
  return v7;
}

//----- (000A5960) --------------------------------------------------------
int __fastcall sub_A5960(int a1, int a2)
{
  unsigned int **v2; // r5
  int v3; // r4
  int v4; // r7

  v2 = (unsigned int **)(a1 + 44);
  v3 = a1;
  v4 = a2;
  sub_95C00((_DWORD *)(a1 + 44));
  *(_DWORD *)(v3 + 156) = 0;
  *(_BYTE *)(v3 + 160) = 0;
  *(_DWORD *)v3 = &off_F10A4;
  *(_DWORD *)(v3 + 44) = &off_F10B8;
  *(_BYTE *)(v3 + 161) = 0;
  *(_DWORD *)(v3 + 164) = 0;
  *(_DWORD *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 172) = 0;
  *(_DWORD *)(v3 + 176) = 0;
  sub_941F4(v2, 0);
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 4) = &off_F0818;
  *(_DWORD *)v3 = &off_F10DC;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 44) = &off_F10F0;
  sub_A93A8((_DWORD *)(v3 + 32));
  *(_DWORD *)(v3 + 36) = v4 | 0x10;
  *(_DWORD *)(v3 + 40) = &unk_2FEF48;
  *(_DWORD *)(v3 + 4) = &off_F1000;
  sub_941F4(v2, v3 + 4);
  return v3;
}
// F0818: using guessed type void *off_F0818;
// F1000: using guessed type void *off_F1000;
// F10A4: using guessed type void *off_F10A4;
// F10B8: using guessed type void *off_F10B8;
// F10DC: using guessed type void *off_F10DC;
// F10F0: using guessed type void *off_F10F0;

//----- (000A6554) --------------------------------------------------------
_DWORD *__fastcall sub_A6554(_DWORD *result, int a2, int a3, int a4, signed __int64 a5)
{
  signed __int64 v5; // r4
  int v6; // r1
  int v7; // r12

  v5 = a5;
  result[6] = a3;
  result[5] = a2;
  result[4] = a2;
  if ( a5 <= 0x7FFFFFFF )
  {
    v7 = a2;
  }
  else
  {
    v6 = a2 - 4;
    do
    {
      v7 = v6;
      v5 -= 0x7FFFFFFFLL;
      v6 -= 4;
    }
    while ( v5 > 0x7FFFFFFF );
  }
  result[5] = v7 + 4 * v5;
  return result;
}

//----- (000A65A0) --------------------------------------------------------
_DWORD *__fastcall sub_A65A0(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  _DWORD *v4; // r4
  _DWORD *result; // r0
  bool v6; // zf
  int v7; // r7
  int v8; // r6
  int v9; // r5

  v4 = a1;
  result = (_DWORD *)a1[9];
  v6 = a2 == (_DWORD)result;
  v7 = (v4[8] >> 3) & 1;
  v8 = v4[8] & 0x10;
  v9 = a2 + 4 * *(result - 3);
  if ( (_DWORD *)a2 == result )
    result = (_DWORD *)(a2 + 4 * *(result - 2));
  else
    v9 += 4 * a3;
  if ( !v6 )
  {
    a3 = 0;
    result = (_DWORD *)v9;
  }
  if ( v7 )
  {
    v4[1] = a2;
    v4[2] = a2 + 4 * a3;
    v4[3] = v9;
  }
  if ( v8 )
  {
    result = sub_A6554(v4, a2, (int)result, 0, a4);
    if ( !v7 )
    {
      v4[1] = v9;
      v4[2] = v9;
      v4[3] = v9;
    }
  }
  return result;
}

//----- (000A6614) --------------------------------------------------------
_DWORD *__fastcall sub_A6614(int a1, signed int a2, int a3)
{
  signed int v3; // r3
  int v4; // r5
  int v5; // r6
  _DWORD *v6; // r4

  v3 = a2;
  if ( a2 )
    v3 = 1;
  v4 = a3;
  if ( a3 < 0 )
    v3 = 0;
  v5 = a2;
  v6 = (_DWORD *)a1;
  if ( v3 )
  {
    sub_B9E18((const wchar_t **)(a1 + 36), 0, *(_DWORD *)(*(_DWORD *)(a1 + 36) - 12), 0);
    sub_A65A0(v6, v5, v4, 0);
  }
  return v6;
}

//----- (000A664C) --------------------------------------------------------
signed int __fastcall sub_A664C(_DWORD *a1, signed int a2)
{
  _DWORD *v2; // r4
  signed int v3; // r5
  unsigned int v4; // r1
  signed int *v5; // r3
  signed int *v6; // r2
  int v7; // r0
  bool v8; // zf
  unsigned int v9; // r0
  int v10; // r3
  _DWORD *v11; // r3
  int v12; // r2
  int v13; // r8
  char *v14; // r0
  signed int result; // r0
  unsigned int *v16; // r3
  signed int v17; // r2
  char *v18; // [sp+4h] [bp-1Ch]

  v2 = a1;
  v3 = a2;
  if ( !(a1[8] & 0x10) )
    return -1;
  if ( a2 == -1 )
    return 0;
  v4 = 268435454;
  v5 = (signed int *)a1[5];
  v6 = (signed int *)a1[6];
  v7 = *(_DWORD *)(a1[9] - 8);
  v8 = v5 == v6;
  if ( v5 >= v6 )
    v8 = v7 == 268435454;
  if ( v8 )
    return -1;
  if ( v5 < v6 )
  {
    *v5 = v3;
  }
  else
  {
    v9 = 2 * v7;
    if ( v9 >= 0x200 )
    {
      if ( v9 <= 0xFFFFFFE )
        v4 = v9;
    }
    else
    {
      v4 = 512;
    }
    v18 = (char *)&unk_2FEF30;
    sub_BA5B8((int *)&v18, v4);
    v10 = v2[4];
    if ( v10 )
      sub_BA25C((const wchar_t **)&v18, (const wchar_t *)v2[4], (v2[6] - v10) >> 2);
    v11 = v18;
    v12 = *((_DWORD *)v18 - 3);
    v13 = v12 + 1;
    if ( (unsigned int)(v12 + 1) > *((_DWORD *)v18 - 2) || *((_DWORD *)v18 - 1) > 0 )
    {
      sub_BA5B8((int *)&v18, v12 + 1);
      v11 = v18;
      v12 = *((_DWORD *)v18 - 3);
    }
    v11[v12] = v3;
    if ( v11 - 3 != (_DWORD *)&unk_2FEF24 )
      *(v11 - 3) = v13;
    if ( v11 - 3 != (_DWORD *)&unk_2FEF24 )
    {
      *(v11 - 1) = 0;
      v11[v13] = 0;
    }
    sub_B9740(v2 + 9, (int *)&v18);
    sub_A65A0(v2, v2[9], (v2[2] - v2[1]) >> 2, (v2[5] - v2[4]) >> 2);
    v14 = v18 - 12;
    if ( v18 - 12 != (char *)&unk_2FEF24 )
    {
      v16 = (unsigned int *)(v18 - 4);
      __dmb(0xFu);
      do
        v17 = __ldrex(v16);
      while ( __strex(v17 - 1, v16) );
      __dmb(0xFu);
      if ( v17 <= 0 )
        operator delete(v14);
    }
    v5 = (signed int *)v2[5];
  }
  result = v3;
  v2[5] = v5 + 1;
  return result;
}

//----- (000A6844) --------------------------------------------------------
signed __int64 *__fastcall sub_A6844(int a1, _DWORD *a2, signed __int64 a3, int a4, unsigned __int8 a5)
{
  signed __int64 *v5; // r6
  int v6; // r9
  _BOOL4 v7; // r7
  _BOOL4 v8; // r10
  int v9; // r12
  int v10; // r7
  int v11; // r0
  _BOOL4 v12; // r4
  int v13; // r10
  unsigned int v14; // r4
  signed __int64 v15; // r4
  int v16; // r7

  v5 = (signed __int64 *)a1;
  v6 = a2[8] & 8;
  v7 = (a5 & a2[8] & 8) != 0;
  v8 = (a2[8] & 0x10 & a5) != 0;
  v9 = v8 && v7;
  *(_QWORD *)a1 = -1LL;
  *(_DWORD *)(a1 + 8) = 0;
  if ( v8 && v7 )
  {
    v9 = a4 - 1;
    if ( a4 != 1 )
      v9 = 1;
  }
  if ( a5 & 0x10 )
    v10 = 0;
  else
    v10 = v7;
  if ( v10 )
    v11 = a2[1];
  else
    v11 = a2[4];
  v12 = a3 == 0;
  if ( v11 )
    v12 = 1;
  if ( !v12 )
    return v5;
  if ( a5 & 8 )
    v13 = 0;
  else
    v13 = v8;
  if ( v13 | v10 || v9 )
  {
    v14 = a2[5];
    if ( v14 && v14 > a2[3] )
    {
      if ( !v6 )
      {
        a2[1] = v14;
        a2[2] = v14;
      }
      a2[3] = v14;
    }
    if ( a4 == 1 )
    {
      v15 = a3 + __PAIR__((signed int)(v14 - v11) >> 33, (signed int)(v14 - v11) >> 2);
      a3 += __PAIR__((a2[2] - v11) >> 33, (a2[2] - v11) >> 2);
    }
    else
    {
      if ( a4 == 2 )
        a3 += __PAIR__((a2[3] - v11) >> 33, (a2[3] - v11) >> 2);
      v15 = a3;
    }
    if ( v9 | v10 && a3 >= 0 && (a2[3] - v11) >> 2 >= a3 )
    {
      v16 = a2[1];
      *v5 = a3;
      a2[2] = v16 + 4 * a3;
    }
    if ( v9 | v13 && v15 >= 0 && (a2[3] - v11) >> 2 >= v15 )
    {
      sub_A6554(a2, a2[4], a2[6], a2[4], v15);
      *v5 = v15;
    }
    return v5;
  }
  return v5;
}

//----- (000A69B0) --------------------------------------------------------
int __fastcall sub_A69B0(int a1, _DWORD *a2, signed __int64 a3, int a4, int a5, int a6)
{
  int v6; // r5
  int v7; // r6
  int v8; // r12
  _BOOL4 v9; // r0
  _BOOL4 v10; // r7
  signed __int64 v11; // r4
  int v12; // r3
  unsigned int v13; // r8
  signed __int64 v15; // [sp+20h] [bp-8h]

  v6 = a2[8];
  v7 = a1;
  v8 = a2[8] & 8;
  v15 = a3;
  v9 = ((unsigned __int8)a6 & v6 & 8) != 0;
  v10 = (v6 & 0x10 & (unsigned __int8)a6) != 0;
  *(_QWORD *)v7 = -1LL;
  v11 = a3;
  *(_DWORD *)(v7 + 8) = 0;
  if ( (a6 & v8) != 0 )
  {
    v12 = a2[1];
    if ( v12 )
      goto LABEL_3;
  }
  else
  {
    v12 = a2[4];
    if ( v12 )
      goto LABEL_3;
  }
  if ( v15 )
    return v7;
LABEL_3:
  if ( v10 || v9 )
  {
    v13 = a2[5];
    if ( v13 && v13 > a2[3] )
    {
      if ( !v8 )
      {
        a2[1] = v13;
        a2[2] = v13;
      }
      a2[3] = v13;
    }
    if ( v11 >= 0 && (a2[3] - v12) >> 2 >= v11 )
    {
      if ( (a6 & v8) != 0 )
      {
        a2[2] = a2[1] + 4 * v11;
        if ( !v10 )
          goto LABEL_13;
      }
      else if ( !v10 )
      {
LABEL_13:
        *(_QWORD *)v7 = v15;
        *(_DWORD *)(v7 + 8) = a4;
        return v7;
      }
      sub_A6554(a2, a2[4], a2[6], a2[4], v11);
      goto LABEL_13;
    }
  }
  return v7;
}

//----- (000A7B20) --------------------------------------------------------
int __fastcall sub_A7B20(int a1, char *a2, int a3, int a4, int *a5, char *a6, unsigned int a7, char **a8)
{
  unsigned int v8; // r9
  char *v9; // r10
  char *v10; // r5
  int v11; // r4
  int result; // r0
  _BOOL4 v13; // r3
  _DWORD *v14; // r10
  char *v15; // r11
  bool v16; // cf
  bool v17; // zf
  unsigned int v18; // r0
  unsigned int v19; // r6
  _DWORD *v20; // r3
  size_t v21; // r0
  char s; // [sp+8h] [bp-30h]
  int v23; // [sp+Ch] [bp-2Ch]

  v8 = a4;
  v9 = a2;
  v10 = a6;
  v11 = a3;
  v23 = *(_DWORD *)a2;
  if ( (signed int)&a6[((a4 - a3) >> 2) - a7] <= 0 )
  {
    if ( a4 <= (unsigned int)a3 )
    {
LABEL_21:
      result = 0;
      goto LABEL_14;
    }
    v20 = (_DWORD *)a3;
    while ( 1 )
    {
      v11 = (int)v20;
      v21 = wcrtomb(v10, *v20, (mbstate_t *)&v23);
      v20 = (_DWORD *)(v11 + 4);
      if ( v21 == -1 )
        goto LABEL_13;
      v10 += v21;
      v11 += 4;
      *(_DWORD *)v9 = v23;
      if ( v8 <= (unsigned int)v20 )
        goto LABEL_21;
    }
  }
  result = a4 > (unsigned int)a3;
  if ( (unsigned int)a6 < a7 )
    v13 = a4 > (unsigned int)a3;
  else
    v13 = 0;
  if ( v13 )
  {
    v14 = (_DWORD *)a3;
    v15 = a2;
    while ( 1 )
    {
      v11 = (int)v14;
      v18 = wcrtomb(&s, *v14, (mbstate_t *)&v23);
      ++v14;
      v19 = v18;
      if ( v18 == -1 )
        break;
      if ( v18 > a7 - (unsigned int)v10 )
      {
        result = 1;
        goto LABEL_14;
      }
      memcpy(v10, &s, v18);
      v10 += v19;
      v16 = v8 >= (unsigned int)v14;
      v17 = v8 == (_DWORD)v14;
      if ( v8 > (unsigned int)v14 )
      {
        v16 = a7 >= (unsigned int)v10;
        v17 = a7 == (_DWORD)v10;
      }
      v11 = (int)v14;
      *(_DWORD *)v15 = v23;
      if ( v17 || !v16 )
      {
        result = v8 > (unsigned int)v14;
        goto LABEL_14;
      }
    }
LABEL_13:
    result = 2;
  }
LABEL_14:
  *a5 = v11;
  *a8 = v10;
  return result;
}

//----- (000A7BF4) --------------------------------------------------------
void __fastcall sub_A7BF4(int a1, int a2, char *s, int a4, int a5, wchar_t *pwc, int a7, int a8)
{
  int *v8; // r8
  wchar_t *v9; // r7
  char *v10; // r4
  int v11; // r1
  bool v12; // cf
  unsigned int v13; // r11
  int v14; // r3
  size_t v15; // r0
  bool v16; // cf
  bool v17; // zf
  mbstate_t p; // [sp+4h] [bp-24h]

  v8 = (int *)a2;
  v9 = pwc;
  v10 = s;
  v11 = *(_DWORD *)a2;
  v12 = (unsigned int)pwc >= a7;
  if ( (unsigned int)pwc < a7 )
    v12 = (unsigned int)s >= a4;
  v13 = a4;
  p.__count = v11;
  if ( !v12 )
  {
    do
    {
      v15 = mbrtowc(v9, v10, v13 - (_DWORD)v10, &p);
      if ( v15 == -1 || v15 == -2 )
        break;
      v14 = p.__count;
      if ( !v15 )
      {
        *(_DWORD *)v9 = 0;
        v15 = 1;
      }
      v10 += v15;
      v9 += 2;
      *v8 = v14;
      v16 = a7 >= (unsigned int)v9;
      v17 = a7 == (_DWORD)v9;
      if ( a7 > (unsigned int)v9 )
      {
        v16 = v13 >= (unsigned int)v10;
        v17 = v13 == (_DWORD)v10;
      }
    }
    while ( !v17 && v16 );
  }
  *(_DWORD *)a5 = v10;
  *(_DWORD *)a8 = v9;
}

//----- (000A7C6C) --------------------------------------------------------
signed int sub_A7C6C()
{
  return 1;
}

//----- (000A7C70) --------------------------------------------------------
signed int sub_A7C70()
{
  return 1;
}

//----- (000A7C74) --------------------------------------------------------
int __fastcall sub_A7C74(int a1, int a2, char *s, int a4, int a5)
{
  int *v5; // r8
  int v6; // r1
  int v7; // r5
  char *v8; // r4
  unsigned int v9; // r6
  bool v10; // cf
  signed int v11; // r7
  size_t v12; // r0
  int v13; // r2
  mbstate_t p; // [sp+4h] [bp-24h]

  v5 = (int *)a2;
  v6 = *(_DWORD *)a2;
  v7 = a5;
  v8 = s;
  v9 = a4;
  v10 = 1;
  if ( a5 )
    v10 = (unsigned int)s >= a4;
  p.__count = v6;
  v11 = !v10;
  if ( !v10 )
  {
    v11 = 0;
    do
    {
      v12 = mbrtowc(0, v8, v9 - (_DWORD)v8, &p);
      if ( v12 + 2 <= 1 )
        break;
      if ( !v12 )
        v12 = 1;
      --v7;
      v8 += v12;
      v11 += v12;
      v13 = v9 > (unsigned int)v8 ? (unsigned __int8)(v7 != 0) : 0;
      *v5 = p.__count;
    }
    while ( v13 );
  }
  return v11;
}

//----- (000A7CDC) --------------------------------------------------------
unsigned int **__fastcall sub_A7CDC(unsigned int **a1)
{
  unsigned int **v1; // r4
  char v3; // [sp+4h] [bp-14h]

  v1 = a1;
  a1[2] = 0;
  a1[1] = (_DWORD *)&byte_6;
  a1[3] = (_DWORD *)(&stru_FF8 + 10);
  sub_A93A8(&v3);
  sub_AB5C4(v1 + 27, (unsigned int **)&v3);
  return sub_AB620((unsigned int **)&v3);
}
// 6: using guessed type char;
// FF8: using guessed type Elf32_Sym;

//----- (000A7D0C) --------------------------------------------------------
unsigned int **__fastcall sub_A7D0C(unsigned int **a1, int a2, unsigned int **a3)
{
  unsigned int **v3; // r5
  unsigned int **v4; // r7
  int v5; // r4
  unsigned int **v6; // r6

  v3 = (unsigned int **)(a2 + 108);
  v4 = a3;
  v5 = a2;
  v6 = a1;
  sub_AB164(a1, (unsigned int **)(a2 + 108));
  sub_AB5C4(v3, v4);
  sub_95DA8(v5, 1);
  return v6;
}

//----- (000A7D34) --------------------------------------------------------
void __fastcall std::__convert_to_v<float>(const char *a1, float *a2, _DWORD *a3)
{
  const char *v3; // r5
  float *v4; // r6
  _DWORD *v5; // r9
  char *v6; // r0
  char *v7; // r8
  unsigned int v8; // r7
  void *v9; // r4
  double v10; // r0
  char *v11; // r3
  bool v12; // zf
  float v13; // s15
  char *endptr; // [sp+4h] [bp-24h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = setlocale(6, 0);
  v7 = v6;
  if ( v6 )
  {
    v8 = strlen(v6) + 1;
    v9 = operator new[](v8);
    memcpy(v9, v7, v8);
    setlocale(6, "C");
  }
  else
  {
    v9 = 0;
  }
  v10 = strtod(v3, &endptr);
  v11 = endptr;
  v12 = endptr == v3;
  v13 = v10;
  *v4 = v13;
  if ( v12 || *v11 )
  {
    *v4 = 0.0;
    *v5 = 4;
  }
  else if ( fabsf(v13) > 3.4028e38 || v13 > 3.4028e38 || v13 < -3.4028e38 )
  {
    if ( v13 <= 0.0 )
      *v4 = -3.4028e38;
    else
      *v4 = 3.4028e38;
    *v5 = 4;
  }
  setlocale(6, (const char *)v9);
  if ( v9 )
    operator delete[](v9);
}

//----- (000A7E20) --------------------------------------------------------
void __fastcall std::__convert_to_v<double>(const char *a1, double *a2, _DWORD *a3)
{
  const char *v3; // r4
  double *v4; // r7
  _DWORD *v5; // r8
  char *v6; // r0
  char *v7; // r9
  unsigned int v8; // r5
  void *v9; // r6
  double v10; // r0
  char *v11; // r3
  bool v12; // zf
  char *endptr; // [sp+4h] [bp-24h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = setlocale(6, 0);
  v7 = v6;
  if ( v6 )
  {
    v8 = strlen(v6) + 1;
    v9 = operator new[](v8);
    memcpy(v9, v7, v8);
    setlocale(6, "C");
  }
  else
  {
    v9 = 0;
  }
  v10 = strtod(v3, &endptr);
  v11 = endptr;
  v12 = endptr == v3;
  *v4 = v10;
  if ( v12 || *v11 )
  {
    *v4 = 0.0;
    *v5 = 4;
  }
  else if ( v10 > 1.79769313e308 || v10 < -1.79769313e308 )
  {
    if ( v10 <= 0.0 )
      *v4 = -1.79769313e308;
    else
      *v4 = 1.79769313e308;
    *v5 = 4;
  }
  setlocale(6, (const char *)v9);
  if ( v9 )
    operator delete[](v9);
}

//----- (000A7F10) --------------------------------------------------------
void __fastcall std::__convert_to_v<long double>(const char *a1, double *a2, _DWORD *a3)
{
  const char *v3; // r5
  double *v4; // r7
  _DWORD *v5; // r8
  char *v6; // r0
  char *v7; // r9
  unsigned int v8; // r4
  void *v9; // r6
  double v10; // d7

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = setlocale(6, 0);
  v7 = v6;
  if ( v6 )
  {
    v8 = strlen(v6) + 1;
    v9 = operator new[](v8);
    memcpy(v9, v7, v8);
    setlocale(6, "C");
  }
  else
  {
    v9 = 0;
  }
  if ( (unsigned int)(sscanf(v3, "%Lf", v4) + 1) <= 1 )
  {
    *v4 = 0.0;
    *v5 = 4;
  }
  else
  {
    v10 = *v4;
    if ( *v4 > 1.79769313e308 )
    {
      if ( v10 > 0.0 )
      {
LABEL_6:
        *v4 = 1.79769313e308;
        goto LABEL_7;
      }
LABEL_14:
      *v4 = -1.79769313e308;
LABEL_7:
      *v5 = 4;
      setlocale(6, (const char *)v9);
      if ( !v9 )
        return;
LABEL_11:
      operator delete[](v9);
      return;
    }
    if ( v10 < -1.79769313e308 )
    {
      if ( v10 > 0.0 )
        goto LABEL_6;
      goto LABEL_14;
    }
  }
  setlocale(6, (const char *)v9);
  if ( v9 )
    goto LABEL_11;
}

//----- (000A8010) --------------------------------------------------------
int __fastcall sub_A8010(_DWORD *a1, const char *a2)
{
  int result; // r0

  *a1 = 0;
  result = strcmp(a2, "C");
  if ( result )
    sub_BFC64("locale::facet::_S_create_c_locale name not valid");
  return result;
}

//----- (000A8038) --------------------------------------------------------
_DWORD *__fastcall sub_A8038(_DWORD *result)
{
  *result = 0;
  return result;
}

//----- (000A8040) --------------------------------------------------------
int sub_A8040()
{
  return 0;
}

//----- (000A8048) --------------------------------------------------------
void __fastcall sub_A8048(int a1, char *a2, size_t a3, const char *a4, const struct tm *a5)
{
  int v5; // r11
  char *v6; // r5
  size_t v7; // r9
  const char *v8; // r8
  char *v9; // r0
  char *v10; // r10
  unsigned int v11; // r6
  void *v12; // r4
  size_t v13; // r6

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v9 = setlocale(6, 0);
  v10 = v9;
  if ( v9 )
  {
    v11 = strlen(v9) + 1;
    v12 = operator new[](v11);
    memcpy(v12, v10, v11);
    setlocale(6, *(const char **)(v5 + 16));
  }
  else
  {
    v12 = 0;
  }
  v13 = strftime(v6, v7, v8, a5);
  setlocale(6, (const char *)v12);
  if ( v12 )
    operator delete[](v12);
  if ( !v13 )
    *v6 = 0;
}

//----- (000A80BC) --------------------------------------------------------
const char *__fastcall sub_A80BC(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  const char *result; // r0
  _DWORD *v4; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v4 = operator new(0xC8u);
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 0;
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
    v4[8] = 0;
    v4[9] = 0;
    v4[10] = 0;
    v4[11] = 0;
    v4[12] = 0;
    v4[13] = 0;
    v4[14] = 0;
    v4[15] = 0;
    v4[16] = 0;
    v4[17] = 0;
    v4[18] = 0;
    v4[19] = 0;
    v4[20] = 0;
    v4[21] = 0;
    v4[22] = 0;
    v4[23] = 0;
    v4[24] = 0;
    v4[25] = 0;
    v4[26] = 0;
    v4[27] = 0;
    v4[28] = 0;
    v4[29] = 0;
    v4[30] = 0;
    v4[31] = 0;
    *v4 = &off_F0A80;
    v4[32] = 0;
    v4[33] = 0;
    v4[34] = 0;
    v4[35] = 0;
    v4[36] = 0;
    v4[37] = 0;
    v4[38] = 0;
    v4[39] = 0;
    v4[40] = 0;
    v4[41] = 0;
    v4[42] = 0;
    v4[43] = 0;
    v4[44] = 0;
    v4[45] = 0;
    v4[46] = 0;
    v4[47] = 0;
    v4[48] = 0;
    *((_BYTE *)v4 + 196) = 0;
    v2 = v4;
    *(_DWORD *)(v1 + 8) = v4;
  }
  v2[2] = "%m/%d/%y";
  v2[3] = "%m/%d/%y";
  v2[4] = "%H:%M:%S";
  v2[5] = "%H:%M:%S";
  v2[6] = &unk_E00F2;
  v2[7] = &unk_E00F2;
  v2[10] = &unk_E00F2;
  v2[8] = "AM";
  v2[17] = "Saturday";
  v2[19] = "Mon";
  v2[9] = &off_E2DC4;
  v2[11] = "Sunday";
  v2[12] = "Monday";
  v2[13] = "Tuesday";
  v2[14] = "Wednesday";
  v2[15] = "Thursday";
  v2[16] = "Friday";
  v2[18] = "Sun";
  v2[20] = "Tue";
  v2[21] = "Wed";
  v2[22] = "Thu";
  v2[23] = "Fri";
  v2[24] = "Sat";
  v2[25] = "January";
  v2[26] = "February";
  v2[27] = "March";
  v2[28] = "April";
  v2[29] = "May";
  v2[30] = "June";
  v2[31] = "July";
  v2[32] = "August";
  v2[33] = "September";
  v2[34] = "October";
  v2[35] = "November";
  result = "Jun";
  v2[41] = "May";
  v2[37] = "Jan";
  v2[38] = "Feb";
  v2[36] = "December";
  v2[39] = "Mar";
  v2[40] = "Apr";
  v2[42] = "Jun";
  v2[43] = "Jul";
  v2[44] = "Aug";
  v2[45] = "Sep";
  v2[46] = "Oct";
  v2[47] = "Nov";
  v2[48] = "Dec";
  return result;
}
// E2DC4: using guessed type void *off_E2DC4;
// F0A80: using guessed type void *;

//----- (000A8384) --------------------------------------------------------
void __fastcall sub_A8384(struct tm *tp, wchar_t *a2, size_t a3, const wchar_t *a4, struct tm *tpa)
{
  struct tm *v5; // r10
  wchar_t *v6; // r6
  size_t v7; // r9
  const wchar_t *v8; // r8
  char *v9; // r0
  char *v10; // r7
  unsigned int v11; // r5
  void *v12; // r4
  size_t v13; // r5

  v5 = tp;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v9 = setlocale(6, 0);
  v10 = v9;
  if ( v9 )
  {
    v11 = strlen(v9) + 1;
    v12 = operator new[](v11);
    memcpy(v12, v10, v11);
    setlocale(6, (const char *)v5->tm_mon);
    v13 = wcsftime(v6, v7, v8, tpa);
    setlocale(6, (const char *)v12);
    if ( v12 )
      operator delete[](v12);
  }
  else
  {
    v13 = wcsftime(v6, v7, v8, tpa);
    setlocale(6, v10);
  }
  if ( !v13 )
    *(_DWORD *)v6 = 0;
}

//----- (000A840C) --------------------------------------------------------
void *__fastcall sub_A840C(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  void *result; // r0
  _DWORD *v4; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v4 = operator new(0xC8u);
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 0;
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
    v4[8] = 0;
    v4[9] = 0;
    v4[10] = 0;
    v4[11] = 0;
    v4[12] = 0;
    v4[13] = 0;
    v4[14] = 0;
    v4[15] = 0;
    v4[16] = 0;
    v4[17] = 0;
    v4[18] = 0;
    v4[19] = 0;
    v4[20] = 0;
    v4[21] = 0;
    v4[22] = 0;
    v4[23] = 0;
    v4[24] = 0;
    v4[25] = 0;
    v4[26] = 0;
    v4[27] = 0;
    v4[28] = 0;
    v4[29] = 0;
    v4[30] = 0;
    v4[31] = 0;
    *v4 = &off_F1978;
    v4[32] = 0;
    v4[33] = 0;
    v4[34] = 0;
    v4[35] = 0;
    v4[36] = 0;
    v4[37] = 0;
    v4[38] = 0;
    v4[39] = 0;
    v4[40] = 0;
    v4[41] = 0;
    v4[42] = 0;
    v4[43] = 0;
    v4[44] = 0;
    v4[45] = 0;
    v4[46] = 0;
    v4[47] = 0;
    v4[48] = 0;
    *((_BYTE *)v4 + 196) = 0;
    v2 = v4;
    *(_DWORD *)(v1 + 8) = v4;
  }
  v2[2] = "%";
  v2[3] = "%";
  v2[4] = &off_ECF44;
  v2[5] = &off_ECF44;
  v2[6] = &unk_ECF68;
  v2[7] = &unk_ECF68;
  v2[10] = &unk_ECF68;
  v2[8] = &off_ECF6C;
  v2[17] = &unk_ED044;
  v2[19] = &off_ED078;
  v2[9] = &off_ECF78;
  v2[11] = &unk_ECF84;
  v2[12] = &off_ECFA0;
  v2[13] = &off_ECFBC;
  v2[14] = &unk_ECFDC;
  v2[15] = off_ED004;
  v2[16] = &unk_ED028;
  v2[18] = &unk_ED068;
  v2[20] = &off_ED088;
  v2[21] = &unk_ED098;
  v2[22] = off_ED0A8;
  v2[23] = &unk_ED0B8;
  v2[24] = &unk_ED0C8;
  v2[25] = &unk_ED0D8;
  v2[26] = &unk_ED0F8;
  v2[27] = &off_ED11C;
  v2[28] = &off_ED134;
  v2[29] = &off_ED14C;
  v2[30] = &unk_ED15C;
  v2[31] = &unk_ED170;
  v2[32] = &off_ED184;
  v2[33] = &unk_ED1A0;
  v2[34] = &unk_ED1C8;
  v2[35] = &unk_ED1E8;
  result = &unk_ED270;
  v2[41] = &off_ED14C;
  v2[37] = &unk_ED230;
  v2[38] = &unk_ED240;
  v2[36] = &off_ED20C;
  v2[39] = &off_ED250;
  v2[40] = &off_ED260;
  v2[42] = &unk_ED270;
  v2[43] = &unk_ED280;
  v2[44] = &off_ED290;
  v2[45] = &unk_ED2A0;
  v2[46] = &unk_ED2B0;
  v2[47] = &unk_ED2C0;
  v2[48] = &off_ED2D0;
  return result;
}
// ECF44: using guessed type void *off_ECF44;
// ECF6C: using guessed type void *off_ECF6C;
// ECF78: using guessed type int *off_ECF78;
// ECFA0: using guessed type void *off_ECFA0;
// ECFBC: using guessed type int *off_ECFBC;
// ED004: using guessed type int *off_ED004[2];
// ED078: using guessed type void *off_ED078;
// ED088: using guessed type int *off_ED088;
// ED0A8: using guessed type int *off_ED0A8[2];
// ED11C: using guessed type void *off_ED11C;
// ED134: using guessed type void *off_ED134;
// ED14C: using guessed type void *off_ED14C;
// ED184: using guessed type void *off_ED184;
// ED20C: using guessed type int *off_ED20C;
// ED250: using guessed type void *off_ED250;
// ED260: using guessed type void *off_ED260;
// ED290: using guessed type void *off_ED290;
// ED2D0: using guessed type int *off_ED2D0;
// F1978: using guessed type void *;

//----- (000A86D4) --------------------------------------------------------
int __fastcall sub_A86D4(_DWORD *a1, _DWORD *a2, _BYTE *a3)
{
  _BYTE *v3; // r8
  _BYTE *v4; // r7
  unsigned int v5; // r3
  _DWORD *v6; // r4
  _DWORD *v7; // r6
  int v8; // r0
  int v9; // r9
  int v10; // r0
  int v11; // r5
  _BYTE *v12; // r3
  unsigned int v13; // r2
  unsigned int v14; // r3
  unsigned __int8 *v15; // r2
  int result; // r0

  v3 = a3;
  v4 = (_BYTE *)a1[2];
  v5 = a1[3];
  v6 = a1;
  v7 = a2;
  *a3 = 1;
  if ( (unsigned int)v4 < v5 )
  {
    LOBYTE(v8) = *v4;
LABEL_3:
    v9 = 0;
    while ( 1 )
    {
      v11 = v5 - (_DWORD)v4;
      if ( (signed int)(v5 - (_DWORD)v4) > 1 )
        break;
      v12 = (_BYTE *)v7[5];
      if ( (unsigned int)v12 >= v7[6] )
      {
        if ( (*(int (__fastcall **)(_DWORD *, _DWORD))(*v7 + 52))(v7, (unsigned __int8)v8) == -1 )
        {
LABEL_16:
          result = v9;
          *v3 = 0;
          return result;
        }
      }
      else
      {
        *v12 = v8;
        ++v7[5];
      }
      v13 = v6[2];
      ++v9;
      v14 = v6[3];
      if ( v13 >= v14 )
      {
        if ( (*(int (__fastcall **)(_DWORD *))(*v6 + 40))(v6) == -1 )
          return v9;
        v15 = (unsigned __int8 *)v6[2];
        v14 = v6[3];
      }
      else
      {
        v15 = (unsigned __int8 *)(v13 + 1);
        v6[2] = v15;
      }
      if ( v14 <= (unsigned int)v15 )
        goto LABEL_5;
      v8 = *v15;
      if ( v8 == -1 )
        return v9;
LABEL_6:
      v4 = (_BYTE *)v6[2];
      v5 = v6[3];
    }
    v10 = (*(int (__fastcall **)(_DWORD *, _BYTE *, unsigned int))(*v7 + 48))(v7, v4, v5 - (_DWORD)v4);
    v9 += v10;
    v6[2] += v10;
    if ( v11 > v10 )
      goto LABEL_16;
LABEL_5:
    v8 = (*(int (__fastcall **)(_DWORD *))(*v6 + 36))(v6);
    if ( v8 == -1 )
      return v9;
    goto LABEL_6;
  }
  v8 = (*(int (**)(void))(*a1 + 36))();
  if ( v8 != -1 )
  {
    v4 = (_BYTE *)v6[2];
    v5 = v6[3];
    goto LABEL_3;
  }
  return 0;
}

//----- (000A8794) --------------------------------------------------------
int __fastcall sub_A8794(_DWORD *a1, _DWORD *a2, _BYTE *a3)
{
  _BYTE *v3; // r7
  int *v4; // r3
  _DWORD *v5; // r6
  unsigned int v6; // r2
  _DWORD *v7; // r4
  int v8; // r0
  int v9; // r8
  int v10; // r0
  int v11; // r5
  int *v12; // r3
  int *v13; // r3
  int v14; // r0
  int *v15; // r3
  int result; // r0

  v3 = a3;
  v4 = (int *)a1[2];
  v5 = a2;
  v6 = a1[3];
  v7 = a1;
  *v3 = 1;
  if ( (unsigned int)v4 >= v6 )
    v8 = (*(int (**)(void))(*a1 + 36))();
  else
    v8 = *v4;
  v9 = 0;
  if ( v8 == -1 )
    return v9;
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = (v7[3] - v7[2]) >> 2;
      if ( v11 <= 1 )
        break;
      v10 = (*(int (__fastcall **)(_DWORD *))(*v5 + 48))(v5);
      v9 += v10;
      v7[2] += 4 * v10;
      if ( v11 > v10 )
        goto LABEL_17;
LABEL_6:
      v8 = (*(int (__fastcall **)(_DWORD *))(*v7 + 36))(v7);
      if ( v8 == -1 )
        return v9;
    }
    v12 = (int *)v5[5];
    if ( (unsigned int)v12 < v5[6] )
    {
      *v12 = v8;
      v5[5] = v12 + 1;
      goto LABEL_10;
    }
    if ( (*(int (__fastcall **)(_DWORD *, int))(*v5 + 52))(v5, v8) == -1 )
      break;
LABEL_10:
    v13 = (int *)v7[2];
    ++v9;
    if ( (unsigned int)v13 >= v7[3] )
    {
      v14 = (*(int (__fastcall **)(_DWORD *))(*v7 + 40))(v7);
    }
    else
    {
      v14 = *v13;
      v7[2] = v13 + 1;
    }
    if ( v14 == -1 )
      return v9;
    v15 = (int *)v7[2];
    if ( (unsigned int)v15 >= v7[3] )
      goto LABEL_6;
    v8 = *v15;
    if ( *v15 == -1 )
      return v9;
  }
LABEL_17:
  result = v9;
  *v3 = 0;
  return result;
}

//----- (000A8848) --------------------------------------------------------
int *sub_A8848()
{
  if ( !(dword_2FEE90 & 1) && _cxa_guard_acquire((unsigned int *)&dword_2FEE90) )
  {
    dword_2FE118 = 0;
    _cxa_guard_release((unsigned int *)&dword_2FEE90);
  }
  return &dword_2FE118;
}
// 2FE118: using guessed type int dword_2FE118;
// 2FEE90: using guessed type int dword_2FEE90;

//----- (000A8880) --------------------------------------------------------
_DWORD *__fastcall sub_A8880(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r3
  char *v4; // r0
  char *v5; // r1
  char *i; // r3
  int v7; // r5
  int v8; // r5
  int v9; // r5
  int v10; // r5
  int v11; // r5
  int v12; // r5
  int v13; // r5
  int v14; // r5

  v2 = a1;
  v3 = 0;
  a1[4] = 0;
  *a1 = a2;
  v4 = (char *)&unk_2FE600;
  v5 = (char *)&unk_2FEE20;
  v2[2] = 28;
  v2[1] = &unk_2FE600;
  for ( v2[3] = &unk_2FEE20; ; v5 = (char *)v2[3] )
  {
    *(_DWORD *)&v5[v3] = 0;
    *(_DWORD *)&v4[v3] = 0;
    v3 += 4;
    if ( v3 == 112 )
      break;
    v4 = (char *)v2[1];
  }
  v2[4] = &dword_2FE298;
  dword_2FE298 = (int)&word_2FE10C;
  word_2FE10C = *(_WORD *)sub_AB4DC();
  dword_2FE29C = 0;
  for ( i = byte_8; i != (char *)&dword_18; i += 4 )
    *(_DWORD *)&i[v2[4]] = 0;
  sub_AC154((int)&unk_2FE3E0, 0, 0, 1);
  sub_AB88C((int)v2, (int *)&unk_2FEE9C, (int)&unk_2FE3E0);
  sub_A03A8(&unk_2FE21C, 1);
  sub_AB88C((int)v2, (int *)&unk_2FE0C8, (int)&unk_2FE21C);
  dword_2FEDB4 = 1;
  dword_2FE13C = 1;
  dword_2FEDB8 = 0;
  dword_2FEDBC = 0;
  byte_2FEDC0 = 0;
  dword_2FEDB0 = (int)&off_F0CF0;
  dword_2FEDC4 = 0;
  dword_2FEDC8 = 0;
  dword_2FEDCC = 0;
  dword_2FEDD0 = 0;
  byte_2FEDD4 = 0;
  byte_2FEDD5 = 0;
  byte_2FEE14 = 0;
  dword_2FE140 = (int)&dword_2FEDB0;
  dword_2FE138 = (int)&off_F09C0;
  sub_C29E0((int)&dword_2FE138);
  sub_AB88C((int)v2, (int *)&unk_2FE0B4, (int)&dword_2FE138);
  dword_2FEE98 = 1;
  dword_2FEE94 = (int)&off_F0A10;
  sub_AB88C((int)v2, (int *)&unk_2FE0B0, (int)&dword_2FEE94);
  dword_2FE7A4 = 1;
  dword_2FE7A0 = (int)&off_F0A50;
  sub_AB88C((int)v2, (int *)&unk_2FE0AC, (int)&dword_2FE7A0);
  dword_2FE0E8 = 1;
  dword_2FE0E4 = (int)&off_F0980;
  dword_2FE0EC = sub_AB4B8();
  sub_AB88C((int)v2, (int *)&unk_2FE098, (int)&dword_2FE0E4);
  dword_2FEC9C = 1;
  dword_2FE784 = 1;
  dword_2FECA0 = 0;
  dword_2FECA4 = 0;
  byte_2FECA8 = 0;
  dword_2FEC98 = (int)&off_F0CD0;
  byte_2FECA9 = 0;
  byte_2FECAA = 0;
  dword_2FECAC = 0;
  dword_2FECB0 = 0;
  dword_2FECB4 = 0;
  dword_2FECB8 = 0;
  dword_2FECBC = 0;
  dword_2FECC0 = 0;
  dword_2FECC4 = 0;
  byte_2FECC8 = 0;
  byte_2FECC9 = 0;
  byte_2FECCA = 0;
  byte_2FECCB = 0;
  byte_2FECCC = 0;
  byte_2FECCD = 0;
  byte_2FECCE = 0;
  byte_2FECCF = 0;
  byte_2FECDB = 0;
  dword_2FE788 = (int)&dword_2FEC98;
  dword_2FE780 = (int)&off_F0AD8;
  sub_C2D70((int)&dword_2FE780);
  sub_AB88C((int)v2, (int *)&unk_2FE0C4, (int)&dword_2FE780);
  dword_2FED68 = 1;
  dword_2FE76C = 1;
  dword_2FED6C = 0;
  dword_2FED64 = (int)&off_F0CE0;
  dword_2FED70 = 0;
  byte_2FED74 = 0;
  byte_2FED75 = 0;
  byte_2FED76 = 0;
  dword_2FED78 = 0;
  dword_2FED7C = 0;
  dword_2FED80 = 0;
  dword_2FED84 = 0;
  dword_2FED88 = 0;
  dword_2FED8C = 0;
  dword_2FED90 = 0;
  byte_2FED94 = 0;
  byte_2FED95 = 0;
  byte_2FED96 = 0;
  byte_2FED97 = 0;
  byte_2FED98 = 0;
  byte_2FED99 = 0;
  byte_2FED9A = 0;
  byte_2FED9B = 0;
  byte_2FEDA7 = 0;
  dword_2FE770 = (int)&dword_2FED64;
  dword_2FE768 = (int)&off_F0AA0;
  sub_C2CB4((int)&dword_2FE768);
  sub_AB88C((int)v2, (int *)&unk_2FE0C0, (int)&dword_2FE768);
  dword_2FE688 = 1;
  dword_2FE684 = (int)&off_F0C00;
  sub_AB88C((int)v2, (int *)&unk_2FE0BC, (int)&dword_2FE684);
  dword_2FE148 = 1;
  dword_2FE144 = (int)&off_F0C18;
  sub_AB88C((int)v2, (int *)&unk_2FE0B8, (int)&dword_2FE144);
  dword_2FE158 = 1;
  dword_2FE15C = 0;
  dword_2FE160 = 0;
  dword_2FE154 = (int)&off_F0A80;
  dword_2FE164 = 0;
  dword_2FE168 = 0;
  dword_2FE16C = 0;
  dword_2FE170 = 0;
  dword_2FE174 = 0;
  dword_2FE178 = 0;
  dword_2FE17C = 0;
  dword_2FE180 = 0;
  dword_2FE184 = 0;
  dword_2FE188 = 0;
  dword_2FE18C = 0;
  dword_2FE190 = 0;
  dword_2FE194 = 0;
  dword_2FE198 = 0;
  dword_2FE19C = 0;
  dword_2FE1A0 = 0;
  dword_2FE1A4 = 0;
  dword_2FE1A8 = 0;
  dword_2FE1AC = 0;
  dword_2FE1B0 = 0;
  dword_2FE1B4 = 0;
  dword_2FE1B8 = 0;
  dword_2FE1BC = 0;
  dword_2FE1C0 = 0;
  dword_2FE1C4 = 0;
  dword_2FE1C8 = 0;
  dword_2FE1CC = 0;
  dword_2FE1D0 = 0;
  dword_2FE1D4 = 0;
  dword_2FE1D8 = 0;
  dword_2FE1DC = 0;
  dword_2FE1E0 = 0;
  dword_2FE1E4 = 0;
  dword_2FE1E8 = 0;
  dword_2FE1EC = 0;
  dword_2FE1F0 = 0;
  dword_2FE1F4 = 0;
  dword_2FE1F8 = 0;
  dword_2FE1FC = 0;
  dword_2FE200 = 0;
  dword_2FE204 = 0;
  dword_2FE208 = 0;
  dword_2FE20C = 0;
  dword_2FE210 = 0;
  dword_2FE214 = 0;
  byte_2FE218 = 0;
  sub_974CC(&unk_2FE0D0, (int)&dword_2FE154, 1);
  sub_AB88C((int)v2, (int *)&unk_2FE0A8, (int)&unk_2FE0D0);
  dword_2FEDAC = 1;
  dword_2FEDA8 = (int)&off_F0C60;
  sub_AB88C((int)v2, (int *)&unk_2FE0A0, (int)&dword_2FEDA8);
  dword_2FE764 = 1;
  dword_2FE760 = (int)&off_F0C30;
  sub_AB88C((int)v2, (int *)&unk_2FE0A4, (int)&dword_2FE760);
  sub_97950(&unk_2FE128, 1);
  sub_AB88C((int)v2, (int *)&unk_2FE09C, (int)&unk_2FE128);
  sub_AAA14(&unk_2FE7A8, 1);
  sub_AB88C((int)v2, (int *)&unk_2FEEA0, (int)&unk_2FE7A8);
  sub_A0410(&unk_2FED58, 1);
  sub_AB88C((int)v2, (int *)&unk_2FE0CC, (int)&unk_2FED58);
  dword_2FE2BC = 1;
  dword_2FE120 = 1;
  dword_2FE2C0 = 0;
  dword_2FE2B8 = (int)&off_F1BE8;
  dword_2FE2C4 = 0;
  byte_2FE2C8 = 0;
  dword_2FE2CC = 0;
  dword_2FE2D0 = 0;
  dword_2FE2D4 = 0;
  dword_2FE2D8 = 0;
  dword_2FE2DC = 0;
  dword_2FE2E0 = 0;
  byte_2FE3DC = 0;
  dword_2FE124 = (int)&dword_2FE2B8;
  dword_2FE11C = (int)&off_F18B8;
  sub_C2A9C((int)&dword_2FE11C);
  sub_AB88C((int)v2, (int *)&unk_2FEF10, (int)&dword_2FE11C);
  dword_2FE690 = 1;
  dword_2FE68C = (int)&off_F1908;
  sub_AB88C((int)v2, (int *)&unk_2FEF0C, (int)&dword_2FE68C);
  dword_2FE150 = 1;
  dword_2FE14C = (int)&off_F1948;
  sub_AB88C((int)v2, (int *)&unk_2FEF08, (int)&dword_2FE14C);
  dword_2FE778 = 1;
  dword_2FE774 = (int)&off_F1838;
  dword_2FE77C = sub_AB4B8();
  sub_AB88C((int)v2, (int *)&unk_2FEEF4, (int)&dword_2FE774);
  dword_2FE22C = 1;
  dword_2FED50 = 1;
  dword_2FE230 = 0;
  dword_2FE228 = (int)&off_F1BC8;
  dword_2FE234 = 0;
  byte_2FE238 = 0;
  dword_2FE23C = 0;
  dword_2FE240 = 0;
  dword_2FE244 = 0;
  dword_2FE248 = 0;
  dword_2FE24C = 0;
  dword_2FE250 = 0;
  dword_2FE254 = 0;
  dword_2FE258 = 0;
  dword_2FE25C = 0;
  byte_2FE260 = 0;
  byte_2FE261 = 0;
  byte_2FE262 = 0;
  byte_2FE263 = 0;
  byte_2FE264 = 0;
  byte_2FE265 = 0;
  byte_2FE266 = 0;
  byte_2FE267 = 0;
  byte_2FE294 = 0;
  dword_2FED54 = (int)&dword_2FE228;
  dword_2FED4C = (int)&off_F19D0;
  sub_C2EF8((int)&dword_2FED4C);
  sub_AB88C((int)v2, (int *)&unk_2FEF20, (int)&dword_2FED4C);
  dword_2FECE0 = 1;
  dword_2FE798 = 1;
  dword_2FECE4 = 0;
  dword_2FECDC = (int)&off_F1BD8;
  dword_2FECE8 = 0;
  byte_2FECEC = 0;
  dword_2FECF0 = 0;
  dword_2FECF4 = 0;
  dword_2FECF8 = 0;
  dword_2FECFC = 0;
  dword_2FED00 = 0;
  dword_2FED04 = 0;
  dword_2FED08 = 0;
  dword_2FED0C = 0;
  dword_2FED10 = 0;
  byte_2FED14 = 0;
  byte_2FED15 = 0;
  byte_2FED16 = 0;
  byte_2FED17 = 0;
  byte_2FED18 = 0;
  byte_2FED19 = 0;
  byte_2FED1A = 0;
  byte_2FED1B = 0;
  byte_2FED48 = 0;
  dword_2FE79C = (int)&dword_2FECDC;
  dword_2FE794 = (int)&off_F1998;
  sub_C2E2C((int)&dword_2FE794);
  sub_AB88C((int)v2, (int *)&unk_2FEF1C, (int)&dword_2FE794);
  dword_2FE0F4 = 1;
  dword_2FE0F0 = (int)&off_F1AF8;
  sub_AB88C((int)v2, (int *)&unk_2FEF18, (int)&dword_2FE0F0);
  dword_2FE790 = 1;
  dword_2FE78C = (int)&off_F1B10;
  sub_AB88C((int)v2, (int *)&unk_2FEF14, (int)&dword_2FE78C);
  dword_2FE698 = 1;
  dword_2FE69C = 0;
  dword_2FE6A0 = 0;
  dword_2FE694 = (int)&off_F1978;
  dword_2FE6A4 = 0;
  dword_2FE6A8 = 0;
  dword_2FE6AC = 0;
  dword_2FE6B0 = 0;
  dword_2FE6B4 = 0;
  dword_2FE6B8 = 0;
  dword_2FE6BC = 0;
  dword_2FE6C0 = 0;
  dword_2FE6C4 = 0;
  dword_2FE6C8 = 0;
  dword_2FE6CC = 0;
  dword_2FE6D0 = 0;
  dword_2FE6D4 = 0;
  dword_2FE6D8 = 0;
  dword_2FE6DC = 0;
  dword_2FE6E0 = 0;
  dword_2FE6E4 = 0;
  dword_2FE6E8 = 0;
  dword_2FE6EC = 0;
  dword_2FE6F0 = 0;
  dword_2FE6F4 = 0;
  dword_2FE6F8 = 0;
  dword_2FE6FC = 0;
  dword_2FE700 = 0;
  dword_2FE704 = 0;
  dword_2FE708 = 0;
  dword_2FE70C = 0;
  dword_2FE710 = 0;
  dword_2FE714 = 0;
  dword_2FE718 = 0;
  dword_2FE71C = 0;
  dword_2FE720 = 0;
  dword_2FE724 = 0;
  dword_2FE728 = 0;
  dword_2FE72C = 0;
  dword_2FE730 = 0;
  dword_2FE734 = 0;
  dword_2FE738 = 0;
  dword_2FE73C = 0;
  dword_2FE740 = 0;
  dword_2FE744 = 0;
  dword_2FE748 = 0;
  dword_2FE74C = 0;
  dword_2FE750 = 0;
  dword_2FE754 = 0;
  byte_2FE758 = 0;
  sub_AD7A0(&unk_2FE670, (int)&dword_2FE694, 1);
  sub_AB88C((int)v2, (int *)&unk_2FEF04, (int)&unk_2FE670);
  dword_2FE2B4 = 1;
  dword_2FE2B0 = (int)&off_F1B58;
  sub_AB88C((int)v2, (int *)&unk_2FEEFC, (int)&dword_2FE2B0);
  dword_2FEE1C = 1;
  dword_2FEE18 = (int)&off_F1B28;
  sub_AB88C((int)v2, (int *)&unk_2FEF00, (int)&dword_2FEE18);
  sub_ADC24(&unk_2FEC88, 1);
  sub_AB88C((int)v2, (int *)&unk_2FEEF8, (int)&unk_2FEC88);
  v7 = v2[3];
  *(_DWORD *)(v7 + 4 * sub_AB850((int *)&unk_2FE0B4)) = &dword_2FEDB0;
  v8 = v2[3];
  *(_DWORD *)(v8 + 4 * sub_AB850((int *)&unk_2FE0C4)) = &dword_2FEC98;
  v9 = v2[3];
  *(_DWORD *)(v9 + 4 * sub_AB850((int *)&unk_2FE0C0)) = &dword_2FED64;
  v10 = v2[3];
  *(_DWORD *)(v10 + 4 * sub_AB850((int *)&unk_2FE0A8)) = &dword_2FE154;
  v11 = v2[3];
  *(_DWORD *)(v11 + 4 * sub_AB850((int *)&unk_2FEF10)) = &dword_2FE2B8;
  v12 = v2[3];
  *(_DWORD *)(v12 + 4 * sub_AB850((int *)&unk_2FEF20)) = &dword_2FE228;
  v13 = v2[3];
  *(_DWORD *)(v13 + 4 * sub_AB850((int *)&unk_2FEF1C)) = &dword_2FECDC;
  v14 = v2[3];
  *(_DWORD *)(v14 + 4 * sub_AB850((int *)&unk_2FEF04)) = &dword_2FE694;
  return v2;
}
// 18: using guessed type int;
// F0980: using guessed type void *;
// F09C0: using guessed type void *;
// F0A10: using guessed type void *;
// F0A50: using guessed type void *;
// F0A80: using guessed type void *off_F0A80;
// F0AA0: using guessed type void *;
// F0AD8: using guessed type void *;
// F0C00: using guessed type void *;
// F0C18: using guessed type void *;
// F0C30: using guessed type void *;
// F0C60: using guessed type void *;
// F0CD0: using guessed type void *off_F0CD0;
// F0CE0: using guessed type void *off_F0CE0;
// F0CF0: using guessed type void *off_F0CF0;
// F1838: using guessed type void *;
// F18B8: using guessed type void *;
// F1908: using guessed type void *;
// F1948: using guessed type void *;
// F1978: using guessed type void *off_F1978;
// F1998: using guessed type void *;
// F19D0: using guessed type void *;
// F1AF8: using guessed type void *;
// F1B10: using guessed type void *;
// F1B28: using guessed type void *;
// F1B58: using guessed type void *;
// F1BC8: using guessed type void *off_F1BC8;
// F1BD8: using guessed type void *off_F1BD8;
// F1BE8: using guessed type void *off_F1BE8;
// 2FE0E4: using guessed type int dword_2FE0E4;
// 2FE0E8: using guessed type int dword_2FE0E8;
// 2FE0EC: using guessed type int dword_2FE0EC;
// 2FE0F0: using guessed type int dword_2FE0F0;
// 2FE0F4: using guessed type int dword_2FE0F4;
// 2FE10C: using guessed type __int16 word_2FE10C;
// 2FE11C: using guessed type int dword_2FE11C;
// 2FE120: using guessed type int dword_2FE120;
// 2FE124: using guessed type int dword_2FE124;
// 2FE138: using guessed type int dword_2FE138;
// 2FE13C: using guessed type int dword_2FE13C;
// 2FE140: using guessed type int dword_2FE140;
// 2FE144: using guessed type int dword_2FE144;
// 2FE148: using guessed type int dword_2FE148;
// 2FE14C: using guessed type int dword_2FE14C;
// 2FE150: using guessed type int dword_2FE150;
// 2FE154: using guessed type int dword_2FE154;
// 2FE158: using guessed type int dword_2FE158;
// 2FE15C: using guessed type int dword_2FE15C;
// 2FE160: using guessed type int dword_2FE160;
// 2FE164: using guessed type int dword_2FE164;
// 2FE168: using guessed type int dword_2FE168;
// 2FE16C: using guessed type int dword_2FE16C;
// 2FE170: using guessed type int dword_2FE170;
// 2FE174: using guessed type int dword_2FE174;
// 2FE178: using guessed type int dword_2FE178;
// 2FE17C: using guessed type int dword_2FE17C;
// 2FE180: using guessed type int dword_2FE180;
// 2FE184: using guessed type int dword_2FE184;
// 2FE188: using guessed type int dword_2FE188;
// 2FE18C: using guessed type int dword_2FE18C;
// 2FE190: using guessed type int dword_2FE190;
// 2FE194: using guessed type int dword_2FE194;
// 2FE198: using guessed type int dword_2FE198;
// 2FE19C: using guessed type int dword_2FE19C;
// 2FE1A0: using guessed type int dword_2FE1A0;
// 2FE1A4: using guessed type int dword_2FE1A4;
// 2FE1A8: using guessed type int dword_2FE1A8;
// 2FE1AC: using guessed type int dword_2FE1AC;
// 2FE1B0: using guessed type int dword_2FE1B0;
// 2FE1B4: using guessed type int dword_2FE1B4;
// 2FE1B8: using guessed type int dword_2FE1B8;
// 2FE1BC: using guessed type int dword_2FE1BC;
// 2FE1C0: using guessed type int dword_2FE1C0;
// 2FE1C4: using guessed type int dword_2FE1C4;
// 2FE1C8: using guessed type int dword_2FE1C8;
// 2FE1CC: using guessed type int dword_2FE1CC;
// 2FE1D0: using guessed type int dword_2FE1D0;
// 2FE1D4: using guessed type int dword_2FE1D4;
// 2FE1D8: using guessed type int dword_2FE1D8;
// 2FE1DC: using guessed type int dword_2FE1DC;
// 2FE1E0: using guessed type int dword_2FE1E0;
// 2FE1E4: using guessed type int dword_2FE1E4;
// 2FE1E8: using guessed type int dword_2FE1E8;
// 2FE1EC: using guessed type int dword_2FE1EC;
// 2FE1F0: using guessed type int dword_2FE1F0;
// 2FE1F4: using guessed type int dword_2FE1F4;
// 2FE1F8: using guessed type int dword_2FE1F8;
// 2FE1FC: using guessed type int dword_2FE1FC;
// 2FE200: using guessed type int dword_2FE200;
// 2FE204: using guessed type int dword_2FE204;
// 2FE208: using guessed type int dword_2FE208;
// 2FE20C: using guessed type int dword_2FE20C;
// 2FE210: using guessed type int dword_2FE210;
// 2FE214: using guessed type int dword_2FE214;
// 2FE218: using guessed type char byte_2FE218;
// 2FE228: using guessed type int dword_2FE228;
// 2FE22C: using guessed type int dword_2FE22C;
// 2FE230: using guessed type int dword_2FE230;
// 2FE234: using guessed type int dword_2FE234;
// 2FE238: using guessed type char byte_2FE238;
// 2FE23C: using guessed type int dword_2FE23C;
// 2FE240: using guessed type int dword_2FE240;
// 2FE244: using guessed type int dword_2FE244;
// 2FE248: using guessed type int dword_2FE248;
// 2FE24C: using guessed type int dword_2FE24C;
// 2FE250: using guessed type int dword_2FE250;
// 2FE254: using guessed type int dword_2FE254;
// 2FE258: using guessed type int dword_2FE258;
// 2FE25C: using guessed type int dword_2FE25C;
// 2FE260: using guessed type char byte_2FE260;
// 2FE261: using guessed type char byte_2FE261;
// 2FE262: using guessed type char byte_2FE262;
// 2FE263: using guessed type char byte_2FE263;
// 2FE264: using guessed type char byte_2FE264;
// 2FE265: using guessed type char byte_2FE265;
// 2FE266: using guessed type char byte_2FE266;
// 2FE267: using guessed type char byte_2FE267;
// 2FE294: using guessed type char byte_2FE294;
// 2FE298: using guessed type int dword_2FE298;
// 2FE29C: using guessed type int dword_2FE29C;
// 2FE2B0: using guessed type int dword_2FE2B0;
// 2FE2B4: using guessed type int dword_2FE2B4;
// 2FE2B8: using guessed type int dword_2FE2B8;
// 2FE2BC: using guessed type int dword_2FE2BC;
// 2FE2C0: using guessed type int dword_2FE2C0;
// 2FE2C4: using guessed type int dword_2FE2C4;
// 2FE2C8: using guessed type char byte_2FE2C8;
// 2FE2CC: using guessed type int dword_2FE2CC;
// 2FE2D0: using guessed type int dword_2FE2D0;
// 2FE2D4: using guessed type int dword_2FE2D4;
// 2FE2D8: using guessed type int dword_2FE2D8;
// 2FE2DC: using guessed type int dword_2FE2DC;
// 2FE2E0: using guessed type int dword_2FE2E0;
// 2FE3DC: using guessed type char byte_2FE3DC;
// 2FE684: using guessed type int dword_2FE684;
// 2FE688: using guessed type int dword_2FE688;
// 2FE68C: using guessed type int dword_2FE68C;
// 2FE690: using guessed type int dword_2FE690;
// 2FE694: using guessed type int dword_2FE694;
// 2FE698: using guessed type int dword_2FE698;
// 2FE69C: using guessed type int dword_2FE69C;
// 2FE6A0: using guessed type int dword_2FE6A0;
// 2FE6A4: using guessed type int dword_2FE6A4;
// 2FE6A8: using guessed type int dword_2FE6A8;
// 2FE6AC: using guessed type int dword_2FE6AC;
// 2FE6B0: using guessed type int dword_2FE6B0;
// 2FE6B4: using guessed type int dword_2FE6B4;
// 2FE6B8: using guessed type int dword_2FE6B8;
// 2FE6BC: using guessed type int dword_2FE6BC;
// 2FE6C0: using guessed type int dword_2FE6C0;
// 2FE6C4: using guessed type int dword_2FE6C4;
// 2FE6C8: using guessed type int dword_2FE6C8;
// 2FE6CC: using guessed type int dword_2FE6CC;
// 2FE6D0: using guessed type int dword_2FE6D0;
// 2FE6D4: using guessed type int dword_2FE6D4;
// 2FE6D8: using guessed type int dword_2FE6D8;
// 2FE6DC: using guessed type int dword_2FE6DC;
// 2FE6E0: using guessed type int dword_2FE6E0;
// 2FE6E4: using guessed type int dword_2FE6E4;
// 2FE6E8: using guessed type int dword_2FE6E8;
// 2FE6EC: using guessed type int dword_2FE6EC;
// 2FE6F0: using guessed type int dword_2FE6F0;
// 2FE6F4: using guessed type int dword_2FE6F4;
// 2FE6F8: using guessed type int dword_2FE6F8;
// 2FE6FC: using guessed type int dword_2FE6FC;
// 2FE700: using guessed type int dword_2FE700;
// 2FE704: using guessed type int dword_2FE704;
// 2FE708: using guessed type int dword_2FE708;
// 2FE70C: using guessed type int dword_2FE70C;
// 2FE710: using guessed type int dword_2FE710;
// 2FE714: using guessed type int dword_2FE714;
// 2FE718: using guessed type int dword_2FE718;
// 2FE71C: using guessed type int dword_2FE71C;
// 2FE720: using guessed type int dword_2FE720;
// 2FE724: using guessed type int dword_2FE724;
// 2FE728: using guessed type int dword_2FE728;
// 2FE72C: using guessed type int dword_2FE72C;
// 2FE730: using guessed type int dword_2FE730;
// 2FE734: using guessed type int dword_2FE734;
// 2FE738: using guessed type int dword_2FE738;
// 2FE73C: using guessed type int dword_2FE73C;
// 2FE740: using guessed type int dword_2FE740;
// 2FE744: using guessed type int dword_2FE744;
// 2FE748: using guessed type int dword_2FE748;
// 2FE74C: using guessed type int dword_2FE74C;
// 2FE750: using guessed type int dword_2FE750;
// 2FE754: using guessed type int dword_2FE754;
// 2FE758: using guessed type char byte_2FE758;
// 2FE760: using guessed type int dword_2FE760;
// 2FE764: using guessed type int dword_2FE764;
// 2FE768: using guessed type int dword_2FE768;
// 2FE76C: using guessed type int dword_2FE76C;
// 2FE770: using guessed type int dword_2FE770;
// 2FE774: using guessed type int dword_2FE774;
// 2FE778: using guessed type int dword_2FE778;
// 2FE77C: using guessed type int dword_2FE77C;
// 2FE780: using guessed type int dword_2FE780;
// 2FE784: using guessed type int dword_2FE784;
// 2FE788: using guessed type int dword_2FE788;
// 2FE78C: using guessed type int dword_2FE78C;
// 2FE790: using guessed type int dword_2FE790;
// 2FE794: using guessed type int dword_2FE794;
// 2FE798: using guessed type int dword_2FE798;
// 2FE79C: using guessed type int dword_2FE79C;
// 2FE7A0: using guessed type int dword_2FE7A0;
// 2FE7A4: using guessed type int dword_2FE7A4;
// 2FEC98: using guessed type int dword_2FEC98;
// 2FEC9C: using guessed type int dword_2FEC9C;
// 2FECA0: using guessed type int dword_2FECA0;
// 2FECA4: using guessed type int dword_2FECA4;
// 2FECA8: using guessed type char byte_2FECA8;
// 2FECA9: using guessed type char byte_2FECA9;
// 2FECAA: using guessed type char byte_2FECAA;
// 2FECAC: using guessed type int dword_2FECAC;
// 2FECB0: using guessed type int dword_2FECB0;
// 2FECB4: using guessed type int dword_2FECB4;
// 2FECB8: using guessed type int dword_2FECB8;
// 2FECBC: using guessed type int dword_2FECBC;
// 2FECC0: using guessed type int dword_2FECC0;
// 2FECC4: using guessed type int dword_2FECC4;
// 2FECC8: using guessed type char byte_2FECC8;
// 2FECC9: using guessed type char byte_2FECC9;
// 2FECCA: using guessed type char byte_2FECCA;
// 2FECCB: using guessed type char byte_2FECCB;
// 2FECCC: using guessed type char byte_2FECCC;
// 2FECCD: using guessed type char byte_2FECCD;
// 2FECCE: using guessed type char byte_2FECCE;
// 2FECCF: using guessed type char byte_2FECCF;
// 2FECDB: using guessed type char byte_2FECDB;
// 2FECDC: using guessed type int dword_2FECDC;
// 2FECE0: using guessed type int dword_2FECE0;
// 2FECE4: using guessed type int dword_2FECE4;
// 2FECE8: using guessed type int dword_2FECE8;
// 2FECEC: using guessed type char byte_2FECEC;
// 2FECF0: using guessed type int dword_2FECF0;
// 2FECF4: using guessed type int dword_2FECF4;
// 2FECF8: using guessed type int dword_2FECF8;
// 2FECFC: using guessed type int dword_2FECFC;
// 2FED00: using guessed type int dword_2FED00;
// 2FED04: using guessed type int dword_2FED04;
// 2FED08: using guessed type int dword_2FED08;
// 2FED0C: using guessed type int dword_2FED0C;
// 2FED10: using guessed type int dword_2FED10;
// 2FED14: using guessed type char byte_2FED14;
// 2FED15: using guessed type char byte_2FED15;
// 2FED16: using guessed type char byte_2FED16;
// 2FED17: using guessed type char byte_2FED17;
// 2FED18: using guessed type char byte_2FED18;
// 2FED19: using guessed type char byte_2FED19;
// 2FED1A: using guessed type char byte_2FED1A;
// 2FED1B: using guessed type char byte_2FED1B;
// 2FED48: using guessed type char byte_2FED48;
// 2FED4C: using guessed type int dword_2FED4C;
// 2FED50: using guessed type int dword_2FED50;
// 2FED54: using guessed type int dword_2FED54;
// 2FED64: using guessed type int dword_2FED64;
// 2FED68: using guessed type int dword_2FED68;
// 2FED6C: using guessed type int dword_2FED6C;
// 2FED70: using guessed type int dword_2FED70;
// 2FED74: using guessed type char byte_2FED74;
// 2FED75: using guessed type char byte_2FED75;
// 2FED76: using guessed type char byte_2FED76;
// 2FED78: using guessed type int dword_2FED78;
// 2FED7C: using guessed type int dword_2FED7C;
// 2FED80: using guessed type int dword_2FED80;
// 2FED84: using guessed type int dword_2FED84;
// 2FED88: using guessed type int dword_2FED88;
// 2FED8C: using guessed type int dword_2FED8C;
// 2FED90: using guessed type int dword_2FED90;
// 2FED94: using guessed type char byte_2FED94;
// 2FED95: using guessed type char byte_2FED95;
// 2FED96: using guessed type char byte_2FED96;
// 2FED97: using guessed type char byte_2FED97;
// 2FED98: using guessed type char byte_2FED98;
// 2FED99: using guessed type char byte_2FED99;
// 2FED9A: using guessed type char byte_2FED9A;
// 2FED9B: using guessed type char byte_2FED9B;
// 2FEDA7: using guessed type char byte_2FEDA7;
// 2FEDA8: using guessed type int dword_2FEDA8;
// 2FEDAC: using guessed type int dword_2FEDAC;
// 2FEDB0: using guessed type int dword_2FEDB0;
// 2FEDB4: using guessed type int dword_2FEDB4;
// 2FEDB8: using guessed type int dword_2FEDB8;
// 2FEDBC: using guessed type int dword_2FEDBC;
// 2FEDC0: using guessed type char byte_2FEDC0;
// 2FEDC4: using guessed type int dword_2FEDC4;
// 2FEDC8: using guessed type int dword_2FEDC8;
// 2FEDCC: using guessed type int dword_2FEDCC;
// 2FEDD0: using guessed type int dword_2FEDD0;
// 2FEDD4: using guessed type char byte_2FEDD4;
// 2FEDD5: using guessed type char byte_2FEDD5;
// 2FEE14: using guessed type char byte_2FEE14;
// 2FEE18: using guessed type int dword_2FEE18;
// 2FEE1C: using guessed type int dword_2FEE1C;
// 2FEE94: using guessed type int dword_2FEE94;
// 2FEE98: using guessed type int dword_2FEE98;

//----- (000A9334) --------------------------------------------------------
_DWORD *sub_A9334()
{
  _DWORD *result; // r0

  result = sub_A8880(&unk_2FE0F8, 2);
  dword_2FEEB8 = (int)&unk_2FE0F8;
  dword_2FEEBC = (int)&unk_2FE0F8;
  return result;
}
// 2FEEB8: using guessed type int dword_2FEEB8;
// 2FEEBC: using guessed type int dword_2FEEBC;

//----- (000A9360) --------------------------------------------------------
_DWORD *sub_A9360()
{
  _DWORD *result; // r0

  result = (_DWORD *)pthread_once((pthread_once_t *)&unk_2FEEB4, (void (*)(void))sub_A9334);
  if ( !dword_2FEEB8 )
  {
    result = sub_A8880(&unk_2FE0F8, 2);
    dword_2FEEB8 = (int)&unk_2FE0F8;
    dword_2FEEBC = (int)&unk_2FE0F8;
  }
  return result;
}
// 2FEEB8: using guessed type int dword_2FEEB8;
// 2FEEBC: using guessed type int dword_2FEEBC;

//----- (000A93A8) --------------------------------------------------------
_DWORD *__fastcall sub_A93A8(_DWORD *a1)
{
  _DWORD *v1; // r4
  unsigned int *v2; // r2
  pthread_mutex_t *v3; // r6
  unsigned int *v4; // r3
  unsigned int v5; // r1
  _DWORD *result; // r0
  unsigned int v7; // r1

  *a1 = 0;
  v1 = a1;
  sub_A9360();
  v2 = (unsigned int *)dword_2FEEBC;
  *v1 = dword_2FEEBC;
  if ( v2 == (unsigned int *)dword_2FEEB8 )
  {
    __dmb(0xFu);
    do
      v7 = __ldrex(v2);
    while ( __strex(v7 + 1, v2) );
    __dmb(0xFu);
    result = v1;
  }
  else
  {
    v3 = (pthread_mutex_t *)sub_A8848();
    if ( pthread_mutex_lock(v3) )
      sub_93480();
    v4 = (unsigned int *)dword_2FEEBC;
    __dmb(0xFu);
    do
      v5 = __ldrex(v4);
    while ( __strex(v5 + 1, v4) );
    __dmb(0xFu);
    *v1 = dword_2FEEBC;
    if ( pthread_mutex_unlock(v3) )
      sub_934A8();
    result = v1;
  }
  return result;
}
// 2FEEB8: using guessed type int dword_2FEEB8;
// 2FEEBC: using guessed type int dword_2FEEBC;

//----- (000A9544) --------------------------------------------------------
const char *__fastcall sub_A9544(char a1)
{
  const char *result; // r0

  switch ( a1 & 0x3D )
  {
    case 1:
    case 0x11:
      result = (const char *)&off_E2EC8;
      break;
    case 5:
      result = (const char *)&unk_E2EE4;
      break;
    case 8:
      result = (const char *)&unk_E2ED0;
      break;
    case 9:
      result = (const char *)&unk_E2EDC;
      break;
    case 0xC:
      result = (const char *)&unk_E2EE8;
      break;
    case 0xD:
      result = (const char *)&unk_E2ECC;
      break;
    case 0x10:
    case 0x30:
      result = "w";
      break;
    case 0x14:
      result = (const char *)&unk_E2EE0;
      break;
    case 0x15:
      result = (const char *)&unk_E2EE4;
      break;
    case 0x18:
      result = (const char *)&unk_E2ED4;
      break;
    case 0x19:
      result = (const char *)&unk_E2EDC;
      break;
    case 0x1C:
      result = (const char *)&unk_E2EEC;
      break;
    case 0x1D:
      result = (const char *)&unk_E2ECC;
      break;
    case 0x34:
      result = (const char *)&unk_E2EE0;
      break;
    case 0x38:
      result = (const char *)&unk_E2ED8;
      break;
    case 0x3C:
      result = (const char *)&unk_E2EF0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// E2EC8: using guessed type void *off_E2EC8;

//----- (000A9634) --------------------------------------------------------
int __fastcall sub_A9634(int fd, void *buf, size_t n)
{
  size_t v3; // r7
  int v4; // r6
  char *v5; // r5
  size_t v6; // r4
  ssize_t v7; // r0
  int v8; // r1
  int v9; // r2

  v3 = n;
  v4 = fd;
  v5 = (char *)buf;
  v6 = n;
  do
  {
    while ( 1 )
    {
      v7 = write(v4, v5, v6);
      if ( v7 == -1 )
        break;
      v6 -= v7;
      v5 += v7;
      if ( !v6 )
        return v3 - v6;
    }
  }
  while ( *(_DWORD *)_errno(-1, v8, v9) == 4 );
  return v3 - v6;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000A9664) --------------------------------------------------------
int __fastcall sub_A9664(int result)
{
  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 0;
  return result;
}

//----- (000A966C) --------------------------------------------------------
_DWORD *__fastcall sub_A966C(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r5
  int v5; // r0
  int v6; // r1
  int v7; // r2

  v3 = a1;
  v4 = a2;
  if ( *a1 || !a2 )
    return 0;
  *(_DWORD *)_errno(a1, a2, a3) = 0;
  while ( 1 )
  {
    v5 = fflush((FILE *)*v3);
    if ( !v5 )
      break;
    if ( *(_DWORD *)_errno(v5, v6, v7) != 4 )
      return 0;
  }
  *((_BYTE *)v3 + 4) = 0;
  *v3 = v4;
  return v3;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000A96A0) --------------------------------------------------------
int __fastcall sub_A96A0(int a1, int a2, char a3)
{
  int v3; // r4
  int v4; // r5
  const char *v5; // r0
  FILE *v7; // r0

  v3 = a1;
  v4 = a2;
  v5 = sub_A9544(a3);
  if ( !v5 )
    return 0;
  if ( *(_DWORD *)v3 )
    return 0;
  v7 = fdopen(v4, v5);
  *(_DWORD *)v3 = v7;
  if ( !v7 )
    return 0;
  *(_BYTE *)(v3 + 4) = 1;
  if ( !v4 )
    setvbuf(v7, 0, 2, 0);
  return v3;
}

//----- (000A96E8) --------------------------------------------------------
int __fastcall sub_A96E8(int a1, const char *a2, char a3)
{
  int v3; // r4
  const char *v4; // r5
  const char *v5; // r1
  int result; // r0
  FILE *v7; // r0

  v3 = a1;
  v4 = a2;
  v5 = sub_A9544(a3);
  if ( !v5 )
    return 0;
  if ( *(_DWORD *)v3 )
    return 0;
  v7 = fopen(v4, v5);
  *(_DWORD *)v3 = v7;
  if ( !v7 )
    return 0;
  result = v3;
  *(_BYTE *)(v3 + 4) = 1;
  return result;
}

//----- (000A9714) --------------------------------------------------------
bool __fastcall sub_A9714(_DWORD *a1)
{
  return *a1 != 0;
}

//----- (000A972C) --------------------------------------------------------
_DWORD *__fastcall sub_A972C(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  _DWORD *result; // r0
  int v5; // r0
  int v6; // r1
  int v7; // r2

  v3 = a1;
  result = (_DWORD *)*a1;
  if ( result )
  {
    if ( *((_BYTE *)v3 + 4) )
    {
      *(_DWORD *)_errno(result, a2, a3) = 0;
      while ( 1 )
      {
        v5 = fclose((FILE *)*v3);
        if ( !v5 )
          break;
        if ( *(_DWORD *)_errno(v5, v6, v7) != 4 )
        {
          result = 0;
          *v3 = 0;
          return result;
        }
      }
      *v3 = 0;
      result = v3;
    }
    else
    {
      *v3 = *((unsigned __int8 *)v3 + 4);
      result = v3;
    }
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000A9768) --------------------------------------------------------
_DWORD *__fastcall sub_A9768(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4

  v3 = a1;
  sub_A972C(a1, a2, a3);
  return v3;
}

//----- (000A9774) --------------------------------------------------------
ssize_t __fastcall sub_A9774(int a1, void *a2, size_t a3)
{
  int v3; // r7
  void *v4; // r6
  size_t v5; // r5
  ssize_t result; // r0
  int v7; // r1
  int v8; // r2
  ssize_t v9; // r4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  while ( 1 )
  {
    result = read(*(signed __int16 *)(*(_DWORD *)v3 + 14), v4, v5);
    v9 = result;
    if ( result != -1 )
      break;
    if ( *(_DWORD *)_errno(-1, v7, v8) != 4 )
      return v9;
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000A97A4) --------------------------------------------------------
int __fastcall sub_A97A4(int a1, void *a2, size_t a3)
{
  return sub_A9634(*(signed __int16 *)(*(_DWORD *)a1 + 14), a2, a3);
}

//----- (000A97B0) --------------------------------------------------------
int __fastcall sub_A97B0(int *a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r2
  int v7; // r11
  int v8; // r10
  int v9; // r9
  int v10; // r6
  int v11; // r5
  ssize_t v12; // r0
  int v13; // r1
  int v14; // r2
  bool v15; // nf
  int v16; // r2
  int v18; // [sp+0h] [bp-38h]
  int v19; // [sp+4h] [bp-34h]
  int v20; // [sp+8h] [bp-30h]
  int v21; // [sp+Ch] [bp-2Ch]

  v5 = a3;
  v6 = *a1;
  v7 = a2;
  v8 = a4;
  v20 = a4;
  v9 = v5 + a5;
  v10 = *(signed __int16 *)(v6 + 14);
  v21 = a5;
  v11 = v5 + a5;
  do
  {
    while ( 1 )
    {
      v18 = v7;
      v19 = v5;
      v12 = writev(v10, (const struct iovec *)&v18, 2);
      if ( v12 == -1 )
        break;
      v11 -= v12;
      v7 += v12;
      if ( !v11 )
        return v9 - v11;
      v16 = v12 - v5;
      v15 = v12 - v5 < 0;
      v5 -= v12;
      if ( !v15 )
        return v9 - (v11 - sub_A9634(v10, (void *)(v8 + v16), a5 - v16));
    }
  }
  while ( *(_DWORD *)_errno(-1, v13, v14) == 4 );
  return v9 - v11;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000A9824) --------------------------------------------------------
signed __int64 __fastcall sub_A9824(int a1, int a2, __int64 offset, int whence)
{
  bool v4; // cf
  signed __int64 result; // r0

  v4 = (unsigned int)((unsigned __int64)(offset + 0x80000000LL) >> 32) >= 1;
  if ( (unsigned __int64)(offset + 0x80000000LL) >> 32 == 1 )
    v4 = 1;
  if ( v4 )
    result = -1LL;
  else
    result = lseek(*(signed __int16 *)(*(_DWORD *)a1 + 14), offset, whence);
  return result;
}

//----- (000A9868) --------------------------------------------------------
int __fastcall sub_A9868(_DWORD *a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  int result; // r0
  int v4; // r3
  int v5; // r3
  int v6; // r4
  int v7; // [sp+4h] [bp-84h]
  struct pollfd fds; // [sp+8h] [bp-80h]
  char v9; // [sp+10h] [bp-78h]
  int v10; // [sp+20h] [bp-68h]
  int v11; // [sp+40h] [bp-48h]

  v1 = *a1;
  v2 = a1;
  v7 = 0;
  if ( ioctl(*(signed __int16 *)(v1 + 14), 0x541Bu, &v7) || (result = v7, v7 < 0) )
  {
    v4 = *v2;
    fds.events = 1;
    fds.fd = *(signed __int16 *)(v4 + 14);
    if ( poll(&fds, 1u, 0) <= 0 || fstat(*(signed __int16 *)(*v2 + 14), (struct stat *)&v9) || (v10 & 0xF000) != 0x8000 )
    {
      result = 0;
    }
    else
    {
      v5 = *v2;
      v6 = v11;
      result = v6 - lseek(*(signed __int16 *)(v5 + 14), 0, 1);
    }
  }
  return result;
}

//----- (000A98E0) --------------------------------------------------------
_DWORD *__fastcall sub_A98E0(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  _DWORD *v4; // r8
  _BYTE *v5; // r7
  int v6; // r9
  int v7; // r10
  signed int v8; // r3
  int v9; // r5
  unsigned __int8 *v10; // r3
  int v11; // r0
  int v12; // r3
  _BYTE *v13; // r6
  signed int v14; // r4
  _BYTE *v15; // r0
  void *v16; // r0
  int v17; // r2
  unsigned int v18; // r0
  int v19; // r3
  int v20; // r2
  unsigned int v22; // r3
  unsigned int v23; // r1
  int v24; // r2
  unsigned int v25; // r3
  unsigned int v26; // r2
  unsigned __int8 v27; // [sp+4h] [bp-24h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  a1[1] = 0;
  v7 = a4;
  sub_A0718(&v27, a1, 1);
  v8 = v27;
  if ( v27 )
  {
    v9 = *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 120);
    v10 = *(unsigned __int8 **)(v9 + 8);
    if ( (unsigned int)v10 >= *(_DWORD *)(v9 + 12) )
      v11 = sub_25E78(*(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 120));
    else
LABEL_3:
      v11 = *v10;
LABEL_4:
    v12 = v4[1];
    while ( 1 )
    {
      v20 = v12 + 1;
      if ( v12 + 1 >= v6 )
        break;
      if ( v11 == -1 )
        goto LABEL_15;
      if ( v11 == v7 )
        goto LABEL_24;
      v13 = *(_BYTE **)(v9 + 8);
      v14 = v6 - v12 - 1;
      if ( v14 >= *(_DWORD *)(v9 + 12) - (signed int)v13 )
        v14 = *(_DWORD *)(v9 + 12) - (_DWORD)v13;
      if ( v14 <= 1 )
      {
        *v5++ = v11;
        v25 = *(_DWORD *)(v9 + 8);
        v26 = *(_DWORD *)(v9 + 12);
        ++v4[1];
        if ( v25 >= v26 )
        {
          v11 = sub_25E84(v9);
          if ( v11 == -1 )
            goto LABEL_4;
          v10 = *(unsigned __int8 **)(v9 + 8);
          v26 = *(_DWORD *)(v9 + 12);
        }
        else
        {
          v10 = (unsigned __int8 *)(v25 + 1);
          *(_DWORD *)(v9 + 8) = v10;
        }
        if ( v26 > (unsigned int)v10 )
          goto LABEL_3;
        v11 = sub_25E78(v9);
        goto LABEL_4;
      }
      v15 = memchr(*(const void **)(v9 + 8), v7, v14);
      if ( v15 )
        v14 = v15 - v13;
      v16 = v5;
      v5 += v14;
      memcpy(v16, v13, v14);
      v17 = *(_DWORD *)(v9 + 8);
      v18 = *(_DWORD *)(v9 + 12);
      v19 = v4[1];
      *(_DWORD *)(v9 + 8) = v17 + v14;
      v12 = v19 + v14;
      v4[1] = v12;
      if ( v17 + v14 >= v18 )
      {
        v11 = (*(int (__fastcall **)(int))(*(_DWORD *)v9 + 36))(v9);
        goto LABEL_4;
      }
      v11 = *(unsigned __int8 *)(v17 + v14);
    }
    if ( v11 == -1 )
    {
LABEL_15:
      v8 = 2;
      goto LABEL_16;
    }
    if ( v11 == v7 )
    {
LABEL_24:
      v22 = *(_DWORD *)(v9 + 8);
      v23 = *(_DWORD *)(v9 + 12);
      v4[1] = v20;
      if ( v22 >= v23 )
      {
        sub_25E84(v9);
        v8 = 0;
      }
      else
      {
        v24 = v22 + 1;
        v8 = 0;
        *(_DWORD *)(v9 + 8) = v24;
      }
    }
    else
    {
      v8 = 4;
    }
  }
LABEL_16:
  if ( v6 > 0 )
    *v5 = 0;
  if ( !v4[1] )
  {
    v8 |= 4u;
LABEL_20:
    sub_93F84((_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12)), *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 20) | v8);
    return v4;
  }
  if ( v8 )
    goto LABEL_20;
  return v4;
}

//----- (000AA0A8) --------------------------------------------------------
_DWORD *__fastcall sub_AA0A8(_DWORD *a1, int *a2, int a3)
{
  _DWORD *v3; // r9
  int *v4; // r7
  int v5; // r6
  int v6; // r3
  _DWORD *v8; // r4
  unsigned __int8 *v9; // r11
  unsigned int v10; // r3
  int v11; // r0
  int v12; // r5
  unsigned int v13; // r5
  signed int v14; // r10
  _BYTE *v15; // r0
  int v16; // r2
  unsigned int v17; // r3
  signed int v18; // r3
  int v19; // r3
  char v20; // r11
  int v21; // r2
  int v22; // r10
  int v23; // r2
  unsigned int v24; // r2
  unsigned int v25; // r3
  unsigned __int8 *v26; // r2
  char v27; // [sp+4h] [bp-2Ch]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  sub_A0718(&v27, a1, 1);
  if ( !v27 )
    goto LABEL_2;
  sub_C0AFC(v4, 0, *(_DWORD *)(*v4 - 12), 0);
  v8 = *(_DWORD **)((char *)v3 + *(_DWORD *)(*v3 - 12) + 120);
  v9 = (unsigned __int8 *)v8[2];
  v10 = v8[3];
  if ( (unsigned int)v9 >= v10 )
  {
    v11 = sub_25E78(*(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 120));
    if ( v11 == -1 )
    {
LABEL_46:
      v18 = 2;
      goto LABEL_31;
    }
    v9 = (unsigned __int8 *)v8[2];
    v10 = v8[3];
  }
  else
  {
    v11 = *v9;
  }
  if ( v5 == v11 )
  {
    v12 = 1;
LABEL_27:
    if ( (unsigned int)v9 >= v10 )
      sub_25E84((int)v8);
    else
      v8[2] = v9 + 1;
    if ( v12 )
      return v3;
    v18 = 0;
LABEL_31:
    v6 = v18 | 4;
    goto LABEL_3;
  }
  v13 = 0;
  while ( 1 )
  {
    v14 = v10 - (_DWORD)v9;
    if ( (signed int)(1073741820 - v13) < (signed int)(v10 - (_DWORD)v9) )
      v14 = 1073741820 - v13;
    if ( v14 <= 1 )
    {
      v19 = *v4;
      v20 = v11;
      v21 = *(_DWORD *)(*v4 - 12);
      v22 = v21 + 1;
      if ( (unsigned int)(v21 + 1) > *(_DWORD *)(*v4 - 8) || *(_DWORD *)(v19 - 4) > 0 )
      {
        sub_C1264(v4, v21 + 1);
        v19 = *v4;
        v21 = *(_DWORD *)(*v4 - 12);
      }
      *(_BYTE *)(v19 + v21) = v20;
      ++v13;
      v23 = *v4;
      if ( (int *)(*v4 - 12) != &dword_2FEF3C )
      {
        *(_DWORD *)(v23 - 12) = v22;
        *(_DWORD *)(v23 - 4) = 0;
        *(_BYTE *)(v23 + v22) = 0;
      }
      v24 = v8[2];
      v25 = v8[3];
      if ( v24 >= v25 )
      {
        v11 = sub_25E84((int)v8);
        if ( v11 == -1 )
          goto LABEL_19;
        v26 = (unsigned __int8 *)v8[2];
        v25 = v8[3];
      }
      else
      {
        v26 = (unsigned __int8 *)(v24 + 1);
        v8[2] = v26;
      }
      v11 = (unsigned int)v26 >= v25 ? sub_25E78((int)v8) : *v26;
    }
    else
    {
      v15 = memchr(v9, v5, v14);
      if ( v15 )
        v14 = v15 - v9;
      sub_C13F8((unsigned int *)v4, (unsigned int)v9, v14);
      v16 = v8[2];
      v13 += v14;
      v17 = v8[3];
      v8[2] = v16 + v14;
      v11 = v16 + v14 >= v17 ? (*(int (__fastcall **)(_DWORD *))(*v8 + 36))(v8) : *(unsigned __int8 *)(v16 + v14);
    }
LABEL_19:
    if ( v13 > 0x3FFFFFFB )
      break;
    if ( v11 == -1 )
    {
      if ( !v13 )
        goto LABEL_46;
      goto LABEL_22;
    }
    if ( v5 == v11 )
    {
      v9 = (unsigned __int8 *)v8[2];
      v12 = v13 + 1;
      v10 = v8[3];
      goto LABEL_27;
    }
    v9 = (unsigned __int8 *)v8[2];
    v10 = v8[3];
  }
  if ( v11 == -1 )
  {
LABEL_22:
    v6 = 2;
    goto LABEL_3;
  }
  if ( v5 == v11 )
  {
    v9 = (unsigned __int8 *)v8[2];
    v12 = v13 + 1;
    v10 = v8[3];
    goto LABEL_27;
  }
LABEL_2:
  v6 = 4;
LABEL_3:
  sub_93F84((_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12)), *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | v6);
  return v3;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000AA2C8) --------------------------------------------------------
_DWORD *__fastcall sub_AA2C8(_DWORD *a1, wchar_t *a2, int a3, int a4)
{
  _DWORD *v4; // r8
  wchar_t *v5; // r7
  int v6; // r9
  int v7; // r10
  signed int v8; // r3
  _DWORD *v9; // r5
  int *v10; // r3
  int v11; // r6
  int v12; // r4
  int v13; // r3
  unsigned int v14; // r3
  const wchar_t *v15; // r0
  int v16; // r4
  wchar_t *v17; // r0
  const wchar_t *v18; // r1
  int v19; // r1
  unsigned int v20; // r0
  unsigned int v21; // r3
  int v22; // r6
  int v23; // r2
  unsigned int v25; // r2
  unsigned int v26; // r1
  int v27; // r0
  unsigned __int8 v28; // [sp+4h] [bp-24h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  a1[1] = 0;
  v7 = a4;
  sub_A2468(&v28, a1, 1);
  v8 = v28;
  if ( !v28 )
    goto LABEL_18;
  v9 = *(_DWORD **)((char *)v4 + *(_DWORD *)(*v4 - 12) + 124);
  v10 = (int *)v9[2];
  if ( (unsigned int)v10 >= v9[3] )
  {
    v27 = sub_25E90(*(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 124));
LABEL_32:
    v11 = v27;
  }
  else
  {
LABEL_3:
    v11 = *v10;
  }
LABEL_4:
  v12 = v4[1];
  v13 = v12 + 1;
  if ( v12 + 1 < v6 )
  {
    while ( v11 != -1 )
    {
      if ( v7 == v11 )
        goto LABEL_23;
      v14 = v9[3];
      v15 = (const wchar_t *)v9[2];
      v16 = v6 - v12 - 1;
      if ( v16 >= (signed int)(v14 - (_DWORD)v15) >> 2 )
        v16 = (signed int)(v14 - (_DWORD)v15) >> 2;
      if ( v16 <= 1 )
      {
        *(_DWORD *)v5 = v11;
        v5 += 2;
        ++v4[1];
        if ( v14 <= (unsigned int)v15 )
        {
          v11 = sub_25E9C((int)v9);
        }
        else
        {
          v11 = *(_DWORD *)v15;
          v9[2] = v15 + 2;
        }
        if ( v11 == -1 )
          goto LABEL_4;
        v10 = (int *)v9[2];
        if ( (unsigned int)v10 < v9[3] )
          goto LABEL_3;
        v27 = sub_25E90((int)v9);
        goto LABEL_32;
      }
      v17 = wmemchr(v15, v7, v16);
      v18 = (const wchar_t *)v9[2];
      if ( v17 )
        v16 = ((char *)v17 - (char *)v18) >> 2;
      wmemcpy(v5, v18, v16);
      v19 = v9[2];
      v20 = v9[3];
      v21 = v19 + 4 * v16;
      v22 = v4[1];
      v5 += 2 * v16;
      v9[2] = v21;
      v23 = v16 + v22;
      v4[1] = v16 + v22;
      if ( v21 >= v20 )
      {
        v27 = (*(int (__fastcall **)(_DWORD *))(*v9 + 36))(v9);
        goto LABEL_32;
      }
      v11 = *(_DWORD *)(v19 + 4 * v16);
      v12 = v23;
      v13 = v23 + 1;
      if ( v23 + 1 >= v6 )
        goto LABEL_14;
    }
    goto LABEL_33;
  }
LABEL_14:
  if ( v11 == -1 )
  {
LABEL_33:
    v8 = 2;
    goto LABEL_18;
  }
  if ( v7 == v11 )
  {
LABEL_23:
    v25 = v9[2];
    v26 = v9[3];
    v4[1] = v13;
    if ( v25 >= v26 )
      sub_25E9C((int)v9);
    else
      v9[2] = v25 + 4;
    v8 = 0;
  }
  else
  {
    v8 = 4;
  }
LABEL_18:
  if ( v6 > 0 )
    *(_DWORD *)v5 = 0;
  if ( !v4[1] )
  {
    v8 |= 4u;
LABEL_22:
    sub_94410((_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12)), *(_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12) + 20) | v8);
    return v4;
  }
  if ( v8 )
    goto LABEL_22;
  return v4;
}

//----- (000AA64C) --------------------------------------------------------
_DWORD *__fastcall sub_AA64C(_DWORD *a1, const wchar_t **a2, int a3)
{
  const wchar_t **v3; // r7
  int v4; // r8
  int v5; // r3
  _DWORD *v7; // r4
  int *v8; // r3
  int v9; // r6
  int v10; // r5
  unsigned int v11; // r5
  unsigned int v12; // r12
  const wchar_t *v13; // r0
  int v14; // r10
  wchar_t *v15; // r0
  unsigned int v16; // r1
  int v17; // r3
  unsigned int v18; // r1
  unsigned int v19; // r2
  unsigned int v20; // r3
  signed int v21; // r3
  const wchar_t *v22; // r3
  int v23; // r1
  int v24; // r10
  int *v25; // r3
  int v26; // r0
  _DWORD *v27; // [sp+4h] [bp-34h]
  char v28; // [sp+Ch] [bp-2Ch]

  v3 = a2;
  v4 = a3;
  v27 = a1;
  sub_A2468(&v28, a1, 1);
  if ( !v28 )
  {
LABEL_2:
    v5 = 4;
LABEL_3:
    sub_94410(
      (_DWORD *)((char *)v27 + *(_DWORD *)(*v27 - 12)),
      *(_DWORD *)((char *)v27 + *(_DWORD *)(*v27 - 12) + 20) | v5);
    return v27;
  }
  sub_B9E18(v3, 0, *((_DWORD *)*v3 - 3), 0);
  v7 = *(_DWORD **)((char *)v27 + *(_DWORD *)(*v27 - 12) + 124);
  v8 = (int *)v7[2];
  if ( (unsigned int)v8 >= v7[3] )
    v9 = sub_25E90(*(_DWORD *)((char *)v27 + *(_DWORD *)(*v27 - 12) + 124));
  else
    v9 = *v8;
  if ( v9 == -1 )
  {
LABEL_47:
    v21 = 2;
LABEL_30:
    v5 = v21 | 4;
    goto LABEL_3;
  }
  if ( v4 == v9 )
  {
    v10 = 1;
    goto LABEL_26;
  }
  v11 = 0;
  while ( 1 )
  {
    v12 = v7[3];
    v13 = (const wchar_t *)v7[2];
    v14 = (signed int)(v12 - (_DWORD)v13) >> 2;
    if ( (signed int)(268435454 - v11) < v14 )
      v14 = 268435454 - v11;
    if ( v14 > 1 )
    {
      v15 = wmemchr(v13, v4, v14);
      v16 = v7[2];
      if ( v15 )
        v14 = (signed int)((signed int)v15 - v16) >> 2;
      sub_BA748((int *)v3, v16, v14);
      v17 = v7[2];
      v11 += v14;
      v18 = v7[3];
      v19 = v17 + 4 * v14;
      v7[2] = v19;
      if ( v19 < v18 )
      {
        v9 = *(_DWORD *)(v17 + 4 * v14);
        goto LABEL_19;
      }
      v26 = (*(int (__fastcall **)(_DWORD *))(*v7 + 36))(v7);
LABEL_42:
      v9 = v26;
      goto LABEL_19;
    }
    v22 = *v3;
    v23 = *((_DWORD *)*v3 - 3);
    v24 = v23 + 1;
    if ( (unsigned int)(v23 + 1) > *((_DWORD *)*v3 - 2) || *((_DWORD *)v22 - 1) > 0 )
    {
      sub_BA5B8((int *)v3, v23 + 1);
      v22 = *v3;
      v13 = (const wchar_t *)v7[2];
      v12 = v7[3];
      v23 = *((_DWORD *)*v3 - 3);
    }
    *(_DWORD *)&v22[2 * v23] = v9;
    ++v11;
    if ( v22 - 6 != (const wchar_t *)&unk_2FEF24 )
    {
      *((_DWORD *)v22 - 3) = v24;
      *((_DWORD *)v22 - 1) = 0;
      *(_DWORD *)&v22[2 * v24] = 0;
    }
    if ( (unsigned int)v13 >= v12 )
    {
      v9 = sub_25E9C((int)v7);
    }
    else
    {
      v9 = *(_DWORD *)v13;
      v7[2] = v13 + 2;
    }
    if ( v9 != -1 )
    {
      v25 = (int *)v7[2];
      if ( (unsigned int)v25 < v7[3] )
      {
        v9 = *v25;
        goto LABEL_19;
      }
      v26 = sub_25E90((int)v7);
      goto LABEL_42;
    }
LABEL_19:
    if ( v11 > 0xFFFFFFD )
      break;
    if ( v9 == -1 )
    {
      if ( !v11 )
        goto LABEL_47;
      goto LABEL_22;
    }
    if ( v4 == v9 )
      goto LABEL_25;
  }
  if ( v9 == -1 )
  {
LABEL_22:
    v5 = 2;
    goto LABEL_3;
  }
  if ( v4 != v9 )
    goto LABEL_2;
LABEL_25:
  v10 = v11 + 1;
LABEL_26:
  v20 = v7[2];
  if ( v20 >= v7[3] )
    sub_25E9C((int)v7);
  else
    v7[2] = v20 + 4;
  if ( !v10 )
  {
    v21 = 0;
    goto LABEL_30;
  }
  return v27;
}

//----- (000AA858) --------------------------------------------------------
int __fastcall sub_AA858(int a1, int a2)
{
  return a2;
}

//----- (000AA85C) --------------------------------------------------------
int __fastcall sub_AA85C(int a1, int a2)
{
  return a2;
}

//----- (000AA860) --------------------------------------------------------
int __fastcall sub_AA860(int a1, const void *a2, int a3, void *a4)
{
  int v4; // r4

  v4 = a3;
  memcpy(a4, a2, a3 - (_DWORD)a2);
  return v4;
}

//----- (000AA870) --------------------------------------------------------
int __fastcall sub_AA870(void *dest, const void *a2, int a3, int a4, void *desta)
{
  int v5; // r4

  v5 = a3;
  memcpy(desta, a2, a3 - (_DWORD)a2);
  return v5;
}

//----- (000AA880) --------------------------------------------------------
_DWORD *__fastcall sub_AA880(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F15A8;
  sub_A8038(a1 + 2);
  *v1 = &off_F1878;
  sub_AB124(v1);
  return v1;
}
// F15A8: using guessed type void *off_F15A8;
// F1878: using guessed type void *;

//----- (000AA8C8) --------------------------------------------------------
_DWORD *__fastcall sub_AA8C8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1558;
  sub_AA880(a1);
  return v1;
}
// F1558: using guessed type void *;

//----- (000AA8E0) --------------------------------------------------------
_DWORD *__fastcall sub_AA8E0(_DWORD *a1)
{
  _DWORD *v1; // r4
  void *v2; // r0

  v1 = a1;
  *a1 = &off_F14F8;
  sub_A8038(a1 + 2);
  if ( *((_BYTE *)v1 + 12) )
  {
    v2 = (void *)v1[6];
    if ( v2 )
      operator delete[](v2);
  }
  sub_AB124(v1);
  return v1;
}
// F14F8: using guessed type void *off_F14F8;

//----- (000AA918) --------------------------------------------------------
void *__fastcall sub_AA918(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_AA880(a1);
  operator delete(v1);
  return v1;
}

//----- (000AA92C) --------------------------------------------------------
void *__fastcall sub_AA92C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1558;
  sub_AA880(a1);
  operator delete(v1);
  return v1;
}
// F1558: using guessed type void *off_F1558;

//----- (000AA94C) --------------------------------------------------------
void *__fastcall sub_AA94C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_AA8E0(a1);
  operator delete(v1);
  return v1;
}

//----- (000AA9D0) --------------------------------------------------------
int __fastcall sub_AA9D0(int a1)
{
  int v1; // r6
  int v2; // r4
  int result; // r0
  int v4; // [sp+0h] [bp-118h]

  v1 = a1;
  v2 = 0;
  do
  {
    *((_BYTE *)&v4 + v2) = v2;
    ++v2;
  }
  while ( v2 != 256 );
  (*(void (**)(void))(*(_DWORD *)a1 + 28))();
  *(_BYTE *)(v1 + 28) = 1;
  result = memcmp(&v4, (const void *)(v1 + 29), 0x100u);
  if ( result )
    *(_BYTE *)(v1 + 28) = 2;
  return result;
}

//----- (000AAA14) --------------------------------------------------------
int __fastcall sub_AAA14(_DWORD *a1, int a2)
{
  int v2; // r4

  v2 = (int)a1;
  a1[1] = a2 != 0;
  *a1 = &off_F15A8;
  a1[2] = sub_AB4B8();
  *(_BYTE *)(v2 + 12) = 0;
  sub_C344C(v2);
  return v2;
}
// F15A8: using guessed type void *;

//----- (000AAAF4) --------------------------------------------------------
int __fastcall sub_AAAF4(int a1, const char *a2, const char *a3)
{
  int v3; // r0
  int result; // r0

  v3 = strcoll(a2, a3);
  if ( v3 )
    result = (v3 >> 30) | 1;
  else
    result = 0;
  return result;
}

//----- (000AAB0C) --------------------------------------------------------
size_t __fastcall sub_AAB0C(int a1, char *a2, const char *a3, size_t a4)
{
  return j_strxfrm(a2, a3, a4);
}

//----- (000AAB18) --------------------------------------------------------
int __fastcall sub_AAB18(int a1, const wchar_t *a2, const wchar_t *a3)
{
  int v3; // r0
  int result; // r0

  v3 = wcscoll(a2, a3);
  if ( v3 )
    result = (v3 >> 30) | 1;
  else
    result = 0;
  return result;
}

//----- (000AAB30) --------------------------------------------------------
size_t __fastcall sub_AAB30(int a1, wchar_t *a2, const wchar_t *a3, size_t a4)
{
  return j_wcsxfrm(a2, a3, a4);
}

//----- (000AAB3C) --------------------------------------------------------
int __fastcall sub_AAB3C(int a1, int a2)
{
  int v2; // r6

  v2 = a1;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 16))(a1, a2);
  return v2;
}

//----- (000AAB6C) --------------------------------------------------------
int __fastcall sub_AAB6C(int a1, int a2)
{
  int v2; // r6

  v2 = a1;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 16))(a1, a2);
  return v2;
}

//----- (000AAB9C) --------------------------------------------------------
signed int __fastcall sub_AAB9C(int a1, char *a2, size_t a3)
{
  int v3; // r4
  char *v4; // r5
  signed int result; // r0
  signed int v6; // r3

  v3 = a1;
  v4 = a2;
  result = fread(a2, 1u, a3, *(FILE **)(a1 + 32));
  if ( result <= 0 )
    v6 = -1;
  else
    v4 += result;
  if ( result > 0 )
    v6 = (unsigned __int8)*(v4 - 1);
  *(_DWORD *)(v3 + 36) = v6;
  return result;
}

//----- (000AABC0) --------------------------------------------------------
size_t __fastcall sub_AABC0(int a1, const void *a2, size_t a3)
{
  return j_fwrite(a2, 1u, a3, *(FILE **)(a1 + 32));
}

//----- (000AABCC) --------------------------------------------------------
int __fastcall sub_AABCC(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r8
  int v5; // r7
  int v6; // r5
  int v7; // r4
  wint_t v8; // r0
  int result; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( a3 )
  {
    v6 = a2 - 4;
    v7 = 0;
    while ( 1 )
    {
      v8 = getwc(*(__FILE **)(v3 + 32));
      if ( v8 == -1 )
        break;
      ++v7;
      *(_DWORD *)(v6 + 4) = v8;
      v6 += 4;
      if ( v5 == v7 )
        goto LABEL_7;
    }
    if ( !v7 )
      goto LABEL_6;
LABEL_7:
    result = v7;
    *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 4 * (v7 + 0x3FFFFFFF));
  }
  else
  {
LABEL_6:
    result = 0;
    *(_DWORD *)(v3 + 36) = -1;
  }
  return result;
}

//----- (000AAC14) --------------------------------------------------------
wint_t __fastcall sub_AAC14(int a1)
{
  int v1; // r4
  wint_t result; // r0

  v1 = a1;
  result = getwc(*(__FILE **)(a1 + 32));
  *(_DWORD *)(v1 + 36) = result;
  return result;
}

//----- (000AAC24) --------------------------------------------------------
int __fastcall sub_AAC24(int a1, int *a2, int a3)
{
  int v3; // r7
  int *v4; // r5
  int v5; // r6
  int v6; // r4
  int v7; // t1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !a3 )
    return 0;
  v6 = 0;
  do
  {
    v7 = *v4;
    ++v4;
    if ( putwc(v7, *(__FILE **)(v3 + 32)) == -1 )
      break;
    ++v6;
  }
  while ( v5 != v6 );
  return v6;
}

//----- (000AAC50) --------------------------------------------------------
int __fastcall sub_AAC50(int a1)
{
  int v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0858;
  sub_AB620((unsigned int **)(a1 + 28));
  return v1;
}
// F0858: using guessed type void *off_F0858;

//----- (000AAC6C) --------------------------------------------------------
int __fastcall sub_AAC6C(int a1)
{
  int v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F0818;
  sub_AB620((unsigned int **)(a1 + 28));
  return v1;
}
// F0818: using guessed type void *off_F0818;

//----- (000AAC88) --------------------------------------------------------
int __fastcall sub_AAC88(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = a1;
  result = getc(*(FILE **)(a1 + 32));
  *(_DWORD *)(v1 + 36) = result;
  return result;
}

//----- (000AAC98) --------------------------------------------------------
int __fastcall sub_AAC98(int a1)
{
  int v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = getc(*(FILE **)(a1 + 32));
  return j_ungetc(v2, *(FILE **)(v1 + 32));
}

//----- (000AACAC) --------------------------------------------------------
int __fastcall sub_AACAC(int a1, int a2)
{
  int v2; // r4
  int result; // r0

  v2 = a1;
  if ( a2 == -1 )
  {
    result = *(_DWORD *)(a1 + 36);
    if ( result == -1 )
      goto LABEL_5;
  }
  else
  {
    result = a2;
  }
  result = ungetc(result, *(FILE **)(v2 + 32));
LABEL_5:
  *(_DWORD *)(v2 + 36) = -1;
  return result;
}

//----- (000AACD0) --------------------------------------------------------
int __fastcall sub_AACD0(int a1)
{
  return j_fflush(*(FILE **)(a1 + 32));
}

//----- (000AACD8) --------------------------------------------------------
int __fastcall sub_AACD8(int a1)
{
  return j_fflush(*(FILE **)(a1 + 32));
}

//----- (000AACE0) --------------------------------------------------------
_QWORD *__fastcall sub_AACE0(int a1, int a2, int off, int a4, int whence)
{
  int v5; // r7
  signed int v6; // r3
  _QWORD *v7; // r6

  v5 = a2;
  v6 = whence;
  v7 = (_QWORD *)a1;
  *(_QWORD *)a1 = -1LL;
  *(_DWORD *)(a1 + 8) = 0;
  if ( whence )
  {
    if ( whence == 1 )
      v6 = 1;
    else
      v6 = 2;
  }
  if ( !fseek(*(FILE **)(a2 + 32), off, v6) )
    *v7 = ftell(*(FILE **)(v5 + 32));
  return v7;
}

//----- (000AAD20) --------------------------------------------------------
_QWORD *__fastcall sub_AAD20(int a1, int a2, int off, int a4, int whence)
{
  int v5; // r7
  signed int v6; // r3
  _QWORD *v7; // r6

  v5 = a2;
  v6 = whence;
  v7 = (_QWORD *)a1;
  *(_QWORD *)a1 = -1LL;
  *(_DWORD *)(a1 + 8) = 0;
  if ( whence )
  {
    if ( whence == 1 )
      v6 = 1;
    else
      v6 = 2;
  }
  if ( !fseek(*(FILE **)(a2 + 32), off, v6) )
    *v7 = ftell(*(FILE **)(v5 + 32));
  return v7;
}

//----- (000AAD60) --------------------------------------------------------
wint_t __fastcall sub_AAD60(int a1)
{
  int v1; // r4
  wint_t v2; // r0

  v1 = a1;
  v2 = getwc(*(__FILE **)(a1 + 32));
  return j_ungetwc(v2, *(__FILE **)(v1 + 32));
}

//----- (000AAD74) --------------------------------------------------------
wint_t __fastcall sub_AAD74(int a1, wint_t a2)
{
  int v2; // r4
  wint_t result; // r0

  v2 = a1;
  if ( a2 != -1 )
  {
    result = a2;
LABEL_4:
    result = ungetwc(result, *(__FILE **)(v2 + 32));
    *(_DWORD *)(v2 + 36) = -1;
    return result;
  }
  result = *(_DWORD *)(a1 + 36);
  if ( result != -1 )
    goto LABEL_4;
  *(_DWORD *)(v2 + 36) = -1;
  return result;
}

//----- (000AAD9C) --------------------------------------------------------
unsigned int **__fastcall sub_AAD9C(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  *a1 = (unsigned int *)&off_F0858;
  sub_AB620(a1 + 7);
  operator delete(v1);
  return v1;
}
// F0858: using guessed type void *off_F0858;

//----- (000AADC0) --------------------------------------------------------
unsigned int **__fastcall sub_AADC0(unsigned int **a1)
{
  unsigned int **v1; // r4

  v1 = a1;
  *a1 = (unsigned int *)&off_F0818;
  sub_AB620(a1 + 7);
  operator delete(v1);
  return v1;
}
// F0818: using guessed type void *off_F0818;

//----- (000AADE4) --------------------------------------------------------
signed int __fastcall sub_AADE4(int a1, int a2)
{
  signed int result; // r0

  if ( a2 != -1 )
    return j_putc(a2, *(FILE **)(a1 + 32));
  result = fflush(*(FILE **)(a1 + 32));
  if ( result )
    result = -1;
  return result;
}

//----- (000AAE08) --------------------------------------------------------
int __fastcall sub_AAE08(int a1, int a2)
{
  int result; // r0

  if ( a2 != -1 )
    return j_putwc(a2, *(__FILE **)(a1 + 32));
  result = fflush(*(FILE **)(a1 + 32));
  if ( result )
    result = -1;
  return result;
}

//----- (000AAE2C) --------------------------------------------------------
int *__fastcall sub_AAE2C(int *a1, int *a2)
{
  return sub_B6E58(a1, *a2, *(_DWORD *)(*a2 - 12));
}

//----- (000AB124) --------------------------------------------------------
_DWORD *__fastcall sub_AB124(_DWORD *result)
{
  *result = &off_F1688;
  return result;
}
// F1688: using guessed type void *;

//----- (000AB134) --------------------------------------------------------
_DWORD *__fastcall sub_AB134(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1688;
  operator delete(a1);
  return v1;
}
// F1688: using guessed type void *off_F1688;

//----- (000AB164) --------------------------------------------------------
unsigned int **__fastcall sub_AB164(unsigned int **result, unsigned int **a2)
{
  unsigned int *v2; // r3
  unsigned int v3; // r1

  v2 = *a2;
  *result = *a2;
  __dmb(0xFu);
  do
    v3 = __ldrex(v2);
  while ( __strex(v3 + 1, v2) );
  __dmb(0xFu);
  return result;
}

//----- (000AB180) --------------------------------------------------------
_DWORD *__fastcall sub_AB180(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

//----- (000AB184) --------------------------------------------------------
int *__fastcall sub_AB184(int *a1, int a2)
{
  int v2; // r9
  int v3; // r3
  int *v4; // r4
  char *v5; // r10
  int v6; // r8
  const char *v7; // r0
  unsigned int v8; // r5
  const char *v9; // r7
  const char *v10; // t1
  int v11; // r0
  bool v12; // zf
  char *(*v13)[6]; // r5
  char *v14; // r7
  size_t v15; // r0
  int v16; // r3
  int v17; // r2
  int v18; // r7
  int v19; // r3
  const char *v20; // r7
  size_t v21; // r0
  char *(*v22)[6]; // r8
  signed int v23; // r5
  int v24; // r3
  int v25; // r2
  int v26; // r7
  int v27; // r3
  const char *v28; // t1
  size_t v29; // r0
  int v30; // r3
  int v31; // r2
  int v32; // r7
  int v33; // r3
  const char *v34; // r7
  size_t v35; // r0
  size_t v37; // r0

  v2 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)a2 + 16);
  v4 = a1;
  *a1 = (int)&unk_2FEF48;
  v5 = *(char **)v3;
  if ( !*(_DWORD *)v3 )
  {
    sub_C0DB8(a1, 0, dword_2FEF3C, 1u, 0x2Au);
    return v4;
  }
  if ( !*(_DWORD *)(v3 + 4) )
    goto LABEL_32;
  v6 = v3;
  v7 = *(const char **)v3;
  v8 = 0;
  while ( 1 )
  {
    v10 = *(const char **)(v6 + 4);
    v6 += 4;
    v9 = v10;
    ++v8;
    v11 = strcmp(v7, v10);
    v12 = v8 == 4;
    if ( v8 <= 4 )
      v12 = v11 == 0;
    if ( !v12 )
      break;
    v7 = v9;
  }
  if ( v11 == 0 )
  {
LABEL_32:
    v37 = strlen(v5);
    sub_C0F20(v4, v5, v37);
    return v4;
  }
  sub_C1264(v4, 0x80u);
  v13 = off_EF9EC;
  v14 = (*off_EF9EC)[0];
  v15 = strlen((*off_EF9EC)[0]);
  sub_C13F8((unsigned int *)v4, (unsigned int)v14, v15);
  v16 = *v4;
  v17 = *(_DWORD *)(*v4 - 12);
  v18 = v17 + 1;
  if ( (unsigned int)(v17 + 1) > *(_DWORD *)(*v4 - 8) || *(_DWORD *)(v16 - 4) > 0 )
  {
    sub_C1264(v4, v17 + 1);
    v16 = *v4;
    v17 = *(_DWORD *)(*v4 - 12);
  }
  *(_BYTE *)(v16 + v17) = 61;
  v19 = *v4;
  if ( (int *)(*v4 - 12) != &dword_2FEF3C )
  {
    *(_DWORD *)(v19 - 12) = v18;
    *(_DWORD *)(v19 - 4) = 0;
    *(_BYTE *)(v19 + v18) = 0;
  }
  v20 = **(const char ***)(*(_DWORD *)v2 + 16);
  v21 = strlen(v20);
  sub_C13F8((unsigned int *)v4, (unsigned int)v20, v21);
  v22 = v13;
  v23 = 4;
  do
  {
    v24 = *v4;
    v25 = *(_DWORD *)(*v4 - 12);
    v26 = v25 + 1;
    if ( (unsigned int)(v25 + 1) > *(_DWORD *)(*v4 - 8) || *(_DWORD *)(v24 - 4) > 0 )
    {
      sub_C1264(v4, v25 + 1);
      v24 = *v4;
      v25 = *(_DWORD *)(*v4 - 12);
    }
    *(_BYTE *)(v24 + v25) = 59;
    v27 = *v4;
    if ( (int *)(*v4 - 12) != &dword_2FEF3C )
    {
      *(_DWORD *)(v27 - 12) = v26;
      *(_DWORD *)(v27 - 4) = 0;
      *(_BYTE *)(v27 + v26) = 0;
    }
    v28 = (*v22)[1];
    v22 = (char *(*)[6])((char *)v22 + 4);
    v29 = strlen(v28);
    sub_C13F8((unsigned int *)v4, (unsigned int)v28, v29);
    v30 = *v4;
    v31 = *(_DWORD *)(*v4 - 12);
    v32 = v31 + 1;
    if ( (unsigned int)(v31 + 1) > *(_DWORD *)(*v4 - 8) || *(_DWORD *)(v30 - 4) > 0 )
    {
      sub_C1264(v4, v31 + 1);
      v30 = *v4;
      v31 = *(_DWORD *)(*v4 - 12);
    }
    *(_BYTE *)(v30 + v31) = 61;
    v33 = *v4;
    if ( (int *)(*v4 - 12) != &dword_2FEF3C )
    {
      *(_DWORD *)(v33 - 12) = v32;
      *(_DWORD *)(v33 - 4) = 0;
      *(_BYTE *)(v33 + v32) = 0;
    }
    v34 = *(const char **)(*(_DWORD *)(*(_DWORD *)v2 + 16) + v23);
    v35 = strlen(v34);
    sub_C13F8((unsigned int *)v4, (unsigned int)v34, v35);
    v23 += 4;
  }
  while ( v23 != 24 );
  return v4;
}
// EF9EC: using guessed type char *(*off_EF9EC)[6];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000AB4B8) --------------------------------------------------------
int sub_AB4B8()
{
  pthread_once((pthread_once_t *)&unk_2FEEC0, (void (*)(void))sub_AB14C);
  return dword_2FEEAC;
}
// AB14C: using guessed type int sub_AB14C();
// 2FEEAC: using guessed type int dword_2FEEAC;

//----- (000AB4DC) --------------------------------------------------------
const char *sub_AB4DC()
{
  return "C";
}

//----- (000AB4E8) --------------------------------------------------------
_DWORD *__fastcall sub_AB4E8(_DWORD *a1)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r5
  unsigned int v3; // r3
  unsigned int v4; // r4
  unsigned int *v5; // r0
  unsigned int *v6; // r3
  unsigned int v7; // r2
  _DWORD *v8; // r2
  unsigned int v9; // r3
  unsigned int v10; // r4
  unsigned int *v11; // r0
  unsigned int *v12; // r3
  unsigned int v13; // r2
  char *v14; // r3
  int v15; // r4
  void *v16; // r0

  v1 = (_DWORD *)a1[1];
  v2 = a1;
  if ( v1 )
  {
    v3 = a1[2];
    if ( !v3 )
      goto LABEL_35;
    v4 = 0;
    do
    {
      v5 = (unsigned int *)v1[v4];
      if ( v5 )
      {
        v6 = v5 + 1;
        __dmb(0xFu);
        do
          v7 = __ldrex(v6);
        while ( __strex(v7 - 1, v6) );
        __dmb(0xFu);
        if ( v7 == 1 )
          (*(void (**)(void))(*v5 + 4))();
        v1 = (_DWORD *)v2[1];
        v3 = v2[2];
      }
      ++v4;
    }
    while ( v3 > v4 );
    if ( v1 )
LABEL_35:
      operator delete[](v1);
  }
  v8 = (_DWORD *)v2[3];
  if ( v8 )
  {
    v9 = v2[2];
    if ( !v9 )
      goto LABEL_36;
    v10 = 0;
    do
    {
      v11 = (unsigned int *)v8[v10];
      if ( v11 )
      {
        v12 = v11 + 1;
        __dmb(0xFu);
        do
          v13 = __ldrex(v12);
        while ( __strex(v13 - 1, v12) );
        __dmb(0xFu);
        if ( v13 == 1 )
          (*(void (**)(void))(*v11 + 4))();
        v8 = (_DWORD *)v2[3];
        v9 = v2[2];
      }
      ++v10;
    }
    while ( v9 > v10 );
    if ( v8 )
LABEL_36:
      operator delete[](v8);
  }
  v14 = (char *)v2[4];
  if ( v14 )
  {
    v15 = 0;
    do
    {
      v16 = *(void **)&v14[v15];
      if ( v16 )
      {
        operator delete[](v16);
        v14 = (char *)v2[4];
      }
      v15 += 4;
    }
    while ( v15 != 24 );
    if ( v14 )
      operator delete[](v14);
  }
  return v2;
}

//----- (000AB5C4) --------------------------------------------------------
unsigned int **__fastcall sub_AB5C4(unsigned int **result, unsigned int **a2)
{
  unsigned int **v2; // r6
  unsigned int *v3; // r3
  unsigned int **v4; // r5
  unsigned int v5; // r1
  unsigned int *v6; // r4
  unsigned int v7; // r3

  v2 = a2;
  v3 = *a2;
  __dmb(0xFu);
  v4 = result;
  do
    v5 = __ldrex(v3);
  while ( __strex(v5 + 1, v3) );
  __dmb(0xFu);
  v6 = *result;
  __dmb(0xFu);
  do
    v7 = __ldrex(v6);
  while ( __strex(v7 - 1, v6) );
  __dmb(0xFu);
  if ( v7 == 1 && v6 )
  {
    sub_AB4E8(v6);
    operator delete(v6);
    result = v4;
    *v4 = *v2;
  }
  else
  {
    *result = *v2;
  }
  return result;
}

//----- (000AB620) --------------------------------------------------------
unsigned int **__fastcall sub_AB620(unsigned int **result)
{
  unsigned int **v1; // r5
  unsigned int *v2; // r4
  unsigned int v3; // r3

  v1 = result;
  v2 = *result;
  __dmb(0xFu);
  do
    v3 = __ldrex(v2);
  while ( __strex(v3 - 1, v2) );
  __dmb(0xFu);
  if ( v3 == 1 )
  {
    if ( v2 )
    {
      sub_AB4E8(v2);
      operator delete(v2);
      result = v1;
    }
  }
  return result;
}

//----- (000AB778) --------------------------------------------------------
int __fastcall sub_AB778(int a1, unsigned int *a2, int a3)
{
  int v3; // r7
  unsigned int *v4; // r4
  int v5; // r6
  int result; // r0
  unsigned int *v7; // r3
  unsigned int v8; // r1
  _DWORD *v9; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !(dword_2FEEB0 & 1) && _cxa_guard_acquire((unsigned int *)&dword_2FEEB0) )
  {
    dword_2FEEA8 = 0;
    _cxa_guard_release((unsigned int *)&dword_2FEEB0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)&dword_2FEEA8) )
  {
    v9 = (_DWORD *)_cxa_allocate_exception(4);
    *v9 = &off_F0638;
    _cxa_throw((int)v9, (int)&`typeinfo for'__gnu_cxx::__concurrence_lock_error, (int)sub_93428);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4 * v5) )
  {
    if ( v4 )
      (*(void (__fastcall **)(unsigned int *))(*v4 + 4))(v4);
  }
  else
  {
    v7 = v4 + 1;
    __dmb(0xFu);
    do
      v8 = __ldrex(v7);
    while ( __strex(v8 + 1, v7) );
    __dmb(0xFu);
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4 * v5) = v4;
  }
  result = pthread_mutex_unlock((pthread_mutex_t *)&dword_2FEEA8);
  if ( result )
    sub_934A8();
  return result;
}
// F0618: using guessed type int *`typeinfo for'__gnu_cxx::__concurrence_lock_error;
// F0638: using guessed type void *off_F0638;
// 2FEEA8: using guessed type int dword_2FEEA8;
// 2FEEB0: using guessed type int dword_2FEEB0;

//----- (000AB850) --------------------------------------------------------
int __fastcall sub_AB850(int *a1)
{
  unsigned int v2; // r3
  int v3; // r3

  if ( *a1 )
    return *a1 - 1;
  __dmb(0xFu);
  do
    v2 = __ldrex((unsigned int *)&unk_2FEEA4);
  while ( __strex(v2 + 1, (unsigned int *)&unk_2FEEA4) );
  v3 = v2 + 1;
  __dmb(0xFu);
  *a1 = v3;
  return v3 - 1;
}

//----- (000AB88C) --------------------------------------------------------
int __fastcall sub_AB88C(int result, int *a2, int a3)
{
  _DWORD *v3; // r5
  int v4; // r8
  unsigned int v5; // r0
  unsigned int v6; // r6
  unsigned int v7; // r7
  void *v8; // r9
  unsigned int v9; // r0
  char *v10; // r0
  int v11; // r3
  char *v12; // r4
  unsigned int v13; // r0
  int v14; // r3
  int v15; // r2
  int v16; // r0
  int v17; // r2
  void *v18; // r10
  unsigned int v19; // r0
  char *v20; // r0
  unsigned int v21; // r12
  int v22; // r3
  int v23; // r3
  int v24; // r2
  int v25; // r12
  int v26; // r2
  unsigned int *v27; // r3
  unsigned int v28; // r1
  int v29; // r4
  unsigned int *v30; // r3
  unsigned int v31; // r2
  unsigned int v32; // r2
  unsigned int v33; // r4
  unsigned int *v34; // r3
  unsigned int v35; // r2

  v3 = (_DWORD *)result;
  v4 = a3;
  if ( a3 )
  {
    v5 = sub_AB850(a2);
    v6 = v5;
    if ( v5 > v3[2] - 1 )
    {
      v7 = v5 + 4;
      v8 = (void *)v3[1];
      if ( v5 + 4 > 0x1FC00000 )
        v9 = -1;
      else
        v9 = 4 * v7;
      v10 = (char *)operator new[](v9);
      v11 = 0;
      v12 = v10;
      v13 = v3[2];
      if ( v13 )
      {
        do
        {
          *(_DWORD *)&v12[v11] = *(_DWORD *)(v3[1] + v11);
          v11 += 4;
        }
        while ( v11 != 4 * v13 );
      }
      if ( v7 > v13 )
      {
        v14 = 0;
        v15 = 4 - v13 + v6;
        v16 = (int)&v12[4 * v13];
        v17 = 4 * v15;
        do
        {
          *(_DWORD *)(v16 + v14) = 0;
          v14 += 4;
        }
        while ( v14 != v17 );
      }
      v18 = (void *)v3[3];
      if ( v7 <= 0x1FC00000 )
        v19 = 4 * v7;
      else
        v19 = -1;
      v20 = (char *)operator new[](v19);
      v21 = v3[2];
      v22 = 0;
      if ( v21 )
      {
        do
        {
          *(_DWORD *)&v20[v22] = *(_DWORD *)(v3[3] + v22);
          v22 += 4;
        }
        while ( v22 != 4 * v21 );
      }
      if ( v7 > v21 )
      {
        v23 = 0;
        v24 = 4 - v21 + v6;
        v25 = (int)&v20[4 * v21];
        v26 = 4 * v24;
        do
        {
          *(_DWORD *)(v25 + v23) = 0;
          v23 += 4;
        }
        while ( v23 != v26 );
      }
      v3[2] = v7;
      v3[1] = v12;
      v3[3] = v20;
      if ( v8 )
        operator delete[](v8);
      if ( v18 )
        operator delete[](v18);
    }
    v27 = (unsigned int *)(v4 + 4);
    __dmb(0xFu);
    do
      v28 = __ldrex(v27);
    while ( __strex(v28 + 1, v27) );
    __dmb(0xFu);
    v29 = v3[1];
    result = *(_DWORD *)(v29 + 4 * v6);
    if ( result )
    {
      v30 = (unsigned int *)(result + 4);
      __dmb(0xFu);
      do
        v31 = __ldrex(v30);
      while ( __strex(v31 - 1, v30) );
      __dmb(0xFu);
      if ( v31 == 1 )
        result = (*(int (**)(void))(*(_DWORD *)result + 4))();
    }
    v32 = v3[2];
    *(_DWORD *)(v29 + 4 * v6) = v4;
    if ( v32 )
    {
      v33 = 0;
      do
      {
        result = *(_DWORD *)(v3[3] + 4 * v33);
        if ( result )
        {
          v34 = (unsigned int *)(result + 4);
          __dmb(0xFu);
          do
            v35 = __ldrex(v34);
          while ( __strex(v35 - 1, v34) );
          __dmb(0xFu);
          if ( v35 == 1 )
            result = (*(int (**)(void))(*(_DWORD *)result + 4))();
          v32 = v3[2];
          *(_DWORD *)(v3[3] + 4 * v33) = 0;
        }
        ++v33;
      }
      while ( v32 > v33 );
    }
  }
  return result;
}

//----- (000ABA38) --------------------------------------------------------
int __fastcall sub_ABA38(int a1, int a2, int *a3)
{
  int v3; // r6
  int *v4; // r4
  int v5; // r5
  unsigned int v6; // r0
  int v7; // r2

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = sub_AB850(a3);
  if ( v6 > *(_DWORD *)(v5 + 8) - 1 || (v7 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 4 * v6)) == 0 )
    sub_BFC64("locale::_Impl::_M_replace_facet");
  return sub_AB88C(v3, v4, v7);
}

//----- (000ABA90) --------------------------------------------------------
_DWORD *__fastcall sub_ABA90(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F16C4;
  a1[2] = &off_F169C;
  a1[3] = &off_F0690;
  sub_95E1C(a1 + 3);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F169C: using guessed type void *off_F169C;
// F16C4: using guessed type void *off_F16C4;

//----- (000ABAD0) --------------------------------------------------------
_DWORD *__fastcall sub_ABAD0(_DWORD *a1)
{
  return sub_ABA90((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000ABADC) --------------------------------------------------------
void *__fastcall sub_ABADC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F16C4;
  a1[2] = &off_F169C;
  a1[3] = &off_F0690;
  sub_95E1C(a1 + 3);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F169C: using guessed type void *off_F169C;
// F16C4: using guessed type void *off_F16C4;

//----- (000ABB24) --------------------------------------------------------
void *__fastcall sub_ABB24(_DWORD *a1)
{
  return sub_ABADC((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000ABB30) --------------------------------------------------------
_DWORD *__fastcall sub_ABB30(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F1774;
  a1[2] = &off_F174C;
  a1[3] = &off_F06A0;
  sub_95E1C(a1 + 3);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F174C: using guessed type void *off_F174C;
// F1774: using guessed type void *off_F1774;

//----- (000ABB68) --------------------------------------------------------
_DWORD *__fastcall sub_ABB68(int a1)
{
  return sub_ABB30((_DWORD *)(a1 - 8));
}

//----- (000ABB70) --------------------------------------------------------
_DWORD *__fastcall sub_ABB70(_DWORD *a1)
{
  return sub_ABB30((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000ABB7C) --------------------------------------------------------
void *__fastcall sub_ABB7C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  a1[1] = 0;
  *a1 = &off_F1774;
  a1[2] = &off_F174C;
  a1[3] = &off_F06A0;
  sub_95E1C(a1 + 3);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F174C: using guessed type void *off_F174C;
// F1774: using guessed type void *off_F1774;

//----- (000ABBBC) --------------------------------------------------------
void *__fastcall sub_ABBBC(int a1)
{
  return sub_ABB7C((_DWORD *)(a1 - 8));
}

//----- (000ABBC4) --------------------------------------------------------
void *__fastcall sub_ABBC4(_DWORD *a1)
{
  return sub_ABB7C((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000ABCE0) --------------------------------------------------------
int *__fastcall sub_ABCE0(int *result, int *a2)
{
  int v2; // r2
  int v3; // r2
  int v4; // r5
  int v5; // r2
  int v6; // r5

  v2 = *a2;
  *result = *a2;
  *(int *)((char *)result + *(_DWORD *)(v2 - 12)) = a2[5];
  result[2] = a2[6];
  v3 = a2[3];
  v4 = *(_DWORD *)(v3 - 12);
  result[2] = v3;
  *(int *)((char *)result + v4 + 8) = a2[4];
  v5 = a2[1];
  v6 = *(_DWORD *)(v5 - 12);
  *result = v5;
  *(int *)((char *)result + v6) = a2[2];
  result[1] = 0;
  return result;
}

//----- (000ABF30) --------------------------------------------------------
int *__fastcall sub_ABF30(int *result, int *a2)
{
  int v2; // r2
  int v3; // r2
  int v4; // r5
  int v5; // r2
  int v6; // r5

  v2 = *a2;
  *result = *a2;
  *(int *)((char *)result + *(_DWORD *)(v2 - 12)) = a2[5];
  result[2] = a2[6];
  v3 = a2[3];
  v4 = *(_DWORD *)(v3 - 12);
  result[2] = v3;
  *(int *)((char *)result + v4 + 8) = a2[4];
  v5 = a2[1];
  v6 = *(_DWORD *)(v5 - 12);
  *result = v5;
  *(int *)((char *)result + v6) = a2[2];
  result[1] = 0;
  return result;
}

//----- (000AC070) --------------------------------------------------------
int __fastcall sub_AC070(int a1, int a2)
{
  int result; // r0

  if ( *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + a2) << 30 >= 0 )
    result = a2;
  else
    result = (unsigned __int8)(a2 - 32);
  return result;
}

//----- (000AC080) --------------------------------------------------------
_BYTE *__fastcall sub_AC080(int a1, _BYTE *a2, _BYTE *a3)
{
  int v3; // r5
  _BYTE *v4; // r6
  _BYTE *v5; // r4

  v3 = a1;
  v4 = a3;
  if ( a2 < a3 )
  {
    v5 = a2;
    do
    {
      *v5 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v3 + 8))(v3, (unsigned __int8)*v5);
      ++v5;
    }
    while ( v5 != v4 );
  }
  return v4;
}

//----- (000AC0A4) --------------------------------------------------------
int __fastcall sub_AC0A4(int a1, int a2)
{
  int result; // r0

  if ( *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + a2) << 31 >= 0 )
    result = a2;
  else
    result = (unsigned __int8)(a2 + 32);
  return result;
}

//----- (000AC0B4) --------------------------------------------------------
_BYTE *__fastcall sub_AC0B4(int a1, _BYTE *a2, _BYTE *a3)
{
  int v3; // r5
  _BYTE *v4; // r6
  _BYTE *v5; // r4

  v3 = a1;
  v4 = a3;
  if ( a2 < a3 )
  {
    v5 = a2;
    do
    {
      *v5 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v3 + 16))(v3, (unsigned __int8)*v5);
      ++v5;
    }
    while ( v5 != v4 );
  }
  return v4;
}

//----- (000AC154) --------------------------------------------------------
_BYTE *__fastcall sub_AC154(int a1, int a2, char a3, int a4)
{
  _BYTE *v4; // r4
  _BOOL4 v5; // r3
  char v6; // r2

  v4 = (_BYTE *)a1;
  v5 = a4 != 0;
  if ( a2 )
    v6 = a3 & 1;
  else
    v6 = 0;
  *(_DWORD *)(a1 + 4) = v5;
  *(_BYTE *)(a1 + 12) = v6;
  *(_DWORD *)a1 = &off_F14F8;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  if ( !a2 )
    a2 = ctype_ + 1;
  *(_DWORD *)(a1 + 24) = a2;
  memset((void *)(a1 + 29), 0, 0x100u);
  v4[28] = 0;
  memset(v4 + 285, 0, 0x100u);
  v4[541] = 0;
  return v4;
}
// F14F8: using guessed type void *;

//----- (000AC1C0) --------------------------------------------------------
int __fastcall sub_AC1C0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
}

//----- (000AC1C8) --------------------------------------------------------
int __fastcall sub_AC1C8(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 24);
}

//----- (000AC1D0) --------------------------------------------------------
int __fastcall sub_AC1D0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 52);
}

//----- (000AC1D8) --------------------------------------------------------
int __fastcall sub_AC1D8(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 24) << 24);
}

//----- (000AC208) --------------------------------------------------------
int __fastcall sub_AC208(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 24) << 24);
}

//----- (000AC238) --------------------------------------------------------
int __fastcall sub_AC238(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
}

//----- (000AC240) --------------------------------------------------------
int __fastcall sub_AC240(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 24);
}

//----- (000AC248) --------------------------------------------------------
int __fastcall sub_AC248(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 52);
}

//----- (000AC250) --------------------------------------------------------
int __fastcall sub_AC250(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) >> 24) << 24);
}

//----- (000AC280) --------------------------------------------------------
int __fastcall sub_AC280(int a1)
{
  return ((unsigned __int16)((unsigned __int8)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) | (unsigned __int16)((((unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 8) & 0xFF) << 8)) | (((*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 16) & 0xFF) << 16)) & 0xFFFFFF | ((unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) >> 24) << 24);
}

//----- (000AC2B0) --------------------------------------------------------
int __fastcall sub_AC2B0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 36);
}

//----- (000AC2B8) --------------------------------------------------------
int __fastcall sub_AC2B8(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 40);
}

//----- (000AC2C0) --------------------------------------------------------
int sub_AC2C0()
{
  return 0;
}

//----- (000AC2C4) --------------------------------------------------------
int sub_AC2C4()
{
  return 0;
}

//----- (000AC2CC) --------------------------------------------------------
int __fastcall sub_AC2CC(int a1, int *a2, unsigned int a3)
{
  int result; // r0
  int v4; // t1

  for ( result = 0; a3 > (unsigned int)a2; result = v4 + __ROR4__(result, 25) )
  {
    v4 = *a2;
    ++a2;
  }
  return result;
}

//----- (000AC2E4) --------------------------------------------------------
_DWORD *__fastcall sub_AC2E4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1AF8;
  sub_AB124(a1);
  return v1;
}
// F1AF8: using guessed type void *off_F1AF8;

//----- (000AC2FC) --------------------------------------------------------
_DWORD *__fastcall sub_AC2FC(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1B10;
  sub_AB124(a1);
  return v1;
}
// F1B10: using guessed type void *off_F1B10;

//----- (000AC314) --------------------------------------------------------
_DWORD *__fastcall sub_AC314(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1908;
  sub_AB124(a1);
  return v1;
}
// F1908: using guessed type void *off_F1908;

//----- (000AC32C) --------------------------------------------------------
_DWORD *__fastcall sub_AC32C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1948;
  sub_AB124(a1);
  return v1;
}
// F1948: using guessed type void *off_F1948;

//----- (000AC344) --------------------------------------------------------
_DWORD *__fastcall sub_AC344(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1978;
  sub_AB124(a1);
  return v1;
}
// F1978: using guessed type void *off_F1978;

//----- (000AC35C) --------------------------------------------------------
_DWORD *__fastcall sub_AC35C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1B28;
  sub_AB124(a1);
  return v1;
}
// F1B28: using guessed type void *off_F1B28;

//----- (000AC374) --------------------------------------------------------
_DWORD *__fastcall sub_AC374(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1B28;
  sub_AB124(a1);
  return v1;
}
// F1B28: using guessed type void *off_F1B28;

//----- (000AC38C) --------------------------------------------------------
_DWORD *__fastcall sub_AC38C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1B58;
  sub_AB124(a1);
  return v1;
}
// F1B58: using guessed type void *off_F1B58;

//----- (000AC3A4) --------------------------------------------------------
_DWORD *__fastcall sub_AC3A4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1B58;
  sub_AB124(a1);
  return v1;
}
// F1B58: using guessed type void *off_F1B58;

//----- (000AC3BC) --------------------------------------------------------
_DWORD *__fastcall sub_AC3BC(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1A28;
  sub_AB124(a1);
  return v1;
}
// F1A28: using guessed type void *off_F1A28;

//----- (000AC3D4) --------------------------------------------------------
_DWORD *__fastcall sub_AC3D4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1878;
  sub_AB124(a1);
  return v1;
}
// F1878: using guessed type void *off_F1878;

//----- (000AC3EC) --------------------------------------------------------
void **__fastcall sub_AC3EC(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (000AC404) --------------------------------------------------------
void **__fastcall sub_AC404(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (000AC41C) --------------------------------------------------------
void **__fastcall sub_AC41C(void **a1, int a2)
{
  void **v2; // r4

  v2 = a1;
  sub_C1C58(a1, *(char **)(*(_DWORD *)(a2 + 8) + 8));
  return v2;
}

//----- (000AC434) --------------------------------------------------------
wchar_t **__fastcall sub_AC434(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (000AC44C) --------------------------------------------------------
wchar_t **__fastcall sub_AC44C(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 36));
  return v2;
}

//----- (000AC464) --------------------------------------------------------
wchar_t **__fastcall sub_AC464(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 44));
  return v2;
}

//----- (000AC47C) --------------------------------------------------------
wchar_t **__fastcall sub_AC47C(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (000AC494) --------------------------------------------------------
wchar_t **__fastcall sub_AC494(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 36));
  return v2;
}

//----- (000AC4AC) --------------------------------------------------------
wchar_t **__fastcall sub_AC4AC(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 44));
  return v2;
}

//----- (000AC4C4) --------------------------------------------------------
wchar_t **__fastcall sub_AC4C4(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 20));
  return v2;
}

//----- (000AC4DC) --------------------------------------------------------
wchar_t **__fastcall sub_AC4DC(wchar_t **a1, int a2)
{
  wchar_t **v2; // r4

  v2 = a1;
  sub_BB064(a1, *(const wchar_t **)(*(_DWORD *)(a2 + 8) + 28));
  return v2;
}

//----- (000AC4F4) --------------------------------------------------------
_DWORD *__fastcall sub_AC4F4(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0

  v1 = *(unsigned __int8 *)(a1 + 108);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F1BC8;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[7];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[9];
    if ( v5 )
      operator delete[](v5);
    v6 = (void *)v2[11];
    if ( v6 )
      operator delete[](v6);
  }
  sub_AB124(v2);
  return v2;
}
// F1BC8: using guessed type void *off_F1BC8;

//----- (000AC534) --------------------------------------------------------
_DWORD *__fastcall sub_AC534(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0

  v1 = *(unsigned __int8 *)(a1 + 108);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F1BD8;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[7];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[9];
    if ( v5 )
      operator delete[](v5);
    v6 = (void *)v2[11];
    if ( v6 )
      operator delete[](v6);
  }
  sub_AB124(v2);
  return v2;
}
// F1BD8: using guessed type void *off_F1BD8;

//----- (000AC574) --------------------------------------------------------
_DWORD *__fastcall sub_AC574(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0

  v1 = *(unsigned __int8 *)(a1 + 292);
  v2 = (_DWORD *)a1;
  *(_DWORD *)a1 = &off_F1BE8;
  if ( v1 )
  {
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      operator delete[](v3);
    v4 = (void *)v2[5];
    if ( v4 )
      operator delete[](v4);
    v5 = (void *)v2[7];
    if ( v5 )
      operator delete[](v5);
  }
  sub_AB124(v2);
  return v2;
}
// F1BE8: using guessed type void *off_F1BE8;

//----- (000AC5AC) --------------------------------------------------------
void *__fastcall sub_AC5AC(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_AC4F4(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC5C0) --------------------------------------------------------
void *__fastcall sub_AC5C0(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_AC534(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC5D4) --------------------------------------------------------
void *__fastcall sub_AC5D4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1AF8;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1AF8: using guessed type void *off_F1AF8;

//----- (000AC5F4) --------------------------------------------------------
void *__fastcall sub_AC5F4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1B10;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1B10: using guessed type void *off_F1B10;

//----- (000AC614) --------------------------------------------------------
void *__fastcall sub_AC614(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_AC574(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC628) --------------------------------------------------------
void *__fastcall sub_AC628(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1908;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1908: using guessed type void *off_F1908;

//----- (000AC648) --------------------------------------------------------
void *__fastcall sub_AC648(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1948;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1948: using guessed type void *off_F1948;

//----- (000AC668) --------------------------------------------------------
void *__fastcall sub_AC668(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_AC344(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC67C) --------------------------------------------------------
void *__fastcall sub_AC67C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1B28;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1B28: using guessed type void *off_F1B28;

//----- (000AC69C) --------------------------------------------------------
void *__fastcall sub_AC69C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1B28;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1B28: using guessed type void *off_F1B28;

//----- (000AC6BC) --------------------------------------------------------
void *__fastcall sub_AC6BC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1B58;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1B58: using guessed type void *off_F1B58;

//----- (000AC6DC) --------------------------------------------------------
void *__fastcall sub_AC6DC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1B58;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1B58: using guessed type void *off_F1B58;

//----- (000AC6FC) --------------------------------------------------------
void *__fastcall sub_AC6FC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1A28;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1A28: using guessed type void *off_F1A28;

//----- (000AC71C) --------------------------------------------------------
void *__fastcall sub_AC71C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1878;
  sub_AB124(a1);
  operator delete(v1);
  return v1;
}
// F1878: using guessed type void *off_F1878;

//----- (000AC73C) --------------------------------------------------------
_DWORD *__fastcall sub_AC73C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1A08;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F1A08: using guessed type void *off_F1A08;

//----- (000AC768) --------------------------------------------------------
void *__fastcall sub_AC768(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_AC73C(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC77C) --------------------------------------------------------
_DWORD *__fastcall sub_AC77C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1BA8;
  sub_AC73C(a1);
  return v1;
}
// F1BA8: using guessed type void *;

//----- (000AC794) --------------------------------------------------------
void *__fastcall sub_AC794(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1BA8;
  sub_AC73C(a1);
  operator delete(v1);
  return v1;
}
// F1BA8: using guessed type void *off_F1BA8;

//----- (000AC7B4) --------------------------------------------------------
_DWORD *__fastcall sub_AC7B4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1838;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F1838: using guessed type void *off_F1838;

//----- (000AC7E0) --------------------------------------------------------
_DWORD *__fastcall sub_AC7E0(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1A88;
  sub_C2C38(a1);
  return v1;
}
// F1A88: using guessed type void *;

//----- (000AC7F8) --------------------------------------------------------
void *__fastcall sub_AC7F8(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1A88;
  sub_C2C38(a1);
  operator delete(v1);
  return v1;
}
// F1A88: using guessed type void *off_F1A88;

//----- (000AC818) --------------------------------------------------------
_DWORD *__fastcall sub_AC818(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1AC0;
  sub_C2BF4(a1);
  return v1;
}
// F1AC0: using guessed type void *;

//----- (000AC830) --------------------------------------------------------
void *__fastcall sub_AC830(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1AC0;
  sub_C2BF4(a1);
  operator delete(v1);
  return v1;
}
// F1AC0: using guessed type void *off_F1AC0;

//----- (000AC850) --------------------------------------------------------
_DWORD *__fastcall sub_AC850(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F18E0;
  sub_C299C(a1);
  return v1;
}
// F18E0: using guessed type void *;

//----- (000AC868) --------------------------------------------------------
void *__fastcall sub_AC868(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F18E0;
  sub_C299C(a1);
  operator delete(v1);
  return v1;
}
// F18E0: using guessed type void *off_F18E0;

//----- (000AC888) --------------------------------------------------------
_DWORD *__fastcall sub_AC888(_DWORD *a1)
{
  _DWORD *v1; // r4
  char *v2; // r5
  int v3; // r0

  v1 = a1;
  v2 = (char *)a1[4];
  *a1 = &off_F1988;
  if ( v2 != sub_AB4DC() && v2 )
    operator delete[](v2);
  v3 = v1[2];
  if ( v3 )
    (*(void (**)(void))(*(_DWORD *)v3 + 4))();
  sub_A8038(v1 + 3);
  sub_AB124(v1);
  return v1;
}
// F1988: using guessed type void *off_F1988;

//----- (000AC8D0) --------------------------------------------------------
void *__fastcall sub_AC8D0(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_AC888(a1);
  operator delete(v1);
  return v1;
}

//----- (000AC8E4) --------------------------------------------------------
_DWORD *__fastcall sub_AC8E4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1A58;
  sub_A034C(a1);
  return v1;
}
// F1A58: using guessed type void *;

//----- (000AC8FC) --------------------------------------------------------
void *__fastcall sub_AC8FC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1A58;
  sub_A034C(a1);
  operator delete(v1);
  return v1;
}
// F1A58: using guessed type void *off_F1A58;

//----- (000AC91C) --------------------------------------------------------
_DWORD *__fastcall sub_AC91C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1838;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  return v1;
}
// F1838: using guessed type void *off_F1838;

//----- (000AC948) --------------------------------------------------------
_DWORD *__fastcall sub_AC948(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1838;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  operator delete(v1);
  return v1;
}
// F1838: using guessed type void *off_F1838;

//----- (000AC978) --------------------------------------------------------
_DWORD *__fastcall sub_AC978(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1838;
  sub_A8038(a1 + 2);
  sub_AB124(v1);
  operator delete(v1);
  return v1;
}
// F1838: using guessed type void *off_F1838;

//----- (000AC9A8) --------------------------------------------------------
signed int __fastcall sub_AC9A8(int a1, const wchar_t *a2, const wchar_t *a3, const wchar_t *a4, const wchar_t *a5)
{
  const wchar_t *v5; // r5
  int v6; // r6
  wchar_t *v7; // r9
  wchar_t *v8; // r10
  const wchar_t *v9; // r4
  const wchar_t *v10; // r5
  int v11; // r8
  int v12; // r7
  size_t v13; // r5
  size_t v14; // r0
  int v15; // r11
  signed int v16; // r5
  wchar_t *v17; // r0
  wchar_t *v18; // r0
  unsigned int *v20; // r10
  signed int v21; // r3
  unsigned int *v22; // r9
  signed int v23; // r3

  v5 = a4;
  v6 = a1;
  v7 = sub_BAD4C(a2, a3);
  v8 = sub_BAD4C(v5, a5);
  v9 = v8;
  v10 = v7;
  v11 = (int)&v8[2 * *((_DWORD *)v8 - 3)];
  v12 = (int)&v7[2 * *((_DWORD *)v7 - 3)];
  while ( 1 )
  {
    v15 = sub_AAB18(v6, v10, v9);
    if ( v15
      || (v13 = (size_t)&v10[2 * wcslen(v10)], v14 = (size_t)&v9[2 * wcslen(v9)], v14 - v11 <= 0 && v13 - v12 <= 0) )
    {
      v16 = v15;
      goto LABEL_8;
    }
    if ( v13 - v12 <= 0 )
    {
      v16 = -1;
      goto LABEL_8;
    }
    if ( v14 - v11 <= 0 )
      break;
    v10 = (const wchar_t *)(v13 + 4);
    v9 = (const wchar_t *)(v14 + 4);
  }
  v16 = 1;
LABEL_8:
  v17 = v8 - 6;
  if ( v8 - 6 != (wchar_t *)&unk_2FEF24 )
  {
    v20 = (unsigned int *)(v8 - 2);
    __dmb(0xFu);
    do
      v21 = __ldrex(v20);
    while ( __strex(v21 - 1, v20) );
    __dmb(0xFu);
    if ( v21 <= 0 )
      operator delete(v17);
  }
  v18 = v7 - 6;
  if ( v7 - 6 != (wchar_t *)&unk_2FEF24 )
  {
    v22 = (unsigned int *)(v7 - 2);
    __dmb(0xFu);
    do
      v23 = __ldrex(v22);
    while ( __strex(v23 - 1, v22) );
    __dmb(0xFu);
    if ( v23 <= 0 )
      operator delete(v18);
  }
  return v16;
}

//----- (000ACAB4) --------------------------------------------------------
int *__fastcall sub_ACAB4(int *a1, int a2, const wchar_t *a3, const wchar_t *a4)
{
  int *v4; // r7
  const wchar_t *v5; // r6
  const wchar_t *v6; // r4
  int v7; // r9
  unsigned int v8; // r6
  int v9; // r11
  unsigned int v10; // r0
  wchar_t *v11; // r5
  const wchar_t *v12; // r4
  int v13; // r3
  int v14; // r2
  int v15; // r8
  size_t v16; // r0
  unsigned int v17; // r0
  size_t v18; // r0
  wchar_t *v20; // [sp+0h] [bp-38h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  *a1 = (int)&unk_2FEF30;
  v20 = sub_BAD4C(a3, a4);
  v8 = v5 - v6;
  v9 = (int)&v20[2 * *((_DWORD *)v20 - 3)];
  if ( v8 > 0x1FC00000 )
    v10 = -1;
  else
    v10 = 4 * v8;
  v11 = (wchar_t *)operator new[](v10);
  v12 = v20;
  while ( 1 )
  {
    v16 = sub_AAB30(v7, v11, v12, v8);
    if ( v8 <= v16 )
    {
      v8 = v16 + 1;
      if ( v11 )
        operator delete[](v11);
      if ( v8 > 0x1FC00000 )
        v17 = -1;
      else
        v17 = 4 * v8;
      v11 = (wchar_t *)operator new[](v17);
      v16 = sub_AAB30(v7, v11, v12, v8);
    }
    sub_BA748(v4, (unsigned int)v11, v16);
    v18 = (size_t)&v12[2 * wcslen(v12)];
    if ( v18 == v9 )
      break;
    v13 = *v4;
    v12 = (const wchar_t *)(v18 + 4);
    v14 = *(_DWORD *)(*v4 - 12);
    v15 = v14 + 1;
    if ( (unsigned int)(v14 + 1) > *(_DWORD *)(*v4 - 8) || *(_DWORD *)(v13 - 4) > 0 )
    {
      sub_BA5B8(v4, v14 + 1);
      v13 = *v4;
      v14 = *(_DWORD *)(*v4 - 12);
    }
    *(_DWORD *)(v13 + 4 * v14) = 0;
    if ( (_UNKNOWN *)(v13 - 12) != &unk_2FEF24 )
    {
      *(_DWORD *)(v13 - 4) = 0;
      *(_DWORD *)(v13 - 12) = v15;
      *(_DWORD *)(v13 + 4 * v15) = 0;
    }
  }
  if ( v11 )
    operator delete[](v11);
  sub_B9DE0((unsigned int *)v20 - 3);
  return v4;
}

//----- (000ACD50) --------------------------------------------------------
_DWORD *__fastcall sub_ACD50(_DWORD *a1, signed int a2)
{
  signed int v2; // r5
  _DWORD *v3; // r4

  v2 = a2;
  if ( a2 )
    v2 = 1;
  *a1 = &off_F1998;
  a1[1] = v2;
  a1[2] = 0;
  v3 = a1;
  sub_C2E2C((int)a1);
  return v3;
}
// F1998: using guessed type void *off_F1998;

//----- (000AD7A0) --------------------------------------------------------
int __fastcall sub_AD7A0(_DWORD *a1, int a2, int a3)
{
  int v3; // r4

  a1[2] = a2;
  a1[1] = a3 != 0;
  *a1 = &off_F1988;
  v3 = (int)a1;
  a1[4] = sub_AB4DC();
  sub_A840C(v3);
  return v3;
}
// F1988: using guessed type void *;

//----- (000ADC24) --------------------------------------------------------
_DWORD *__fastcall sub_ADC24(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4

  a1[1] = a2 != 0;
  v2 = a1;
  *a1 = &off_F1A08;
  a1[2] = sub_AB4B8();
  return v2;
}
// F1A08: using guessed type void *;

//----- (000ADE94) --------------------------------------------------------
int __fastcall sub_ADE94(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEEA0);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::ctype<wchar_t>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1520: using guessed type int *`typeinfo for'std::ctype<wchar_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000ADFFC) --------------------------------------------------------
_DWORD *__fastcall sub_ADFFC(_DWORD *a1, int a2, _DWORD *a3, signed int a4, _DWORD *a5, unsigned int *a6, int *a7, int a8, int a9, int a10, int a11, unsigned int *a12)
{
  signed int v12; // r5
  _DWORD *v13; // r11
  _DWORD *v14; // r4
  signed int v15; // r7
  unsigned int *v16; // r0
  int v17; // r6
  int v18; // r8
  unsigned int *v19; // r10
  unsigned int *v20; // r9
  int v21; // r3
  unsigned int **v22; // r2
  bool v23; // zf
  int *v24; // r3
  _DWORD *result; // r0
  signed int *v26; // r3
  int v27; // r1
  unsigned int v28; // r3
  int *v29; // r3
  int v30; // ST04_4
  _DWORD *v31; // [sp+Ch] [bp-34h]

  v31 = a1;
  v13 = a5;
  v14 = a3;
  v15 = a4;
  v16 = (unsigned int *)sub_ADE94(a11 + 108);
  if ( a10 == 2 )
    v12 = 10;
  if ( a10 != 2 )
  {
    if ( a10 == 4 )
      v12 = 1000;
    else
      v12 = 1;
  }
  v17 = 0;
  v18 = 0;
  v19 = v16;
  v20 = a6;
  while ( 1 )
  {
    v21 = 1;
    if ( v14 )
    {
      if ( v15 == -1 )
      {
        v26 = (signed int *)v14[2];
        if ( (unsigned int)v26 >= v14[3] )
        {
          v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v14 + 36))(v14);
          v15 = (signed int)v16;
        }
        else
        {
          v15 = *v26;
        }
        v21 = v15 + 1;
        if ( v15 == -1 )
          v14 = 0;
        else
          v21 = 0;
        if ( v15 == -1 )
          v21 = 1;
      }
      else
      {
        v21 = 0;
      }
    }
    v22 = (unsigned int **)(&dword_0 + 1);
    if ( v13 )
    {
      if ( v20 == (unsigned int *)-1 )
      {
        v22 = (unsigned int **)v13[2];
        if ( (unsigned int)v22 >= v13[3] )
        {
          v30 = v21;
          v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v13 + 36))(v13);
          v21 = v30;
          v20 = v16;
        }
        else
        {
          v20 = *v22;
        }
        if ( v20 == (unsigned int *)-1 )
          v13 = 0;
        else
          v22 = 0;
        if ( v20 == (unsigned int *)-1 )
          v22 = (unsigned int **)(&dword_0 + 1);
      }
      else
      {
        v22 = 0;
      }
    }
    if ( (unsigned int **)v21 == v22 )
      break;
    if ( v18 == a10 )
      goto LABEL_31;
    if ( v14 )
    {
      if ( v15 == -1 )
      {
        v29 = (int *)v14[2];
        if ( (unsigned int)v29 >= v14[3] )
          v27 = (*(int (__fastcall **)(_DWORD *))(*v14 + 36))(v14);
        else
          v27 = *v29;
        if ( v27 == -1 )
          v14 = 0;
        else
          v15 = v27;
        if ( v27 == -1 )
          v15 = -1;
      }
      else
      {
        v27 = v15;
      }
    }
    else
    {
      v27 = -1;
    }
    v16 = (unsigned int *)((*(int (__fastcall **)(unsigned int *, int, signed int))(*v19 + 48))(v19, v27, 42) - 48);
    if ( (unsigned __int8)v16 > 9u )
      goto LABEL_18;
    v17 = (int)v16 + 10 * v17;
    v16 = (unsigned int *)a9;
    if ( v12 * v17 > a9 || a8 >= v12 * v17 + v12 )
      goto LABEL_18;
    v12 /= 10;
    if ( v14 )
    {
      v28 = v14[2];
      if ( v28 >= v14[3] )
        v16 = (unsigned int *)(*(int (__fastcall **)(_DWORD *))(*v14 + 40))(v14);
      else
        v14[2] = v28 + 4;
      v15 = -1;
    }
    ++v18;
  }
  if ( v18 == a10 )
  {
LABEL_31:
    *a7 = v17;
    goto LABEL_29;
  }
LABEL_18:
  v23 = v18 == 2;
  if ( v18 == 2 )
    v23 = a10 == 4;
  if ( v23 )
    v17 -= 100;
  else
    v16 = a12;
  if ( v23 )
    v24 = a7;
  else
    v24 = (int *)*v16;
  if ( v23 )
    *v24 = v17;
  else
    *v16 = (unsigned int)v24 | 4;
LABEL_29:
  result = v31;
  *v31 = v14;
  v31[1] = v15;
  return result;
}
// 0: using guessed type int dword_0;

//----- (000AE198) --------------------------------------------------------
_DWORD *__fastcall sub_AE198(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r5
  int v10; // r8
  int v11; // r1
  _DWORD *v12; // r4
  int v13; // r6
  int v14; // r3
  signed int v15; // r8
  signed int v16; // r3
  bool v17; // zf
  _DWORD *result; // r0
  int *v19; // r3
  int v20; // r0
  int *v21; // r3
  char v22; // [sp+20h] [bp-38h]
  int v23; // [sp+24h] [bp-34h]
  _DWORD *v24; // [sp+28h] [bp-30h]
  int v25; // [sp+2Ch] [bp-2Ch]
  int v26; // [sp+30h] [bp-28h]
  int v27; // [sp+34h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v24 = a3;
  v25 = a4;
  sub_ADE94(a7 + 108);
  v27 = 0;
  sub_ADFFC(&v22, v10, v24, v25, a5, a6, &v26, 0, 9999, 4, a7, (unsigned int *)&v27);
  v11 = v23;
  v24 = *(_DWORD **)&v22;
  v25 = v23;
  v12 = *(_DWORD **)&v22;
  v13 = v23;
  if ( v27 )
  {
    *a8 |= 4u;
  }
  else
  {
    v11 = a9;
    if ( v26 >= 0 )
      v14 = v26 - 1900;
    else
      v14 = v26 + 100;
    *(_DWORD *)(a9 + 20) = v14;
  }
  v15 = 1;
  if ( v12 )
  {
    if ( v13 == -1 )
    {
      v21 = (int *)v12[2];
      if ( (unsigned int)v21 >= v12[3] )
        v13 = (*(int (__fastcall **)(_DWORD *, int))(*v12 + 36))(v12, v11);
      else
        v13 = *v21;
      if ( v13 == -1 )
        v12 = 0;
      else
        v15 = 0;
      if ( v13 == -1 )
        v15 = 1;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = 1;
  if ( a5 )
  {
    if ( a6 == (unsigned int *)-1 )
    {
      v19 = (int *)a5[2];
      if ( (unsigned int)v19 >= a5[3] )
        v20 = (*(int (**)(void))(*a5 + 36))();
      else
        v20 = *v19;
      v16 = (unsigned int)(v20 + 1) <= 0;
    }
    else
    {
      v16 = 0;
    }
  }
  v17 = v16 == v15;
  result = v9;
  *v9 = v12;
  if ( v16 == v15 )
    v16 = *a8;
  v9[1] = v13;
  if ( v17 )
    *a8 = v16 | 2;
  return result;
}

//----- (000AE2A4) --------------------------------------------------------
int __fastcall sub_AE2A4(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0CC);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::codecvt<wchar_t,char,mbstate_t>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F0F58: using guessed type int *`typeinfo for'std::codecvt<wchar_t,char,mbstate_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000AE334) --------------------------------------------------------
int __fastcall sub_AE334(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF10);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::numpunct<wchar_t>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1D0C: using guessed type int *`typeinfo for'std::numpunct<wchar_t>;

//----- (000AE378) --------------------------------------------------------
int __fastcall sub_AE378(int a1, int a2)
{
  int v2; // r4
  int v3; // r10
  int v4; // r5
  char *v5; // r2
  unsigned int v6; // r0
  char *v7; // r3
  bool v8; // zf
  _BYTE *v9; // r7
  void *v10; // r0
  int v11; // r3
  int v12; // r2
  char *v13; // r2
  unsigned int v14; // r0
  char *v15; // r3
  unsigned int v16; // r0
  wchar_t *v17; // r9
  void *v18; // r0
  int v19; // r3
  char *v20; // r2
  unsigned int v21; // r0
  char *v22; // r3
  unsigned int v23; // r0
  wchar_t *v24; // r8
  void *v25; // r0
  int v26; // r3
  int v27; // r0
  int v28; // r3
  int v29; // r5
  unsigned int *v31; // r2
  signed int v32; // r1
  unsigned int *v33; // r3
  signed int v34; // r2
  unsigned int *v35; // r2
  signed int v36; // r1
  unsigned int *v37; // r3
  signed int v38; // r2
  unsigned int *v39; // r2
  signed int v40; // r1
  unsigned int *v41; // r3
  signed int v42; // r2
  void *v43; // [sp+8h] [bp-40h]
  int v44; // [sp+Ch] [bp-3Ch]
  void *v45; // [sp+10h] [bp-38h]
  int v46; // [sp+14h] [bp-34h]
  void *v47; // [sp+18h] [bp-30h]
  int v48; // [sp+1Ch] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 292) = 1;
  v3 = a2;
  v4 = sub_AE334(a2);
  (*(void (__fastcall **)(void **, int))(*(_DWORD *)v4 + 16))(&v43, v4);
  v5 = (char *)v43;
  v7 = (char *)v43 - 12;
  v6 = *((_DWORD *)v43 - 3);
  v8 = (char *)v43 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v6;
  if ( !v8 )
  {
    v31 = (unsigned int *)(v5 - 4);
    __dmb(0xFu);
    do
      v32 = __ldrex(v31);
    while ( __strex(v32 - 1, v31) );
    __dmb(0xFu);
    if ( v32 <= 0 )
      operator delete(v7);
    v6 = *(_DWORD *)(v2 + 12);
  }
  v9 = operator new[](v6);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 16))(&v44, v4);
  sub_C0440(&v44, v9, *(_DWORD *)(v2 + 12), 0);
  v10 = (void *)(v44 - 12);
  if ( (int *)(v44 - 12) != &dword_2FEF3C )
  {
    v41 = (unsigned int *)(v44 - 4);
    __dmb(0xFu);
    do
      v42 = __ldrex(v41);
    while ( __strex(v42 - 1, v41) );
    __dmb(0xFu);
    if ( v42 <= 0 )
      operator delete(v10);
  }
  v11 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v9;
  if ( v11 )
    LOBYTE(v11) = (char)*v9 > 0;
  v12 = *(_DWORD *)v4;
  *(_BYTE *)(v2 + 16) = v11;
  (*(void (__fastcall **)(void **, int))(v12 + 20))(&v45, v4);
  v13 = (char *)v45;
  v15 = (char *)v45 - 12;
  v14 = *((_DWORD *)v45 - 3);
  v8 = (char *)v45 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 24) = v14;
  if ( !v8 )
  {
    v39 = (unsigned int *)(v13 - 4);
    __dmb(0xFu);
    do
      v40 = __ldrex(v39);
    while ( __strex(v40 - 1, v39) );
    __dmb(0xFu);
    if ( v40 <= 0 )
      operator delete(v15);
    v14 = *(_DWORD *)(v2 + 24);
  }
  if ( v14 > 0x1FC00000 )
    v16 = -1;
  else
    v16 = 4 * v14;
  v17 = (wchar_t *)operator new[](v16);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 20))(&v46, v4);
  sub_B96FC(&v46, v17, *(_DWORD *)(v2 + 24), 0);
  v18 = (void *)(v46 - 12);
  if ( (_UNKNOWN *)(v46 - 12) != &unk_2FEF24 )
  {
    v37 = (unsigned int *)(v46 - 4);
    __dmb(0xFu);
    do
      v38 = __ldrex(v37);
    while ( __strex(v38 - 1, v37) );
    __dmb(0xFu);
    if ( v38 <= 0 )
      operator delete(v18);
  }
  v19 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 20) = v17;
  (*(void (**)(void))(v19 + 24))();
  v20 = (char *)v47;
  v22 = (char *)v47 - 12;
  v21 = *((_DWORD *)v47 - 3);
  v8 = (char *)v47 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 32) = v21;
  if ( !v8 )
  {
    v35 = (unsigned int *)(v20 - 4);
    __dmb(0xFu);
    do
      v36 = __ldrex(v35);
    while ( __strex(v36 - 1, v35) );
    __dmb(0xFu);
    if ( v36 <= 0 )
      operator delete(v22);
    v21 = *(_DWORD *)(v2 + 32);
  }
  if ( v21 > 0x1FC00000 )
    v23 = -1;
  else
    v23 = 4 * v21;
  v24 = (wchar_t *)operator new[](v23);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v4 + 24))(&v48, v4);
  sub_B96FC(&v48, v24, *(_DWORD *)(v2 + 32), 0);
  v25 = (void *)(v48 - 12);
  if ( (_UNKNOWN *)(v48 - 12) != &unk_2FEF24 )
  {
    v33 = (unsigned int *)(v48 - 4);
    __dmb(0xFu);
    do
      v34 = __ldrex(v33);
    while ( __strex(v34 - 1, v33) );
    __dmb(0xFu);
    if ( v34 <= 0 )
      operator delete(v25);
  }
  v26 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 28) = v24;
  v27 = (*(int (__fastcall **)(int))(v26 + 8))(v4);
  v28 = *(_DWORD *)v4;
  *(_DWORD *)(v2 + 36) = v27;
  *(_DWORD *)(v2 + 40) = (*(int (__fastcall **)(int))(v28 + 12))(v4);
  v29 = sub_ADE94(v3);
  (*(void (**)(void))(*(_DWORD *)v29 + 44))();
  return (*(int (__fastcall **)(int, char *, char *, int))(*(_DWORD *)v29 + 44))(
           v29,
           off_F3C54[0],
           off_F3C54[0] + 26,
           v2 + 188);
}
// F3C54: using guessed type char *off_F3C54[17];
// F3C58: using guessed type char *off_F3C58[16];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000AE684) --------------------------------------------------------
int __fastcall sub_AE684(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF08);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1C70: using guessed type int *`typeinfo for'std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>;

//----- (000AE6C8) --------------------------------------------------------
int __fastcall sub_AE6C8(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF0C);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1CE0: using guessed type int *`typeinfo for'std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>;

//----- (000AE70C) --------------------------------------------------------
int __fastcall sub_AE70C(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF1C);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::moneypunct<wchar_t,true>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1D30: using guessed type int *`typeinfo for'std::moneypunct<wchar_t,true>;

//----- (000AE750) --------------------------------------------------------
int __fastcall sub_AE750(int a1, int a2)
{
  int v2; // r5
  int v3; // r10
  int v4; // r0
  int v5; // r4
  int v6; // r0
  int (__fastcall *v7)(int); // r3
  int v8; // r0
  int (__fastcall *v9)(int); // r3
  int v10; // r0
  void (__fastcall *v11)(void **, int); // r3
  char *v12; // r2
  unsigned int v13; // r0
  char *v14; // r3
  bool v15; // zf
  _BYTE *v16; // r7
  void *v17; // r0
  int v18; // r3
  int v19; // r2
  char *v20; // r2
  unsigned int v21; // r0
  char *v22; // r3
  unsigned int v23; // r0
  void *v24; // r0
  int v25; // r3
  char *v26; // r2
  unsigned int v27; // r0
  char *v28; // r3
  unsigned int v29; // r0
  wchar_t *v30; // r9
  void *v31; // r0
  int v32; // r3
  char *v33; // r2
  unsigned int v34; // r0
  char *v35; // r3
  unsigned int v36; // r0
  wchar_t *v37; // r8
  void *v38; // r0
  int v39; // r3
  int v40; // r0
  int v41; // r2
  int v42; // r0
  int v43; // r0
  unsigned int *v45; // r2
  signed int v46; // r1
  unsigned int *v47; // r3
  signed int v48; // r2
  unsigned int *v49; // r2
  signed int v50; // r1
  unsigned int *v51; // r3
  signed int v52; // r2
  unsigned int *v53; // r2
  signed int v54; // r1
  unsigned int *v55; // r3
  signed int v56; // r2
  unsigned int *v57; // r2
  signed int v58; // r1
  unsigned int *v59; // r3
  signed int v60; // r2
  wchar_t *v61; // [sp+4h] [bp-5Ch]
  void *v62; // [sp+8h] [bp-58h]
  int v63; // [sp+Ch] [bp-54h]
  void *v64; // [sp+10h] [bp-50h]
  int v65; // [sp+14h] [bp-4Ch]
  void *v66; // [sp+18h] [bp-48h]
  int v67; // [sp+1Ch] [bp-44h]
  void *v68; // [sp+20h] [bp-40h]
  int v69; // [sp+24h] [bp-3Ch]
  int v70; // [sp+28h] [bp-38h]
  int v71; // [sp+2Ch] [bp-34h]
  int v72; // [sp+30h] [bp-30h]
  int v73; // [sp+34h] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 108) = 1;
  v3 = a2;
  v4 = sub_AE70C(a2);
  v5 = v4;
  v6 = (*(int (**)(void))(*(_DWORD *)v4 + 8))();
  v7 = *(int (__fastcall **)(int))(*(_DWORD *)v5 + 12);
  *(_DWORD *)(v2 + 20) = v6;
  v8 = v7(v5);
  v9 = *(int (__fastcall **)(int))(*(_DWORD *)v5 + 32);
  *(_DWORD *)(v2 + 24) = v8;
  v10 = v9(v5);
  v11 = *(void (__fastcall **)(void **, int))(*(_DWORD *)v5 + 16);
  *(_DWORD *)(v2 + 52) = v10;
  v11(&v62, v5);
  v12 = (char *)v62;
  v14 = (char *)v62 - 12;
  v13 = *((_DWORD *)v62 - 3);
  v15 = (char *)v62 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v13;
  if ( !v15 )
  {
    v45 = (unsigned int *)(v12 - 4);
    __dmb(0xFu);
    do
      v46 = __ldrex(v45);
    while ( __strex(v46 - 1, v45) );
    __dmb(0xFu);
    if ( v46 <= 0 )
      operator delete(v14);
    v13 = *(_DWORD *)(v2 + 12);
  }
  v16 = operator new[](v13);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 16))(&v63, v5);
  sub_C0440(&v63, v16, *(_DWORD *)(v2 + 12), 0);
  v17 = (void *)(v63 - 12);
  if ( (int *)(v63 - 12) != &dword_2FEF3C )
  {
    v55 = (unsigned int *)(v63 - 4);
    __dmb(0xFu);
    do
      v56 = __ldrex(v55);
    while ( __strex(v56 - 1, v55) );
    __dmb(0xFu);
    if ( v56 <= 0 )
      operator delete(v17);
  }
  v18 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v16;
  if ( v18 )
    LOBYTE(v18) = (char)*v16 > 0;
  v19 = *(_DWORD *)v5;
  *(_BYTE *)(v2 + 16) = v18;
  (*(void (__fastcall **)(void **, int))(v19 + 20))(&v64, v5);
  v20 = (char *)v64;
  v22 = (char *)v64 - 12;
  v21 = *((_DWORD *)v64 - 3);
  v15 = (char *)v64 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 32) = v21;
  if ( !v15 )
  {
    v53 = (unsigned int *)(v20 - 4);
    __dmb(0xFu);
    do
      v54 = __ldrex(v53);
    while ( __strex(v54 - 1, v53) );
    __dmb(0xFu);
    if ( v54 <= 0 )
      operator delete(v22);
    v21 = *(_DWORD *)(v2 + 32);
  }
  if ( v21 > 0x1FC00000 )
    v23 = -1;
  else
    v23 = 4 * v21;
  v61 = (wchar_t *)operator new[](v23);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 20))(&v65, v5);
  sub_B96FC(&v65, v61, *(_DWORD *)(v2 + 32), 0);
  v24 = (void *)(v65 - 12);
  if ( (_UNKNOWN *)(v65 - 12) != &unk_2FEF24 )
  {
    v51 = (unsigned int *)(v65 - 4);
    __dmb(0xFu);
    do
      v52 = __ldrex(v51);
    while ( __strex(v52 - 1, v51) );
    __dmb(0xFu);
    if ( v52 <= 0 )
      operator delete(v24);
  }
  v25 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 28) = v61;
  (*(void (__fastcall **)(void **, int))(v25 + 24))(&v66, v5);
  v26 = (char *)v66;
  v28 = (char *)v66 - 12;
  v27 = *((_DWORD *)v66 - 3);
  v15 = (char *)v66 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 40) = v27;
  if ( !v15 )
  {
    v49 = (unsigned int *)(v26 - 4);
    __dmb(0xFu);
    do
      v50 = __ldrex(v49);
    while ( __strex(v50 - 1, v49) );
    __dmb(0xFu);
    if ( v50 <= 0 )
      operator delete(v28);
    v27 = *(_DWORD *)(v2 + 40);
  }
  if ( v27 > 0x1FC00000 )
    v29 = -1;
  else
    v29 = 4 * v27;
  v30 = (wchar_t *)operator new[](v29);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 24))(&v67, v5);
  sub_B96FC(&v67, v30, *(_DWORD *)(v2 + 40), 0);
  v31 = (void *)(v67 - 12);
  if ( (_UNKNOWN *)(v67 - 12) != &unk_2FEF24 )
  {
    v59 = (unsigned int *)(v67 - 4);
    __dmb(0xFu);
    do
      v60 = __ldrex(v59);
    while ( __strex(v60 - 1, v59) );
    __dmb(0xFu);
    if ( v60 <= 0 )
      operator delete(v31);
  }
  v32 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 36) = v30;
  (*(void (__fastcall **)(void **, int))(v32 + 28))(&v68, v5);
  v33 = (char *)v68;
  v35 = (char *)v68 - 12;
  v34 = *((_DWORD *)v68 - 3);
  v15 = (char *)v68 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 48) = v34;
  if ( !v15 )
  {
    v57 = (unsigned int *)(v33 - 4);
    __dmb(0xFu);
    do
      v58 = __ldrex(v57);
    while ( __strex(v58 - 1, v57) );
    __dmb(0xFu);
    if ( v58 <= 0 )
      operator delete(v35);
    v34 = *(_DWORD *)(v2 + 48);
  }
  if ( v34 > 0x1FC00000 )
    v36 = -1;
  else
    v36 = 4 * v34;
  v37 = (wchar_t *)operator new[](v36);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 28))(&v69, v5);
  sub_B96FC(&v69, v37, *(_DWORD *)(v2 + 48), 0);
  v38 = (void *)(v69 - 12);
  if ( (_UNKNOWN *)(v69 - 12) != &unk_2FEF24 )
  {
    v47 = (unsigned int *)(v69 - 4);
    __dmb(0xFu);
    do
      v48 = __ldrex(v47);
    while ( __strex(v48 - 1, v47) );
    __dmb(0xFu);
    if ( v48 <= 0 )
      operator delete(v38);
  }
  v39 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 44) = v37;
  v40 = (*(int (__fastcall **)(int))(v39 + 36))(v5);
  *(_DWORD *)(v2 + 56) = v40;
  v41 = *(_DWORD *)v5;
  v71 = v40;
  v70 = v40;
  v42 = (*(int (__fastcall **)(int))(v41 + 40))(v5);
  *(_DWORD *)(v2 + 60) = v42;
  v73 = v42;
  v72 = v42;
  v43 = sub_ADE94(v3);
  return (*(int (**)(void))(*(_DWORD *)v43 + 44))();
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000AEB48) --------------------------------------------------------
int __fastcall sub_AEB48(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF20);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(
             v3,
             (int)&`typeinfo for'std::locale::facet,
             (int)&`typeinfo for'std::moneypunct<wchar_t,false>,
             0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1C88: using guessed type int *`typeinfo for'std::moneypunct<wchar_t,false>;

//----- (000AEB8C) --------------------------------------------------------
int __fastcall sub_AEB8C(int a1, int a2)
{
  int v2; // r5
  int v3; // r10
  int v4; // r0
  int v5; // r4
  int v6; // r0
  int (__fastcall *v7)(int); // r3
  int v8; // r0
  int (__fastcall *v9)(int); // r3
  int v10; // r0
  void (__fastcall *v11)(void **, int); // r3
  char *v12; // r2
  unsigned int v13; // r0
  char *v14; // r3
  bool v15; // zf
  _BYTE *v16; // r7
  void *v17; // r0
  int v18; // r3
  int v19; // r2
  char *v20; // r2
  unsigned int v21; // r0
  char *v22; // r3
  unsigned int v23; // r0
  void *v24; // r0
  int v25; // r3
  char *v26; // r2
  unsigned int v27; // r0
  char *v28; // r3
  unsigned int v29; // r0
  wchar_t *v30; // r9
  void *v31; // r0
  int v32; // r3
  char *v33; // r2
  unsigned int v34; // r0
  char *v35; // r3
  unsigned int v36; // r0
  wchar_t *v37; // r8
  void *v38; // r0
  int v39; // r3
  int v40; // r0
  int v41; // r2
  int v42; // r0
  int v43; // r0
  unsigned int *v45; // r2
  signed int v46; // r1
  unsigned int *v47; // r3
  signed int v48; // r2
  unsigned int *v49; // r2
  signed int v50; // r1
  unsigned int *v51; // r3
  signed int v52; // r2
  unsigned int *v53; // r2
  signed int v54; // r1
  unsigned int *v55; // r3
  signed int v56; // r2
  unsigned int *v57; // r2
  signed int v58; // r1
  unsigned int *v59; // r3
  signed int v60; // r2
  wchar_t *v61; // [sp+4h] [bp-5Ch]
  void *v62; // [sp+8h] [bp-58h]
  int v63; // [sp+Ch] [bp-54h]
  void *v64; // [sp+10h] [bp-50h]
  int v65; // [sp+14h] [bp-4Ch]
  void *v66; // [sp+18h] [bp-48h]
  int v67; // [sp+1Ch] [bp-44h]
  void *v68; // [sp+20h] [bp-40h]
  int v69; // [sp+24h] [bp-3Ch]
  int v70; // [sp+28h] [bp-38h]
  int v71; // [sp+2Ch] [bp-34h]
  int v72; // [sp+30h] [bp-30h]
  int v73; // [sp+34h] [bp-2Ch]

  v2 = a1;
  *(_BYTE *)(a1 + 108) = 1;
  v3 = a2;
  v4 = sub_AEB48(a2);
  v5 = v4;
  v6 = (*(int (**)(void))(*(_DWORD *)v4 + 8))();
  v7 = *(int (__fastcall **)(int))(*(_DWORD *)v5 + 12);
  *(_DWORD *)(v2 + 20) = v6;
  v8 = v7(v5);
  v9 = *(int (__fastcall **)(int))(*(_DWORD *)v5 + 32);
  *(_DWORD *)(v2 + 24) = v8;
  v10 = v9(v5);
  v11 = *(void (__fastcall **)(void **, int))(*(_DWORD *)v5 + 16);
  *(_DWORD *)(v2 + 52) = v10;
  v11(&v62, v5);
  v12 = (char *)v62;
  v14 = (char *)v62 - 12;
  v13 = *((_DWORD *)v62 - 3);
  v15 = (char *)v62 - 12 == (char *)&dword_2FEF3C;
  *(_DWORD *)(v2 + 12) = v13;
  if ( !v15 )
  {
    v45 = (unsigned int *)(v12 - 4);
    __dmb(0xFu);
    do
      v46 = __ldrex(v45);
    while ( __strex(v46 - 1, v45) );
    __dmb(0xFu);
    if ( v46 <= 0 )
      operator delete(v14);
    v13 = *(_DWORD *)(v2 + 12);
  }
  v16 = operator new[](v13);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 16))(&v63, v5);
  sub_C0440(&v63, v16, *(_DWORD *)(v2 + 12), 0);
  v17 = (void *)(v63 - 12);
  if ( (int *)(v63 - 12) != &dword_2FEF3C )
  {
    v55 = (unsigned int *)(v63 - 4);
    __dmb(0xFu);
    do
      v56 = __ldrex(v55);
    while ( __strex(v56 - 1, v55) );
    __dmb(0xFu);
    if ( v56 <= 0 )
      operator delete(v17);
  }
  v18 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v2 + 8) = v16;
  if ( v18 )
    LOBYTE(v18) = (char)*v16 > 0;
  v19 = *(_DWORD *)v5;
  *(_BYTE *)(v2 + 16) = v18;
  (*(void (__fastcall **)(void **, int))(v19 + 20))(&v64, v5);
  v20 = (char *)v64;
  v22 = (char *)v64 - 12;
  v21 = *((_DWORD *)v64 - 3);
  v15 = (char *)v64 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 32) = v21;
  if ( !v15 )
  {
    v53 = (unsigned int *)(v20 - 4);
    __dmb(0xFu);
    do
      v54 = __ldrex(v53);
    while ( __strex(v54 - 1, v53) );
    __dmb(0xFu);
    if ( v54 <= 0 )
      operator delete(v22);
    v21 = *(_DWORD *)(v2 + 32);
  }
  if ( v21 > 0x1FC00000 )
    v23 = -1;
  else
    v23 = 4 * v21;
  v61 = (wchar_t *)operator new[](v23);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 20))(&v65, v5);
  sub_B96FC(&v65, v61, *(_DWORD *)(v2 + 32), 0);
  v24 = (void *)(v65 - 12);
  if ( (_UNKNOWN *)(v65 - 12) != &unk_2FEF24 )
  {
    v51 = (unsigned int *)(v65 - 4);
    __dmb(0xFu);
    do
      v52 = __ldrex(v51);
    while ( __strex(v52 - 1, v51) );
    __dmb(0xFu);
    if ( v52 <= 0 )
      operator delete(v24);
  }
  v25 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 28) = v61;
  (*(void (__fastcall **)(void **, int))(v25 + 24))(&v66, v5);
  v26 = (char *)v66;
  v28 = (char *)v66 - 12;
  v27 = *((_DWORD *)v66 - 3);
  v15 = (char *)v66 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 40) = v27;
  if ( !v15 )
  {
    v49 = (unsigned int *)(v26 - 4);
    __dmb(0xFu);
    do
      v50 = __ldrex(v49);
    while ( __strex(v50 - 1, v49) );
    __dmb(0xFu);
    if ( v50 <= 0 )
      operator delete(v28);
    v27 = *(_DWORD *)(v2 + 40);
  }
  if ( v27 > 0x1FC00000 )
    v29 = -1;
  else
    v29 = 4 * v27;
  v30 = (wchar_t *)operator new[](v29);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 24))(&v67, v5);
  sub_B96FC(&v67, v30, *(_DWORD *)(v2 + 40), 0);
  v31 = (void *)(v67 - 12);
  if ( (_UNKNOWN *)(v67 - 12) != &unk_2FEF24 )
  {
    v59 = (unsigned int *)(v67 - 4);
    __dmb(0xFu);
    do
      v60 = __ldrex(v59);
    while ( __strex(v60 - 1, v59) );
    __dmb(0xFu);
    if ( v60 <= 0 )
      operator delete(v31);
  }
  v32 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 36) = v30;
  (*(void (__fastcall **)(void **, int))(v32 + 28))(&v68, v5);
  v33 = (char *)v68;
  v35 = (char *)v68 - 12;
  v34 = *((_DWORD *)v68 - 3);
  v15 = (char *)v68 - 12 == (char *)&unk_2FEF24;
  *(_DWORD *)(v2 + 48) = v34;
  if ( !v15 )
  {
    v57 = (unsigned int *)(v33 - 4);
    __dmb(0xFu);
    do
      v58 = __ldrex(v57);
    while ( __strex(v58 - 1, v57) );
    __dmb(0xFu);
    if ( v58 <= 0 )
      operator delete(v35);
    v34 = *(_DWORD *)(v2 + 48);
  }
  if ( v34 > 0x1FC00000 )
    v36 = -1;
  else
    v36 = 4 * v34;
  v37 = (wchar_t *)operator new[](v36);
  (*(void (__fastcall **)(int *, int))(*(_DWORD *)v5 + 28))(&v69, v5);
  sub_B96FC(&v69, v37, *(_DWORD *)(v2 + 48), 0);
  v38 = (void *)(v69 - 12);
  if ( (_UNKNOWN *)(v69 - 12) != &unk_2FEF24 )
  {
    v47 = (unsigned int *)(v69 - 4);
    __dmb(0xFu);
    do
      v48 = __ldrex(v47);
    while ( __strex(v48 - 1, v47) );
    __dmb(0xFu);
    if ( v48 <= 0 )
      operator delete(v38);
  }
  v39 = *(_DWORD *)v5;
  *(_DWORD *)(v2 + 44) = v37;
  v40 = (*(int (__fastcall **)(int))(v39 + 36))(v5);
  *(_DWORD *)(v2 + 56) = v40;
  v41 = *(_DWORD *)v5;
  v71 = v40;
  v70 = v40;
  v42 = (*(int (__fastcall **)(int))(v41 + 40))(v5);
  *(_DWORD *)(v2 + 60) = v42;
  v73 = v42;
  v72 = v42;
  v43 = sub_ADE94(v3);
  return (*(int (**)(void))(*(_DWORD *)v43 + 44))();
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000AF00C) --------------------------------------------------------
int __fastcall sub_AF00C(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *v3; // r0
  int result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF04);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) || (v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2)) == 0 )
    sub_BFA38();
  result = _dynamic_cast(v3, (int)&`typeinfo for'std::locale::facet, (int)&`typeinfo for'std::__timepunct<wchar_t>, 0);
  if ( !result )
    _cxa_bad_cast();
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1D88: using guessed type int *`typeinfo for'std::__timepunct<wchar_t>;

//----- (000AF050) --------------------------------------------------------
int __fastcall sub_AF050(int a1, int a2, int a3, char a4, int a5, int a6, struct tm *a7, unsigned __int8 a8, unsigned __int8 a9)
{
  int v9; // r6
  int v10; // r9
  struct tm *v11; // r11
  char v12; // r5
  size_t v13; // r8
  int result; // r0
  int v15; // [sp+8h] [bp-238h]
  char v16; // [sp+Ch] [bp-234h]
  int v17; // [sp+10h] [bp-230h]
  int v18; // [sp+14h] [bp-22Ch]
  int v19; // [sp+18h] [bp-228h]
  int v20; // [sp+1Ch] [bp-224h]
  wchar_t v21[272]; // [sp+20h] [bp-220h]

  v9 = a1;
  v15 = a3;
  v16 = a4;
  v10 = sub_ADE94(a5 + 108);
  v11 = (struct tm *)sub_AF00C(a5 + 108);
  v17 = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v10 + 40))(v10, 37);
  if ( a9 )
  {
    v18 = a9;
    v19 = a8;
    v20 = 0;
  }
  else
  {
    v18 = a8;
    v19 = 0;
  }
  sub_A8384(v11, v21, 0x80u, (const wchar_t *)&v17, a7);
  v12 = v16;
  v13 = wcslen(v21);
  if ( !v16 && v13 != (*(int (__fastcall **)(int, wchar_t *, size_t))(*(_DWORD *)v15 + 48))(v15, v21, v13) )
    v12 = 1;
  result = v9;
  *(_DWORD *)v9 = v15;
  *(_BYTE *)(v9 + 4) = v12;
  return result;
}

//----- (000AF1B0) --------------------------------------------------------
_DWORD *__fastcall sub_AF1B0(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEEA0);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::ctype<wchar_t>,
                          0) != 0);
  return result;
}
// F1520: using guessed type int *`typeinfo for'std::ctype<wchar_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000AF1FC) --------------------------------------------------------
_DWORD *__fastcall sub_AF1FC(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FE0CC);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::codecvt<wchar_t,char,mbstate_t>,
                          0) != 0);
  return result;
}
// F0F58: using guessed type int *`typeinfo for'std::codecvt<wchar_t,char,mbstate_t>;
// F1678: using guessed type int *`typeinfo for'std::locale::facet;

//----- (000AF2D0) --------------------------------------------------------
_DWORD *__fastcall sub_AF2D0(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF08);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>,
                          0) != 0);
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1C70: using guessed type int *`typeinfo for'std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>;

//----- (000AF314) --------------------------------------------------------
_DWORD *__fastcall sub_AF314(int a1)
{
  int v1; // r4
  unsigned int v2; // r0
  _DWORD *result; // r0

  v1 = a1;
  v2 = sub_AB850((int *)&unk_2FEF0C);
  if ( v2 >= *(_DWORD *)(*(_DWORD *)v1 + 8) )
    return 0;
  result = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + 4 * v2);
  if ( result )
    result = (_DWORD *)(_dynamic_cast(
                          result,
                          (int)&`typeinfo for'std::locale::facet,
                          (int)&`typeinfo for'std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>,
                          0) != 0);
  return result;
}
// F1678: using guessed type int *`typeinfo for'std::locale::facet;
// F1CE0: using guessed type int *`typeinfo for'std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>;

//----- (000AF534) --------------------------------------------------------
_DWORD *__fastcall sub_AF534(_DWORD *result, int a2, unsigned __int8 *a3, int a4, char *a5, char *a6)
{
  int v6; // r12
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r7
  int v10; // r6
  char *v11; // r4
  bool v12; // cf
  char *v13; // r3
  _DWORD *v14; // r5
  int v15; // t1
  unsigned int v16; // r3
  int v17; // r9
  unsigned __int8 v18; // r8
  int v19; // r3
  int *v20; // r4
  int v21; // t1
  int v22; // r3
  int v23; // r12
  int v24; // r8
  char v25; // r5
  int v26; // t1
  int v27; // r3
  int *v28; // r2
  int v29; // t1
  int v30; // r3

  v6 = 0;
  v7 = a4 - 1;
  v8 = *a3;
  v9 = 0;
  v10 = (int)a5;
  v11 = a6;
  while ( v8 < (v11 - a5) >> 2 && (char)v8 > 0 )
  {
    v12 = v9 >= v7;
    v11 -= 4 * v8;
    if ( v9 >= v7 )
      ++v6;
    else
      ++v9;
    if ( !v12 )
      v8 = a3[v9];
  }
  if ( v11 != a5 )
  {
    v13 = a5;
    v14 = result;
    do
    {
      v15 = *(_DWORD *)v13;
      v13 += 4;
      *v14 = v15;
      ++v14;
    }
    while ( v11 != v13 );
    v16 = ((v11 - (a5 + 4)) & 0xFFFFFFFC) + 4;
    result = (_DWORD *)((char *)result + v16);
    v10 = (int)&a5[v16];
  }
  while ( 1 )
  {
    v12 = v6-- != 0;
    if ( !v12 )
      break;
    while ( 1 )
    {
      *result = a2;
      v17 = (int)(result + 1);
      v18 = a3[v9];
      if ( !a3[v9] )
        break;
      LOBYTE(v19) = a3[v9];
      v20 = (int *)v10;
      do
      {
        v21 = *v20;
        ++v20;
        v19 = (unsigned __int8)(v19 - 1);
        result[1] = v21;
        ++result;
      }
      while ( v19 );
      v12 = v6-- != 0;
      v22 = 4 * ((unsigned __int8)(v18 - 1) + 1);
      result = (_DWORD *)(v17 + v22);
      v10 += v22;
      if ( !v12 )
        goto LABEL_20;
    }
    ++result;
  }
LABEL_20:
  v23 = (int)&a3[v9];
  while ( 1 )
  {
    v12 = v9-- != 0;
    if ( !v12 )
      break;
    while ( 1 )
    {
      *result = a2;
      v24 = (int)(result + 1);
      v26 = *(unsigned __int8 *)(v23-- - 1);
      v25 = v26;
      if ( !v26 )
        break;
      LOBYTE(v27) = v25;
      v28 = (int *)v10;
      do
      {
        v29 = *v28;
        ++v28;
        v27 = (unsigned __int8)(v27 - 1);
        result[1] = v29;
        ++result;
      }
      while ( v27 );
      v12 = v9-- != 0;
      v30 = 4 * ((unsigned __int8)(v25 - 1) + 1);
      result = (_DWORD *)(v24 + v30);
      v10 += v30;
      if ( !v12 )
        return result;
    }
    ++result;
  }
  return result;
}

//----- (000AF624) --------------------------------------------------------
wchar_t *__fastcall sub_AF624(int a1, unsigned __int8 *a2, int a3, int a4, const wchar_t *a5, char *a6, char *a7, signed int *a8)
{
  int v8; // r7
  wchar_t *v9; // r0
  int v10; // r8
  wchar_t *result; // r0

  if ( a5 )
  {
    v8 = ((char *)a5 - a7) >> 2;
    v9 = (wchar_t *)sub_AF534(a6, a4, a2, a3, a7, &a7[4 * v8]);
    v10 = (char *)v9 - a6;
    result = wmemcpy(v9, a5, *a8 - v8);
    *a8 = *a8 - v8 + (v10 >> 2);
  }
  else
  {
    result = (wchar_t *)((char *)sub_AF534(a6, a4, a2, a3, a7, &a7[4 * *a8]) - a6);
    *a8 = (signed int)result >> 2;
  }
  return result;
}

//----- (000AF698) --------------------------------------------------------
int __fastcall sub_AF698(int a1, unsigned __int8 *a2, int a3, int a4, int a5, char *a6, char *a7, signed int *a8)
{
  int result; // r0

  result = (char *)sub_AF534(a6, a4, a2, a3, a7, &a7[4 * *a8]) - a6;
  *a8 = result >> 2;
  return result;
}

//----- (000AF6C4) --------------------------------------------------------
int *__fastcall sub_AF6C4(int *a1, int a2, int a3, int a4, _DWORD *a5, int a6, char **a7)
{
  int *v7; // r7
  int v8; // r8
  int v9; // r0
  int v10; // r5
  int v11; // r4
  int v12; // r9
  char *v13; // r5
  int *v14; // r1
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r9
  int v18; // r1
  int v20; // r3
  signed int v21; // r8
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r3
  _DWORD *v25; // r10
  unsigned int v26; // r2
  unsigned int v27; // r1
  _DWORD *v28; // r3
  int v29; // r2
  int v30; // r10
  int v31; // r3
  int v32; // r2
  unsigned int v33; // ST14_4
  unsigned int v34; // r9
  signed int v35; // r5
  bool v36; // cf
  signed int v37; // r1
  char *v38; // r1
  unsigned int v39; // r3
  int v40; // r0
  char *v41; // r0
  char *v42; // r0
  unsigned int *v43; // r3
  signed int v44; // r2
  _DWORD *v45; // r3
  int v46; // r2
  unsigned int v47; // r1
  unsigned int *v48; // r0
  unsigned int *v49; // r4
  unsigned int *v50; // r1
  signed int v51; // r3
  int v52; // [sp+10h] [bp-60h]
  int v53; // [sp+14h] [bp-5Ch]
  unsigned int v54; // [sp+14h] [bp-5Ch]
  int v55; // [sp+18h] [bp-58h]
  unsigned int v56; // [sp+1Ch] [bp-54h]
  int *v57; // [sp+20h] [bp-50h]
  int v58; // [sp+24h] [bp-4Ch]
  signed int v59; // [sp+28h] [bp-48h]
  unsigned int v60; // [sp+2Ch] [bp-44h]
  int v61; // [sp+30h] [bp-40h]
  int v62; // [sp+34h] [bp-3Ch]
  int v63; // [sp+3Ch] [bp-34h]
  _DWORD *v64; // [sp+40h] [bp-30h]
  _DWORD *v65; // [sp+44h] [bp-2Ch]

  v7 = a1;
  v61 = a3;
  v62 = a4;
  v52 = a3;
  v55 = (unsigned __int8)a4;
  v8 = sub_ADE94((int)(a5 + 27));
  v9 = sub_AB850((int *)&unk_2FEF1C);
  v10 = *(_DWORD *)(a5[27] + 12);
  v11 = *(_DWORD *)(v10 + 4 * v9);
  v12 = v9;
  if ( !v11 )
  {
    v48 = (unsigned int *)operator new(0x70u);
    v48[1] = 0;
    v48[2] = 0;
    v48[3] = 0;
    *v48 = (unsigned int)&off_F1BD8;
    v49 = v48;
    *((_BYTE *)v48 + 16) = 0;
    v48[5] = 0;
    v48[6] = 0;
    v48[7] = 0;
    v48[8] = 0;
    v48[9] = 0;
    v48[10] = 0;
    v48[11] = 0;
    v48[12] = 0;
    v48[13] = 0;
    *((_BYTE *)v48 + 56) = 0;
    *((_BYTE *)v48 + 57) = 0;
    *((_BYTE *)v48 + 58) = 0;
    *((_BYTE *)v48 + 59) = 0;
    *((_BYTE *)v48 + 60) = 0;
    *((_BYTE *)v48 + 61) = 0;
    *((_BYTE *)v48 + 62) = 0;
    *((_BYTE *)v48 + 63) = 0;
    *((_BYTE *)v48 + 108) = 0;
    sub_AE750((int)v48, (int)(a5 + 27));
    sub_AB778(a5[27], v49, v12);
    v11 = *(_DWORD *)(v10 + 4 * v12);
  }
  v13 = *a7;
  if ( *(_DWORD *)*a7 == *(_DWORD *)(v11 + 64) )
  {
    v47 = *(_DWORD *)(v11 + 48);
    v16 = *((_DWORD *)v13 - 3);
    v57 = *(int **)(v11 + 44);
    v63 = *(_DWORD *)(v11 + 60);
    v56 = v47;
    if ( v16 )
      v13 += 4;
  }
  else
  {
    v14 = *(int **)(v11 + 36);
    v15 = *(_DWORD *)(v11 + 40);
    v63 = *(_DWORD *)(v11 + 56);
    v16 = *((_DWORD *)v13 - 3);
    v57 = v14;
    v56 = v15;
  }
  v17 = ((*(int (__fastcall **)(int, signed int, char *, char *))(*(_DWORD *)v8 + 20))(v8, 4, v13, &v13[4 * v16])
       - (signed int)v13) >> 2;
  if ( !v17 )
    goto LABEL_6;
  v64 = &unk_2FEF30;
  sub_BA5B8((int *)&v64, 2 * v17);
  v20 = *(_DWORD *)(v11 + 52);
  v21 = v17 - v20;
  if ( v17 - v20 > 0 )
  {
    v21 &= ~(v20 >> 32);
    if ( v20 < 0 )
      v21 = v17;
    if ( *(_DWORD *)(v11 + 12) )
    {
      sub_BA0E8((int)&v64, 0, *(v64 - 3), 2 * v21, 0);
      v22 = v64;
      if ( *(v64 - 1) >= 0 )
      {
        sub_B9F10((const wchar_t **)&v64);
        v22 = v64;
      }
      v23 = sub_AF534(
              v22,
              *(_DWORD *)(v11 + 24),
              *(unsigned __int8 **)(v11 + 8),
              *(_DWORD *)(v11 + 12),
              v13,
              &v13[4 * v21]);
      v24 = v64;
      v25 = v23;
      if ( *(v64 - 1) >= 0 )
      {
        sub_B9F10((const wchar_t **)&v64);
        v24 = v64;
      }
      v26 = *(v24 - 3);
      v27 = v25 - v24;
      if ( v27 > v26 )
        sub_BFC08("basic_string::erase");
      sub_B9E18((const wchar_t **)&v64, v27, v26 - v27, 0);
      v20 = *(_DWORD *)(v11 + 52);
    }
    else
    {
      sub_BA25C((const wchar_t **)&v64, (const wchar_t *)v13, v21);
      v20 = *(_DWORD *)(v11 + 52);
    }
  }
  if ( v20 > 0 )
  {
    v28 = v64;
    v53 = *(_DWORD *)(v11 + 20);
    v29 = *(v64 - 3);
    v30 = v29 + 1;
    if ( (unsigned int)(v29 + 1) > *(v64 - 2) || *(v64 - 1) > 0 )
    {
      sub_BA5B8((int *)&v64, v29 + 1);
      v28 = v64;
      v29 = *(v64 - 3);
    }
    v28[v29] = v53;
    if ( v28 - 3 != (_DWORD *)&unk_2FEF24 )
    {
      *(v28 - 3) = v30;
      *(v28 - 1) = 0;
      v28[v30] = 0;
    }
    if ( v21 < 0 )
    {
      sub_BA854((int *)&v64, -v21, *(_DWORD *)(v11 + 68));
      sub_BA748((int *)&v64, (unsigned int)v13, v17);
    }
    else
    {
      sub_BA748((int *)&v64, (unsigned int)&v13[4 * v21], *(_DWORD *)(v11 + 52));
    }
  }
  v31 = a5[3] & 0x200;
  v58 = a5[3] & 0xB0;
  v32 = *(v64 - 3) + v56;
  if ( v31 )
    v31 = *(_DWORD *)(v11 + 32);
  v33 = v32 + v31;
  v65 = &unk_2FEF30;
  sub_BA5B8((int *)&v65, 2 * (v32 + v31));
  v34 = a5[2];
  v35 = 1;
  v36 = v33 >= v34;
  v54 = v34 - v33;
  v37 = !v36;
  if ( v58 != 16 )
    v37 = 0;
  v59 = v37;
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v63 + v35 - 1) )
    {
      case 0u:
        if ( !v59 )
          goto def_AF8C6;
        goto LABEL_40;
      case 1u:
        if ( !v59 )
        {
          v45 = v65;
          v46 = *(v65 - 3);
          v60 = v46 + 1;
          if ( (unsigned int)(v46 + 1) > *(v65 - 2) || *(v65 - 1) > 0 )
          {
            sub_BA5B8((int *)&v65, v60);
            v45 = v65;
            v46 = *(v65 - 3);
          }
          v45[v46] = a6;
          if ( v45 - 3 != (_DWORD *)&unk_2FEF24 )
          {
            *(v45 - 1) = 0;
            *(v45 - 3) = v60;
            v45[v60] = 0;
          }
def_AF8C6:
          if ( v35 == 4 )
            goto LABEL_41;
LABEL_35:
          ++v35;
          continue;
        }
LABEL_40:
        sub_BA854((int *)&v65, v54, a6);
        if ( v35 != 4 )
          goto LABEL_35;
LABEL_41:
        if ( v56 > 1 )
          sub_BA748((int *)&v65, (unsigned int)(v57 + 1), v56 - 1);
LABEL_43:
        v38 = (char *)v65;
        v39 = *(v65 - 3);
        if ( v34 > v39 )
        {
          if ( v58 == 32 )
            sub_BA854((int *)&v65, v34 - v39, a6);
          else
            sub_BA0E8((int)&v65, 0, 0, v34 - v39, a6);
          v38 = (char *)v65;
        }
        else
        {
          v34 = *(v65 - 3);
        }
        if ( !v55 )
        {
          v40 = (*(int (__fastcall **)(int))(*(_DWORD *)v52 + 48))(v52);
          v38 = (char *)v65;
          if ( v34 != v40 )
            LOBYTE(v55) = 1;
        }
        v41 = v38 - 12;
        if ( v38 - 12 != (char *)&unk_2FEF24 )
        {
          v50 = (unsigned int *)(v38 - 4);
          __dmb(0xFu);
          do
            v51 = __ldrex(v50);
          while ( __strex(v51 - 1, v50) );
          __dmb(0xFu);
          if ( v51 <= 0 )
            operator delete(v41);
        }
        v42 = (char *)(v64 - 3);
        if ( v64 - 3 != (_DWORD *)&unk_2FEF24 )
        {
          v43 = v64 - 1;
          __dmb(0xFu);
          do
            v44 = __ldrex(v43);
          while ( __strex(v44 - 1, v43) );
          __dmb(0xFu);
          if ( v44 <= 0 )
            operator delete(v42);
        }
LABEL_6:
        a5[2] = 0;
        v61 = v52;
        LOBYTE(v62) = v55;
        v18 = v62;
        *v7 = v52;
        v7[1] = v18;
        return v7;
      case 2u:
        if ( a5[3] & 0x200 )
          sub_BA748((int *)&v65, *(_DWORD *)(v11 + 28), *(_DWORD *)(v11 + 32));
        goto def_AF8C6;
      case 3u:
        if ( v56 )
        {
          sub_BA920((int *)&v65, *v57);
          goto def_AF8C6;
        }
        if ( v35 == 4 )
          goto LABEL_43;
        goto LABEL_35;
      case 4u:
        sub_BA638((int *)&v65, (const wchar_t **)&v64);
        goto def_AF8C6;
      default:
        goto def_AF8C6;
    }
  }
}
// F1BD8: using guessed type void *off_F1BD8;

//----- (000AFB44) --------------------------------------------------------
int *__fastcall sub_AFB44(int *a1, int a2, int a3, int a4, _DWORD *a5, int a6, char **a7)
{
  int *v7; // r7
  int v8; // r8
  int v9; // r0
  int v10; // r5
  int v11; // r4
  int v12; // r9
  char *v13; // r5
  int *v14; // r1
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r9
  int v18; // r1
  int v20; // r3
  signed int v21; // r8
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r3
  _DWORD *v25; // r10
  unsigned int v26; // r2
  unsigned int v27; // r1
  _DWORD *v28; // r3
  int v29; // r2
  int v30; // r10
  int v31; // r3
  int v32; // r2
  unsigned int v33; // ST14_4
  unsigned int v34; // r9
  signed int v35; // r5
  bool v36; // cf
  signed int v37; // r1
  char *v38; // r1
  unsigned int v39; // r3
  int v40; // r0
  char *v41; // r0
  char *v42; // r0
  unsigned int *v43; // r3
  signed int v44; // r2
  _DWORD *v45; // r3
  int v46; // r2
  unsigned int v47; // r1
  unsigned int *v48; // r0
  unsigned int *v49; // r4
  unsigned int *v50; // r1
  signed int v51; // r3
  int v52; // [sp+10h] [bp-60h]
  int v53; // [sp+14h] [bp-5Ch]
  unsigned int v54; // [sp+14h] [bp-5Ch]
  int v55; // [sp+18h] [bp-58h]
  unsigned int v56; // [sp+1Ch] [bp-54h]
  int *v57; // [sp+20h] [bp-50h]
  int v58; // [sp+24h] [bp-4Ch]
  signed int v59; // [sp+28h] [bp-48h]
  unsigned int v60; // [sp+2Ch] [bp-44h]
  int v61; // [sp+30h] [bp-40h]
  int v62; // [sp+34h] [bp-3Ch]
  int v63; // [sp+3Ch] [bp-34h]
  _DWORD *v64; // [sp+40h] [bp-30h]
  _DWORD *v65; // [sp+44h] [bp-2Ch]

  v7 = a1;
  v61 = a3;
  v62 = a4;
  v52 = a3;
  v55 = (unsigned __int8)a4;
  v8 = sub_ADE94((int)(a5 + 27));
  v9 = sub_AB850((int *)&unk_2FEF20);
  v10 = *(_DWORD *)(a5[27] + 12);
  v11 = *(_DWORD *)(v10 + 4 * v9);
  v12 = v9;
  if ( !v11 )
  {
    v48 = (unsigned int *)operator new(0x70u);
    v48[1] = 0;
    v48[2] = 0;
    v48[3] = 0;
    *v48 = (unsigned int)&off_F1BC8;
    v49 = v48;
    *((_BYTE *)v48 + 16) = 0;
    v48[5] = 0;
    v48[6] = 0;
    v48[7] = 0;
    v48[8] = 0;
    v48[9] = 0;
    v48[10] = 0;
    v48[11] = 0;
    v48[12] = 0;
    v48[13] = 0;
    *((_BYTE *)v48 + 56) = 0;
    *((_BYTE *)v48 + 57) = 0;
    *((_BYTE *)v48 + 58) = 0;
    *((_BYTE *)v48 + 59) = 0;
    *((_BYTE *)v48 + 60) = 0;
    *((_BYTE *)v48 + 61) = 0;
    *((_BYTE *)v48 + 62) = 0;
    *((_BYTE *)v48 + 63) = 0;
    *((_BYTE *)v48 + 108) = 0;
    sub_AEB8C((int)v48, (int)(a5 + 27));
    sub_AB778(a5[27], v49, v12);
    v11 = *(_DWORD *)(v10 + 4 * v12);
  }
  v13 = *a7;
  if ( *(_DWORD *)*a7 == *(_DWORD *)(v11 + 64) )
  {
    v47 = *(_DWORD *)(v11 + 48);
    v16 = *((_DWORD *)v13 - 3);
    v57 = *(int **)(v11 + 44);
    v63 = *(_DWORD *)(v11 + 60);
    v56 = v47;
    if ( v16 )
      v13 += 4;
  }
  else
  {
    v14 = *(int **)(v11 + 36);
    v15 = *(_DWORD *)(v11 + 40);
    v63 = *(_DWORD *)(v11 + 56);
    v16 = *((_DWORD *)v13 - 3);
    v57 = v14;
    v56 = v15;
  }
  v17 = ((*(int (__fastcall **)(int, signed int, char *, char *))(*(_DWORD *)v8 + 20))(v8, 4, v13, &v13[4 * v16])
       - (signed int)v13) >> 2;
  if ( !v17 )
    goto LABEL_6;
  v64 = &unk_2FEF30;
  sub_BA5B8((int *)&v64, 2 * v17);
  v20 = *(_DWORD *)(v11 + 52);
  v21 = v17 - v20;
  if ( v17 - v20 > 0 )
  {
    v21 &= ~(v20 >> 32);
    if ( v20 < 0 )
      v21 = v17;
    if ( *(_DWORD *)(v11 + 12) )
    {
      sub_BA0E8((int)&v64, 0, *(v64 - 3), 2 * v21, 0);
      v22 = v64;
      if ( *(v64 - 1) >= 0 )
      {
        sub_B9F10((const wchar_t **)&v64);
        v22 = v64;
      }
      v23 = sub_AF534(
              v22,
              *(_DWORD *)(v11 + 24),
              *(unsigned __int8 **)(v11 + 8),
              *(_DWORD *)(v11 + 12),
              v13,
              &v13[4 * v21]);
      v24 = v64;
      v25 = v23;
      if ( *(v64 - 1) >= 0 )
      {
        sub_B9F10((const wchar_t **)&v64);
        v24 = v64;
      }
      v26 = *(v24 - 3);
      v27 = v25 - v24;
      if ( v27 > v26 )
        sub_BFC08("basic_string::erase");
      sub_B9E18((const wchar_t **)&v64, v27, v26 - v27, 0);
      v20 = *(_DWORD *)(v11 + 52);
    }
    else
    {
      sub_BA25C((const wchar_t **)&v64, (const wchar_t *)v13, v21);
      v20 = *(_DWORD *)(v11 + 52);
    }
  }
  if ( v20 > 0 )
  {
    v28 = v64;
    v53 = *(_DWORD *)(v11 + 20);
    v29 = *(v64 - 3);
    v30 = v29 + 1;
    if ( (unsigned int)(v29 + 1) > *(v64 - 2) || *(v64 - 1) > 0 )
    {
      sub_BA5B8((int *)&v64, v29 + 1);
      v28 = v64;
      v29 = *(v64 - 3);
    }
    v28[v29] = v53;
    if ( v28 - 3 != (_DWORD *)&unk_2FEF24 )
    {
      *(v28 - 3) = v30;
      *(v28 - 1) = 0;
      v28[v30] = 0;
    }
    if ( v21 < 0 )
    {
      sub_BA854((int *)&v64, -v21, *(_DWORD *)(v11 + 68));
      sub_BA748((int *)&v64, (unsigned int)v13, v17);
    }
    else
    {
      sub_BA748((int *)&v64, (unsigned int)&v13[4 * v21], *(_DWORD *)(v11 + 52));
    }
  }
  v31 = a5[3] & 0x200;
  v58 = a5[3] & 0xB0;
  v32 = *(v64 - 3) + v56;
  if ( v31 )
    v31 = *(_DWORD *)(v11 + 32);
  v33 = v32 + v31;
  v65 = &unk_2FEF30;
  sub_BA5B8((int *)&v65, 2 * (v32 + v31));
  v34 = a5[2];
  v35 = 1;
  v36 = v33 >= v34;
  v54 = v34 - v33;
  v37 = !v36;
  if ( v58 != 16 )
    v37 = 0;
  v59 = v37;
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v63 + v35 - 1) )
    {
      case 0u:
        if ( !v59 )
          goto def_AFD46;
        goto LABEL_40;
      case 1u:
        if ( !v59 )
        {
          v45 = v65;
          v46 = *(v65 - 3);
          v60 = v46 + 1;
          if ( (unsigned int)(v46 + 1) > *(v65 - 2) || *(v65 - 1) > 0 )
          {
            sub_BA5B8((int *)&v65, v60);
            v45 = v65;
            v46 = *(v65 - 3);
          }
          v45[v46] = a6;
          if ( v45 - 3 != (_DWORD *)&unk_2FEF24 )
          {
            *(v45 - 1) = 0;
            *(v45 - 3) = v60;
            v45[v60] = 0;
          }
def_AFD46:
          if ( v35 == 4 )
            goto LABEL_41;
LABEL_35:
          ++v35;
          continue;
        }
LABEL_40:
        sub_BA854((int *)&v65, v54, a6);
        if ( v35 != 4 )
          goto LABEL_35;
LABEL_41:
        if ( v56 > 1 )
          sub_BA748((int *)&v65, (unsigned int)(v57 + 1), v56 - 1);
LABEL_43:
        v38 = (char *)v65;
        v39 = *(v65 - 3);
        if ( v34 > v39 )
        {
          if ( v58 == 32 )
            sub_BA854((int *)&v65, v34 - v39, a6);
          else
            sub_BA0E8((int)&v65, 0, 0, v34 - v39, a6);
          v38 = (char *)v65;
        }
        else
        {
          v34 = *(v65 - 3);
        }
        if ( !v55 )
        {
          v40 = (*(int (__fastcall **)(int))(*(_DWORD *)v52 + 48))(v52);
          v38 = (char *)v65;
          if ( v34 != v40 )
            LOBYTE(v55) = 1;
        }
        v41 = v38 - 12;
        if ( v38 - 12 != (char *)&unk_2FEF24 )
        {
          v50 = (unsigned int *)(v38 - 4);
          __dmb(0xFu);
          do
            v51 = __ldrex(v50);
          while ( __strex(v51 - 1, v50) );
          __dmb(0xFu);
          if ( v51 <= 0 )
            operator delete(v41);
        }
        v42 = (char *)(v64 - 3);
        if ( v64 - 3 != (_DWORD *)&unk_2FEF24 )
        {
          v43 = v64 - 1;
          __dmb(0xFu);
          do
            v44 = __ldrex(v43);
          while ( __strex(v44 - 1, v43) );
          __dmb(0xFu);
          if ( v44 <= 0 )
            operator delete(v42);
        }
LABEL_6:
        a5[2] = 0;
        v61 = v52;
        LOBYTE(v62) = v55;
        v18 = v62;
        *v7 = v52;
        v7[1] = v18;
        return v7;
      case 2u:
        if ( a5[3] & 0x200 )
          sub_BA748((int *)&v65, *(_DWORD *)(v11 + 28), *(_DWORD *)(v11 + 32));
        goto def_AFD46;
      case 3u:
        if ( v56 )
        {
          sub_BA920((int *)&v65, *v57);
          goto def_AFD46;
        }
        if ( v35 == 4 )
          goto LABEL_43;
        goto LABEL_35;
      case 4u:
        sub_BA638((int *)&v65, (const wchar_t **)&v64);
        goto def_AFD46;
      default:
        goto def_AFD46;
    }
  }
}
// F1BC8: using guessed type void *off_F1BC8;

//----- (000AFFC4) --------------------------------------------------------
int *__fastcall sub_AFFC4(int a1, int a2, int a3, int a4, double a5, int a6, __int64 a7)
{
  int *v7; // r8
  int v8; // r10
  int v9; // r11
  int v10; // r3
  char *v11; // r11
  void *v12; // r0
  unsigned int *v14; // r2
  signed int v15; // r3
  int v16; // [sp+4h] [bp-14Ch]
  char v17[324]; // [sp+10h] [bp-140h]
  int v18; // [sp+154h] [bp+4h]
  int v19; // [sp+158h] [bp+8h]
  int *v20; // [sp+15Ch] [bp+Ch]
  int v21; // [sp+160h] [bp+10h]
  int v22; // [sp+164h] [bp+14h]
  int v23; // [sp+16Ch] [bp+1Ch]
  int v24; // [sp+170h] [bp+20h]
  int v25; // [sp+174h] [bp+24h]

  v7 = (int *)a1;
  v19 = a2;
  v21 = a3;
  v22 = a4;
  v18 = LOBYTE(a5);
  sub_AB164((unsigned int **)&v24, (unsigned int **)(HIDWORD(a5) + 108));
  v8 = sub_ADE94((int)&v24);
  v25 = sub_AB4B8();
  v9 = sub_96850((unsigned int)&v25, v17, 0, "%.*Lf", 0, v16, a7);
  v20 = &v23;
  sub_B9DC4((void **)&v25, v9, 0);
  v10 = v25;
  v11 = &v17[v9];
  if ( *(_DWORD *)(v25 - 4) >= 0 )
  {
    sub_B9F10((const wchar_t **)&v25);
    v10 = v25;
  }
  (*(void (__fastcall **)(int, char *, char *, int))(*(_DWORD *)v8 + 44))(v8, v17, v11, v10);
  if ( v18 )
    sub_AF6C4(v7, v19, v21, v22, (_DWORD *)HIDWORD(a5), a6, (char **)&v25);
  else
    sub_AFB44(v7, v19, v21, v22, (_DWORD *)HIDWORD(a5), a6, (char **)&v25);
  v12 = (void *)(v25 - 12);
  if ( (_UNKNOWN *)(v25 - 12) != &unk_2FEF24 )
  {
    v14 = (unsigned int *)(v25 - 4);
    __dmb(0xFu);
    do
      v15 = __ldrex(v14);
    while ( __strex(v15 - 1, v14) );
    __dmb(0xFu);
    if ( v15 <= 0 )
      operator delete(v12);
  }
  sub_AB620((unsigned int **)&v24);
  return v7;
}
// AFFC4: using guessed type char var_174[324];

//----- (000B00F8) --------------------------------------------------------
int *__fastcall sub_B00F8(int *a1, int a2, int a3, int a4, char a5, _DWORD *a6, int a7, char **a8)
{
  int *v8; // r5

  v8 = a1;
  if ( a5 )
    sub_AF6C4(a1, a2, a3, a4, a6, a7, a8);
  else
    sub_AFB44(a1, a2, a3, a4, a6, a7, a8);
  return v8;
}

//----- (000B0130) --------------------------------------------------------
wchar_t *__fastcall sub_B0130(int a1, wchar_t c, wchar_t *s1, wchar_t *s2, int a5, size_t n)
{
  wchar_t v6; // r9
  wchar_t *v7; // r4
  wchar_t *v8; // r8
  int v9; // r6
  size_t v10; // r7
  signed int v11; // r6
  signed int v12; // r10
  int v14; // r0
  int v15; // r6
  int v16; // r0
  int v17; // r3
  int v18; // r0

  v6 = c;
  v7 = s1;
  v8 = s2;
  v9 = *(_DWORD *)(a1 + 12) & 0xB0;
  v10 = a5 - n;
  if ( v9 != 32 )
  {
    if ( v9 != 16 )
      goto LABEL_16;
    v14 = sub_ADE94(a1 + 108);
    v15 = v14;
    v16 = (*(int (**)(void))(*(_DWORD *)v14 + 40))();
    v17 = *(_DWORD *)v8;
    if ( *(_DWORD *)v8 == v16
      || (v18 = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v15 + 40))(v15, 43),
          v17 = *(_DWORD *)v8,
          *(_DWORD *)v8 == v18) )
    {
      *(_DWORD *)v7 = v17;
      v7 += 2;
      v11 = 2;
      v12 = 1;
      goto LABEL_4;
    }
    if ( *(_DWORD *)v8 != (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v15 + 40))(v15, 48)
      || (signed int)n <= 1
      || *((_DWORD *)v8 + 1) != (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v15 + 40))(v15, 120)
      && *((_DWORD *)v8 + 1) != (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v15 + 40))(v15, 88) )
    {
LABEL_16:
      v11 = 0;
      v12 = 0;
    }
    else
    {
      v11 = 4;
      v12 = 2;
      *(_DWORD *)v7 = *(_DWORD *)v8;
      *((_DWORD *)v7 + 1) = *((_DWORD *)v8 + 1);
      v7 += 4;
    }
LABEL_4:
    wmemset(v7, v6, v10);
    return j_wmemcpy(&v7[2 * v10], &v8[v11], n - v12);
  }
  wmemcpy(s1, s2, n);
  return j_wmemset(&v7[2 * n], v6, a5 - n);
}

//----- (000B0214) --------------------------------------------------------
wchar_t *__fastcall sub_B0214(int a1, int a2, int a3, int a4, wchar_t *s1, wchar_t *s2, int a7)
{
  int v7; // r5
  wchar_t *result; // r0

  v7 = a3;
  result = sub_B0130(a4, a2, s1, s2, a3, *(_DWORD *)a7);
  *(_DWORD *)a7 = v7;
  return result;
}

//----- (000B0234) --------------------------------------------------------
int __fastcall sub_B0234(int a1, unsigned int a2, int a3, __int16 a4, char a5)
{
  _DWORD *v5; // r4
  _DWORD *v6; // r7
  unsigned int v7; // r5
  bool v9; // zf
  _DWORD *v10; // r3
  signed int v11; // r4
  int v12; // r5
  _DWORD *v13; // r3
  int v14; // r4

  if ( a5 )
  {
    v5 = (_DWORD *)(a1 - 4);
    do
    {
      v6 = v5;
      v7 = a2 % 0xA;
      a2 /= 0xAu;
      *v5 = *(_DWORD *)(a3 + 4 * (v7 + 4));
      --v5;
    }
    while ( a2 );
  }
  else if ( (a4 & 0x4A) == 64 )
  {
    v13 = (_DWORD *)(a1 - 4);
    do
    {
      v14 = a2 & 7;
      a2 >>= 3;
      v6 = v13;
      *v13 = *(_DWORD *)(a3 + 4 * (v14 + 4));
      --v13;
    }
    while ( a2 );
  }
  else
  {
    v9 = (a4 & 0x4000) == 0;
    v10 = (_DWORD *)(a1 - 4);
    if ( v9 )
      v11 = 4;
    else
      v11 = 20;
    do
    {
      v12 = a2 & 0xF;
      a2 >>= 4;
      v6 = v10;
      *v10 = *(_DWORD *)(a3 + 4 * (v12 + v11));
      --v10;
    }
    while ( a2 );
  }
  return (a1 - (signed int)v6) >> 2;
}

//----- (000B02B4) --------------------------------------------------------
int __fastcall sub_B02B4(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, unsigned int a7)
{
  int v7; // r5
  int v8; // r0
  int v9; // r9
  int v10; // r6
  int v11; // r8
  unsigned int v12; // r9
  unsigned int v13; // r2
  int v14; // r11
  bool v15; // zf
  int v16; // r3
  signed int v17; // r8
  int v18; // r1
  int v19; // r0
  int v20; // r2
  int v21; // r3
  wchar_t *s2; // r12
  int v23; // r2
  int v24; // r6
  int v25; // r8
  int (__fastcall *v26)(int, wchar_t *, int); // r4
  int v27; // r0
  int result; // r0
  unsigned __int8 *v29; // r1
  int v30; // r2
  int v31; // r3
  unsigned int *v32; // r0
  unsigned int *v33; // r6
  int v34; // r1
  int v35; // r2
  wchar_t s1; // [sp+10h] [bp-58h]
  char v37; // [sp+18h] [bp-50h]
  char v38; // [sp+60h] [bp-8h]
  wchar_t *v39; // [sp+68h] [bp+0h]
  int v40; // [sp+6Ch] [bp+4h]
  int v41; // [sp+70h] [bp+8h]
  int v42; // [sp+74h] [bp+Ch]
  int v43; // [sp+7Ch] [bp+14h]

  v7 = a1;
  v40 = a2;
  v41 = a3;
  v42 = a4;
  v8 = sub_AB850((int *)&unk_2FEF10);
  v9 = *(_DWORD *)(a5[27] + 12);
  v10 = *(_DWORD *)(v9 + 4 * v8);
  v11 = v8;
  if ( !v10 )
  {
    v32 = (unsigned int *)operator new(0x128u);
    v32[1] = 0;
    v32[2] = 0;
    v32[3] = 0;
    *v32 = (unsigned int)&off_F1BE8;
    v33 = v32;
    *((_BYTE *)v32 + 16) = 0;
    v32[5] = 0;
    v32[6] = 0;
    v32[7] = 0;
    v32[8] = 0;
    v32[9] = 0;
    v32[10] = 0;
    *((_BYTE *)v32 + 292) = 0;
    sub_AE378((int)v32, (int)(a5 + 27));
    sub_AB778(a5[27], v33, v11);
    v10 = *(_DWORD *)(v9 + 4 * v11);
  }
  v12 = a5[3];
  v13 = a7;
  v14 = a5[3] & 0x4A;
  v15 = v14 == 8;
  if ( v14 != 8 )
    v15 = v14 == 64;
  v16 = a5[3];
  v17 = !v15;
  if ( a7 )
    v18 = 0;
  else
    v18 = v17 & 1;
  if ( v18 )
    v13 = 0;
  v39 = &s1;
  v19 = sub_B0234((int)&v38, v13, v10 + 44, v16, v17);
  v20 = *(unsigned __int8 *)(v10 + 16);
  v21 = v19;
  v43 = v19;
  s2 = &v39[2 * (20 - v19)];
  if ( v20 )
  {
    v29 = *(unsigned __int8 **)(v10 + 8);
    v30 = *(_DWORD *)(v10 + 12);
    v31 = *(_DWORD *)(v10 + 40);
    v39 = (wchar_t *)&v37;
    sub_AF698(v40, v29, v30, v31, (int)a5, &v37, (char *)s2, &v43);
    v21 = v43;
    s2 = v39;
  }
  if ( !v17 && v12 & 0x200 && a7 )
  {
    if ( v14 == 64 )
    {
      v35 = *(_DWORD *)(v10 + 60);
      ++v21;
      s2 -= 2;
      v43 = v21;
      *(_DWORD *)s2 = v35;
    }
    else
    {
      s2 -= 4;
      v21 += 2;
      v34 = *(_DWORD *)(v10 + 44 + 4 * (((v12 >> 14) & 1) + 2));
      v43 = v21;
      *((_DWORD *)s2 + 1) = v34;
      *(_DWORD *)s2 = *(_DWORD *)(v10 + 60);
    }
  }
  v23 = a5[2];
  if ( v23 > v21 )
  {
    sub_B0214(v40, a6, v23, (int)a5, &s1, s2, (int)&v43);
    v21 = v43;
    s2 = &s1;
  }
  v24 = (unsigned __int8)v42;
  v25 = v41;
  a5[2] = 0;
  if ( !v24 )
  {
    v26 = *(int (__fastcall **)(int, wchar_t *, int))(*(_DWORD *)v25 + 48);
    v39 = (wchar_t *)v21;
    v27 = v26(v25, s2, v21);
    if ( (wchar_t *)v27 != v39 )
      LOBYTE(v24) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v25;
  *(_BYTE *)(v7 + 4) = v24;
  return result;
}
// F1BE8: using guessed type void *off_F1BE8;

//----- (000B0494) --------------------------------------------------------
int __fastcall sub_B0494(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, unsigned int a7)
{
  int v7; // r8

  v7 = a1;
  sub_B02B4(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (000B04C0) --------------------------------------------------------
_DWORD *__fastcall sub_B04C0(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, unsigned int a7)
{
  _DWORD *v7; // r8
  int v8; // r6
  int v9; // ST14_4
  int v10; // r0
  char v11; // r1
  char v13; // [sp+18h] [bp-28h]
  char v14; // [sp+1Ch] [bp-24h]

  v7 = a1;
  v8 = a5[3];
  v9 = a4;
  a5[3] = v8 & 0xFFFFBFB5 | 0x208;
  sub_B02B4((int)&v13, a2, a3, a4, a5, a6, a7);
  v10 = *(_DWORD *)&v13;
  v11 = v14;
  a5[3] = v8;
  LOBYTE(v9) = v11;
  *v7 = v10;
  v7[1] = v9;
  return v7;
}

//----- (000B0518) --------------------------------------------------------
int __fastcall sub_B0518(int a1, int a2, unsigned __int64 a3, int a4, __int16 a5, char a6)
{
  int v6; // r9
  unsigned __int64 v7; // r4
  _DWORD *v8; // r6
  _DWORD *v9; // r7
  _DWORD *v11; // r3
  signed int v12; // r1
  int v13; // r6
  _DWORD *v14; // r3
  int v15; // r0

  v6 = a1;
  v7 = a3;
  if ( a6 )
  {
    v8 = (_DWORD *)(a1 - 4);
    do
    {
      v9 = v8;
      *v8 = *(_DWORD *)(a4 + 4 * (v7 % 0xA + 4));
      --v8;
      v7 /= 0xAuLL;
    }
    while ( v7 );
  }
  else if ( (a5 & 0x4A) == 64 )
  {
    v14 = (_DWORD *)(a1 - 4);
    do
    {
      v15 = (v7 & 7) + 4;
      v9 = v14;
      v7 >>= 3;
      *v14 = *(_DWORD *)(a4 + 4 * v15);
      --v14;
    }
    while ( v7 );
  }
  else
  {
    v11 = (_DWORD *)(a1 - 4);
    if ( a5 & 0x4000 )
      v12 = 20;
    else
      v12 = 4;
    do
    {
      v13 = (v7 & 0xF) + v12;
      v9 = v11;
      v7 >>= 4;
      *v11 = *(_DWORD *)(a4 + 4 * v13);
      --v11;
    }
    while ( v7 );
  }
  return (v6 - (signed int)v9) >> 2;
}

//----- (000B05CC) --------------------------------------------------------
int __fastcall sub_B05CC(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, unsigned __int64 a7)
{
  int v7; // r5
  int v8; // r0
  int v9; // r9
  int v10; // r6
  int v11; // r8
  unsigned int v12; // r9
  int v13; // r11
  bool v14; // zf
  signed int v15; // r8
  int v16; // r3
  unsigned __int64 v17; // r2
  int v18; // r0
  int v19; // r2
  char *v20; // r3
  wchar_t *s2; // r12
  int v22; // r2
  int v23; // r6
  int v24; // r8
  int (__fastcall *v25)(int, wchar_t *, char *); // r4
  int v26; // r0
  int result; // r0
  unsigned __int8 *v28; // r1
  int v29; // r2
  int v30; // r3
  unsigned int *v31; // r0
  unsigned int *v32; // r6
  int v33; // r1
  int v34; // r2
  wchar_t s1[4]; // [sp+10h] [bp-A8h]
  char v36; // [sp+18h] [bp-A0h]
  int v37; // [sp+B0h] [bp-8h]
  char *v38; // [sp+BCh] [bp+4h]
  int v39; // [sp+C0h] [bp+8h]
  int v40; // [sp+C4h] [bp+Ch]
  int v41; // [sp+C8h] [bp+10h]
  int v42; // [sp+CCh] [bp+14h]
  char *v43; // [sp+D4h] [bp+1Ch]

  v7 = a1;
  v39 = a2;
  v41 = a3;
  v42 = a4;
  v8 = sub_AB850((int *)&unk_2FEF10);
  v9 = *(_DWORD *)(a5[27] + 12);
  v10 = *(_DWORD *)(v9 + 4 * v8);
  v11 = v8;
  if ( !v10 )
  {
    v31 = (unsigned int *)operator new(0x128u);
    v31[1] = 0;
    v31[2] = 0;
    v31[3] = 0;
    *v31 = (unsigned int)&off_F1BE8;
    v32 = v31;
    *((_BYTE *)v31 + 16) = 0;
    v31[5] = 0;
    v31[6] = 0;
    v31[7] = 0;
    v31[8] = 0;
    v31[9] = 0;
    v31[10] = 0;
    *((_BYTE *)v31 + 292) = 0;
    sub_AE378((int)v31, (int)(a5 + 27));
    sub_AB778(a5[27], v32, v11);
    v10 = *(_DWORD *)(v9 + 4 * v11);
  }
  v12 = a5[3];
  v13 = a5[3] & 0x4A;
  v14 = v13 == 8;
  if ( v13 != 8 )
    v14 = v13 == 64;
  v15 = !v14;
  if ( a7 )
    v16 = 0;
  else
    v16 = v15 & 1;
  v40 = v10 + 44;
  if ( v16 )
    v17 = 0LL;
  else
    v17 = a7;
  v18 = sub_B0518((int)&v37, a7 | HIDWORD(a7), v17, v40, v12, v15);
  v19 = *(unsigned __int8 *)(v10 + 16);
  v20 = (char *)v18;
  v43 = (char *)v18;
  s2 = &s1[2 * (40 - v18)];
  if ( v19 )
  {
    v28 = *(unsigned __int8 **)(v10 + 8);
    v29 = *(_DWORD *)(v10 + 12);
    v30 = *(_DWORD *)(v10 + 40);
    v38 = &v36;
    sub_AF698(v39, v28, v29, v30, (int)a5, &v36, (char *)&s1[2 * (40 - v18)], (signed int *)&v43);
    v20 = v43;
    s2 = (wchar_t *)v38;
  }
  if ( !v15 && v12 & 0x200 && a7 )
  {
    if ( v13 == 64 )
    {
      v34 = *(_DWORD *)(v10 + 60);
      ++v20;
      s2 -= 2;
      v43 = v20;
      *(_DWORD *)s2 = v34;
    }
    else
    {
      s2 -= 4;
      v33 = *(_DWORD *)(v40 + 4 * (((v12 >> 14) & 1) + 2));
      v20 += 2;
      v43 = v20;
      *((_DWORD *)s2 + 1) = v33;
      *(_DWORD *)s2 = *(_DWORD *)(v10 + 60);
    }
  }
  v22 = a5[2];
  if ( v22 > (signed int)v20 )
  {
    sub_B0214(v39, a6, v22, (int)a5, s1, s2, (int)&v43);
    v20 = v43;
    s2 = s1;
  }
  v23 = (unsigned __int8)v42;
  v24 = v41;
  a5[2] = 0;
  if ( !v23 )
  {
    v25 = *(int (__fastcall **)(int, wchar_t *, char *))(*(_DWORD *)v24 + 48);
    v38 = v20;
    v26 = v25(v24, s2, v20);
    if ( (char *)v26 != v38 )
      LOBYTE(v23) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v24;
  *(_BYTE *)(v7 + 4) = v23;
  return result;
}
// F1BE8: using guessed type void *off_F1BE8;
// B05CC: using guessed type wchar_t var_CC[4];

//----- (000B07B4) --------------------------------------------------------
int __fastcall sub_B07B4(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, unsigned __int64 a7)
{
  int v7; // r8

  v7 = a1;
  sub_B05CC(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (000B07E4) --------------------------------------------------------
int __fastcall sub_B07E4(int a1, int *a2)
{
  int *v2; // r6
  int v3; // r0
  int v4; // r7
  int v5; // r5
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r4

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FEF1C);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x70u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F1BD8;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = 0;
    v7[13] = 0;
    *((_BYTE *)v7 + 56) = 0;
    *((_BYTE *)v7 + 57) = 0;
    *((_BYTE *)v7 + 58) = 0;
    *((_BYTE *)v7 + 59) = 0;
    *((_BYTE *)v7 + 60) = 0;
    *((_BYTE *)v7 + 61) = 0;
    *((_BYTE *)v7 + 62) = 0;
    *((_BYTE *)v7 + 63) = 0;
    *((_BYTE *)v7 + 108) = 0;
    sub_AE750((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F1BD8: using guessed type void *off_F1BD8;

//----- (000B088C) --------------------------------------------------------
_DWORD **__fastcall sub_B088C(_DWORD **a1)
{
  _DWORD **v1; // r4
  _DWORD *v2; // r0
  unsigned int v3; // r2

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v3 = v2[2];
    if ( v3 >= v2[3] )
      (*(void (**)(void))(*v2 + 40))();
    else
      v2[2] = v3 + 4;
    v1[1] = (_DWORD *)-1;
  }
  return v1;
}

//----- (000B08B4) --------------------------------------------------------
int __fastcall sub_B08B4(int a1, int *a2)
{
  int *v2; // r6
  int v3; // r0
  int v4; // r7
  int v5; // r5
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r4

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FEF20);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x70u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F1BC8;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = 0;
    v7[13] = 0;
    *((_BYTE *)v7 + 56) = 0;
    *((_BYTE *)v7 + 57) = 0;
    *((_BYTE *)v7 + 58) = 0;
    *((_BYTE *)v7 + 59) = 0;
    *((_BYTE *)v7 + 60) = 0;
    *((_BYTE *)v7 + 61) = 0;
    *((_BYTE *)v7 + 62) = 0;
    *((_BYTE *)v7 + 63) = 0;
    *((_BYTE *)v7 + 108) = 0;
    sub_AEB8C((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F1BC8: using guessed type void *off_F1BC8;

//----- (000B095C) --------------------------------------------------------
int __fastcall sub_B095C(int a1, int *a2)
{
  int *v2; // r5
  int v3; // r0
  int v4; // r6
  int v5; // r4
  int result; // r0
  unsigned int *v7; // r0
  unsigned int *v8; // r7

  v2 = a2;
  v3 = sub_AB850((int *)&unk_2FEF10);
  v4 = *(_DWORD *)(*v2 + 12);
  v5 = v3;
  result = *(_DWORD *)(v4 + 4 * v3);
  if ( !result )
  {
    v7 = (unsigned int *)operator new(0x128u);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    *v7 = (unsigned int)&off_F1BE8;
    v8 = v7;
    *((_BYTE *)v7 + 16) = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    *((_BYTE *)v7 + 292) = 0;
    sub_AE378((int)v7, (int)v2);
    sub_AB778(*v2, v8, v5);
    result = *(_DWORD *)(v4 + 4 * v5);
  }
  return result;
}
// F1BE8: using guessed type void *off_F1BE8;

//----- (000B09E0) --------------------------------------------------------
int __fastcall sub_B09E0(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, signed int a7)
{
  int v7; // r6
  int v8; // r0
  unsigned int v9; // r10
  int v10; // r11
  bool v11; // zf
  signed int v12; // r9
  int v13; // r3
  int v14; // r8
  unsigned int v15; // r1
  int v16; // r0
  int v17; // r2
  int v18; // r3
  wchar_t *v19; // r5
  int v20; // r2
  wchar_t *s2; // ST04_4
  int v22; // r8
  int v23; // r9
  int (__fastcall *v24)(int, wchar_t *, int); // r4
  int v25; // r0
  int result; // r0
  int v27; // r2
  int v28; // r2
  int v29; // r1
  int v30; // r2
  wchar_t s1[4]; // [sp+10h] [bp-58h]
  char v32; // [sp+18h] [bp-50h]
  int v33; // [sp+60h] [bp-8h]
  int v34; // [sp+6Ch] [bp+4h]
  int v35; // [sp+70h] [bp+8h]
  int v36; // [sp+74h] [bp+Ch]
  int v37; // [sp+78h] [bp+10h]
  int v38; // [sp+7Ch] [bp+14h]
  int v39; // [sp+80h] [bp+18h]
  int v40; // [sp+84h] [bp+1Ch]

  v7 = a1;
  v35 = a2;
  v37 = a3;
  v38 = a4;
  v8 = sub_B095C((int)&v39, a5 + 27);
  v9 = a5[3];
  v10 = a5[3] & 0x4A;
  v11 = v10 == 8;
  if ( v10 != 8 )
    v11 = v10 == 64;
  v12 = !v11;
  v13 = v12 ^ 1;
  v14 = v8;
  v36 = v8 + 44;
  if ( a7 > 0 )
    v13 |= 1u;
  v15 = a7;
  if ( !v13 )
    v15 = -a7;
  v16 = sub_B0234((int)&v33, v15, v36, v9, v12);
  v17 = *(unsigned __int8 *)(v14 + 16);
  v18 = v16;
  v40 = v16;
  v19 = &s1[2 * (20 - v16)];
  if ( v17 )
  {
    v19 = (wchar_t *)&v32;
    sub_AF698(
      v35,
      *(unsigned __int8 **)(v14 + 8),
      *(_DWORD *)(v14 + 12),
      *(_DWORD *)(v14 + 40),
      (int)a5,
      &v32,
      (char *)&s1[2 * (20 - v16)],
      &v40);
    v18 = v40;
  }
  if ( v12 )
  {
    if ( a7 < 0 )
    {
      v28 = *(_DWORD *)(v14 + 44);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v28;
    }
    else if ( v9 & 0x800 )
    {
      v27 = *(_DWORD *)(v14 + 48);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v27;
    }
  }
  else if ( v9 & 0x200 && a7 )
  {
    if ( v10 == 64 )
    {
      v30 = *(_DWORD *)(v14 + 60);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v30;
    }
    else
    {
      v19 -= 4;
      v29 = *(_DWORD *)(v36 + 4 * (((v9 >> 14) & 1) + 2));
      v18 += 2;
      v40 = v18;
      *((_DWORD *)v19 + 1) = v29;
      *(_DWORD *)v19 = *(_DWORD *)(v14 + 60);
    }
  }
  v20 = a5[2];
  if ( v20 > v18 )
  {
    s2 = v19;
    v19 = s1;
    sub_B0214(v35, a6, v20, (int)a5, s1, s2, (int)&v40);
    v18 = v40;
  }
  v22 = (unsigned __int8)v38;
  v23 = v37;
  a5[2] = 0;
  if ( !v22 )
  {
    v24 = *(int (__fastcall **)(int, wchar_t *, int))(*(_DWORD *)v23 + 48);
    v34 = v18;
    v25 = v24(v23, v19, v18);
    if ( v25 != v34 )
      LOBYTE(v22) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v23;
  *(_BYTE *)(v7 + 4) = v22;
  return result;
}
// B09E0: using guessed type wchar_t var_7C[4];

//----- (000B0B6C) --------------------------------------------------------
int __fastcall sub_B0B6C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, signed int a7)
{
  int v7; // r8

  v7 = a1;
  sub_B09E0(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (000B0B98) --------------------------------------------------------
int *__fastcall sub_B0B98(int a1, int c, int a3, int a4, _DWORD *a5, int ca, unsigned __int8 a7)
{
  int *v7; // r5
  int v8; // r6
  int v9; // r10
  int v10; // r9
  int v11; // r1
  _DWORD *v13; // r0
  int v14; // r8
  int v15; // r2
  wchar_t *v16; // r12
  int v17; // r0
  int v18; // r0
  int v19; // r0
  wchar_t s; // [sp+10h] [bp+0h]
  wchar_t *v21; // [sp+14h] [bp+4h]
  int v22; // [sp+18h] [bp+8h]
  int v23; // [sp+1Ch] [bp+Ch]
  int v24; // [sp+20h] [bp+10h]
  int v25; // [sp+24h] [bp+14h]
  int v26; // [sp+28h] [bp+18h]
  char v27; // [sp+2Ch] [bp+1Ch]

  v7 = (int *)a1;
  v8 = a3;
  v24 = a3;
  v25 = a4;
  v9 = a5[3];
  v10 = (unsigned __int8)a4;
  if ( !(v9 & 1) )
  {
    sub_B09E0((int)&v26, c, v24, v25, a5, ca, a7);
    v8 = v26;
    LOBYTE(v10) = v27;
    goto LABEL_3;
  }
  v13 = (_DWORD *)sub_B095C((int)&v26, a5 + 27);
  if ( a7 )
  {
    v14 = v13[6];
    v15 = a5[2];
    v22 = v13[5];
    if ( v14 < v15 )
      goto LABEL_6;
LABEL_13:
    a5[2] = 0;
    if ( !v10 && v14 != (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, v22, v14) )
      LOBYTE(v10) = 1;
    goto LABEL_3;
  }
  v14 = v13[8];
  v15 = a5[2];
  v22 = v13[7];
  if ( v14 >= v15 )
    goto LABEL_13;
LABEL_6:
  v23 = v15 - v14;
  v21 = &s;
  wmemset(&s, ca, v15 - v14);
  v16 = v21;
  a5[2] = 0;
  if ( (v9 & 0xB0) != 32 )
  {
    if ( v10 )
      goto LABEL_3;
    v17 = (*(int (__fastcall **)(int, wchar_t *, int))(*(_DWORD *)v8 + 48))(v8, v16, v23);
    if ( v23 == v17 )
    {
      v18 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, v22, v14);
      LOBYTE(v10) = v14 - v18;
      if ( v14 != v18 )
        LOBYTE(v10) = 1;
      goto LABEL_3;
    }
LABEL_22:
    LOBYTE(v10) = 1;
    goto LABEL_3;
  }
  if ( v10 )
    goto LABEL_3;
  if ( v14 != (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v8 + 48))(v8, v22, v14) )
    goto LABEL_22;
  v19 = (*(int (__fastcall **)(int, wchar_t *, int))(*(_DWORD *)v8 + 48))(v8, v21, v23);
  LOBYTE(v10) = v23 - v19;
  if ( v23 != v19 )
    LOBYTE(v10) = 1;
LABEL_3:
  v24 = v8;
  LOBYTE(v25) = v10;
  v11 = v25;
  *v7 = v8;
  v7[1] = v11;
  return v7;
}

//----- (000B0CEC) --------------------------------------------------------
int __fastcall sub_B0CEC(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, signed __int64 a7)
{
  int v7; // r6
  int v8; // r0
  unsigned int v9; // r10
  int v10; // r11
  bool v11; // zf
  signed int v12; // r9
  int v13; // r3
  int v14; // r8
  unsigned __int64 v15; // r2
  int v16; // r0
  int v17; // r2
  int v18; // r3
  wchar_t *v19; // r5
  int v20; // r2
  wchar_t *s2; // ST04_4
  int v22; // r8
  int v23; // r9
  int (__fastcall *v24)(int, wchar_t *, int); // r4
  int v25; // r0
  int result; // r0
  int v27; // r2
  int v28; // r2
  int v29; // r1
  int v30; // r2
  wchar_t s1[4]; // [sp+10h] [bp-A8h]
  char v32; // [sp+18h] [bp-A0h]
  int v33; // [sp+B0h] [bp-8h]
  int v34; // [sp+BCh] [bp+4h]
  int v35; // [sp+C0h] [bp+8h]
  int v36; // [sp+C4h] [bp+Ch]
  int v37; // [sp+C8h] [bp+10h]
  int v38; // [sp+CCh] [bp+14h]
  int v39; // [sp+D0h] [bp+18h]
  int v40; // [sp+D4h] [bp+1Ch]

  v7 = a1;
  v35 = a2;
  v37 = a3;
  v38 = a4;
  v8 = sub_B095C((int)&v39, a5 + 27);
  v9 = a5[3];
  v10 = a5[3] & 0x4A;
  v11 = v10 == 8;
  if ( v10 != 8 )
    v11 = v10 == 64;
  v12 = !v11;
  v13 = v12 ^ 1;
  v14 = v8;
  v36 = v8 + 44;
  if ( a7 >= 1 )
    v13 |= 1u;
  if ( v13 )
  {
    v15 = a7;
  }
  else
  {
    LODWORD(v15) = -(signed int)a7;
    HIDWORD(v15) = HIDWORD(a7) - (2 * HIDWORD(a7) + ((unsigned int)a7 > 0));
  }
  v16 = sub_B0518((int)&v33, HIDWORD(a7) - ((unsigned int)a7 < 1), v15, v36, v9, v12);
  v17 = *(unsigned __int8 *)(v14 + 16);
  v18 = v16;
  v40 = v16;
  v19 = &s1[2 * (40 - v16)];
  if ( v17 )
  {
    v19 = (wchar_t *)&v32;
    sub_AF698(
      v35,
      *(unsigned __int8 **)(v14 + 8),
      *(_DWORD *)(v14 + 12),
      *(_DWORD *)(v14 + 40),
      (int)a5,
      &v32,
      (char *)&s1[2 * (40 - v16)],
      &v40);
    v18 = v40;
  }
  if ( v12 )
  {
    if ( a7 < 0 )
    {
      v28 = *(_DWORD *)(v14 + 44);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v28;
    }
    else if ( v9 & 0x800 )
    {
      v27 = *(_DWORD *)(v14 + 48);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v27;
    }
  }
  else if ( v9 & 0x200 && a7 )
  {
    if ( v10 == 64 )
    {
      v30 = *(_DWORD *)(v14 + 60);
      ++v18;
      v19 -= 2;
      v40 = v18;
      *(_DWORD *)v19 = v30;
    }
    else
    {
      v19 -= 4;
      v29 = *(_DWORD *)(v36 + 4 * (((v9 >> 14) & 1) + 2));
      v18 += 2;
      v40 = v18;
      *((_DWORD *)v19 + 1) = v29;
      *(_DWORD *)v19 = *(_DWORD *)(v14 + 60);
    }
  }
  v20 = a5[2];
  if ( v20 > v18 )
  {
    s2 = v19;
    v19 = s1;
    sub_B0214(v35, a6, v20, (int)a5, s1, s2, (int)&v40);
    v18 = v40;
  }
  v22 = (unsigned __int8)v38;
  v23 = v37;
  a5[2] = 0;
  if ( !v22 )
  {
    v24 = *(int (__fastcall **)(int, wchar_t *, int))(*(_DWORD *)v23 + 48);
    v34 = v18;
    v25 = v24(v23, v19, v18);
    if ( v25 != v34 )
      LOBYTE(v22) = 1;
  }
  result = v7;
  *(_DWORD *)v7 = v23;
  *(_BYTE *)(v7 + 4) = v22;
  return result;
}
// B0CEC: using guessed type wchar_t var_CC[4];

//----- (000B0E94) --------------------------------------------------------
int __fastcall sub_B0E94(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, signed __int64 a7)
{
  int v7; // r8

  v7 = a1;
  sub_B0CEC(a1, a2, a3, a4, a5, a6, a7);
  return v7;
}

//----- (000B0EC4) --------------------------------------------------------
#error "B1072: call analysis failed (funcsize=166)"

//----- (000B1080) --------------------------------------------------------
int __fastcall sub_B1080(double a1, int a2, int a3, double a4)
{
  int v4; // r7

  v4 = LODWORD(a1);
  sub_B0EC4(SLODWORD(a1), SHIDWORD(a1), a2, a3, a4);
  return v4;
}

//----- (000B10B4) --------------------------------------------------------
#error "B1262: call analysis failed (funcsize=166)"

//----- (000B1270) --------------------------------------------------------
int __fastcall sub_B1270(double a1, int a2, int a3, double a4)
{
  int v4; // r7

  v4 = LODWORD(a1);
  sub_B10B4(SLODWORD(a1), SHIDWORD(a1), a2, a3, a4);
  return v4;
}

//----- (000B12A4) --------------------------------------------------------
int __fastcall sub_B12A4(_DWORD **a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  signed int v3; // r3
  int result; // r0
  int *v5; // r3
  int v6; // r3

  v1 = a1;
  v2 = *a1;
  v3 = -1;
  if ( !v2 )
    return v3;
  v3 = v1[1];
  if ( v3 != -1 )
    return v3;
  v5 = (int *)v2[2];
  if ( (unsigned int)v5 >= v2[3] )
    v6 = (*(int (**)(void))(*v2 + 36))();
  else
    v6 = *v5;
  result = v6;
  if ( v6 == -1 )
    *v1 = 0;
  else
    v1[1] = v6;
  return result;
}

//----- (000B12DC) --------------------------------------------------------
bool __fastcall sub_B12DC(_DWORD **a1, int a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r0
  signed int v4; // r5
  _DWORD *v5; // r0
  signed int v6; // r0
  int *v8; // r2
  unsigned int v9; // r3
  int v10; // r0
  int *v11; // r3
  int v12; // r0
  bool v13; // zf
  int v14; // ST04_4
  int v15; // ST04_4

  v2 = a1;
  v3 = *a1;
  v4 = 1;
  if ( v3 )
  {
    if ( v2[1] == -1 )
    {
      v11 = (int *)v3[2];
      if ( (unsigned int)v11 >= v3[3] )
      {
        v15 = a2;
        v12 = (*(int (**)(void))(*v3 + 36))();
        a2 = v15;
      }
      else
      {
        v12 = *v11;
      }
      v13 = v12 == -1;
      if ( v12 == -1 )
        *v2 = 0;
      else
        v2[1] = v12;
      v5 = *(_DWORD **)a2;
      v4 = v13 != 0;
      if ( v5 )
        goto LABEL_6;
LABEL_28:
      v6 = 1;
      return (unsigned int)(v6 - v4) <= 0;
    }
    v4 = 0;
  }
  v5 = *(_DWORD **)a2;
  if ( !*(_DWORD *)a2 )
    goto LABEL_28;
LABEL_6:
  if ( *(_DWORD *)(a2 + 4) == -1 )
  {
    v8 = (int *)v5[2];
    v9 = v5[3];
    if ( (unsigned int)v8 >= v9 )
    {
      v14 = a2;
      v10 = (*(int (**)(void))(*v5 + 36))();
      a2 = v14;
    }
    else
    {
      v10 = *v8;
    }
    if ( v10 == -1 )
      v9 = 0;
    else
      *(_DWORD *)(a2 + 4) = v10;
    if ( v10 == -1 )
    {
      v6 = 1;
      *(_DWORD *)a2 = v9;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  return (unsigned int)(v6 - v4) <= 0;
}

//----- (000B1364) --------------------------------------------------------
_DWORD *__fastcall sub_B1364(_DWORD *a1, int a2, _DWORD *a3, int a4, int a5, int a6, int *a7, int a8, int a9, int a10, _DWORD *a11)
{
  int v11; // r9
  int v12; // r8
  int v13; // r11
  int v14; // r5
  _DWORD *v15; // r1
  _DWORD *v16; // r4
  int v18; // r0
  int v19; // r10
  unsigned int v20; // r4
  int v21; // r8
  int v22; // r9
  _DWORD *v23; // t1
  int v24; // r8
  int v25; // r9
  int *v26; // r11
  unsigned int v27; // r5
  size_t v28; // r10
  int v29; // t1
  size_t v30; // r0
  unsigned int v31; // r2
  unsigned int v32; // r5
  int v33; // r10
  int v34; // r2
  signed int v35; // r3
  signed int *v36; // r1
  unsigned int v37; // r4
  int v38; // r5
  const wchar_t *v39; // r8
  size_t v40; // r6
  int v41; // r9
  int v42; // t1
  int (*v43)(void); // r3
  int v44; // r0
  int v45; // [sp+14h] [bp+0h]
  int v46; // [sp+18h] [bp+4h]
  _DWORD *v47; // [sp+1Ch] [bp+8h]
  _DWORD **v48; // [sp+20h] [bp+Ch]
  _DWORD *v49; // [sp+24h] [bp+10h]
  int v50; // [sp+28h] [bp+14h]

  v47 = a1;
  v49 = a3;
  v50 = a4;
  v11 = a9;
  v48 = &v49;
  v12 = a8;
  v13 = sub_ADE94(a10 + 108);
  v14 = sub_B12DC(&v49, (int)&a5);
  if ( !v14 )
  {
    v18 = sub_B12A4(&v49);
    if ( v11 )
    {
      v19 = v12 - 4;
      v46 = v12;
      v20 = 0;
      v21 = v11;
      v22 = v18;
      do
      {
        while ( 1 )
        {
          v23 = *(_DWORD **)(v19 + 4);
          v19 += 4;
          if ( *v23 == v22 || v22 == (*(int (**)(void))(*(_DWORD *)v13 + 24))() )
            break;
          if ( ++v14 == v21 )
            goto LABEL_10;
        }
        *(&v45 + v20++) = v14++;
      }
      while ( v14 != v21 );
LABEL_10:
      v24 = v46;
      v25 = 0;
      if ( v20 <= 1 )
      {
LABEL_37:
        if ( v20 == 1 )
        {
          v37 = v25 + 1;
          sub_B088C(&v49);
          v38 = v45;
          v39 = *(const wchar_t **)(v24 + 4 * v45);
          v40 = wcslen(v39);
          if ( v25 + 1 < v40 )
          {
            v41 = (int)&v39[2 * v25];
            do
            {
              if ( sub_B12DC(&v49, (int)&a5) )
                break;
              v42 = *(_DWORD *)(v41 + 4);
              v41 += 4;
              if ( v42 != sub_B12A4(&v49) )
                break;
              ++v37;
              sub_B088C(&v49);
            }
            while ( v37 < v40 );
          }
          if ( v37 == v40 )
          {
            *a7 = v38;
            goto LABEL_3;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          v26 = &v45;
          v27 = 1;
          v28 = wcslen(*(const wchar_t **)(v24 + 4 * v45));
          do
          {
            v29 = v26[1];
            ++v26;
            ++v27;
            v30 = wcslen(*(const wchar_t **)(v24 + 4 * v29));
            if ( v28 >= v30 )
              v28 = v30;
          }
          while ( v27 < v20 );
          if ( v49 )
          {
            v31 = v49[2];
            if ( v31 >= v49[3] )
              (*(void (**)(void))(*v49 + 40))();
            else
              v49[2] = v31 + 4;
            v50 = -1;
          }
          if ( ++v25 >= v28 || sub_B12DC(&v49, (int)&a5) )
            break;
          v32 = 0;
          do
          {
            v33 = 4 * v32;
            v34 = *(_DWORD *)(*(_DWORD *)(v24 + 4 * *(&v45 + v32)) + 4 * v25);
            v35 = -1;
            if ( v49 )
            {
              v35 = v50;
              if ( v50 == -1 )
              {
                v36 = (signed int *)v49[2];
                if ( (unsigned int)v36 >= v49[3] )
                {
                  v43 = *(int (**)(void))(*v49 + 36);
                  v45 = *(_DWORD *)(*(_DWORD *)(v24 + 4 * *(&v45 + v32)) + 4 * v25);
                  v44 = v43();
                  v34 = v45;
                  v35 = v44;
                }
                else
                {
                  v35 = *v36;
                }
                if ( v35 == -1 )
                  v49 = 0;
                else
                  v50 = v35;
              }
            }
            if ( v34 == v35 )
              ++v32;
            else
              --v20;
            if ( v34 != v35 )
              *(int *)((char *)&v45 + v33) = *(&v45 + v20);
          }
          while ( v20 > v32 );
          if ( v20 <= 1 )
            goto LABEL_37;
        }
      }
    }
  }
  *a11 |= 4u;
LABEL_3:
  v15 = v48[1];
  v16 = v47;
  *v47 = *v48;
  v16[1] = v15;
  return v16;
}

//----- (000B1548) --------------------------------------------------------
int **__fastcall sub_B1548(int **a1, int a2, int *a3, int a4, _DWORD *a5, _DWORD *a6, int *a7, int a8, unsigned int a9, int a10, _DWORD *a11)
{
  int v11; // r10
  int v12; // r9
  int v13; // r5
  unsigned int v14; // r4
  unsigned int v15; // r9
  _DWORD **v16; // r5
  int *v17; // r0
  signed int v18; // r6
  signed int v19; // r3
  int v20; // r0
  unsigned int v21; // r3
  int v22; // r11
  _DWORD *v23; // r1
  int v24; // r2
  int v25; // r6
  _DWORD *v26; // r12
  int v27; // r6
  int v28; // r1
  _DWORD *v29; // r6
  unsigned int v30; // r2
  int *v31; // r1
  int *v32; // r1
  int **v33; // r4
  int *v35; // r2
  int *v36; // r3
  int v37; // r0
  _DWORD *v38; // r2
  _DWORD *v39; // r0
  bool v40; // zf
  signed int v41; // r3
  int v42; // r3
  int v43; // r11
  int v44; // r6
  int v45; // r10
  _DWORD *v46; // t1
  int v47; // r6
  int v48; // r9
  unsigned int v49; // [sp+18h] [bp+0h]
  int **v50; // [sp+1Ch] [bp+4h]
  int **v51; // [sp+20h] [bp+8h]
  unsigned int i; // [sp+24h] [bp+Ch]
  int *v53; // [sp+28h] [bp+10h]
  int v54; // [sp+2Ch] [bp+14h]

  v50 = a1;
  v53 = a3;
  v54 = a4;
  v51 = &v53;
  v11 = a8;
  v12 = sub_ADE94(a10 + 108);
  v13 = sub_B12DC(&v53, (int)&a5);
  if ( v13 || (v43 = sub_B12A4(&v53), !(2 * a9)) )
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
  }
  else
  {
    v44 = v11 - 4;
    i = v11;
    v14 = 0;
    v45 = 2 * a9;
    do
    {
      while ( 1 )
      {
        v46 = *(_DWORD **)(v44 + 4);
        v44 += 4;
        if ( *v46 == v43 || v43 == (*(int (**)(void))(*(_DWORD *)v12 + 24))() )
          break;
        if ( ++v13 == v45 )
          goto LABEL_69;
      }
      *(&v49 + v14++) = v13++;
    }
    while ( v13 != v45 );
LABEL_69:
    v11 = i;
    v15 = v14;
    v16 = (_DWORD **)v14;
    if ( v14 )
    {
      v47 = 0;
      sub_B088C(&v53);
      v48 = 0;
      v16 = &a5;
      do
      {
        ++v48;
        (&a5)[v47] = (_DWORD *)wcslen(*(const wchar_t **)(v11 + 4 * *(unsigned int *)((char *)&v49 + v47 * 4)));
        ++v47;
      }
      while ( v48 != v14 );
      v15 = 1;
    }
  }
  v17 = v53;
  for ( i = 4 * v15; ; i += 4 )
  {
    v18 = 1;
    if ( v17 )
    {
      if ( v54 == -1 )
      {
        v35 = (int *)v17[2];
        v36 = (int *)v17[3];
        if ( v35 >= v36 )
          v37 = (*(int (**)(void))(*v17 + 36))();
        else
          v37 = *v35;
        if ( v37 == -1 )
          v36 = 0;
        else
          v54 = v37;
        if ( v37 == -1 )
        {
          v53 = v36;
          v18 = 1;
        }
        else
        {
          v18 = 0;
        }
      }
      else
      {
        v18 = 0;
      }
    }
    v19 = 1;
    if ( !a5 )
      goto LABEL_12;
    if ( a6 != (_DWORD *)-1 )
    {
      v19 = 0;
LABEL_12:
      if ( v19 == v18 )
        break;
      goto LABEL_13;
    }
    v38 = (_DWORD *)a5[2];
    if ( (unsigned int)v38 >= a5[3] )
      v39 = (_DWORD *)(*(int (**)(void))(*a5 + 36))();
    else
      v39 = (_DWORD *)*v38;
    v40 = (_DWORD *)((char *)v39 + 1) == 0;
    if ( v39 == (_DWORD *)-1 )
      v39 = 0;
    else
      a6 = v39;
    if ( v40 )
    {
      a5 = v39;
      v41 = 1;
    }
    else
    {
      v41 = 0;
    }
    if ( v41 == v18 )
      break;
LABEL_13:
    v20 = -1;
    if ( v53 && (v20 = v54, v54 == -1) )
    {
      v31 = (int *)v53[2];
      if ( (unsigned int)v31 >= v53[3] )
        v20 = (*(int (__fastcall **)(int *))(*v53 + 36))(v53);
      else
        v20 = *v31;
      if ( v20 == -1 )
        v53 = 0;
      else
        v54 = v20;
      if ( !v14 )
        goto LABEL_38;
    }
    else if ( !v14 )
    {
      goto LABEL_38;
    }
    v21 = 0;
    v49 = v20;
    v22 = 0;
    do
    {
      v23 = v16[v21];
      v24 = 4 * v21;
      v25 = *(&v49 + v21);
      v26 = &v16[v21];
      if ( v15 >= (unsigned int)v23 )
      {
        ++v22;
        ++v21;
      }
      v27 = *(_DWORD *)(v11 + 4 * v25);
      if ( v15 < (unsigned int)v23 )
      {
        v28 = *(_DWORD *)(v27 + i);
        if ( v28 == v49 )
          ++v21;
        else
          --v14;
        if ( v28 != v49 )
        {
          v29 = v16[v14];
          *(unsigned int *)((char *)&v49 + v24) = *(&v49 + v14);
          *v26 = v29;
        }
      }
    }
    while ( v14 > v21 );
    if ( v14 == v22 )
      break;
    v17 = v53;
    if ( v53 )
    {
      v30 = v53[2];
      if ( v30 >= v53[3] )
      {
        (*(void (**)(void))(*v53 + 40))();
        v17 = v53;
      }
      else
      {
        v53[2] = v30 + 4;
      }
      v54 = -1;
    }
    ++v15;
  }
  if ( v14 != 1 )
  {
    if ( v14 == 2 && ((_DWORD *)v15 == *v16 || (_DWORD *)v15 == v16[1]) )
      goto LABEL_60;
LABEL_38:
    *a11 |= 4u;
    goto LABEL_39;
  }
  if ( (_DWORD *)v15 != *v16 )
    goto LABEL_38;
LABEL_60:
  v42 = v49;
  if ( a9 <= v49 )
    v42 = v49 - a9;
  *a7 = v42;
LABEL_39:
  v32 = v51[1];
  v33 = v50;
  *v50 = *v51;
  v33[1] = v32;
  return v33;
}

//----- (000B17A0) --------------------------------------------------------
_DWORD *__fastcall sub_B17A0(_DWORD *a1, int a2, int *a3, int a4, _DWORD *a5, _DWORD *a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r6
  int v10; // r10
  int v11; // r4
  _DWORD *v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  int v17; // r3
  _DWORD *v18; // r4
  int v19; // r5
  signed int v20; // r7
  signed int v21; // r3
  bool v22; // zf
  _DWORD *result; // r0
  int *v24; // r3
  int v25; // r0
  int *v26; // r3
  int *v27; // [sp+20h] [bp-70h]
  int v28; // [sp+24h] [bp-6Ch]
  int *v29; // [sp+28h] [bp-68h]
  int v30; // [sp+2Ch] [bp-64h]
  int v31; // [sp+30h] [bp-60h]
  int v32; // [sp+34h] [bp-5Ch]
  int v33; // [sp+38h] [bp-58h]
  int v34; // [sp+3Ch] [bp-54h]
  int v35; // [sp+40h] [bp-50h]
  int v36; // [sp+44h] [bp-4Ch]
  int v37; // [sp+48h] [bp-48h]
  int v38; // [sp+4Ch] [bp-44h]
  int v39; // [sp+50h] [bp-40h]
  int v40; // [sp+54h] [bp-3Ch]
  int v41; // [sp+58h] [bp-38h]
  int v42; // [sp+5Ch] [bp-34h]
  int v43; // [sp+60h] [bp-30h]
  int v44; // [sp+64h] [bp-2Ch]
  int v45; // [sp+68h] [bp-28h]
  int v46; // [sp+6Ch] [bp-24h]

  v9 = a1;
  v10 = a2;
  v29 = a3;
  v30 = a4;
  v11 = sub_AF00C(a7 + 108);
  sub_ADE94(a7 + 108);
  v12 = *(_DWORD **)(v11 + 8);
  v13 = v12[20];
  v14 = v12[18];
  v15 = v12[19];
  v35 = v13;
  v16 = *(_DWORD *)(v11 + 8);
  v34 = v15;
  v33 = v14;
  v36 = *(_DWORD *)(v16 + 84);
  v37 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 88);
  v38 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 92);
  v39 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 96);
  v40 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 44);
  v41 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 48);
  v42 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 52);
  v43 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 56);
  v44 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 60);
  v17 = *(_DWORD *)(v11 + 8);
  v32 = 0;
  v45 = *(_DWORD *)(v17 + 64);
  v46 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 68);
  sub_B1548(&v27, v10, v29, v30, a5, a6, &v31, (int)&v33, 7u, a7, &v32);
  v29 = v27;
  v30 = v28;
  v18 = v27;
  v19 = v28;
  if ( v32 )
    *a8 |= 4u;
  else
    *(_DWORD *)(a9 + 24) = v31;
  v20 = 1;
  if ( v18 )
  {
    if ( v19 == -1 )
    {
      v26 = (int *)v18[2];
      if ( (unsigned int)v26 >= v18[3] )
        v19 = (*(int (__fastcall **)(_DWORD *))(*v18 + 36))(v18);
      else
        v19 = *v26;
      if ( v19 == -1 )
        v18 = 0;
      else
        v20 = 0;
      if ( v19 == -1 )
        v20 = 1;
    }
    else
    {
      v20 = 0;
    }
  }
  v21 = 1;
  if ( a5 )
  {
    if ( a6 == (_DWORD *)-1 )
    {
      v24 = (int *)a5[2];
      if ( (unsigned int)v24 >= a5[3] )
        v25 = (*(int (**)(void))(*a5 + 36))();
      else
        v25 = *v24;
      v21 = (unsigned int)(v25 + 1) <= 0;
    }
    else
    {
      v21 = 0;
    }
  }
  v22 = v21 == v20;
  result = v9;
  *v9 = v18;
  if ( v21 == v20 )
    v21 = *a8;
  v9[1] = v19;
  if ( v22 )
    *a8 = v21 | 2;
  return result;
}

//----- (000B18F0) --------------------------------------------------------
_DWORD *__fastcall sub_B18F0(_DWORD *a1, int a2, int *a3, int a4, _DWORD *a5, _DWORD *a6, int a7, int *a8, int a9)
{
  _DWORD *v9; // r6
  int v10; // r10
  int v11; // r4
  _DWORD *v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  _DWORD *v17; // r4
  int v18; // r5
  signed int v19; // r8
  signed int v20; // r3
  bool v21; // zf
  _DWORD *result; // r0
  int *v23; // r3
  int v24; // r0
  int *v25; // r3
  int *v26; // [sp+20h] [bp-98h]
  int v27; // [sp+24h] [bp-94h]
  int *v28; // [sp+28h] [bp-90h]
  int v29; // [sp+2Ch] [bp-8Ch]
  int v30; // [sp+30h] [bp-88h]
  int v31; // [sp+34h] [bp-84h]
  int v32; // [sp+38h] [bp-80h]
  int v33; // [sp+3Ch] [bp-7Ch]
  int v34; // [sp+40h] [bp-78h]
  int v35; // [sp+44h] [bp-74h]
  int v36; // [sp+48h] [bp-70h]
  int v37; // [sp+4Ch] [bp-6Ch]
  int v38; // [sp+50h] [bp-68h]
  int v39; // [sp+54h] [bp-64h]
  int v40; // [sp+58h] [bp-60h]
  int v41; // [sp+5Ch] [bp-5Ch]
  int v42; // [sp+60h] [bp-58h]
  int v43; // [sp+64h] [bp-54h]
  int v44; // [sp+68h] [bp-50h]
  int v45; // [sp+6Ch] [bp-4Ch]
  int v46; // [sp+70h] [bp-48h]
  int v47; // [sp+74h] [bp-44h]
  int v48; // [sp+78h] [bp-40h]
  int v49; // [sp+7Ch] [bp-3Ch]
  int v50; // [sp+80h] [bp-38h]
  int v51; // [sp+84h] [bp-34h]
  int v52; // [sp+88h] [bp-30h]
  int v53; // [sp+8Ch] [bp-2Ch]
  int v54; // [sp+90h] [bp-28h]
  int v55; // [sp+94h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v28 = a3;
  v29 = a4;
  v11 = sub_AF00C(a7 + 108);
  sub_ADE94(a7 + 108);
  v12 = *(_DWORD **)(v11 + 8);
  v13 = v12[39];
  v14 = v12[37];
  v15 = v12[38];
  v34 = v13;
  v16 = *(_DWORD *)(v11 + 8);
  v33 = v15;
  v32 = v14;
  v35 = *(_DWORD *)(v16 + 160);
  v36 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 164);
  v37 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 168);
  v38 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 172);
  v39 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 176);
  v40 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 180);
  v41 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 184);
  v42 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 188);
  v43 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 192);
  v44 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 100);
  v45 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 104);
  v46 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 108);
  v47 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 112);
  v48 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 116);
  v49 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 120);
  v50 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 124);
  v51 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 128);
  v52 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 132);
  v53 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 136);
  v54 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 140);
  v55 = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 144);
  v31 = 0;
  sub_B1548(&v26, v10, v28, v29, a5, a6, &v30, (int)&v32, 0xCu, a7, &v31);
  v28 = v26;
  v29 = v27;
  v17 = v26;
  v18 = v27;
  if ( v31 )
    *a8 |= 4u;
  else
    *(_DWORD *)(a9 + 16) = v30;
  v19 = 1;
  if ( v17 )
  {
    if ( v18 == -1 )
    {
      v25 = (int *)v17[2];
      if ( (unsigned int)v25 >= v17[3] )
        v18 = (*(int (__fastcall **)(_DWORD *))(*v17 + 36))(v17);
      else
        v18 = *v25;
      if ( v18 == -1 )
        v17 = 0;
      else
        v19 = 0;
      if ( v18 == -1 )
        v19 = 1;
    }
    else
    {
      v19 = 0;
    }
  }
  v20 = 1;
  if ( a5 )
  {
    if ( a6 == (_DWORD *)-1 )
    {
      v23 = (int *)a5[2];
      if ( (unsigned int)v23 >= a5[3] )
        v24 = (*(int (**)(void))(*a5 + 36))();
      else
        v24 = *v23;
      v20 = (unsigned int)(v24 + 1) <= 0;
    }
    else
    {
      v20 = 0;
    }
  }
  v21 = v19 == v20;
  result = v9;
  *v9 = v17;
  if ( v19 == v20 )
    v20 = *a8;
  v9[1] = v18;
  if ( v21 )
    *a8 = v20 | 2;
  return result;
}

//----- (000B1AA4) --------------------------------------------------------
int **__fastcall sub_B1AA4(int **a1, int a2, int *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, _DWORD *a8, int *a9, const wchar_t *a10)
{
  int v10; // r4
  const wchar_t *v11; // r6
  int v12; // r11
  int v13; // r4
  unsigned int v14; // r9
  size_t v15; // r10
  _BOOL4 v16; // r2
  int v17; // r7
  signed int v18; // r3
  int v19; // r7
  signed int v20; // r7
  signed int v21; // r3
  int v22; // r1
  int *v24; // r3
  int v25; // r0
  unsigned int **v26; // r2
  unsigned int *v27; // r0
  _DWORD *v28; // r3
  int v29; // r8
  int v30; // r0
  bool v31; // zf
  int *v32; // r2
  int v33; // r3
  int v34; // r0
  _DWORD *v35; // r3
  _DWORD *v36; // r0
  unsigned int *v37; // r1
  int *v38; // r7
  int v39; // r3
  _DWORD *v40; // r3
  int *v41; // r7
  int v42; // r3
  int v43; // r3
  int v44; // r7
  const char *v45; // r1
  int v46; // r0
  char *v47; // r2
  int v48; // r0
  int v49; // ST20_4
  int v50; // ST20_4
  _DWORD *v51; // r3
  _DWORD *v52; // r3
  int v53; // r3
  _DWORD *v54; // r0
  unsigned int *v55; // r1
  int *v56; // r2
  int v57; // r0
  _DWORD **v58; // r0
  int v59; // r0
  int v60; // [sp+18h] [bp-A0h]
  int **v61; // [sp+28h] [bp-90h]
  int v62; // [sp+2Ch] [bp-8Ch]
  int *v63; // [sp+48h] [bp-70h]
  int v64; // [sp+4Ch] [bp-6Ch]
  int *v65; // [sp+50h] [bp-68h]
  int v66; // [sp+54h] [bp-64h]
  int v67; // [sp+58h] [bp-60h]
  int v68; // [sp+5Ch] [bp-5Ch]
  int v69; // [sp+60h] [bp-58h]
  int v70; // [sp+64h] [bp-54h]
  int v71; // [sp+68h] [bp-50h]
  int v72; // [sp+6Ch] [bp-4Ch]
  int v73; // [sp+70h] [bp-48h]
  int v74; // [sp+74h] [bp-44h]
  int v75; // [sp+78h] [bp-40h]
  int v76; // [sp+7Ch] [bp-3Ch]
  int v77; // [sp+80h] [bp-38h]
  int v78; // [sp+84h] [bp-34h]
  int v79; // [sp+88h] [bp-30h]
  int v80; // [sp+8Ch] [bp-2Ch]

  v61 = a1;
  v10 = a7 + 108;
  v65 = a3;
  v66 = a4;
  v62 = a2;
  v11 = a10;
  v12 = sub_AF00C(a7 + 108);
  v13 = sub_ADE94(v10);
  v14 = 0;
  v67 = 0;
  v15 = wcslen(v11);
  while ( 1 )
  {
    v20 = 1;
    if ( v65 )
    {
      if ( v66 == -1 )
      {
        v24 = (int *)v65[2];
        if ( (unsigned int)v24 >= v65[3] )
          v25 = (*(int (**)(void))(*v65 + 36))();
        else
          v25 = *v24;
        if ( v25 == -1 )
          v24 = 0;
        else
          v66 = v25;
        if ( v25 == -1 )
        {
          v65 = v24;
          v20 = 1;
        }
        else
        {
          v20 = 0;
        }
      }
      else
      {
        v20 = 0;
      }
    }
    v21 = 1;
    if ( a5 )
    {
      if ( a6 == (unsigned int *)-1 )
      {
        v26 = (unsigned int **)a5[2];
        if ( (unsigned int)v26 >= a5[3] )
          v27 = (unsigned int *)(*(int (**)(void))(*a5 + 36))();
        else
          v27 = *v26;
        v28 = (unsigned int *)((char *)v27 + 1);
        if ( v27 == (unsigned int *)-1 )
          v28 = 0;
        else
          a6 = v27;
        if ( v27 == (unsigned int *)-1 )
        {
          a5 = v28;
          v21 = 1;
        }
        else
        {
          v21 = 0;
        }
      }
      else
      {
        v21 = 0;
      }
    }
    if ( v21 == v20 )
      break;
    v16 = v14 < v15;
    if ( v67 )
      v16 = 0;
    if ( !v16 )
      break;
    v17 = (int)&v11[2 * v14];
    if ( (*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v13 + 48))(v13, *(_DWORD *)&v11[2 * v14], 0) == 37 )
    {
      v29 = v14 + 1;
      v30 = (*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v13 + 48))(v13, *(_DWORD *)(v17 + 4), 0);
      v68 = 0;
      v31 = v30 == 69;
      if ( v30 != 69 )
        v31 = v30 == 79;
      if ( v31 )
      {
        v29 = v14 + 2;
        v30 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v13 + 48))(v13, *(_DWORD *)(v17 + 8));
      }
      switch ( v30 )
      {
        case 65:
          v35 = *(_DWORD **)(v12 + 8);
          v36 = a5;
          v37 = a6;
          v38 = a9 + 6;
          v69 = v35[11];
          v70 = v35[12];
          v71 = v35[13];
          v72 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 56);
          v73 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 60);
          v74 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 64);
          v39 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 68);
          goto LABEL_59;
        case 66:
          v40 = *(_DWORD **)(v12 + 8);
          v41 = a9 + 4;
          v69 = v40[25];
          v70 = v40[26];
          v71 = v40[27];
          v72 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 112);
          v73 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 116);
          v74 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 120);
          v75 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 124);
          v76 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 128);
          v77 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 132);
          v78 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 136);
          v79 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 140);
          v42 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 144);
          goto LABEL_61;
        case 67:
        case 89:
        case 121:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, &v68, 0, 9999, 4, a7, (unsigned int *)&v67);
          v65 = v63;
          v66 = v64;
          if ( !v67 )
          {
            if ( v68 >= 0 )
              v43 = v68 - 1900;
            else
              v43 = v68 + 100;
            a9[5] = v43;
          }
          break;
        case 68:
          v44 = *(_DWORD *)v13;
          v45 = "%m/%d/%y";
          v46 = v13;
          v47 = algn_E2D2D;
          goto LABEL_68;
        case 72:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, a9 + 2, 0, 23, 2, a7, (unsigned int *)&v67);
          goto LABEL_70;
        case 73:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, a9 + 2, 1, 12, 2, a7, (unsigned int *)&v67);
          goto LABEL_70;
        case 77:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, a9 + 1, 0, 59, 2, a7, (unsigned int *)&v67);
          goto LABEL_70;
        case 82:
          v44 = *(_DWORD *)v13;
          v46 = v13;
          v45 = "%H:%M";
          v47 = algn_E2D36;
          goto LABEL_68;
        case 83:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, a9, 0, 61, 2, a7, (unsigned int *)&v67);
          v65 = v63;
          v66 = v64;
          break;
        case 84:
          v44 = *(_DWORD *)v13;
          v46 = v13;
          v45 = "%H:%M:%S";
          v47 = algn_E2D41;
LABEL_68:
          (*(void (__fastcall **)(int, const char *, char *, int *))(v44 + 44))(v46, v45, v47, &v69);
          sub_B1AA4(&v63, v62, v65, v66, a5, a6, a7, &v67, a9, &v69);
          v65 = v63;
          v66 = v64;
          break;
        case 88:
          sub_B1AA4(&v63, v62, v65, v66, a5, a6, a7, &v67, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 16));
          v65 = v63;
          v66 = v64;
          break;
        case 90:
          v48 = sub_B12A4(&v65);
          if ( !(*(int (__fastcall **)(int, signed int, int))(*(_DWORD *)v13 + 8))(v13, 1, v48) )
            goto def_B1BFA;
          sub_B1364(&v63, v62, v65, v66, (int)a5, (int)a6, &v69, (int)&off_F3C98, 14, a7, &v67);
          v65 = v63;
          v66 = v64;
          if ( !sub_B12DC(&v65, (int)&a5) && !v67 && !v69 )
          {
            v49 = sub_B12A4(&v65);
            if ( v49 == (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v13 + 40))(v13, 45)
              || (v50 = sub_B12A4(&v65), v50 == (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v13 + 40))(v13, 43)) )
            {
              sub_ADFFC(&v63, v62, v65, v66, a5, a6, &v69, 0, 23, 2, a7, (unsigned int *)&v67);
              v65 = v63;
              v66 = v64;
              sub_ADFFC(&v63, v62, v63, v64, a5, a6, &v69, 0, 59, 2, a7, (unsigned int *)&v67);
              v65 = v63;
              v66 = v64;
            }
          }
          break;
        case 97:
          v51 = *(_DWORD **)(v12 + 8);
          v36 = a5;
          v37 = a6;
          v38 = a9 + 6;
          v69 = v51[18];
          v70 = v51[19];
          v71 = v51[20];
          v72 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 84);
          v73 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 88);
          v74 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 92);
          v39 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 96);
LABEL_59:
          v75 = v39;
          sub_B1364(&v63, v62, v65, v66, (int)v36, (int)v37, v38, (int)&v69, 7, a7, &v67);
          v65 = v63;
          v66 = v64;
          break;
        case 98:
        case 104:
          v52 = *(_DWORD **)(v12 + 8);
          v41 = a9 + 4;
          v69 = v52[37];
          v70 = v52[38];
          v71 = v52[39];
          v72 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 160);
          v73 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 164);
          v74 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 168);
          v75 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 172);
          v76 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 176);
          v77 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 180);
          v78 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 184);
          v79 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 188);
          v42 = *(_DWORD *)(*(_DWORD *)(v12 + 8) + 192);
LABEL_61:
          v80 = v42;
          sub_B1364(&v63, v62, v65, v66, (int)a5, (int)a6, v41, (int)&v69, 12, a7, &v67);
          v65 = v63;
          v66 = v64;
          break;
        case 99:
          sub_B1AA4(&v63, v62, v65, v66, a5, a6, a7, &v67, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 24));
          v65 = v63;
          v66 = v64;
          break;
        case 100:
          v53 = 1;
          v54 = a5;
          v55 = a6;
          v60 = a7;
          v56 = a9 + 3;
          goto LABEL_88;
        case 101:
          v57 = sub_B12A4(&v65);
          if ( (*(int (__fastcall **)(int, signed int, int))(*(_DWORD *)v13 + 8))(v13, 8, v57) )
          {
            v58 = sub_B088C(&v65);
            sub_ADFFC(&v63, v62, *v58, (signed int)v58[1], a5, a6, a9 + 3, 1, 9, 1, a7, (unsigned int *)&v67);
            v65 = v63;
            v66 = v64;
          }
          else
          {
            v54 = a5;
            v55 = a6;
            v53 = 10;
            v60 = a7;
            v56 = a9 + 3;
LABEL_88:
            sub_ADFFC(&v63, v62, v65, v66, v54, v55, v56, v53, 31, 2, v60, (unsigned int *)&v67);
LABEL_70:
            v65 = v63;
            v66 = v64;
          }
          break;
        case 109:
          sub_ADFFC(&v63, v62, v65, v66, a5, a6, &v68, 1, 12, 2, a7, (unsigned int *)&v67);
          v65 = v63;
          v66 = v64;
          if ( !v67 )
            a9[4] = v68 - 1;
          break;
        case 110:
          v34 = sub_B12A4(&v65);
          if ( (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v13 + 48))(v13, v34, 0) != 10 )
            goto def_B1BFA;
          goto LABEL_94;
        case 116:
          v59 = sub_B12A4(&v65);
          if ( (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v13 + 48))(v13, v59, 0) != 9 )
            goto def_B1BFA;
LABEL_94:
          sub_B088C(&v65);
          break;
        case 120:
          sub_B1AA4(&v63, v62, v65, v66, a5, a6, a7, &v67, a9, *(_DWORD *)(*(_DWORD *)(v12 + 8) + 8));
          v65 = v63;
          v66 = v64;
          break;
        default:
def_B1BFA:
          v67 |= 4u;
          break;
      }
      v14 = v29;
    }
    else
    {
      v18 = -1;
      v19 = *(_DWORD *)&v11[2 * v14];
      if ( v65 && (v18 = v66, v66 == -1) )
      {
        v32 = (int *)v65[2];
        if ( (unsigned int)v32 >= v65[3] )
          v33 = (*(int (**)(void))(*v65 + 36))();
        else
          v33 = *v32;
        if ( v33 == -1 )
          v65 = 0;
        else
          v66 = v33;
        if ( v19 != v33 )
        {
LABEL_9:
          v67 |= 4u;
          goto LABEL_10;
        }
      }
      else if ( v19 != v18 )
      {
        goto LABEL_9;
      }
      sub_B088C(&v65);
    }
LABEL_10:
    ++v14;
  }
  if ( v67 || v14 != v15 )
    *a8 |= 4u;
  v22 = v66;
  *v61 = v65;
  v61[1] = (int *)v22;
  return v61;
}
// F3C98: using guessed type void *off_F3C98;

//----- (000B22E4) --------------------------------------------------------
int **__fastcall sub_B22E4(int **a1, int a2, int *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int *a9)
{
  int **v9; // r5
  int v10; // r9
  int v11; // r0
  signed int v12; // r7
  int *v13; // r4
  int v14; // r6
  signed int v15; // r3
  bool v16; // zf
  int **result; // r0
  int *v18; // r3
  int v19; // r0
  int *v20; // r3
  int *v21; // [sp+18h] [bp-30h]
  int v22; // [sp+1Ch] [bp-2Ch]
  int *v23; // [sp+20h] [bp-28h]
  int v24; // [sp+24h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v23 = a3;
  v24 = a4;
  v11 = sub_AF00C(a7 + 108);
  v12 = 1;
  sub_B1AA4(&v21, v10, v23, v24, a5, a6, a7, a8, a9, *(const wchar_t **)(*(_DWORD *)(v11 + 8) + 16));
  v23 = v21;
  v24 = v22;
  v13 = v21;
  v14 = v22;
  if ( v21 )
  {
    if ( v24 == -1 )
    {
      v20 = (int *)v23[2];
      if ( (unsigned int)v20 >= v23[3] )
        v14 = (*(int (__fastcall **)(int *))(*v23 + 36))(v23);
      else
        v14 = *v20;
      if ( v14 == -1 )
        v13 = 0;
      else
        v12 = 0;
      if ( v14 == -1 )
        v12 = 1;
    }
    else
    {
      v12 = 0;
    }
  }
  v15 = 1;
  if ( a5 )
  {
    if ( a6 == (unsigned int *)-1 )
    {
      v18 = (int *)a5[2];
      if ( (unsigned int)v18 >= a5[3] )
        v19 = (*(int (**)(void))(*a5 + 36))();
      else
        v19 = *v18;
      v15 = (unsigned int)(v19 + 1) <= 0;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = v15 == v12;
  result = v9;
  *v9 = v13;
  if ( v15 == v12 )
    v15 = *a8;
  v9[1] = (int *)v14;
  if ( v16 )
    *a8 = v15 | 2;
  return result;
}

//----- (000B23B4) --------------------------------------------------------
int **__fastcall sub_B23B4(int **a1, int a2, int *a3, int a4, _DWORD *a5, unsigned int *a6, int a7, int *a8, int *a9)
{
  int **v9; // r5
  int v10; // r9
  int v11; // r0
  signed int v12; // r7
  int *v13; // r4
  int v14; // r6
  signed int v15; // r3
  bool v16; // zf
  int **result; // r0
  int *v18; // r3
  int v19; // r0
  int *v20; // r3
  int *v21; // [sp+18h] [bp-30h]
  int v22; // [sp+1Ch] [bp-2Ch]
  int *v23; // [sp+20h] [bp-28h]
  int v24; // [sp+24h] [bp-24h]

  v9 = a1;
  v10 = a2;
  v23 = a3;
  v24 = a4;
  v11 = sub_AF00C(a7 + 108);
  v12 = 1;
  sub_B1AA4(&v21, v10, v23, v24, a5, a6, a7, a8, a9, *(const wchar_t **)(*(_DWORD *)(v11 + 8) + 8));
  v23 = v21;
  v24 = v22;
  v13 = v21;
  v14 = v22;
  if ( v21 )
  {
    if ( v24 == -1 )
    {
      v20 = (int *)v23[2];
      if ( (unsigned int)v20 >= v23[3] )
        v14 = (*(int (__fastcall **)(int *))(*v23 + 36))(v23);
      else
        v14 = *v20;
      if ( v14 == -1 )
        v13 = 0;
      else
        v12 = 0;
      if ( v14 == -1 )
        v12 = 1;
    }
    else
    {
      v12 = 0;
    }
  }
  v15 = 1;
  if ( a5 )
  {
    if ( a6 == (unsigned int *)-1 )
    {
      v18 = (int *)a5[2];
      if ( (unsigned int)v18 >= a5[3] )
        v19 = (*(int (**)(void))(*a5 + 36))();
      else
        v19 = *v18;
      v15 = (unsigned int)(v19 + 1) <= 0;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = v15 == v12;
  result = v9;
  *v9 = v13;
  if ( v15 == v12 )
    v15 = *a8;
  v9[1] = (int *)v14;
  if ( v16 )
    *a8 = v15 | 2;
  return result;
}

//----- (000B2484) --------------------------------------------------------
int **__fastcall sub_B2484(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int *v9; // r4
  int v10; // r8
  int v11; // r0
  int v12; // r9
  int v13; // r3
  int v14; // r6
  int v15; // r0
  signed int v16; // r7
  int *v17; // r0
  int v18; // r5
  _DWORD *v19; // r0
  signed int v20; // r3
  int v21; // r3
  int v22; // r2
  int *v23; // r0
  signed int v24; // r5
  _DWORD *v25; // r0
  signed int v26; // r3
  int v27; // r5
  wchar_t *v28; // r0
  _BYTE *v29; // r3
  int v30; // r2
  int v31; // r5
  char v32; // r7
  _DWORD *v33; // r3
  unsigned int v34; // r3
  unsigned int *v35; // r3
  int v36; // r1
  _BOOL4 v38; // r3
  int v39; // r3
  signed int v40; // r0
  unsigned int v41; // r2
  _DWORD *v42; // r3
  _BYTE *v43; // r3
  char v44; // r1
  unsigned int v45; // r3
  int *v46; // r3
  int v47; // r0
  int v48; // r3
  int *v49; // r3
  int v50; // r0
  int *v51; // r2
  _BYTE *v52; // r3
  int v53; // r2
  int v54; // r5
  _DWORD *v55; // r3
  int v56; // r2
  bool v57; // zf
  int *v58; // r3
  int v59; // r0
  int v60; // r1
  int *v61; // r3
  int v62; // r0
  int *v63; // r3
  int *v64; // r3
  int v65; // r2
  int v66; // r11
  int v67; // r5
  int *v68; // r0
  signed int v69; // r7
  _DWORD *v70; // r0
  signed int v71; // r3
  unsigned int v72; // r3
  _DWORD *v73; // r3
  int v74; // r0
  int *v75; // r3
  int *v76; // r2
  int v77; // r0
  int v78; // r5
  unsigned int i; // r4
  int v80; // r0
  int v81; // t1
  int v82; // [sp+10h] [bp-78h]
  int v83; // [sp+14h] [bp-74h]
  signed int v84; // [sp+20h] [bp-68h]
  unsigned int v85; // [sp+28h] [bp-60h]
  char v86; // [sp+2Ch] [bp-5Ch]
  signed int v87; // [sp+30h] [bp-58h]
  int **v88; // [sp+34h] [bp-54h]
  _BOOL4 v89; // [sp+3Ch] [bp-4Ch]
  int *v90; // [sp+40h] [bp-48h]
  wchar_t c[2]; // [sp+44h] [bp-44h]
  char v92; // [sp+4Ch] [bp-3Ch]
  _DWORD *v93; // [sp+54h] [bp-34h]
  char *v94; // [sp+58h] [bp-30h]
  int v95; // [sp+5Ch] [bp-2Ch]

  v88 = a1;
  v9 = (int *)(a7 + 108);
  v90 = a3;
  *(_DWORD *)c = a4;
  v10 = sub_ADE94(a7 + 108);
  v11 = sub_B08B4((int)&v92, v9);
  v12 = v11;
  v83 = v11 + 64;
  if ( *(_DWORD *)(v11 + 40) )
    v89 = *(_DWORD *)(v11 + 48) != 0;
  else
    v89 = 0;
  v13 = *(unsigned __int8 *)(v11 + 16);
  v93 = &unk_2FEF48;
  if ( v13 )
    sub_C1264(&v93, 0x20u);
  v94 = (char *)&unk_2FEF48;
  sub_C1264(&v94, 0x20u);
  v14 = 0;
  v82 = 0;
  v84 = 0;
  v95 = *(_DWORD *)(v12 + 60);
  v86 = 0;
  v85 = 0;
  v87 = 0;
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v95 + v82) )
    {
      case 0u:
        goto LABEL_9;
      case 1u:
        if ( sub_B12DC(&v90, (int)&a5)
          || (v15 = sub_B12A4(&v90), !(*(int (__fastcall **)(int, signed int, int))(*(_DWORD *)v10 + 8))(v10, 8, v15)) )
        {
          v16 = 0;
          if ( v82 != 3 )
            goto LABEL_10;
        }
        else
        {
          sub_B088C(&v90);
LABEL_9:
          v16 = 1;
          if ( v82 != 3 )
          {
LABEL_10:
            v17 = v90;
            if ( v90 )
            {
LABEL_11:
              if ( *(_DWORD *)c == -1 )
              {
                v49 = (int *)v17[2];
                if ( (unsigned int)v49 >= v17[3] )
                  v50 = (*(int (**)(void))(*v17 + 36))();
                else
                  v50 = *v49;
                v51 = (int *)(v50 + 1);
                if ( v50 == -1 )
                  v51 = 0;
                else
                  *(_DWORD *)c = v50;
                if ( v50 == -1 )
                {
                  v90 = v51;
                  v18 = 1;
                }
                else
                {
                  v18 = 0;
                }
              }
              else
              {
                v18 = 0;
              }
LABEL_14:
              v19 = a5;
              if ( !a5 )
                goto LABEL_103;
            }
            else
            {
              while ( 1 )
              {
                v19 = a5;
                v18 = 1;
                if ( a5 )
                  break;
LABEL_103:
                v20 = 1;
LABEL_18:
                if ( v20 == v18 )
                  goto LABEL_19;
                if ( v90 && *(_DWORD *)c == -1 )
                {
                  v64 = (int *)v90[2];
                  if ( (unsigned int)v64 >= v90[3] )
                    v65 = (*(int (**)(void))(*v90 + 36))();
                  else
                    v65 = *v64;
                  if ( v65 == -1 )
                    v90 = 0;
                  else
                    *(_DWORD *)c = v65;
                }
                v18 = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v10 + 8))(v10, 8);
                if ( !v18 )
                  goto LABEL_19;
                v17 = v90;
                if ( !v90 )
                  goto LABEL_14;
                v45 = v90[2];
                if ( v45 >= v90[3] )
                {
                  (*(void (**)(void))(*v90 + 40))();
                  v17 = v90;
                }
                else
                {
                  v90[2] = v45 + 4;
                }
                *(_DWORD *)c = -1;
                if ( v17 )
                  goto LABEL_11;
              }
            }
            if ( a6 == -1 )
            {
              v46 = (int *)v19[2];
              if ( (unsigned int)v46 >= v19[3] )
                v47 = (*(int (**)(void))(*v19 + 36))();
              else
                v47 = *v46;
              v48 = v47 + 1;
              if ( v47 == -1 )
                v48 = 0;
              else
                a6 = v47;
              if ( v47 == -1 )
              {
                a5 = (_DWORD *)v48;
                v20 = 1;
              }
              else
              {
                v20 = 0;
              }
            }
            else
            {
              v20 = 0;
            }
            goto LABEL_18;
          }
        }
        if ( v85 > 1 )
          v39 = v16 & 1;
        else
          v39 = 0;
LABEL_65:
        if ( v39 )
        {
          if ( v87 )
            v78 = *(_DWORD *)(v12 + 44);
          else
            v78 = *(_DWORD *)(v12 + 36);
          for ( i = 1; !sub_B12DC(&v90, (int)&a5) && i < v85; ++i )
          {
            v80 = sub_B12A4(&v90);
            v81 = *(_DWORD *)(v78 + 4);
            v78 += 4;
            if ( v81 != v80 )
              goto LABEL_49;
            sub_B088C(&v90);
          }
          if ( i != v85 )
            goto LABEL_49;
        }
        else if ( !v16 )
        {
LABEL_49:
          *a8 |= 4u;
          goto LABEL_50;
        }
        if ( *((_DWORD *)v94 - 3) > 1u )
        {
          v40 = sub_C0768((int *)&v94, 48, 0);
          if ( v40 )
          {
            v42 = (_DWORD *)(v40 + 1);
            if ( v40 == -1 )
              v42 = v94;
            else
              v41 = v40;
            if ( v40 == -1 )
              v41 = *(v42 - 3) - 1;
            sub_C0D44((int *)&v94, 0, v41);
          }
        }
        if ( v87 )
        {
          v43 = v94;
          if ( *((_DWORD *)v94 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v94);
            v43 = v94;
          }
          if ( *v43 != 48 )
          {
            if ( *((_DWORD *)v43 - 1) >= 0 )
              sub_C0BF4((int *)&v94);
            sub_C0DB8((int *)&v94, 0, 0, 1u, 0x2Du);
            *((_DWORD *)v94 - 1) = -1;
          }
        }
        if ( *(v93 - 3) )
        {
          v44 = v14;
          if ( v84 )
            v44 = v86;
          sub_C15D0((int *)&v93, v44);
          if ( !sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v93) )
            *a8 |= 4u;
        }
        if ( v84 && *(_DWORD *)(v12 + 52) != v14 )
          goto LABEL_49;
        sub_C0480(a9, (int *)&v94);
LABEL_50:
        if ( sub_B12DC(&v90, (int)&a5) )
          *a8 |= 2u;
        v35 = (unsigned int *)v94;
        v36 = *(_DWORD *)c;
        *v88 = v90;
        v88[1] = (int *)v36;
        sub_C0AC4(v35 - 3);
        sub_C0AC4(v93 - 3);
        return v88;
      case 2u:
        if ( *(_DWORD *)(a7 + 12) & 0x200 )
          goto LABEL_172;
        v38 = v82 == 0;
        if ( v85 > 1 )
          v38 = 1;
        if ( v38 )
          goto LABEL_172;
        if ( v82 == 1 )
        {
          if ( v89 || (unsigned __int8)v95 == 3 )
            goto LABEL_172;
          if ( BYTE2(v95) == 1 )
          {
            v66 = *(_DWORD *)(v12 + 32);
            v67 = 0;
            v68 = v90;
            goto LABEL_173;
          }
          v21 = 2;
        }
        else
        {
          if ( v82 != 2 )
            goto def_B253A;
          if ( HIBYTE(v95) == 4 || v89 && HIBYTE(v95) == 3 )
          {
LABEL_172:
            v66 = *(_DWORD *)(v12 + 32);
            v67 = 0;
            v68 = v90;
LABEL_173:
            if ( v68 )
              goto LABEL_174;
LABEL_192:
            v70 = a5;
            v69 = 1;
            if ( a5 )
            {
              while ( 1 )
              {
                if ( a6 == -1 )
                {
                  v73 = (_DWORD *)v70[2];
                  v74 = (unsigned int)v73 >= v70[3] ? (*(int (**)(void))(*v70 + 36))() : *v73;
                  if ( v74 == -1 )
                    v73 = 0;
                  else
                    a6 = v74;
                  if ( v74 == -1 )
                  {
                    a5 = v73;
                    v71 = 1;
                  }
                  else
                  {
                    v71 = 0;
                  }
                }
                else
                {
                  v71 = 0;
                }
                if ( v71 == v69 )
                  break;
LABEL_182:
                if ( v67 == v66 )
                  goto def_B253A;
                if ( *(_DWORD *)(*(_DWORD *)(v12 + 28) + 4 * v67) != sub_B12A4(&v90) )
                  goto LABEL_184;
                v68 = v90;
                if ( v90 )
                {
                  v72 = v90[2];
                  if ( v72 >= v90[3] )
                  {
                    (*(void (**)(void))(*v90 + 40))();
                    v68 = v90;
                  }
                  else
                  {
                    v90[2] = v72 + 4;
                  }
                  *(_DWORD *)c = -1;
                }
                ++v67;
                if ( !v68 )
                  goto LABEL_192;
LABEL_174:
                if ( *(_DWORD *)c == -1 )
                {
                  v75 = (int *)v68[2];
                  v76 = (int *)v68[3];
                  if ( v75 >= v76 )
                    v77 = (*(int (**)(void))(*v68 + 36))();
                  else
                    v77 = *v75;
                  if ( v77 == -1 )
                    v76 = 0;
                  else
                    *(_DWORD *)c = v77;
                  if ( v77 == -1 )
                  {
                    v90 = v76;
                    v69 = 1;
                  }
                  else
                  {
                    v69 = 0;
                  }
                }
                else
                {
                  v69 = 0;
                }
                v70 = a5;
                if ( !a5 )
                  goto LABEL_193;
              }
            }
            else
            {
LABEL_193:
              if ( v69 != 1 )
                goto LABEL_182;
            }
            if ( v67 != v66 )
            {
LABEL_184:
              if ( v67 || *(_DWORD *)(a7 + 12) & 0x200 )
                goto LABEL_49;
            }
def_B253A:
            v16 = 1;
            goto LABEL_19;
          }
          v21 = 3;
        }
        goto LABEL_23;
      case 3u:
        if ( *(_DWORD *)(v12 + 40) && !sub_B12DC(&v90, (int)&a5) && **(_DWORD **)(v12 + 36) == sub_B12A4(&v90) )
        {
          v85 = *(_DWORD *)(v12 + 40);
          sub_B088C(&v90);
          goto def_B253A;
        }
        if ( !*(_DWORD *)(v12 + 48) || sub_B12DC(&v90, (int)&a5) || **(_DWORD **)(v12 + 44) != sub_B12A4(&v90) )
        {
          if ( !*(_DWORD *)(v12 + 40) || *(_DWORD *)(v12 + 48) )
          {
            v16 = !v89;
          }
          else
          {
            v87 = 1;
            v16 = 1;
          }
        }
        else
        {
          v85 = *(_DWORD *)(v12 + 48);
          sub_B088C(&v90);
          v16 = 1;
          v87 = 1;
        }
        goto LABEL_19;
      case 4u:
        v23 = v90;
        if ( v90 )
          goto LABEL_25;
        while ( 2 )
        {
          v25 = a5;
          v24 = 1;
          if ( !a5 )
            goto LABEL_46;
LABEL_29:
          if ( a6 == -1 )
          {
            v58 = (int *)v25[2];
            if ( (unsigned int)v58 >= v25[3] )
              v59 = (*(int (**)(void))(*v25 + 36))();
            else
              v59 = *v58;
            v60 = v59 + 1;
            if ( v59 == -1 )
              v60 = 0;
            else
              a6 = v59;
            if ( v59 == -1 )
            {
              a5 = (_DWORD *)v60;
              v26 = 1;
            }
            else
            {
              v26 = 0;
            }
          }
          else
          {
            v26 = 0;
          }
          if ( v24 == v26 )
            goto LABEL_47;
LABEL_33:
          if ( v90 )
          {
            v27 = *(_DWORD *)c;
            if ( *(_DWORD *)c == -1 )
            {
              v63 = (int *)v90[2];
              if ( (unsigned int)v63 >= v90[3] )
                v27 = (*(int (**)(void))(*v90 + 36))();
              else
                v27 = *v63;
              if ( v27 == -1 )
                v90 = 0;
              else
                *(_DWORD *)c = v27;
            }
          }
          else
          {
            v27 = -1;
          }
          v28 = wmemchr((const wchar_t *)(v12 + 68), v27, 0xAu);
          if ( v28 )
          {
            v29 = v94;
            v30 = *((_DWORD *)v94 - 3);
            v31 = v30 + 1;
            v32 = off_F3C5C[0][((signed int)v28 - v83) >> 2];
            if ( (unsigned int)(v30 + 1) > *((_DWORD *)v94 - 2) || *((_DWORD *)v94 - 1) > 0 )
            {
              sub_C1264(&v94, v30 + 1);
              v29 = v94;
              v30 = *((_DWORD *)v94 - 3);
            }
            v29[v30] = v32;
            ++v14;
            v33 = v94;
            if ( v94 - 12 != (char *)&dword_2FEF3C )
            {
              *((_DWORD *)v94 - 3) = v31;
              *(v33 - 1) = 0;
              *((_BYTE *)v33 + v31) = 0;
            }
            goto LABEL_41;
          }
          if ( *(_DWORD *)(v12 + 20) == v27 && !v84 )
          {
            if ( *(_DWORD *)(v12 + 52) <= 0 )
              goto LABEL_47;
            v86 = v14;
            v14 = 0;
            v84 = 1;
LABEL_41:
            v23 = v90;
            if ( !v90 )
              continue;
            v34 = v90[2];
            if ( v34 >= v90[3] )
            {
              (*(void (**)(void))(*v90 + 40))();
              v23 = v90;
            }
            else
            {
              v90[2] = v34 + 4;
            }
            *(_DWORD *)c = -1;
            if ( !v23 )
              continue;
LABEL_25:
            if ( *(_DWORD *)c == -1 )
            {
              v61 = (int *)v23[2];
              if ( (unsigned int)v61 >= v23[3] )
                v62 = (*(int (**)(void))(*v23 + 36))();
              else
                v62 = *v61;
              if ( v62 == -1 )
                v61 = 0;
              else
                *(_DWORD *)c = v62;
              if ( v62 == -1 )
              {
                v90 = v61;
                v24 = 1;
              }
              else
              {
                v24 = 0;
              }
            }
            else
            {
              v24 = 0;
            }
            v25 = a5;
            if ( !a5 )
            {
LABEL_46:
              if ( v24 != 1 )
                goto LABEL_33;
LABEL_47:
              v16 = 1;
              goto LABEL_48;
            }
            goto LABEL_29;
          }
          break;
        }
        if ( !*(_BYTE *)(v12 + 16) || *(_DWORD *)(v12 + 24) != v27 || v84 )
          goto LABEL_47;
        if ( v14 )
        {
          v52 = v93;
          v14 = (unsigned __int8)v14;
          v53 = *(v93 - 3);
          v54 = v53 + 1;
          if ( (unsigned int)(v53 + 1) > *(v93 - 2) || *(v93 - 1) > 0 )
          {
            sub_C1264(&v93, v53 + 1);
            v52 = v93;
            v53 = *(v93 - 3);
          }
          v52[v53] = v14;
          v55 = v93;
          v56 = (int)(v93 - 3);
          v57 = v93 - 3 == &dword_2FEF3C;
          if ( v93 - 3 == &dword_2FEF3C )
          {
            v14 = 0;
          }
          else
          {
            *(v93 - 3) = v54;
            v56 = 0;
          }
          if ( !v57 )
          {
            *(v55 - 1) = v56;
            v14 = v56;
            *((_BYTE *)v55 + v54) = v56;
          }
          goto LABEL_41;
        }
        v16 = 0;
LABEL_48:
        if ( !*((_DWORD *)v94 - 3) )
          goto LABEL_49;
LABEL_19:
        v21 = v82 + 1;
        if ( v82 + 1 <= 3 )
          v22 = v16 & 1;
        else
          v22 = 0;
        if ( !v22 )
        {
          if ( v85 > 1 )
            v39 = v16 & 1;
          else
            v39 = 0;
          goto LABEL_65;
        }
LABEL_23:
        v82 = v21;
        continue;
      default:
        goto def_B253A;
    }
  }
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B2C08) --------------------------------------------------------
int **__fastcall sub_B2C08(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int *a7, _DWORD *a8, int *a9)
{
  int *v9; // r4
  int v10; // r8
  int v11; // r0
  int v12; // r9
  int v13; // r3
  int v14; // r6
  int v15; // r0
  int v16; // r1
  signed int v17; // r7
  int *v18; // r0
  int v19; // r5
  _DWORD *v20; // r0
  signed int v21; // r3
  int v22; // r3
  int v23; // r2
  int *v24; // r0
  signed int v25; // r5
  _DWORD *v26; // r0
  signed int v27; // r3
  int v28; // r5
  wchar_t *v29; // r0
  _BYTE *v30; // r3
  int v31; // r2
  int v32; // r5
  char v33; // r7
  _DWORD *v34; // r3
  unsigned int v35; // r3
  char *v36; // r3
  int v37; // r1
  int *v38; // r2
  int *v40; // r1
  _BOOL4 v41; // r3
  int v42; // r3
  signed int v43; // r0
  unsigned int v44; // r2
  _DWORD *v45; // r3
  _BYTE *v46; // r3
  char v47; // r1
  unsigned int v48; // r3
  int *v49; // r3
  int v50; // r0
  int **v51; // r3
  int *v52; // r0
  bool v53; // zf
  _BYTE *v54; // r3
  int v55; // r2
  int v56; // r5
  _DWORD *v57; // r3
  int v58; // r2
  bool v59; // zf
  int *v60; // r3
  int v61; // r0
  bool v62; // zf
  int *v63; // r3
  int v64; // r0
  int *v65; // r3
  int *v66; // r3
  int v67; // r2
  int v68; // r11
  int v69; // r5
  int *v70; // r0
  signed int v71; // r7
  _DWORD *v72; // r0
  signed int v73; // r3
  unsigned int v74; // r3
  _DWORD *v75; // r3
  unsigned int v76; // r2
  int v77; // r0
  int *v78; // r3
  int v79; // r0
  int v80; // r5
  unsigned int i; // r4
  int v82; // r0
  int v83; // t1
  unsigned int *v84; // r3
  signed int v85; // r1
  int v86; // [sp+10h] [bp-78h]
  int v87; // [sp+14h] [bp-74h]
  signed int v88; // [sp+20h] [bp-68h]
  unsigned int v89; // [sp+28h] [bp-60h]
  char v90; // [sp+2Ch] [bp-5Ch]
  signed int v91; // [sp+30h] [bp-58h]
  int **v92; // [sp+34h] [bp-54h]
  _BOOL4 v93; // [sp+3Ch] [bp-4Ch]
  int *v94; // [sp+40h] [bp-48h]
  wchar_t c[2]; // [sp+44h] [bp-44h]
  char v96; // [sp+4Ch] [bp-3Ch]
  _DWORD *v97; // [sp+54h] [bp-34h]
  char *v98; // [sp+58h] [bp-30h]
  int v99; // [sp+5Ch] [bp-2Ch]

  v92 = a1;
  v9 = a7 + 27;
  v94 = a3;
  *(_DWORD *)c = a4;
  v10 = sub_ADE94((int)(a7 + 27));
  v11 = sub_B07E4((int)&v96, v9);
  v12 = v11;
  v87 = v11 + 64;
  if ( *(_DWORD *)(v11 + 40) )
    v93 = *(_DWORD *)(v11 + 48) != 0;
  else
    v93 = 0;
  v13 = *(unsigned __int8 *)(v11 + 16);
  v97 = &unk_2FEF48;
  if ( v13 )
    sub_C1264(&v97, 0x20u);
  v98 = (char *)&unk_2FEF48;
  sub_C1264(&v98, 0x20u);
  v14 = 0;
  v86 = 0;
  v88 = 0;
  v90 = 0;
  v99 = *(_DWORD *)(v12 + 60);
  v89 = 0;
  v91 = 0;
  while ( 2 )
  {
    switch ( *((unsigned __int8 *)&v99 + v86) )
    {
      case 0u:
        goto LABEL_9;
      case 1u:
        if ( sub_B12DC(&v94, (int)&a5)
          || (v15 = sub_B12A4(&v94), !(*(int (__fastcall **)(int, signed int, int))(*(_DWORD *)v10 + 8))(v10, 8, v15)) )
        {
          v16 = v86;
          v17 = 0;
          if ( v86 != 3 )
            goto LABEL_10;
        }
        else
        {
          sub_B088C(&v94);
LABEL_9:
          v16 = v86;
          v17 = 1;
          if ( v86 != 3 )
          {
LABEL_10:
            v18 = v94;
            if ( v94 )
            {
LABEL_11:
              if ( *(_DWORD *)c == -1 )
              {
                v51 = (int **)v18[2];
                if ( (unsigned int)v51 >= v18[3] )
                  v52 = (int *)(*(int (**)(void))(*v18 + 36))();
                else
                  v52 = *v51;
                v53 = (int *)((char *)v52 + 1) == 0;
                if ( v52 == (int *)-1 )
                  v52 = 0;
                else
                  *(_DWORD *)c = v52;
                if ( v53 )
                {
                  v94 = v52;
                  v19 = 1;
                }
                else
                {
                  v19 = 0;
                }
              }
              else
              {
                v19 = 0;
              }
LABEL_14:
              v20 = a5;
              if ( !a5 )
                goto LABEL_104;
            }
            else
            {
              while ( 1 )
              {
                v20 = a5;
                v19 = 1;
                if ( a5 )
                  break;
LABEL_104:
                v21 = 1;
LABEL_18:
                if ( v21 == v19 )
                  goto LABEL_19;
                if ( v94 && *(_DWORD *)c == -1 )
                {
                  v66 = (int *)v94[2];
                  if ( (unsigned int)v66 >= v94[3] )
                    v67 = (*(int (**)(void))(*v94 + 36))();
                  else
                    v67 = *v66;
                  if ( v67 == -1 )
                    v94 = 0;
                  else
                    *(_DWORD *)c = v67;
                }
                v19 = (*(int (__fastcall **)(int, signed int))(*(_DWORD *)v10 + 8))(v10, 8);
                if ( !v19 )
                  goto LABEL_19;
                v18 = v94;
                if ( !v94 )
                  goto LABEL_14;
                v48 = v94[2];
                if ( v48 >= v94[3] )
                {
                  (*(void (**)(void))(*v94 + 40))();
                  v18 = v94;
                }
                else
                {
                  v94[2] = v48 + 4;
                }
                *(_DWORD *)c = -1;
                if ( v18 )
                  goto LABEL_11;
              }
            }
            if ( a6 == -1 )
            {
              v49 = (int *)v20[2];
              if ( (unsigned int)v49 >= v20[3] )
                v50 = (*(int (**)(void))(*v20 + 36))();
              else
                v50 = *v49;
              if ( v50 == -1 )
                v16 = 0;
              else
                a6 = v50;
              if ( v50 == -1 )
              {
                a5 = (_DWORD *)v16;
                v21 = 1;
              }
              else
              {
                v21 = 0;
              }
            }
            else
            {
              v21 = 0;
            }
            goto LABEL_18;
          }
        }
LABEL_63:
        if ( v89 > 1 )
          v42 = v17 & 1;
        else
          v42 = 0;
        if ( v42 )
        {
          if ( v91 )
            v80 = *(_DWORD *)(v12 + 44);
          else
            v80 = *(_DWORD *)(v12 + 36);
          for ( i = 1; !sub_B12DC(&v94, (int)&a5) && i < v89; ++i )
          {
            v82 = sub_B12A4(&v94);
            v83 = *(_DWORD *)(v80 + 4);
            v80 += 4;
            if ( v83 != v82 )
              goto LABEL_49;
            sub_B088C(&v94);
          }
          if ( i != v89 )
            goto LABEL_49;
        }
        else if ( !v17 )
        {
LABEL_49:
          *a8 |= 4u;
          goto LABEL_50;
        }
        if ( *((_DWORD *)v98 - 3) > 1u )
        {
          v43 = sub_C0768((int *)&v98, 48, 0);
          if ( v43 )
          {
            v45 = (_DWORD *)(v43 + 1);
            if ( v43 == -1 )
              v45 = v98;
            else
              v44 = v43;
            if ( v43 == -1 )
              v44 = *(v45 - 3) - 1;
            sub_C0D44((int *)&v98, 0, v44);
          }
        }
        if ( v91 )
        {
          v46 = v98;
          if ( *((_DWORD *)v98 - 1) >= 0 )
          {
            sub_C0BF4((int *)&v98);
            v46 = v98;
          }
          if ( *v46 != 48 )
          {
            if ( *((_DWORD *)v46 - 1) >= 0 )
              sub_C0BF4((int *)&v98);
            sub_C0DB8((int *)&v98, 0, 0, 1u, 0x2Du);
            *((_DWORD *)v98 - 1) = -1;
          }
        }
        if ( *(v97 - 3) )
        {
          v47 = v14;
          if ( v88 )
            v47 = v90;
          sub_C15D0((int *)&v97, v47);
          if ( !sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v97) )
            *a8 |= 4u;
        }
        if ( v88 && *(_DWORD *)(v12 + 52) != v14 )
          goto LABEL_49;
        sub_C0480(a9, (int *)&v98);
LABEL_50:
        if ( sub_B12DC(&v94, (int)&a5) )
          *a8 |= 2u;
        v36 = v98;
        v37 = *(_DWORD *)c;
        v38 = (int *)(v98 - 12);
        *v92 = v94;
        v92[1] = (int *)v37;
        if ( v38 != &dword_2FEF3C )
        {
          v84 = (unsigned int *)(v36 - 4);
          __dmb(0xFu);
          do
            v85 = __ldrex(v84);
          while ( __strex(v85 - 1, v84) );
          __dmb(0xFu);
          if ( v85 <= 0 )
            operator delete(v38);
        }
        sub_C0AC4(v97 - 3);
        return v92;
      case 2u:
        v40 = a7;
        if ( a7[3] & 0x200 )
          goto LABEL_173;
        v41 = v86 == 0;
        if ( v89 > 1 )
          v41 = 1;
        if ( v41 )
          goto LABEL_173;
        if ( v86 == 1 )
        {
          v40 = (int *)v93;
          if ( v93 || (unsigned __int8)v99 == 3 )
            goto LABEL_173;
          if ( BYTE2(v99) == 1 )
          {
            v68 = *(_DWORD *)(v12 + 32);
            v69 = 0;
            v70 = v94;
            goto LABEL_174;
          }
          v22 = 2;
        }
        else
        {
          if ( v86 != 2 )
            goto def_B2CBE;
          if ( HIBYTE(v99) == 4 || v93 && HIBYTE(v99) == 3 )
          {
LABEL_173:
            v68 = *(_DWORD *)(v12 + 32);
            v69 = 0;
            v70 = v94;
LABEL_174:
            if ( v70 )
              goto LABEL_175;
LABEL_193:
            v72 = a5;
            v71 = 1;
            if ( a5 )
            {
              while ( 1 )
              {
                if ( a6 == -1 )
                {
                  v75 = (_DWORD *)v72[2];
                  v76 = v72[3];
                  v77 = (unsigned int)v75 >= v76 ? (*(int (**)(void))(*v72 + 36))() : *v75;
                  if ( v77 == -1 )
                    v76 = 0;
                  else
                    a6 = v77;
                  if ( v77 == -1 )
                  {
                    a5 = (_DWORD *)v76;
                    v73 = 1;
                  }
                  else
                  {
                    v73 = 0;
                  }
                }
                else
                {
                  v73 = 0;
                }
                if ( v71 == v73 )
                  break;
LABEL_183:
                if ( v69 == v68 )
                  goto def_B2CBE;
                if ( *(_DWORD *)(*(_DWORD *)(v12 + 28) + 4 * v69) != sub_B12A4(&v94) )
                  goto LABEL_185;
                v70 = v94;
                if ( v94 )
                {
                  v74 = v94[2];
                  if ( v74 >= v94[3] )
                  {
                    (*(void (**)(void))(*v94 + 40))();
                    v70 = v94;
                  }
                  else
                  {
                    v94[2] = v74 + 4;
                  }
                  *(_DWORD *)c = -1;
                }
                ++v69;
                if ( !v70 )
                  goto LABEL_193;
LABEL_175:
                if ( *(_DWORD *)c == -1 )
                {
                  v78 = (int *)v70[2];
                  if ( (unsigned int)v78 >= v70[3] )
                    v79 = (*(int (**)(void))(*v70 + 36))();
                  else
                    v79 = *v78;
                  if ( v79 == -1 )
                    v40 = 0;
                  else
                    *(_DWORD *)c = v79;
                  if ( v79 == -1 )
                  {
                    v94 = v40;
                    v71 = 1;
                  }
                  else
                  {
                    v71 = 0;
                  }
                }
                else
                {
                  v71 = 0;
                }
                v72 = a5;
                if ( !a5 )
                  goto LABEL_194;
              }
            }
            else
            {
LABEL_194:
              if ( v71 != 1 )
                goto LABEL_183;
            }
            if ( v69 != v68 )
            {
LABEL_185:
              if ( v69 || a7[3] & 0x200 )
                goto LABEL_49;
            }
def_B2CBE:
            v17 = 1;
            goto LABEL_19;
          }
          v22 = 3;
        }
        goto LABEL_23;
      case 3u:
        if ( *(_DWORD *)(v12 + 40) && !sub_B12DC(&v94, (int)&a5) && **(_DWORD **)(v12 + 36) == sub_B12A4(&v94) )
        {
          v89 = *(_DWORD *)(v12 + 40);
          sub_B088C(&v94);
          goto def_B2CBE;
        }
        if ( !*(_DWORD *)(v12 + 48) || sub_B12DC(&v94, (int)&a5) || **(_DWORD **)(v12 + 44) != sub_B12A4(&v94) )
        {
          if ( !*(_DWORD *)(v12 + 40) || *(_DWORD *)(v12 + 48) )
          {
            v17 = !v93;
          }
          else
          {
            v91 = 1;
            v17 = 1;
          }
        }
        else
        {
          v89 = *(_DWORD *)(v12 + 48);
          sub_B088C(&v94);
          v17 = 1;
          v91 = 1;
        }
        goto LABEL_19;
      case 4u:
        v24 = v94;
        if ( v94 )
          goto LABEL_25;
        while ( 2 )
        {
          v26 = a5;
          v25 = 1;
          if ( !a5 )
            goto LABEL_46;
LABEL_29:
          if ( a6 == -1 )
          {
            v60 = (int *)v26[2];
            if ( (unsigned int)v60 >= v26[3] )
              v61 = (*(int (**)(void))(*v26 + 36))();
            else
              v61 = *v60;
            v62 = v61 == -1;
            if ( v61 == -1 )
              v61 = 0;
            else
              a6 = v61;
            if ( v62 )
            {
              a5 = (_DWORD *)v61;
              v27 = 1;
            }
            else
            {
              v27 = 0;
            }
          }
          else
          {
            v27 = 0;
          }
          if ( v27 == v25 )
            goto LABEL_47;
LABEL_33:
          if ( v94 )
          {
            v28 = *(_DWORD *)c;
            if ( *(_DWORD *)c == -1 )
            {
              v65 = (int *)v94[2];
              if ( (unsigned int)v65 >= v94[3] )
                v28 = (*(int (**)(void))(*v94 + 36))();
              else
                v28 = *v65;
              if ( v28 == -1 )
                v94 = 0;
              else
                *(_DWORD *)c = v28;
            }
          }
          else
          {
            v28 = -1;
          }
          v29 = wmemchr((const wchar_t *)(v12 + 68), v28, 0xAu);
          if ( v29 )
          {
            v30 = v98;
            v31 = *((_DWORD *)v98 - 3);
            v32 = v31 + 1;
            v33 = off_F3C5C[0][((signed int)v29 - v87) >> 2];
            if ( (unsigned int)(v31 + 1) > *((_DWORD *)v98 - 2) || *((_DWORD *)v98 - 1) > 0 )
            {
              sub_C1264(&v98, v31 + 1);
              v30 = v98;
              v31 = *((_DWORD *)v98 - 3);
            }
            v30[v31] = v33;
            ++v14;
            v34 = v98;
            if ( v98 - 12 != (char *)&dword_2FEF3C )
            {
              *((_DWORD *)v98 - 3) = v32;
              *(v34 - 1) = 0;
              *((_BYTE *)v34 + v32) = 0;
            }
            goto LABEL_41;
          }
          if ( *(_DWORD *)(v12 + 20) == v28 && !v88 )
          {
            if ( *(_DWORD *)(v12 + 52) <= 0 )
              goto LABEL_47;
            v90 = v14;
            v14 = 0;
            v88 = 1;
LABEL_41:
            v24 = v94;
            if ( !v94 )
              continue;
            v35 = v94[2];
            if ( v35 >= v94[3] )
            {
              (*(void (**)(void))(*v94 + 40))();
              v24 = v94;
            }
            else
            {
              v94[2] = v35 + 4;
            }
            *(_DWORD *)c = -1;
            if ( !v24 )
              continue;
LABEL_25:
            if ( *(_DWORD *)c == -1 )
            {
              v63 = (int *)v24[2];
              if ( (unsigned int)v63 >= v24[3] )
                v64 = (*(int (**)(void))(*v24 + 36))();
              else
                v64 = *v63;
              if ( v64 == -1 )
                v63 = 0;
              else
                *(_DWORD *)c = v64;
              if ( v64 == -1 )
              {
                v94 = v63;
                v25 = 1;
              }
              else
              {
                v25 = 0;
              }
            }
            else
            {
              v25 = 0;
            }
            v26 = a5;
            if ( !a5 )
            {
LABEL_46:
              if ( v25 != 1 )
                goto LABEL_33;
LABEL_47:
              v17 = 1;
              goto LABEL_48;
            }
            goto LABEL_29;
          }
          break;
        }
        if ( !*(_BYTE *)(v12 + 16) || *(_DWORD *)(v12 + 24) != v28 || v88 )
          goto LABEL_47;
        if ( v14 )
        {
          v54 = v97;
          v14 = (unsigned __int8)v14;
          v55 = *(v97 - 3);
          v56 = v55 + 1;
          if ( (unsigned int)(v55 + 1) > *(v97 - 2) || *(v97 - 1) > 0 )
          {
            sub_C1264(&v97, v55 + 1);
            v54 = v97;
            v55 = *(v97 - 3);
          }
          v54[v55] = v14;
          v57 = v97;
          v58 = (int)(v97 - 3);
          v59 = v97 - 3 == &dword_2FEF3C;
          if ( v97 - 3 == &dword_2FEF3C )
          {
            v14 = 0;
          }
          else
          {
            *(v97 - 3) = v56;
            v58 = 0;
          }
          if ( !v59 )
          {
            *(v57 - 1) = v58;
            v14 = v58;
            *((_BYTE *)v57 + v56) = v58;
          }
          goto LABEL_41;
        }
        v17 = 0;
LABEL_48:
        if ( !*((_DWORD *)v98 - 3) )
          goto LABEL_49;
LABEL_19:
        v22 = v86 + 1;
        if ( v86 + 1 <= 3 )
          v23 = v17 & 1;
        else
          v23 = 0;
        if ( !v23 )
          goto LABEL_63;
LABEL_23:
        v86 = v22;
        continue;
      default:
        goto def_B2CBE;
    }
  }
}
// F3C5C: using guessed type char *off_F3C5C[15];
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B33A8) --------------------------------------------------------
int **__fastcall sub_B33A8(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, char a7, int *a8, _DWORD *a9, double *a10)
{
  int **v10; // r5
  const char *v11; // r10
  const char *v12; // r2
  int v13; // r1
  char *v14; // r3
  bool v15; // zf
  unsigned int *v17; // r2
  signed int v18; // r1
  int *v19; // [sp+18h] [bp-38h]
  int v20; // [sp+1Ch] [bp-34h]
  int *v21; // [sp+20h] [bp-30h]
  int v22; // [sp+24h] [bp-2Ch]
  const char *v23; // [sp+28h] [bp-28h]
  int v24; // [sp+2Ch] [bp-24h]

  v10 = a1;
  v21 = a3;
  v22 = a4;
  v23 = (const char *)&unk_2FEF48;
  if ( a7 )
    sub_B2C08(&v19, a2, a3, a4, a5, a6, a8, a9, (int *)&v23);
  else
    sub_B2484(&v19, a2, a3, a4, a5, a6, (int)a8, a9, (int *)&v23);
  v11 = v23;
  v21 = v19;
  v22 = v20;
  v24 = sub_AB4B8();
  std::__convert_to_v<long double>(v11, a10, a9);
  v12 = v23;
  v13 = v22;
  v14 = (char *)(v23 - 12);
  v15 = v23 - 12 == (const char *)&dword_2FEF3C;
  *v10 = v21;
  v10[1] = (int *)v13;
  if ( !v15 )
  {
    v17 = (unsigned int *)(v12 - 4);
    __dmb(0xFu);
    do
      v18 = __ldrex(v17);
    while ( __strex(v18 - 1, v17) );
    __dmb(0xFu);
    if ( v18 <= 0 )
      operator delete(v14);
  }
  return v10;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3470) --------------------------------------------------------
int **__fastcall sub_B3470(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, char a7, int *a8, _DWORD *a9, int *a10)
{
  int **v10; // r5
  int v11; // r7
  int v12; // r10
  char *v13; // r3
  size_t v14; // r7
  int v15; // r3
  void *v16; // r8
  int v17; // r7
  int v18; // r1
  char *v19; // r2
  unsigned int *v21; // r3
  signed int v22; // r1
  int *v23; // [sp+18h] [bp-40h]
  int v24; // [sp+1Ch] [bp-3Ch]
  int *v25; // [sp+20h] [bp-38h]
  int v26; // [sp+24h] [bp-34h]
  char *v27; // [sp+2Ch] [bp-2Ch]

  v10 = a1;
  v11 = a2;
  v25 = a3;
  v26 = a4;
  v27 = (char *)&unk_2FEF48;
  v12 = sub_ADE94((int)(a8 + 27));
  if ( a7 )
    sub_B2C08(&v23, v11, v25, v26, a5, a6, a8, a9, (int *)&v27);
  else
    sub_B2484(&v23, v11, v25, v26, a5, a6, (int)a8, a9, (int *)&v27);
  v13 = v27;
  v14 = *((_DWORD *)v27 - 3);
  v25 = v23;
  v26 = v24;
  if ( v14 )
  {
    sub_BA8D8(a10, v14, 0);
    v15 = *a10;
    v16 = v27;
    v17 = (int)&v27[v14];
    if ( *(_DWORD *)(*a10 - 4) >= 0 )
    {
      sub_B9F10((const wchar_t **)a10);
      v15 = *a10;
    }
    (*(void (__fastcall **)(int, void *, int, int))(*(_DWORD *)v12 + 44))(v12, v16, v17, v15);
    v13 = v27;
  }
  v18 = v26;
  v19 = v13 - 12;
  *v10 = v25;
  v10[1] = (int *)v18;
  if ( v13 - 12 != (char *)&dword_2FEF3C )
  {
    v21 = (unsigned int *)(v13 - 4);
    __dmb(0xFu);
    do
      v22 = __ldrex(v21);
    while ( __strex(v22 - 1, v21) );
    __dmb(0xFu);
    if ( v22 <= 0 )
      operator delete(v19);
  }
  return v10;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3588) --------------------------------------------------------
int **__fastcall sub_B3588(int **a1, int a2, int *a3, int a4, int *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int v9; // r4
  int *v10; // r6
  int v11; // r5
  _BOOL4 v12; // r8
  signed int v13; // r2
  int v14; // r11
  signed int v15; // r7
  int v16; // r9
  char v17; // r9
  int v18; // r3
  int v19; // r2
  int v20; // r3
  int *v21; // r0
  unsigned int v22; // r3
  int *v23; // r3
  int v24; // r0
  bool v25; // zf
  int *v26; // r0
  signed int v27; // r3
  unsigned int v28; // r3
  int v29; // r0
  char v30; // r1
  int v31; // r3
  int *v32; // r1
  int *v33; // r0
  unsigned int v34; // r3
  int *v35; // r3
  int v36; // r0
  bool v37; // zf
  int *v38; // r0
  int v39; // r3
  unsigned int *v40; // r4
  int v41; // r1
  wchar_t *v43; // r0
  int *v44; // r3
  int v45; // r0
  int *v46; // r3
  int *v47; // r2
  int v48; // r0
  _DWORD **v49; // r0
  int v50; // r0
  unsigned int v51; // r0
  char v52; // r1
  int v53; // r0
  int v54; // r3
  char v55; // r1
  int v56; // ST04_4
  _DWORD **v57; // r0
  int v58; // r0
  int v59; // r0
  int *v60; // r0
  unsigned int v61; // r2
  int *v62; // r1
  int v63; // r0
  signed int v64; // r7
  signed int v65; // r3
  int *v66; // r2
  int v67; // r0
  wchar_t *s; // [sp+8h] [bp-50h]
  signed int v69; // [sp+Ch] [bp-4Ch]
  int **v70; // [sp+10h] [bp-48h]
  int *v71; // [sp+18h] [bp-40h]
  int v72; // [sp+1Ch] [bp-3Ch]
  char v73; // [sp+24h] [bp-34h]
  unsigned int *v74; // [sp+2Ch] [bp-2Ch]

  v9 = 0;
  v70 = a1;
  v71 = a3;
  v72 = a4;
  v10 = a9;
  v11 = sub_B095C((int)&v73, (int *)(a7 + 108));
  v12 = sub_B12DC(&v71, (int)&a5);
  if ( v12 )
  {
LABEL_2:
    v13 = *(unsigned __int8 *)(v11 + 16);
    v14 = 0;
    v15 = 0;
    v12 = 1;
    goto LABEL_3;
  }
  v53 = sub_B12A4(&v71);
  v54 = v53;
  if ( (unsigned int)(*(_DWORD *)(v11 + 192) - v53) <= 0 || *(_DWORD *)(v11 + 188) == v53 )
  {
    v13 = *(unsigned __int8 *)(v11 + 16);
    if ( *(_BYTE *)(v11 + 16) && *(_DWORD *)(v11 + 40) == v53 )
    {
      v13 = 1;
    }
    else if ( *(_DWORD *)(v11 + 36) != v53 )
    {
      if ( (unsigned int)(*(_DWORD *)(v11 + 192) - v53) <= 0 )
        v55 = 43;
      else
        v55 = 45;
      v56 = v53;
      sub_C15D0(v10, v55);
      v57 = sub_B088C(&v71);
      v9 = v56;
      if ( sub_B12DC(v57, (int)&a5) )
        goto LABEL_2;
      v58 = sub_B12A4(&v71);
      v13 = *(unsigned __int8 *)(v11 + 16);
      v54 = v58;
    }
  }
  else
  {
    v13 = *(unsigned __int8 *)(v11 + 16);
  }
  v14 = 0;
  v15 = 0;
  v59 = v54;
  while ( 1 )
  {
    if ( v13 && *(_DWORD *)(v11 + 40) == v59 )
    {
      v9 = v59;
      v74 = (unsigned int *)&unk_2FEF48;
      goto LABEL_129;
    }
    if ( *(_DWORD *)(v11 + 36) == v59 )
      break;
    v9 = *(_DWORD *)(v11 + 204);
    if ( v9 != v59 )
      break;
    if ( !v15 )
      sub_C15D0(v10, 48);
    v60 = v71;
    ++v14;
    if ( !v71 )
    {
LABEL_167:
      v64 = 1;
      goto LABEL_158;
    }
    v61 = v71[2];
    if ( v61 >= v71[3] )
    {
      (*(void (**)(void))(*v71 + 40))();
      v60 = v71;
      v72 = -1;
      if ( !v71 )
        goto LABEL_167;
    }
    else
    {
      v72 = -1;
      v71[2] = v61 + 4;
    }
    v62 = (int *)v60[2];
    if ( (unsigned int)v62 >= v60[3] )
      v63 = (*(int (**)(void))(*v60 + 36))();
    else
      v63 = *v62;
    if ( v63 == -1 )
    {
      v64 = 1;
      v71 = 0;
    }
    else
    {
      v72 = v63;
      v64 = 0;
    }
LABEL_158:
    v65 = 1;
    if ( a5 )
    {
      if ( a6 == -1 )
      {
        v66 = (int *)a5[2];
        if ( (unsigned int)v66 >= a5[3] )
          v67 = (*(int (**)(void))(*a5 + 36))();
        else
          v67 = *v66;
        if ( v67 == -1 )
          v66 = 0;
        else
          a6 = v67;
        if ( v67 == -1 )
        {
          a5 = v66;
          v65 = 1;
        }
        else
        {
          v65 = 0;
        }
      }
      else
      {
        v65 = 0;
      }
    }
    if ( v65 == v64 )
    {
      v12 = 1;
      v13 = *(unsigned __int8 *)(v11 + 16);
      v15 = 1;
      goto LABEL_3;
    }
    v15 = 1;
    v59 = sub_B12A4(&v71);
    v13 = *(unsigned __int8 *)(v11 + 16);
  }
  v9 = v59;
LABEL_3:
  v74 = (unsigned int *)&unk_2FEF48;
  if ( v13 )
LABEL_129:
    sub_C1264(&v74, 0x20u);
  v16 = *(unsigned __int8 *)(v11 + 292);
  if ( !*(_BYTE *)(v11 + 292) )
  {
    if ( !v12 )
    {
      v69 = 0;
      while ( 2 )
      {
        v17 = v9 - 48;
        if ( (unsigned int)(v9 - 48) <= 9 )
        {
LABEL_8:
          v18 = *v10;
          v19 = *(_DWORD *)(*v10 - 12);
          v9 = v19 + 1;
          if ( (unsigned int)(v19 + 1) > *(_DWORD *)(*v10 - 8) || *(_DWORD *)(v18 - 4) > 0 )
          {
            sub_C1264(v10, v19 + 1);
            v18 = *v10;
            v19 = *(_DWORD *)(*v10 - 12);
          }
          *(_BYTE *)(v18 + v19) = v17 + 48;
          v20 = *v10;
          if ( (int *)(*v10 - 12) == &dword_2FEF3C )
          {
            v15 = 1;
          }
          else
          {
            *(_DWORD *)(v20 - 12) = v9;
            *(_DWORD *)(v20 - 4) = 0;
            v15 = 1;
            *(_BYTE *)(v20 + v9) = 0;
          }
          break;
        }
LABEL_32:
        if ( *(_DWORD *)(v11 + 36) == v9 && (v69 ^ 1) & !v12 & 0xFF )
        {
          sub_C15D0(v10, 46);
          v9 = 1;
          v12 = 0;
          v69 = 1;
        }
        else
        {
          if ( *(_DWORD *)(v11 + 260) != v9 && *(_DWORD *)(v11 + 284) != v9 || !(v15 & !v12) )
            goto LABEL_71;
          sub_C15D0(v10, 101);
          if ( v71 )
          {
            v28 = v71[2];
            if ( v28 >= v71[3] )
              (*(void (**)(void))(*v71 + 40))();
            else
              v71[2] = v28 + 4;
            v72 = -1;
          }
          if ( sub_B12DC(&v71, (int)&a5) )
            goto LABEL_180;
          v29 = sub_B12A4(&v71);
          v9 = v29;
          if ( *(_DWORD *)(v11 + 192) == v29 )
          {
            v30 = 43;
          }
          else
          {
            if ( *(_DWORD *)(v11 + 188) != v29 )
            {
              v12 = 1;
              v15 = 1;
              continue;
            }
            v30 = 45;
          }
          sub_C15D0(v10, v30);
          v12 = 1;
          v15 = 1;
        }
        break;
      }
      v21 = v71;
      if ( !v71 )
        goto LABEL_191;
      v22 = v71[2];
      if ( v22 < v71[3] )
      {
        v71[2] = v22 + 4;
        v72 = -1;
        goto LABEL_17;
      }
      (*(void (**)(void))(*v71 + 40))();
      v21 = v71;
      v72 = -1;
      if ( v71 )
      {
LABEL_17:
        v23 = (int *)v21[2];
        if ( (unsigned int)v23 >= v21[3] )
          v24 = (*(int (**)(void))(*v21 + 36))();
        else
          v24 = *v23;
        v25 = v24 == -1;
        if ( v24 != -1 )
          v72 = v24;
        v26 = a5;
        if ( v25 )
          v23 = 0;
        else
          v9 = 0;
        if ( v25 )
        {
          v9 = 1;
          v71 = v23;
        }
        if ( a5 )
          goto LABEL_27;
LABEL_83:
        v27 = 1;
      }
      else
      {
LABEL_191:
        v26 = a5;
        v9 = 1;
        if ( !a5 )
          goto LABEL_83;
LABEL_27:
        if ( a6 == -1 )
        {
          v46 = (int *)v26[2];
          v47 = (int *)v26[3];
          if ( v46 >= v47 )
            v48 = (*(int (**)(void))(*v26 + 36))();
          else
            v48 = *v46;
          if ( v48 == -1 )
            v47 = 0;
          else
            a6 = v48;
          if ( v48 == -1 )
          {
            v27 = 1;
            a5 = v47;
          }
          else
          {
            v27 = 0;
          }
        }
        else
        {
          v27 = 0;
        }
      }
      if ( v27 == v9 )
        goto LABEL_71;
      v9 = sub_B12A4(&v71);
      v17 = v9 - 48;
      if ( (unsigned int)(v9 - 48) <= 9 )
        goto LABEL_8;
      goto LABEL_32;
    }
LABEL_165:
    v12 = 0;
    v69 = 0;
    goto LABEL_71;
  }
  if ( v12 )
    goto LABEL_165;
  s = (wchar_t *)(v11 + 204);
  v31 = *(unsigned __int8 *)(v11 + 16);
  v69 = 0;
  while ( 2 )
  {
    if ( !v31 )
      goto LABEL_49;
LABEL_48:
    if ( v9 == *(_DWORD *)(v11 + 40) )
    {
      v9 = v69;
      if ( !(!v12 & (v69 ^ 1) & 0xFF) )
        goto LABEL_71;
      if ( !v14 )
      {
        sub_C0AFC(v10, 0, *(_DWORD *)(*v10 - 12), 0);
        goto LABEL_165;
      }
      sub_C15D0((int *)&v74, v14);
      v12 = 0;
      v69 = 0;
      v14 = 0;
      goto LABEL_54;
    }
LABEL_49:
    if ( v9 == *(_DWORD *)(v11 + 36) )
    {
      if ( !(!v12 & (v69 ^ 1) & 0xFF) )
        goto LABEL_71;
      if ( *(v74 - 3) )
        sub_C15D0((int *)&v74, v14);
      sub_C15D0(v10, 46);
      v12 = 0;
      v9 = 1;
      v69 = 1;
      goto LABEL_54;
    }
    v43 = wmemchr(s, v9, 0xAu);
    if ( v43 )
    {
      v9 = v11 + 204;
      sub_C15D0(v10, (((char *)v43 - (char *)s) >> 2) + 48);
      ++v14;
      v15 = 1;
      goto LABEL_54;
    }
    if ( v9 != *(_DWORD *)(v11 + 260) && v9 != *(_DWORD *)(v11 + 284) || !(v15 & !v12) )
      goto LABEL_71;
    if ( *(v74 - 3) && !v69 )
      sub_C15D0((int *)&v74, v14);
    sub_C15D0(v10, 101);
    v49 = sub_B088C(&v71);
    if ( !sub_B12DC(v49, (int)&a5) )
    {
      v50 = sub_B12A4(&v71);
      v9 = v50;
      v51 = *(_DWORD *)(v11 + 192) - v50;
      if ( v51 > 0 && *(_DWORD *)(v11 + 188) != v9 )
      {
        v12 = 1;
        v31 = *(unsigned __int8 *)(v11 + 16);
        v15 = 1;
        continue;
      }
      v31 = *(unsigned __int8 *)(v11 + 16);
      if ( *(_BYTE *)(v11 + 16) && *(_DWORD *)(v11 + 40) == v9 )
      {
        v12 = 1;
        v15 = 1;
        goto LABEL_48;
      }
      if ( *(_DWORD *)(v11 + 36) == v9 )
      {
        v12 = 1;
        v15 = 1;
        continue;
      }
      if ( v51 <= 0 )
        v52 = 43;
      else
        v52 = 45;
      sub_C15D0(v10, v52);
      v12 = 1;
      v15 = 1;
LABEL_54:
      v33 = v71;
      if ( !v71 )
        goto LABEL_192;
      v34 = v71[2];
      if ( v34 < v71[3] )
      {
        v32 = (int *)-1;
        v71[2] = v34 + 4;
        v72 = -1;
        goto LABEL_57;
      }
      (*(void (**)(void))(*v71 + 40))();
      v33 = v71;
      v72 = -1;
      if ( v71 )
      {
LABEL_57:
        v35 = (int *)v33[2];
        if ( (unsigned int)v35 >= v33[3] )
          v36 = (*(int (**)(void))(*v33 + 36))();
        else
          v36 = *v35;
        v37 = v36 == -1;
        if ( v36 != -1 )
          v72 = v36;
        v38 = a5;
        if ( v37 )
          v35 = 0;
        else
          v9 = 0;
        if ( v37 )
        {
          v9 = v16;
          v71 = v35;
        }
        if ( !a5 )
          goto LABEL_79;
      }
      else
      {
LABEL_192:
        v38 = a5;
        v9 = v16;
        if ( !a5 )
        {
LABEL_79:
          if ( v9 == v16 )
            goto LABEL_71;
LABEL_80:
          v9 = sub_B12A4(&v71);
          v31 = *(unsigned __int8 *)(v11 + 16);
          continue;
        }
      }
      if ( a6 == -1 )
      {
        v44 = (int *)v38[2];
        if ( (unsigned int)v44 >= v38[3] )
          v45 = (*(int (**)(void))(*v38 + 36))();
        else
          v45 = *v44;
        if ( v45 == -1 )
          v32 = 0;
        else
          a6 = v45;
        if ( v45 == -1 )
        {
          a5 = v32;
          v39 = v16;
        }
        else
        {
          v39 = 0;
        }
      }
      else
      {
        v39 = 0;
      }
      if ( v9 == v39 )
        goto LABEL_71;
      goto LABEL_80;
    }
    break;
  }
LABEL_180:
  v12 = 1;
LABEL_71:
  v40 = v74;
  if ( *(v74 - 3) )
  {
    if ( !v12 & (v69 ^ 1) & 0xFF )
    {
      sub_C15D0((int *)&v74, v14);
      v40 = v74;
    }
    if ( !sub_C303C(*(_DWORD *)(v11 + 8), *(_DWORD *)(v11 + 12), (unsigned __int8 **)&v74) )
      *a8 = 4;
  }
  v41 = v72;
  *v70 = v71;
  v70[1] = (int *)v41;
  sub_C0AC4(v40 - 3);
  return v70;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3BA8) --------------------------------------------------------
int **__fastcall sub_B3BA8(int **a1, int a2, int *a3, int a4, int *a5, int a6, int a7, signed int *a8, float *a9)
{
  int **v9; // r6
  int v10; // r11
  const char *v11; // r8
  int *v12; // r0
  signed int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  int *v19; // r3
  int v20; // r0
  int *v21; // r3
  int v22; // r0
  bool v23; // zf
  unsigned int *v24; // r2
  signed int v25; // r1
  int *v26; // [sp+18h] [bp-40h]
  int v27; // [sp+1Ch] [bp-3Ch]
  int *v28; // [sp+20h] [bp-38h]
  int v29; // [sp+24h] [bp-34h]
  const char *v30; // [sp+28h] [bp-30h]
  int v31; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v30 = (const char *)&unk_2FEF48;
  v28 = a3;
  v29 = a4;
  sub_C1264(&v30, 0x20u);
  sub_B3588(&v26, v10, v28, v29, a5, a6, a7, a8, (int *)&v30);
  v11 = v30;
  v28 = v26;
  v29 = v27;
  v31 = sub_AB4B8();
  std::__convert_to_v<float>(v11, a9, a8);
  if ( v28 )
  {
    if ( v29 == -1 )
    {
      v21 = (int *)v28[2];
      if ( (unsigned int)v21 >= v28[3] )
        v22 = (*(int (**)(void))(*v28 + 36))();
      else
        v22 = *v21;
      v23 = v22 == -1;
      if ( v22 != -1 )
        v29 = v22;
      v12 = a5;
      if ( v23 )
        v21 = 0;
      else
        v11 = 0;
      if ( v23 )
      {
        v11 = (_BYTE *)(&dword_0 + 1);
        v28 = v21;
      }
      if ( a5 )
        goto LABEL_6;
LABEL_28:
      v13 = 1;
      goto LABEL_9;
    }
    v11 = 0;
  }
  else
  {
    v11 = (_BYTE *)(&dword_0 + 1);
  }
  v12 = a5;
  if ( !a5 )
    goto LABEL_28;
LABEL_6:
  if ( a6 == -1 )
  {
    v19 = (int *)v12[2];
    if ( (unsigned int)v19 >= v12[3] )
      v20 = (*(int (**)(void))(*v12 + 36))();
    else
      v20 = *v19;
    v13 = (unsigned int)(v20 + 1) <= 0;
  }
  else
  {
    v13 = 0;
  }
LABEL_9:
  v14 = v11 == (const char *)v13;
  v15 = v30;
  v16 = v29;
  if ( v11 == (const char *)v13 )
    v13 = *a8 | 2;
  *v9 = v28;
  v9[1] = (int *)v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v24 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v25 = __ldrex(v24);
    while ( __strex(v25 - 1, v24) );
    __dmb(0xFu);
    if ( v25 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 0: using guessed type int dword_0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3CFC) --------------------------------------------------------
int **__fastcall sub_B3CFC(int **a1, int a2, int *a3, int a4, int *a5, int a6, int a7, signed int *a8, double *a9)
{
  int **v9; // r6
  int v10; // r11
  const char *v11; // r8
  int *v12; // r0
  signed int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  int *v19; // r3
  int v20; // r0
  int *v21; // r3
  int v22; // r0
  bool v23; // zf
  unsigned int *v24; // r2
  signed int v25; // r1
  int *v26; // [sp+18h] [bp-40h]
  int v27; // [sp+1Ch] [bp-3Ch]
  int *v28; // [sp+20h] [bp-38h]
  int v29; // [sp+24h] [bp-34h]
  const char *v30; // [sp+28h] [bp-30h]
  int v31; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v30 = (const char *)&unk_2FEF48;
  v28 = a3;
  v29 = a4;
  sub_C1264(&v30, 0x20u);
  sub_B3588(&v26, v10, v28, v29, a5, a6, a7, a8, (int *)&v30);
  v11 = v30;
  v28 = v26;
  v29 = v27;
  v31 = sub_AB4B8();
  std::__convert_to_v<double>(v11, a9, a8);
  if ( v28 )
  {
    if ( v29 == -1 )
    {
      v21 = (int *)v28[2];
      if ( (unsigned int)v21 >= v28[3] )
        v22 = (*(int (**)(void))(*v28 + 36))();
      else
        v22 = *v21;
      v23 = v22 == -1;
      if ( v22 != -1 )
        v29 = v22;
      v12 = a5;
      if ( v23 )
        v21 = 0;
      else
        v11 = 0;
      if ( v23 )
      {
        v11 = (_BYTE *)(&dword_0 + 1);
        v28 = v21;
      }
      if ( a5 )
        goto LABEL_6;
LABEL_28:
      v13 = 1;
      goto LABEL_9;
    }
    v11 = 0;
  }
  else
  {
    v11 = (_BYTE *)(&dword_0 + 1);
  }
  v12 = a5;
  if ( !a5 )
    goto LABEL_28;
LABEL_6:
  if ( a6 == -1 )
  {
    v19 = (int *)v12[2];
    if ( (unsigned int)v19 >= v12[3] )
      v20 = (*(int (**)(void))(*v12 + 36))();
    else
      v20 = *v19;
    v13 = (unsigned int)(v20 + 1) <= 0;
  }
  else
  {
    v13 = 0;
  }
LABEL_9:
  v14 = v11 == (const char *)v13;
  v15 = v30;
  v16 = v29;
  if ( v11 == (const char *)v13 )
    v13 = *a8 | 2;
  *v9 = v28;
  v9[1] = (int *)v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v24 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v25 = __ldrex(v24);
    while ( __strex(v25 - 1, v24) );
    __dmb(0xFu);
    if ( v25 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 0: using guessed type int dword_0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3E50) --------------------------------------------------------
int **__fastcall sub_B3E50(int **a1, int a2, int *a3, int a4, int *a5, int a6, int a7, signed int *a8, double *a9)
{
  int **v9; // r6
  int v10; // r11
  const char *v11; // r8
  int *v12; // r0
  signed int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r1
  char *v17; // r3
  int *v19; // r3
  int v20; // r0
  int *v21; // r3
  int v22; // r0
  bool v23; // zf
  unsigned int *v24; // r2
  signed int v25; // r1
  int *v26; // [sp+18h] [bp-40h]
  int v27; // [sp+1Ch] [bp-3Ch]
  int *v28; // [sp+20h] [bp-38h]
  int v29; // [sp+24h] [bp-34h]
  const char *v30; // [sp+28h] [bp-30h]
  int v31; // [sp+2Ch] [bp-2Ch]

  v9 = a1;
  v10 = a2;
  v30 = (const char *)&unk_2FEF48;
  v28 = a3;
  v29 = a4;
  sub_C1264(&v30, 0x20u);
  sub_B3588(&v26, v10, v28, v29, a5, a6, a7, a8, (int *)&v30);
  v11 = v30;
  v28 = v26;
  v29 = v27;
  v31 = sub_AB4B8();
  std::__convert_to_v<long double>(v11, a9, a8);
  if ( v28 )
  {
    if ( v29 == -1 )
    {
      v21 = (int *)v28[2];
      if ( (unsigned int)v21 >= v28[3] )
        v22 = (*(int (**)(void))(*v28 + 36))();
      else
        v22 = *v21;
      v23 = v22 == -1;
      if ( v22 != -1 )
        v29 = v22;
      v12 = a5;
      if ( v23 )
        v21 = 0;
      else
        v11 = 0;
      if ( v23 )
      {
        v11 = (_BYTE *)(&dword_0 + 1);
        v28 = v21;
      }
      if ( a5 )
        goto LABEL_6;
LABEL_28:
      v13 = 1;
      goto LABEL_9;
    }
    v11 = 0;
  }
  else
  {
    v11 = (_BYTE *)(&dword_0 + 1);
  }
  v12 = a5;
  if ( !a5 )
    goto LABEL_28;
LABEL_6:
  if ( a6 == -1 )
  {
    v19 = (int *)v12[2];
    if ( (unsigned int)v19 >= v12[3] )
      v20 = (*(int (**)(void))(*v12 + 36))();
    else
      v20 = *v19;
    v13 = (unsigned int)(v20 + 1) <= 0;
  }
  else
  {
    v13 = 0;
  }
LABEL_9:
  v14 = v11 == (const char *)v13;
  v15 = v30;
  v16 = v29;
  if ( v11 == (const char *)v13 )
    v13 = *a8 | 2;
  *v9 = v28;
  v9[1] = (int *)v16;
  if ( v14 )
    *a8 = v13;
  v17 = (char *)(v15 - 12);
  if ( v15 - 12 != (const char *)&dword_2FEF3C )
  {
    v24 = (unsigned int *)(v15 - 4);
    __dmb(0xFu);
    do
      v25 = __ldrex(v24);
    while ( __strex(v25 - 1, v24) );
    __dmb(0xFu);
    if ( v25 <= 0 )
      operator delete(v17);
  }
  return v9;
}
// 0: using guessed type int dword_0;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B3FA4) --------------------------------------------------------
_DWORD *__fastcall sub_B3FA4(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned int *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  int v14; // r0
  unsigned int v15; // r4
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r5
  int v19; // r11
  size_t v20; // r9
  unsigned int v21; // r0
  unsigned int v22; // r6
  signed int v23; // r7
  int v24; // r4
  _DWORD *v25; // r1
  unsigned int v26; // r6
  _DWORD *v27; // r0
  unsigned int v28; // r3
  int *v29; // r3
  int v30; // r0
  bool v31; // zf
  int v32; // r4
  _DWORD *v33; // r0
  signed int v34; // r3
  signed int v35; // r4
  _DWORD *v36; // r3
  int v37; // r2
  int v38; // r1
  int *v40; // r3
  unsigned int v41; // r2
  int v42; // r0
  signed int v43; // r0
  wchar_t *v44; // r0
  int v45; // r1
  int v46; // r4
  unsigned int v47; // r6
  _DWORD *v48; // r0
  unsigned int v49; // r3
  int *v50; // r3
  int v51; // r0
  bool v52; // zf
  _DWORD *v53; // r0
  int v54; // r4
  int v55; // r3
  int *v56; // r3
  int v57; // r0
  signed int v58; // r9
  int v59; // r5
  signed int v60; // r6
  unsigned int v61; // r2
  int v62; // r6
  int v63; // r0
  int v64; // [sp+4h] [bp-64h]
  unsigned int v65; // [sp+8h] [bp-60h]
  unsigned int v66; // [sp+10h] [bp-58h]
  int v67; // [sp+14h] [bp-54h]
  _DWORD *v68; // [sp+1Ch] [bp-4Ch]
  char v69; // [sp+20h] [bp-48h]
  _BOOL4 v70; // [sp+24h] [bp-44h]
  _DWORD *v71; // [sp+28h] [bp-40h]
  int v72; // [sp+2Ch] [bp-3Ch]
  char v73; // [sp+34h] [bp-34h]
  _DWORD *v74; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v68 = a1;
  v71 = a3;
  v72 = a4;
  v10 = sub_B095C((int)&v73, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v66 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v66 = v13;
  }
  if ( sub_B12DC(&v71, (int)&a5) )
  {
    v15 = 0;
    v70 = 0;
  }
  else
  {
    v14 = sub_B12A4(&v71);
    v15 = v14;
    v70 = (unsigned int)(*(_DWORD *)(v12 + 188) - v14) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v12 + 188) - v14) > 0 && *(_DWORD *)(v12 + 192) != v14 )
    {
      v16 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_131;
    }
    v16 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(_DWORD *)(v12 + 40) == v14 )
    {
      v16 = 1;
      goto LABEL_131;
    }
    if ( *(_DWORD *)(v12 + 36) == v14 )
    {
LABEL_131:
      v58 = v66;
      v19 = 0;
      v59 = v11;
      v60 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v12 + 40) == v15 || *(_DWORD *)(v12 + 36) == v15 )
        {
LABEL_170:
          v66 = v58;
          v18 = 0;
          v69 = v60;
          goto LABEL_12;
        }
        if ( *(_DWORD *)(v12 + 204) == v15 )
        {
          v62 = v60 ^ 1;
          if ( v58 == 10 )
            v62 |= 1u;
          if ( v62 )
          {
            if ( v59 )
            {
              if ( v58 == 8 )
                v19 = 0;
              else
                ++v19;
              v60 = 1;
            }
            else
            {
              v19 = 0;
              v60 = 1;
              v58 = 8;
            }
            goto LABEL_142;
          }
        }
        else if ( !v60 )
        {
          goto LABEL_170;
        }
        if ( *(_DWORD *)(v12 + 196) != v15 && *(_DWORD *)(v12 + 200) != v15 )
        {
          v66 = v58;
          v18 = 0;
          v69 = 1;
          goto LABEL_12;
        }
        if ( v59 )
        {
          if ( v58 != 16 )
          {
            v66 = v58;
            v18 = 0;
            v69 = 1;
            goto LABEL_13;
          }
          v19 = 0;
          v60 = 0;
        }
        else
        {
          v19 = 0;
          v60 = 0;
          v58 = 16;
        }
LABEL_142:
        if ( v71 )
        {
          v61 = v71[2];
          if ( v61 >= v71[3] )
            (*(void (**)(void))(*v71 + 40))();
          else
            v71[2] = v61 + 4;
          v72 = -1;
        }
        if ( sub_B12DC(&v71, (int)&a5) )
        {
          v66 = v58;
          v18 = 1;
          v69 = v60;
          v16 = *(unsigned __int8 *)(v12 + 16);
          if ( v58 != 16 )
            goto LABEL_13;
          goto LABEL_148;
        }
        v15 = sub_B12A4(&v71);
        if ( !v60 )
        {
          v66 = v58;
          v18 = 0;
          v69 = 0;
          v16 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v16 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v17 = sub_B088C(&v71);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v63 = sub_B12A4(&v71);
      v16 = *(unsigned __int8 *)(v12 + 16);
      v15 = v63;
      goto LABEL_131;
    }
  }
  v16 = *(unsigned __int8 *)(v12 + 16);
  v18 = 1;
  v19 = 0;
  v69 = 0;
LABEL_12:
  if ( v66 == 16 )
LABEL_148:
    v20 = 22;
  else
LABEL_13:
    v20 = v66;
  v74 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v74, 0x20u);
  if ( v70 )
    v21 = 2147483648;
  else
    v21 = 0x7FFFFFFF;
  v67 = v21;
  v64 = *(unsigned __int8 *)(v12 + 292);
  v65 = v21 / v66;
  if ( !*(_BYTE *)(v12 + 292) )
  {
    if ( v18 )
    {
      v22 = 0;
      v23 = 0;
      v35 = 0;
      goto LABEL_48;
    }
    v22 = 0;
    v23 = 0;
    if ( v20 > 0xA )
      goto LABEL_67;
LABEL_22:
    if ( v15 > 0x2F && v20 + 48 > v15 )
    {
      v24 = v15 - 48;
      while ( 1 )
      {
        v25 = (_DWORD *)v65;
        if ( v65 >= v22 )
        {
          ++v19;
          v26 = v66 * v22;
          if ( v67 - v24 < v26 )
            LOBYTE(v23) = v23 | 1;
          v22 = v26 + v24;
          v23 = (unsigned __int8)v23;
        }
        else
        {
          v23 = 1;
        }
        v27 = v71;
        if ( !v71 )
          break;
        v28 = v71[2];
        if ( v28 >= v71[3] )
        {
          (*(void (**)(void))(*v71 + 40))();
          v27 = v71;
          v72 = -1;
          if ( !v71 )
            break;
        }
        else
        {
          v72 = -1;
          v71[2] = v28 + 4;
        }
        v29 = (int *)v27[2];
        if ( (unsigned int)v29 >= v27[3] )
          v30 = (*(int (**)(void))(*v27 + 36))();
        else
          v30 = *v29;
        v32 = v30 + 1;
        v31 = v30 == -1;
        if ( v30 != -1 )
          v72 = v30;
        v33 = a5;
        if ( v31 )
          v25 = 0;
        else
          v32 = 0;
        if ( v31 )
        {
          v32 = 1;
          v71 = v25;
        }
        if ( !a5 )
        {
LABEL_65:
          if ( v32 == 1 )
            goto LABEL_47;
          goto LABEL_66;
        }
LABEL_43:
        if ( a6 == -1 )
        {
          v40 = (int *)v33[2];
          v41 = v33[3];
          if ( (unsigned int)v40 >= v41 )
            v42 = (*(int (**)(void))(*v33 + 36))();
          else
            v42 = *v40;
          if ( v42 == -1 )
            v41 = 0;
          else
            a6 = v42;
          if ( v42 == -1 )
          {
            a5 = (_DWORD *)v41;
            v34 = 1;
          }
          else
          {
            v34 = 0;
          }
        }
        else
        {
          v34 = 0;
        }
        if ( v34 == v32 )
          goto LABEL_47;
LABEL_66:
        v15 = sub_B12A4(&v71);
        if ( v20 <= 0xA )
          goto LABEL_22;
LABEL_67:
        if ( v15 - 48 > 9 )
        {
          if ( v15 - 97 > 5 )
          {
            if ( v15 - 65 > 5 )
              goto LABEL_82;
            v24 = v15 - 55;
          }
          else
          {
            v24 = v15 - 87;
          }
        }
        else
        {
          v24 = v15 - 48;
        }
      }
      v33 = a5;
      v32 = 1;
      if ( !a5 )
        goto LABEL_65;
      goto LABEL_43;
    }
LABEL_82:
    v36 = v74;
    v35 = 0;
    if ( !*(v74 - 3) )
      goto LABEL_49;
LABEL_83:
    sub_C15D0((int *)&v74, v19);
    v43 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v74);
    v36 = v74;
    if ( !v43 )
      *a8 = 4;
    goto LABEL_49;
  }
  if ( v18 )
  {
    v22 = 0;
    v23 = 0;
    v35 = 0;
    goto LABEL_48;
  }
  v22 = 0;
  v23 = 0;
  while ( !*(_BYTE *)(v12 + 16) || v15 != *(_DWORD *)(v12 + 40) )
  {
    if ( v15 == *(_DWORD *)(v12 + 36) )
      goto LABEL_82;
    v44 = wmemchr((const wchar_t *)(v12 + 204), v15, v20);
    if ( !v44 )
      goto LABEL_82;
    v46 = (signed int)((char *)v44 - v12 - 204) >> 2;
    if ( v46 > 15 )
      v46 -= 6;
    if ( v65 >= v22 )
    {
      ++v19;
      v45 = v67;
      v47 = v66 * v22;
      if ( v67 - v46 < v47 )
        LOBYTE(v23) = v23 | 1;
      v22 = v47 + v46;
      v23 = (unsigned __int8)v23;
    }
    else
    {
      v23 = 1;
    }
LABEL_98:
    v48 = v71;
    if ( !v71 )
      goto LABEL_116;
    v49 = v71[2];
    if ( v49 >= v71[3] )
    {
      (*(void (**)(void))(*v71 + 40))();
      v48 = v71;
      v72 = -1;
      if ( !v71 )
      {
LABEL_116:
        v53 = a5;
        v54 = v64;
        if ( !a5 )
          goto LABEL_117;
        goto LABEL_110;
      }
    }
    else
    {
      v71[2] = v49 + 4;
      v72 = -1;
    }
    v50 = (int *)v48[2];
    if ( (unsigned int)v50 >= v48[3] )
      v51 = (*(int (**)(void))(*v48 + 36))();
    else
      v51 = *v50;
    v52 = v51 == -1;
    if ( v51 == -1 )
      v71 = 0;
    else
      v72 = v51;
    v53 = a5;
    if ( v52 )
      v54 = v64;
    else
      v54 = 0;
    if ( !a5 )
    {
LABEL_117:
      v55 = v64;
      goto LABEL_113;
    }
LABEL_110:
    if ( a6 == -1 )
    {
      v56 = (int *)v53[2];
      if ( (unsigned int)v56 >= v53[3] )
        v57 = (*(int (**)(void))(*v53 + 36))();
      else
        v57 = *v56;
      if ( v57 == -1 )
        v45 = 0;
      else
        a6 = v57;
      if ( v57 == -1 )
      {
        a5 = (_DWORD *)v45;
        v55 = v64;
      }
      else
      {
        v55 = 0;
      }
    }
    else
    {
      v55 = 0;
    }
LABEL_113:
    if ( v54 == v55 )
    {
LABEL_47:
      v35 = 0;
      v18 = 1;
      goto LABEL_48;
    }
    v15 = sub_B12A4(&v71);
  }
  if ( v19 )
  {
    sub_C15D0((int *)&v74, v19);
    v19 = 0;
    goto LABEL_98;
  }
  v35 = 1;
LABEL_48:
  v36 = v74;
  if ( *(v74 - 3) )
    goto LABEL_83;
LABEL_49:
  if ( v19 )
    v37 = 0;
  else
    v37 = ((unsigned __int8)v69 ^ 1) & 1;
  if ( v37 && !*(v36 - 3) || v35 )
  {
    *a9 = 0;
    *a8 = 4;
  }
  else if ( v23 )
  {
    if ( v70 )
      *a9 = 2147483648;
    else
      *a9 = 0x7FFFFFFF;
    *a8 = 4;
  }
  else
  {
    if ( v70 )
      v22 = -v22;
    *a9 = v22;
  }
  if ( v18 )
    *a8 |= 2u;
  v38 = v72;
  *v68 = v71;
  v68[1] = v38;
  sub_C0AC4(v36 - 3);
  return v68;
}

//----- (000B44FC) --------------------------------------------------------
_DWORD *__fastcall sub_B44FC(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned int *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_B3FA4(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B4538) --------------------------------------------------------
_DWORD *__fastcall sub_B4538(_DWORD *a1, int a2, _DWORD *a3, int a4, int *a5, int a6, int a7, signed int *a8, _BYTE *a9)
{
  _DWORD *v9; // r10
  int v10; // r0
  unsigned int v11; // r5
  signed int v12; // r12
  _DWORD *v13; // r8
  _BOOL4 v14; // r4
  int v15; // r2
  _BOOL4 v16; // r6
  int v17; // r7
  int v18; // r9
  _DWORD *v19; // r1
  signed int v20; // r1
  unsigned int v21; // r0
  unsigned int v22; // r4
  _BOOL4 v23; // r3
  signed int *v24; // r1
  signed int *v25; // r7
  int *v26; // r9
  int v27; // r0
  int *v28; // r3
  int v29; // r0
  int v30; // r1
  signed int v32; // r7
  signed int v33; // r7
  signed int *v34; // r1
  int v35; // ST28_4
  signed int v36; // ST2C_4
  int v37; // ST28_4
  signed int v38; // ST2C_4
  int v39; // ST28_4
  signed int v40; // ST2C_4
  int v41; // ST28_4
  signed int v42; // ST2C_4
  int v43; // r0
  _BOOL4 v44; // [sp+1Ch] [bp-1Ch]
  char v45; // [sp+30h] [bp-8h]
  int v46; // [sp+34h] [bp-4h]
  _DWORD *v47; // [sp+38h] [bp+0h]
  int v48; // [sp+3Ch] [bp+4h]
  unsigned int v49; // [sp+44h] [bp+Ch]

  v9 = a1;
  v47 = a3;
  v48 = a4;
  if ( !(*(_DWORD *)(a7 + 12) & 1) )
  {
    v49 = -1;
    sub_B3FA4(&v45, a2, v47, v48, a5, a6, a7, a8, &v49);
    v47 = *(_DWORD **)&v45;
    v48 = v46;
    if ( v49 <= 1 )
    {
      *a9 = v49 & 1;
    }
    else
    {
      *a9 = 1;
      *a8 = 4;
      if ( sub_B12DC(&v47, (int)&a5) )
        *a8 |= 2u;
    }
    goto LABEL_66;
  }
  v10 = sub_B095C((int)&v49, (int *)(a7 + 108));
  v11 = 0;
  v12 = -1;
  v44 = 1;
  v13 = (_DWORD *)v10;
  v14 = *(_DWORD *)(v10 + 32) <= 0u;
  v15 = 1;
  v16 = *(_DWORD *)(v10 + 24) <= 0u;
LABEL_6:
  v17 = !v16 || !v14;
  if ( !v17 )
  {
LABEL_33:
    v23 = v44;
    goto LABEL_34;
  }
  while ( 1 )
  {
    v18 = v17;
    if ( v47 )
    {
      v19 = (_DWORD *)(v48 + 1);
      if ( v48 == -1 )
      {
        v26 = (int *)v47[2];
        if ( (unsigned int)v26 >= v47[3] )
        {
          v39 = v15;
          v40 = v12;
          v27 = (*(int (**)(void))(*v47 + 36))();
          v12 = v40;
          v15 = v39;
        }
        else
        {
          v27 = *v26;
        }
        if ( v27 == -1 )
          v19 = 0;
        else
          v48 = v27;
        if ( v27 == -1 )
        {
          v47 = v19;
          v18 = v17;
        }
        else
        {
          v18 = 0;
        }
      }
      else
      {
        v18 = 0;
      }
    }
    if ( !a5 )
      goto LABEL_15;
    if ( a6 != -1 )
    {
      v17 = 0;
LABEL_15:
      if ( v17 == v18 )
        goto LABEL_64;
      goto LABEL_16;
    }
    v28 = (int *)a5[2];
    if ( (unsigned int)v28 >= a5[3] )
    {
      v37 = v15;
      v38 = v12;
      v29 = (*(int (**)(void))(*a5 + 36))();
      v12 = v38;
      v15 = v37;
    }
    else
    {
      v29 = *v28;
    }
    if ( v29 == -1 )
      v28 = 0;
    else
      a6 = v29;
    if ( v29 == -1 )
      a5 = v28;
    else
      v17 = 0;
    if ( v17 == v18 )
    {
LABEL_64:
      v23 = v44;
      v17 = 1;
      goto LABEL_34;
    }
LABEL_16:
    v20 = -1;
    if ( v47 )
    {
      v20 = v48;
      if ( v48 == -1 )
      {
        v25 = (signed int *)v47[2];
        if ( (unsigned int)v25 >= v47[3] )
        {
          v41 = v15;
          v42 = v12;
          v43 = (*(int (**)(void))(*v47 + 36))();
          v12 = v42;
          v15 = v41;
          v20 = v43;
        }
        else
        {
          v20 = *v25;
        }
        if ( v20 == -1 )
          v47 = 0;
        else
          v48 = v20;
      }
    }
    if ( !v14 )
    {
      v21 = *(_DWORD *)(v13[7] + 4 * v11) - v20;
      v15 = v21 + (v21 <= 0) + v20 - *(_DWORD *)(v13[7] + 4 * v11);
    }
    if ( (v15 ^ 1) & v16 )
    {
      v23 = v44;
LABEL_75:
      v17 = 0;
      goto LABEL_36;
    }
    if ( !v16 )
      v44 = (unsigned int)(*(_DWORD *)(v13[5] + 4 * v11) - v20) <= 0;
    if ( v14 && !v44 )
      break;
    if ( !v44 & (v15 ^ 1) )
    {
      v23 = 0;
      goto LABEL_75;
    }
    ++v11;
    if ( v47 )
    {
      v22 = v47[2];
      if ( v22 >= v47[3] )
      {
        v35 = v15;
        v36 = v12;
        (*(void (**)(void))(*v47 + 40))();
        v12 = v36;
        v15 = v35;
      }
      else
      {
        v47[2] = v22 + 4;
      }
      v48 = v12;
    }
    v14 = 1;
    if ( v15 )
      v14 = v11 >= v13[8];
    v16 = 1;
    if ( !v44 )
      goto LABEL_6;
    v16 = v11 >= v13[6];
    v17 = !v16 || !v14;
    if ( !v17 )
      goto LABEL_33;
  }
  v23 = 0;
  v17 = 0;
LABEL_34:
  if ( v15 && v11 == v13[8] && v11 )
  {
    *a9 = 0;
    if ( v23 && v13[6] == v11 )
    {
      *a8 = 4;
    }
    else
    {
      if ( v17 )
        v32 = 2;
      else
        v32 = 0;
      *a8 = v32;
    }
  }
  else
  {
LABEL_36:
    if ( v23 && v13[6] == v11 && v11 )
    {
      if ( v17 )
        v33 = 2;
      else
        v33 = 0;
      v34 = a8;
      *a9 = 1;
      *v34 = v33;
    }
    else
    {
      v24 = a8;
      *a9 = 0;
      *v24 = 4;
      if ( v17 )
        *v24 = 6;
    }
  }
LABEL_66:
  v30 = v48;
  *v9 = v47;
  v9[1] = v30;
  return v9;
}

//----- (000B47E4) --------------------------------------------------------
int **__fastcall sub_B47E4(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int16 *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  int v14; // r0
  unsigned int v15; // r4
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r5
  int v19; // r11
  size_t v20; // r9
  int *v21; // r1
  unsigned int v22; // r6
  signed int v23; // r7
  int v24; // r4
  int v25; // r6
  int *v26; // r0
  unsigned int v27; // r3
  int *v28; // r3
  int v29; // r0
  bool v30; // zf
  int v31; // r4
  _DWORD *v32; // r0
  signed int v33; // r3
  signed int v34; // r4
  _DWORD *v35; // r3
  int v36; // r2
  signed __int16 v37; // r1
  int v38; // r1
  int *v40; // r3
  unsigned int v41; // r2
  int v42; // r0
  signed int v43; // r0
  wchar_t *v44; // r0
  int v45; // r6
  int *v46; // r0
  unsigned int v47; // r3
  int *v48; // r3
  int v49; // r0
  bool v50; // zf
  _DWORD *v51; // r0
  unsigned int v52; // r3
  int *v53; // r3
  int v54; // r0
  bool v55; // zf
  signed int v56; // r9
  int v57; // r5
  signed int v58; // r6
  unsigned int v59; // r2
  int v60; // r6
  int v61; // r0
  unsigned int v62; // [sp+0h] [bp-60h]
  unsigned int v63; // [sp+4h] [bp-5Ch]
  signed int v64; // [sp+Ch] [bp-54h]
  int **v65; // [sp+14h] [bp-4Ch]
  char v66; // [sp+18h] [bp-48h]
  _BOOL4 v67; // [sp+1Ch] [bp-44h]
  int *v68; // [sp+20h] [bp-40h]
  int v69; // [sp+24h] [bp-3Ch]
  char v70; // [sp+2Ch] [bp-34h]
  _DWORD *v71; // [sp+34h] [bp-2Ch]

  v9 = a7;
  v65 = a1;
  v68 = a3;
  v69 = a4;
  v10 = sub_B095C((int)&v70, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v64 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v64 = v13;
  }
  if ( sub_B12DC(&v68, (int)&a5) )
  {
    v15 = 0;
    v67 = 0;
  }
  else
  {
    v14 = sub_B12A4(&v68);
    v15 = v14;
    v67 = (unsigned int)(*(_DWORD *)(v12 + 188) - v14) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v12 + 188) - v14) > 0 && *(_DWORD *)(v12 + 192) != v14 )
    {
      v16 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_128;
    }
    v16 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(_DWORD *)(v12 + 40) == v14 )
    {
      v16 = 1;
      goto LABEL_128;
    }
    if ( *(_DWORD *)(v12 + 36) == v14 )
    {
LABEL_128:
      v56 = v64;
      v19 = 0;
      v57 = v11;
      v58 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v12 + 40) == v15 || *(_DWORD *)(v12 + 36) == v15 )
        {
LABEL_166:
          v64 = v56;
          v18 = 0;
          v66 = v58;
          goto LABEL_12;
        }
        if ( *(_DWORD *)(v12 + 204) == v15 )
        {
          v60 = v58 ^ 1;
          if ( v56 == 10 )
            v60 |= 1u;
          if ( v60 )
          {
            if ( v57 )
            {
              if ( v56 == 8 )
                v19 = 0;
              else
                ++v19;
              v58 = 1;
            }
            else
            {
              v19 = 0;
              v58 = 1;
              v56 = 8;
            }
            goto LABEL_139;
          }
        }
        else if ( !v58 )
        {
          goto LABEL_166;
        }
        if ( *(_DWORD *)(v12 + 196) != v15 && *(_DWORD *)(v12 + 200) != v15 )
        {
          v64 = v56;
          v18 = 0;
          v66 = 1;
          goto LABEL_12;
        }
        if ( v57 )
        {
          if ( v56 != 16 )
          {
            v64 = v56;
            v18 = 0;
            v66 = 1;
            goto LABEL_13;
          }
          v19 = 0;
          v58 = 0;
        }
        else
        {
          v19 = 0;
          v58 = 0;
          v56 = 16;
        }
LABEL_139:
        if ( v68 )
        {
          v59 = v68[2];
          if ( v59 >= v68[3] )
            (*(void (**)(void))(*v68 + 40))();
          else
            v68[2] = v59 + 4;
          v69 = -1;
        }
        if ( sub_B12DC(&v68, (int)&a5) )
        {
          v64 = v56;
          v18 = 1;
          v66 = v58;
          v16 = *(unsigned __int8 *)(v12 + 16);
          if ( v56 != 16 )
            goto LABEL_13;
          goto LABEL_145;
        }
        v15 = sub_B12A4(&v68);
        if ( !v58 )
        {
          v64 = v56;
          v18 = 0;
          v66 = 0;
          v16 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v16 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v17 = sub_B088C(&v68);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v61 = sub_B12A4(&v68);
      v16 = *(unsigned __int8 *)(v12 + 16);
      v15 = v61;
      goto LABEL_128;
    }
  }
  v16 = *(unsigned __int8 *)(v12 + 16);
  v18 = 1;
  v19 = 0;
  v66 = 0;
LABEL_12:
  if ( v64 == 16 )
LABEL_145:
    v20 = 22;
  else
LABEL_13:
    v20 = v64;
  v71 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v71, 0x20u);
  v62 = *(unsigned __int8 *)(v12 + 292);
  v63 = (unsigned __int16)(0xFFFF / v64);
  if ( !*(_BYTE *)(v12 + 292) )
  {
    if ( v18 )
    {
      v22 = 0;
      v23 = 0;
      v34 = 0;
      goto LABEL_45;
    }
    v21 = (int *)(v20 + 48);
    v22 = 0;
    v23 = 0;
    if ( v20 > 0xA )
      goto LABEL_63;
LABEL_19:
    if ( v15 > 0x2F && v20 + 48 > v15 )
    {
      v24 = v15 - 48;
      while ( 1 )
      {
        if ( v63 >= v22 )
        {
          ++v19;
          v25 = (unsigned __int16)(v64 * v22);
          if ( v25 > 0xFFFF - v24 )
            LOBYTE(v23) = v23 | 1;
          v23 = (unsigned __int8)v23;
          v22 = (unsigned __int16)(v25 + v24);
        }
        else
        {
          v23 = 1;
        }
        v26 = v68;
        if ( !v68 )
          break;
        v27 = v68[2];
        if ( v27 >= v68[3] )
        {
          (*(void (**)(void))(*v68 + 40))();
          v26 = v68;
          v69 = -1;
          if ( !v68 )
            break;
        }
        else
        {
          v69 = -1;
          v68[2] = v27 + 4;
        }
        v28 = (int *)v26[2];
        if ( (unsigned int)v28 >= v26[3] )
          v29 = (*(int (**)(void))(*v26 + 36))();
        else
          v29 = *v28;
        v31 = v29 + 1;
        v30 = v29 == -1;
        if ( v29 != -1 )
          v69 = v29;
        v32 = a5;
        if ( v30 )
          v21 = 0;
        else
          v31 = 0;
        if ( v30 )
        {
          v31 = 1;
          v68 = v21;
        }
        if ( !a5 )
        {
LABEL_61:
          if ( v31 == 1 )
            goto LABEL_44;
          goto LABEL_62;
        }
LABEL_40:
        if ( a6 == -1 )
        {
          v40 = (int *)v32[2];
          v41 = v32[3];
          if ( (unsigned int)v40 >= v41 )
            v42 = (*(int (**)(void))(*v32 + 36))();
          else
            v42 = *v40;
          if ( v42 == -1 )
            v41 = 0;
          else
            a6 = v42;
          if ( v42 == -1 )
          {
            a5 = (_DWORD *)v41;
            v33 = 1;
          }
          else
          {
            v33 = 0;
          }
        }
        else
        {
          v33 = 0;
        }
        if ( v33 == v31 )
          goto LABEL_44;
LABEL_62:
        v15 = sub_B12A4(&v68);
        if ( v20 <= 0xA )
          goto LABEL_19;
LABEL_63:
        if ( v15 - 48 > 9 )
        {
          if ( v15 - 97 > 5 )
          {
            if ( v15 - 65 > 5 )
              goto LABEL_78;
            v24 = v15 - 55;
          }
          else
          {
            v24 = v15 - 87;
          }
        }
        else
        {
          v24 = v15 - 48;
        }
      }
      v32 = a5;
      v31 = 1;
      if ( !a5 )
        goto LABEL_61;
      goto LABEL_40;
    }
LABEL_78:
    v35 = v71;
    v34 = 0;
    if ( !*(v71 - 3) )
      goto LABEL_46;
LABEL_79:
    sub_C15D0((int *)&v71, v19);
    v43 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v71);
    v35 = v71;
    if ( !v43 )
      *a8 = 4;
    goto LABEL_46;
  }
  if ( v18 )
  {
    v22 = 0;
    v23 = 0;
    v34 = 0;
    goto LABEL_45;
  }
  v22 = 0;
  v23 = 0;
  while ( !*(_BYTE *)(v12 + 16) || v15 != *(_DWORD *)(v12 + 40) )
  {
    if ( v15 == *(_DWORD *)(v12 + 36) )
      goto LABEL_78;
    v44 = wmemchr((const wchar_t *)(v12 + 204), v15, v20);
    if ( !v44 )
      goto LABEL_78;
    v15 = (signed int)((char *)v44 - v12 - 204) >> 2;
    if ( (signed int)v15 > 15 )
      v15 -= 6;
    if ( v63 >= v22 )
    {
      ++v19;
      v45 = (unsigned __int16)(v64 * v22);
      if ( v45 > (signed int)(0xFFFF - v15) )
        LOBYTE(v23) = v23 | 1;
      v23 = (unsigned __int8)v23;
      v22 = (unsigned __int16)(v45 + v15);
    }
    else
    {
      v23 = 1;
    }
LABEL_94:
    v46 = v68;
    if ( !v68 )
      goto LABEL_113;
    v47 = v68[2];
    if ( v47 >= v68[3] )
    {
      (*(void (**)(void))(*v68 + 40))();
      v46 = v68;
      v69 = -1;
      if ( !v68 )
      {
LABEL_113:
        v51 = a5;
        v15 = v62;
        if ( !a5 )
          goto LABEL_114;
        goto LABEL_107;
      }
    }
    else
    {
      v68[2] = v47 + 4;
      v69 = -1;
    }
    v48 = (int *)v46[2];
    if ( (unsigned int)v48 >= v46[3] )
      v49 = (*(int (**)(void))(*v46 + 36))();
    else
      v49 = *v48;
    v50 = v49 == -1;
    if ( v49 != -1 )
      v69 = v49;
    v51 = a5;
    if ( v50 )
      v48 = 0;
    else
      v15 = 0;
    if ( v50 )
    {
      v15 = v62;
      v68 = v48;
    }
    if ( !a5 )
    {
LABEL_114:
      v52 = v62;
      goto LABEL_110;
    }
LABEL_107:
    if ( a6 == -1 )
    {
      v53 = (int *)v51[2];
      if ( (unsigned int)v53 >= v51[3] )
        v54 = (*(int (**)(void))(*v51 + 36))();
      else
        v54 = *v53;
      v55 = v54 == -1;
      if ( v54 == -1 )
        v54 = 0;
      else
        a6 = v54;
      if ( v55 )
      {
        a5 = (_DWORD *)v54;
        v52 = v62;
      }
      else
      {
        v52 = 0;
      }
    }
    else
    {
      v52 = 0;
    }
LABEL_110:
    if ( v15 == v52 )
    {
LABEL_44:
      v34 = 0;
      v18 = 1;
      goto LABEL_45;
    }
    v15 = sub_B12A4(&v68);
  }
  if ( v19 )
  {
    sub_C15D0((int *)&v71, v19);
    v19 = 0;
    goto LABEL_94;
  }
  v34 = 1;
LABEL_45:
  v35 = v71;
  if ( *(v71 - 3) )
    goto LABEL_79;
LABEL_46:
  if ( v19 )
    v36 = 0;
  else
    v36 = ((unsigned __int8)v66 ^ 1) & 1;
  if ( v36 && !*(v35 - 3) || v34 )
  {
    v37 = 0;
    goto LABEL_52;
  }
  if ( v23 )
  {
    v37 = -1;
LABEL_52:
    *a9 = v37;
    *a8 = 4;
  }
  else
  {
    if ( v67 )
      v22 = -v22;
    *a9 = v22;
  }
  if ( v18 )
    *a8 |= 2u;
  v38 = v69;
  *v65 = v68;
  v65[1] = (int *)v38;
  sub_C0AC4(v35 - 3);
  return v65;
}

//----- (000B4D20) --------------------------------------------------------
int **__fastcall sub_B4D20(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int16 *a9)
{
  int **v9; // r8

  v9 = a1;
  sub_B47E4(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B4D5C) --------------------------------------------------------
int **__fastcall sub_B4D5C(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r5
  int v14; // r0
  unsigned int v15; // r4
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r5
  int v19; // r11
  size_t v20; // r9
  int *v21; // r1
  unsigned int v22; // r6
  signed int v23; // r7
  int v24; // r4
  unsigned int v25; // r6
  int *v26; // r0
  unsigned int v27; // r3
  int *v28; // r3
  int v29; // r0
  bool v30; // zf
  int v31; // r4
  _DWORD *v32; // r0
  signed int v33; // r3
  signed int v34; // r4
  _DWORD *v35; // r3
  int v36; // r2
  signed int v37; // r1
  int v38; // r1
  int *v40; // r3
  unsigned int v41; // r2
  int v42; // r0
  signed int v43; // r0
  wchar_t *v44; // r0
  unsigned int v45; // r6
  int *v46; // r0
  unsigned int v47; // r3
  int *v48; // r3
  int v49; // r0
  bool v50; // zf
  _DWORD *v51; // r0
  unsigned int v52; // r3
  int *v53; // r3
  int v54; // r0
  bool v55; // zf
  signed int v56; // r9
  int v57; // r5
  signed int v58; // r6
  unsigned int v59; // r2
  int v60; // r6
  int v61; // r0
  unsigned int v62; // [sp+0h] [bp-60h]
  unsigned int v63; // [sp+4h] [bp-5Ch]
  unsigned int v64; // [sp+Ch] [bp-54h]
  int **v65; // [sp+14h] [bp-4Ch]
  char v66; // [sp+18h] [bp-48h]
  _BOOL4 v67; // [sp+1Ch] [bp-44h]
  int *v68; // [sp+20h] [bp-40h]
  int v69; // [sp+24h] [bp-3Ch]
  char v70; // [sp+2Ch] [bp-34h]
  _DWORD *v71; // [sp+34h] [bp-2Ch]

  v9 = a7;
  v65 = a1;
  v68 = a3;
  v69 = a4;
  v10 = sub_B095C((int)&v70, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v64 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v64 = v13;
  }
  if ( sub_B12DC(&v68, (int)&a5) )
  {
    v15 = 0;
    v67 = 0;
  }
  else
  {
    v14 = sub_B12A4(&v68);
    v15 = v14;
    v67 = (unsigned int)(*(_DWORD *)(v12 + 188) - v14) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v12 + 188) - v14) > 0 && *(_DWORD *)(v12 + 192) != v14 )
    {
      v16 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_128;
    }
    v16 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(_DWORD *)(v12 + 40) == v14 )
    {
      v16 = 1;
      goto LABEL_128;
    }
    if ( *(_DWORD *)(v12 + 36) == v14 )
    {
LABEL_128:
      v56 = v64;
      v19 = 0;
      v57 = v11;
      v58 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v12 + 40) == v15 || *(_DWORD *)(v12 + 36) == v15 )
        {
LABEL_166:
          v64 = v56;
          v18 = 0;
          v66 = v58;
          goto LABEL_12;
        }
        if ( *(_DWORD *)(v12 + 204) == v15 )
        {
          v60 = v58 ^ 1;
          if ( v56 == 10 )
            v60 |= 1u;
          if ( v60 )
          {
            if ( v57 )
            {
              if ( v56 == 8 )
                v19 = 0;
              else
                ++v19;
              v58 = 1;
            }
            else
            {
              v19 = 0;
              v58 = 1;
              v56 = 8;
            }
            goto LABEL_139;
          }
        }
        else if ( !v58 )
        {
          goto LABEL_166;
        }
        if ( *(_DWORD *)(v12 + 196) != v15 && *(_DWORD *)(v12 + 200) != v15 )
        {
          v64 = v56;
          v18 = 0;
          v66 = 1;
          goto LABEL_12;
        }
        if ( v57 )
        {
          if ( v56 != 16 )
          {
            v64 = v56;
            v18 = 0;
            v66 = 1;
            goto LABEL_13;
          }
          v19 = 0;
          v58 = 0;
        }
        else
        {
          v19 = 0;
          v58 = 0;
          v56 = 16;
        }
LABEL_139:
        if ( v68 )
        {
          v59 = v68[2];
          if ( v59 >= v68[3] )
            (*(void (**)(void))(*v68 + 40))();
          else
            v68[2] = v59 + 4;
          v69 = -1;
        }
        if ( sub_B12DC(&v68, (int)&a5) )
        {
          v64 = v56;
          v18 = 1;
          v66 = v58;
          v16 = *(unsigned __int8 *)(v12 + 16);
          if ( v56 != 16 )
            goto LABEL_13;
          goto LABEL_145;
        }
        v15 = sub_B12A4(&v68);
        if ( !v58 )
        {
          v64 = v56;
          v18 = 0;
          v66 = 0;
          v16 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v16 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v17 = sub_B088C(&v68);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v61 = sub_B12A4(&v68);
      v16 = *(unsigned __int8 *)(v12 + 16);
      v15 = v61;
      goto LABEL_128;
    }
  }
  v16 = *(unsigned __int8 *)(v12 + 16);
  v18 = 1;
  v19 = 0;
  v66 = 0;
LABEL_12:
  if ( v64 == 16 )
LABEL_145:
    v20 = 22;
  else
LABEL_13:
    v20 = v64;
  v71 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v71, 0x20u);
  v62 = *(unsigned __int8 *)(v12 + 292);
  v63 = 0xFFFFFFFF / v64;
  if ( !*(_BYTE *)(v12 + 292) )
  {
    if ( v18 )
    {
      v22 = 0;
      v23 = 0;
      v34 = 0;
      goto LABEL_45;
    }
    v21 = (int *)(v20 + 48);
    v22 = 0;
    v23 = 0;
    if ( v20 > 0xA )
      goto LABEL_63;
LABEL_19:
    if ( v15 > 0x2F && v20 + 48 > v15 )
    {
      v24 = v15 - 48;
      while ( 1 )
      {
        if ( v63 >= v22 )
        {
          ++v19;
          v25 = v64 * v22;
          if ( ~v24 < v25 )
            LOBYTE(v23) = v23 | 1;
          v22 = v25 + v24;
          v23 = (unsigned __int8)v23;
        }
        else
        {
          v23 = 1;
        }
        v26 = v68;
        if ( !v68 )
          break;
        v27 = v68[2];
        if ( v27 >= v68[3] )
        {
          (*(void (**)(void))(*v68 + 40))();
          v26 = v68;
          v69 = -1;
          if ( !v68 )
            break;
        }
        else
        {
          v69 = -1;
          v68[2] = v27 + 4;
        }
        v28 = (int *)v26[2];
        if ( (unsigned int)v28 >= v26[3] )
          v29 = (*(int (**)(void))(*v26 + 36))();
        else
          v29 = *v28;
        v31 = v29 + 1;
        v30 = v29 == -1;
        if ( v29 != -1 )
          v69 = v29;
        v32 = a5;
        if ( v30 )
          v21 = 0;
        else
          v31 = 0;
        if ( v30 )
        {
          v31 = 1;
          v68 = v21;
        }
        if ( !a5 )
        {
LABEL_61:
          if ( v31 == 1 )
            goto LABEL_44;
          goto LABEL_62;
        }
LABEL_40:
        if ( a6 == -1 )
        {
          v40 = (int *)v32[2];
          v41 = v32[3];
          if ( (unsigned int)v40 >= v41 )
            v42 = (*(int (**)(void))(*v32 + 36))();
          else
            v42 = *v40;
          if ( v42 == -1 )
            v41 = 0;
          else
            a6 = v42;
          if ( v42 == -1 )
          {
            a5 = (_DWORD *)v41;
            v33 = 1;
          }
          else
          {
            v33 = 0;
          }
        }
        else
        {
          v33 = 0;
        }
        if ( v33 == v31 )
          goto LABEL_44;
LABEL_62:
        v15 = sub_B12A4(&v68);
        if ( v20 <= 0xA )
          goto LABEL_19;
LABEL_63:
        if ( v15 - 48 > 9 )
        {
          if ( v15 - 97 > 5 )
          {
            if ( v15 - 65 > 5 )
              goto LABEL_78;
            v24 = v15 - 55;
          }
          else
          {
            v24 = v15 - 87;
          }
        }
        else
        {
          v24 = v15 - 48;
        }
      }
      v32 = a5;
      v31 = 1;
      if ( !a5 )
        goto LABEL_61;
      goto LABEL_40;
    }
LABEL_78:
    v35 = v71;
    v34 = 0;
    if ( !*(v71 - 3) )
      goto LABEL_46;
LABEL_79:
    sub_C15D0((int *)&v71, v19);
    v43 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v71);
    v35 = v71;
    if ( !v43 )
      *a8 = 4;
    goto LABEL_46;
  }
  if ( v18 )
  {
    v22 = 0;
    v23 = 0;
    v34 = 0;
    goto LABEL_45;
  }
  v22 = 0;
  v23 = 0;
  while ( !*(_BYTE *)(v12 + 16) || v15 != *(_DWORD *)(v12 + 40) )
  {
    if ( v15 == *(_DWORD *)(v12 + 36) )
      goto LABEL_78;
    v44 = wmemchr((const wchar_t *)(v12 + 204), v15, v20);
    if ( !v44 )
      goto LABEL_78;
    v15 = (signed int)((char *)v44 - v12 - 204) >> 2;
    if ( (signed int)v15 > 15 )
      v15 -= 6;
    if ( v63 >= v22 )
    {
      ++v19;
      v45 = v64 * v22;
      if ( ~v15 < v45 )
        LOBYTE(v23) = v23 | 1;
      v22 = v45 + v15;
      v23 = (unsigned __int8)v23;
    }
    else
    {
      v23 = 1;
    }
LABEL_94:
    v46 = v68;
    if ( !v68 )
      goto LABEL_113;
    v47 = v68[2];
    if ( v47 >= v68[3] )
    {
      (*(void (**)(void))(*v68 + 40))();
      v46 = v68;
      v69 = -1;
      if ( !v68 )
      {
LABEL_113:
        v51 = a5;
        v15 = v62;
        if ( !a5 )
          goto LABEL_114;
        goto LABEL_107;
      }
    }
    else
    {
      v68[2] = v47 + 4;
      v69 = -1;
    }
    v48 = (int *)v46[2];
    if ( (unsigned int)v48 >= v46[3] )
      v49 = (*(int (**)(void))(*v46 + 36))();
    else
      v49 = *v48;
    v50 = v49 == -1;
    if ( v49 != -1 )
      v69 = v49;
    v51 = a5;
    if ( v50 )
      v48 = 0;
    else
      v15 = 0;
    if ( v50 )
    {
      v15 = v62;
      v68 = v48;
    }
    if ( !a5 )
    {
LABEL_114:
      v52 = v62;
      goto LABEL_110;
    }
LABEL_107:
    if ( a6 == -1 )
    {
      v53 = (int *)v51[2];
      if ( (unsigned int)v53 >= v51[3] )
        v54 = (*(int (**)(void))(*v51 + 36))();
      else
        v54 = *v53;
      v55 = v54 == -1;
      if ( v54 == -1 )
        v54 = 0;
      else
        a6 = v54;
      if ( v55 )
      {
        a5 = (_DWORD *)v54;
        v52 = v62;
      }
      else
      {
        v52 = 0;
      }
    }
    else
    {
      v52 = 0;
    }
LABEL_110:
    if ( v15 == v52 )
    {
LABEL_44:
      v34 = 0;
      v18 = 1;
      goto LABEL_45;
    }
    v15 = sub_B12A4(&v68);
  }
  if ( v19 )
  {
    sub_C15D0((int *)&v71, v19);
    v19 = 0;
    goto LABEL_94;
  }
  v34 = 1;
LABEL_45:
  v35 = v71;
  if ( *(v71 - 3) )
    goto LABEL_79;
LABEL_46:
  if ( v19 )
    v36 = 0;
  else
    v36 = ((unsigned __int8)v66 ^ 1) & 1;
  if ( v36 && !*(v35 - 3) || v34 )
  {
    v37 = 0;
    goto LABEL_52;
  }
  if ( v23 )
  {
    v37 = -1;
LABEL_52:
    *a9 = v37;
    *a8 = 4;
  }
  else
  {
    if ( v67 )
      v22 = -v22;
    *a9 = v22;
  }
  if ( v18 )
    *a8 |= 2u;
  v38 = v69;
  *v65 = v68;
  v65[1] = (int *)v38;
  sub_C0AC4(v35 - 3);
  return v65;
}

//----- (000B5284) --------------------------------------------------------
int **__fastcall sub_B5284(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int **v9; // r8

  v9 = a1;
  sub_B4D5C(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B52C0) --------------------------------------------------------
int **__fastcall sub_B52C0(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v9; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  signed int v13; // r4
  int v14; // r0
  unsigned int v15; // r4
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r5
  int v19; // r11
  size_t v20; // r9
  unsigned int v21; // r6
  signed int v22; // r7
  int v23; // r4
  unsigned int v24; // r6
  int *v25; // r0
  unsigned int v26; // r3
  int *v27; // r3
  int v28; // r0
  bool v29; // zf
  int v30; // r4
  _DWORD *v31; // r0
  signed int v32; // r3
  signed int v33; // r4
  _DWORD *v34; // r3
  int v35; // r2
  signed int v36; // r1
  char *v37; // r2
  int v38; // r1
  int *v40; // r3
  int v41; // r0
  bool v42; // zf
  signed int v43; // r0
  wchar_t *v44; // r0
  unsigned int v45; // r6
  int *v46; // r0
  unsigned int v47; // r3
  int *v48; // r3
  int v49; // r0
  bool v50; // zf
  int *v51; // r2
  _DWORD *v52; // r0
  unsigned int v53; // r3
  int *v54; // r3
  int v55; // r0
  int v56; // r3
  signed int v57; // r9
  int v58; // r5
  signed int v59; // r6
  unsigned int v60; // r2
  int v61; // r6
  int v62; // r0
  unsigned int *v63; // r3
  signed int v64; // r1
  unsigned int v65; // [sp+4h] [bp-64h]
  unsigned int v66; // [sp+8h] [bp-60h]
  unsigned int v67; // [sp+10h] [bp-58h]
  int **v68; // [sp+18h] [bp-50h]
  char v69; // [sp+20h] [bp-48h]
  _BOOL4 v70; // [sp+24h] [bp-44h]
  int *v71; // [sp+28h] [bp-40h]
  int v72; // [sp+2Ch] [bp-3Ch]
  char v73; // [sp+34h] [bp-34h]
  _DWORD *v74; // [sp+3Ch] [bp-2Ch]

  v9 = a7;
  v68 = a1;
  v71 = a3;
  v72 = a4;
  v10 = sub_B095C((int)&v73, (int *)(a7 + 108));
  v11 = *(_DWORD *)(v9 + 12) & 0x4A;
  v12 = v10;
  if ( v11 == 64 )
  {
    v67 = 8;
  }
  else
  {
    if ( v11 == 8 )
      v13 = 16;
    else
      v13 = 10;
    v67 = v13;
  }
  if ( sub_B12DC(&v71, (int)&a5) )
  {
    v15 = 0;
    v70 = 0;
  }
  else
  {
    v14 = sub_B12A4(&v71);
    v15 = v14;
    v70 = (unsigned int)(*(_DWORD *)(v12 + 188) - v14) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v12 + 188) - v14) > 0 && *(_DWORD *)(v12 + 192) != v14 )
    {
      v16 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_130;
    }
    v16 = *(unsigned __int8 *)(v12 + 16);
    if ( *(_BYTE *)(v12 + 16) && *(_DWORD *)(v12 + 40) == v14 )
    {
      v16 = 1;
      goto LABEL_130;
    }
    if ( *(_DWORD *)(v12 + 36) == v14 )
    {
LABEL_130:
      v57 = v67;
      v19 = 0;
      v58 = v11;
      v59 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v12 + 40) == v15 || *(_DWORD *)(v12 + 36) == v15 )
        {
LABEL_168:
          v67 = v57;
          v18 = 0;
          v69 = v59;
          goto LABEL_12;
        }
        if ( *(_DWORD *)(v12 + 204) == v15 )
        {
          v61 = v59 ^ 1;
          if ( v57 == 10 )
            v61 |= 1u;
          if ( v61 )
          {
            if ( v58 )
            {
              if ( v57 == 8 )
                v19 = 0;
              else
                ++v19;
              v59 = 1;
            }
            else
            {
              v19 = 0;
              v59 = 1;
              v57 = 8;
            }
            goto LABEL_141;
          }
        }
        else if ( !v59 )
        {
          goto LABEL_168;
        }
        if ( *(_DWORD *)(v12 + 196) != v15 && *(_DWORD *)(v12 + 200) != v15 )
        {
          v67 = v57;
          v18 = 0;
          v69 = 1;
          goto LABEL_12;
        }
        if ( v58 )
        {
          if ( v57 != 16 )
          {
            v67 = v57;
            v18 = 0;
            v69 = 1;
            goto LABEL_13;
          }
          v19 = 0;
          v59 = 0;
        }
        else
        {
          v19 = 0;
          v59 = 0;
          v57 = 16;
        }
LABEL_141:
        if ( v71 )
        {
          v60 = v71[2];
          if ( v60 >= v71[3] )
            (*(void (**)(void))(*v71 + 40))();
          else
            v71[2] = v60 + 4;
          v72 = -1;
        }
        if ( sub_B12DC(&v71, (int)&a5) )
        {
          v67 = v57;
          v18 = 1;
          v69 = v59;
          v16 = *(unsigned __int8 *)(v12 + 16);
          if ( v57 != 16 )
            goto LABEL_13;
          goto LABEL_147;
        }
        v15 = sub_B12A4(&v71);
        if ( !v59 )
        {
          v67 = v57;
          v18 = 0;
          v69 = 0;
          v16 = *(unsigned __int8 *)(v12 + 16);
          goto LABEL_12;
        }
        v16 = *(unsigned __int8 *)(v12 + 16);
      }
    }
    v17 = sub_B088C(&v71);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v62 = sub_B12A4(&v71);
      v16 = *(unsigned __int8 *)(v12 + 16);
      v15 = v62;
      goto LABEL_130;
    }
  }
  v16 = *(unsigned __int8 *)(v12 + 16);
  v18 = 1;
  v19 = 0;
  v69 = 0;
LABEL_12:
  if ( v67 == 16 )
LABEL_147:
    v20 = 22;
  else
LABEL_13:
    v20 = v67;
  v74 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v74, 0x20u);
  v65 = *(unsigned __int8 *)(v12 + 292);
  v66 = 0xFFFFFFFF / v67;
  if ( !*(_BYTE *)(v12 + 292) )
  {
    if ( v18 )
    {
      v21 = 0;
      v22 = 0;
      v33 = 0;
      goto LABEL_45;
    }
    v21 = 0;
    v22 = 0;
    if ( v20 > 0xA )
      goto LABEL_65;
LABEL_19:
    if ( v15 > 0x2F && v15 < v20 + 48 )
    {
      v23 = v15 - 48;
      while ( 1 )
      {
        if ( v66 >= v21 )
        {
          ++v19;
          v24 = v67 * v21;
          if ( ~v23 < v24 )
            LOBYTE(v22) = v22 | 1;
          v21 = v24 + v23;
          v22 = (unsigned __int8)v22;
        }
        else
        {
          v22 = 1;
        }
        v25 = v71;
        if ( !v71 )
          break;
        v26 = v71[2];
        if ( v26 >= v71[3] )
        {
          (*(void (**)(void))(*v71 + 40))();
          v25 = v71;
          v72 = -1;
          if ( !v71 )
            break;
        }
        else
        {
          v72 = -1;
          v71[2] = v26 + 4;
        }
        v27 = (int *)v25[2];
        if ( (unsigned int)v27 >= v25[3] )
          v28 = (*(int (**)(void))(*v25 + 36))();
        else
          v28 = *v27;
        v30 = v28 + 1;
        v29 = v28 == -1;
        if ( v28 != -1 )
          v72 = v28;
        v31 = a5;
        if ( v29 )
          v27 = 0;
        else
          v30 = 0;
        if ( v29 )
        {
          v30 = 1;
          v71 = v27;
        }
        if ( !a5 )
        {
LABEL_63:
          if ( v30 == 1 )
            goto LABEL_44;
          goto LABEL_64;
        }
LABEL_40:
        if ( a6 == -1 )
        {
          v40 = (int *)v31[2];
          if ( (unsigned int)v40 >= v31[3] )
            v41 = (*(int (**)(void))(*v31 + 36))();
          else
            v41 = *v40;
          v42 = v41 == -1;
          if ( v41 == -1 )
            v41 = 0;
          else
            a6 = v41;
          if ( v42 )
          {
            a5 = (_DWORD *)v41;
            v32 = 1;
          }
          else
          {
            v32 = 0;
          }
        }
        else
        {
          v32 = 0;
        }
        if ( v30 == v32 )
          goto LABEL_44;
LABEL_64:
        v15 = sub_B12A4(&v71);
        if ( v20 <= 0xA )
          goto LABEL_19;
LABEL_65:
        if ( v15 - 48 > 9 )
        {
          if ( v15 - 97 > 5 )
          {
            if ( v15 - 65 > 5 )
              goto LABEL_80;
            v23 = v15 - 55;
          }
          else
          {
            v23 = v15 - 87;
          }
        }
        else
        {
          v23 = v15 - 48;
        }
      }
      v31 = a5;
      v30 = 1;
      if ( !a5 )
        goto LABEL_63;
      goto LABEL_40;
    }
LABEL_80:
    v34 = v74;
    v33 = 0;
    if ( !*(v74 - 3) )
      goto LABEL_46;
LABEL_81:
    sub_C15D0((int *)&v74, v19);
    v43 = sub_C303C(*(_DWORD *)(v12 + 8), *(_DWORD *)(v12 + 12), (unsigned __int8 **)&v74);
    v34 = v74;
    if ( !v43 )
      *a8 = 4;
    goto LABEL_46;
  }
  if ( v18 )
  {
    v21 = 0;
    v22 = 0;
    v33 = 0;
    goto LABEL_45;
  }
  v21 = 0;
  v22 = 0;
  while ( !*(_BYTE *)(v12 + 16) || v15 != *(_DWORD *)(v12 + 40) )
  {
    if ( v15 == *(_DWORD *)(v12 + 36) )
      goto LABEL_80;
    v44 = wmemchr((const wchar_t *)(v12 + 204), v15, v20);
    if ( !v44 )
      goto LABEL_80;
    v15 = (signed int)((char *)v44 - v12 - 204) >> 2;
    if ( (signed int)v15 > 15 )
      v15 -= 6;
    if ( v66 >= v21 )
    {
      ++v19;
      v45 = v67 * v21;
      if ( ~v15 < v45 )
        LOBYTE(v22) = v22 | 1;
      v21 = v45 + v15;
      v22 = (unsigned __int8)v22;
    }
    else
    {
      v22 = 1;
    }
LABEL_96:
    v46 = v71;
    if ( !v71 )
      goto LABEL_115;
    v47 = v71[2];
    if ( v47 >= v71[3] )
    {
      (*(void (**)(void))(*v71 + 40))();
      v46 = v71;
      v72 = -1;
      if ( !v71 )
      {
LABEL_115:
        v52 = a5;
        v15 = v65;
        if ( !a5 )
          goto LABEL_116;
        goto LABEL_109;
      }
    }
    else
    {
      v15 = -1;
      v71[2] = v47 + 4;
      v72 = -1;
    }
    v48 = (int *)v46[2];
    if ( (unsigned int)v48 >= v46[3] )
      v49 = (*(int (**)(void))(*v46 + 36))();
    else
      v49 = *v48;
    v51 = (int *)(v49 + 1);
    v50 = v49 == -1;
    if ( v49 != -1 )
      v72 = v49;
    v52 = a5;
    if ( v50 )
      v51 = 0;
    else
      v15 = 0;
    if ( v50 )
    {
      v15 = v65;
      v71 = v51;
    }
    if ( !a5 )
    {
LABEL_116:
      v53 = v65;
      goto LABEL_112;
    }
LABEL_109:
    if ( a6 == -1 )
    {
      v54 = (int *)v52[2];
      if ( (unsigned int)v54 >= v52[3] )
        v55 = (*(int (**)(void))(*v52 + 36))();
      else
        v55 = *v54;
      v56 = v55 + 1;
      if ( v55 == -1 )
        v56 = 0;
      else
        a6 = v55;
      if ( v55 == -1 )
      {
        a5 = (_DWORD *)v56;
        v53 = v65;
      }
      else
      {
        v53 = 0;
      }
    }
    else
    {
      v53 = 0;
    }
LABEL_112:
    if ( v15 == v53 )
    {
LABEL_44:
      v33 = 0;
      v18 = 1;
      goto LABEL_45;
    }
    v15 = sub_B12A4(&v71);
  }
  if ( v19 )
  {
    sub_C15D0((int *)&v74, v19);
    v19 = 0;
    goto LABEL_96;
  }
  v33 = 1;
LABEL_45:
  v34 = v74;
  if ( *(v74 - 3) )
    goto LABEL_81;
LABEL_46:
  if ( v19 )
    v35 = 0;
  else
    v35 = ((unsigned __int8)v69 ^ 1) & 1;
  if ( v35 && !*(v34 - 3) || v33 )
  {
    v36 = 0;
    goto LABEL_52;
  }
  if ( v22 )
  {
    v36 = -1;
LABEL_52:
    *a9 = v36;
    *a8 = 4;
  }
  else
  {
    if ( v70 )
      v21 = -v21;
    *a9 = v21;
  }
  if ( v18 )
    *a8 |= 2u;
  v37 = (char *)(v34 - 3);
  v38 = v72;
  *v68 = v71;
  v68[1] = (int *)v38;
  if ( v34 - 3 != &dword_2FEF3C )
  {
    v63 = v34 - 1;
    __dmb(0xFu);
    do
      v64 = __ldrex(v63);
    while ( __strex(v64 - 1, v63) );
    __dmb(0xFu);
    if ( v64 <= 0 )
      operator delete(v37);
  }
  return v68;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B5814) --------------------------------------------------------
int **__fastcall sub_B5814(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int **v9; // r8

  v9 = a1;
  sub_B52C0(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B5850) --------------------------------------------------------
int **__fastcall sub_B5850(int **a1, int a2, int *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, int *a9)
{
  int **v9; // r6
  int v10; // r9
  int *v11; // r0
  int v12; // r1
  int v13; // r3
  int **result; // r0
  int *v15; // [sp+18h] [bp-14h]
  int v16; // [sp+1Ch] [bp-10h]
  int *v17; // [sp+20h] [bp-Ch]
  int v18; // [sp+24h] [bp-8h]
  int v19; // [sp+2Ch] [bp+0h]

  v9 = a1;
  v10 = *(_DWORD *)(a7 + 12);
  v17 = a3;
  v18 = a4;
  *(_DWORD *)(a7 + 12) = v10 & 0xFFFFFFB5 | 8;
  sub_B52C0(&v15, a2, a3, a4, a5, a6, a7, a8, &v19);
  v11 = v15;
  v12 = v16;
  v13 = v19;
  *(_DWORD *)(a7 + 12) = v10;
  *v9 = v11;
  v9[1] = (int *)v12;
  result = v9;
  *a9 = v13;
  return result;
}

//----- (000B58B4) --------------------------------------------------------
_DWORD *__fastcall sub_B58B4(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned __int64 *a9)
{
  signed int v9; // r7
  __int64 v10; // r10
  int v11; // r4
  int v12; // r0
  int v13; // r5
  int v14; // r6
  int v15; // r0
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r4
  unsigned __int64 v19; // r0
  unsigned __int64 v20; // r8
  signed int v21; // r5
  wchar_t *v22; // r0
  signed __int64 v23; // r0
  __int64 v24; // r10
  unsigned int v25; // r3
  _DWORD *v26; // r3
  bool v27; // zf
  _DWORD *v28; // r0
  int v29; // r10
  int v30; // r3
  signed int v31; // r7
  _DWORD *v32; // r12
  int v33; // r3
  char *v34; // r3
  int v35; // r1
  _DWORD *v37; // r3
  signed int v38; // r0
  int v39; // r11
  unsigned int v40; // r3
  _DWORD *v41; // r3
  bool v42; // zf
  _DWORD *v43; // r0
  signed int v44; // r3
  int *v45; // r3
  unsigned int v46; // r2
  int v47; // r0
  int v48; // r4
  int v49; // r9
  signed int v50; // r5
  unsigned int v51; // r2
  unsigned __int64 v52; // r2
  int v53; // r5
  int v54; // r0
  unsigned int *v55; // r12
  signed int v56; // r2
  size_t n; // [sp+Ch] [bp-74h]
  int v58; // [sp+10h] [bp-70h]
  int v59; // [sp+14h] [bp-6Ch]
  unsigned __int64 v60; // [sp+18h] [bp-68h]
  unsigned __int64 v61; // [sp+20h] [bp-60h]
  _DWORD *v62; // [sp+30h] [bp-50h]
  char v63; // [sp+38h] [bp-48h]
  _BOOL4 v64; // [sp+3Ch] [bp-44h]
  _DWORD *v65; // [sp+40h] [bp-40h]
  int v66; // [sp+44h] [bp-3Ch]
  char v67; // [sp+4Ch] [bp-34h]
  _DWORD *v68; // [sp+54h] [bp-2Ch]

  v11 = a7;
  v62 = a1;
  v65 = a3;
  v66 = a4;
  v12 = sub_B095C((int)&v67, (int *)(a7 + 108));
  v13 = *(_DWORD *)(v11 + 12) & 0x4A;
  if ( v13 == 64 )
    v9 = 8;
  v14 = v12;
  if ( v13 != 64 )
  {
    if ( v13 == 8 )
      v9 = 16;
    else
      v9 = 10;
  }
  if ( sub_B12DC(&v65, (int)&a5) )
  {
    HIDWORD(v10) = 0;
    v64 = 0;
  }
  else
  {
    v15 = sub_B12A4(&v65);
    HIDWORD(v10) = v15;
    v64 = (unsigned int)(*(_DWORD *)(v14 + 188) - v15) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v14 + 188) - v15) > 0 && *(_DWORD *)(v14 + 192) != v15 )
    {
      v16 = *(unsigned __int8 *)(v14 + 16);
      goto LABEL_133;
    }
    v16 = *(unsigned __int8 *)(v14 + 16);
    if ( *(_BYTE *)(v14 + 16) && *(_DWORD *)(v14 + 40) == v15 )
    {
      v16 = 1;
      goto LABEL_133;
    }
    if ( *(_DWORD *)(v14 + 36) == v15 )
    {
LABEL_133:
      LODWORD(v10) = 0;
      v48 = v13;
      v49 = 0;
      v50 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v14 + 40) == HIDWORD(v10) || *(_DWORD *)(v14 + 36) == HIDWORD(v10) )
        {
LABEL_171:
          v63 = v50;
          v18 = 0;
          v58 = v49;
          goto LABEL_13;
        }
        if ( *(_DWORD *)(v14 + 204) == HIDWORD(v10) )
        {
          v53 = v50 ^ 1;
          if ( v9 == 10 )
            v53 |= 1u;
          if ( v53 )
          {
            if ( v48 )
            {
              if ( v9 == 8 )
                v49 = 0;
              else
                ++v49;
              v50 = 1;
            }
            else
            {
              v49 = 0;
              v50 = 1;
              v9 = 8;
            }
            goto LABEL_144;
          }
        }
        else if ( !v50 )
        {
          goto LABEL_171;
        }
        if ( *(_DWORD *)(v14 + 196) != HIDWORD(v10) && *(_DWORD *)(v14 + 200) != HIDWORD(v10) )
        {
          v58 = v49;
          v18 = 0;
          v63 = 1;
          goto LABEL_13;
        }
        if ( v48 )
        {
          if ( v9 != 16 )
          {
            v58 = v49;
            v18 = 0;
            v63 = 1;
            goto LABEL_14;
          }
          v49 = 0;
          v50 = 0;
        }
        else
        {
          v49 = 0;
          v50 = 0;
          v9 = 16;
        }
LABEL_144:
        if ( v65 )
        {
          v51 = v65[2];
          if ( v51 >= v65[3] )
            (*(void (**)(void))(*v65 + 40))();
          else
            v65[2] = v51 + 4;
          v66 = -1;
        }
        if ( sub_B12DC(&v65, (int)&a5) )
        {
          v63 = v50;
          v58 = v49;
          v18 = 1;
          v16 = *(unsigned __int8 *)(v14 + 16);
          if ( v9 != 16 )
            goto LABEL_14;
          goto LABEL_150;
        }
        HIDWORD(v10) = sub_B12A4(&v65);
        if ( !v50 )
        {
          v63 = 0;
          v18 = 0;
          v58 = v49;
          v16 = *(unsigned __int8 *)(v14 + 16);
          goto LABEL_13;
        }
        v16 = *(unsigned __int8 *)(v14 + 16);
      }
    }
    v17 = sub_B088C(&v65);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v54 = sub_B12A4(&v65);
      v16 = *(unsigned __int8 *)(v14 + 16);
      HIDWORD(v10) = v54;
      goto LABEL_133;
    }
  }
  v16 = *(unsigned __int8 *)(v14 + 16);
  v18 = 1;
  v58 = 0;
  v63 = 0;
LABEL_13:
  if ( v9 == 16 )
LABEL_150:
    n = 22;
  else
LABEL_14:
    n = v9;
  v68 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v68, 0x20u);
  if ( v64 )
    v61 = 0x8000000000000000LL;
  else
    v61 = 0x7FFFFFFFFFFFFFFFLL;
  v19 = v61 / v9;
  v59 = *(unsigned __int8 *)(v14 + 292);
  v60 = v61 / v9;
  if ( !*(_BYTE *)(v14 + 292) )
  {
    if ( v18 )
    {
      v21 = 0;
      v20 = 0LL;
      v31 = 0;
      goto LABEL_50;
    }
    v20 = 0LL;
    v21 = 0;
    if ( n > 0xA )
      goto LABEL_112;
LABEL_86:
    if ( HIDWORD(v10) <= 0x2F || (HIDWORD(v19) = n + 48, HIDWORD(v10) >= n + 48) )
    {
LABEL_81:
      v32 = v68;
      v31 = 0;
      if ( !*(v68 - 3) )
        goto LABEL_51;
      goto LABEL_82;
    }
    v39 = HIDWORD(v10) - 48;
    while ( 1 )
    {
      if ( v60 >= v20 )
      {
        v10 = v39;
        ++v58;
        v19 = v61 - v10;
        if ( v61 - v10 < v9 * v20 )
          LOBYTE(v21) = v21 | 1;
        v20 = v10 + v9 * v20;
        v21 = (unsigned __int8)v21;
      }
      else
      {
        v21 = 1;
      }
      LODWORD(v19) = v65;
      if ( !v65 )
        break;
      v40 = v65[2];
      if ( v40 >= v65[3] )
      {
        (*(void (**)(void))(*v65 + 40))();
        LODWORD(v19) = v65;
        v66 = -1;
        if ( !v65 )
          break;
      }
      else
      {
        v66 = -1;
        v65[2] = v40 + 4;
      }
      v41 = *(_DWORD **)(v19 + 8);
      if ( (unsigned int)v41 >= *(_DWORD *)(v19 + 12) )
        LODWORD(v19) = (*(int (**)(void))(*(_DWORD *)v19 + 36))();
      else
        LODWORD(v19) = *v41;
      v42 = (_DWORD)v19 == -1;
      if ( (_DWORD)v19 != -1 )
        v66 = v19;
      v43 = a5;
      if ( v42 )
        HIDWORD(v19) = 0;
      else
        LODWORD(v10) = 0;
      if ( v42 )
      {
        LODWORD(v10) = 1;
        v65 = (_DWORD *)HIDWORD(v19);
      }
      if ( !a5 )
      {
LABEL_120:
        v44 = 1;
        goto LABEL_110;
      }
LABEL_107:
      if ( a6 == -1 )
      {
        v45 = (int *)v43[2];
        v46 = v43[3];
        if ( (unsigned int)v45 >= v46 )
          v47 = (*(int (**)(void))(*v43 + 36))();
        else
          v47 = *v45;
        if ( v47 == -1 )
          v46 = 0;
        else
          a6 = v47;
        if ( v47 == -1 )
        {
          a5 = (_DWORD *)v46;
          v44 = 1;
        }
        else
        {
          v44 = 0;
        }
      }
      else
      {
        v44 = 0;
      }
LABEL_110:
      if ( (_DWORD)v10 == v44 )
      {
LABEL_49:
        v31 = 0;
        v18 = 1;
        goto LABEL_50;
      }
      HIDWORD(v10) = sub_B12A4(&v65);
      if ( n <= 0xA )
        goto LABEL_86;
LABEL_112:
      LODWORD(v10) = HIDWORD(v10) - 48;
      if ( (unsigned int)(HIDWORD(v10) - 48) > 9 )
      {
        if ( (unsigned int)(HIDWORD(v10) - 97) > 5 )
        {
          if ( (unsigned int)(HIDWORD(v10) - 65) > 5 )
            goto LABEL_81;
          v39 = HIDWORD(v10) - 55;
        }
        else
        {
          v39 = HIDWORD(v10) - 87;
        }
      }
      else
      {
        v39 = HIDWORD(v10) - 48;
      }
    }
    v43 = a5;
    LODWORD(v10) = 1;
    if ( !a5 )
      goto LABEL_120;
    goto LABEL_107;
  }
  if ( v18 )
  {
    v21 = 0;
    v20 = 0LL;
    v31 = 0;
    goto LABEL_50;
  }
  v20 = 0LL;
  v21 = 0;
  while ( !*(_BYTE *)(v14 + 16) || HIDWORD(v10) != *(_DWORD *)(v14 + 40) )
  {
    if ( HIDWORD(v10) == *(_DWORD *)(v14 + 36) )
      goto LABEL_81;
    v22 = wmemchr((const wchar_t *)(v14 + 204), WORD2(v10), n);
    if ( !v22 )
      goto LABEL_81;
    HIDWORD(v23) = v61 / v9 >> 32;
    LODWORD(v24) = (signed int)((char *)v22 - v14 - 204) >> 2;
    if ( (signed int)v24 > 15 )
      LODWORD(v24) = v24 - 6;
    if ( v60 >= v20 )
    {
      v24 = (signed int)v24;
      ++v58;
      v23 = v61 - (signed int)v24;
      if ( v61 - (signed int)v24 < v9 * v20 )
        LOBYTE(v21) = v21 | 1;
      v20 = v24 + v9 * v20;
      v21 = (unsigned __int8)v21;
    }
    else
    {
      v21 = 1;
    }
LABEL_33:
    LODWORD(v23) = v65;
    if ( !v65 )
      goto LABEL_67;
    v25 = v65[2];
    if ( v25 >= v65[3] )
    {
      (*(void (**)(void))(*v65 + 40))();
      LODWORD(v23) = v65;
      v66 = -1;
      if ( !v65 )
      {
LABEL_67:
        v28 = a5;
        v29 = v59;
        if ( !a5 )
          goto LABEL_68;
        goto LABEL_45;
      }
    }
    else
    {
      v65[2] = v25 + 4;
      v66 = -1;
    }
    v26 = *(_DWORD **)(v23 + 8);
    if ( (unsigned int)v26 >= *(_DWORD *)(v23 + 12) )
      LODWORD(v23) = (*(int (**)(void))(*(_DWORD *)v23 + 36))();
    else
      LODWORD(v23) = *v26;
    v27 = (_DWORD)v23 == -1;
    if ( (_DWORD)v23 == -1 )
      v65 = 0;
    else
      v66 = v23;
    v28 = a5;
    if ( v27 )
      v29 = v59;
    else
      v29 = 0;
    if ( !a5 )
    {
LABEL_68:
      if ( v29 == v59 )
        goto LABEL_49;
      goto LABEL_69;
    }
LABEL_45:
    if ( a6 == -1 )
    {
      v37 = (_DWORD *)v28[2];
      if ( (unsigned int)v37 >= v28[3] )
        LODWORD(v23) = (*(int (**)(void))(*v28 + 36))();
      else
        LODWORD(v23) = *v37;
      if ( (_DWORD)v23 == -1 )
        v23 = 0xFFFFFFFFLL;
      else
        a6 = v23;
      if ( (_DWORD)v23 == -1 )
      {
        a5 = (_DWORD *)HIDWORD(v23);
        v30 = v59;
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v30 = 0;
    }
    if ( v29 == v30 )
      goto LABEL_49;
LABEL_69:
    HIDWORD(v10) = sub_B12A4(&v65);
  }
  if ( v58 )
  {
    sub_C15D0((int *)&v68, v58);
    HIDWORD(v23) = 0;
    v58 = 0;
    goto LABEL_33;
  }
  v31 = 1;
LABEL_50:
  v32 = v68;
  if ( *(v68 - 3) )
  {
LABEL_82:
    sub_C15D0((int *)&v68, v58);
    v38 = sub_C303C(*(_DWORD *)(v14 + 8), *(_DWORD *)(v14 + 12), (unsigned __int8 **)&v68);
    v32 = v68;
    if ( !v38 )
      *a8 = 4;
  }
LABEL_51:
  if ( v58 )
    v33 = 0;
  else
    v33 = ((unsigned __int8)v63 ^ 1) & 1;
  if ( v33 && !*(v32 - 3) || v31 )
  {
    *a9 = 0LL;
    *a8 = 4;
  }
  else if ( v21 )
  {
    if ( v64 )
      *a9 = 0x8000000000000000LL;
    else
      *a9 = 0x7FFFFFFFFFFFFFFFLL;
    *a8 = 4;
  }
  else
  {
    LODWORD(v52) = -(signed int)v20;
    HIDWORD(v52) = HIDWORD(v20) - (2 * HIDWORD(v20) + ((unsigned int)v20 > 0));
    if ( !v64 )
      v52 = v20;
    *a9 = v52;
  }
  if ( v18 )
    *a8 |= 2u;
  v34 = (char *)(v32 - 3);
  v35 = v66;
  *v62 = v65;
  v62[1] = v35;
  if ( v32 - 3 != &dword_2FEF3C )
  {
    v55 = v32 - 1;
    __dmb(0xFu);
    do
      v56 = __ldrex(v55);
    while ( __strex(v56 - 1, v55) );
    __dmb(0xFu);
    if ( v56 <= 0 )
      operator delete(v34);
  }
  return v62;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000B5ECC) --------------------------------------------------------
_DWORD *__fastcall sub_B5ECC(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, unsigned __int64 *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_B58B4(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B5F08) --------------------------------------------------------
_DWORD *__fastcall sub_B5F08(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int64 *a9)
{
  signed int v9; // r7
  int v10; // r4
  int v11; // r0
  int v12; // r4
  int v13; // r8
  int v14; // r0
  unsigned int v15; // r5
  signed int v16; // r3
  _DWORD **v17; // r0
  signed int v18; // r6
  unsigned __int64 v19; // r10
  signed int v20; // r7
  int v21; // r5
  int v22; // r1
  __int64 v23; // r4
  _DWORD *v24; // r0
  unsigned int v25; // r3
  int *v26; // r3
  int v27; // r0
  bool v28; // zf
  int v29; // r4
  _DWORD *v30; // r0
  signed int v31; // r3
  signed int v32; // r4
  _DWORD *v33; // r5
  int v34; // r3
  signed __int64 v35; // r2
  int v36; // r1
  int *v38; // r3
  unsigned int v39; // r2
  int v40; // r0
  signed int v41; // r0
  wchar_t *v42; // r0
  unsigned __int64 v43; // r4
  __int64 v44; // r0
  _DWORD *v45; // r0
  unsigned int v46; // r3
  int *v47; // r3
  int v48; // r0
  bool v49; // zf
  _DWORD *v50; // r2
  _DWORD *v51; // r0
  int v52; // r3
  int *v53; // r3
  int v54; // r0
  int v55; // r3
  int v56; // r6
  int v57; // r10
  signed int v58; // r4
  unsigned int v59; // r2
  signed __int64 v60; // r2
  int v61; // r4
  int v62; // r0
  __int64 v63; // [sp+0h] [bp-70h]
  size_t n; // [sp+8h] [bp-68h]
  int v65; // [sp+Ch] [bp-64h]
  unsigned __int64 v66; // [sp+10h] [bp-60h]
  int v67; // [sp+18h] [bp-58h]
  _DWORD *v68; // [sp+24h] [bp-4Ch]
  char v69; // [sp+28h] [bp-48h]
  _BOOL4 v70; // [sp+2Ch] [bp-44h]
  _DWORD *v71; // [sp+30h] [bp-40h]
  int v72; // [sp+34h] [bp-3Ch]
  char v73; // [sp+3Ch] [bp-34h]
  _DWORD *v74; // [sp+44h] [bp-2Ch]

  v10 = a7;
  v68 = a1;
  v71 = a3;
  v72 = a4;
  v11 = sub_B095C((int)&v73, (int *)(a7 + 108));
  v12 = *(_DWORD *)(v10 + 12) & 0x4A;
  if ( v12 == 64 )
    v9 = 8;
  v13 = v11;
  if ( v12 != 64 )
  {
    if ( v12 == 8 )
      v9 = 16;
    else
      v9 = 10;
  }
  if ( sub_B12DC(&v71, (int)&a5) )
  {
    v15 = 0;
    v70 = 0;
  }
  else
  {
    v14 = sub_B12A4(&v71);
    v15 = v14;
    v70 = (unsigned int)(*(_DWORD *)(v13 + 188) - v14) <= 0;
    if ( (unsigned int)(*(_DWORD *)(v13 + 188) - v14) > 0 && *(_DWORD *)(v13 + 192) != v14 )
    {
      v16 = *(unsigned __int8 *)(v13 + 16);
      goto LABEL_129;
    }
    v16 = *(unsigned __int8 *)(v13 + 16);
    if ( *(_BYTE *)(v13 + 16) && *(_DWORD *)(v13 + 40) == v14 )
    {
      v16 = 1;
      goto LABEL_129;
    }
    if ( *(_DWORD *)(v13 + 36) == v14 )
    {
LABEL_129:
      v56 = v12;
      v57 = 0;
      v58 = 0;
      while ( 1 )
      {
        if ( v16 && *(_DWORD *)(v13 + 40) == v15 || *(_DWORD *)(v13 + 36) == v15 )
        {
LABEL_166:
          v69 = v58;
          v18 = 0;
          v65 = v57;
          goto LABEL_13;
        }
        if ( *(_DWORD *)(v13 + 204) == v15 )
        {
          v61 = v58 ^ 1;
          if ( v9 == 10 )
            v61 |= 1u;
          if ( v61 )
          {
            if ( v56 )
            {
              if ( v9 == 8 )
                v57 = 0;
              else
                ++v57;
              v58 = 1;
            }
            else
            {
              v57 = 0;
              v58 = 1;
              v9 = 8;
            }
            goto LABEL_140;
          }
        }
        else if ( !v58 )
        {
          goto LABEL_166;
        }
        if ( *(_DWORD *)(v13 + 196) != v15 && *(_DWORD *)(v13 + 200) != v15 )
        {
          v65 = v57;
          v18 = 0;
          v69 = 1;
          goto LABEL_13;
        }
        if ( v56 )
        {
          if ( v9 != 16 )
          {
            v65 = v57;
            v18 = 0;
            v69 = 1;
            goto LABEL_14;
          }
          v57 = 0;
          v58 = 0;
        }
        else
        {
          v57 = 0;
          v58 = 0;
          v9 = 16;
        }
LABEL_140:
        if ( v71 )
        {
          v59 = v71[2];
          if ( v59 >= v71[3] )
            (*(void (**)(void))(*v71 + 40))();
          else
            v71[2] = v59 + 4;
          v72 = -1;
        }
        if ( sub_B12DC(&v71, (int)&a5) )
        {
          v69 = v58;
          v65 = v57;
          v18 = 1;
          v16 = *(unsigned __int8 *)(v13 + 16);
          if ( v9 != 16 )
            goto LABEL_14;
          goto LABEL_146;
        }
        v15 = sub_B12A4(&v71);
        if ( !v58 )
        {
          v69 = 0;
          v18 = 0;
          v65 = v57;
          v16 = *(unsigned __int8 *)(v13 + 16);
          goto LABEL_13;
        }
        v16 = *(unsigned __int8 *)(v13 + 16);
      }
    }
    v17 = sub_B088C(&v71);
    if ( !sub_B12DC(v17, (int)&a5) )
    {
      v62 = sub_B12A4(&v71);
      v16 = *(unsigned __int8 *)(v13 + 16);
      v15 = v62;
      goto LABEL_129;
    }
  }
  v16 = *(unsigned __int8 *)(v13 + 16);
  v18 = 1;
  v65 = 0;
  v69 = 0;
LABEL_13:
  if ( v9 == 16 )
LABEL_146:
    n = 22;
  else
LABEL_14:
    n = v9;
  v74 = &unk_2FEF48;
  if ( v16 )
    sub_C1264(&v74, 0x20u);
  v63 = v9;
  v67 = *(unsigned __int8 *)(v13 + 292);
  v66 = 0xFFFFFFFFFFFFFFFFLL / v9;
  if ( !*(_BYTE *)(v13 + 292) )
  {
    if ( v18 )
    {
      v20 = 0;
      v19 = 0LL;
      v32 = 0;
      goto LABEL_46;
    }
    v19 = 0LL;
    v20 = 0;
    if ( n > 0xA )
      goto LABEL_64;
LABEL_20:
    if ( v15 > 0x2F && n + 48 > v15 )
    {
      v21 = v15 - 48;
      while ( 1 )
      {
        v22 = HIDWORD(v66);
        if ( v66 >= v19 )
        {
          v23 = v21;
          v22 = ~HIDWORD(v23);
          ++v65;
          if ( ~v23 < v63 * v19 )
            LOBYTE(v20) = v20 | 1;
          v19 = v23 + v63 * v19;
          v20 = (unsigned __int8)v20;
        }
        else
        {
          v20 = 1;
        }
        v24 = v71;
        if ( !v71 )
          break;
        v25 = v71[2];
        if ( v25 >= v71[3] )
        {
          (*(void (**)(void))(*v71 + 40))();
          v24 = v71;
          v72 = -1;
          if ( !v71 )
            break;
        }
        else
        {
          v72 = -1;
          v71[2] = v25 + 4;
        }
        v26 = (int *)v24[2];
        if ( (unsigned int)v26 >= v24[3] )
          v27 = (*(int (**)(void))(*v24 + 36))();
        else
          v27 = *v26;
        v29 = v27 + 1;
        v28 = v27 == -1;
        if ( v27 != -1 )
          v72 = v27;
        v30 = a5;
        if ( v28 )
          v22 = 0;
        else
          v29 = 0;
        if ( v28 )
        {
          v29 = 1;
          v71 = (_DWORD *)v22;
        }
        if ( !a5 )
        {
LABEL_62:
          if ( v29 == 1 )
            goto LABEL_45;
          goto LABEL_63;
        }
LABEL_41:
        if ( a6 == -1 )
        {
          v38 = (int *)v30[2];
          v39 = v30[3];
          if ( (unsigned int)v38 >= v39 )
            v40 = (*(int (**)(void))(*v30 + 36))();
          else
            v40 = *v38;
          if ( v40 == -1 )
            v39 = 0;
          else
            a6 = v40;
          if ( v40 == -1 )
          {
            a5 = (_DWORD *)v39;
            v31 = 1;
          }
          else
          {
            v31 = 0;
          }
        }
        else
        {
          v31 = 0;
        }
        if ( v31 == v29 )
          goto LABEL_45;
LABEL_63:
        v15 = sub_B12A4(&v71);
        if ( n <= 0xA )
          goto LABEL_20;
LABEL_64:
        if ( v15 - 48 > 9 )
        {
          if ( v15 - 97 > 5 )
          {
            if ( v15 - 65 > 5 )
              goto LABEL_79;
            v21 = v15 - 55;
          }
          else
          {
            v21 = v15 - 87;
          }
        }
        else
        {
          v21 = v15 - 48;
        }
      }
      v30 = a5;
      v29 = 1;
      if ( !a5 )
        goto LABEL_62;
      goto LABEL_41;
    }
LABEL_79:
    v33 = v74;
    v32 = 0;
    if ( !*(v74 - 3) )
      goto LABEL_47;
LABEL_80:
    sub_C15D0((int *)&v74, v65);
    v41 = sub_C303C(*(_DWORD *)(v13 + 8), *(_DWORD *)(v13 + 12), (unsigned __int8 **)&v74);
    v33 = v74;
    if ( !v41 )
      *a8 = 4;
    goto LABEL_47;
  }
  if ( v18 )
  {
    v20 = 0;
    v19 = 0LL;
    v32 = 0;
    goto LABEL_46;
  }
  v19 = 0LL;
  v20 = 0;
  while ( !*(_BYTE *)(v13 + 16) || v15 != *(_DWORD *)(v13 + 40) )
  {
    if ( v15 == *(_DWORD *)(v13 + 36) )
      goto LABEL_79;
    v42 = wmemchr((const wchar_t *)(v13 + 204), v15, n);
    if ( !v42 )
      goto LABEL_79;
    LODWORD(v43) = v66;
    LODWORD(v44) = (signed int)((char *)v42 - v13 - 204) >> 2;
    if ( (signed int)v44 > 15 )
      LODWORD(v44) = v44 - 6;
    if ( v66 >= v19 )
    {
      v44 = (signed int)v44;
      ++v65;
      v43 = ~(signed __int64)(signed int)v44;
      if ( v43 < v63 * v19 )
        LOBYTE(v20) = v20 | 1;
      v19 = v44 + v63 * v19;
      v20 = (unsigned __int8)v20;
    }
    else
    {
      v20 = 1;
    }
LABEL_95:
    v45 = v71;
    if ( !v71 )
      goto LABEL_114;
    v46 = v71[2];
    if ( v46 >= v71[3] )
    {
      (*(void (**)(void))(*v71 + 40))();
      v45 = v71;
      v72 = -1;
      if ( !v71 )
      {
LABEL_114:
        v51 = a5;
        LODWORD(v43) = v67;
        if ( !a5 )
          goto LABEL_115;
        goto LABEL_108;
      }
    }
    else
    {
      v71[2] = v46 + 4;
      v72 = -1;
    }
    v47 = (int *)v45[2];
    if ( (unsigned int)v47 >= v45[3] )
      v48 = (*(int (**)(void))(*v45 + 36))();
    else
      v48 = *v47;
    v50 = (_DWORD *)(v48 + 1);
    v49 = v48 == -1;
    if ( v48 != -1 )
      v72 = v48;
    v51 = a5;
    if ( v49 )
      v50 = 0;
    else
      LODWORD(v43) = 0;
    if ( v49 )
    {
      LODWORD(v43) = v67;
      v71 = v50;
    }
    if ( !a5 )
    {
LABEL_115:
      v52 = v67;
      goto LABEL_111;
    }
LABEL_108:
    if ( a6 == -1 )
    {
      v53 = (int *)v51[2];
      if ( (unsigned int)v53 >= v51[3] )
        v54 = (*(int (**)(void))(*v51 + 36))();
      else
        v54 = *v53;
      v55 = v54 + 1;
      if ( v54 == -1 )
        v55 = 0;
      else
        a6 = v54;
      if ( v54 == -1 )
      {
        a5 = (_DWORD *)v55;
        v52 = v67;
      }
      else
      {
        v52 = 0;
      }
    }
    else
    {
      v52 = 0;
    }
LABEL_111:
    if ( (_DWORD)v43 == v52 )
    {
LABEL_45:
      v32 = 0;
      v18 = 1;
      goto LABEL_46;
    }
    v15 = sub_B12A4(&v71);
  }
  if ( v65 )
  {
    sub_C15D0((int *)&v74, v65);
    LODWORD(v43) = 0;
    v65 = 0;
    goto LABEL_95;
  }
  v32 = 1;
LABEL_46:
  v33 = v74;
  if ( *(v74 - 3) )
    goto LABEL_80;
LABEL_47:
  if ( v65 )
    v34 = 0;
  else
    v34 = ((unsigned __int8)v69 ^ 1) & 1;
  if ( v34 && !*(v33 - 3) || v32 )
  {
    v35 = 0LL;
    goto LABEL_53;
  }
  if ( v20 )
  {
    v35 = -1LL;
LABEL_53:
    *a9 = v35;
    *a8 = 4;
  }
  else
  {
    LODWORD(v60) = -(signed int)v19;
    HIDWORD(v60) = HIDWORD(v19) - (2 * HIDWORD(v19) + ((unsigned int)v19 > 0));
    if ( !v70 )
      v60 = v19;
    *a9 = v60;
  }
  if ( v18 )
    *a8 |= 2u;
  v36 = v72;
  *v68 = v71;
  v68[1] = v36;
  sub_C0AC4(v33 - 3);
  return v68;
}

//----- (000B649C) --------------------------------------------------------
_DWORD *__fastcall sub_B649C(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8, signed __int64 *a9)
{
  _DWORD *v9; // r8

  v9 = a1;
  sub_B5F08(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return v9;
}

//----- (000B64D8) --------------------------------------------------------
_DWORD *__fastcall sub_B64D8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1DB4;
  a1[1] = &off_F0690;
  sub_95E1C(a1 + 1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F1DB4: using guessed type void *off_F1DB4;

//----- (000B6500) --------------------------------------------------------
_DWORD *__fastcall sub_B6500(_DWORD *a1)
{
  return sub_B64D8((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000B650C) --------------------------------------------------------
_DWORD *__fastcall sub_B650C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F1DE4;
  a1[1] = &off_F06A0;
  sub_95E1C(a1 + 1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F1DE4: using guessed type void *off_F1DE4;

//----- (000B6534) --------------------------------------------------------
_DWORD *__fastcall sub_B6534(_DWORD *a1)
{
  return sub_B650C((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000B6540) --------------------------------------------------------
void *__fastcall sub_B6540(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1DB4;
  a1[1] = &off_F0690;
  sub_95E1C(a1 + 1);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F1DB4: using guessed type void *off_F1DB4;

//----- (000B6570) --------------------------------------------------------
void *__fastcall sub_B6570(_DWORD *a1)
{
  return sub_B6540((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000B657C) --------------------------------------------------------
void *__fastcall sub_B657C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F1DE4;
  a1[1] = &off_F06A0;
  sub_95E1C(a1 + 1);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F1DE4: using guessed type void *off_F1DE4;

//----- (000B65AC) --------------------------------------------------------
void *__fastcall sub_B65AC(_DWORD *a1)
{
  return sub_B657C((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000B6668) --------------------------------------------------------
_DWORD *__fastcall sub_B6668(_DWORD *a1, void (__fastcall *a2)(char *))
{
  _DWORD *v2; // r4

  v2 = a1;
  a2((char *)a1 + *(_DWORD *)(*a1 - 12));
  return v2;
}

//----- (000B66B0) --------------------------------------------------------
_DWORD *__fastcall sub_B66B0(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12) + 120);
  if ( v2 && (*(int (**)(void))(*(_DWORD *)v2 + 24))() == -1 )
    sub_93F84((_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12)), *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 20) | 1);
  return v1;
}

//----- (000B69EC) --------------------------------------------------------
_BYTE *__fastcall sub_B69EC(int a1, int *a2)
{
  int v2; // r2
  _BYTE *v3; // r4
  int *v4; // r5
  _DWORD *v5; // r3
  _DWORD *v6; // r0
  int v7; // r1
  _BYTE *result; // r0

  v2 = *a2;
  v3 = (_BYTE *)a1;
  *(_DWORD *)(a1 + 4) = a2;
  *(_BYTE *)a1 = 0;
  v4 = a2;
  v5 = (int *)((char *)a2 + *(_DWORD *)(v2 - 12));
  v6 = (_DWORD *)v5[28];
  if ( v6 )
  {
    v7 = v5[5];
    if ( v7 )
      goto LABEL_6;
    sub_B66B0(v6);
    v2 = *v4;
  }
  v5 = (int *)((char *)v4 + *(_DWORD *)(v2 - 12));
  v7 = v5[5];
  if ( !v7 )
  {
    result = v3;
    *v3 = 1;
    return result;
  }
LABEL_6:
  sub_93F84(v5, v7 | 4);
  return v3;
}

//----- (000B6A30) --------------------------------------------------------
int __fastcall sub_B6A30(int a1)
{
  int v1; // r4
  int v2; // r5
  int v3; // r0
  _DWORD *v5; // r0

  v1 = a1;
  v2 = *(_DWORD *)(**(_DWORD **)(a1 + 4) - 12) + *(_DWORD *)(a1 + 4);
  if ( !(*(_DWORD *)(v2 + 12) & 0x2000) )
    return v1;
  if ( std::uncaught_exception() )
    return v1;
  v3 = *(_DWORD *)(v2 + 120);
  if ( !v3 || (*(int (**)(void))(*(_DWORD *)v3 + 24))() != -1 )
    return v1;
  v5 = (_DWORD *)(*(_DWORD *)(**(_DWORD **)(v1 + 4) - 12) + *(_DWORD *)(v1 + 4));
  sub_93F84(v5, v5[5] | 1);
  return v1;
}

//----- (000B6B64) --------------------------------------------------------
int *__fastcall sub_B6B64(int *a1, char a2)
{
  int *v2; // r4
  char v3; // r6
  int v4; // r0
  _BYTE *v5; // r2
  int v6; // r5
  int v7; // r0
  char v9; // [sp+0h] [bp-18h]
  _DWORD *v10; // [sp+4h] [bp-14h]

  v2 = a1;
  v3 = a2;
  sub_B69EC((int)&v9, a1);
  if ( v9 )
  {
    v4 = *(int *)((char *)v2 + *(_DWORD *)(*v2 - 12) + 120);
    v5 = *(_BYTE **)(v4 + 20);
    if ( (unsigned int)v5 >= *(_DWORD *)(v4 + 24) )
    {
      if ( sub_25EA8(v4) == -1 )
        sub_93F84((int *)((char *)v2 + *(_DWORD *)(*v2 - 12)), *(int *)((char *)v2 + *(_DWORD *)(*v2 - 12) + 20) | 1);
    }
    else
    {
      *v5 = v3;
      ++*(_DWORD *)(v4 + 20);
    }
  }
  v6 = (int)v10 + *(_DWORD *)(*v10 - 12);
  if ( !(*(_DWORD *)(v6 + 12) & 0x2000) )
    return v2;
  if ( std::uncaught_exception() )
    return v2;
  v7 = *(_DWORD *)(v6 + 120);
  if ( !v7 || (*(int (**)(void))(*(_DWORD *)v7 + 24))() != -1 )
    return v2;
  sub_93F84(
    (_DWORD *)((char *)v10 + *(_DWORD *)(*v10 - 12)),
    *(_DWORD *)((char *)v10 + *(_DWORD *)(*v10 - 12) + 20) | 1);
  return v2;
}

//----- (000B6D9C) --------------------------------------------------------
_DWORD *__fastcall sub_B6D9C(_DWORD *a1, char a2)
{
  _DWORD *v2; // r5
  char v3; // r7
  int v4; // r4
  _BYTE *v5; // r6
  char v6; // r0

  v2 = a1;
  v3 = a2;
  v4 = (int)a1 + *(_DWORD *)(*a1 - 12);
  if ( !*(_BYTE *)(v4 + 117) )
  {
    v5 = *(_BYTE **)(v4 + 124);
    if ( !v5 )
      sub_BFA38();
    if ( v5[28] )
    {
      v6 = v5[61];
    }
    else
    {
      sub_AA9D0(*(_DWORD *)(v4 + 124));
      v6 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v5 + 24))(v5, 32);
    }
    *(_BYTE *)(v4 + 116) = v6;
    *(_BYTE *)(v4 + 117) = 1;
  }
  *(_BYTE *)(v4 + 116) = v3;
  return v2;
}

//----- (000B6E58) --------------------------------------------------------
int *__fastcall sub_B6E58(int *a1, int a2, int a3)
{
  int *v3; // r4
  int v4; // r7
  int v5; // r5
  int v6; // r10
  unsigned int v7; // r0
  _BOOL4 v8; // r11
  int v9; // r3
  int v10; // r7
  _BYTE *v11; // r6
  char v12; // r0
  int v13; // r3
  char v14; // r6
  int v15; // r3
  int v16; // r0
  _BYTE *v17; // r2
  int v18; // r5
  int v19; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r3
  int v24; // r6
  _BYTE *v25; // r9
  char v26; // r0
  int v27; // r3
  char v28; // r9
  int v29; // r0
  _BYTE *v30; // r3
  char v31; // [sp+8h] [bp-30h]
  _DWORD *v32; // [sp+Ch] [bp-2Ch]

  v3 = a1;
  v4 = a3;
  sub_B69EC((int)&v31, a1);
  if ( v31 )
  {
    v5 = (int)v3 + *(_DWORD *)(*v3 - 12);
    v6 = *(_DWORD *)(v5 + 8);
    if ( v6 <= v4 )
    {
      v21 = (*(int (**)(void))(**(_DWORD **)(v5 + 120) + 48))();
      v15 = *v3;
      if ( v4 != v21 )
      {
LABEL_21:
        sub_93F84((int *)((char *)v3 + *(_DWORD *)(v15 - 12)), *(int *)((char *)v3 + *(_DWORD *)(v15 - 12) + 20) | 1);
        v15 = *v3;
      }
LABEL_22:
      v9 = (int)v3 + *(_DWORD *)(v15 - 12);
    }
    else
    {
      v7 = (*(_DWORD *)(v5 + 12) & 0xB0) - 32;
      v8 = v7 <= 0;
      if ( v7 > 0 )
      {
        v24 = v6 - v4;
        if ( *(_BYTE *)(v5 + 117) )
        {
          v28 = *(_BYTE *)(v5 + 116);
          v9 = (int)v3 + *(_DWORD *)(*v3 - 12);
        }
        else
        {
          v25 = *(_BYTE **)(v5 + 124);
          if ( !v25 )
            sub_BFA38();
          if ( v25[28] )
          {
            v26 = v25[61];
          }
          else
          {
            sub_AA9D0(*(_DWORD *)(v5 + 124));
            v26 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v25 + 24))(v25, 32);
          }
          *(_BYTE *)(v5 + 116) = v26;
          v27 = *v3;
          v28 = v26;
          *(_BYTE *)(v5 + 117) = 1;
          v5 = (int)v3 + *(_DWORD *)(v27 - 12);
          v9 = (int)v3 + *(_DWORD *)(v27 - 12);
        }
        if ( v24 <= 0 )
          goto LABEL_5;
        do
        {
          v29 = *(_DWORD *)(v5 + 120);
          v30 = *(_BYTE **)(v29 + 20);
          if ( (unsigned int)v30 >= *(_DWORD *)(v29 + 24) )
          {
            if ( sub_25EA8(v29) == -1 )
            {
              sub_93F84(
                (int *)((char *)v3 + *(_DWORD *)(*v3 - 12)),
                *(int *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | 1);
              v5 = (int)v3 + *(_DWORD *)(*v3 - 12);
              v9 = (int)v3 + *(_DWORD *)(*v3 - 12);
              goto LABEL_5;
            }
          }
          else
          {
            *v30 = v28;
            ++*(_DWORD *)(v29 + 20);
          }
          --v24;
          v5 = (int)v3 + *(_DWORD *)(*v3 - 12);
        }
        while ( v24 );
      }
      v9 = v5;
LABEL_5:
      if ( !*(_DWORD *)(v5 + 20) )
      {
        v22 = (*(int (**)(void))(**(_DWORD **)(v5 + 120) + 48))();
        v23 = *v3;
        if ( v4 != v22 )
        {
          sub_93F84((int *)((char *)v3 + *(_DWORD *)(v23 - 12)), *(int *)((char *)v3 + *(_DWORD *)(v23 - 12) + 20) | 1);
          v23 = *v3;
        }
        v5 = (int)v3 + *(_DWORD *)(v23 - 12);
        v9 = (int)v3 + *(_DWORD *)(v23 - 12);
      }
      if ( v8 && !*(_DWORD *)(v5 + 20) )
      {
        v10 = v6 - v4;
        if ( *(_BYTE *)(v5 + 117) )
        {
          v14 = *(_BYTE *)(v5 + 116);
        }
        else
        {
          v11 = *(_BYTE **)(v5 + 124);
          if ( !v11 )
            sub_BFA38();
          if ( v11[28] )
          {
            v12 = v11[61];
          }
          else
          {
            sub_AA9D0(*(_DWORD *)(v5 + 124));
            v12 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v11 + 24))(v11, 32);
          }
          *(_BYTE *)(v5 + 116) = v12;
          v13 = *v3;
          v14 = v12;
          *(_BYTE *)(v5 + 117) = 1;
          v5 = (int)v3 + *(_DWORD *)(v13 - 12);
          v9 = (int)v3 + *(_DWORD *)(v13 - 12);
        }
        if ( v10 > 0 )
        {
          while ( 1 )
          {
            v16 = *(_DWORD *)(v5 + 120);
            v17 = *(_BYTE **)(v16 + 20);
            if ( (unsigned int)v17 < *(_DWORD *)(v16 + 24) )
            {
              *v17 = v14;
              ++*(_DWORD *)(v16 + 20);
            }
            else if ( sub_25EA8(v16) == -1 )
            {
              v15 = *v3;
              goto LABEL_21;
            }
            --v10;
            v15 = *v3;
            if ( !v10 )
              goto LABEL_22;
            v5 = (int)v3 + *(_DWORD *)(v15 - 12);
          }
        }
      }
    }
    *(_DWORD *)(v9 + 8) = 0;
  }
  v18 = (int)v32 + *(_DWORD *)(*v32 - 12);
  if ( !(*(_DWORD *)(v18 + 12) & 0x2000) )
    return v3;
  if ( std::uncaught_exception() )
    return v3;
  v19 = *(_DWORD *)(v18 + 120);
  if ( !v19 || (*(int (**)(void))(*(_DWORD *)v19 + 24))() != -1 )
    return v3;
  sub_93F84(
    (_DWORD *)((char *)v32 + *(_DWORD *)(*v32 - 12)),
    *(_DWORD *)((char *)v32 + *(_DWORD *)(*v32 - 12) + 20) | 1);
  return v3;
}

//----- (000B70E8) --------------------------------------------------------
int *__fastcall sub_B70E8(int *a1, char a2)
{
  char v3; // [sp+7h] [bp-9h]

  v3 = a2;
  return sub_B6E58(a1, (int)&v3, 1);
}

//----- (000B7130) --------------------------------------------------------
int *__fastcall sub_B7130(int *a1, const char *a2)
{
  int *v2; // r5
  int v3; // r4
  int v4; // r0

  v2 = a1;
  v3 = (int)a2;
  if ( a2 )
  {
    v4 = strlen(a2);
    sub_B6E58(v2, v3, v4);
  }
  else
  {
    sub_93F84((int *)((char *)a1 + *(_DWORD *)(*a1 - 12)), *(int *)((char *)a1 + *(_DWORD *)(*a1 - 12) + 20) | 1);
  }
  return v2;
}

//----- (000B71CC) --------------------------------------------------------
int *__fastcall sub_B71CC(int *a1, int a2)
{
  int *v2; // r4
  int v3; // r10
  int v4; // r5
  int *v5; // r6
  int v6; // r7
  _BYTE *v7; // r8
  int v8; // r0
  int v9; // r3
  int v10; // lr
  int v11; // r5
  int v12; // r0
  char v14; // [sp+10h] [bp-40h]
  _DWORD *v15; // [sp+14h] [bp-3Ch]
  char v16; // [sp+18h] [bp-38h]
  char v17; // [sp+1Ch] [bp-34h]
  int v18; // [sp+20h] [bp-30h]
  bool v19; // [sp+24h] [bp-2Ch]

  v2 = a1;
  v3 = a2;
  sub_B69EC((int)&v14, a1);
  if ( v14 )
  {
    v4 = (int)v2 + *(_DWORD *)(*v2 - 12);
    v5 = *(int **)(v4 + 128);
    if ( !v5 )
      sub_BFA38();
    v6 = *(_DWORD *)(v4 + 120);
    if ( *(_BYTE *)(v4 + 117) )
    {
      v9 = *(unsigned __int8 *)(v4 + 116);
    }
    else
    {
      v7 = *(_BYTE **)(v4 + 124);
      if ( !v7 )
        sub_BFA38();
      if ( v7[28] )
      {
        v8 = (unsigned __int8)v7[61];
      }
      else
      {
        sub_AA9D0(*(_DWORD *)(v4 + 124));
        v8 = (*(int (__fastcall **)(_BYTE *, signed int))(*(_DWORD *)v7 + 24))(v7, 32);
      }
      v9 = v8;
      *(_BYTE *)(v4 + 116) = v8;
      *(_BYTE *)(v4 + 117) = 1;
    }
    v10 = *v5;
    v18 = v6;
    v19 = v6 == 0;
    (*(void (__fastcall **)(char *, int *, int, _DWORD, int, int, int))(v10 + 12))(
      &v16,
      v5,
      v6,
      *(_DWORD *)&v19,
      v4,
      v9,
      v3);
    if ( v17 )
      sub_93F84((int *)((char *)v2 + *(_DWORD *)(*v2 - 12)), *(int *)((char *)v2 + *(_DWORD *)(*v2 - 12) + 20) | 1);
  }
  v11 = (int)v15 + *(_DWORD *)(*v15 - 12);
  if ( !(*(_DWORD *)(v11 + 12) & 0x2000) )
    return v2;
  if ( std::uncaught_exception() )
    return v2;
  v12 = *(_DWORD *)(v11 + 120);
  if ( !v12 || (*(int (**)(void))(*(_DWORD *)v12 + 24))() != -1 )
    return v2;
  sub_93F84(
    (_DWORD *)((char *)v15 + *(_DWORD *)(*v15 - 12)),
    *(_DWORD *)((char *)v15 + *(_DWORD *)(*v15 - 12) + 20) | 1);
  return v2;
}

//----- (000B7E9C) --------------------------------------------------------
_DWORD *__fastcall sub_B7E9C(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12) + 124);
  if ( v2 && (*(int (**)(void))(*(_DWORD *)v2 + 24))() == -1 )
    sub_94410((_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12)), *(_DWORD *)((char *)v1 + *(_DWORD *)(*v1 - 12) + 20) | 1);
  return v1;
}

//----- (000B81D8) --------------------------------------------------------
_BYTE *__fastcall sub_B81D8(int a1, _DWORD *a2)
{
  _BYTE *v2; // r4
  int v3; // r3
  _DWORD *v4; // r5
  _DWORD *v5; // r3
  _DWORD *v6; // r0
  int v7; // r1
  _BYTE *result; // r0

  v2 = (_BYTE *)a1;
  v3 = *a2;
  *(_DWORD *)(a1 + 4) = a2;
  v4 = a2;
  *(_BYTE *)a1 = 0;
  v5 = (_DWORD *)((char *)a2 + *(_DWORD *)(v3 - 12));
  v6 = (_DWORD *)v5[28];
  if ( v6 )
  {
    v7 = v5[5];
    if ( v7 )
      goto LABEL_6;
    sub_B7E9C(v6);
    v5 = (_DWORD *)((char *)v4 + *(_DWORD *)(*v4 - 12));
  }
  v7 = v5[5];
  if ( !v7 )
  {
    result = v2;
    *v2 = 1;
    return result;
  }
LABEL_6:
  sub_94410(v5, v7 | 4);
  return v2;
}

//----- (000B821C) --------------------------------------------------------
int __fastcall sub_B821C(int a1)
{
  int v1; // r4
  int v2; // r5
  int v3; // r0
  _DWORD *v5; // r0

  v1 = a1;
  v2 = *(_DWORD *)(**(_DWORD **)(a1 + 4) - 12) + *(_DWORD *)(a1 + 4);
  if ( !(*(_DWORD *)(v2 + 12) & 0x2000) )
    return v1;
  if ( std::uncaught_exception() )
    return v1;
  v3 = *(_DWORD *)(v2 + 124);
  if ( !v3 || (*(int (**)(void))(*(_DWORD *)v3 + 24))() != -1 )
    return v1;
  v5 = (_DWORD *)(*(_DWORD *)(**(_DWORD **)(v1 + 4) - 12) + *(_DWORD *)(v1 + 4));
  sub_94410(v5, v5[5] | 1);
  return v1;
}

//----- (000B8350) --------------------------------------------------------
_DWORD *__fastcall sub_B8350(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r0
  int *v5; // r2
  int v6; // r5
  int v7; // r0
  char v9; // [sp+0h] [bp-18h]
  _DWORD *v10; // [sp+4h] [bp-14h]

  v2 = a1;
  v3 = a2;
  sub_B81D8((int)&v9, a1);
  if ( v9 )
  {
    v4 = *(_DWORD *)((char *)v2 + *(_DWORD *)(*v2 - 12) + 124);
    v5 = *(int **)(v4 + 20);
    if ( (unsigned int)v5 >= *(_DWORD *)(v4 + 24) )
    {
      v3 = sub_25EB4(v4);
    }
    else
    {
      *v5 = v3;
      *(_DWORD *)(v4 + 20) = v5 + 1;
    }
    if ( v3 == -1 )
      sub_94410(
        (_DWORD *)((char *)v2 + *(_DWORD *)(*v2 - 12)),
        *(_DWORD *)((char *)v2 + *(_DWORD *)(*v2 - 12) + 20) | 1);
  }
  v6 = (int)v10 + *(_DWORD *)(*v10 - 12);
  if ( !(*(_DWORD *)(v6 + 12) & 0x2000) )
    return v2;
  if ( std::uncaught_exception() )
    return v2;
  v7 = *(_DWORD *)(v6 + 124);
  if ( !v7 || (*(int (**)(void))(*(_DWORD *)v7 + 24))() != -1 )
    return v2;
  sub_94410(
    (_DWORD *)((char *)v10 + *(_DWORD *)(*v10 - 12)),
    *(_DWORD *)((char *)v10 + *(_DWORD *)(*v10 - 12) + 20) | 1);
  return v2;
}

//----- (000B861C) --------------------------------------------------------
int *__fastcall sub_B861C(int *a1, int a2, int a3)
{
  int *v3; // r4
  int v4; // r8
  int v5; // r5
  int v6; // r10
  unsigned int v7; // r0
  _BOOL4 v8; // r11
  int v9; // r3
  int v10; // r8
  int v11; // r6
  int v12; // r3
  int *v13; // r2
  int v14; // r0
  int v15; // r3
  int v16; // r5
  int v17; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r3
  int v22; // r6
  int v23; // r7
  int v24; // r3
  int *v25; // r2
  int v26; // r0
  int v27; // r3
  int v28; // r0
  int v29; // r0
  int v30; // r3
  int v31; // r0
  int v32; // r0
  int v33; // r3
  char v34; // [sp+8h] [bp-30h]
  _DWORD *v35; // [sp+Ch] [bp-2Ch]

  v3 = a1;
  v4 = a3;
  sub_B81D8((int)&v34, a1);
  if ( v34 )
  {
    v5 = (int)v3 + *(_DWORD *)(*v3 - 12);
    v6 = *(_DWORD *)(v5 + 8);
    if ( v6 <= v4 )
    {
      v19 = (*(int (**)(void))(**(_DWORD **)(v5 + 124) + 48))();
      v15 = *v3;
      if ( v4 == v19 )
        goto LABEL_18;
    }
    else
    {
      v7 = (*(_DWORD *)(v5 + 12) & 0xB0) - 32;
      v8 = v7 <= 0;
      if ( v7 > 0 )
      {
        v22 = v6 - v4;
        if ( *(_BYTE *)(v5 + 120) )
        {
          v23 = *(_DWORD *)(v5 + 116);
          v9 = (int)v3 + *(_DWORD *)(*v3 - 12);
        }
        else
        {
          v28 = *(_DWORD *)(v5 + 128);
          if ( !v28 )
            sub_BFA38();
          v29 = (*(int (**)(void))(*(_DWORD *)v28 + 40))();
          v30 = *v3;
          *(_DWORD *)(v5 + 116) = v29;
          v23 = v29;
          *(_BYTE *)(v5 + 120) = 1;
          v5 = (int)v3 + *(_DWORD *)(v30 - 12);
          v9 = (int)v3 + *(_DWORD *)(v30 - 12);
        }
        if ( v22 > 0 )
        {
          while ( 1 )
          {
            v24 = *(_DWORD *)(v5 + 124);
            v25 = *(int **)(v24 + 20);
            if ( (unsigned int)v25 >= *(_DWORD *)(v24 + 24) )
            {
              v26 = sub_25EB4(*(_DWORD *)(v5 + 124));
            }
            else
            {
              v26 = v23;
              *v25 = v23;
              *(_DWORD *)(v24 + 20) = v25 + 1;
            }
            v27 = *v3;
            if ( v26 == -1 )
              break;
            --v22;
            v5 = (int)v3 + *(_DWORD *)(v27 - 12);
            if ( !v22 )
              goto LABEL_4;
          }
          sub_94410((int *)((char *)v3 + *(_DWORD *)(v27 - 12)), *(int *)((char *)v3 + *(_DWORD *)(v27 - 12) + 20) | 1);
          v5 = (int)v3 + *(_DWORD *)(*v3 - 12);
          v9 = (int)v3 + *(_DWORD *)(*v3 - 12);
        }
      }
      else
      {
LABEL_4:
        v9 = v5;
      }
      if ( !*(_DWORD *)(v5 + 20) )
      {
        v20 = (*(int (**)(void))(**(_DWORD **)(v5 + 124) + 48))();
        v21 = *v3;
        if ( v4 != v20 )
        {
          sub_94410((int *)((char *)v3 + *(_DWORD *)(v21 - 12)), *(int *)((char *)v3 + *(_DWORD *)(v21 - 12) + 20) | 1);
          v21 = *v3;
        }
        v5 = (int)v3 + *(_DWORD *)(v21 - 12);
        v9 = (int)v3 + *(_DWORD *)(v21 - 12);
      }
      if ( !v8 || *(_DWORD *)(v5 + 20) )
        goto LABEL_19;
      v10 = v6 - v4;
      if ( *(_BYTE *)(v5 + 120) )
      {
        v11 = *(_DWORD *)(v5 + 116);
      }
      else
      {
        v31 = *(_DWORD *)(v5 + 128);
        if ( !v31 )
          sub_BFA38();
        v32 = (*(int (**)(void))(*(_DWORD *)v31 + 40))();
        v33 = *v3;
        *(_DWORD *)(v5 + 116) = v32;
        v11 = v32;
        *(_BYTE *)(v5 + 120) = 1;
        v5 = (int)v3 + *(_DWORD *)(v33 - 12);
        v9 = (int)v3 + *(_DWORD *)(v33 - 12);
      }
      if ( v10 <= 0 )
        goto LABEL_19;
      while ( 1 )
      {
        v12 = *(_DWORD *)(v5 + 124);
        v13 = *(int **)(v12 + 20);
        if ( (unsigned int)v13 >= *(_DWORD *)(v12 + 24) )
        {
          v14 = sub_25EB4(*(_DWORD *)(v5 + 124));
        }
        else
        {
          v14 = v11;
          *v13 = v11;
          *(_DWORD *)(v12 + 20) = v13 + 1;
        }
        v15 = *v3;
        if ( v14 == -1 )
          break;
        if ( !--v10 )
          goto LABEL_18;
        v5 = (int)v3 + *(_DWORD *)(v15 - 12);
      }
    }
    sub_94410((int *)((char *)v3 + *(_DWORD *)(v15 - 12)), *(int *)((char *)v3 + *(_DWORD *)(v15 - 12) + 20) | 1);
    v15 = *v3;
LABEL_18:
    v9 = (int)v3 + *(_DWORD *)(v15 - 12);
LABEL_19:
    *(_DWORD *)(v9 + 8) = 0;
  }
  v16 = (int)v35 + *(_DWORD *)(*v35 - 12);
  if ( !(*(_DWORD *)(v16 + 12) & 0x2000) )
    return v3;
  if ( std::uncaught_exception() )
    return v3;
  v17 = *(_DWORD *)(v16 + 124);
  if ( !v17 || (*(int (**)(void))(*(_DWORD *)v17 + 24))() != -1 )
    return v3;
  sub_94410(
    (_DWORD *)((char *)v35 + *(_DWORD *)(*v35 - 12)),
    *(_DWORD *)((char *)v35 + *(_DWORD *)(*v35 - 12) + 20) | 1);
  return v3;
}

//----- (000B96FC) --------------------------------------------------------
signed int __fastcall sub_B96FC(int *a1, wchar_t *a2, unsigned int a3, unsigned int a4)
{
  int v4; // r6
  unsigned int v5; // r5
  size_t v6; // r4
  signed int result; // r0

  v4 = *a1;
  v5 = *(_DWORD *)(*a1 - 12);
  if ( a4 > v5 )
    sub_BFC08("basic_string::copy");
  v6 = v5 - a4;
  if ( v5 - a4 >= a3 )
    v6 = a3;
  if ( !v6 )
    return v6;
  if ( v6 != 1 )
  {
    wmemcpy(a2, (const wchar_t *)(v4 + 4 * a4), v6);
    return v6;
  }
  result = 1;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4 * a4);
  return result;
}

//----- (000B9740) --------------------------------------------------------
int *__fastcall sub_B9740(int *result, int *a2)
{
  int v2; // r2
  int v3; // r3

  v2 = *result;
  if ( *(_DWORD *)(*result - 4) < 0 )
    *(_DWORD *)(v2 - 4) = 0;
  v3 = *a2;
  if ( *(_DWORD *)(*a2 - 4) < 0 )
    *(_DWORD *)(v3 - 4) = 0;
  *result = v3;
  *a2 = v2;
  return result;
}

//----- (000B978C) --------------------------------------------------------
int __fastcall sub_B978C(int *a1, int a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v4; // r8
  int v5; // r5
  unsigned int v6; // r0
  int result; // r0
  unsigned int v8; // r11
  const wchar_t *v9; // r5
  int v10; // r4
  size_t v11; // r10
  const wchar_t *v12; // r9
  int v13; // t1
  unsigned int v14; // r6

  v4 = (_DWORD *)a2;
  v5 = *a1;
  v6 = *(_DWORD *)(*a1 - 12);
  if ( a4 )
  {
    if ( a4 > v6 || (v8 = v6 - a4, v6 - a4 < a3) )
    {
LABEL_7:
      result = -1;
    }
    else
    {
      v9 = (const wchar_t *)(v5 + 4 * a3);
      v10 = a3 + 1;
      v11 = a4 - 1;
      v12 = (const wchar_t *)(a2 + 4);
      while ( 1 )
      {
        v13 = *(_DWORD *)v9;
        v9 += 2;
        v14 = v10;
        if ( v13 == *v4 && !wmemcmp(v9, v12, v11) )
          break;
        ++v10;
        if ( v8 < v14 )
          goto LABEL_7;
      }
      result = v10 - 1;
    }
  }
  else if ( a3 > v6 )
  {
    result = -1;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (000B984C) --------------------------------------------------------
signed int __fastcall sub_B984C(_DWORD *a1, const wchar_t *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r7
  const wchar_t *v5; // r8
  size_t v6; // r3
  int v8; // r4
  int v9; // r5
  const wchar_t *v10; // r0

  v4 = a4;
  v5 = a2;
  v6 = *(_DWORD *)(*a1 - 12);
  if ( v4 > v6 )
    return -1;
  v8 = v6 - v4;
  if ( v6 - v4 >= a3 )
    v8 = a3;
  v9 = *a1 + 4 * v8;
  while ( 1 )
  {
    v10 = (const wchar_t *)v9;
    v9 -= 4;
    if ( !wmemcmp(v10, v5, v4) )
      break;
    if ( !v8 )
      return -1;
    --v8;
  }
  return v8;
}

//----- (000B98FC) --------------------------------------------------------
signed int __fastcall sub_B98FC(int *a1, const wchar_t *a2, unsigned int a3, size_t a4)
{
  int *v4; // r7
  const wchar_t *v5; // r10
  unsigned int v6; // r4
  size_t v7; // r6
  int v8; // r5
  int v9; // r8
  int v10; // r1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( !a4 )
    return -1;
  v8 = *a1;
  if ( a3 >= *(_DWORD *)(*a1 - 12) )
    return -1;
  v9 = 4 * a3;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v8 + v9);
    v9 += 4;
    if ( wmemchr(v5, v10, v7) )
      break;
    v8 = *v4;
    if ( ++v6 >= *(_DWORD *)(*v4 - 12) )
      return -1;
  }
  return v6;
}

//----- (000B9974) --------------------------------------------------------
signed int __fastcall sub_B9974(int *a1, const wchar_t *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r7
  int v5; // r6
  int *v6; // r8
  const wchar_t *v7; // r9
  int v8; // r3
  bool v9; // zf
  int v11; // r5
  int v12; // r4
  int v13; // r1

  v4 = a4;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = *(_DWORD *)(*a1 - 12);
  v9 = v4 == 0;
  if ( v4 )
    v9 = v8 == 0;
  if ( v9 )
    return -1;
  v11 = v8 - 1;
  if ( a3 < v8 - 1 )
    v11 = a3;
  v12 = 4 * v11;
  while ( 1 )
  {
    v13 = *(_DWORD *)(v5 + v12);
    v12 -= 4;
    if ( wmemchr(v7, v13, v4) )
      break;
    if ( !v11 )
      return -1;
    v5 = *v6;
    --v11;
  }
  return v11;
}

//----- (000B99F0) --------------------------------------------------------
signed int __fastcall sub_B99F0(int *a1, const wchar_t *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r10
  int v5; // r5
  int *v6; // r8
  const wchar_t *v7; // r9
  unsigned int v8; // r4
  int v9; // r6
  int v10; // r1

  v4 = a4;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = a3;
  if ( a3 >= *(_DWORD *)(*a1 - 12) )
    return -1;
  v9 = 4 * a3;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v5 + v9);
    v9 += 4;
    if ( !wmemchr(v7, v10, v4) )
      break;
    v5 = *v6;
    if ( ++v8 >= *(_DWORD *)(*v6 - 12) )
      return -1;
  }
  return v8;
}

//----- (000B9AA0) --------------------------------------------------------
signed int __fastcall sub_B9AA0(int *a1, const wchar_t *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r9
  int v5; // r6
  int *v6; // r7
  const wchar_t *v7; // r8
  int v8; // r3
  int v10; // r5
  int v11; // r4
  int v12; // r1

  v4 = a4;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = *(_DWORD *)(*a1 - 12);
  if ( !v8 )
    return -1;
  v10 = v8 - 1;
  if ( a3 < v8 - 1 )
    v10 = a3;
  v11 = 4 * v10;
  while ( 1 )
  {
    v12 = *(_DWORD *)(v5 + v11);
    v11 -= 4;
    if ( !wmemchr(v7, v12, v4) )
      break;
    if ( !v10 )
      return -1;
    v5 = *v6;
    --v10;
  }
  return v10;
}

//----- (000B9D00) --------------------------------------------------------
_DWORD *__fastcall sub_B9D00(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // r4
  unsigned int v3; // r0
  _BOOL4 v4; // r5
  _DWORD *result; // r0

  v2 = a1;
  if ( a1 > 0xFFFFFFE )
    sub_BFBAC((int)"basic_string::_S_create");
  if ( a1 <= a2 )
    goto LABEL_10;
  if ( a1 < 2 * a2 )
    v2 = 2 * a2;
  v3 = 4 * (v2 + 4);
  v4 = v3 + 16 > 0x1000;
  if ( a2 >= v2 )
    v4 = 0;
  if ( v4 )
  {
    v2 += (4096 - (((_WORD)v3 + 16) & 0xFFFu)) >> 2;
    if ( v2 >= 0xFFFFFFE )
      v2 = 268435454;
LABEL_10:
    v3 = 4 * (v2 + 4);
  }
  result = operator new(v3);
  result[1] = v2;
  result[2] = 0;
  return result;
}

//----- (000B9D64) --------------------------------------------------------
void *__fastcall sub_B9D64(unsigned int a1, int a2)
{
  int v2; // r7
  size_t v3; // r5
  int v4; // r4
  _DWORD *v6; // r0
  _DWORD *v7; // r6

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return &unk_2FEF30;
  v6 = sub_B9D00(a1, 0);
  v7 = v6;
  v4 = (int)(v6 + 3);
  if ( v3 == 1 )
    v6[3] = v2;
  else
    wmemset((wchar_t *)v6 + 6, v2, v3);
  if ( v7 != (_DWORD *)&unk_2FEF24 )
    sub_25EC0(v7, v3);
  return (void *)v4;
}

//----- (000B9DC4) --------------------------------------------------------
void **__fastcall sub_B9DC4(void **a1, unsigned int a2, int a3)
{
  void **v3; // r4

  v3 = a1;
  *a1 = sub_B9D64(a2, a3);
  return v3;
}

//----- (000B9DE0) --------------------------------------------------------
void __fastcall sub_B9DE0(unsigned int *a1)
{
  if ( &unk_2FEF24 != (_UNKNOWN *)a1 )
    sub_25ED0(a1);
}

//----- (000B9E18) --------------------------------------------------------
wchar_t *__fastcall sub_B9E18(const wchar_t **a1, size_t a2, int a3, int a4)
{
  const wchar_t **v4; // r7
  const wchar_t *v5; // r4
  size_t v6; // r5
  int v7; // r6
  int v8; // r9
  int v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // r8
  size_t v12; // r10
  _DWORD *v13; // r0
  const wchar_t *v14; // r3
  wchar_t *result; // r0
  int v16; // r9
  int v17; // r5
  bool v18; // zf
  int v19; // r9
  int v20; // r5

  v4 = a1;
  v5 = *a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v9 = *((_DWORD *)*a1 - 3);
  v10 = *((_DWORD *)v5 - 2);
  v11 = a4 - a3 + v9;
  v12 = v9 - v6 - a3;
  if ( v11 > v10 || *((_DWORD *)v5 - 1) > 0 )
  {
    v13 = sub_B9D00(v11, v10);
    v14 = *v4;
    v5 = (const wchar_t *)(v13 + 3);
    if ( v6 )
    {
      if ( v6 != 1 )
      {
        wmemcpy((wchar_t *)v13 + 6, *v4, v6);
        v14 = *v4;
        if ( !v12 )
          goto LABEL_7;
        goto LABEL_13;
      }
      v13[3] = *(_DWORD *)v14;
    }
    if ( !v12 )
    {
LABEL_7:
      if ( v14 - 6 != (const wchar_t *)&unk_2FEF24 )
        sub_25ED0((unsigned int *)v14 - 3);
      *v4 = v5;
      goto LABEL_10;
    }
LABEL_13:
    v16 = v8 + v6;
    v17 = v6 + v7;
    if ( v12 == 1 )
    {
      *(_DWORD *)&v5[2 * v16] = *(_DWORD *)&v14[2 * v17];
    }
    else
    {
      wmemcpy((wchar_t *)&v5[2 * v16], &v14[2 * v17], v12);
      v14 = *v4;
    }
    goto LABEL_7;
  }
  v18 = a3 == a4;
  if ( a3 != a4 )
    v18 = v9 - v6 == a3;
  if ( !v18 )
  {
    v19 = a4 + v6;
    v20 = v6 + a3;
    if ( v12 == 1 )
    {
      *(_DWORD *)&v5[2 * v19] = *(_DWORD *)&v5[2 * v20];
    }
    else
    {
      wmemmove((wchar_t *)&v5[2 * v19], &v5[2 * v20], v12);
      v5 = *v4;
    }
  }
LABEL_10:
  result = (wchar_t *)(v5 - 6);
  if ( v5 - 6 != (const wchar_t *)&unk_2FEF24 )
    result = (wchar_t *)sub_25EC0(result, v11);
  return result;
}

//----- (000B9F10) --------------------------------------------------------
const wchar_t **__fastcall sub_B9F10(const wchar_t **result)
{
  const wchar_t *v1; // r3
  const wchar_t **v2; // r4

  v1 = *result;
  v2 = result;
  if ( *result - 6 != (const wchar_t *)&unk_2FEF24 )
  {
    if ( *((_DWORD *)v1 - 1) > 0 )
    {
      result = (const wchar_t **)sub_B9E18(result, 0, 0, 0);
      v1 = *v2;
    }
    *((_DWORD *)v1 - 1) = -1;
  }
  return result;
}

//----- (000BA0E8) --------------------------------------------------------
_DWORD *__fastcall sub_BA0E8(int c, size_t a2, int a3, unsigned int a4, int ca)
{
  _DWORD *v5; // r6
  size_t v6; // r8
  size_t v7; // r5
  _DWORD *result; // r0

  v5 = (_DWORD *)c;
  v6 = a2;
  v7 = a4;
  if ( a4 > 268435454 - *(_DWORD *)(*(_DWORD *)c - 12) + a3 )
    sub_BFBAC((int)"basic_string::_M_replace_aux");
  sub_B9E18((const wchar_t **)c, a2, a3, a4);
  if ( !v7 )
    return v5;
  if ( v7 != 1 )
  {
    wmemset((wchar_t *)(*v5 + 4 * v6), ca, v7);
    return v5;
  }
  result = v5;
  *(_DWORD *)(*v5 + 4 * v6) = ca;
  return result;
}

//----- (000BA228) --------------------------------------------------------
const wchar_t **__fastcall sub_BA228(const wchar_t **a1, size_t a2, int a3, const wchar_t *a4, size_t a5)
{
  const wchar_t *v5; // r7
  const wchar_t **v6; // r5
  size_t v7; // r6
  const wchar_t **result; // r0

  v5 = a4;
  v6 = a1;
  v7 = a2;
  sub_B9E18(a1, a2, a3, a5);
  if ( !a5 )
    return v6;
  if ( a5 != 1 )
  {
    wmemcpy((wchar_t *)&(*v6)[2 * v7], v5, a5);
    return v6;
  }
  result = v6;
  *(_DWORD *)&(*v6)[2 * v7] = *(_DWORD *)v5;
  return result;
}

//----- (000BA25C) --------------------------------------------------------
const wchar_t **__fastcall sub_BA25C(const wchar_t **a1, const wchar_t *a2, size_t a3)
{
  wchar_t **v3; // r5
  wchar_t *v4; // r4
  int v5; // r6
  int v6; // r7
  unsigned int v8; // r0

  v3 = (wchar_t **)a1;
  v4 = (wchar_t *)*a1;
  v5 = a3;
  v6 = *((_DWORD *)*a1 - 3);
  if ( a3 > 0xFFFFFFE )
    sub_BFBAC((int)"basic_string::assign");
  if ( a2 < v4 || a2 > &v4[2 * v6] || *((_DWORD *)v4 - 1) > 0 )
    return sub_BA228(a1, 0, v6, a2, a3);
  v8 = ((char *)a2 - (char *)v4) >> 2;
  if ( a3 > v8 )
  {
    if ( !v8 )
      goto LABEL_10;
    if ( a3 != 1 )
    {
      wmemmove(v4, a2, a3);
      v4 = *v3;
      goto LABEL_10;
    }
LABEL_16:
    *(_DWORD *)v4 = *(_DWORD *)a2;
    goto LABEL_10;
  }
  if ( a3 == 1 )
    goto LABEL_16;
  wmemcpy(v4, a2, a3);
  v4 = *v3;
LABEL_10:
  if ( v4 - 6 != (wchar_t *)&unk_2FEF24 )
    sub_25EC0((_DWORD *)v4 - 3, v5);
  return (const wchar_t **)v3;
}

//----- (000BA38C) --------------------------------------------------------
const wchar_t **__fastcall sub_BA38C(const wchar_t **a1, size_t a2, const wchar_t *a3, unsigned int a4)
{
  const wchar_t *v4; // r8
  const wchar_t *v5; // r6
  const wchar_t **v6; // r7
  size_t v7; // r9
  size_t v8; // r5
  size_t v9; // r2
  const wchar_t **result; // r0
  int v11; // r10
  int v12; // r6
  const wchar_t *v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // r4
  int v16; // r11

  v4 = a3;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = a4;
  v9 = *((_DWORD *)*a1 - 3);
  if ( a2 > v9 )
    sub_BFC08("basic_string::insert");
  if ( a4 > 268435454 - v9 )
    sub_BFBAC((int)"basic_string::insert");
  if ( v4 < v5 || v4 > &v5[2 * v9] || *((_DWORD *)v5 - 1) > 0 )
    return sub_BA228(a1, a2, 0, v4, a4);
  v11 = 4 * a4;
  sub_B9E18(a1, a2, 0, a4);
  v12 = ((char *)v4 - (char *)v5) >> 2;
  v13 = *v6;
  v14 = (unsigned int)&(*v6)[2 * v12];
  v15 = (unsigned int)&(*v6)[2 * v7];
  if ( v15 < v14 + v11 )
  {
    if ( v14 < v15 )
    {
      v16 = (signed int)(v15 - v14) >> 2;
      if ( v16 == 1 )
        *(_DWORD *)&v13[2 * v7] = *(_DWORD *)&v13[2 * v12];
      else
        wmemcpy((wchar_t *)&(*v6)[2 * v7], (const wchar_t *)v14, (signed int)(v15 - v14) >> 2);
      if ( v8 - v16 == 1 )
      {
        result = v6;
        *(_DWORD *)(v15 + 4 * v16) = *(_DWORD *)(v15 + 4 * v8);
      }
      else
      {
        wmemcpy((wchar_t *)(v15 + 4 * v16), (const wchar_t *)(v15 + v11), v8 - v16);
        result = v6;
      }
    }
    else if ( v8 == 1 )
    {
      result = v6;
      *(_DWORD *)&v13[2 * v7] = *(_DWORD *)(v14 + 4);
    }
    else
    {
      wmemcpy((wchar_t *)&(*v6)[2 * v7], (const wchar_t *)(v14 + v11), v8);
      result = v6;
    }
  }
  else if ( v8 == 1 )
  {
    result = v6;
    *(_DWORD *)&v13[2 * v7] = *(_DWORD *)&v13[2 * v12];
  }
  else
  {
    wmemcpy((wchar_t *)&(*v6)[2 * v7], (const wchar_t *)v14, v8);
    result = v6;
  }
  return result;
}

//----- (000BA568) --------------------------------------------------------
int __fastcall sub_BA568(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  size_t v5; // r2
  int v6; // r1
  _DWORD *v7; // r5
  int v8; // r6

  v3 = a1;
  v4 = sub_B9D00(*a1 + a3, a1[1]);
  v5 = *v3;
  v6 = *v3;
  v7 = v4;
  v8 = (int)(v4 + 3);
  if ( *v3 )
  {
    v8 = (int)(v4 + 3);
    if ( v5 == 1 )
      v4[3] = v3[3];
    else
      wmemcpy((wchar_t *)v4 + 6, (const wchar_t *)v3 + 6, v5);
    v6 = *v3;
  }
  if ( v7 != (_DWORD *)&unk_2FEF24 )
    sub_25EC0(v7, v6);
  return v8;
}

//----- (000BA5B8) --------------------------------------------------------
void __fastcall sub_BA5B8(int *a1, unsigned int a2)
{
  int *v2; // r4
  int v3; // r3
  unsigned int v4; // r2
  _DWORD *v5; // r3
  unsigned int v6; // t1
  int v7; // r2
  int v8; // r6
  unsigned int *v9; // r0
  char v10; // [sp+4h] [bp-14h]

  v2 = a1;
  v3 = *a1;
  if ( a2 != *(_DWORD *)(*a1 - 8) || *(_DWORD *)(v3 - 4) > 0 )
  {
    v6 = *(_DWORD *)(v3 - 12);
    v5 = (_DWORD *)(v3 - 12);
    v4 = v6;
    if ( a2 < v6 )
      v7 = 0;
    else
      v7 = a2 - v4;
    v8 = sub_BA568(v5, (int)&v10, v7);
    v9 = (unsigned int *)(*v2 - 12);
    if ( v9 != (unsigned int *)&unk_2FEF24 )
      sub_25ED0(v9);
    *v2 = v8;
  }
}

//----- (000BA638) --------------------------------------------------------
int *__fastcall sub_BA638(int *a1, const wchar_t **a2)
{
  const wchar_t **v2; // r7
  const wchar_t *v3; // r1
  int *v4; // r4
  size_t v5; // r5
  int v6; // r3
  int v7; // r6
  int v8; // r8

  v2 = a2;
  v3 = *a2;
  v4 = a1;
  v5 = *((_DWORD *)v3 - 3);
  if ( v5 )
  {
    v6 = *a1;
    v7 = *(_DWORD *)(*a1 - 12);
    v8 = v7 + v5;
    if ( v7 + v5 > *(_DWORD *)(*a1 - 8) || *(_DWORD *)(v6 - 4) > 0 )
    {
      sub_BA5B8(a1, v7 + v5);
      v6 = *v4;
      v3 = *v2;
      v7 = *(_DWORD *)(*v4 - 12);
    }
    if ( v5 == 1 )
    {
      *(_DWORD *)(v6 + 4 * v7) = *(_DWORD *)v3;
    }
    else
    {
      wmemcpy((wchar_t *)(v6 + 4 * v7), v3, v5);
      v6 = *v4;
    }
    if ( (_UNKNOWN *)(v6 - 12) != &unk_2FEF24 )
      sub_25EC0((_DWORD *)(v6 - 12), v8);
  }
  return v4;
}

//----- (000BA748) --------------------------------------------------------
int *__fastcall sub_BA748(int *a1, unsigned int a2, size_t a3)
{
  int *v3; // r4
  const wchar_t *v4; // r6
  size_t v5; // r5
  unsigned int v6; // r3
  int v7; // r2
  int v8; // r7
  int v10; // r6

  v3 = a1;
  v4 = (const wchar_t *)a2;
  v5 = a3;
  if ( !a3 )
    return v3;
  v6 = *a1;
  v7 = *(_DWORD *)(*a1 - 12);
  if ( v5 > 268435454 - v7 )
    sub_BFBAC((int)"basic_string::append");
  v8 = v5 + v7;
  if ( v5 + v7 > *(_DWORD *)(v6 - 8) )
  {
    if ( a2 < v6 )
      goto LABEL_5;
LABEL_15:
    if ( a2 <= v6 + 4 * v7 )
    {
      v10 = a2 - v6;
      sub_BA5B8(a1, v8);
      v6 = *v3;
      v7 = *(_DWORD *)(*v3 - 12);
      v4 = (const wchar_t *)(*v3 + 4 * (v10 >> 2));
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if ( *(_DWORD *)(v6 - 4) <= 0 )
    goto LABEL_6;
  if ( a2 >= v6 )
    goto LABEL_15;
LABEL_5:
  sub_BA5B8(a1, v8);
  v6 = *v3;
  v7 = *(_DWORD *)(*v3 - 12);
LABEL_6:
  if ( v5 == 1 )
  {
    *(_DWORD *)(v6 + 4 * v7) = *(_DWORD *)v4;
  }
  else
  {
    wmemcpy((wchar_t *)(v6 + 4 * v7), v4, v5);
    v6 = *v3;
  }
  if ( (_UNKNOWN *)(v6 - 12) != &unk_2FEF24 )
    sub_25EC0((_DWORD *)(v6 - 12), v8);
  return v3;
}

//----- (000BA854) --------------------------------------------------------
int *__fastcall sub_BA854(int *a1, unsigned int a2, int a3)
{
  int *v3; // r4
  int v4; // r8
  size_t v5; // r5
  int v6; // r3
  int v7; // r6
  int v8; // r7

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( a2 )
  {
    v6 = *a1;
    v7 = *(_DWORD *)(*a1 - 12);
    if ( a2 > 268435454 - v7 )
      sub_BFBAC((int)"basic_string::append");
    v8 = a2 + v7;
    if ( a2 + v7 > *(_DWORD *)(v6 - 8) || *(_DWORD *)(v6 - 4) > 0 )
    {
      sub_BA5B8(a1, a2 + v7);
      v6 = *v3;
      v7 = *(_DWORD *)(*v3 - 12);
    }
    if ( v5 == 1 )
    {
      *(_DWORD *)(v6 + 4 * v7) = v4;
    }
    else
    {
      wmemset((wchar_t *)(v6 + 4 * v7), v4, v5);
      v6 = *v3;
    }
    if ( (_UNKNOWN *)(v6 - 12) != &unk_2FEF24 )
      sub_25EC0((_DWORD *)(v6 - 12), v8);
  }
  return v3;
}

//----- (000BA8D8) --------------------------------------------------------
int *__fastcall sub_BA8D8(int *result, size_t a2, int a3)
{
  unsigned int v3; // r5

  v3 = *(_DWORD *)(*result - 12);
  if ( a2 > 0xFFFFFFE )
    sub_BFBAC((int)"basic_string::resize");
  if ( a2 > v3 )
    return sub_BA854(result, a2 - v3, a3);
  if ( a2 < v3 )
    result = (int *)sub_B9E18((const wchar_t **)result, a2, v3 - a2, 0);
  return result;
}

//----- (000BA920) --------------------------------------------------------
_DWORD *__fastcall sub_BA920(int *a1, int a2)
{
  int v2; // r3
  int *v3; // r4
  int v4; // r2
  int v5; // r6
  int v6; // r5
  _DWORD *result; // r0

  v2 = *a1;
  v3 = a1;
  v4 = *(_DWORD *)(*a1 - 12);
  v5 = a2;
  v6 = v4 + 1;
  if ( (unsigned int)(v4 + 1) > *(_DWORD *)(*a1 - 8) || *(_DWORD *)(v2 - 4) > 0 )
  {
    sub_BA5B8(a1, v4 + 1);
    v2 = *v3;
    v4 = *(_DWORD *)(*v3 - 12);
  }
  result = (_DWORD *)(v2 - 12);
  *(_DWORD *)(v2 + 4 * v4) = v5;
  if ( (_UNKNOWN *)(v2 - 12) != &unk_2FEF24 )
    result = sub_25EC0(result, v6);
  return result;
}

//----- (000BA9F4) --------------------------------------------------------
int *__fastcall sub_BA9F4(int *a1, int *a2)
{
  int v2; // r3
  int *v3; // r4
  _DWORD *v4; // r0
  int *result; // r0
  unsigned int *v6; // r2
  unsigned int v7; // r0
  char v8; // [sp+4h] [bp-Ch]

  v2 = *a2;
  v3 = a1;
  v4 = (_DWORD *)(*a2 - 12);
  if ( *(_DWORD *)(*a2 - 4) < 0 )
  {
    *v3 = sub_BA568(v4, (int)&v8, 0);
    result = v3;
  }
  else
  {
    if ( v4 != (_DWORD *)&unk_2FEF24 )
    {
      v6 = (unsigned int *)(v2 - 4);
      __dmb(0xFu);
      do
        v7 = __ldrex(v6);
      while ( __strex(v7 + 1, v6) );
      __dmb(0xFu);
    }
    *v3 = v2;
    result = v3;
  }
  return result;
}

//----- (000BAA48) --------------------------------------------------------
int *__fastcall sub_BAA48(int *a1, int *a2)
{
  int v2; // r3
  unsigned int *v3; // r2
  int *v4; // r4
  unsigned int *v5; // r0
  int v6; // r5
  int v8; // r0
  unsigned int *v9; // r2
  unsigned int v10; // r0
  char v11; // [sp+4h] [bp-14h]

  v2 = *a2;
  v3 = (unsigned int *)(*a1 - 12);
  v4 = a1;
  v5 = (unsigned int *)(*a2 - 12);
  if ( v3 != v5 )
  {
    if ( *(_DWORD *)(v2 - 4) < 0 )
    {
      v8 = sub_BA568(v5, (int)&v11, 0);
      v3 = (unsigned int *)(*v4 - 12);
      v6 = v8;
    }
    else
    {
      if ( v5 != (unsigned int *)&unk_2FEF24 )
      {
        v9 = (unsigned int *)(v2 - 4);
        __dmb(0xFu);
        do
          v10 = __ldrex(v9);
        while ( __strex(v10 + 1, v9) );
        __dmb(0xFu);
        v3 = (unsigned int *)(*v4 - 12);
      }
      v6 = v2;
    }
    if ( v3 != (unsigned int *)&unk_2FEF24 )
      sub_25ED0(v3);
    *v4 = v6;
  }
  return v4;
}

//----- (000BABAC) --------------------------------------------------------
void *__fastcall sub_BABAC(const wchar_t *a1, const wchar_t *a2)
{
  const wchar_t *v2; // r5
  int v3; // r6
  _DWORD *v4; // r0
  _DWORD *v5; // r7
  int v6; // r4

  v2 = a1;
  if ( a1 == a2 )
    return &unk_2FEF30;
  v3 = ((char *)a2 - (char *)a1) >> 2;
  v4 = sub_B9D00(v3, 0);
  v5 = v4;
  v6 = (int)(v4 + 3);
  if ( v3 == 1 )
    v4[3] = *(_DWORD *)v2;
  else
    wmemcpy((wchar_t *)v4 + 6, v2, v3);
  if ( v5 != (_DWORD *)&unk_2FEF24 )
    sub_25EC0(v5, v3);
  return (void *)v6;
}

//----- (000BAC1C) --------------------------------------------------------
wchar_t *__fastcall sub_BAC1C(const wchar_t *a1, const wchar_t *a2)
{
  const wchar_t *v2; // r4
  int v3; // r7
  _DWORD *v4; // r0
  _DWORD *v5; // r6
  wchar_t *v6; // r5
  _DWORD *v8; // r0

  v2 = a1;
  if ( a1 == a2 )
    return (wchar_t *)&unk_2FEF30;
  if ( !a1 )
  {
    if ( a2 )
      sub_BFA98((int)"basic_string::_S_construct null not valid");
    v8 = sub_B9D00(0, 0);
    v3 = (int)v2;
    v6 = (wchar_t *)(v8 + 3);
    v5 = v8;
    goto LABEL_9;
  }
  v3 = ((char *)a2 - (char *)a1) >> 2;
  v4 = sub_B9D00(v3, 0);
  v5 = v4;
  v6 = (wchar_t *)(v4 + 3);
  if ( v3 != 1 )
  {
LABEL_9:
    wmemcpy(v6, v2, v3);
    goto LABEL_5;
  }
  v4[3] = *(_DWORD *)v2;
LABEL_5:
  if ( v5 != (_DWORD *)&unk_2FEF24 )
    sub_25EC0(v5, v3);
  return v6;
}

//----- (000BAC94) --------------------------------------------------------
wchar_t **__fastcall sub_BAC94(wchar_t **a1, int *a2, unsigned int a3, unsigned int a4)
{
  wchar_t **v4; // r6
  int v5; // r4
  unsigned int v6; // r5
  unsigned int v7; // r5
  int v8; // r1

  v4 = a1;
  v5 = *a2;
  v6 = *(_DWORD *)(*a2 - 12);
  if ( a3 > v6 )
    sub_BFC08("basic_string::basic_string");
  v7 = v6 - a3;
  if ( v7 > a4 )
    v8 = a3 + a4;
  else
    v8 = a3 + v7;
  *a1 = sub_BAC1C((const wchar_t *)(v5 + 4 * a3), (const wchar_t *)(v5 + 4 * v8));
  return v4;
}

//----- (000BAD4C) --------------------------------------------------------
wchar_t *__fastcall sub_BAD4C(const wchar_t *a1, const wchar_t *a2)
{
  const wchar_t *v2; // r4
  int v3; // r7
  _DWORD *v4; // r0
  _DWORD *v5; // r6
  wchar_t *v6; // r5
  _DWORD *v8; // r0

  v2 = a1;
  if ( a1 == a2 )
    return (wchar_t *)&unk_2FEF30;
  if ( !a1 )
  {
    if ( a2 )
      sub_BFA98((int)"basic_string::_S_construct null not valid");
    v8 = sub_B9D00(0, 0);
    v3 = (int)v2;
    v6 = (wchar_t *)(v8 + 3);
    v5 = v8;
    goto LABEL_9;
  }
  v3 = ((char *)a2 - (char *)a1) >> 2;
  v4 = sub_B9D00(v3, 0);
  v5 = v4;
  v6 = (wchar_t *)(v4 + 3);
  if ( v3 != 1 )
  {
LABEL_9:
    wmemcpy(v6, v2, v3);
    goto LABEL_5;
  }
  v4[3] = *(_DWORD *)v2;
LABEL_5:
  if ( v5 != (_DWORD *)&unk_2FEF24 )
    sub_25EC0(v5, v3);
  return v6;
}

//----- (000BADC4) --------------------------------------------------------
wchar_t **__fastcall sub_BADC4(wchar_t **a1, const wchar_t *a2, int a3)
{
  wchar_t **v3; // r4

  v3 = a1;
  *a1 = sub_BAD4C(a2, &a2[2 * a3]);
  return v3;
}

//----- (000BADE0) --------------------------------------------------------
const wchar_t **__fastcall sub_BADE0(const wchar_t **a1, size_t a2, unsigned int a3, const wchar_t *a4, unsigned int a5)
{
  size_t v5; // r4
  const wchar_t *v6; // r1
  const wchar_t **v7; // r6
  size_t v8; // r7
  int v9; // r8
  const wchar_t **v10; // r6
  const wchar_t **result; // r0
  int v12; // r9
  const wchar_t *v13; // [sp+Ch] [bp-24h]

  v5 = a2;
  v6 = *a1;
  v7 = a1;
  v8 = *((_DWORD *)*a1 - 3);
  if ( v5 > v8 )
    sub_BFC08("basic_string::replace");
  v9 = v8 - v5;
  if ( v8 - v5 >= a3 )
    v9 = a3;
  if ( a5 > 268435454 - v8 + v9 )
    sub_BFBAC((int)"basic_string::replace");
  if ( a4 < v6 || a4 > &v6[2 * v8] || *((_DWORD *)v6 - 1) > 0 )
    return sub_BA228(a1, v5, v9, a4, a5);
  if ( &a4[2 * a5] <= &v6[2 * v5] )
  {
    v12 = ((char *)a4 - (char *)v6) >> 2;
    goto LABEL_12;
  }
  if ( a4 < &v6[2 * (v9 + v5)] )
  {
    sub_BADC4((wchar_t **)&v13, a4, a5);
    v10 = sub_BA228(v7, v5, v9, v13, a5);
    if ( v13 - 6 != (const wchar_t *)&unk_2FEF24 )
      sub_25ED0((unsigned int *)v13 - 3);
    return v10;
  }
  v12 = a5 + (((char *)a4 - (char *)v6) >> 2) - v9;
LABEL_12:
  sub_B9E18(a1, v5, v9, a5);
  if ( a5 == 1 )
  {
    result = v7;
    *(_DWORD *)&(*v7)[2 * v5] = *(_DWORD *)&(*v7)[2 * v12];
  }
  else
  {
    wmemcpy((wchar_t *)&(*v7)[2 * v5], &(*v7)[2 * v12], a5);
    result = v7;
  }
  return result;
}

//----- (000BB064) --------------------------------------------------------
wchar_t **__fastcall sub_BB064(wchar_t **a1, const wchar_t *a2)
{
  const wchar_t *v2; // r4
  wchar_t **v3; // r5
  const wchar_t *v4; // r1

  v2 = a2;
  v3 = a1;
  v4 = (const wchar_t *)-4;
  if ( v2 )
    v4 = &v2[2 * wcslen(v2)];
  *v3 = sub_BAD4C(v2, v4);
  return v3;
}

//----- (000BB0E8) --------------------------------------------------------
int __fastcall sub_BB0E8(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  int v5; // r6
  bool v6; // zf
  bool v7; // zf
  bool v8; // nf

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !sub_A9714((_DWORD *)(a1 + 36)) )
  {
    v6 = v4 == 0;
    if ( !v4 )
      v6 = v5 == 0;
    if ( v6 )
    {
      *(_DWORD *)(v3 + 64) = 1;
    }
    else
    {
      v7 = v4 == 0;
      v8 = v4 < 0;
      if ( v4 )
      {
        v7 = v5 == 0;
        v8 = v5 < 0;
      }
      if ( !v8 && !v7 )
      {
        *(_DWORD *)(v3 + 60) = v4;
        *(_DWORD *)(v3 + 64) = v5;
      }
    }
  }
  return v3;
}

//----- (000BB118) --------------------------------------------------------
int __fastcall sub_BB118(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r5
  int v5; // r6
  bool v6; // zf
  bool v7; // zf
  bool v8; // nf

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !sub_A9714((_DWORD *)(a1 + 36)) )
  {
    v6 = v4 == 0;
    if ( !v4 )
      v6 = v5 == 0;
    if ( v6 )
    {
      *(_DWORD *)(v3 + 64) = 1;
    }
    else
    {
      v7 = v4 == 0;
      v8 = v4 < 0;
      if ( v4 )
      {
        v7 = v5 == 0;
        v8 = v5 < 0;
      }
      if ( !v8 && !v7 )
      {
        *(_DWORD *)(v3 + 60) = v4;
        *(_DWORD *)(v3 + 64) = v5;
      }
    }
  }
  return v3;
}

//----- (000BB148) --------------------------------------------------------
int __fastcall sub_BB148(_DWORD *a1)
{
  _DWORD *v1; // r5
  _DWORD *v2; // r6
  int v3; // r0
  int v4; // r4
  int v5; // r6

  v1 = a1;
  if ( !(a1[11] & 8) )
    return -1;
  v2 = a1 + 9;
  if ( !sub_A9714(a1 + 9) )
    return -1;
  v3 = v1[21];
  v4 = v1[3] - v1[2];
  if ( !v3 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v3 + 20))() >= 0 )
  {
    v5 = sub_A9868(v2);
    return v4 + v5 / (*(int (**)(void))(*(_DWORD *)v1[21] + 32))();
  }
  return v4;
}

//----- (000BB19C) --------------------------------------------------------
int __fastcall sub_BB19C(_DWORD *a1)
{
  _DWORD *v1; // r5
  _DWORD *v2; // r6
  int v3; // r0
  int v4; // r4
  int v5; // r6

  v1 = a1;
  if ( !(a1[11] & 8) )
    return -1;
  v2 = a1 + 9;
  if ( !sub_A9714(a1 + 9) )
    return -1;
  v3 = v1[22];
  v4 = (v1[3] - v1[2]) >> 2;
  if ( !v3 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v3 + 20))() >= 0 )
  {
    v5 = sub_A9868(v2);
    return v4 + v5 / (*(int (**)(void))(*(_DWORD *)v1[22] + 32))();
  }
  return v4;
}

//----- (000BB1F4) --------------------------------------------------------
signed int __fastcall sub_BB1F4(_DWORD *a1)
{
  if ( a1[4] >= a1[5] )
    return 0;
  if ( (*(int (**)(void))(*a1 + 52))() == -1 )
    return -1;
  return 0;
}

//----- (000BB21C) --------------------------------------------------------
signed int __fastcall sub_BB21C(_DWORD *a1)
{
  if ( a1[4] >= a1[5] )
    return 0;
  if ( (*(int (**)(void))(*a1 + 52))() == -1 )
    return -1;
  return 0;
}

//----- (000BB244) --------------------------------------------------------
signed int __fastcall sub_BB244(int a1, int a2)
{
  int v2; // r5
  int v3; // r4
  unsigned int v4; // r3
  int v5; // r6
  int v6; // r0
  _BYTE *v7; // r3
  int v8; // r2
  bool v9; // zf
  int v11; // r0
  int v12; // r1
  int v13; // [sp+8h] [bp-28h]
  int v14; // [sp+Ch] [bp-24h]

  v2 = a2;
  v3 = a1;
  if ( !(*(_DWORD *)(a1 + 44) & 8) )
    return -1;
  if ( *(_BYTE *)(a1 + 70) )
  {
    if ( (*(int (**)(void))(*(_DWORD *)a1 + 52))() == -1 )
      return -1;
    v8 = *(_DWORD *)(v3 + 60);
    v5 = *(unsigned __int8 *)(v3 + 80);
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 4) = v8;
    *(_DWORD *)(v3 + 8) = v8;
    *(_DWORD *)(v3 + 12) = v8;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    *(_BYTE *)(v3 + 70) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(unsigned __int8 *)(a1 + 80);
    if ( *(_DWORD *)(a1 + 4) < v4 )
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
      v6 = *(unsigned __int8 *)(v4 - 1);
      goto LABEL_5;
    }
  }
  (*(void (__fastcall **)(int *, int, signed int, signed int, signed int, signed int))(*(_DWORD *)v3 + 16))(
    &v13,
    v3,
    -1,
    -1,
    1,
    24);
  v9 = v14 == -1;
  if ( v14 == -1 )
    v9 = v13 == -1;
  if ( v9 )
    return -1;
  v6 = (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 36))(v3);
  if ( v6 == -1 )
    return -1;
LABEL_5:
  if ( v2 == -1 )
    return 0;
  if ( v2 == v6 )
    return v2;
  if ( v5 )
    return -1;
  if ( *(_BYTE *)(v3 + 80) )
  {
    v7 = *(_BYTE **)(v3 + 8);
  }
  else
  {
    v11 = *(_DWORD *)(v3 + 8);
    v12 = *(_DWORD *)(v3 + 12);
    v7 = (_BYTE *)(v3 + 71);
    *(_DWORD *)(v3 + 4) = v3 + 71;
    *(_DWORD *)(v3 + 72) = v11;
    *(_DWORD *)(v3 + 76) = v12;
    *(_DWORD *)(v3 + 8) = v3 + 71;
    *(_DWORD *)(v3 + 12) = v3 + 72;
    *(_BYTE *)(v3 + 80) = 1;
  }
  *(_BYTE *)(v3 + 69) = 1;
  *v7 = v2;
  return v2;
}

//----- (000BB318) --------------------------------------------------------
signed int __fastcall sub_BB318(int a1, int a2)
{
  int v2; // r5
  int v3; // r4
  unsigned int v4; // r3
  int v5; // r6
  int v6; // r0
  _DWORD *v7; // r3
  int v9; // r2
  bool v10; // zf
  int v11; // r0
  int v12; // r1
  int v13; // [sp+8h] [bp-28h]
  int v14; // [sp+Ch] [bp-24h]

  v2 = a2;
  v3 = a1;
  if ( !(*(_DWORD *)(a1 + 44) & 8) )
    return -1;
  if ( *(_BYTE *)(a1 + 70) )
  {
    if ( (*(int (**)(void))(*(_DWORD *)a1 + 52))() == -1 )
      return -1;
    v9 = *(_DWORD *)(v3 + 60);
    v5 = *(unsigned __int8 *)(v3 + 84);
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 4) = v9;
    *(_DWORD *)(v3 + 8) = v9;
    *(_DWORD *)(v3 + 12) = v9;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    *(_BYTE *)(v3 + 70) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(unsigned __int8 *)(a1 + 84);
    if ( *(_DWORD *)(a1 + 4) < v4 )
    {
      v6 = *(_DWORD *)(v4 - 4);
      *(_DWORD *)(v3 + 8) = v4 - 4;
      goto LABEL_5;
    }
  }
  (*(void (__fastcall **)(int *, int, signed int, signed int, signed int, signed int))(*(_DWORD *)v3 + 16))(
    &v13,
    v3,
    -1,
    -1,
    1,
    24);
  v10 = v14 == -1;
  if ( v14 == -1 )
    v10 = v13 == -1;
  if ( v10 )
    return -1;
  v6 = (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 36))(v3);
  if ( v6 == -1 )
    return -1;
LABEL_5:
  if ( v2 == -1 )
    return 0;
  if ( v2 == v6 )
    return v2;
  if ( v5 )
    return -1;
  if ( *(_BYTE *)(v3 + 84) )
  {
    v7 = *(_DWORD **)(v3 + 8);
  }
  else
  {
    v11 = *(_DWORD *)(v3 + 8);
    v12 = *(_DWORD *)(v3 + 12);
    v7 = (_DWORD *)(v3 + 72);
    *(_DWORD *)(v3 + 4) = v3 + 72;
    *(_DWORD *)(v3 + 76) = v11;
    *(_DWORD *)(v3 + 80) = v12;
    *(_DWORD *)(v3 + 8) = v3 + 72;
    *(_DWORD *)(v3 + 12) = v3 + 76;
    *(_BYTE *)(v3 + 84) = 1;
  }
  *(_BYTE *)(v3 + 69) = 1;
  *v7 = v2;
  return v2;
}

//----- (000BB3EC) --------------------------------------------------------
int __fastcall sub_BB3EC(int a1, unsigned __int8 *a2, int a3)
{
  int v3; // r4
  int v4; // r0
  unsigned __int8 *v5; // r6
  int v6; // r5
  int v7; // r7
  int v8; // r7
  int v9; // r3
  unsigned int v10; // r2
  int v11; // r1
  int v12; // r3
  int v13; // ST00_4
  int v14; // r6
  int v15; // r5
  int v16; // r0
  int result; // r0
  int v18; // r3
  int v19; // r2
  unsigned int v20; // r2

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 84);
  v5 = a2;
  v6 = a3;
  v7 = *(_DWORD *)(v3 + 44);
  if ( !v4 )
    sub_BFA38();
  if ( !(*(int (**)(void))(*(_DWORD *)v4 + 24))() || !(v7 & 0x10) || *(_BYTE *)(v3 + 69) )
    return sub_95174((_DWORD *)v3, v5, v6);
  v8 = *(_DWORD *)(v3 + 20);
  v9 = *(_DWORD *)(v3 + 24) - v8;
  if ( !*(_BYTE *)(v3 + 70) )
  {
    v10 = *(_DWORD *)(v3 + 64);
    if ( v10 > 1 )
      v9 = v10 - 1;
  }
  if ( v9 >= 1024 )
    v9 = 1024;
  if ( v9 > v6 )
    return sub_95174((_DWORD *)v3, v5, v6);
  v11 = *(_DWORD *)(v3 + 16);
  v12 = (int)v5;
  v13 = v6;
  v14 = v8 - v11;
  v15 = v6 + v8 - v11;
  v16 = sub_A97B0((int *)(v3 + 36), v11, v8 - v11, v12, v13);
  if ( v16 == v15 )
  {
    v18 = *(_DWORD *)(v3 + 60);
    v19 = *(_DWORD *)(v3 + 44) << 27;
    *(_DWORD *)(v3 + 4) = v18;
    *(_DWORD *)(v3 + 8) = v18;
    *(_DWORD *)(v3 + 12) = v18;
    if ( v19 >= 0 || (v20 = *(_DWORD *)(v3 + 64), v20 <= 1) )
    {
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v3 + 20) = v18;
      *(_DWORD *)(v3 + 16) = v18;
      *(_DWORD *)(v3 + 24) = v20 - 1 + v18;
    }
    *(_BYTE *)(v3 + 70) = 1;
  }
  if ( v14 >= v16 )
    result = 0;
  else
    result = v16 - v14;
  return result;
}

//----- (000BB4A0) --------------------------------------------------------
int __fastcall sub_BB4A0(int a1, const wchar_t *a2, int a3)
{
  int v3; // r4
  int v4; // r0
  const wchar_t *v5; // r6
  int v6; // r5
  int v7; // r7
  int v8; // r7
  int v9; // r3
  unsigned int v10; // r2
  int v11; // r1
  int v12; // r3
  int v13; // r6
  int v14; // r0
  int result; // r0
  int v16; // r3
  int v17; // r2
  unsigned int v18; // r2

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 88);
  v5 = a2;
  v6 = a3;
  v7 = *(_DWORD *)(v3 + 44);
  if ( !v4 )
    sub_BFA38();
  if ( !(*(int (**)(void))(*(_DWORD *)v4 + 24))() || !(v7 & 0x10) || *(_BYTE *)(v3 + 69) )
    return sub_952B4(v3, v5, v6);
  v8 = *(_DWORD *)(v3 + 20);
  v9 = (*(_DWORD *)(v3 + 24) - v8) >> 2;
  if ( !*(_BYTE *)(v3 + 70) )
  {
    v10 = *(_DWORD *)(v3 + 64);
    if ( v10 > 1 )
      v9 = v10 - 1;
  }
  if ( v9 >= 1024 )
    v9 = 1024;
  if ( v9 > v6 )
    return sub_952B4(v3, v5, v6);
  v11 = *(_DWORD *)(v3 + 16);
  v12 = (int)v5;
  v13 = (v8 - v11) >> 2;
  v14 = sub_A97B0((int *)(v3 + 36), v11, v13, v12, v6);
  if ( v14 == v6 + v13 )
  {
    v16 = *(_DWORD *)(v3 + 60);
    v17 = *(_DWORD *)(v3 + 44) << 27;
    *(_DWORD *)(v3 + 4) = v16;
    *(_DWORD *)(v3 + 8) = v16;
    *(_DWORD *)(v3 + 12) = v16;
    if ( v17 >= 0 || (v18 = *(_DWORD *)(v3 + 64), v18 <= 1) )
    {
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v3 + 20) = v16;
      *(_DWORD *)(v3 + 16) = v16;
      *(_DWORD *)(v3 + 24) = v16 + 4 * (v18 + 0x3FFFFFFF);
    }
    *(_BYTE *)(v3 + 70) = 1;
  }
  if ( v13 >= v14 )
    result = 0;
  else
    result = v14 - v13;
  return result;
}

//----- (000BB55C) --------------------------------------------------------
int __fastcall sub_BB55C(int a1)
{
  int v1; // r4
  unsigned __int8 *v2; // r3
  unsigned int v3; // r2
  int result; // r0
  unsigned int v5; // r3
  int v6; // r0
  size_t v7; // r8
  int v8; // r0
  signed int v9; // r7
  int v10; // r6
  const void *v11; // r1
  signed int v12; // r5
  signed int v13; // r6
  char *v14; // r0
  int v15; // r2
  int v16; // r10
  char *v17; // r1
  size_t v18; // r5
  unsigned int v19; // r2
  void *v20; // r5
  signed int v21; // r2
  ssize_t v22; // r0
  unsigned __int8 *v23; // r1
  ssize_t v24; // r0
  int v25; // r0
  const void *v26; // r1
  void *v27; // r0
  signed int v28; // r6
  int v29; // r3
  bool v30; // zf
  unsigned __int8 *v31; // r3
  unsigned __int8 *v32; // r1
  unsigned int v33; // r0
  int v34; // r5
  int v35; // r1
  int v36; // r3
  char *v37; // r9
  void *v38; // r0
  int v39; // r1
  int v40; // [sp+1Ch] [bp-2Ch]

  v1 = a1;
  if ( !(*(_DWORD *)(a1 + 44) & 8) )
    return -1;
  if ( *(_BYTE *)(a1 + 70) )
  {
    result = (*(int (**)(void))(*(_DWORD *)a1 + 52))();
    if ( result == -1 )
      return result;
    v23 = *(unsigned __int8 **)(v1 + 60);
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 16) = 0;
    v2 = v23;
    *(_DWORD *)(v1 + 4) = v23;
    *(_DWORD *)(v1 + 8) = v23;
    *(_DWORD *)(v1 + 12) = v23;
    *(_DWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 70) = 0;
  }
  else
  {
    v2 = *(unsigned __int8 **)(a1 + 8);
  }
  if ( *(_BYTE *)(v1 + 80) )
  {
    v33 = *(_DWORD *)(v1 + 76);
    v34 = *(_DWORD *)(v1 + 60);
    if ( *(unsigned __int8 **)(v1 + 4) == v2 )
      v35 = *(_DWORD *)(v1 + 72);
    else
      v35 = *(_DWORD *)(v1 + 72) + 1;
    *(_BYTE *)(v1 + 80) = 0;
    *(_DWORD *)(v1 + 72) = v35;
    v2 = (unsigned __int8 *)v35;
    v3 = v33;
    *(_DWORD *)(v1 + 8) = v35;
    *(_DWORD *)(v1 + 12) = v33;
    *(_DWORD *)(v1 + 4) = v34;
  }
  else
  {
    v3 = *(_DWORD *)(v1 + 12);
  }
  if ( v3 > (unsigned int)v2 )
    return *v2;
  v5 = *(_DWORD *)(v1 + 64);
  v6 = *(_DWORD *)(v1 + 84);
  if ( v5 <= 1 )
    v7 = 1;
  else
    v7 = v5 - 1;
  if ( !v6 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v6 + 24))() )
  {
    v24 = sub_A9774(v1 + 36, *(void **)(v1 + 4), v7);
    v18 = v24;
    if ( !v24 )
    {
      v36 = *(_DWORD *)(v1 + 60);
      result = -1;
      *(_DWORD *)(v1 + 20) = v18;
      *(_DWORD *)(v1 + 16) = v18;
      *(_DWORD *)(v1 + 24) = v18;
      *(_BYTE *)(v1 + 69) = v18;
      *(_DWORD *)(v1 + 4) = v36;
      *(_DWORD *)(v1 + 8) = v36;
      *(_DWORD *)(v1 + 12) = v36;
      return result;
    }
    if ( v24 > 0 )
      goto LABEL_50;
LABEL_63:
    sub_BFDD4("basic_filebuf::underflow error reading the file");
  }
  v8 = (*(int (**)(void))(**(_DWORD **)(v1 + 84) + 20))();
  if ( v8 <= 0 )
  {
    v10 = v7;
    v9 = v7 - 1 + (*(int (**)(void))(**(_DWORD **)(v1 + 84) + 32))();
  }
  else
  {
    v9 = v7 * v8;
    v10 = v7 * v8;
  }
  v11 = *(const void **)(v1 + 96);
  v12 = *(_DWORD *)(v1 + 100) - (_DWORD)v11;
  if ( v10 <= v12 )
    v13 = 0;
  else
    v13 = v10 - v12;
  if ( *(_BYTE *)(v1 + 69) && *(_DWORD *)(v1 + 12) == *(_DWORD *)(v1 + 4) )
  {
    if ( *(const void **)(v1 + 100) == v11 )
    {
      if ( v9 <= *(_DWORD *)(v1 + 92) )
        goto LABEL_24;
      v37 = (char *)operator new[](v9);
      goto LABEL_70;
    }
    if ( v9 <= *(_DWORD *)(v1 + 92) )
    {
      v13 = 0;
      goto LABEL_68;
    }
    v13 = 0;
    v37 = (char *)operator new[](v9);
LABEL_77:
    memcpy(v37, *(const void **)(v1 + 96), v12);
    goto LABEL_71;
  }
  if ( v9 > *(_DWORD *)(v1 + 92) )
  {
    v37 = (char *)operator new[](v9);
    if ( !v12 )
    {
LABEL_70:
      v12 = 0;
LABEL_71:
      v38 = *(void **)(v1 + 88);
      if ( v38 )
        operator delete[](v38);
      *(_DWORD *)(v1 + 88) = v37;
      v14 = v37;
      *(_DWORD *)(v1 + 92) = v9;
      goto LABEL_25;
    }
    goto LABEL_77;
  }
  if ( *(const void **)(v1 + 100) != v11 )
LABEL_68:
    memmove(*(void **)(v1 + 88), v11, *(_DWORD *)(v1 + 100) - (_DWORD)v11);
LABEL_24:
  v14 = *(char **)(v1 + 88);
LABEL_25:
  v15 = *(_DWORD *)(v1 + 52);
  v16 = 0;
  v17 = &v14[v12];
  *(_DWORD *)(v1 + 96) = v14;
  v18 = 0;
  *(_DWORD *)(v1 + 100) = v17;
  *(_DWORD *)(v1 + 56) = v15;
  if ( v13 > 0 )
    goto LABEL_37;
  v28 = 0;
  while ( 1 )
  {
    v19 = *(_DWORD *)(v1 + 96);
    v20 = *(void **)(v1 + 4);
    v40 = *(_DWORD *)(v1 + 4);
    if ( v19 < (unsigned int)v17 )
    {
      v25 = (*(int (__cdecl **)(_DWORD, int, unsigned int, char *, int))(**(_DWORD **)(v1 + 84) + 16))(
              *(_DWORD *)(v1 + 84),
              v1 + 52,
              v19,
              v17,
              v1 + 96);
      v20 = *(void **)(v1 + 4);
      v16 = v25;
      if ( v25 == 3 )
      {
LABEL_46:
        v26 = *(const void **)(v1 + 88);
        v27 = v20;
        v18 = *(_DWORD *)(v1 + 100) - (_DWORD)v26;
        if ( v7 < v18 )
          v18 = v7;
        memcpy(v27, v26, v18);
        *(_DWORD *)(v1 + 96) = *(_DWORD *)(v1 + 88) + v18;
        goto LABEL_32;
      }
    }
    else if ( v16 == 3 )
    {
      goto LABEL_46;
    }
    v18 = v40 - (_DWORD)v20;
    if ( v16 == 2 )
      break;
LABEL_32:
    v21 = v18 ? 0 : ((unsigned __int8)v28 ^ 1) & 1;
    if ( !v21 )
      break;
    v17 = *(char **)(v1 + 100);
    v13 = 1;
LABEL_37:
    if ( (signed int)&v17[v13 - *(_DWORD *)(v1 + 88)] > *(_DWORD *)(v1 + 92) )
      sub_BFDD4("basic_filebuf::underflow codecvt::max_length() is not valid");
    v22 = sub_A9774(v1 + 36, v17, v13);
    if ( v22 )
    {
      v28 = 0;
      if ( v22 == -1 )
        break;
    }
    else
    {
      v28 = 1;
    }
    v17 = (char *)(*(_DWORD *)(v1 + 100) + v22);
    *(_DWORD *)(v1 + 100) = v17;
  }
  if ( (signed int)v18 <= 0 )
  {
    if ( !v28 )
    {
      if ( v16 == 2 )
        sub_BFDD4("basic_filebuf::underflow invalid byte sequence in file");
      goto LABEL_63;
    }
    v39 = *(_DWORD *)(v1 + 60);
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 4) = v39;
    *(_DWORD *)(v1 + 8) = v39;
    *(_DWORD *)(v1 + 12) = v39;
    *(_DWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 69) = 0;
    if ( v16 == 1 )
      sub_BFDD4("basic_filebuf::underflow incomplete character in file");
    return -1;
  }
LABEL_50:
  v29 = *(_DWORD *)(v1 + 44);
  *(_BYTE *)(v1 + 69) = 1;
  v30 = (v29 & 8) == 0;
  v31 = *(unsigned __int8 **)(v1 + 60);
  if ( v30 )
  {
    v32 = *(unsigned __int8 **)(v1 + 60);
  }
  else
  {
    *(_DWORD *)(v1 + 12) = &v31[v18];
    v32 = v31;
  }
  if ( v30 )
  {
    *(_DWORD *)(v1 + 4) = v31;
    *(_DWORD *)(v1 + 8) = v31;
    *(_DWORD *)(v1 + 12) = v31;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = v31;
    *(_DWORD *)(v1 + 8) = v31;
  }
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return *v32;
}

//----- (000BB850) --------------------------------------------------------
signed int __fastcall sub_BB850(int a1, _BYTE *a2, signed int a3)
{
  int v3; // r7
  signed int v4; // r8
  _BYTE *v5; // r5
  signed int v6; // r4
  _BYTE *v7; // r3
  _BYTE *v8; // r2
  signed int v9; // r6
  int v10; // r0
  int v11; // r1
  int v12; // r3
  int v13; // r2
  unsigned int v14; // r3
  int v15; // r8
  int v16; // r3
  int v17; // r0
  _BYTE *v18; // r1
  _BYTE *v19; // r3
  int v20; // r8
  ssize_t v21; // r0
  int v22; // r3
  int v23; // r3
  signed int result; // r0
  int v25; // r3
  int v26; // r2
  unsigned int v27; // r2
  int v28; // r1

  v3 = a1;
  v4 = *(unsigned __int8 *)(a1 + 80);
  v5 = a2;
  v6 = a3;
  if ( *(_BYTE *)(a1 + 80) )
  {
    v7 = *(_BYTE **)(a1 + 8);
    if ( a3 <= 0 )
    {
      v9 = 0;
      v8 = *(_BYTE **)(a1 + 4);
      goto LABEL_5;
    }
    v8 = *(_BYTE **)(a1 + 4);
    if ( v7 != v8 )
    {
      v9 = 0;
LABEL_5:
      v10 = *(_DWORD *)(a1 + 72);
      v11 = *(_DWORD *)(v3 + 76);
      if ( v7 == v8 )
        v12 = *(_DWORD *)(v3 + 72);
      else
        v12 = v10 + 1;
      v13 = *(_DWORD *)(v3 + 60);
      *(_DWORD *)(v3 + 72) = v12;
      *(_DWORD *)(v3 + 12) = v11;
      *(_DWORD *)(v3 + 4) = v13;
      *(_DWORD *)(v3 + 8) = v12;
      *(_BYTE *)(v3 + 80) = 0;
      goto LABEL_9;
    }
    --v6;
    v9 = 1;
    v5 = a2 + 1;
    *a2 = *v7;
    v28 = *(unsigned __int8 *)(a1 + 80);
    v7 = (_BYTE *)(*(_DWORD *)(a1 + 8) + 1);
    *(_DWORD *)(a1 + 8) = v7;
    if ( v28 )
    {
      v8 = *(_BYTE **)(a1 + 4);
      v9 = 1;
      goto LABEL_5;
    }
  }
  else
  {
    v9 = *(unsigned __int8 *)(a1 + 70);
    if ( *(_BYTE *)(a1 + 70) )
    {
      if ( (*(int (**)(void))(*(_DWORD *)a1 + 52))() == -1 )
        return v4;
      v23 = *(_DWORD *)(v3 + 60);
      v9 = v4;
      *(_DWORD *)(v3 + 20) = v4;
      *(_DWORD *)(v3 + 16) = v4;
      *(_DWORD *)(v3 + 24) = v4;
      *(_BYTE *)(v3 + 70) = v4;
      *(_DWORD *)(v3 + 4) = v23;
      *(_DWORD *)(v3 + 8) = v23;
      *(_DWORD *)(v3 + 12) = v23;
    }
  }
LABEL_9:
  v14 = *(_DWORD *)(v3 + 64);
  v15 = *(_DWORD *)(v3 + 44);
  if ( v14 <= 1 )
    v16 = 1;
  else
    v16 = v14 - 1;
  if ( v6 <= v16 )
    goto LABEL_43;
  v17 = *(_DWORD *)(v3 + 84);
  if ( !v17 )
    sub_BFA38();
  if ( !(*(int (**)(void))(*(_DWORD *)v17 + 24))() || !(v15 & 8) )
  {
LABEL_43:
    v9 += sub_95110((_DWORD *)v3, v5, v6);
    return v9;
  }
  v18 = *(_BYTE **)(v3 + 8);
  v19 = *(_BYTE **)(v3 + 12);
  v20 = v19 - v18;
  if ( v19 != v18 )
  {
    memcpy(v5, v18, v19 - v18);
    v9 += v20;
    v6 -= v20;
    v5 += v20;
    *(_DWORD *)(v3 + 8) += v20;
  }
  while ( 1 )
  {
    v21 = sub_A9774(v3 + 36, v5, v6);
    if ( v21 == -1 )
      sub_BFDD4("basic_filebuf::xsgetn error reading the file");
    if ( !v21 )
      break;
    v6 -= v21;
    v9 += v21;
    if ( !v6 )
      goto LABEL_31;
    v5 += v21;
  }
  if ( v6 )
  {
    v22 = *(_DWORD *)(v3 + 60);
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    *(_BYTE *)(v3 + 69) = 0;
    *(_DWORD *)(v3 + 4) = v22;
    *(_DWORD *)(v3 + 8) = v22;
    *(_DWORD *)(v3 + 12) = v22;
    return v9;
  }
LABEL_31:
  v25 = *(_DWORD *)(v3 + 60);
  v26 = *(_DWORD *)(v3 + 44) << 27;
  *(_DWORD *)(v3 + 4) = v25;
  *(_DWORD *)(v3 + 8) = v25;
  *(_DWORD *)(v3 + 12) = v25;
  if ( v26 >= 0 || (v27 = *(_DWORD *)(v3 + 64), v27 <= 1) )
  {
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
  }
  else
  {
    *(_DWORD *)(v3 + 20) = v25;
    *(_DWORD *)(v3 + 16) = v25;
    *(_DWORD *)(v3 + 24) = v27 - 1 + v25;
  }
  result = v9;
  *(_BYTE *)(v3 + 69) = 1;
  return result;
}

//----- (000BB9CC) --------------------------------------------------------
int __fastcall sub_BB9CC(int a1)
{
  int v1; // r4
  unsigned int v2; // r3
  unsigned int v3; // r2
  int result; // r0
  unsigned int v5; // r7
  int v6; // r0
  size_t v7; // r7
  int v8; // r0
  signed int v9; // r6
  int v10; // r11
  const void *v11; // r1
  signed int v12; // r5
  signed int v13; // r11
  char *v14; // r0
  int v15; // r2
  int v16; // r9
  char *v17; // r1
  int v18; // r5
  unsigned int v19; // r2
  wchar_t *v20; // r5
  signed int v21; // r2
  ssize_t v22; // r0
  unsigned int v23; // r1
  ssize_t v24; // r0
  int v25; // r0
  const wchar_t *v26; // r1
  wchar_t *v27; // r0
  signed int v28; // r11
  bool v29; // zf
  int *v30; // r3
  int *v31; // r2
  int v32; // r2
  int v33; // r1
  unsigned int v34; // r0
  int v35; // r5
  int v36; // r1
  int v37; // r3
  char *v38; // r8
  void *v39; // r0
  int v40; // r1
  int v41; // [sp+1Ch] [bp-2Ch]

  v1 = a1;
  if ( !(*(_DWORD *)(a1 + 44) & 8) )
    return -1;
  if ( *(_BYTE *)(a1 + 70) )
  {
    result = (*(int (**)(void))(*(_DWORD *)a1 + 52))();
    if ( result == -1 )
      return result;
    v23 = *(_DWORD *)(v1 + 60);
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 16) = 0;
    v2 = v23;
    *(_DWORD *)(v1 + 4) = v23;
    *(_DWORD *)(v1 + 8) = v23;
    *(_DWORD *)(v1 + 12) = v23;
    *(_DWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 70) = 0;
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 8);
  }
  if ( *(_BYTE *)(v1 + 84) )
  {
    v32 = *(_DWORD *)(v1 + 76);
    v33 = *(_DWORD *)(v1 + 4) - v2;
    v34 = *(_DWORD *)(v1 + 80);
    v35 = *(_DWORD *)(v1 + 60);
    if ( *(_DWORD *)(v1 + 4) != v2 )
      v33 = 1;
    *(_BYTE *)(v1 + 84) = 0;
    v36 = v32 + 4 * v33;
    *(_DWORD *)(v1 + 12) = v34;
    v3 = v34;
    *(_DWORD *)(v1 + 76) = v36;
    v2 = v36;
    *(_DWORD *)(v1 + 8) = v36;
    *(_DWORD *)(v1 + 4) = v35;
  }
  else
  {
    v3 = *(_DWORD *)(v1 + 12);
  }
  if ( v3 > v2 )
    return *(_DWORD *)v2;
  v5 = *(_DWORD *)(v1 + 64);
  v6 = *(_DWORD *)(v1 + 88);
  if ( v5 <= 1 )
    v7 = 1;
  else
    v7 = v5 - 1;
  if ( !v6 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v6 + 24))() )
  {
    v24 = sub_A9774(v1 + 36, *(void **)(v1 + 4), v7);
    v18 = v24;
    if ( !v24 )
    {
      v37 = *(_DWORD *)(v1 + 60);
      result = -1;
      *(_DWORD *)(v1 + 20) = v18;
      *(_DWORD *)(v1 + 16) = v18;
      *(_DWORD *)(v1 + 24) = v18;
      *(_BYTE *)(v1 + 69) = v18;
      *(_DWORD *)(v1 + 4) = v37;
      *(_DWORD *)(v1 + 8) = v37;
      *(_DWORD *)(v1 + 12) = v37;
      return result;
    }
    if ( v24 > 0 )
      goto LABEL_50;
LABEL_62:
    sub_BFDD4("basic_filebuf::underflow error reading the file");
  }
  v8 = (*(int (**)(void))(**(_DWORD **)(v1 + 88) + 20))();
  if ( v8 <= 0 )
  {
    v10 = v7;
    v9 = v7 - 1 + (*(int (**)(void))(**(_DWORD **)(v1 + 88) + 32))();
  }
  else
  {
    v9 = v7 * v8;
    v10 = v7 * v8;
  }
  v11 = *(const void **)(v1 + 100);
  v12 = *(_DWORD *)(v1 + 104) - (_DWORD)v11;
  if ( v10 <= v12 )
    v13 = 0;
  else
    v13 = v10 - v12;
  if ( *(_BYTE *)(v1 + 69) && *(_DWORD *)(v1 + 12) == *(_DWORD *)(v1 + 4) )
  {
    if ( *(const void **)(v1 + 104) == v11 )
    {
      if ( v9 <= *(_DWORD *)(v1 + 96) )
        goto LABEL_24;
      v38 = (char *)operator new[](v9);
      goto LABEL_69;
    }
    if ( v9 <= *(_DWORD *)(v1 + 96) )
    {
      v13 = 0;
      goto LABEL_67;
    }
    v13 = 0;
    v38 = (char *)operator new[](v9);
LABEL_76:
    memcpy(v38, *(const void **)(v1 + 100), v12);
    goto LABEL_70;
  }
  if ( v9 > *(_DWORD *)(v1 + 96) )
  {
    v38 = (char *)operator new[](v9);
    if ( !v12 )
    {
LABEL_69:
      v12 = 0;
LABEL_70:
      v39 = *(void **)(v1 + 92);
      if ( v39 )
        operator delete[](v39);
      *(_DWORD *)(v1 + 92) = v38;
      v14 = v38;
      *(_DWORD *)(v1 + 96) = v9;
      goto LABEL_25;
    }
    goto LABEL_76;
  }
  if ( *(const void **)(v1 + 104) != v11 )
LABEL_67:
    memmove(*(void **)(v1 + 92), v11, *(_DWORD *)(v1 + 104) - (_DWORD)v11);
LABEL_24:
  v14 = *(char **)(v1 + 92);
LABEL_25:
  v15 = *(_DWORD *)(v1 + 52);
  v16 = 0;
  v17 = &v14[v12];
  *(_DWORD *)(v1 + 100) = v14;
  v18 = 0;
  *(_DWORD *)(v1 + 104) = v17;
  *(_DWORD *)(v1 + 56) = v15;
  if ( v13 > 0 )
    goto LABEL_37;
  v28 = 0;
  while ( 1 )
  {
    v19 = *(_DWORD *)(v1 + 100);
    v20 = *(wchar_t **)(v1 + 4);
    v41 = *(_DWORD *)(v1 + 4);
    if ( v19 < (unsigned int)v17 )
    {
      v25 = (*(int (__cdecl **)(_DWORD, int, unsigned int, char *))(**(_DWORD **)(v1 + 88) + 16))(
              *(_DWORD *)(v1 + 88),
              v1 + 52,
              v19,
              v17);
      v20 = *(wchar_t **)(v1 + 4);
      v16 = v25;
      if ( v25 == 3 )
      {
LABEL_46:
        v26 = *(const wchar_t **)(v1 + 92);
        v27 = v20;
        v18 = *(_DWORD *)(v1 + 104) - (_DWORD)v26;
        if ( v7 < v18 )
          v18 = v7;
        wmemcpy(v27, v26, v18);
        *(_DWORD *)(v1 + 100) = *(_DWORD *)(v1 + 92) + v18;
        goto LABEL_32;
      }
    }
    else if ( v16 == 3 )
    {
      goto LABEL_46;
    }
    v18 = (v41 - (signed int)v20) >> 2;
    if ( v16 == 2 )
      break;
LABEL_32:
    v21 = v18 ? 0 : ((unsigned __int8)v28 ^ 1) & 1;
    if ( !v21 )
      break;
    v17 = *(char **)(v1 + 104);
    v13 = 1;
LABEL_37:
    if ( (signed int)&v17[v13 - *(_DWORD *)(v1 + 92)] > *(_DWORD *)(v1 + 96) )
      sub_BFDD4("basic_filebuf::underflow codecvt::max_length() is not valid");
    v22 = sub_A9774(v1 + 36, v17, v13);
    if ( v22 )
    {
      v28 = 0;
      if ( v22 == -1 )
        break;
    }
    else
    {
      v28 = 1;
    }
    v17 = (char *)(*(_DWORD *)(v1 + 104) + v22);
    *(_DWORD *)(v1 + 104) = v17;
  }
  if ( v18 <= 0 )
  {
    if ( !v28 )
    {
      if ( v16 == 2 )
        sub_BFDD4("basic_filebuf::underflow invalid byte sequence in file");
      goto LABEL_62;
    }
    v40 = *(_DWORD *)(v1 + 60);
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 4) = v40;
    *(_DWORD *)(v1 + 8) = v40;
    *(_DWORD *)(v1 + 12) = v40;
    *(_DWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 69) = 0;
    if ( v16 == 1 )
      sub_BFDD4("basic_filebuf::underflow incomplete character in file");
    return -1;
  }
LABEL_50:
  v29 = (*(_DWORD *)(v1 + 44) & 8) == 0;
  v30 = *(int **)(v1 + 60);
  if ( *(_DWORD *)(v1 + 44) & 8 )
  {
    *(_DWORD *)(v1 + 12) = &v30[v18];
    v31 = v30;
  }
  else
  {
    v31 = *(int **)(v1 + 60);
  }
  result = *v31;
  if ( v29 )
  {
    *(_DWORD *)(v1 + 4) = v30;
    *(_DWORD *)(v1 + 8) = v30;
    *(_DWORD *)(v1 + 12) = v30;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = v30;
    *(_DWORD *)(v1 + 8) = v30;
  }
  *(_BYTE *)(v1 + 69) = 1;
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

//----- (000BBCD4) --------------------------------------------------------
signed int __fastcall sub_BBCD4(int a1, wchar_t *a2, signed int a3)
{
  int v3; // r7
  signed int v4; // r8
  wchar_t *v5; // r5
  signed int v6; // r4
  char *v7; // r2
  char *v8; // r3
  signed int v9; // r6
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r0
  int v14; // r3
  unsigned int v15; // r3
  int v16; // r8
  int v17; // r3
  int v18; // r0
  const wchar_t *v19; // r1
  int v20; // r3
  int v21; // r8
  ssize_t v22; // r0
  int v23; // r3
  int v24; // r3
  signed int result; // r0
  int v26; // r3
  int v27; // r2
  unsigned int v28; // r2

  v3 = a1;
  v4 = *(unsigned __int8 *)(a1 + 84);
  v5 = a2;
  v6 = a3;
  if ( *(_BYTE *)(a1 + 84) )
  {
    v7 = *(char **)(a1 + 8);
    if ( v6 <= 0 )
    {
      v9 = 0;
      v8 = *(char **)(a1 + 4);
    }
    else
    {
      v8 = *(char **)(a1 + 4);
      if ( v7 == v8 )
      {
        v8 = *(char **)(a1 + 8);
        --v6;
        v9 = 1;
        v5 = a2 + 2;
        *(_DWORD *)a2 = *(_DWORD *)v7;
        v7 += 4;
        *(_DWORD *)(a1 + 8) = v7;
      }
      else
      {
        v9 = 0;
      }
    }
    v10 = v8 - v7;
    v11 = *(_DWORD *)(a1 + 60);
    v12 = *(_DWORD *)(a1 + 80);
    v13 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(v3 + 4) = v11;
    v14 = v13 + 4 * (v10 != 0);
    *(_DWORD *)(v3 + 12) = v12;
    *(_DWORD *)(v3 + 76) = v14;
    *(_DWORD *)(v3 + 8) = v14;
    *(_BYTE *)(v3 + 84) = 0;
  }
  else
  {
    v9 = *(unsigned __int8 *)(a1 + 70);
    if ( *(_BYTE *)(a1 + 70) )
    {
      if ( (*(int (**)(void))(*(_DWORD *)a1 + 52))() == -1 )
        return v4;
      v24 = *(_DWORD *)(v3 + 60);
      v9 = v4;
      *(_DWORD *)(v3 + 20) = v4;
      *(_DWORD *)(v3 + 16) = v4;
      *(_DWORD *)(v3 + 24) = v4;
      *(_BYTE *)(v3 + 70) = v4;
      *(_DWORD *)(v3 + 4) = v24;
      *(_DWORD *)(v3 + 8) = v24;
      *(_DWORD *)(v3 + 12) = v24;
    }
  }
  v15 = *(_DWORD *)(v3 + 64);
  v16 = *(_DWORD *)(v3 + 44);
  if ( v15 <= 1 )
    v17 = 1;
  else
    v17 = v15 - 1;
  if ( v6 <= v17 )
    goto LABEL_39;
  v18 = *(_DWORD *)(v3 + 88);
  if ( !v18 )
    sub_BFA38();
  if ( !(*(int (**)(void))(*(_DWORD *)v18 + 24))() || !(v16 & 8) )
  {
LABEL_39:
    v9 += sub_9524C(v3, v5, v6);
    return v9;
  }
  v19 = *(const wchar_t **)(v3 + 8);
  v20 = *(_DWORD *)(v3 + 12);
  v21 = (v20 - (signed int)v19) >> 2;
  if ( v21 )
  {
    wmemcpy(v5, v19, (v20 - (signed int)v19) >> 2);
    v9 += v21;
    v6 -= v21;
    v5 += 2 * v21;
    *(_DWORD *)(v3 + 8) += 4 * v21;
  }
  while ( 1 )
  {
    v22 = sub_A9774(v3 + 36, v5, v6);
    if ( v22 == -1 )
      sub_BFDD4("basic_filebuf::xsgetn error reading the file");
    if ( !v22 )
      break;
    v6 -= v22;
    v9 += v22;
    if ( !v6 )
      goto LABEL_28;
    v5 += 2 * v22;
  }
  if ( v6 )
  {
    v23 = *(_DWORD *)(v3 + 60);
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    *(_BYTE *)(v3 + 69) = 0;
    *(_DWORD *)(v3 + 4) = v23;
    *(_DWORD *)(v3 + 8) = v23;
    *(_DWORD *)(v3 + 12) = v23;
    return v9;
  }
LABEL_28:
  v26 = *(_DWORD *)(v3 + 60);
  v27 = *(_DWORD *)(v3 + 44) << 27;
  *(_DWORD *)(v3 + 4) = v26;
  *(_DWORD *)(v3 + 8) = v26;
  *(_DWORD *)(v3 + 12) = v26;
  if ( v27 >= 0 || (v28 = *(_DWORD *)(v3 + 64), v28 <= 1) )
  {
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
  }
  else
  {
    *(_DWORD *)(v3 + 20) = v26;
    *(_DWORD *)(v3 + 16) = v26;
    *(_DWORD *)(v3 + 24) = v26 + 4 * (v28 + 0x3FFFFFFF);
  }
  result = v9;
  *(_BYTE *)(v3 + 69) = 1;
  return result;
}

//----- (000BBEAC) --------------------------------------------------------
_DWORD *__fastcall sub_BBEAC(_DWORD *a1)
{
  int v1; // r7
  _DWORD *v2; // r4

  v1 = (int)(a1 + 7);
  v2 = a1;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_F0818;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_A93A8(a1 + 7);
  v2[8] = 0;
  *v2 = &off_F1E38;
  sub_A9664((int)(v2 + 9));
  v2[11] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  *((_BYTE *)v2 + 68) = 0;
  *((_BYTE *)v2 + 69) = 0;
  *((_BYTE *)v2 + 70) = 0;
  *((_BYTE *)v2 + 71) = 0;
  v2[18] = 0;
  v2[19] = 0;
  *((_BYTE *)v2 + 80) = 0;
  v2[21] = 0;
  v2[22] = 0;
  v2[23] = 0;
  v2[24] = 0;
  v2[25] = 0;
  v2[16] = 1024;
  if ( sub_98FCC(v1) )
    v2[21] = sub_98048(v1);
  return v2;
}
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;

//----- (000BBF60) --------------------------------------------------------
_DWORD *__fastcall sub_BBF60(_DWORD *result)
{
  _DWORD *v1; // r4

  v1 = result;
  if ( !*((_BYTE *)result + 68) && !result[15] )
  {
    result = operator new[](result[16]);
    *((_BYTE *)v1 + 68) = 1;
    v1[15] = result;
  }
  return result;
}

//----- (000BBF80) --------------------------------------------------------
void __fastcall sub_BBF80(int a1)
{
  int v1; // r4
  void *v2; // r0
  void *v3; // r0

  v1 = a1;
  if ( *(_BYTE *)(a1 + 68) )
  {
    v2 = *(void **)(a1 + 60);
    if ( v2 )
      operator delete[](v2);
    *(_DWORD *)(v1 + 60) = 0;
    *(_BYTE *)(v1 + 68) = 0;
  }
  v3 = *(void **)(v1 + 88);
  if ( v3 )
    operator delete[](v3);
  *(_DWORD *)(v1 + 88) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 100) = 0;
}

//----- (000BBFB0) --------------------------------------------------------
int *__fastcall sub_BBFB0(int *a1)
{
  int v1; // r3
  int *v2; // r5
  int v3; // r3
  int *result; // r0
  int v5; // r2
  int v6; // r1

  v1 = *a1;
  v2 = a1;
  *(_DWORD *)(v1 + 44) = 0;
  *(_BYTE *)(v1 + 80) = 0;
  sub_BBF80(v1);
  v3 = *v2;
  result = v2;
  v5 = *(_DWORD *)(*v2 + 60);
  v6 = *(_DWORD *)(*v2 + 48);
  *(_BYTE *)(v3 + 69) = 0;
  *(_BYTE *)(v3 + 70) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 4) = v5;
  *(_DWORD *)(v3 + 8) = v5;
  *(_DWORD *)(v3 + 12) = v5;
  *(_DWORD *)(v3 + 52) = v6;
  *(_DWORD *)(v3 + 56) = v6;
  return result;
}

//----- (000BBFE8) --------------------------------------------------------
bool __fastcall sub_BBFE8(int a1, void *a2, size_t a3)
{
  int v3; // r4
  void *v4; // r6
  int v5; // r0
  size_t v6; // r5
  int v7; // r0
  unsigned int v8; // r0
  int v9; // r0
  int v11; // r3
  char v12[4]; // [sp+10h] [bp+0h]
  unsigned int v13; // [sp+14h] [bp+4h]
  int v14; // [sp+18h] [bp+8h]
  int v15; // [sp+1Ch] [bp+Ch]

  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a1 + 84);
  v6 = a3;
  if ( !v5 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v5 + 24))() )
    goto LABEL_5;
  v7 = (*(int (**)(void))(**(_DWORD **)(v3 + 84) + 32))();
  v8 = (*(int (__fastcall **)(_DWORD, int, void *, size_t, int *, char *, char *, int *))(**(_DWORD **)(v3 + 84) + 8))(
         *(_DWORD *)(v3 + 84),
         v3 + 52,
         v4,
         (size_t)v4 + v6,
         &v15,
         v12,
         &v12[v7 * v6],
         &v14);
  if ( v8 > 1 )
  {
    if ( v8 == 3 )
    {
LABEL_5:
      v9 = sub_A97A4(v3 + 36, v4, v6);
      return v9 - v6 <= 0;
    }
LABEL_13:
    sub_BFDD4("basic_filebuf::_M_convert_to_external conversion error");
  }
  v13 = v8;
  v6 = v14 - (_DWORD)v12;
  v9 = sub_A97A4(v3 + 36, v12, v14 - (_DWORD)v12);
  if ( v6 == v9 )
    v11 = v13 & 1;
  else
    v11 = 0;
  if ( v11 )
  {
    if ( (*(int (__cdecl **)(_DWORD, int, int, _DWORD))(**(_DWORD **)(v3 + 84) + 8))(
           *(_DWORD *)(v3 + 84),
           v3 + 52,
           v15,
           *(_DWORD *)(v3 + 20)) != 2 )
    {
      v6 = v14 - (_DWORD)v12;
      v9 = sub_A97A4(v3 + 36, v12, v14 - (_DWORD)v12);
      return v9 - v6 <= 0;
    }
    goto LABEL_13;
  }
  return v9 - v6 <= 0;
}
// BBFE8: using guessed type char var_14[4];

//----- (000BC0E4) --------------------------------------------------------
int __fastcall sub_BC0E4(int a1)
{
  int v1; // r4
  int v3; // r2
  int v4; // r3
  int v5; // ST00_4

  v1 = a1;
  if ( (*(int (**)(void))(**(_DWORD **)(a1 + 84) + 24))() )
    return *(_DWORD *)(v1 + 8) - *(_DWORD *)(v1 + 12);
  v3 = *(_DWORD *)(v1 + 88);
  v4 = *(_DWORD *)(v1 + 96);
  v5 = *(_DWORD *)(v1 + 8) - *(_DWORD *)(v1 + 4);
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(v1 + 84) + 28))(*(_DWORD *)(v1 + 84))
       + *(_DWORD *)(v1 + 88)
       - *(_DWORD *)(v1 + 100);
}

//----- (000BC124) --------------------------------------------------------
bool __fastcall sub_BC124(_DWORD *a1)
{
  _DWORD *v1; // r10
  _BOOL4 v2; // r4
  int v3; // r0
  int v4; // r8
  unsigned int v5; // r0
  unsigned int v6; // r4
  int v8; // [sp+Ch] [bp-A4h]
  char v9; // [sp+10h] [bp-A0h]

  v1 = a1;
  if ( a1[4] < a1[5] )
    v2 = (*(int (**)(void))(*a1 + 52))() != -1;
  else
    v2 = 1;
  if ( !*((_BYTE *)v1 + 70) )
    return v2;
  v3 = v1[21];
  if ( !v3 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v3 + 24))() || !v2 )
    return v2;
  v4 = 0;
  while ( 1 )
  {
    v5 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)v1[21] + 12))(v1[21]);
    v6 = v5;
    if ( v5 == 2 )
      break;
    if ( v5 <= 1 )
    {
      v4 = v8 - (_DWORD)&v9;
      if ( v8 - (signed int)&v9 <= 0 )
        return (*(int (__fastcall **)(_DWORD *, signed int))(*v1 + 52))(v1, -1) != -1;
      if ( v4 != sub_A97A4((int)(v1 + 9), &v9, v8 - (_DWORD)&v9) )
        break;
    }
    if ( v4 <= 0 || v6 != 1 )
      return (*(int (__fastcall **)(_DWORD *, signed int))(*v1 + 52))(v1, -1) != -1;
  }
  return 0;
}

//----- (000BC1E0) --------------------------------------------------------
int __fastcall sub_BC1E0(int a1)
{
  _DWORD *v1; // r6
  int v2; // r5
  _BOOL4 v3; // r7
  int v4; // r2
  int v5; // r1
  int result; // r0

  v1 = (_DWORD *)(a1 + 36);
  v2 = a1;
  if ( !sub_A9714((_DWORD *)(a1 + 36)) )
    goto LABEL_8;
  v3 = !sub_BC124((_DWORD *)v2);
  *(_DWORD *)(v2 + 44) = 0;
  *(_BYTE *)(v2 + 80) = 0;
  sub_BBF80(v2);
  v4 = *(_DWORD *)(v2 + 60);
  v5 = *(_DWORD *)(v2 + 48);
  *(_BYTE *)(v2 + 69) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 4) = v4;
  *(_DWORD *)(v2 + 8) = v4;
  *(_DWORD *)(v2 + 12) = v4;
  *(_DWORD *)(v2 + 52) = v5;
  *(_DWORD *)(v2 + 56) = v5;
  if ( !sub_A972C(v1, v5, v4) )
    goto LABEL_8;
  if ( !v3 )
    result = v2;
  else
LABEL_8:
    result = 0;
  return result;
}

//----- (000BC274) --------------------------------------------------------
unsigned int **__fastcall sub_BC274(_DWORD *a1)
{
  unsigned int **v1; // r4
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2

  v1 = (unsigned int **)a1;
  *a1 = &off_F1E38;
  v2 = a1 + 9;
  sub_BC1E0((int)a1);
  sub_A9768(v2, v3, v4);
  *v1 = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 7);
  return v1;
}
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;

//----- (000BC2AC) --------------------------------------------------------
int __fastcall sub_BC2AC(int a1, const char *a2, int a3)
{
  _DWORD *v3; // r6
  int v4; // r4
  const char *v5; // r8
  int v6; // r7
  int v7; // r3
  int v8; // r2
  bool v10; // zf
  int v11; // [sp+8h] [bp-28h]
  int v12; // [sp+Ch] [bp-24h]

  v3 = (_DWORD *)(a1 + 36);
  v4 = a1;
  v5 = a2;
  v6 = a3;
  if ( sub_A9714((_DWORD *)(a1 + 36)) )
    return 0;
  sub_A96E8((int)v3, v5, v6);
  if ( !sub_A9714(v3) )
    return 0;
  sub_BBF60((_DWORD *)v4);
  v7 = *(_DWORD *)(v4 + 60);
  v8 = *(_DWORD *)(v4 + 48);
  *(_DWORD *)(v4 + 44) = v6;
  *(_DWORD *)(v4 + 4) = v7;
  *(_DWORD *)(v4 + 8) = v7;
  *(_DWORD *)(v4 + 12) = v7;
  *(_BYTE *)(v4 + 69) = 0;
  *(_BYTE *)(v4 + 70) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 52) = v8;
  *(_DWORD *)(v4 + 56) = v8;
  if ( !(v6 & 2) )
    return v4;
  (*(void (__fastcall **)(int *, int, _DWORD, _DWORD, signed int, int))(*(_DWORD *)v4 + 16))(&v11, v4, 0, 0, 2, v6);
  v10 = v12 == -1;
  if ( v12 == -1 )
    v10 = v11 == -1;
  if ( !v10 )
    return v4;
  sub_BC1E0(v4);
  return 0;
}

//----- (000BC34C) --------------------------------------------------------
unsigned int **__fastcall sub_BC34C(_DWORD *a1)
{
  unsigned int **v1; // r4
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2

  v1 = (unsigned int **)a1;
  *a1 = &off_F1E38;
  v2 = a1 + 9;
  sub_BC1E0((int)a1);
  sub_A9768(v2, v3, v4);
  *v1 = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 7);
  operator delete(v1);
  return v1;
}
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;

//----- (000BC38C) --------------------------------------------------------
unsigned int **__fastcall sub_BC38C(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F1F14;
  a1[27] = (unsigned int *)&off_F1F28;
  a1[1] = (unsigned int *)&off_F1E38;
  sub_BC1E0((int)(a1 + 1));
  sub_A9768(v1 + 10, v2, v3);
  v1[1] = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 8);
  *v1 = (unsigned int *)&off_F1EDC;
  v1[27] = (unsigned int *)&off_F0690;
  sub_95E1C(v1 + 27);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1EDC: using guessed type void *off_F1EDC;
// F1F14: using guessed type void *off_F1F14;
// F1F28: using guessed type void *off_F1F28;

//----- (000BC3F8) --------------------------------------------------------
unsigned int **__fastcall sub_BC3F8(_DWORD *a1)
{
  return sub_BC38C((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC404) --------------------------------------------------------
unsigned int **__fastcall sub_BC404(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F1EB4;
  a1[28] = (unsigned int *)&off_F1EC8;
  a1[2] = (unsigned int *)&off_F1E38;
  sub_BC1E0((int)(a1 + 2));
  sub_A9768(v1 + 11, v2, v3);
  v1[2] = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 9);
  v1[1] = 0;
  *v1 = (unsigned int *)&off_F1E7C;
  v1[28] = (unsigned int *)&off_F0690;
  sub_95E1C(v1 + 28);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1E7C: using guessed type void *off_F1E7C;
// F1EB4: using guessed type void *off_F1EB4;
// F1EC8: using guessed type void *off_F1EC8;

//----- (000BC474) --------------------------------------------------------
unsigned int **__fastcall sub_BC474(_DWORD *a1)
{
  return sub_BC404((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC480) --------------------------------------------------------
void *__fastcall sub_BC480(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = &off_F1EB4;
  a1[28] = &off_F1EC8;
  a1[2] = &off_F1E38;
  sub_BC1E0((int)(a1 + 2));
  sub_A9768((_DWORD *)v1 + 11, v2, v3);
  *((_DWORD *)v1 + 2) = &off_F0818;
  sub_AB620((unsigned int **)v1 + 9);
  *((_DWORD *)v1 + 1) = 0;
  *(_DWORD *)v1 = &off_F1E7C;
  *((_DWORD *)v1 + 28) = &off_F0690;
  sub_95E1C((_DWORD *)v1 + 28);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1E7C: using guessed type void *off_F1E7C;
// F1EB4: using guessed type void *off_F1EB4;
// F1EC8: using guessed type void *off_F1EC8;

//----- (000BC4F8) --------------------------------------------------------
void *__fastcall sub_BC4F8(_DWORD *a1)
{
  return sub_BC480((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC504) --------------------------------------------------------
void *__fastcall sub_BC504(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = &off_F1F14;
  a1[27] = &off_F1F28;
  a1[1] = &off_F1E38;
  sub_BC1E0((int)(a1 + 1));
  sub_A9768((_DWORD *)v1 + 10, v2, v3);
  *((_DWORD *)v1 + 1) = &off_F0818;
  sub_AB620((unsigned int **)v1 + 8);
  *(_DWORD *)v1 = &off_F1EDC;
  *((_DWORD *)v1 + 27) = &off_F0690;
  sub_95E1C((_DWORD *)v1 + 27);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1EDC: using guessed type void *off_F1EDC;
// F1F14: using guessed type void *off_F1F14;
// F1F28: using guessed type void *off_F1F28;

//----- (000BC578) --------------------------------------------------------
void *__fastcall sub_BC578(_DWORD *a1)
{
  return sub_BC504((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC584) --------------------------------------------------------
unsigned int **__fastcall sub_BC584(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  a1[29] = (unsigned int *)&off_F201C;
  *a1 = (unsigned int *)&off_F1FF4;
  a1[2] = (unsigned int *)&off_F2008;
  a1[3] = (unsigned int *)&off_F1E38;
  sub_BC1E0((int)(a1 + 3));
  sub_A9768(v1 + 12, v2, v3);
  v1[3] = (unsigned int *)&off_F0818;
  sub_AB620(v1 + 10);
  v1[1] = 0;
  *v1 = (unsigned int *)&off_F1F64;
  v1[2] = (unsigned int *)&off_F1F3C;
  v1[29] = (unsigned int *)&off_F0690;
  sub_95E1C(v1 + 29);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1F3C: using guessed type void *off_F1F3C;
// F1F64: using guessed type void *off_F1F64;
// F1FF4: using guessed type void *off_F1FF4;
// F2008: using guessed type void *off_F2008;
// F201C: using guessed type void *off_F201C;

//----- (000BC610) --------------------------------------------------------
unsigned int **__fastcall sub_BC610(_DWORD *a1)
{
  return sub_BC584((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC61C) --------------------------------------------------------
void *__fastcall sub_BC61C(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  a1[29] = &off_F201C;
  *a1 = &off_F1FF4;
  a1[2] = &off_F2008;
  a1[3] = &off_F1E38;
  sub_BC1E0((int)(a1 + 3));
  sub_A9768((_DWORD *)v1 + 12, v2, v3);
  *((_DWORD *)v1 + 3) = &off_F0818;
  sub_AB620((unsigned int **)v1 + 10);
  *((_DWORD *)v1 + 1) = 0;
  *(_DWORD *)v1 = &off_F1F64;
  *((_DWORD *)v1 + 2) = &off_F1F3C;
  *((_DWORD *)v1 + 29) = &off_F0690;
  sub_95E1C((_DWORD *)v1 + 29);
  operator delete(v1);
  return v1;
}
// F0690: using guessed type void *off_F0690;
// F0818: using guessed type void *off_F0818;
// F1E38: using guessed type void *off_F1E38;
// F1F3C: using guessed type void *off_F1F3C;
// F1F64: using guessed type void *off_F1F64;
// F1FF4: using guessed type void *off_F1FF4;
// F2008: using guessed type void *off_F2008;
// F201C: using guessed type void *off_F201C;

//----- (000BC6AC) --------------------------------------------------------
void *__fastcall sub_BC6AC(_DWORD *a1)
{
  return sub_BC61C((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BC6B8) --------------------------------------------------------
int __fastcall sub_BC6B8(int a1, _DWORD *a2, __int64 a3, int whence, int a5)
{
  int v5; // r7
  _DWORD *v6; // r6
  __int64 v7; // r4
  int v8; // r1
  int result; // r0
  signed __int64 v10; // r0
  signed __int64 v11; // r2
  bool v12; // zf
  int v13; // r0
  int v14; // r1

  v5 = a1;
  *(_QWORD *)a1 = -1LL;
  v6 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  v7 = a3;
  if ( !sub_BC124(a2) )
    return v5;
  v10 = sub_A9824((int)(v6 + 9), v8, v7, whence);
  v11 = v10;
  v12 = HIDWORD(v10) == -1;
  if ( HIDWORD(v10) == -1 )
    v12 = (_DWORD)v10 == -1;
  if ( v12 )
    return v5;
  v13 = v6[22];
  v14 = v6[15];
  v6[25] = v13;
  v6[24] = v13;
  result = v5;
  *((_BYTE *)v6 + 69) = 0;
  *((_BYTE *)v6 + 70) = 0;
  v6[5] = 0;
  v6[4] = 0;
  v6[6] = 0;
  v6[13] = a5;
  *(_QWORD *)v5 = v11;
  *(_DWORD *)(v5 + 8) = a5;
  v6[1] = v14;
  v6[2] = v14;
  v6[3] = v14;
  return result;
}

//----- (000BC740) --------------------------------------------------------
signed int __fastcall sub_BC740(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  _BYTE *v4; // r1
  _BYTE *v5; // r2
  int v7; // r0
  bool v8; // zf
  unsigned int v9; // r1
  int v10; // r2
  int v11; // r0
  int v12; // r6
  int v13; // r2
  int v14; // r3
  int v15; // r0
  int v16; // r1
  int v17; // r3
  int v18; // r3
  int v19; // r2
  unsigned int v20; // r2
  int v21; // [sp+8h] [bp-28h]
  int v22; // [sp+Ch] [bp-24h]

  v2 = a1;
  v3 = a2;
  if ( !(*(_DWORD *)(a1 + 44) & 0x10) )
    return -1;
  if ( *(_BYTE *)(a1 + 69) )
  {
    if ( *(_BYTE *)(a1 + 80) )
    {
      v12 = *(_DWORD *)(a1 + 76);
      v13 = *(_DWORD *)(a1 + 60);
      v14 = *(_DWORD *)(a1 + 4);
      v15 = *(_DWORD *)(a1 + 8);
      v16 = *(_DWORD *)(v2 + 72);
      *(_DWORD *)(v2 + 12) = v12;
      if ( v15 == v14 )
        v17 = v16;
      else
        v17 = v16 + 1;
      *(_DWORD *)(v2 + 4) = v13;
      *(_DWORD *)(v2 + 72) = v17;
      *(_DWORD *)(v2 + 8) = v17;
      *(_BYTE *)(v2 + 80) = 0;
    }
    v7 = sub_BC0E4(v2);
    sub_BC6B8((int)&v21, (_DWORD *)v2, v7, 1, *(_DWORD *)(v2 + 56));
    v8 = v22 == -1;
    if ( v22 == -1 )
      v8 = v21 == -1;
    if ( v8 )
      return -1;
  }
  v4 = *(_BYTE **)(v2 + 16);
  v5 = *(_BYTE **)(v2 + 20);
  if ( v4 < v5 )
  {
    if ( (unsigned int)(v3 + 1) > 0 )
    {
      *v5 = v3;
      v4 = *(_BYTE **)(v2 + 16);
      v5 = (_BYTE *)(*(_DWORD *)(v2 + 20) + 1);
      *(_DWORD *)(v2 + 20) = v5;
    }
    if ( !sub_BBFE8(v2, v4, v5 - v4) )
      return -1;
    v18 = *(_DWORD *)(v2 + 60);
    v19 = *(_DWORD *)(v2 + 44) << 27;
    *(_DWORD *)(v2 + 4) = v18;
    *(_DWORD *)(v2 + 8) = v18;
    *(_DWORD *)(v2 + 12) = v18;
    if ( v19 >= 0 || (v20 = *(_DWORD *)(v2 + 64), v20 <= 1) )
    {
      *(_DWORD *)(v2 + 20) = 0;
      *(_DWORD *)(v2 + 16) = 0;
      *(_DWORD *)(v2 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 20) = v18;
      *(_DWORD *)(v2 + 16) = v18;
      *(_DWORD *)(v2 + 24) = v20 - 1 + v18;
    }
    goto LABEL_28;
  }
  v9 = *(_DWORD *)(v2 + 64);
  if ( v9 > 1 )
  {
    v10 = *(_DWORD *)(v2 + 60);
    v11 = *(_DWORD *)(v2 + 44) & 0x10;
    if ( v11 )
      --v9;
    else
      *(_DWORD *)(v2 + 20) = 0;
    if ( v11 )
      v9 += v10;
    else
      *(_DWORD *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 4) = v10;
    *(_DWORD *)(v2 + 8) = v10;
    *(_DWORD *)(v2 + 12) = v10;
    if ( v11 )
    {
      *(_DWORD *)(v2 + 20) = v10;
      *(_DWORD *)(v2 + 16) = v10;
    }
    if ( v11 )
      *(_DWORD *)(v2 + 24) = v9;
    else
      *(_DWORD *)(v2 + 24) = 0;
    *(_BYTE *)(v2 + 70) = 1;
    if ( (unsigned int)(v3 + 1) > 0 )
      *(_BYTE *)(*(_DWORD *)(v2 + 20))++ = v3;
LABEL_28:
    if ( v3 == -1 )
      v3 = 0;
    return v3;
  }
  LOBYTE(v21) = v3;
  if ( (unsigned int)(v3 + 1) > 0 && !sub_BBFE8(v2, &v21, 1u) )
    return -1;
  if ( v3 == -1 )
    v3 = 0;
  *(_BYTE *)(v2 + 70) = 1;
  return v3;
}

//----- (000BC884) --------------------------------------------------------
int __fastcall sub_BC884(int a1, int a2, unsigned int a3, int a4, int whence)
{
  int v5; // r7
  int v6; // r0
  int v7; // r6
  unsigned int v8; // r5
  int v9; // r8
  int v10; // r0
  int v11; // r4
  bool v12; // r10
  int v13; // r2
  int v14; // r3
  bool v15; // zf
  signed int v16; // r10
  int v17; // r8
  __int64 v18; // r4
  signed __int64 v19; // r0
  bool v20; // zf
  int v22; // r0
  int v23; // r1
  int v24; // r2
  int v25; // r3
  int v26; // r1
  int v27; // r2
  int v28; // [sp+Ch] [bp-3Ch]
  char v29; // [sp+10h] [bp-38h]
  int v30; // [sp+14h] [bp-34h]
  int v31; // [sp+18h] [bp-30h]

  v5 = a1;
  v6 = *(_DWORD *)(a2 + 84);
  v7 = a2;
  v8 = a3;
  v9 = a4;
  if ( v6 )
  {
    v10 = (*(int (**)(void))(*(_DWORD *)v6 + 20))();
    v11 = v10;
    if ( v10 >= 0 )
    {
      v12 = v10 <= 0;
    }
    else
    {
      v12 = 1;
      v11 = 0;
    }
  }
  else
  {
    v11 = 0;
    v12 = 1;
  }
  *(_QWORD *)v5 = -1LL;
  *(_DWORD *)(v5 + 8) = 0;
  if ( !sub_A9714((_DWORD *)(v7 + 36)) )
    return v5;
  v13 = v8 | v9;
  v14 = v8 | v9 ? v12 : 0;
  if ( v14 )
    return v5;
  v15 = v13 == 0;
  if ( !v13 )
    v15 = whence == 1;
  if ( v15 && (!*(_BYTE *)(v7 + 70) || (*(int (**)(void))(**(_DWORD **)(v7 + 84) + 24))()) )
  {
    v16 = 1;
  }
  else
  {
    v16 = *(unsigned __int8 *)(v7 + 80);
    if ( *(_BYTE *)(v7 + 80) )
    {
      v22 = *(_DWORD *)(v7 + 60);
      v16 = 0;
      v23 = *(_DWORD *)(v7 + 8);
      v24 = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 76);
      v25 = *(_DWORD *)(v7 + 72);
      *(_DWORD *)(v7 + 4) = v22;
      if ( v23 != v24 )
        ++v25;
      *(_BYTE *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 72) = v25;
      *(_DWORD *)(v7 + 8) = v25;
    }
  }
  v17 = v11 * v9 + v8 * (v11 >> 31);
  v28 = *(_DWORD *)(v7 + 48);
  v18 = (unsigned int)v11 * (unsigned __int64)v8;
  HIDWORD(v18) += v17;
  if ( *(_BYTE *)(v7 + 69) && (unsigned int)(whence - 1) <= 0 )
  {
    v28 = *(_DWORD *)(v7 + 56);
    v18 += sub_BC0E4(v7);
  }
  if ( v16 )
  {
    if ( *(_BYTE *)(v7 + 70) )
      v18 = *(_DWORD *)(v7 + 20) - *(_DWORD *)(v7 + 16);
    v19 = sub_A9824(v7 + 36, 1, 0LL, 1);
    v20 = HIDWORD(v19) == -1;
    if ( HIDWORD(v19) == -1 )
      v20 = (_DWORD)v19 == -1;
    if ( !v20 )
    {
      *(_QWORD *)v5 = v18 + v19;
      *(_DWORD *)(v5 + 8) = v28;
    }
    return v5;
  }
  sub_BC6B8((int)&v29, (_DWORD *)v7, v18, whence, v28);
  v26 = v30;
  v27 = v31;
  *(_DWORD *)v5 = *(_DWORD *)&v29;
  *(_DWORD *)(v5 + 4) = v26;
  *(_DWORD *)(v5 + 8) = v27;
  return v5;
}

//----- (000BC9E4) --------------------------------------------------------
_DWORD *__fastcall sub_BC9E4(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r6
  int v6; // r7
  int v7; // r1
  int v8; // r2
  int v10; // r1
  int v11; // r2
  int v12; // r4
  int v13; // r3
  int v14; // r0
  int v15; // r3
  char v16; // [sp+8h] [bp-30h]
  int v17; // [sp+Ch] [bp-2Ch]
  int v18; // [sp+10h] [bp-28h]
  int v19; // [sp+30h] [bp-8h]
  int v20; // [sp+34h] [bp-4h]

  v5 = a1;
  v6 = a2;
  *(_QWORD *)a1 = -1LL;
  a1[2] = 0;
  v19 = a3;
  v20 = a4;
  if ( sub_A9714((_DWORD *)(a2 + 36)) )
  {
    if ( *(_BYTE *)(v6 + 80) )
    {
      v10 = *(_DWORD *)(v6 + 76);
      v11 = *(_DWORD *)(v6 + 60);
      v12 = *(_DWORD *)(v6 + 8);
      v13 = *(_DWORD *)(v6 + 4);
      v14 = *(_DWORD *)(v6 + 72);
      *(_BYTE *)(v6 + 80) = 0;
      if ( v12 == v13 )
        v15 = v14;
      else
        v15 = v14 + 1;
      *(_DWORD *)(v6 + 12) = v10;
      *(_DWORD *)(v6 + 72) = v15;
      *(_DWORD *)(v6 + 8) = v15;
      *(_DWORD *)(v6 + 4) = v11;
    }
    sub_BC6B8((int)&v16, (_DWORD *)v6, *(__int64 *)&v19, 0, a5);
    v7 = v17;
    v8 = v18;
    *v5 = *(_DWORD *)&v16;
    v5[1] = v7;
    v5[2] = v8;
  }
  return v5;
}

//----- (000BCA64) --------------------------------------------------------
int __fastcall sub_BCA64(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r5
  int result; // r0
  int v6; // r0
  int v7; // r6
  int v8; // r0
  int v9; // r3
  int v10; // r8
  int v11; // r3
  int v12; // ST00_4
  int v13; // r0
  int v14; // r3
  size_t v15; // r7
  int v16; // r1
  int v17; // r6
  int v18; // [sp+8h] [bp-28h]
  int v19; // [sp+Ch] [bp-24h]

  v2 = a1;
  v3 = a2;
  if ( sub_98FCC(a2) )
    v4 = sub_98048(v3);
  else
    v4 = 0;
  result = sub_A9714(v2 + 9);
  if ( !result || !*((_BYTE *)v2 + 69) && !*((_BYTE *)v2 + 70) )
    goto LABEL_4;
  v6 = v2[21];
  if ( !v6 )
    goto LABEL_24;
  result = (*(int (**)(void))(*(_DWORD *)v6 + 20))() + 1;
  if ( result )
  {
    v7 = *((unsigned __int8 *)v2 + 69);
    if ( *((_BYTE *)v2 + 69) )
    {
      v8 = v2[21];
      if ( v8 )
      {
        result = (*(int (**)(void))(*(_DWORD *)v8 + 24))();
        if ( result )
        {
          if ( v4 )
          {
            result = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 24))(v4);
            if ( !result )
            {
              result = (*(int (__fastcall **)(int *, _DWORD *, _DWORD, _DWORD, signed int, _DWORD))(*v2 + 16))(
                         &v18,
                         v2,
                         0,
                         0,
                         1,
                         v2[11]);
              if ( (v19 & v18) == -1 )
                goto LABEL_14;
            }
          }
        }
        else
        {
          v10 = v2[22];
          v11 = v2[24];
          v12 = v2[2] - v2[1];
          v13 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)v2[21] + 28))(v2[21]);
          v14 = v2[25];
          v2[24] = v10 + v13;
          v15 = v14 - (v10 + v13);
          if ( v14 != v10 + v13 )
            memmove((void *)v2[22], (const void *)(v10 + v13), v15);
          v16 = v2[15];
          v17 = v2[22];
          result = v2[12];
          v2[1] = v16;
          v2[24] = v17;
          v2[25] = v15 + v17;
          v2[2] = v16;
          v2[3] = v16;
          v2[13] = result;
          v2[14] = result;
          v2[5] = 0;
          v2[4] = 0;
          v2[6] = 0;
        }
LABEL_4:
        v2[21] = v4;
        return result;
      }
LABEL_24:
      sub_BFA38();
    }
    if ( !*((_BYTE *)v2 + 70) )
      goto LABEL_4;
    result = sub_BC124(v2);
    if ( result )
    {
      v9 = v2[15];
      v2[5] = v7;
      v2[4] = v7;
      v2[6] = v7;
      v2[1] = v9;
      v2[2] = v9;
      v2[3] = v9;
      goto LABEL_4;
    }
  }
LABEL_14:
  v2[21] = 0;
  return result;
}

//----- (000BDC64) --------------------------------------------------------
_DWORD *__fastcall sub_BDC64(_DWORD *a1)
{
  int v1; // r7
  _DWORD *v2; // r4

  v1 = (int)(a1 + 7);
  v2 = a1;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_F0858;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_A93A8(a1 + 7);
  v2[8] = 0;
  *v2 = &off_F2030;
  sub_A9664((int)(v2 + 9));
  v2[11] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  *((_BYTE *)v2 + 68) = 0;
  *((_BYTE *)v2 + 69) = 0;
  *((_BYTE *)v2 + 70) = 0;
  v2[18] = 0;
  v2[19] = 0;
  v2[20] = 0;
  *((_BYTE *)v2 + 84) = 0;
  v2[22] = 0;
  v2[23] = 0;
  v2[24] = 0;
  v2[25] = 0;
  v2[26] = 0;
  v2[16] = 1024;
  if ( sub_AF1FC(v1) )
    v2[22] = sub_AE2A4(v1);
  return v2;
}
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;

//----- (000BDD18) --------------------------------------------------------
_DWORD *__fastcall sub_BDD18(_DWORD *result)
{
  _DWORD *v1; // r4
  unsigned int v2; // r0
  unsigned int v3; // r0

  v1 = result;
  if ( !*((_BYTE *)result + 68) && !result[15] )
  {
    v2 = result[16];
    if ( v2 > 0x1FC00000 )
      v3 = -1;
    else
      v3 = 4 * v2;
    result = operator new[](v3);
    *((_BYTE *)v1 + 68) = 1;
    v1[15] = result;
  }
  return result;
}

//----- (000BDD44) --------------------------------------------------------
void __fastcall sub_BDD44(int a1)
{
  int v1; // r4
  void *v2; // r0
  void *v3; // r0

  v1 = a1;
  if ( *(_BYTE *)(a1 + 68) )
  {
    v2 = *(void **)(a1 + 60);
    if ( v2 )
      operator delete[](v2);
    *(_DWORD *)(v1 + 60) = 0;
    *(_BYTE *)(v1 + 68) = 0;
  }
  v3 = *(void **)(v1 + 92);
  if ( v3 )
    operator delete[](v3);
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 100) = 0;
  *(_DWORD *)(v1 + 104) = 0;
}

//----- (000BDD74) --------------------------------------------------------
int *__fastcall sub_BDD74(int *a1)
{
  int v1; // r3
  int *v2; // r5
  int v3; // r3
  int *result; // r0
  int v5; // r2
  int v6; // r1

  v1 = *a1;
  v2 = a1;
  *(_DWORD *)(v1 + 44) = 0;
  *(_BYTE *)(v1 + 84) = 0;
  sub_BDD44(v1);
  v3 = *v2;
  result = v2;
  v5 = *(_DWORD *)(*v2 + 60);
  v6 = *(_DWORD *)(*v2 + 48);
  *(_BYTE *)(v3 + 69) = 0;
  *(_BYTE *)(v3 + 70) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 4) = v5;
  *(_DWORD *)(v3 + 8) = v5;
  *(_DWORD *)(v3 + 12) = v5;
  *(_DWORD *)(v3 + 52) = v6;
  *(_DWORD *)(v3 + 56) = v6;
  return result;
}

//----- (000BDDAC) --------------------------------------------------------
bool __fastcall sub_BDDAC(int a1, void *a2, size_t a3)
{
  int v3; // r4
  void *v4; // r6
  int v5; // r0
  size_t v6; // r5
  int v7; // r0
  unsigned int v8; // r0
  int v9; // r0
  int v11; // r3
  char v12[4]; // [sp+10h] [bp+0h]
  unsigned int v13; // [sp+14h] [bp+4h]
  int v14; // [sp+18h] [bp+8h]
  int v15; // [sp+1Ch] [bp+Ch]

  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a1 + 88);
  v6 = a3;
  if ( !v5 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v5 + 24))() )
    goto LABEL_5;
  v7 = (*(int (**)(void))(**(_DWORD **)(v3 + 88) + 32))();
  v8 = (*(int (__fastcall **)(_DWORD, int, void *, size_t, int *, char *, char *, int *))(**(_DWORD **)(v3 + 88) + 8))(
         *(_DWORD *)(v3 + 88),
         v3 + 52,
         v4,
         (size_t)v4 + 4 * v6,
         &v15,
         v12,
         &v12[v7 * v6],
         &v14);
  if ( v8 > 1 )
  {
    if ( v8 == 3 )
    {
LABEL_5:
      v9 = sub_A97A4(v3 + 36, v4, v6);
      return v9 - v6 <= 0;
    }
LABEL_13:
    sub_BFDD4("basic_filebuf::_M_convert_to_external conversion error");
  }
  v13 = v8;
  v6 = v14 - (_DWORD)v12;
  v9 = sub_A97A4(v3 + 36, v12, v14 - (_DWORD)v12);
  if ( v6 == v9 )
    v11 = v13 & 1;
  else
    v11 = 0;
  if ( v11 )
  {
    if ( (*(int (__cdecl **)(_DWORD, int, int, unsigned int))(**(_DWORD **)(v3 + 88) + 8))(
           *(_DWORD *)(v3 + 88),
           v3 + 52,
           v15,
           ((*(_DWORD *)(v3 + 20) - v15) & 0xFFFFFFFC) + v15) != 2 )
    {
      v6 = v14 - (_DWORD)v12;
      v9 = sub_A97A4(v3 + 36, v12, v14 - (_DWORD)v12);
      return v9 - v6 <= 0;
    }
    goto LABEL_13;
  }
  return v9 - v6 <= 0;
}
// BDDAC: using guessed type char var_14[4];

//----- (000BDEB0) --------------------------------------------------------
int __fastcall sub_BDEB0(int a1)
{
  int v1; // r4
  int v3; // r2
  int v4; // r3
  int v5; // ST00_4

  v1 = a1;
  if ( (*(int (**)(void))(**(_DWORD **)(a1 + 88) + 24))() )
    return (*(_DWORD *)(v1 + 8) - *(_DWORD *)(v1 + 12)) >> 2;
  v3 = *(_DWORD *)(v1 + 92);
  v4 = *(_DWORD *)(v1 + 100);
  v5 = (*(_DWORD *)(v1 + 8) - *(_DWORD *)(v1 + 4)) >> 2;
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(v1 + 88) + 28))(*(_DWORD *)(v1 + 88))
       + *(_DWORD *)(v1 + 92)
       - *(_DWORD *)(v1 + 104);
}

//----- (000BDEF4) --------------------------------------------------------
bool __fastcall sub_BDEF4(_DWORD *a1)
{
  _DWORD *v1; // r10
  _BOOL4 v2; // r4
  int v3; // r0
  int v4; // r8
  unsigned int v5; // r0
  unsigned int v6; // r4
  int v8; // [sp+Ch] [bp-A4h]
  char v9; // [sp+10h] [bp-A0h]

  v1 = a1;
  if ( a1[4] < a1[5] )
    v2 = (*(int (**)(void))(*a1 + 52))() != -1;
  else
    v2 = 1;
  if ( !*((_BYTE *)v1 + 70) )
    return v2;
  v3 = v1[22];
  if ( !v3 )
    sub_BFA38();
  if ( (*(int (**)(void))(*(_DWORD *)v3 + 24))() || !v2 )
    return v2;
  v4 = 0;
  while ( 1 )
  {
    v5 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)v1[22] + 12))(v1[22]);
    v6 = v5;
    if ( v5 == 2 )
      break;
    if ( v5 <= 1 )
    {
      v4 = v8 - (_DWORD)&v9;
      if ( v8 - (signed int)&v9 <= 0 )
        return (*(int (__fastcall **)(_DWORD *, signed int))(*v1 + 52))(v1, -1) != -1;
      if ( v4 != sub_A97A4((int)(v1 + 9), &v9, v8 - (_DWORD)&v9) )
        break;
    }
    if ( v4 <= 0 || v6 != 1 )
      return (*(int (__fastcall **)(_DWORD *, signed int))(*v1 + 52))(v1, -1) != -1;
  }
  return 0;
}

//----- (000BDFB0) --------------------------------------------------------
int __fastcall sub_BDFB0(int a1)
{
  _DWORD *v1; // r6
  int v2; // r5
  _BOOL4 v3; // r7
  int v4; // r2
  int v5; // r1
  int result; // r0

  v1 = (_DWORD *)(a1 + 36);
  v2 = a1;
  if ( !sub_A9714((_DWORD *)(a1 + 36)) )
    goto LABEL_8;
  v3 = !sub_BDEF4((_DWORD *)v2);
  *(_DWORD *)(v2 + 44) = 0;
  *(_BYTE *)(v2 + 84) = 0;
  sub_BDD44(v2);
  v4 = *(_DWORD *)(v2 + 60);
  v5 = *(_DWORD *)(v2 + 48);
  *(_BYTE *)(v2 + 69) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 4) = v4;
  *(_DWORD *)(v2 + 8) = v4;
  *(_DWORD *)(v2 + 12) = v4;
  *(_DWORD *)(v2 + 52) = v5;
  *(_DWORD *)(v2 + 56) = v5;
  if ( !sub_A972C(v1, v5, v4) )
    goto LABEL_8;
  if ( !v3 )
    result = v2;
  else
LABEL_8:
    result = 0;
  return result;
}

//----- (000BE044) --------------------------------------------------------
unsigned int **__fastcall sub_BE044(_DWORD *a1)
{
  unsigned int **v1; // r4
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2

  v1 = (unsigned int **)a1;
  *a1 = &off_F2030;
  v2 = a1 + 9;
  sub_BDFB0((int)a1);
  sub_A9768(v2, v3, v4);
  *v1 = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 7);
  return v1;
}
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;

//----- (000BE07C) --------------------------------------------------------
int __fastcall sub_BE07C(int a1, const char *a2, int a3)
{
  _DWORD *v3; // r6
  int v4; // r4
  const char *v5; // r8
  int v6; // r7
  int v7; // r3
  int v8; // r2
  bool v10; // zf
  int v11; // [sp+8h] [bp-28h]
  int v12; // [sp+Ch] [bp-24h]

  v3 = (_DWORD *)(a1 + 36);
  v4 = a1;
  v5 = a2;
  v6 = a3;
  if ( sub_A9714((_DWORD *)(a1 + 36)) )
    return 0;
  sub_A96E8((int)v3, v5, v6);
  if ( !sub_A9714(v3) )
    return 0;
  sub_BDD18((_DWORD *)v4);
  v7 = *(_DWORD *)(v4 + 60);
  v8 = *(_DWORD *)(v4 + 48);
  *(_DWORD *)(v4 + 44) = v6;
  *(_DWORD *)(v4 + 4) = v7;
  *(_DWORD *)(v4 + 8) = v7;
  *(_DWORD *)(v4 + 12) = v7;
  *(_BYTE *)(v4 + 69) = 0;
  *(_BYTE *)(v4 + 70) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 52) = v8;
  *(_DWORD *)(v4 + 56) = v8;
  if ( !(v6 & 2) )
    return v4;
  (*(void (__fastcall **)(int *, int, _DWORD, _DWORD, signed int, int))(*(_DWORD *)v4 + 16))(&v11, v4, 0, 0, 2, v6);
  v10 = v12 == -1;
  if ( v12 == -1 )
    v10 = v11 == -1;
  if ( !v10 )
    return v4;
  sub_BDFB0(v4);
  return 0;
}

//----- (000BE11C) --------------------------------------------------------
unsigned int **__fastcall sub_BE11C(_DWORD *a1)
{
  unsigned int **v1; // r4
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2

  v1 = (unsigned int **)a1;
  *a1 = &off_F2030;
  v2 = a1 + 9;
  sub_BDFB0((int)a1);
  sub_A9768(v2, v3, v4);
  *v1 = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 7);
  operator delete(v1);
  return v1;
}
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;

//----- (000BE15C) --------------------------------------------------------
unsigned int **__fastcall sub_BE15C(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F210C;
  a1[28] = (unsigned int *)&off_F2120;
  a1[1] = (unsigned int *)&off_F2030;
  sub_BDFB0((int)(a1 + 1));
  sub_A9768(v1 + 10, v2, v3);
  v1[1] = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 8);
  *v1 = (unsigned int *)&off_F20D4;
  v1[28] = (unsigned int *)&off_F06A0;
  sub_95E1C(v1 + 28);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F20D4: using guessed type void *off_F20D4;
// F210C: using guessed type void *off_F210C;
// F2120: using guessed type void *off_F2120;

//----- (000BE1C8) --------------------------------------------------------
unsigned int **__fastcall sub_BE1C8(_DWORD *a1)
{
  return sub_BE15C((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE1D4) --------------------------------------------------------
unsigned int **__fastcall sub_BE1D4(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = (unsigned int *)&off_F20AC;
  a1[29] = (unsigned int *)&off_F20C0;
  a1[2] = (unsigned int *)&off_F2030;
  sub_BDFB0((int)(a1 + 2));
  sub_A9768(v1 + 11, v2, v3);
  v1[2] = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 9);
  v1[1] = 0;
  *v1 = (unsigned int *)&off_F2074;
  v1[29] = (unsigned int *)&off_F06A0;
  sub_95E1C(v1 + 29);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F2074: using guessed type void *off_F2074;
// F20AC: using guessed type void *off_F20AC;
// F20C0: using guessed type void *off_F20C0;

//----- (000BE244) --------------------------------------------------------
unsigned int **__fastcall sub_BE244(_DWORD *a1)
{
  return sub_BE1D4((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE250) --------------------------------------------------------
void *__fastcall sub_BE250(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = &off_F210C;
  a1[28] = &off_F2120;
  a1[1] = &off_F2030;
  sub_BDFB0((int)(a1 + 1));
  sub_A9768((_DWORD *)v1 + 10, v2, v3);
  *((_DWORD *)v1 + 1) = &off_F0858;
  sub_AB620((unsigned int **)v1 + 8);
  *(_DWORD *)v1 = &off_F20D4;
  *((_DWORD *)v1 + 28) = &off_F06A0;
  sub_95E1C((_DWORD *)v1 + 28);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F20D4: using guessed type void *off_F20D4;
// F210C: using guessed type void *off_F210C;
// F2120: using guessed type void *off_F2120;

//----- (000BE2C4) --------------------------------------------------------
void *__fastcall sub_BE2C4(_DWORD *a1)
{
  return sub_BE250((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE2D0) --------------------------------------------------------
void *__fastcall sub_BE2D0(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  *a1 = &off_F20AC;
  a1[29] = &off_F20C0;
  a1[2] = &off_F2030;
  sub_BDFB0((int)(a1 + 2));
  sub_A9768((_DWORD *)v1 + 11, v2, v3);
  *((_DWORD *)v1 + 2) = &off_F0858;
  sub_AB620((unsigned int **)v1 + 9);
  *((_DWORD *)v1 + 1) = 0;
  *(_DWORD *)v1 = &off_F2074;
  *((_DWORD *)v1 + 29) = &off_F06A0;
  sub_95E1C((_DWORD *)v1 + 29);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F2074: using guessed type void *off_F2074;
// F20AC: using guessed type void *off_F20AC;
// F20C0: using guessed type void *off_F20C0;

//----- (000BE348) --------------------------------------------------------
void *__fastcall sub_BE348(_DWORD *a1)
{
  return sub_BE2D0((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE354) --------------------------------------------------------
unsigned int **__fastcall sub_BE354(unsigned int **a1)
{
  unsigned int **v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  a1[30] = (unsigned int *)&off_F2214;
  *a1 = (unsigned int *)&off_F21EC;
  a1[2] = (unsigned int *)&off_F2200;
  a1[3] = (unsigned int *)&off_F2030;
  sub_BDFB0((int)(a1 + 3));
  sub_A9768(v1 + 12, v2, v3);
  v1[3] = (unsigned int *)&off_F0858;
  sub_AB620(v1 + 10);
  v1[1] = 0;
  *v1 = (unsigned int *)&off_F215C;
  v1[2] = (unsigned int *)&off_F2134;
  v1[30] = (unsigned int *)&off_F06A0;
  sub_95E1C(v1 + 30);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F2134: using guessed type void *off_F2134;
// F215C: using guessed type void *off_F215C;
// F21EC: using guessed type void *off_F21EC;
// F2200: using guessed type void *off_F2200;
// F2214: using guessed type void *off_F2214;

//----- (000BE3E0) --------------------------------------------------------
unsigned int **__fastcall sub_BE3E0(_DWORD *a1)
{
  return sub_BE354((unsigned int **)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE3EC) --------------------------------------------------------
void *__fastcall sub_BE3EC(_DWORD *a1)
{
  void *v1; // r4
  int v2; // r1
  int v3; // r2

  v1 = a1;
  a1[30] = &off_F2214;
  *a1 = &off_F21EC;
  a1[2] = &off_F2200;
  a1[3] = &off_F2030;
  sub_BDFB0((int)(a1 + 3));
  sub_A9768((_DWORD *)v1 + 12, v2, v3);
  *((_DWORD *)v1 + 3) = &off_F0858;
  sub_AB620((unsigned int **)v1 + 10);
  *((_DWORD *)v1 + 1) = 0;
  *(_DWORD *)v1 = &off_F215C;
  *((_DWORD *)v1 + 2) = &off_F2134;
  *((_DWORD *)v1 + 30) = &off_F06A0;
  sub_95E1C((_DWORD *)v1 + 30);
  operator delete(v1);
  return v1;
}
// F06A0: using guessed type void *off_F06A0;
// F0858: using guessed type void *off_F0858;
// F2030: using guessed type void *off_F2030;
// F2134: using guessed type void *off_F2134;
// F215C: using guessed type void *off_F215C;
// F21EC: using guessed type void *off_F21EC;
// F2200: using guessed type void *off_F2200;
// F2214: using guessed type void *off_F2214;

//----- (000BE47C) --------------------------------------------------------
void *__fastcall sub_BE47C(_DWORD *a1)
{
  return sub_BE3EC((_DWORD *)((char *)a1 + *(_DWORD *)(*a1 - 12)));
}

//----- (000BE488) --------------------------------------------------------
int __fastcall sub_BE488(int a1, _DWORD *a2, __int64 a3, int whence, int a5)
{
  int v5; // r7
  _DWORD *v6; // r6
  __int64 v7; // r4
  int v8; // r1
  int result; // r0
  signed __int64 v10; // r0
  signed __int64 v11; // r2
  bool v12; // zf
  int v13; // r0
  int v14; // r1

  v5 = a1;
  *(_QWORD *)a1 = -1LL;
  v6 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  v7 = a3;
  if ( !sub_BDEF4(a2) )
    return v5;
  v10 = sub_A9824((int)(v6 + 9), v8, v7, whence);
  v11 = v10;
  v12 = HIDWORD(v10) == -1;
  if ( HIDWORD(v10) == -1 )
    v12 = (_DWORD)v10 == -1;
  if ( v12 )
    return v5;
  v13 = v6[23];
  v14 = v6[15];
  v6[26] = v13;
  v6[25] = v13;
  result = v5;
  *((_BYTE *)v6 + 69) = 0;
  *((_BYTE *)v6 + 70) = 0;
  v6[5] = 0;
  v6[4] = 0;
  v6[6] = 0;
  v6[13] = a5;
  *(_QWORD *)v5 = v11;
  *(_DWORD *)(v5 + 8) = a5;
  v6[1] = v14;
  v6[2] = v14;
  v6[3] = v14;
  return result;
}

//----- (000BE510) --------------------------------------------------------
signed int __fastcall sub_BE510(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  int v4; // r0
  bool v5; // zf
  int *v6; // r1
  int *v7; // r3
  int v8; // r3
  int v9; // r2
  unsigned int v10; // r2
  unsigned int v12; // r2
  int v13; // r3
  int v14; // r1
  int *v15; // r3
  int v16; // r1
  int v17; // r3
  int v18; // r2
  int v19; // r0
  int v20; // r3
  int v21; // r1
  int v22; // r3
  int v23; // [sp+8h] [bp-20h]
  int v24; // [sp+Ch] [bp-1Ch]

  v2 = a1;
  v3 = a2;
  if ( !(*(_DWORD *)(a1 + 44) & 0x10) )
    return -1;
  if ( *(_BYTE *)(a1 + 69) )
  {
    if ( *(_BYTE *)(a1 + 84) )
    {
      v16 = *(_DWORD *)(a1 + 8);
      v17 = *(_DWORD *)(a1 + 4);
      v18 = *(_DWORD *)(a1 + 60);
      v19 = *(_DWORD *)(a1 + 80);
      v20 = v16 - v17;
      v21 = *(_DWORD *)(v2 + 76);
      *(_DWORD *)(v2 + 4) = v18;
      v22 = v21 + 4 * (v20 != 0);
      *(_DWORD *)(v2 + 12) = v19;
      *(_DWORD *)(v2 + 76) = v22;
      *(_DWORD *)(v2 + 8) = v22;
      *(_BYTE *)(v2 + 84) = 0;
    }
    v4 = sub_BDEB0(v2);
    sub_BE488((int)&v23, (_DWORD *)v2, v4, 1, *(_DWORD *)(v2 + 56));
    v5 = v24 == -1;
    if ( v24 == -1 )
      v5 = v23 == -1;
    if ( v5 )
      return -1;
  }
  v6 = *(int **)(v2 + 16);
  v7 = *(int **)(v2 + 20);
  if ( v6 < v7 )
  {
    if ( (unsigned int)(v3 + 1) > 0 )
    {
      *v7 = v3;
      ++v7;
      *(_DWORD *)(v2 + 20) = v7;
    }
    if ( sub_BDDAC(v2, v6, v7 - v6) )
    {
      v8 = *(_DWORD *)(v2 + 60);
      v9 = *(_DWORD *)(v2 + 44) << 27;
      *(_DWORD *)(v2 + 4) = v8;
      *(_DWORD *)(v2 + 8) = v8;
      *(_DWORD *)(v2 + 12) = v8;
      if ( v9 >= 0 || (v10 = *(_DWORD *)(v2 + 64), v10 <= 1) )
      {
        *(_DWORD *)(v2 + 20) = 0;
        *(_DWORD *)(v2 + 16) = 0;
        *(_DWORD *)(v2 + 24) = 0;
      }
      else
      {
        *(_DWORD *)(v2 + 20) = v8;
        *(_DWORD *)(v2 + 16) = v8;
        *(_DWORD *)(v2 + 24) = v8 + 4 * (v10 + 0x3FFFFFFF);
      }
      if ( (unsigned int)(v3 + 1) <= 0 )
        v3 = 0;
      return v3;
    }
    return -1;
  }
  v12 = *(_DWORD *)(v2 + 64);
  if ( v12 <= 1 )
  {
    v23 = v3;
    if ( (unsigned int)(v3 + 1) <= 0 )
    {
      v3 = 0;
    }
    else if ( !sub_BDDAC(v2, &v23, 1u) )
    {
      return -1;
    }
    *(_BYTE *)(v2 + 70) = 1;
    return v3;
  }
  v13 = *(_DWORD *)(v2 + 60);
  v14 = *(_DWORD *)(v2 + 44) & 0x10;
  if ( v14 )
    v12 += 0x40000000;
  else
    *(_DWORD *)(v2 + 20) = 0;
  if ( v14 )
    --v12;
  else
    *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 4) = v13;
  *(_DWORD *)(v2 + 8) = v13;
  if ( v14 )
    v12 = v13 + 4 * v12;
  *(_DWORD *)(v2 + 12) = v13;
  if ( v14 )
  {
    *(_DWORD *)(v2 + 20) = v13;
    *(_DWORD *)(v2 + 16) = v13;
  }
  if ( v14 )
    *(_DWORD *)(v2 + 24) = v12;
  else
    *(_DWORD *)(v2 + 24) = 0;
  *(_BYTE *)(v2 + 70) = 1;
  if ( (unsigned int)(v3 + 1) <= 0 )
    return 0;
  v15 = *(int **)(v2 + 20);
  *v15 = v3;
  *(_DWORD *)(v2 + 20) = v15 + 1;
  return v3;
}

//----- (000BE650) --------------------------------------------------------
int __fastcall sub_BE650(int a1, int a2, unsigned int a3, int a4, int whence)
{
  int v5; // r7
  int v6; // r0
  int v7; // r6
  unsigned int v8; // r5
  int v9; // r8
  int v10; // r0
  int v11; // r4
  bool v12; // r10
  int v13; // r2
  int v14; // r3
  bool v15; // zf
  signed int v16; // r3
  int v17; // r8
  __int64 v18; // r4
  signed __int64 v19; // r0
  bool v20; // zf
  int v22; // r0
  int v23; // r2
  int v24; // r1
  int v25; // r2
  int v26; // r1
  int v27; // r2
  signed int v28; // ST0C_4
  int v29; // r0
  int v30; // [sp+14h] [bp-34h]
  char v31; // [sp+18h] [bp-30h]
  int v32; // [sp+1Ch] [bp-2Ch]
  int v33; // [sp+20h] [bp-28h]

  v5 = a1;
  v6 = *(_DWORD *)(a2 + 88);
  v7 = a2;
  v8 = a3;
  v9 = a4;
  if ( v6 )
  {
    v10 = (*(int (**)(void))(*(_DWORD *)v6 + 20))();
    v11 = v10;
    if ( v10 >= 0 )
    {
      v12 = v10 <= 0;
    }
    else
    {
      v12 = 1;
      v11 = 0;
    }
  }
  else
  {
    v11 = 0;
    v12 = 1;
  }
  *(_QWORD *)v5 = -1LL;
  *(_DWORD *)(v5 + 8) = 0;
  if ( !sub_A9714((_DWORD *)(v7 + 36)) )
    return v5;
  v13 = v8 | v9;
  v14 = v8 | v9 ? v12 : 0;
  if ( v14 )
    return v5;
  v15 = v13 == 0;
  if ( !v13 )
    v15 = whence == 1;
  if ( v15 && (!*(_BYTE *)(v7 + 70) || (*(int (**)(void))(**(_DWORD **)(v7 + 88) + 24))()) )
  {
    v16 = 1;
  }
  else
  {
    v16 = *(unsigned __int8 *)(v7 + 84);
    if ( *(_BYTE *)(v7 + 84) )
    {
      v16 = 0;
      v22 = *(_DWORD *)(v7 + 60);
      v23 = *(_DWORD *)(v7 + 8) - *(_DWORD *)(v7 + 4);
      v24 = *(_DWORD *)(v7 + 80);
      *(_BYTE *)(v7 + 84) = 0;
      *(_DWORD *)(v7 + 4) = v22;
      *(_DWORD *)(v7 + 12) = v24;
      v25 = *(_DWORD *)(v7 + 76) + 4 * (v23 != 0);
      *(_DWORD *)(v7 + 76) = v25;
      *(_DWORD *)(v7 + 8) = v25;
    }
  }
  v17 = v11 * v9 + v8 * (v11 >> 31);
  v30 = *(_DWORD *)(v7 + 48);
  v18 = (unsigned int)v11 * (unsigned __int64)v8;
  HIDWORD(v18) += v17;
  if ( *(_BYTE *)(v7 + 69) && (unsigned int)(whence - 1) <= 0 )
  {
    v30 = *(_DWORD *)(v7 + 56);
    v28 = v16;
    v29 = sub_BDEB0(v7);
    v16 = v28;
    v18 += v29;
  }
  if ( v16 )
  {
    if ( *(_BYTE *)(v7 + 70) )
      v18 = (*(_DWORD *)(v7 + 20) - *(_DWORD *)(v7 + 16)) >> 2;
    v19 = sub_A9824(v7 + 36, 1, 0LL, 1);
    v20 = HIDWORD(v19) == -1;
    if ( HIDWORD(v19) == -1 )
      v20 = (_DWORD)v19 == -1;
    if ( !v20 )
    {
      *(_QWORD *)v5 = v18 + v19;
      *(_DWORD *)(v5 + 8) = v30;
    }
    return v5;
  }
  sub_BE488((int)&v31, (_DWORD *)v7, v18, whence, v30);
  v26 = v32;
  v27 = v33;
  *(_DWORD *)v5 = *(_DWORD *)&v31;
  *(_DWORD *)(v5 + 4) = v26;
  *(_DWORD *)(v5 + 8) = v27;
  return v5;
}

//----- (000BE7B4) --------------------------------------------------------
_DWORD *__fastcall sub_BE7B4(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r6
  int v6; // r7
  int v7; // r1
  int v8; // r2
  int v10; // r1
  int v11; // r3
  int v12; // r2
  int v13; // r0
  int v14; // r3
  char v15; // [sp+8h] [bp-30h]
  int v16; // [sp+Ch] [bp-2Ch]
  int v17; // [sp+10h] [bp-28h]
  int v18; // [sp+30h] [bp-8h]
  int v19; // [sp+34h] [bp-4h]

  v5 = a1;
  v6 = a2;
  *(_QWORD *)a1 = -1LL;
  a1[2] = 0;
  v18 = a3;
  v19 = a4;
  if ( sub_A9714((_DWORD *)(a2 + 36)) )
  {
    if ( *(_BYTE *)(v6 + 84) )
    {
      v10 = *(_DWORD *)(v6 + 80);
      v11 = *(_DWORD *)(v6 + 8) - *(_DWORD *)(v6 + 4);
      v12 = *(_DWORD *)(v6 + 60);
      v13 = *(_DWORD *)(v6 + 76);
      if ( *(_DWORD *)(v6 + 8) != *(_DWORD *)(v6 + 4) )
        v11 = 1;
      *(_BYTE *)(v6 + 84) = 0;
      v14 = v13 + 4 * v11;
      *(_DWORD *)(v6 + 12) = v10;
      *(_DWORD *)(v6 + 76) = v14;
      *(_DWORD *)(v6 + 8) = v14;
      *(_DWORD *)(v6 + 4) = v12;
    }
    sub_BE488((int)&v15, (_DWORD *)v6, *(__int64 *)&v18, 0, a5);
    v7 = v16;
    v8 = v17;
    *v5 = *(_DWORD *)&v15;
    v5[1] = v7;
    v5[2] = v8;
  }
  return v5;
}

//----- (000BE838) --------------------------------------------------------
int __fastcall sub_BE838(_DWORD *a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r5
  int result; // r0
  int v6; // r0
  int v7; // r6
  int v8; // r0
  int v9; // r3
  int v10; // r6
  int v11; // r3
  int v12; // ST00_4
  int v13; // r0
  int v14; // r3
  size_t v15; // r7
  int v16; // r1
  int v17; // r6
  int v18; // [sp+8h] [bp-28h]
  int v19; // [sp+Ch] [bp-24h]

  v2 = a1;
  v3 = a2;
  if ( sub_AF1FC(a2) )
    v4 = sub_AE2A4(v3);
  else
    v4 = 0;
  result = sub_A9714(v2 + 9);
  if ( !result || !*((_BYTE *)v2 + 69) && !*((_BYTE *)v2 + 70) )
    goto LABEL_4;
  v6 = v2[22];
  if ( !v6 )
    goto LABEL_24;
  result = (*(int (**)(void))(*(_DWORD *)v6 + 20))() + 1;
  if ( result )
  {
    v7 = *((unsigned __int8 *)v2 + 69);
    if ( *((_BYTE *)v2 + 69) )
    {
      v8 = v2[22];
      if ( v8 )
      {
        result = (*(int (**)(void))(*(_DWORD *)v8 + 24))();
        if ( result )
        {
          if ( v4 )
          {
            result = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 24))(v4);
            if ( !result )
            {
              result = (*(int (__fastcall **)(int *, _DWORD *, _DWORD, _DWORD, signed int, _DWORD))(*v2 + 16))(
                         &v18,
                         v2,
                         0,
                         0,
                         1,
                         v2[11]);
              if ( (v19 & v18) == -1 )
                goto LABEL_14;
            }
          }
        }
        else
        {
          v10 = v2[23];
          v11 = v2[25];
          v12 = (v2[2] - v2[1]) >> 2;
          v13 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)v2[22] + 28))(v2[22]);
          v14 = v2[26];
          v2[25] = v10 + v13;
          v15 = v14 - (v10 + v13);
          if ( v14 != v10 + v13 )
            memmove((void *)v2[23], (const void *)(v10 + v13), v15);
          v16 = v2[15];
          v17 = v2[23];
          result = v2[12];
          v2[1] = v16;
          v2[25] = v17;
          v2[26] = v15 + v17;
          v2[2] = v16;
          v2[3] = v16;
          v2[13] = result;
          v2[14] = result;
          v2[5] = 0;
          v2[4] = 0;
          v2[6] = 0;
        }
LABEL_4:
        v2[22] = v4;
        return result;
      }
LABEL_24:
      sub_BFA38();
    }
    if ( !*((_BYTE *)v2 + 70) )
      goto LABEL_4;
    result = sub_BDEF4(v2);
    if ( result )
    {
      v9 = v2[15];
      v2[5] = v7;
      v2[4] = v7;
      v2[6] = v7;
      v2[1] = v9;
      v2[2] = v9;
      v2[3] = v9;
      goto LABEL_4;
    }
  }
LABEL_14:
  v2[22] = 0;
  return result;
}

//----- (000BFA08) --------------------------------------------------------
void __noreturn sub_BFA08()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F0678;
  _cxa_throw((int)v0, (int)&`typeinfo for'std::bad_alloc, (int)std::bad_alloc::~bad_alloc);
}
// F0660: using guessed type void *`typeinfo for'std::bad_alloc;
// F0678: using guessed type void *off_F0678;

//----- (000BFA38) --------------------------------------------------------
void __noreturn sub_BFA38()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F23E0;
  _cxa_throw((int)v0, (int)&`typeinfo for'std::bad_cast, (int)std::bad_cast::~bad_cast);
}
// F23CC: using guessed type void *`typeinfo for'std::bad_cast;
// F23E0: using guessed type void *off_F23E0;

//----- (000BFA98) --------------------------------------------------------
void __fastcall __noreturn sub_BFA98(int a1)
{
  char *v1; // r6
  _DWORD *v2; // r4
  int v3; // [sp+Ch] [bp-14h]

  v1 = (char *)a1;
  v2 = (_DWORD *)_cxa_allocate_exception(8);
  sub_C1C58((void **)&v3, v1);
  sub_94F40(v2, &v3);
  sub_C0AC4((unsigned int *)(v3 - 12));
  _cxa_throw((int)v2, (int)&`typeinfo for'std::logic_error, (int)sub_94CE0);
}
// F073C: using guessed type int *`typeinfo for'std::logic_error;

//----- (000BFBAC) --------------------------------------------------------
void __fastcall __noreturn sub_BFBAC(int a1)
{
  char *v1; // r6
  _DWORD *v2; // r4
  int v3; // [sp+Ch] [bp-14h]

  v1 = (char *)a1;
  v2 = (_DWORD *)_cxa_allocate_exception(8);
  sub_C1C58((void **)&v3, v1);
  sub_94F94(v2, &v3);
  sub_C0AC4((unsigned int *)(v3 - 12));
  _cxa_throw((int)v2, (int)&`typeinfo for'std::length_error, (int)sub_94DBC);
}
// F0790: using guessed type int *`typeinfo for'std::length_error;

//----- (000BFC08) --------------------------------------------------------
void __fastcall __noreturn sub_BFC08(char *a1)
{
  char *v1; // r6
  _DWORD *v2; // r4
  int v3; // [sp+Ch] [bp-14h]

  v1 = a1;
  v2 = (_DWORD *)_cxa_allocate_exception(8);
  sub_C1C58((void **)&v3, v1);
  sub_94FAC(v2, &v3);
  sub_C0AC4((unsigned int *)(v3 - 12));
  _cxa_throw((int)v2, (int)&`typeinfo for'std::out_of_range, (int)sub_94DF4);
}
// F076C: using guessed type int *`typeinfo for'std::out_of_range;

//----- (000BFC64) --------------------------------------------------------
void __fastcall __noreturn sub_BFC64(char *a1)
{
  char *v1; // r6
  _DWORD *v2; // r4
  int v3; // [sp+Ch] [bp-14h]

  v1 = a1;
  v2 = (_DWORD *)_cxa_allocate_exception(8);
  sub_C1C58((void **)&v3, v1);
  sub_94FC4(v2, &v3);
  sub_C0AC4((unsigned int *)(v3 - 12));
  _cxa_throw((int)v2, (int)&`typeinfo for'std::runtime_error, (int)sub_94E2C);
}
// F0800: using guessed type int *`typeinfo for'std::runtime_error;

//----- (000BFDD4) --------------------------------------------------------
void __fastcall __noreturn sub_BFDD4(char *a1)
{
  char *v1; // r6
  _DWORD *v2; // r4
  int v3; // [sp+Ch] [bp-14h]

  v1 = a1;
  v2 = (_DWORD *)_cxa_allocate_exception(8);
  sub_C1C58((void **)&v3, v1);
  sub_C3524(v2, &v3);
  sub_C0AC4((unsigned int *)(v3 - 12));
  _cxa_throw((int)v2, (int)&`typeinfo for'std::ios_base::failure, (int)sub_C34B8);
}
// F2448: using guessed type int *`typeinfo for'std::ios_base::failure;

//----- (000BFE24) --------------------------------------------------------
void __fastcall __noreturn sub_BFE24(int a1)
{
  int v1; // r6
  _DWORD *v2; // r4
  int *v3; // r5
  int v4; // [sp+4h] [bp-1Ch]

  v1 = a1;
  v2 = (_DWORD *)_cxa_allocate_exception(16);
  v3 = sub_C37D0();
  (*(void (__fastcall **)(int *, int *, int))(*v3 + 12))(&v4, v3, v1);
  sub_94FC4(v2, &v4);
  sub_C0AC4((unsigned int *)(v4 - 12));
  v2[2] = v1;
  v2[3] = v3;
  *v2 = &off_F2490;
  _cxa_throw((int)v2, (int)&`typeinfo for'std::system_error, (int)sub_C3744);
}
// F2490: using guessed type void *off_F2490;
// F24C8: using guessed type int *`typeinfo for'std::system_error;

//----- (000BFF80) --------------------------------------------------------
const char *sub_BFF80()
{
  return "bad_function_call";
}

//----- (000BFF8C) --------------------------------------------------------
_DWORD *__fastcall sub_BFF8C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F2298;
  std::exception::~exception((int)a1);
  return v1;
}
// F2298: using guessed type void *;

//----- (000BFFA4) --------------------------------------------------------
void *__fastcall sub_BFFA4(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F2298;
  std::exception::~exception((int)a1);
  operator delete(v1);
  return v1;
}
// F2298: using guessed type void *off_F2298;

//----- (000BFFC8) --------------------------------------------------------
const char *sub_BFFC8()
{
  return "future";
}

//----- (000BFFD4) --------------------------------------------------------
_DWORD *__fastcall sub_BFFD4(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F2308;
  sub_C367C(a1);
  return v1;
}
// F2308: using guessed type void *;

//----- (000BFFEC) --------------------------------------------------------
void *__fastcall sub_BFFEC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F2308;
  sub_C367C(a1);
  operator delete(v1);
  return v1;
}
// F2308: using guessed type void *off_F2308;

//----- (000C000C) --------------------------------------------------------
std::exception *__fastcall sub_C000C(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F22B8;
  sub_94CE0(a1);
  return v1;
}
// F22B8: using guessed type void *;

//----- (000C0024) --------------------------------------------------------
std::exception *__fastcall sub_C0024(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F22B8;
  sub_94CE0(a1);
  operator delete((void *)v1);
  return v1;
}
// F22B8: using guessed type void *off_F22B8;

//----- (000C0044) --------------------------------------------------------
_DWORD *__fastcall sub_C0044(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F22D0;
  std::__exception_ptr::exception_ptr::~exception_ptr((std::__exception_ptr::exception_ptr *)(a1 + 1));
  return v1;
}
// F22D0: using guessed type void *;

//----- (000C0060) --------------------------------------------------------
void *__fastcall sub_C0060(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F22D0;
  std::__exception_ptr::exception_ptr::~exception_ptr((std::__exception_ptr::exception_ptr *)(a1 + 1));
  operator delete(v1);
  return v1;
}
// F22D0: using guessed type void *off_F22D0;

//----- (000C0080) --------------------------------------------------------
int __fastcall sub_C0080(int a1)
{
  int v1; // r4
  void (***v2)(void); // r0
  int result; // r0

  v1 = a1;
  *(_DWORD *)a1 = &off_F22F0;
  sub_C3560((pthread_cond_t *)(a1 + 12));
  v2 = *(void (****)(void))(v1 + 4);
  if ( v2 )
    (**v2)();
  result = v1;
  *(_DWORD *)(v1 + 4) = 0;
  return result;
}
// F22F0: using guessed type void *;

//----- (000C00A8) --------------------------------------------------------
void *__fastcall sub_C00A8(int a1)
{
  void *v1; // r4

  v1 = (void *)a1;
  sub_C0080(a1);
  operator delete(v1);
  return v1;
}

//----- (000C00BC) --------------------------------------------------------
int __fastcall sub_C00BC(int a1)
{
  int v1; // r2
  int v2; // r4
  void *v3; // r0
  unsigned int *v5; // r3
  signed int v6; // r2
  int v7; // [sp+4h] [bp-14h]

  v1 = *(_DWORD *)(a1 + 8);
  (*(void (__fastcall **)(int *))(**(_DWORD **)(a1 + 12) + 12))(&v7);
  v2 = v7;
  v3 = (void *)(v7 - 12);
  if ( (int *)(v7 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v7 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  return v2;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C010C) --------------------------------------------------------
int *__fastcall sub_C010C(int *a1, int a2, int a3)
{
  int *v3; // r4
  int *result; // r0

  v3 = a1;
  *a1 = (int)&unk_2FEF48;
  switch ( a3 )
  {
    case 1:
      sub_C0F20(a1, "Future already retrieved", 0x18u);
      result = v3;
      break;
    case 2:
      sub_C0F20(a1, "Promise already satisfied", 0x19u);
      result = v3;
      break;
    case 3:
      sub_C0F20(a1, "No associated state", 0x13u);
      result = v3;
      break;
    case 4:
      sub_C0F20(a1, "Broken promise", 0xEu);
      result = v3;
      break;
    default:
      sub_C0F20(a1, "Unknown error", 0xDu);
      result = v3;
      break;
  }
  return result;
}

//----- (000C01A0) --------------------------------------------------------
int *sub_C01A0()
{
  if ( !(dword_2FEF38 & 1) && _cxa_guard_acquire((unsigned int *)&dword_2FEF38) )
  {
    dword_2FEF34 = 0;
    sub_C37B4(&dword_2FEF34);
    dword_2FEF34 = (int)&off_F2308;
    _cxa_guard_release((unsigned int *)&dword_2FEF38);
    sub_936DC();
  }
  return &dword_2FEF34;
}
// F2308: using guessed type void *off_F2308;
// 2FEF34: using guessed type int dword_2FEF34;
// 2FEF38: using guessed type int dword_2FEF38;

//----- (000C0348) --------------------------------------------------------
_BYTE *__fastcall sub_C0348(_BYTE *result, _BYTE *a2, int a3)
{
  size_t v3; // r2

  v3 = a3 - (_DWORD)a2;
  if ( v3 != 1 )
    return j_memcpy(result, a2, v3);
  *result = *a2;
  return result;
}

//----- (000C0440) --------------------------------------------------------
signed int __fastcall sub_C0440(int *a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  int v4; // r6
  unsigned int v5; // r5
  size_t v6; // r4
  signed int result; // r0

  v4 = *a1;
  v5 = *(_DWORD *)(*a1 - 12);
  if ( a4 > v5 )
    sub_BFC08("basic_string::copy");
  v6 = v5 - a4;
  if ( v5 - a4 >= a3 )
    v6 = a3;
  if ( !v6 )
    return v6;
  if ( v6 != 1 )
  {
    memcpy(a2, (const void *)(v4 + a4), v6);
    return v6;
  }
  result = 1;
  *a2 = *(_BYTE *)(v4 + a4);
  return result;
}

//----- (000C0480) --------------------------------------------------------
int *__fastcall sub_C0480(int *result, int *a2)
{
  int v2; // r2
  int v3; // r3

  v2 = *result;
  if ( *(_DWORD *)(*result - 4) < 0 )
    *(_DWORD *)(v2 - 4) = 0;
  v3 = *a2;
  if ( *(_DWORD *)(*a2 - 4) < 0 )
    *(_DWORD *)(v3 - 4) = 0;
  *result = v3;
  *a2 = v2;
  return result;
}

//----- (000C04CC) --------------------------------------------------------
signed int __fastcall sub_C04CC(int *a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  int v4; // r7
  unsigned int v5; // r0
  signed int result; // r0
  unsigned int v7; // r10
  const void *v8; // r8
  int v9; // r11
  unsigned __int8 *v10; // r4
  int v11; // r5
  int v12; // r9
  int v13; // t1
  unsigned int v14; // r6
  int n; // [sp+4h] [bp-2Ch]

  v4 = *a1;
  v5 = *(_DWORD *)(*a1 - 12);
  if ( a4 )
  {
    if ( a4 > v5 || (v7 = v5 - a4, a3 > v5 - a4) )
    {
LABEL_7:
      result = -1;
    }
    else
    {
      v8 = a2 + 1;
      v9 = *a2;
      v10 = (unsigned __int8 *)(v4 + a3);
      n = a4 - 1;
      v11 = a3 + 1;
      while ( 1 )
      {
        v12 = (int)&v10[-v4];
        v13 = *v10++;
        v14 = v11;
        if ( v13 == v9 && !memcmp(v10, v8, n) )
          break;
        ++v11;
        if ( v7 < v14 )
          goto LABEL_7;
      }
      result = v12;
    }
  }
  else if ( a3 > v5 )
  {
    result = -1;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (000C0588) --------------------------------------------------------
signed int __fastcall sub_C0588(int *a1, const void *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r6
  int v5; // r7
  const void *v6; // r8
  size_t v7; // r3
  int v9; // r4

  v4 = a4;
  v5 = *a1;
  v6 = a2;
  v7 = *(_DWORD *)(*a1 - 12);
  if ( v4 > v7 )
    return -1;
  v9 = v7 - v4;
  if ( v7 - v4 >= a3 )
    v9 = a3;
  while ( memcmp((const void *)(v5 + v9), v6, v4) )
  {
    if ( !v9 )
      return -1;
    --v9;
  }
  return v9;
}

//----- (000C0628) --------------------------------------------------------
signed int __fastcall sub_C0628(int *a1, const void *a2, unsigned int a3, size_t a4)
{
  const void *v4; // r8
  unsigned int v5; // r4
  size_t v6; // r6
  int v7; // r7
  unsigned int v8; // r5

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( !a4 )
    return -1;
  v7 = *a1;
  v8 = *(_DWORD *)(*a1 - 12);
  if ( v8 <= a3 )
    return -1;
  while ( !memchr(v4, *(unsigned __int8 *)(v7 + v5), v6) )
  {
    if ( v8 <= ++v5 )
      return -1;
  }
  return v5;
}

//----- (000C0690) --------------------------------------------------------
signed int __fastcall sub_C0690(int *a1, const void *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r7
  int v5; // r6
  const void *v6; // r8
  int v7; // r3
  bool v8; // zf
  int v10; // r4

  v4 = a4;
  v5 = *a1;
  v6 = a2;
  v7 = *(_DWORD *)(*a1 - 12);
  v8 = v4 == 0;
  if ( v4 )
    v8 = v7 == 0;
  if ( v8 )
    return -1;
  v10 = v7 - 1;
  if ( a3 < v7 - 1 )
    v10 = a3;
  while ( !memchr(v6, *(unsigned __int8 *)(v5 + v10), v4) )
  {
    if ( !v10 )
      return -1;
    --v10;
  }
  return v10;
}

//----- (000C0704) --------------------------------------------------------
signed int __fastcall sub_C0704(int *a1, const void *a2, unsigned int a3, size_t a4)
{
  const void *v4; // r8
  int v5; // r5
  unsigned int v6; // r4
  size_t v7; // r7
  unsigned int v8; // r6

  v4 = a2;
  v5 = *a1;
  v6 = a3;
  v7 = a4;
  v8 = *(_DWORD *)(*a1 - 12);
  if ( a3 >= v8 )
    return -1;
  while ( memchr(v4, *(unsigned __int8 *)(v5 + v6), v7) )
  {
    if ( ++v6 >= v8 )
      return -1;
  }
  return v6;
}

//----- (000C0768) --------------------------------------------------------
signed int __fastcall sub_C0768(int *a1, int a2, unsigned int a3)
{
  int v3; // r3
  unsigned int v4; // r0
  int v5; // r4
  int v6; // r3
  int v7; // t1

  v3 = *a1;
  v4 = *(_DWORD *)(*a1 - 12);
  if ( a3 >= v4 )
    return -1;
  v5 = *(unsigned __int8 *)(v3 + a3);
  v6 = v3 + a3;
  if ( v5 == a2 )
  {
    while ( ++a3 < v4 )
    {
      v7 = *(unsigned __int8 *)(v6++ + 1);
      if ( v7 != v5 )
        return a3;
    }
    return -1;
  }
  return a3;
}

//----- (000C07A0) --------------------------------------------------------
signed int __fastcall sub_C07A0(int *a1, const void *a2, unsigned int a3, size_t a4)
{
  size_t v4; // r8
  int v5; // r6
  const void *v6; // r7
  int v7; // r3
  int v9; // r4

  v4 = a4;
  v5 = *a1;
  v6 = a2;
  v7 = *(_DWORD *)(*a1 - 12);
  if ( !v7 )
    return -1;
  v9 = v7 - 1;
  if ( a3 < v7 - 1 )
    v9 = a3;
  while ( memchr(v6, *(unsigned __int8 *)(v5 + v9), v4) )
  {
    if ( !v9 )
      return -1;
    --v9;
  }
  return v9;
}

//----- (000C0840) --------------------------------------------------------
int __fastcall sub_C0840(const void **a1, const void **a2)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r1
  unsigned int v4; // r5
  unsigned int v5; // r4
  size_t v6; // r2
  int result; // r0

  v2 = *a1;
  v3 = *a2;
  v4 = *(v2 - 3);
  v5 = *(v3 - 3);
  if ( v5 >= v4 )
    v6 = *(v2 - 3);
  else
    v6 = *(v3 - 3);
  result = memcmp(v2, v3, v6);
  if ( !result )
    result = v4 - v5;
  return result;
}

//----- (000C08E8) --------------------------------------------------------
int __fastcall sub_C08E8(const void **a1, const char *a2)
{
  const char *v2; // r5
  const void *v3; // r4
  size_t v4; // r6
  const void *v5; // r0
  size_t v6; // r4
  size_t v7; // r2
  int result; // r0

  v2 = a2;
  v3 = *a1;
  v4 = strlen(a2);
  v5 = v3;
  v6 = *((_DWORD *)v3 - 3);
  if ( v4 >= v6 )
    v7 = v6;
  else
    v7 = v4;
  result = memcmp(v5, v2, v7);
  if ( !result )
    result = v6 - v4;
  return result;
}

//----- (000C09C4) --------------------------------------------------------
int *__fastcall sub_C09C4(int *result, int a2)
{
  if ( result != &dword_2FEF3C )
  {
    *result = a2;
    result[2] = 0;
    *((_BYTE *)result + a2 + 12) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C09E4) --------------------------------------------------------
_DWORD *__fastcall sub_C09E4(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // r4
  _BOOL4 v3; // r0
  _DWORD *result; // r0

  v2 = a1;
  if ( a1 > 0x3FFFFFFC )
    sub_BFBAC((int)"basic_string::_S_create");
  if ( a1 > a2 )
  {
    if ( a1 < 2 * a2 )
      v2 = 2 * a2;
    v3 = v2 + 29 > 0x1000;
    if ( a2 >= v2 )
      v3 = 0;
    if ( v3 )
    {
      v2 = v2 + 4096 - (((_WORD)v2 + 29) & 0xFFF);
      if ( v2 >= 0x3FFFFFFC )
        v2 = 1073741820;
    }
  }
  result = operator new(v2 + 13);
  result[1] = v2;
  result[2] = 0;
  return result;
}

//----- (000C0A44) --------------------------------------------------------
void *__fastcall sub_C0A44(unsigned int a1, int a2)
{
  int v2; // r6
  size_t v3; // r4
  void *result; // r0
  int *v5; // r0
  int *v6; // r5
  void *v7; // r3

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return &unk_2FEF48;
  v5 = sub_C09E4(a1, 0);
  v6 = v5;
  v7 = v5 + 3;
  if ( v3 == 1 )
    *((_BYTE *)v5 + 12) = v2;
  else
    v7 = memset(v5 + 3, v2, v3);
  result = v7;
  if ( v6 != &dword_2FEF3C )
  {
    *v6 = v3;
    v6[2] = 0;
    *((_BYTE *)v7 + v3) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C0AA8) --------------------------------------------------------
void **__fastcall sub_C0AA8(void **a1, unsigned int a2, int a3)
{
  void **v3; // r4

  v3 = a1;
  *a1 = sub_C0A44(a2, a3);
  return v3;
}

//----- (000C0AC4) --------------------------------------------------------
void __fastcall sub_C0AC4(unsigned int *a1)
{
  if ( &dword_2FEF3C != (int *)a1 )
    sub_25EFC(a1);
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C0AD8) --------------------------------------------------------
_DWORD *__fastcall sub_C0AD8(_DWORD *a1)
{
  _DWORD *v1; // r4
  unsigned int *v2; // r0

  v1 = a1;
  v2 = (unsigned int *)(*a1 - 12);
  if ( v2 != (unsigned int *)&dword_2FEF3C )
    sub_25EFC(v2);
  return v1;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C0AFC) --------------------------------------------------------
void __fastcall sub_C0AFC(int *a1, size_t a2, int a3, int a4)
{
  int *v4; // r7
  int v5; // r4
  size_t v6; // r5
  int v7; // r6
  int v8; // r9
  int v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // r8
  size_t v12; // r10
  _DWORD *v13; // r0
  _BYTE *v14; // r1
  unsigned int *v15; // r0
  int v16; // r9
  int v17; // r5
  bool v18; // zf
  int v19; // r9
  int v20; // r5

  v4 = a1;
  v5 = *a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v9 = *(_DWORD *)(*a1 - 12);
  v10 = *(_DWORD *)(v5 - 8);
  v11 = a4 - a3 + v9;
  v12 = v9 - v6 - a3;
  if ( v11 > v10 || *(_DWORD *)(v5 - 4) > 0 )
  {
    v13 = sub_C09E4(v11, v10);
    v5 = (int)(v13 + 3);
    if ( v6 )
    {
      v14 = (_BYTE *)*v4;
      if ( v6 != 1 )
      {
        memcpy(v13 + 3, v14, v6);
        if ( !v12 )
          goto LABEL_7;
        goto LABEL_13;
      }
      *((_BYTE *)v13 + 12) = *v14;
    }
    if ( !v12 )
    {
LABEL_7:
      v15 = (unsigned int *)(*v4 - 12);
      if ( v15 != (unsigned int *)&dword_2FEF3C )
        sub_25EFC(v15);
      *v4 = v5;
      goto LABEL_10;
    }
LABEL_13:
    v16 = v8 + v6;
    v17 = v6 + v7;
    if ( v12 == 1 )
      *(_BYTE *)(v5 + v16) = *(_BYTE *)(*v4 + v17);
    else
      memcpy((void *)(v5 + v16), (const void *)(*v4 + v17), v12);
    goto LABEL_7;
  }
  v18 = a3 == a4;
  if ( a3 != a4 )
    v18 = v9 - v6 == a3;
  if ( !v18 )
  {
    v19 = a4 + v6;
    v20 = v6 + a3;
    if ( v12 == 1 )
      *(_BYTE *)(v5 + v19) = *(_BYTE *)(v5 + v20);
    else
      memmove((void *)(v5 + v19), (const void *)(v5 + v20), v12);
    v5 = *v4;
  }
LABEL_10:
  if ( (int *)(v5 - 12) != &dword_2FEF3C )
  {
    *(_DWORD *)(v5 - 12) = v11;
    *(_DWORD *)(v5 - 4) = 0;
    *(_BYTE *)(v5 + v11) = 0;
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C0BF4) --------------------------------------------------------
void __fastcall sub_C0BF4(int *a1)
{
  int v1; // r3
  int *v2; // r4

  v1 = *a1;
  v2 = a1;
  if ( (int *)(*a1 - 12) != &dword_2FEF3C )
  {
    if ( *(_DWORD *)(v1 - 4) > 0 )
    {
      sub_C0AFC(a1, 0, 0, 0);
      v1 = *v2;
    }
    *(_DWORD *)(v1 - 4) = -1;
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C0C28) --------------------------------------------------------
void __fastcall sub_C0C28(int *a1)
{
  if ( *(_DWORD *)(*a1 - 4) >= 0 )
    sub_C0BF4(a1);
}

//----- (000C0D44) --------------------------------------------------------
int *__fastcall sub_C0D44(int *a1, size_t a2, unsigned int a3)
{
  int *v3; // r4
  size_t v4; // r5
  unsigned int v5; // r5

  v3 = a1;
  v4 = *(_DWORD *)(*a1 - 12);
  if ( a2 > v4 )
    sub_BFC08("basic_string::erase");
  v5 = v4 - a2;
  if ( v5 < a3 )
    a3 = v5;
  sub_C0AFC(a1, a2, a3, 0);
  return v3;
}

//----- (000C0DB8) --------------------------------------------------------
int *__fastcall sub_C0DB8(int *a1, size_t a2, int a3, unsigned int a4, unsigned __int8 a5)
{
  int *v5; // r6
  size_t v6; // r8
  size_t v7; // r5

  v5 = a1;
  v6 = a2;
  v7 = a4;
  if ( a4 > 1073741820 - *(_DWORD *)(*a1 - 12) + a3 )
    sub_BFBAC((int)"basic_string::_M_replace_aux");
  sub_C0AFC(a1, a2, a3, a4);
  if ( v7 )
  {
    if ( v7 == 1 )
      *(_BYTE *)(*v5 + v6) = a5;
    else
      memset((void *)(*v5 + v6), a5, v7);
  }
  return v5;
}

//----- (000C0EF0) --------------------------------------------------------
int *__fastcall sub_C0EF0(int *a1, size_t a2, int a3, _BYTE *a4, size_t a5)
{
  _BYTE *v5; // r7
  int *v6; // r5
  size_t v7; // r6
  int *result; // r0

  v5 = a4;
  v6 = a1;
  v7 = a2;
  sub_C0AFC(a1, a2, a3, a5);
  if ( !a5 )
    return v6;
  if ( a5 != 1 )
  {
    memcpy((void *)(*v6 + v7), v5, a5);
    return v6;
  }
  result = v6;
  *(_BYTE *)(*v6 + v7) = *v5;
  return result;
}

//----- (000C0F20) --------------------------------------------------------
int *__fastcall sub_C0F20(int *a1, _BYTE *a2, size_t a3)
{
  int *v3; // r5
  _BYTE *v4; // r4
  size_t v5; // r6
  int v6; // r7
  int *result; // r0
  int *v8; // r3

  v3 = a1;
  v4 = (_BYTE *)*a1;
  v5 = a3;
  v6 = *(_DWORD *)(*a1 - 12);
  if ( a3 > 0x3FFFFFFC )
    sub_BFBAC((int)"basic_string::assign");
  if ( a2 < v4 || a2 > &v4[v6] || *((_DWORD *)v4 - 1) > 0 )
    return sub_C0EF0(a1, 0, v6, a2, a3);
  if ( a3 > a2 - v4 )
  {
    if ( a2 == v4 )
      goto LABEL_9;
    if ( a3 != 1 )
    {
      memmove(v4, a2, a3);
      v4 = (_BYTE *)*v3;
      goto LABEL_9;
    }
LABEL_18:
    *v4 = *a2;
    v4 = (_BYTE *)*a1;
    goto LABEL_9;
  }
  if ( a3 == 1 )
    goto LABEL_18;
  memcpy(v4, a2, a3);
  v4 = (_BYTE *)*v3;
LABEL_9:
  v8 = &dword_2FEF3C;
  if ( v4 - 12 == (_BYTE *)&dword_2FEF3C )
  {
    result = v3;
  }
  else
  {
    *((_DWORD *)v4 - 3) = v5;
    LOBYTE(v8) = 0;
    result = v3;
    *((_DWORD *)v4 - 1) = 0;
  }
  if ( v4 - 12 != (_BYTE *)&dword_2FEF3C )
    v4[v5] = (_BYTE)v8;
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1034) --------------------------------------------------------
int *__fastcall sub_C1034(int *a1, const char *a2)
{
  int *v2; // r5
  char *v3; // r4
  size_t v4; // r0

  v2 = a1;
  v3 = (char *)a2;
  v4 = strlen(a2);
  return sub_C0F20(v2, v3, v4);
}

//----- (000C1050) --------------------------------------------------------
int *__fastcall sub_C1050(int *a1, size_t a2, _BYTE *a3, unsigned int a4)
{
  _BYTE *v4; // lr
  unsigned int v5; // r6
  int *v6; // r7
  size_t v7; // r8
  size_t v8; // r5
  size_t v9; // r2
  int *result; // r0
  int v11; // r6
  int v12; // r4
  _BYTE *v13; // r1
  _BYTE *v14; // r3
  int v15; // r9

  v4 = a3;
  v5 = *a1;
  v6 = a1;
  v7 = a2;
  v8 = a4;
  v9 = *(_DWORD *)(*a1 - 12);
  if ( a2 > v9 )
    sub_BFC08("basic_string::insert");
  if ( a4 > 1073741820 - v9 )
    sub_BFBAC((int)"basic_string::insert");
  if ( (unsigned int)v4 < v5 || (unsigned int)v4 > v9 + v5 || *(_DWORD *)(v5 - 4) > 0 )
    return sub_C0EF0(a1, a2, 0, v4, a4);
  v11 = (int)&v4[-v5];
  sub_C0AFC(a1, a2, 0, a4);
  v12 = *v6;
  v13 = (_BYTE *)(*v6 + v11);
  v14 = (_BYTE *)(*v6 + v7);
  if ( v14 < &v13[v8] )
  {
    if ( v13 < v14 )
    {
      v15 = v14 - v13;
      if ( v14 - v13 == 1 )
        *(_BYTE *)(v12 + v7) = *(_BYTE *)(v12 + v11);
      else
        v14 = memcpy((void *)(*v6 + v7), v13, v14 - v13);
      if ( v8 - v15 == 1 )
      {
        result = v6;
        v14[v15] = v14[v8];
      }
      else
      {
        memcpy(&v14[v15], &v14[v8], v8 - v15);
        result = v6;
      }
    }
    else if ( v8 == 1 )
    {
      result = v6;
      *(_BYTE *)(v12 + v7) = v13[1];
    }
    else
    {
      memcpy((void *)(*v6 + v7), &v13[v8], v8);
      result = v6;
    }
  }
  else if ( v8 == 1 )
  {
    result = v6;
    *(_BYTE *)(v12 + v7) = *(_BYTE *)(v12 + v11);
  }
  else
  {
    memcpy((void *)(*v6 + v7), v13, v8);
    result = v6;
  }
  return result;
}

//----- (000C1218) --------------------------------------------------------
_BYTE *__fastcall sub_C1218(size_t *a1, int a2, int a3)
{
  size_t *v3; // r4
  int *v4; // r0
  size_t v5; // r2
  int *v6; // r5
  _BYTE *result; // r0

  v3 = a1;
  v4 = sub_C09E4(*a1 + a3, a1[1]);
  v5 = *v3;
  v6 = v4;
  result = v4 + 3;
  if ( *v3 )
  {
    if ( v5 == 1 )
    {
      result = v6 + 3;
      *((_BYTE *)v6 + 12) = *((_BYTE *)v3 + 12);
    }
    else
    {
      result = memcpy(v6 + 3, v3 + 3, v5);
    }
    v5 = *v3;
  }
  if ( v6 != &dword_2FEF3C )
  {
    *v6 = v5;
    v6[2] = 0;
    result[v5] = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1264) --------------------------------------------------------
void __fastcall sub_C1264(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // r4
  int v3; // r3
  unsigned int v4; // r2
  size_t *v5; // r3
  unsigned int v6; // t1
  int v7; // r2
  _BYTE *v8; // r6
  unsigned int *v9; // r0
  char v10; // [sp+4h] [bp-14h]

  v2 = a1;
  v3 = *a1;
  if ( a2 != *(_DWORD *)(*a1 - 8) || *(_DWORD *)(v3 - 4) > 0 )
  {
    v6 = *(_DWORD *)(v3 - 12);
    v5 = (size_t *)(v3 - 12);
    v4 = v6;
    if ( a2 < v6 )
      v7 = 0;
    else
      v7 = a2 - v4;
    v8 = sub_C1218(v5, (int)&v10, v7);
    v9 = (unsigned int *)(*v2 - 12);
    if ( v9 != (unsigned int *)&dword_2FEF3C )
      sub_25EFC(v9);
    *v2 = v8;
  }
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C12E4) --------------------------------------------------------
int *__fastcall sub_C12E4(int *a1, _BYTE **a2)
{
  _BYTE **v2; // r7
  _BYTE *v3; // r1
  int *v4; // r4
  size_t v5; // r5
  int v6; // r3
  int v7; // r6
  int v8; // r8
  int v9; // r3

  v2 = a2;
  v3 = *a2;
  v4 = a1;
  v5 = *((_DWORD *)v3 - 3);
  if ( v5 )
  {
    v6 = *a1;
    v7 = *(_DWORD *)(*a1 - 12);
    v8 = v7 + v5;
    if ( v7 + v5 > *(_DWORD *)(*a1 - 8) || *(_DWORD *)(v6 - 4) > 0 )
    {
      sub_C1264(a1, v7 + v5);
      v6 = *v4;
      v3 = *v2;
      v7 = *(_DWORD *)(*v4 - 12);
    }
    if ( v5 == 1 )
      *(_BYTE *)(v6 + v7) = *v3;
    else
      memcpy((void *)(v6 + v7), v3, v5);
    v9 = *v4;
    if ( (int *)(*v4 - 12) != &dword_2FEF3C )
    {
      *(_DWORD *)(v9 - 12) = v8;
      *(_DWORD *)(v9 - 4) = 0;
      *(_BYTE *)(v9 + v8) = 0;
    }
  }
  return v4;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C13F8) --------------------------------------------------------
unsigned int *__fastcall sub_C13F8(unsigned int *a1, unsigned int a2, size_t a3)
{
  unsigned int *v3; // r4
  _BYTE *v4; // r6
  size_t v5; // r5
  unsigned int v6; // r3
  int v7; // r2
  unsigned int v8; // r7
  unsigned int v9; // r3
  int v11; // r6

  v3 = a1;
  v4 = (_BYTE *)a2;
  v5 = a3;
  if ( !a3 )
    return v3;
  v6 = *a1;
  v7 = *(_DWORD *)(*a1 - 12);
  if ( v5 > 1073741820 - v7 )
    sub_BFBAC((int)"basic_string::append");
  v8 = v5 + v7;
  if ( v5 + v7 > *(_DWORD *)(v6 - 8) )
  {
    if ( a2 < v6 )
      goto LABEL_5;
LABEL_15:
    if ( a2 <= v7 + v6 )
    {
      v11 = a2 - v6;
      sub_C1264(a1, v8);
      v6 = *v3;
      v4 = (_BYTE *)(v11 + *v3);
      v7 = *(_DWORD *)(*v3 - 12);
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if ( *(_DWORD *)(v6 - 4) <= 0 )
    goto LABEL_6;
  if ( a2 >= v6 )
    goto LABEL_15;
LABEL_5:
  sub_C1264(a1, v8);
  v6 = *v3;
  v7 = *(_DWORD *)(*v3 - 12);
LABEL_6:
  if ( v5 == 1 )
    *(_BYTE *)(v6 + v7) = *v4;
  else
    memcpy((void *)(v6 + v7), v4, v5);
  v9 = *v3;
  if ( (int *)(*v3 - 12) != &dword_2FEF3C )
  {
    *(_DWORD *)(v9 - 12) = v8;
    *(_DWORD *)(v9 - 4) = 0;
    *(_BYTE *)(v9 + v8) = 0;
  }
  return v3;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C14B4) --------------------------------------------------------
unsigned int *__fastcall sub_C14B4(unsigned int *a1, const char *a2)
{
  unsigned int *v2; // r5
  unsigned int v3; // r4
  size_t v4; // r0

  v2 = a1;
  v3 = (unsigned int)a2;
  v4 = strlen(a2);
  return sub_C13F8(v2, v3, v4);
}

//----- (000C14E4) --------------------------------------------------------
unsigned int *__fastcall sub_C14E4(unsigned int *a1, const char *a2)
{
  unsigned int *v2; // r5
  unsigned int v3; // r4
  size_t v4; // r0

  v2 = a1;
  v3 = (unsigned int)a2;
  v4 = strlen(a2);
  return sub_C13F8(v2, v3, v4);
}

//----- (000C1500) --------------------------------------------------------
int *__fastcall sub_C1500(int *a1, unsigned int a2, int a3)
{
  int *v3; // r4
  int v4; // r8
  size_t v5; // r5
  int v6; // r3
  int v7; // r6
  int v8; // r7
  int v9; // r3

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( a2 )
  {
    v6 = *a1;
    v7 = *(_DWORD *)(*a1 - 12);
    if ( a2 > 1073741820 - v7 )
      sub_BFBAC((int)"basic_string::append");
    v8 = a2 + v7;
    if ( a2 + v7 > *(_DWORD *)(v6 - 8) || *(_DWORD *)(v6 - 4) > 0 )
    {
      sub_C1264(a1, a2 + v7);
      v6 = *v3;
      v7 = *(_DWORD *)(*v3 - 12);
    }
    if ( v5 == 1 )
      *(_BYTE *)(v6 + v7) = v4;
    else
      memset((void *)(v6 + v7), v4, v5);
    v9 = *v3;
    if ( (int *)(*v3 - 12) != &dword_2FEF3C )
    {
      *(_DWORD *)(v9 - 12) = v8;
      *(_DWORD *)(v9 - 4) = 0;
      *(_BYTE *)(v9 + v8) = 0;
    }
  }
  return v3;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1588) --------------------------------------------------------
void __fastcall sub_C1588(int *a1, size_t a2, int a3)
{
  unsigned int v3; // r5

  v3 = *(_DWORD *)(*a1 - 12);
  if ( a2 > 0x3FFFFFFC )
    sub_BFBAC((int)"basic_string::resize");
  if ( a2 > v3 )
  {
    sub_C1500(a1, a2 - v3, a3);
  }
  else if ( a2 < v3 )
  {
    sub_C0AFC(a1, a2, v3 - a2, 0);
  }
}

//----- (000C15C8) --------------------------------------------------------
void __fastcall sub_C15C8(int *a1, size_t a2)
{
  sub_C1588(a1, a2, 0);
}

//----- (000C15D0) --------------------------------------------------------
unsigned int __fastcall sub_C15D0(int *a1, char a2)
{
  int v2; // r3
  int *v3; // r4
  int v4; // r2
  char v5; // r6
  unsigned int result; // r0
  int v7; // r5
  int v8; // r3

  v2 = *a1;
  v3 = a1;
  v4 = *(_DWORD *)(*a1 - 12);
  v5 = a2;
  result = *(_DWORD *)(*a1 - 8);
  v7 = v4 + 1;
  if ( v4 + 1 > result || *(_DWORD *)(v2 - 4) > 0 )
  {
    sub_C1264(v3, v4 + 1);
    v2 = *v3;
    v4 = *(_DWORD *)(*v3 - 12);
  }
  *(_BYTE *)(v2 + v4) = v5;
  v8 = *v3;
  if ( (int *)(*v3 - 12) != &dword_2FEF3C )
  {
    *(_DWORD *)(v8 - 12) = v7;
    *(_DWORD *)(v8 - 4) = 0;
    *(_BYTE *)(v8 + v7) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C16AC) --------------------------------------------------------
_DWORD *__fastcall sub_C16AC(_DWORD *a1, int *a2)
{
  int v2; // r3
  _DWORD *v3; // r4
  size_t *v4; // r0
  _DWORD *result; // r0
  unsigned int *v6; // r2
  unsigned int v7; // r0
  char v8; // [sp+4h] [bp-Ch]

  v2 = *a2;
  v3 = a1;
  v4 = (size_t *)(*a2 - 12);
  if ( *(_DWORD *)(*a2 - 4) < 0 )
  {
    *v3 = sub_C1218(v4, (int)&v8, 0);
    result = v3;
  }
  else
  {
    if ( v4 != (size_t *)&dword_2FEF3C )
    {
      v6 = (unsigned int *)(v2 - 4);
      __dmb(0xFu);
      do
        v7 = __ldrex(v6);
      while ( __strex(v7 + 1, v6) );
      __dmb(0xFu);
    }
    *v3 = v2;
    result = v3;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1700) --------------------------------------------------------
_DWORD *__fastcall sub_C1700(_DWORD *a1, _DWORD *a2)
{
  _BYTE *v2; // r3
  unsigned int *v3; // r2
  _DWORD *v4; // r4
  size_t *v5; // r0
  _BYTE *v6; // r5
  _BYTE *v8; // r0
  unsigned int *v9; // r2
  unsigned int v10; // r0
  char v11; // [sp+4h] [bp-14h]

  v2 = (_BYTE *)*a2;
  v3 = (unsigned int *)(*a1 - 12);
  v4 = a1;
  v5 = (size_t *)(*a2 - 12);
  if ( v3 != v5 )
  {
    if ( *((_DWORD *)v2 - 1) < 0 )
    {
      v8 = sub_C1218(v5, (int)&v11, 0);
      v3 = (unsigned int *)(*v4 - 12);
      v6 = v8;
    }
    else
    {
      if ( v5 != (size_t *)&dword_2FEF3C )
      {
        v9 = (unsigned int *)(v2 - 4);
        __dmb(0xFu);
        do
          v10 = __ldrex(v9);
        while ( __strex(v10 + 1, v9) );
        __dmb(0xFu);
        v3 = (unsigned int *)(*v4 - 12);
      }
      v6 = v2;
    }
    if ( v3 != (unsigned int *)&dword_2FEF3C )
      sub_25EFC(v3);
    *v4 = v6;
  }
  return v4;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1804) --------------------------------------------------------
void *__fastcall sub_C1804(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // r4
  size_t v3; // r5
  int *v4; // r0
  int *v5; // r6
  void *v6; // r3
  void *result; // r0

  v2 = a1;
  if ( a1 == a2 )
    return &unk_2FEF48;
  v3 = a2 - a1;
  v4 = sub_C09E4(a2 - a1, 0);
  v5 = v4;
  v6 = v4 + 3;
  if ( v3 == 1 )
    *((_BYTE *)v4 + 12) = *v2;
  else
    v6 = memcpy(v4 + 3, v2, v3);
  result = v6;
  if ( v5 != &dword_2FEF3C )
  {
    *v5 = v3;
    v5[2] = 0;
    *((_BYTE *)v6 + v3) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1870) --------------------------------------------------------
void *__fastcall sub_C1870(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // r4
  size_t v3; // r6
  int *v4; // r0
  int *v5; // r5
  void *v6; // r3
  void *result; // r0
  int *v8; // r0

  v2 = a1;
  if ( a1 == a2 )
    return &unk_2FEF48;
  if ( a1 )
  {
    v3 = a2 - a1;
    v4 = sub_C09E4(a2 - a1, 0);
    v5 = v4;
    v6 = v4 + 3;
    if ( v3 == 1 )
    {
      *((_BYTE *)v4 + 12) = *v2;
      goto LABEL_5;
    }
  }
  else
  {
    if ( a2 )
      sub_BFA98((int)"basic_string::_S_construct null not valid");
    v8 = sub_C09E4(0, 0);
    v3 = (size_t)v2;
    v6 = v8 + 3;
    v5 = v8;
  }
  v6 = memcpy(v6, v2, v3);
LABEL_5:
  result = v6;
  if ( v5 != &dword_2FEF3C )
  {
    *v5 = v3;
    v5[2] = 0;
    *((_BYTE *)v6 + v3) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C18E4) --------------------------------------------------------
void **__fastcall sub_C18E4(void **a1, int *a2, unsigned int a3, unsigned int a4)
{
  void **v4; // r6
  int v5; // r4
  unsigned int v6; // r5
  unsigned int v7; // r5
  int v8; // r1

  v4 = a1;
  v5 = *a2;
  v6 = *(_DWORD *)(*a2 - 12);
  if ( a3 > v6 )
    sub_BFC08("basic_string::basic_string");
  v7 = v6 - a3;
  if ( v7 > a4 )
    v8 = a3 + a4;
  else
    v8 = a3 + v7;
  *a1 = sub_C1870((_BYTE *)(v5 + a3), (_BYTE *)(v8 + v5));
  return v4;
}

//----- (000C1994) --------------------------------------------------------
void *__fastcall sub_C1994(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // r4
  size_t v3; // r6
  int *v4; // r0
  int *v5; // r5
  void *v6; // r3
  void *result; // r0
  int *v8; // r0

  v2 = a1;
  if ( a1 == a2 )
    return &unk_2FEF48;
  if ( a1 )
  {
    v3 = a2 - a1;
    v4 = sub_C09E4(a2 - a1, 0);
    v5 = v4;
    v6 = v4 + 3;
    if ( v3 == 1 )
    {
      *((_BYTE *)v4 + 12) = *v2;
      goto LABEL_5;
    }
  }
  else
  {
    if ( a2 )
      sub_BFA98((int)"basic_string::_S_construct null not valid");
    v8 = sub_C09E4(0, 0);
    v3 = (size_t)v2;
    v6 = v8 + 3;
    v5 = v8;
  }
  v6 = memcpy(v6, v2, v3);
LABEL_5:
  result = v6;
  if ( v5 != &dword_2FEF3C )
  {
    *v5 = v3;
    v5[2] = 0;
    *((_BYTE *)v6 + v3) = 0;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1A08) --------------------------------------------------------
void **__fastcall sub_C1A08(void **a1, _BYTE *a2, int a3)
{
  void **v3; // r4

  v3 = a1;
  *a1 = sub_C1994(a2, &a2[a3]);
  return v3;
}

//----- (000C1A20) --------------------------------------------------------
int *__fastcall sub_C1A20(int *a1, size_t a2, unsigned int a3, _BYTE *a4, unsigned int a5)
{
  size_t v5; // r4
  unsigned int v6; // r1
  int *v7; // r6
  size_t v8; // r7
  int v9; // r8
  int *v10; // r6
  int *result; // r0
  int v12; // r7
  unsigned int *v13; // [sp+Ch] [bp-1Ch]

  v5 = a2;
  v6 = *a1;
  v7 = a1;
  v8 = *(_DWORD *)(*a1 - 12);
  if ( v5 > v8 )
    sub_BFC08("basic_string::replace");
  v9 = v8 - v5;
  if ( v8 - v5 >= a3 )
    v9 = a3;
  if ( a5 > 1073741820 - v8 + v9 )
    sub_BFBAC((int)"basic_string::replace");
  if ( (unsigned int)a4 < v6 || (unsigned int)a4 > v8 + v6 || *(_DWORD *)(v6 - 4) > 0 )
    return sub_C0EF0(a1, v5, v9, a4, a5);
  if ( (unsigned int)&a4[a5] <= v6 + v5 )
  {
    v12 = (int)&a4[-v6];
    goto LABEL_12;
  }
  if ( (unsigned int)a4 < v9 + v5 + v6 )
  {
    sub_C1A08((void **)&v13, a4, a5);
    v10 = sub_C0EF0(v7, v5, v9, v13, a5);
    if ( v13 - 3 != (unsigned int *)&dword_2FEF3C )
      sub_25EFC(v13 - 3);
    return v10;
  }
  v12 = (int)&a4[a5 - v6 - v9];
LABEL_12:
  sub_C0AFC(a1, v5, v9, a5);
  if ( a5 == 1 )
  {
    result = v7;
    *(_BYTE *)(*v7 + v5) = *(_BYTE *)(*v7 + v12);
  }
  else
  {
    memcpy((void *)(*v7 + v5), (const void *)(*v7 + v12), a5);
    result = v7;
  }
  return result;
}
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C1C58) --------------------------------------------------------
void **__fastcall sub_C1C58(void **a1, char *a2)
{
  char *v2; // r4
  void **v3; // r5
  char *v4; // r1

  v2 = a2;
  v3 = a1;
  v4 = (char *)-1;
  if ( v2 )
    v4 = &v2[strlen(v2)];
  *v3 = sub_C1994(v2, v4);
  return v3;
}

//----- (000C1CBC) --------------------------------------------------------
_DWORD *__fastcall sub_C1CBC(_DWORD *a1, int a2)
{
  int v2; // r4
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  unsigned __int8 *v5; // r3
  int v6; // r0
  signed int v7; // r3
  signed int i; // r7
  unsigned int v9; // r12
  int v10; // r2
  unsigned int v11; // r1
  unsigned int v13; // r3
  unsigned __int8 *v14; // r1
  char v15; // [sp+4h] [bp-24h]

  v2 = a2;
  v3 = a1;
  if ( a2 == 1 )
    return sub_A0F18(a1);
  a1[1] = 0;
  sub_A0718(&v15, a1, 1);
  if ( v2 <= 0 || !v15 )
    return v3;
  v4 = *(_DWORD **)((char *)v3 + *(_DWORD *)(*v3 - 12) + 120);
  v5 = (unsigned __int8 *)v4[2];
  if ( (unsigned int)v5 >= v4[3] )
    v6 = (*(int (__fastcall **)(_DWORD))(*v4 + 36))(*(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 120));
  else
    v6 = *v5;
  v7 = v3[1];
  for ( i = 0; ; i = 1 )
  {
    while ( 2 )
    {
      if ( v2 > v7 )
      {
        while ( 1 )
        {
          if ( v6 == -1 )
            goto LABEL_16;
          v9 = v4[3];
          v10 = v2 - v7;
          v11 = v4[2];
          if ( v2 - v7 >= (signed int)(v9 - v11) )
            v10 = v9 - v11;
          if ( v10 <= 1 )
            break;
          v7 += v10;
          v4[2] = v11 + v10;
          v3[1] = v7;
          if ( v9 <= v11 + v10 )
            goto LABEL_29;
          v6 = *(unsigned __int8 *)(v11 + v10);
          if ( v2 <= v7 )
            goto LABEL_15;
        }
        v3[1] = v7 + 1;
        if ( v9 <= v11 )
        {
          v6 = (*(int (__fastcall **)(_DWORD *))(*v4 + 40))(v4);
          if ( v6 == -1 )
            goto LABEL_27;
          v14 = (unsigned __int8 *)v4[2];
          v13 = v4[3];
        }
        else
        {
          v13 = v9;
          v14 = (unsigned __int8 *)(v11 + 1);
          v4[2] = v14;
        }
        if ( (unsigned int)v14 >= v13 )
LABEL_29:
          v6 = (*(int (__fastcall **)(_DWORD *))(*v4 + 36))(v4);
        else
          v6 = *v14;
LABEL_27:
        v7 = v3[1];
        continue;
      }
      break;
    }
LABEL_15:
    if ( v2 != 0x7FFFFFFF || v6 == -1 )
      break;
    v3[1] = 2147483648;
    v7 = 2147483648;
  }
LABEL_16:
  if ( i )
    v3[1] = 0x7FFFFFFF;
  if ( v6 == -1 )
    sub_93F84((_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12)), *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | 2);
  return v3;
}

//----- (000C1E14) --------------------------------------------------------
_DWORD *__fastcall sub_C1E14(_DWORD *a1, signed int a2)
{
  signed int v2; // r4
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int *v5; // r3
  int v6; // r0
  signed int v7; // r3
  signed int v8; // r7
  unsigned int v9; // r12
  int v10; // r2
  int *v11; // r1
  unsigned int v12; // r0
  int *v14; // r3
  char v15; // [sp+4h] [bp-24h]

  v2 = a2;
  v3 = a1;
  if ( a2 == 1 )
    return sub_A2C50(a1);
  a1[1] = 0;
  sub_A2468(&v15, a1, 1);
  if ( v2 > 0 && v15 )
  {
    v4 = *(_DWORD **)((char *)v3 + *(_DWORD *)(*v3 - 12) + 124);
    v5 = (int *)v4[2];
    if ( (unsigned int)v5 >= v4[3] )
      v6 = (*(int (__fastcall **)(_DWORD))(*v4 + 36))(*(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 124));
    else
      v6 = *v5;
    v7 = v3[1];
    v8 = 0;
LABEL_8:
    while ( v2 <= v7 )
    {
LABEL_15:
      if ( v2 != 0x7FFFFFFF || v6 == -1 )
        goto LABEL_16;
      v3[1] = 2147483648;
      v7 = 2147483648;
      v8 = 1;
    }
    while ( v6 != -1 )
    {
      v9 = v4[3];
      v10 = v2 - v7;
      v11 = (int *)v4[2];
      if ( v2 - v7 >= (signed int)(v9 - (_DWORD)v11) >> 2 )
        v10 = (signed int)(v9 - (_DWORD)v11) >> 2;
      if ( v10 <= 1 )
      {
        v3[1] = v7 + 1;
        if ( v9 <= (unsigned int)v11 )
        {
          v6 = (*(int (__fastcall **)(_DWORD *))(*v4 + 40))(v4);
        }
        else
        {
          v6 = *v11;
          v4[2] = v11 + 1;
        }
        if ( v6 != -1 )
        {
          v14 = (int *)v4[2];
          if ( (unsigned int)v14 >= v4[3] )
LABEL_30:
            v6 = (*(int (__fastcall **)(_DWORD *))(*v4 + 36))(v4);
          else
            v6 = *v14;
        }
        v7 = v3[1];
        goto LABEL_8;
      }
      v12 = (unsigned int)&v11[v10];
      v7 += v10;
      v4[2] = v12;
      v3[1] = v7;
      if ( v9 <= v12 )
        goto LABEL_30;
      v6 = v11[v10];
      if ( v2 <= v7 )
        goto LABEL_15;
    }
LABEL_16:
    if ( v8 )
      v3[1] = 0x7FFFFFFF;
    if ( v6 == -1 )
      sub_94410(
        (_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12)),
        *(_DWORD *)((char *)v3 + *(_DWORD *)(*v3 - 12) + 20) | 2);
  }
  return v3;
}

//----- (000C1F74) --------------------------------------------------------
_DWORD *__fastcall sub_C1F74(_DWORD *result)
{
  *result = &off_F2348;
  return result;
}
// F2348: using guessed type void *;

//----- (000C1F84) --------------------------------------------------------
int sub_C1F84()
{
  return 0;
}

//----- (000C1F88) --------------------------------------------------------
int sub_C1F88()
{
  return 0;
}

//----- (000C1F8C) --------------------------------------------------------
int sub_C1F8C()
{
  return 0;
}

//----- (000C1F90) --------------------------------------------------------
_DWORD *__fastcall sub_C1F90(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F2348;
  operator delete(a1);
  return v1;
}
// F2348: using guessed type void *off_F2348;

//----- (000C1FA8) --------------------------------------------------------
bool __fastcall sub_C1FA8(int a1, int a2)
{
  const char *v2; // r0
  const char *v3; // r1

  if ( a2 == a1 )
    return 1;
  v2 = *(const char **)(a1 + 4);
  if ( *v2 == 42 )
    return 0;
  v3 = *(const char **)(a2 + 4);
  if ( *v3 == 42 )
    ++v3;
  return strcmp(v2, v3) == 0;
}

//----- (000C1FDC) --------------------------------------------------------
__cxxabiv1::__vmi_class_type_info *__fastcall __cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info(__cxxabiv1::__vmi_class_type_info *this)
{
  __cxxabiv1::__vmi_class_type_info *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F2370;
  __cxxabiv1::__class_type_info::~__class_type_info(this);
  return v1;
}
// F2370: using guessed type void *off_F2370;

//----- (000C1FF8) --------------------------------------------------------
__cxxabiv1::__vmi_class_type_info *__fastcall __cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info(__cxxabiv1::__vmi_class_type_info *this)
{
  __cxxabiv1::__vmi_class_type_info *v1; // r4

  v1 = this;
  __cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info(this);
  operator delete((void *)v1);
  return v1;
}

//----- (000C200C) --------------------------------------------------------
int __fastcall __cxxabiv1::__vmi_class_type_info::__do_find_public_src(int a1, int a2, _DWORD *a3, int a4, _DWORD *a5)
{
  int v5; // r7
  _DWORD *v6; // r9
  int v7; // r4
  int v8; // r3
  int v9; // r5
  int i; // r4
  int v11; // r0
  int v12; // r11
  int v13; // r2
  int result; // r0
  bool v15; // zf

  v5 = a2;
  v6 = a3;
  v7 = a1;
  if ( a3 == a5 && sub_C1FA8(a1, a4) )
    return 6;
  v8 = *(_DWORD *)(v7 + 12);
  v9 = v8 - 1;
  for ( i = v7 + 8 * v8 + 4; ; i -= 8 )
  {
    v15 = v9-- == -1;
    if ( v15 )
      return 1;
    v11 = *(_DWORD *)(i + 8);
    if ( v11 & 2 )
    {
      v12 = *(_DWORD *)(i + 8) & 1;
      if ( v11 & 1 )
      {
        if ( v5 == -3 )
          continue;
        v13 = *(_DWORD *)(*v6 + (v11 >> 8));
      }
      result = (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(i + 4) + 32))(*(_DWORD *)(i + 4));
      if ( result > 3 )
        break;
    }
  }
  if ( v12 )
    result |= 1u;
  return result;
}

//----- (000C208C) --------------------------------------------------------
int __fastcall __cxxabiv1::__vmi_class_type_info::__do_dyncast(int a1, int a2, int a3, int a4, int *a5, int a6, int *a7, int *a8)
{
  int v8; // r11
  int *v9; // r7
  int v10; // r2
  int v11; // r3
  unsigned int v12; // r11
  int v13; // r6
  int v14; // r6
  int v15; // r3
  int v16; // r1
  int v17; // r7
  int v18; // r0
  int v19; // r0
  signed int v20; // r8
  bool v21; // zf
  int v22; // r3
  int v23; // r1
  int v24; // r12
  signed int v25; // r3
  signed int v26; // r10
  int v27; // r1
  signed int v28; // r3
  int v30; // r1
  int v31; // r2
  int v32; // r3
  int v33; // ST14_4
  int v34; // r0
  int v35; // [sp+10h] [bp-70h]
  int v36; // [sp+18h] [bp-68h]
  signed int v37; // [sp+1Ch] [bp-64h]
  int v38; // [sp+20h] [bp-60h]
  signed int v39; // [sp+24h] [bp-5Ch]
  _BOOL4 v40; // [sp+28h] [bp-58h]
  int v41; // [sp+2Ch] [bp-54h]
  int v42; // [sp+34h] [bp-4Ch]
  signed int v43; // [sp+3Ch] [bp-44h]
  int v44; // [sp+44h] [bp-3Ch]
  int v45; // [sp+48h] [bp-38h]
  int v46; // [sp+4Ch] [bp-34h]
  int v47; // [sp+50h] [bp-30h]
  int v48; // [sp+54h] [bp-2Ch]

  v8 = a2;
  v38 = a4;
  v9 = a7;
  v42 = a1;
  v41 = a3;
  if ( a8[4] << 27 < 0 )
    a8[4] = *(_DWORD *)(a1 + 8);
  if ( a5 == a7 && sub_C1FA8(a1, a6) )
  {
    a8[2] = v41;
    return 0;
  }
  v40 = sub_C1FA8(v42, v38);
  if ( !v40 )
  {
    v36 = v8;
    if ( v8 < 0 )
      v11 = 0;
    else
      v9 = a7;
    if ( v8 >= 0 )
      v11 = (int)v9 - v8;
    v37 = 0;
    v12 = v11;
    v39 = 1;
    v43 = 0;
LABEL_11:
    v13 = *(_DWORD *)(v42 + 12);
    v35 = v13 - 1;
    v14 = v42 + 8 * v13 + 4;
    while ( 1 )
    {
      if ( v35 == -1 )
      {
        if ( v43 & v39 )
        {
          v39 = 0;
          v43 = 1;
          goto LABEL_11;
        }
        return v37;
      }
      v15 = *(_DWORD *)(v14 + 8);
      v16 = a8[4];
      v17 = v15 << 31;
      v44 = 0;
      v18 = v15 >> 8;
      v45 = 0;
      if ( v15 << 31 < 0 )
        v17 = *a5;
      v48 = v16;
      v46 = 0;
      if ( v15 << 31 < 0 )
        v18 = *(_DWORD *)(v17 + v18);
      v47 = 0;
      if ( v15 << 31 < 0 )
        v10 = v41 | 1;
      if ( !(v15 & 1) )
        v10 = v41;
      if ( v12 && (unsigned int)a5 + v18 > v12 == v39 )
      {
        v43 = 1;
        goto LABEL_45;
      }
      if ( !(v15 & 2) )
      {
        if ( v36 == -2 && !(v16 << 30) )
          goto LABEL_45;
        v10 &= 0xFFFFFFFD;
      }
      v19 = (*(int (__cdecl **)(_DWORD, int, int, int))(**(_DWORD **)(v14 + 4) + 28))(
              *(_DWORD *)(v14 + 4),
              v36,
              v10,
              v38);
      v20 = v47;
      v21 = (v47 & 0xFFFFFFFB) == 2;
      v22 = v46 | a8[2];
      a8[2] = v22;
      if ( v21 )
      {
        v31 = v44;
        v32 = v45;
        v40 = v19;
        a8[3] = v20;
        *a8 = v31;
        a8[1] = v32;
        return v40;
      }
      v23 = *a8;
      if ( v37 )
      {
        if ( !v23 )
        {
          v10 = v44;
          if ( v44 )
            goto LABEL_31;
          goto LABEL_44;
        }
      }
      else if ( !v23 )
      {
        v10 = v44;
        v30 = v45;
        *a8 = v44;
        a8[1] = v30;
        if ( v10 )
        {
          if ( !v22 )
          {
            v37 = v19;
            goto LABEL_45;
          }
          v10 = *(_DWORD *)(v42 + 8) << 31;
          if ( !(*(_DWORD *)(v42 + 8) & 1) )
            return v19;
        }
        v37 = v19;
        goto LABEL_44;
      }
      v10 = v44;
      if ( v23 == v44 )
      {
        v10 = v45 | a8[1];
        a8[1] = v10;
      }
      else if ( v44 || v19 )
      {
LABEL_31:
        v24 = a8[3];
        if ( v22 <= 3 || v22 & 1 && a8[4] & 2 )
        {
          if ( v24 > 0 )
          {
            v25 = v20;
            v26 = a8[3];
            goto LABEL_36;
          }
          if ( v20 > 3 && (!(v20 & 1) || !(*(_DWORD *)(v42 + 8) & 2)) )
          {
            v25 = v20;
            if ( (v20 ^ 1) > 3 )
            {
LABEL_40:
              v27 = v45;
              LOBYTE(v26) = v25;
              v24 = v20;
              *a8 = v10;
              v37 = 0;
              a8[1] = v27;
              goto LABEL_41;
            }
            v26 = 1;
            goto LABEL_57;
          }
          if ( v36 < 0 )
          {
            if ( v36 != -2 )
            {
              v24 = (*(int (__fastcall **)(int, int, int, int, int *))(*(_DWORD *)v38 + 32))(v38, v36, *a8, a6, a7);
              v26 = v24;
              goto LABEL_88;
            }
          }
          else if ( a7 == (int *)(v23 + v36) )
          {
            v26 = 6;
            v24 = 6;
LABEL_88:
            v25 = v20;
LABEL_36:
            if ( v20 > 0 )
            {
LABEL_37:
              v10 = v26 ^ v25;
              if ( (v26 ^ v25) > 3 )
              {
                if ( v25 > 3 )
                {
                  v10 = v44;
                  goto LABEL_40;
                }
LABEL_41:
                a8[3] = v24;
                if ( v26 & 2 || !(v26 & 1) )
                  return v40;
LABEL_43:
                v22 = a8[2];
                goto LABEL_44;
              }
LABEL_57:
              if ( (v26 & v25) > 3 )
              {
                *a8 = 0;
                v40 = 1;
                a8[3] = 2;
                return v40;
              }
              *a8 = 0;
              v37 = 1;
              a8[3] = 1;
              goto LABEL_43;
            }
            if ( v26 <= 3 || v26 & 1 && *(_DWORD *)(v42 + 8) & 2 )
            {
              if ( v36 < 0 )
              {
                if ( v36 != -2 )
                {
                  v33 = v24;
                  v34 = (*(int (__fastcall **)(int, int, int, int, int *))(*(_DWORD *)v38 + 32))(v38, v36, v44, a6, a7);
                  v24 = v33;
                  v20 = v34;
                  v25 = v34;
                  goto LABEL_37;
                }
              }
              else if ( a7 == (int *)(v44 + v36) )
              {
                v25 = 6;
                v20 = 6;
                goto LABEL_37;
              }
              v25 = 1;
              v20 = 1;
              goto LABEL_37;
            }
LABEL_55:
            if ( (v26 ^ 1) > 3 )
              goto LABEL_41;
            v25 = 1;
            goto LABEL_57;
          }
          v26 = 1;
          v24 = 1;
          goto LABEL_88;
        }
        if ( !v24 )
          v24 = 1;
        v26 = v24;
        v25 = v20;
        if ( v20 )
          goto LABEL_37;
        goto LABEL_55;
      }
LABEL_44:
      if ( v22 == 4 )
        return v37;
LABEL_45:
      v14 -= 8;
      --v35;
    }
  }
  *a8 = (int)a5;
  a8[1] = v41;
  if ( v8 < 0 )
  {
    if ( v8 == -2 )
    {
      a8[3] = 1;
      return 0;
    }
    return 0;
  }
  v40 = 0;
  if ( a7 == (int *)((char *)a5 + v8) )
    v28 = 6;
  else
    v28 = 1;
  a8[3] = v28;
  return v40;
}

//----- (000C2410) --------------------------------------------------------
int __fastcall __cxxabiv1::__vmi_class_type_info::__do_upcast(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r8
  _DWORD *v5; // r11
  signed int v6; // r9
  int v7; // r5
  int v8; // r4
  int v9; // r5
  int v10; // r4
  unsigned int v11; // r2
  int v12; // r7
  int v13; // r10
  int v14; // r2
  int v15; // r2
  int result; // r0
  int v17; // r1
  signed int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // [sp+4h] [bp-4Ch]
  int v22; // [sp+14h] [bp-3Ch]
  int v23; // [sp+18h] [bp-38h]
  int v24; // [sp+1Ch] [bp-34h]
  int v25; // [sp+20h] [bp-30h]
  int v26; // [sp+24h] [bp-2Ch]

  v4 = (_DWORD *)a3;
  v5 = a4;
  v22 = a1;
  v6 = __cxxabiv1::__class_type_info::__do_upcast(a1, a2, a3, a4);
  if ( v6 )
    return v6;
  v21 = v5[2];
  if ( v5[2] << 27 < 0 )
    v21 = *(_DWORD *)(v22 + 8);
  v7 = *(_DWORD *)(v22 + 12);
  v8 = v7 + 2;
  v9 = v7 - 1;
  v10 = v22 + 8 * v8;
  if ( v9 == -1 )
  {
LABEL_21:
    v6 = v5[1];
    if ( v5[1] )
      v6 = 1;
    return v6;
  }
  while ( 1 )
  {
    v11 = *(_DWORD *)(v10 - 4);
    v12 = (v11 >> 1) & 1;
    v23 = 0;
    v24 = 0;
    v13 = v11 & 1;
    v25 = v21;
    v26 = 0;
    if ( !v12 && !(v21 & 1) )
      goto LABEL_19;
    if ( v4 )
    {
      v14 = (signed int)v11 >> 8;
      if ( v13 )
        v15 = *(_DWORD *)(*v4 + v14);
    }
    result = (*(int (**)(void))(**(_DWORD **)(v10 - 8) + 24))();
    v6 = result;
    if ( !result )
      goto LABEL_19;
    if ( v26 == 8 && v13 )
      v26 = *(_DWORD *)(v10 - 8);
    if ( v24 > 3 && !v12 )
      v24 &= 0xFFFFFFFD;
    v17 = v5[3];
    if ( v17 )
      break;
    v18 = v24;
    v19 = v25;
    v20 = v26;
    *v5 = v23;
    v5[1] = v18;
    v5[2] = v19;
    v5[3] = v20;
    if ( v18 <= 3 )
      return v6;
    if ( v18 & 2 )
    {
      if ( !(*(_DWORD *)(v22 + 8) & 1) )
        return v6;
      --v9;
      v10 -= 8;
    }
    else
    {
      if ( !(v18 & 1) || !(*(_DWORD *)(v22 + 8) & 2) )
        return v6;
      --v9;
      v10 -= 8;
    }
LABEL_20:
    if ( v9 == -1 )
      goto LABEL_21;
  }
  if ( *v5 == v23 )
  {
    if ( !*v5 && (v26 == 8 || v17 == 8 || !sub_C1FA8(v26, v17)) )
    {
      result = v6;
      v5[1] = 2;
      return result;
    }
    v5[1] |= v24;
LABEL_19:
    --v9;
    v10 -= 8;
    goto LABEL_20;
  }
  *v5 = 0;
  v5[1] = 2;
  return result;
}

//----- (000C2564) --------------------------------------------------------
const char *__fastcall std::bad_typeid::what(std::bad_typeid *this)
{
  return "std::bad_typeid";
}

//----- (000C2570) --------------------------------------------------------
std::bad_typeid *__fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  std::bad_typeid *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F23B0;
  std::exception::~exception((int)this);
  return v1;
}
// F23B0: using guessed type void *;

//----- (000C258C) --------------------------------------------------------
std::bad_typeid *__fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  std::bad_typeid *v1; // r4

  v1 = this;
  std::bad_typeid::~bad_typeid(this);
  operator delete((void *)v1);
  return v1;
}

//----- (000C25A0) --------------------------------------------------------
void __noreturn _cxa_bad_cast()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F23E0;
  _cxa_throw((int)v0, (int)&`typeinfo for'std::bad_cast, (int)std::bad_cast::~bad_cast);
}
// F23CC: using guessed type void *`typeinfo for'std::bad_cast;
// F23E0: using guessed type void *off_F23E0;

//----- (000C25D0) --------------------------------------------------------
void __noreturn _cxa_bad_typeid()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)_cxa_allocate_exception(4);
  *v0 = &off_F23B0;
  _cxa_throw((int)v0, (int)&`typeinfo for'std::bad_typeid, (int)std::bad_typeid::~bad_typeid);
}
// F23B0: using guessed type void *off_F23B0;
// F23C0: using guessed type void *`typeinfo for'std::bad_typeid;

//----- (000C2600) --------------------------------------------------------
int __fastcall _dynamic_cast(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // r5
  int v5; // r6
  int v6; // r8
  int *v7; // r0
  int v8; // r9
  int v9; // r12
  int v10; // r7
  int v11; // r6
  void (__cdecl *v12)(int *, int, signed int, int); // r6
  int result; // r0
  int v14; // [sp+14h] [bp-34h]
  int v15; // [sp+18h] [bp-30h]
  int v16; // [sp+1Ch] [bp-2Ch]
  int v17; // [sp+20h] [bp-28h]
  int v18; // [sp+24h] [bp-24h]

  v4 = a1;
  v5 = *a1;
  v6 = a2;
  v7 = *(int **)(*a1 - 4);
  v8 = a3;
  v9 = *(_DWORD *)(v5 - 8);
  v10 = a4;
  v14 = 0;
  v11 = *v7;
  v15 = 0;
  v12 = *(void (__cdecl **)(int *, int, signed int, int))(v11 + 28);
  v16 = 0;
  v17 = 0;
  v18 = 16;
  v12(v7, a4, 6, a3);
  result = v14;
  if ( !v14 )
    goto LABEL_8;
  if ( (v17 & 6) != 6 && ((unsigned __int8)v15 & (unsigned __int8)v16 & 6) != 6 )
  {
    if ( (v16 & 5) != 4 && !v17 )
    {
      if ( v10 >= 0 )
      {
        if ( v4 == (_DWORD *)(v10 + v14) )
          return result;
        goto LABEL_8;
      }
      if ( v10 != -2
        && ((*(int (__fastcall **)(int, int, int, int, _DWORD *))(*(_DWORD *)v8 + 32))(v8, v10, v14, v6, v4) & 6) == 6 )
      {
        return v14;
      }
    }
LABEL_8:
    result = 0;
  }
  return result;
}

//----- (000C26F8) --------------------------------------------------------
int __fastcall std::__exception_ptr::exception_ptr::exception_ptr(int result)
{
  *(_DWORD *)result = 0;
  return result;
}

//----- (000C2700) --------------------------------------------------------
_DWORD *__fastcall std::__exception_ptr::exception_ptr::exception_ptr(_DWORD *result)
{
  *result = 0;
  return result;
}

//----- (000C2718) --------------------------------------------------------
int __fastcall std::__exception_ptr::exception_ptr::_M_addref(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r1

  if ( *(_DWORD *)result )
  {
    v1 = (unsigned int *)(*(_DWORD *)result - 128);
    __dmb(0xFu);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xFu);
  }
  return result;
}

//----- (000C2738) --------------------------------------------------------
std::__exception_ptr::exception_ptr *__fastcall std::__exception_ptr::exception_ptr::exception_ptr(std::__exception_ptr::exception_ptr *this, void *a2)
{
  std::__exception_ptr::exception_ptr *v2; // r4

  v2 = this;
  *(_DWORD *)this = a2;
  std::__exception_ptr::exception_ptr::_M_addref((int)this);
  return v2;
}

//----- (000C2748) --------------------------------------------------------
std::__exception_ptr::exception_ptr *__fastcall std::__exception_ptr::exception_ptr::exception_ptr(std::__exception_ptr::exception_ptr *this, const std::__exception_ptr::exception_ptr *a2)
{
  std::__exception_ptr::exception_ptr *v2; // r4

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  std::__exception_ptr::exception_ptr::_M_addref((int)this);
  return v2;
}

//----- (000C2758) --------------------------------------------------------
void __fastcall std::__exception_ptr::exception_ptr::_M_release(std::__exception_ptr::exception_ptr *this)
{
  int v1; // r3
  unsigned int *v2; // r4
  unsigned int *v3; // r2
  unsigned int v4; // r1
  unsigned int v5; // r1
  void (__fastcall *v6)(_DWORD); // r3

  v1 = *(_DWORD *)this;
  v2 = (unsigned int *)this;
  if ( *(_DWORD *)this )
  {
    v3 = (unsigned int *)(v1 - 128);
    __dmb(0xFu);
    do
    {
      v4 = __ldrex(v3);
      v5 = v4 - 1;
    }
    while ( __strex(v5, v3) );
    __dmb(0xFu);
    if ( !v5 )
    {
      v6 = *(void (__fastcall **)(_DWORD))(v1 - 116);
      if ( v6 )
        v6(*(_DWORD *)this);
      _cxa_free_exception(*v2);
      *v2 = 0;
    }
  }
}

//----- (000C2794) --------------------------------------------------------
std::__exception_ptr::exception_ptr *__fastcall std::__exception_ptr::exception_ptr::~exception_ptr(std::__exception_ptr::exception_ptr *this)
{
  std::__exception_ptr::exception_ptr *v1; // r4

  v1 = this;
  std::__exception_ptr::exception_ptr::_M_release(this);
  return v1;
}

//----- (000C27A0) --------------------------------------------------------
int __fastcall std::__exception_ptr::exception_ptr::_M_get(std::__exception_ptr::exception_ptr *this)
{
  return *(_DWORD *)this;
}

//----- (000C27A4) --------------------------------------------------------
int __fastcall std::__exception_ptr::exception_ptr::swap(int result, std::__exception_ptr::exception_ptr *a2)
{
  int v2; // r2

  v2 = *(_DWORD *)result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)a2 = v2;
  return result;
}

//----- (000C27B0) --------------------------------------------------------
std::__exception_ptr::exception_ptr *__fastcall std::__exception_ptr::exception_ptr::operator=(std::__exception_ptr::exception_ptr *a1, const std::__exception_ptr::exception_ptr *a2)
{
  std::__exception_ptr::exception_ptr *v2; // r5
  char v4; // [sp+4h] [bp-14h]

  v2 = a1;
  std::__exception_ptr::exception_ptr::exception_ptr((std::__exception_ptr::exception_ptr *)&v4, a2);
  std::__exception_ptr::exception_ptr::swap((int)&v4, v2);
  std::__exception_ptr::exception_ptr::~exception_ptr((std::__exception_ptr::exception_ptr *)&v4);
  return v2;
}

//----- (000C27D4) --------------------------------------------------------
bool __fastcall std::__exception_ptr::exception_ptr::operator!(_DWORD *a1)
{
  return *a1 == 0;
}

//----- (000C27E0) --------------------------------------------------------
_DWORD *__fastcall std::__exception_ptr::exception_ptr::operator void (std::__exception_ptr::exception_ptr::*)(void)(_DWORD *result, _DWORD *a2)
{
  if ( *a2 )
  {
    result[1] = 0;
    *result = std::__exception_ptr::exception_ptr::_M_safe_bool_dummy;
  }
  else
  {
    *result = 0;
    result[1] = 0;
  }
  return result;
}

//----- (000C27FC) --------------------------------------------------------
int __fastcall std::__exception_ptr::exception_ptr::__cxa_exception_type(std::__exception_ptr::exception_ptr *this)
{
  return *(_DWORD *)(*(_DWORD *)this - 120);
}

//----- (000C2804) --------------------------------------------------------
int __fastcall std::__exception_ptr::operator==(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2 + ((unsigned int)(*a1 - *a2) <= 0) + *a2 - *a1;
}

//----- (000C2810) --------------------------------------------------------
int __fastcall std::__exception_ptr::operator!=(_DWORD *a1, _DWORD *a2)
{
  return (unsigned __int8)(std::__exception_ptr::operator==(a1, a2) ^ 1);
}

//----- (000C2820) --------------------------------------------------------
std::__exception_ptr::exception_ptr *__fastcall std::current_exception(std::__exception_ptr::exception_ptr *a1)
{
  std::__exception_ptr::exception_ptr *v1; // r4
  int v2; // r1
  std::__exception_ptr::exception_ptr *result; // r0
  unsigned int v4; // r3
  void *v5; // r1

  v1 = a1;
  v2 = *_cxa_get_globals();
  if ( v2
    && *(_BYTE *)(v2 + 32) == 71
    && *(_BYTE *)(v2 + 33) == 78
    && *(_BYTE *)(v2 + 34) == 85
    && *(_BYTE *)(v2 + 35) == 67
    && *(_BYTE *)(v2 + 36) == 67
    && *(_BYTE *)(v2 + 37) == 43
    && *(_BYTE *)(v2 + 38) == 43
    && (v4 = *(unsigned __int8 *)(v2 + 39), v4 <= 1) )
  {
    if ( v4 == 1 )
      v5 = *(void **)v2;
    else
      v5 = (void *)(v2 + 120);
    std::__exception_ptr::exception_ptr::exception_ptr(v1, v5);
    result = v1;
  }
  else
  {
    std::__exception_ptr::exception_ptr::exception_ptr((int)v1);
    result = v1;
  }
  return result;
}

//----- (000C2888) --------------------------------------------------------
void __fastcall __noreturn std::rethrow_exception(std::__exception_ptr::exception_ptr *a1)
{
  int v1; // r4
  char *v2; // r0
  unsigned int *v3; // r2
  int v4; // r3
  unsigned int v5; // r0
  int v6; // r4
  void *v7; // r1
  void *v8; // r2

  v1 = std::__exception_ptr::exception_ptr::_M_get(a1);
  v2 = _cxa_allocate_dependent_exception();
  v3 = (unsigned int *)(v1 - 128);
  *(_DWORD *)v2 = v1;
  __dmb(0xFu);
  v4 = (int)v2;
  do
    v5 = __ldrex(v3);
  while ( __strex(v5 + 1, v3) );
  __dmb(0xFu);
  v6 = v4 + 32;
  v7 = __cxxabiv1::__unexpected_handler;
  v8 = __cxxabiv1::__terminate_handler;
  *(_BYTE *)(v4 + 32) = 71;
  *(_DWORD *)(v4 + 4) = v7;
  *(_DWORD *)(v4 + 8) = v8;
  *(_BYTE *)(v4 + 33) = 78;
  *(_BYTE *)(v4 + 34) = 85;
  *(_BYTE *)(v4 + 39) = 1;
  *(_DWORD *)(v4 + 40) = sub_C26A8;
  *(_BYTE *)(v4 + 35) = 67;
  *(_BYTE *)(v4 + 36) = 67;
  *(_BYTE *)(v4 + 37) = 43;
  *(_BYTE *)(v4 + 38) = 43;
  __Unwind_RaiseException(v4 + 32, 67, 43, v4);
  _cxa_begin_catch(v6);
  std::terminate();
}
// C26A8: using guessed type int sub_C26A8();
// F3C4C: using guessed type void *__cxxabiv1::__terminate_handler;
// F3C50: using guessed type void *__cxxabiv1::__unexpected_handler;

//----- (000C291C) --------------------------------------------------------
const char *__fastcall std::bad_cast::what(std::bad_cast *this)
{
  return "std::bad_cast";
}

//----- (000C2928) --------------------------------------------------------
std::bad_cast *__fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  std::bad_cast *v1; // r4

  v1 = this;
  *(_DWORD *)this = &off_F23E0;
  std::exception::~exception((int)this);
  return v1;
}
// F23E0: using guessed type void *off_F23E0;

//----- (000C2944) --------------------------------------------------------
std::bad_cast *__fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  std::bad_cast *v1; // r4

  v1 = this;
  std::bad_cast::~bad_cast(this);
  operator delete((void *)v1);
  return v1;
}

//----- (000C2958) --------------------------------------------------------
_DWORD *__fastcall sub_C2958(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F09C0;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F09C0: using guessed type void *off_F09C0;

//----- (000C2988) --------------------------------------------------------
void *__fastcall sub_C2988(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C2958(a1);
  operator delete(v1);
  return v1;
}

//----- (000C299C) --------------------------------------------------------
_DWORD *__fastcall sub_C299C(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F18B8;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F18B8: using guessed type void *off_F18B8;

//----- (000C29CC) --------------------------------------------------------
void *__fastcall sub_C29CC(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C299C(a1);
  operator delete(v1);
  return v1;
}

//----- (000C29E0) --------------------------------------------------------
const char *__fastcall sub_C29E0(int a1)
{
  int v1; // r4
  _DWORD *v2; // r5
  int v3; // r6
  int v4; // r3
  char *v5; // r0
  char v6; // r1
  int v7; // r2
  int v8; // r3
  char *v9; // r0
  char v10; // r1
  int v11; // r2
  _DWORD *v12; // r3
  const char *result; // r0
  _DWORD *v14; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v14 = operator new(0x68u);
    v14[1] = 0;
    v14[2] = 0;
    v14[3] = 0;
    *((_BYTE *)v14 + 16) = 0;
    v14[5] = 0;
    v14[6] = 0;
    v14[7] = 0;
    v14[8] = 0;
    *((_BYTE *)v14 + 36) = 0;
    *((_BYTE *)v14 + 37) = 0;
    *((_BYTE *)v14 + 100) = 0;
    v2 = v14;
    *v14 = &off_F0CF0;
    *(_DWORD *)(v1 + 8) = v14;
  }
  *((_BYTE *)v2 + 36) = 46;
  v3 = *(_DWORD *)(v1 + 8);
  v4 = 0;
  v5 = off_F3C58[0];
  v2[3] = 0;
  v2[2] = &unk_E00F2;
  *((_BYTE *)v2 + 16) = 0;
  *(_BYTE *)(v3 + 37) = 44;
  do
  {
    v6 = v5[v4];
    v7 = *(_DWORD *)(v1 + 8) + v4++;
    *(_BYTE *)(v7 + 38) = v6;
  }
  while ( v4 != 36 );
  v8 = 0;
  v9 = off_F3C54[0];
  do
  {
    v10 = v9[v8];
    v11 = *(_DWORD *)(v1 + 8) + v8++;
    *(_BYTE *)(v11 + 74) = v10;
  }
  while ( v8 != 26 );
  v12 = *(_DWORD **)(v1 + 8);
  result = "true";
  v12[6] = 4;
  v12[5] = "true";
  v12[7] = "false";
  v12[8] = 5;
  return result;
}
// F0CF0: using guessed type void *;
// F3C54: using guessed type char *off_F3C54[17];
// F3C58: using guessed type char *off_F3C58[16];

//----- (000C2A9C) --------------------------------------------------------
signed int __fastcall sub_C2A9C(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  int v3; // r3
  char *v4; // r0
  int v5; // r2
  int v6; // r1
  int v7; // r2
  int v8; // r3
  char *v9; // r0
  int v10; // r1
  signed int result; // r0
  _DWORD *v12; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v12 = operator new(0x128u);
    v12[1] = 0;
    v12[2] = 0;
    v12[3] = 0;
    *((_BYTE *)v12 + 16) = 0;
    v12[5] = 0;
    v12[6] = 0;
    v12[7] = 0;
    v12[8] = 0;
    v12[9] = 0;
    v12[10] = 0;
    *((_BYTE *)v12 + 292) = 0;
    v2 = v12;
    *v12 = &off_F1BE8;
    *(_DWORD *)(v1 + 8) = v12;
  }
  v3 = 0;
  v2[3] = 0;
  v4 = off_F3C58[0];
  v2[2] = &unk_E00F2;
  *((_BYTE *)v2 + 16) = 0;
  v2[9] = 46;
  v2[10] = 44;
  v5 = (int)(v2 + 10);
  do
  {
    v6 = (unsigned __int8)v4[v3++];
    *(_DWORD *)(v5 + 4) = v6;
    v5 += 4;
  }
  while ( v3 != 36 );
  v7 = (int)(v2 + 46);
  v8 = 0;
  v9 = off_F3C54[0];
  do
  {
    v10 = (unsigned __int8)v9[v8++];
    *(_DWORD *)(v7 + 4) = v10;
    v7 += 4;
  }
  while ( v8 != 26 );
  result = 4;
  v2[6] = 4;
  v2[5] = &off_ED2E0;
  v2[7] = &unk_ED2F4;
  v2[8] = 5;
  return result;
}
// ED2E0: using guessed type int *off_ED2E0;
// F1BE8: using guessed type void *;
// F3C54: using guessed type char *off_F3C54[17];
// F3C58: using guessed type char *off_F3C58[16];

//----- (000C2B4C) --------------------------------------------------------
_DWORD *__fastcall sub_C2B4C(_DWORD *a1, int a2, int a3, int a4, int a5, int *a6)
{
  _DWORD *v6; // r4

  v6 = a1;
  sub_C16AC(a1, a6);
  return v6;
}

//----- (000C2B5C) --------------------------------------------------------
int *__fastcall sub_C2B5C(int *a1, int a2, int a3, int a4, int a5, int *a6)
{
  int *v6; // r4

  v6 = a1;
  sub_BA9F4(a1, a6);
  return v6;
}

//----- (000C2B6C) --------------------------------------------------------
_DWORD *__fastcall sub_C2B6C(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F0AA0;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F0AA0: using guessed type void *off_F0AA0;

//----- (000C2B9C) --------------------------------------------------------
void *__fastcall sub_C2B9C(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C2B6C(a1);
  operator delete(v1);
  return v1;
}

//----- (000C2BB0) --------------------------------------------------------
_DWORD *__fastcall sub_C2BB0(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F0AD8;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F0AD8: using guessed type void *off_F0AD8;

//----- (000C2BE0) --------------------------------------------------------
void *__fastcall sub_C2BE0(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C2BB0(a1);
  operator delete(v1);
  return v1;
}

//----- (000C2BF4) --------------------------------------------------------
_DWORD *__fastcall sub_C2BF4(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F1998;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F1998: using guessed type void *off_F1998;

//----- (000C2C24) --------------------------------------------------------
void *__fastcall sub_C2C24(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C2BF4(a1);
  operator delete(v1);
  return v1;
}

//----- (000C2C38) --------------------------------------------------------
_DWORD *__fastcall sub_C2C38(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r0

  v1 = a1;
  v2 = a1[2];
  *v1 = &off_F19D0;
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  sub_AB124(v1);
  return v1;
}
// F19D0: using guessed type void *off_F19D0;

//----- (000C2C68) --------------------------------------------------------
void *__fastcall sub_C2C68(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  sub_C2C38(a1);
  operator delete(v1);
  return v1;
}

//----- (000C2CB4) --------------------------------------------------------
signed int __fastcall sub_C2CB4(int a1)
{
  int v1; // r4
  _DWORD *v2; // r5
  signed int result; // r0
  int v4; // r3
  _DWORD *v5; // r2
  char *v6; // r5
  int v7; // r7
  char v8; // r1
  int v9; // r2
  _DWORD *v10; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v10 = operator new(0x44u);
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = 0;
    *((_BYTE *)v10 + 16) = 0;
    *((_BYTE *)v10 + 17) = 0;
    *((_BYTE *)v10 + 18) = 0;
    v10[5] = 0;
    v10[6] = 0;
    v10[7] = 0;
    v10[8] = 0;
    v10[9] = 0;
    v10[10] = 0;
    v10[11] = 0;
    *((_BYTE *)v10 + 48) = 0;
    *((_BYTE *)v10 + 49) = 0;
    *((_BYTE *)v10 + 50) = 0;
    *((_BYTE *)v10 + 51) = 0;
    *((_BYTE *)v10 + 52) = 0;
    *((_BYTE *)v10 + 53) = 0;
    *((_BYTE *)v10 + 54) = 0;
    *((_BYTE *)v10 + 55) = 0;
    *((_BYTE *)v10 + 67) = 0;
    v2 = v10;
    *v10 = &off_F0CE0;
    *(_DWORD *)(v1 + 8) = v10;
  }
  *((_BYTE *)v2 + 17) = 46;
  result = 67109634;
  v4 = 0;
  *(_BYTE *)(*(_DWORD *)(v1 + 8) + 18) = 44;
  v5 = *(_DWORD **)(v1 + 8);
  v6 = off_F3C5C[0];
  v5[12] = 67109634;
  v7 = *(_DWORD *)(v1 + 8);
  v5[3] = 0;
  v5[2] = &unk_E00F2;
  v5[5] = &unk_E00F2;
  v5[7] = &unk_E00F2;
  v5[9] = &unk_E00F2;
  v5[6] = 0;
  v5[8] = 0;
  v5[10] = 0;
  v5[11] = 0;
  *(_DWORD *)(v7 + 52) = 67109634;
  do
  {
    v8 = v6[v4];
    v9 = *(_DWORD *)(v1 + 8) + v4++;
    *(_BYTE *)(v9 + 56) = v8;
  }
  while ( v4 != 11 );
  return result;
}
// F0CE0: using guessed type void *;
// F3C5C: using guessed type char *off_F3C5C[15];

//----- (000C2D70) --------------------------------------------------------
signed int __fastcall sub_C2D70(int a1)
{
  int v1; // r4
  _DWORD *v2; // r5
  signed int result; // r0
  int v4; // r3
  _DWORD *v5; // r2
  char *v6; // r5
  int v7; // r7
  char v8; // r1
  int v9; // r2
  _DWORD *v10; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v10 = operator new(0x44u);
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = 0;
    *((_BYTE *)v10 + 16) = 0;
    *((_BYTE *)v10 + 17) = 0;
    *((_BYTE *)v10 + 18) = 0;
    v10[5] = 0;
    v10[6] = 0;
    v10[7] = 0;
    v10[8] = 0;
    v10[9] = 0;
    v10[10] = 0;
    v10[11] = 0;
    *((_BYTE *)v10 + 48) = 0;
    *((_BYTE *)v10 + 49) = 0;
    *((_BYTE *)v10 + 50) = 0;
    *((_BYTE *)v10 + 51) = 0;
    *((_BYTE *)v10 + 52) = 0;
    *((_BYTE *)v10 + 53) = 0;
    *((_BYTE *)v10 + 54) = 0;
    *((_BYTE *)v10 + 55) = 0;
    *((_BYTE *)v10 + 67) = 0;
    v2 = v10;
    *v10 = &off_F0CD0;
    *(_DWORD *)(v1 + 8) = v10;
  }
  *((_BYTE *)v2 + 17) = 46;
  result = 67109634;
  v4 = 0;
  *(_BYTE *)(*(_DWORD *)(v1 + 8) + 18) = 44;
  v5 = *(_DWORD **)(v1 + 8);
  v6 = off_F3C5C[0];
  v5[12] = 67109634;
  v7 = *(_DWORD *)(v1 + 8);
  v5[3] = 0;
  v5[2] = &unk_E00F2;
  v5[5] = &unk_E00F2;
  v5[7] = &unk_E00F2;
  v5[9] = &unk_E00F2;
  v5[6] = 0;
  v5[8] = 0;
  v5[10] = 0;
  v5[11] = 0;
  *(_DWORD *)(v7 + 52) = 67109634;
  do
  {
    v8 = v6[v4];
    v9 = *(_DWORD *)(v1 + 8) + v4++;
    *(_BYTE *)(v9 + 56) = v8;
  }
  while ( v4 != 11 );
  return result;
}
// F0CD0: using guessed type void *;
// F3C5C: using guessed type char *off_F3C5C[15];

//----- (000C2E2C) --------------------------------------------------------
signed int __fastcall sub_C2E2C(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  signed int result; // r0
  int v4; // r3
  int v5; // r7
  char *v6; // r4
  int v7; // r2
  int v8; // r1
  _DWORD *v9; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v9 = operator new(0x70u);
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = 0;
    *((_BYTE *)v9 + 16) = 0;
    v9[5] = 0;
    v9[6] = 0;
    v9[7] = 0;
    v9[8] = 0;
    v9[9] = 0;
    v9[10] = 0;
    v9[11] = 0;
    v9[12] = 0;
    v9[13] = 0;
    *((_BYTE *)v9 + 56) = 0;
    *((_BYTE *)v9 + 57) = 0;
    *((_BYTE *)v9 + 58) = 0;
    *((_BYTE *)v9 + 59) = 0;
    *((_BYTE *)v9 + 60) = 0;
    *((_BYTE *)v9 + 61) = 0;
    *((_BYTE *)v9 + 62) = 0;
    *((_BYTE *)v9 + 63) = 0;
    *((_BYTE *)v9 + 108) = 0;
    v2 = v9;
    *v9 = &off_F1BD8;
    *(_DWORD *)(v1 + 8) = v9;
  }
  v2[2] = &unk_E00F2;
  result = 67109634;
  v4 = 0;
  v2[14] = 67109634;
  v5 = *(_DWORD *)(v1 + 8);
  v2[7] = &unk_ECF68;
  v2[3] = 0;
  v2[8] = 0;
  v2[10] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[9] = &unk_ECF68;
  v2[11] = &unk_ECF68;
  v2[5] = 46;
  v2[6] = 44;
  *(_DWORD *)(v5 + 60) = 67109634;
  v6 = off_F3C5C[0];
  v7 = *(_DWORD *)(v1 + 8);
  do
  {
    v8 = (unsigned __int8)v6[v4++];
    v7 += 4;
    *(_DWORD *)(v7 + 60) = v8;
  }
  while ( v4 != 11 );
  return result;
}
// F1BD8: using guessed type void *;
// F3C5C: using guessed type char *off_F3C5C[15];

//----- (000C2EF8) --------------------------------------------------------
signed int __fastcall sub_C2EF8(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  signed int result; // r0
  int v4; // r3
  int v5; // r7
  char *v6; // r4
  int v7; // r2
  int v8; // r1
  _DWORD *v9; // r0

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 8);
  if ( !v2 )
  {
    v9 = operator new(0x70u);
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = 0;
    *((_BYTE *)v9 + 16) = 0;
    v9[5] = 0;
    v9[6] = 0;
    v9[7] = 0;
    v9[8] = 0;
    v9[9] = 0;
    v9[10] = 0;
    v9[11] = 0;
    v9[12] = 0;
    v9[13] = 0;
    *((_BYTE *)v9 + 56) = 0;
    *((_BYTE *)v9 + 57) = 0;
    *((_BYTE *)v9 + 58) = 0;
    *((_BYTE *)v9 + 59) = 0;
    *((_BYTE *)v9 + 60) = 0;
    *((_BYTE *)v9 + 61) = 0;
    *((_BYTE *)v9 + 62) = 0;
    *((_BYTE *)v9 + 63) = 0;
    *((_BYTE *)v9 + 108) = 0;
    v2 = v9;
    *v9 = &off_F1BC8;
    *(_DWORD *)(v1 + 8) = v9;
  }
  v2[2] = &unk_E00F2;
  result = 67109634;
  v4 = 0;
  v2[14] = 67109634;
  v5 = *(_DWORD *)(v1 + 8);
  v2[7] = &unk_ECF68;
  v2[3] = 0;
  v2[8] = 0;
  v2[10] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[9] = &unk_ECF68;
  v2[11] = &unk_ECF68;
  v2[5] = 46;
  v2[6] = 44;
  *(_DWORD *)(v5 + 60) = 67109634;
  v6 = off_F3C5C[0];
  v7 = *(_DWORD *)(v1 + 8);
  do
  {
    v8 = (unsigned __int8)v6[v4++];
    v7 += 4;
    *(_DWORD *)(v7 + 60) = v8;
  }
  while ( v4 != 11 );
  return result;
}
// F1BC8: using guessed type void *;
// F3C5C: using guessed type char *off_F3C5C[15];

//----- (000C2FC4) --------------------------------------------------------
int __fastcall sub_C2FC4(int a1, _BYTE *a2, int a3)
{
  int result; // r0
  _BYTE *v4; // r3
  char *v5; // r1
  _BYTE *v6; // r2
  char v7; // r3
  char v8; // r3

  result = *(_DWORD *)(a1 + 12);
  *a2 = 37;
  if ( result << 20 >= 0 )
    v4 = a2 + 1;
  else
    v4 = a2 + 2;
  if ( result << 20 < 0 )
    a2[1] = 43;
  if ( result << 21 < 0 )
    *v4++ = 35;
  *v4 = 46;
  v4[1] = 42;
  v5 = v4 + 2;
  if ( a3 )
  {
    v5 = v4 + 3;
    v4[2] = a3;
  }
  if ( (result & 0x104) == 4 )
  {
    v6 = v5 + 1;
    *v5 = 102;
LABEL_17:
    *v6 = 0;
    return result;
  }
  if ( (result & 0x104) != 256 )
  {
    v6 = v5 + 1;
    if ( result & 0x4000 )
      v7 = 71;
    else
      v7 = 103;
    *v5 = v7;
    goto LABEL_17;
  }
  if ( result & 0x4000 )
    v8 = 69;
  else
    v8 = 101;
  *v5 = v8;
  v5[1] = 0;
  return result;
}

//----- (000C303C) --------------------------------------------------------
signed int __fastcall sub_C303C(int a1, int a2, unsigned __int8 **a3)
{
  unsigned int v3; // r1
  unsigned __int8 *v4; // r6
  int v5; // r4
  int v6; // r3
  unsigned int v7; // r7
  int v8; // r4
  unsigned int v9; // r1
  int v10; // t1
  int v11; // r5
  signed int v12; // r2
  int v13; // r5
  int v14; // r1
  unsigned int v15; // r0
  int v16; // r1

  v3 = a2 - 1;
  v4 = *a3;
  v5 = *((_DWORD *)*a3 - 3);
  v6 = v5 - 1;
  if ( v3 >= v5 - 1 )
    v7 = v5 - 1;
  else
    v7 = v3;
  if ( v7 )
  {
    v8 = (int)&v4[v5];
    v9 = 0;
    do
    {
      v10 = *(unsigned __int8 *)(v8-- - 1);
      --v6;
      v11 = *(unsigned __int8 *)(a1 + v9++);
      v12 = (unsigned int)(v11 - v10) <= 0;
      if ( v9 < v7 )
        v13 = v12 & 1;
      else
        v13 = 0;
    }
    while ( v13 );
  }
  else
  {
    v12 = 1;
  }
  if ( v6 )
    v14 = v12 & 1;
  else
    v14 = 0;
  v15 = *(unsigned __int8 *)(a1 + v7);
  if ( v14 )
  {
    do
    {
      v12 = v4[v6--] - v15 <= 0;
      if ( v6 )
        v16 = v12 & 1;
      else
        v16 = 0;
    }
    while ( v16 );
  }
  if ( (char)v15 > 0 )
  {
    if ( *v4 <= v15 )
      v12 &= 1u;
    else
      v12 = 0;
  }
  return v12;
}

//----- (000C30B8) --------------------------------------------------------
_DWORD *__fastcall sub_C30B8(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F2408;
  sub_AA8E0(a1);
  return v1;
}
// F2408: using guessed type void *;

//----- (000C30D0) --------------------------------------------------------
void *__fastcall sub_C30D0(_DWORD *a1)
{
  void *v1; // r4

  v1 = a1;
  *a1 = &off_F2408;
  sub_AA8E0(a1);
  operator delete(v1);
  return v1;
}
// F2408: using guessed type void *off_F2408;

//----- (000C3154) --------------------------------------------------------
wctype_t __fastcall sub_C3154(int a1, unsigned int a2)
{
  wctype_t result; // r0

  if ( a2 == 8 )
    return j_wctype("space");
  if ( a2 > 8 )
  {
    if ( a2 == 32 )
    {
      result = j_wctype("cntrl");
    }
    else
    {
      if ( a2 > 0x20 )
      {
        if ( a2 == 68 )
          return j_wctype("xdigit");
        if ( a2 == 151 )
          return j_wctype("print");
        return 0;
      }
      if ( a2 != 16 )
      {
        if ( a2 == 23 )
          return j_wctype("graph");
        return 0;
      }
      result = j_wctype("punct");
    }
  }
  else
  {
    if ( a2 == 3 )
      return j_wctype("alpha");
    if ( a2 <= 3 )
    {
      if ( a2 != 1 )
      {
        if ( a2 == 2 )
          return j_wctype("lower");
        return 0;
      }
      result = j_wctype("upper");
    }
    else
    {
      if ( a2 != 4 )
      {
        if ( a2 == 7 )
          return j_wctype("alnum");
        return 0;
      }
      result = j_wctype("digit");
    }
  }
  return result;
}

//----- (000C3210) --------------------------------------------------------
wint_t __fastcall sub_C3210(int a1, wint_t a2)
{
  return j_towupper(a2);
}

//----- (000C3218) --------------------------------------------------------
unsigned int __fastcall sub_C3218(int a1, wint_t *a2, unsigned int a3)
{
  unsigned int v3; // r6
  wint_t *v4; // r4
  unsigned int v5; // r5

  v3 = a3;
  if ( (unsigned int)a2 < a3 )
  {
    v4 = a2;
    v5 = (unsigned int)a2 + ((a3 + 3 - (_DWORD)(a2 + 1)) & 0xFFFFFFFC) + 4;
    do
    {
      *v4 = towupper(*v4);
      ++v4;
    }
    while ( v4 != (wint_t *)v5 );
  }
  return v3;
}

//----- (000C3240) --------------------------------------------------------
wint_t __fastcall sub_C3240(int a1, wint_t a2)
{
  return j_towlower(a2);
}

//----- (000C3248) --------------------------------------------------------
unsigned int __fastcall sub_C3248(int a1, wint_t *a2, unsigned int a3)
{
  unsigned int v3; // r6
  wint_t *v4; // r4
  unsigned int v5; // r5

  v3 = a3;
  if ( (unsigned int)a2 < a3 )
  {
    v4 = a2;
    v5 = (unsigned int)a2 + ((a3 + 3 - (_DWORD)(a2 + 1)) & 0xFFFFFFFC) + 4;
    do
    {
      *v4 = towlower(*v4);
      ++v4;
    }
    while ( v4 != (wint_t *)v5 );
  }
  return v3;
}

//----- (000C3270) --------------------------------------------------------
signed int __fastcall sub_C3270(int a1, unsigned __int8 a2, wint_t a3)
{
  int v3; // r6
  unsigned __int8 v4; // r7
  wint_t v5; // r8
  int v6; // r5
  int v7; // r4
  int v8; // r3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = 0;
  do
  {
    v8 = v3 + v7++;
    if ( v4 & *(_BYTE *)(v8 + 1168) && iswctype(v5, *(_DWORD *)(v6 + 1184)) )
      return 1;
    v6 += 4;
  }
  while ( v7 != 16 );
  return 0;
}

//----- (000C32B0) --------------------------------------------------------
unsigned int __fastcall sub_C32B0(int a1, unsigned int a2, unsigned int a3, _BYTE *a4)
{
  int v4; // r8
  unsigned int v5; // r11
  _BYTE *v6; // r9
  int v7; // r6
  unsigned int v8; // r10
  int v9; // r4
  int v10; // r5
  char v11; // r7
  wctype_t v12; // r1
  int v13; // r0
  int v14; // r3

  v4 = a1;
  v5 = a3;
  v6 = a4;
  if ( a2 < a3 )
  {
    v7 = a2 + 4;
    v8 = (unsigned int)&a4[((a3 + 3 - (a2 + 4)) >> 2) + 1];
    do
    {
      v9 = 0;
      v10 = v4;
      v11 = 0;
      do
      {
        v12 = *(_DWORD *)(v10 + 1184);
        v10 += 4;
        v13 = iswctype(*(_DWORD *)(v7 - 4), v12);
        v14 = v4 + v9++;
        if ( v13 )
          v11 |= *(_BYTE *)(v14 + 1168);
      }
      while ( v9 != 16 );
      *v6++ = v11;
      v7 += 4;
    }
    while ( v6 != (_BYTE *)v8 );
  }
  return v5;
}

//----- (000C3308) --------------------------------------------------------
_DWORD *__fastcall sub_C3308(int a1, int a2, _DWORD *a3, unsigned int a4)
{
  int v4; // r6
  int v5; // r8
  _DWORD *v6; // r4
  unsigned int v7; // r9
  _DWORD *v9; // r5
  int v10; // r2

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( (unsigned int)a3 < a4 )
  {
    v9 = a3;
    while ( 1 )
    {
      v10 = *v9;
      v6 = v9;
      ++v9;
      if ( (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v4 + 8))(v4, v5, v10) )
        break;
      if ( v7 <= (unsigned int)v9 )
        return v9;
    }
  }
  return v6;
}

//----- (000C3340) --------------------------------------------------------
_DWORD *__fastcall sub_C3340(int a1, int a2, _DWORD *a3, unsigned int a4)
{
  int v4; // r6
  int v5; // r8
  _DWORD *v6; // r4
  unsigned int v7; // r9
  _DWORD *v9; // r5
  int v10; // r2

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( (unsigned int)a3 < a4 )
  {
    v9 = a3;
    while ( 1 )
    {
      v10 = *v9;
      v6 = v9;
      ++v9;
      if ( !(*(int (__fastcall **)(int, int, int))(*(_DWORD *)v4 + 8))(v4, v5, v10) )
        break;
      if ( v7 <= (unsigned int)v9 )
        return v9;
    }
  }
  return v6;
}

//----- (000C3378) --------------------------------------------------------
int __fastcall sub_C3378(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * (a2 + 36));
}

//----- (000C3380) --------------------------------------------------------
unsigned int __fastcall sub_C3380(int a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  int v4; // r5
  unsigned int result; // r0
  int v6; // r1
  int v7; // t1

  v4 = a1;
  result = a3;
  if ( a2 < a3 )
  {
    v6 = a2 - 1;
    do
    {
      v7 = *(unsigned __int8 *)(v6++ + 1);
      *a4 = *(_DWORD *)(v4 + 4 * (v7 + 36));
      ++a4;
    }
    while ( v6 != a3 - 1 );
  }
  return result;
}

//----- (000C33A4) --------------------------------------------------------
int __fastcall sub_C33A4(int a1, wint_t a2, int a3)
{
  int v3; // r4
  int result; // r0

  v3 = a3;
  if ( a2 <= 0x7F && *(_BYTE *)(a1 + 12) )
    return *(unsigned __int8 *)(a2 + a1 + 13);
  result = wctob(a2);
  if ( result == -1 )
    result = v3;
  else
    result = (unsigned __int8)result;
  return result;
}

//----- (000C33C8) --------------------------------------------------------
unsigned int __fastcall sub_C33C8(int a1, unsigned int a2, unsigned int a3, char a4, _BYTE *a5)
{
  int v5; // r9
  unsigned int v6; // r7
  char v7; // r8
  _BYTE *v8; // r4
  int v9; // r6
  unsigned int v10; // r9
  wint_t v11; // t1
  int v12; // r0
  char v13; // r5
  int v15; // r6
  unsigned int v16; // r10
  int v17; // r4
  wint_t v18; // r0
  unsigned int v19; // t1
  int v20; // r3
  int v21; // r0

  v5 = a1;
  v6 = a3;
  v7 = a4;
  v8 = a5;
  if ( *(_BYTE *)(a1 + 12) )
  {
    if ( a2 < a3 )
    {
      v15 = a2 - 4;
      v16 = (unsigned int)&a5[((~a2 + a3) >> 2) + 2];
      v17 = (int)(a5 + 1);
      do
      {
        v19 = *(_DWORD *)(v15 + 4);
        v15 += 4;
        v18 = v19;
        v20 = v5 + v19;
        if ( v19 <= 0x7F )
        {
          *(_BYTE *)(v17 - 1) = *(_BYTE *)(v20 + 13);
        }
        else
        {
          v21 = wctob(v18);
          if ( v21 == -1 )
            LOBYTE(v21) = v7;
          *(_BYTE *)(v17 - 1) = v21;
        }
        ++v17;
      }
      while ( v17 != v16 );
    }
  }
  else if ( a2 < a3 )
  {
    v9 = a2 - 4;
    v10 = (unsigned int)&a5[((~a2 + a3) >> 2) + 1];
    do
    {
      v11 = *(_DWORD *)(v9 + 4);
      v9 += 4;
      v12 = wctob(v11);
      v13 = v12;
      if ( v12 == -1 )
        v13 = v7;
      *v8++ = v13;
    }
    while ( v8 != (_BYTE *)v10 );
  }
  return v6;
}

//----- (000C344C) --------------------------------------------------------
wctype_t __fastcall sub_C344C(int a1)
{
  int v1; // r6
  wint_t v2; // r4
  int v3; // r0
  int v4; // r3
  int v5; // r5
  int v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // r4
  int v10; // r3
  signed int v11; // r1
  wctype_t result; // r0

  v1 = a1;
  v2 = 0;
  do
  {
    v3 = wctob(v2);
    v4 = v1 + v2++;
    if ( v3 == -1 )
    {
      *(_BYTE *)(v1 + 12) = 0;
      goto LABEL_5;
    }
    *(_BYTE *)(v4 + 13) = v3;
  }
  while ( v2 != 128 );
  *(_BYTE *)(v1 + 12) = 1;
LABEL_5:
  v5 = v1 + 140;
  v6 = 0;
  do
  {
    v7 = v6++;
    *(_DWORD *)(v5 + 4) = btowc(v7);
    v5 += 4;
  }
  while ( v6 != 256 );
  v8 = v1;
  v9 = 0;
  do
  {
    v10 = v1 + v9;
    v11 = 1 << v9++;
    *(_BYTE *)(v10 + 1168) = v11;
    result = sub_C3154(v1, (unsigned __int8)v11);
    v8 += 4;
    *(_DWORD *)(v8 + 1180) = result;
  }
  while ( v9 != 16 );
  return result;
}

//----- (000C34B4) --------------------------------------------------------
int __fastcall sub_C34B4(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (000C34B8) --------------------------------------------------------
std::exception *__fastcall sub_C34B8(std::exception *this)
{
  int v1; // r2
  std::exception *v2; // r4
  void *v3; // r0
  unsigned int *v5; // r2
  signed int v6; // r3

  v1 = *((_DWORD *)this + 1);
  v2 = this;
  v3 = (void *)(v1 - 12);
  *(_DWORD *)v2 = &off_F2438;
  if ( (int *)(v1 - 12) != &dword_2FEF3C )
  {
    v5 = (unsigned int *)(v1 - 4);
    __dmb(0xFu);
    do
      v6 = __ldrex(v5);
    while ( __strex(v6 - 1, v5) );
    __dmb(0xFu);
    if ( v6 <= 0 )
      operator delete(v3);
  }
  std::exception::~exception((int)v2);
  return v2;
}
// F2438: using guessed type void *off_F2438;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C3510) --------------------------------------------------------
std::exception *__fastcall sub_C3510(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  sub_C34B8(a1);
  operator delete((void *)v1);
  return v1;
}

//----- (000C3524) --------------------------------------------------------
_DWORD *__fastcall sub_C3524(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r4

  v2 = a1;
  *a1 = &off_F2438;
  sub_C16AC(a1 + 1, a2);
  return v2;
}
// F2438: using guessed type void *;

//----- (000C3560) --------------------------------------------------------
pthread_cond_t *__fastcall sub_C3560(pthread_cond_t *a1)
{
  pthread_cond_t *v1; // r4

  v1 = a1;
  pthread_cond_destroy(a1);
  return v1;
}

//----- (000C35B0) --------------------------------------------------------
std::exception *__fastcall sub_C35B0(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F2468;
  sub_94E2C(a1);
  return v1;
}
// F2468: using guessed type void *;

//----- (000C35C8) --------------------------------------------------------
std::exception *__fastcall sub_C35C8(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F2468;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}
// F2468: using guessed type void *off_F2468;

//----- (000C35E8) --------------------------------------------------------
_DWORD *__fastcall sub_C35E8(_DWORD *a1, int a2)
{
  int v2; // r6
  _DWORD *v3; // r4
  void *v4; // r0
  _DWORD *result; // r0
  unsigned int *v6; // r2
  signed int v7; // r3
  int v8; // [sp+Ch] [bp-14h]

  v2 = a2;
  v3 = a1;
  sub_C1C58((void **)&v8, "regex_error");
  sub_94FC4(v3, &v8);
  v4 = (void *)(v8 - 12);
  if ( (int *)(v8 - 12) != &dword_2FEF3C )
  {
    v6 = (unsigned int *)(v8 - 4);
    __dmb(0xFu);
    do
      v7 = __ldrex(v6);
    while ( __strex(v7 - 1, v6) );
    __dmb(0xFu);
    if ( v7 <= 0 )
      operator delete(v4);
  }
  result = v3;
  v3[2] = v2;
  *v3 = &off_F2468;
  return result;
}
// F2468: using guessed type void *off_F2468;
// 2FEF3C: using guessed type int dword_2FEF3C;

//----- (000C3664) --------------------------------------------------------
const char *sub_C3664()
{
  return "generic";
}

//----- (000C3670) --------------------------------------------------------
const char *sub_C3670()
{
  return "system";
}

//----- (000C367C) --------------------------------------------------------
_DWORD *__fastcall sub_C367C(_DWORD *result)
{
  *result = &off_F24A8;
  return result;
}
// F24A8: using guessed type void *;

//----- (000C368C) --------------------------------------------------------
_DWORD *__fastcall sub_C368C(_DWORD *result, int a2, int a3)
{
  *result = a3;
  result[1] = a2;
  return result;
}

//----- (000C3694) --------------------------------------------------------
bool __fastcall sub_C3694(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r4
  _BOOL4 result; // r0
  int v5; // [sp+0h] [bp-18h]
  int v6; // [sp+4h] [bp-14h]

  v3 = a3;
  (*(void (__fastcall **)(int *, int, int))(*(_DWORD *)a1 + 16))(&v5, a1, a2);
  if ( v6 == v3[1] )
    result = (unsigned int)(v5 - *v3) <= 0;
  else
    result = 0;
  return result;
}

//----- (000C36C8) --------------------------------------------------------
bool __fastcall sub_C36C8(int a1, _DWORD *a2, int a3)
{
  _BOOL4 result; // r0

  if ( a2[1] == a1 )
    result = (unsigned int)(*a2 - a3) <= 0;
  else
    result = 0;
  return result;
}

//----- (000C36DC) --------------------------------------------------------
_DWORD *__fastcall sub_C36DC(_DWORD *result)
{
  *result = &off_F24A8;
  return result;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C36EC) --------------------------------------------------------
_DWORD *__fastcall sub_C36EC(_DWORD *result)
{
  *result = &off_F24A8;
  return result;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C36FC) --------------------------------------------------------
_DWORD *__fastcall sub_C36FC(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F24A8;
  operator delete(a1);
  return v1;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C3714) --------------------------------------------------------
_DWORD *__fastcall sub_C3714(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F24A8;
  operator delete(a1);
  return v1;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C372C) --------------------------------------------------------
_DWORD *__fastcall sub_C372C(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  *a1 = &off_F24A8;
  operator delete(a1);
  return v1;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C3744) --------------------------------------------------------
std::exception *__fastcall sub_C3744(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F2490;
  sub_94E2C(a1);
  return v1;
}
// F2490: using guessed type void *off_F2490;

//----- (000C375C) --------------------------------------------------------
std::exception *__fastcall sub_C375C(std::exception *a1)
{
  std::exception *v1; // r4

  v1 = a1;
  *(_DWORD *)a1 = &off_F2490;
  sub_94E2C(a1);
  operator delete((void *)v1);
  return v1;
}
// F2490: using guessed type void *off_F2490;

//----- (000C377C) --------------------------------------------------------
void **__fastcall sub_C377C(void **a1, int a2, int a3)
{
  void **v3; // r4
  char *v4; // r0

  v3 = a1;
  v4 = strerror(a3);
  sub_C1C58(v3, v4);
  return v3;
}

//----- (000C3798) --------------------------------------------------------
void **__fastcall sub_C3798(void **a1, int a2, int a3)
{
  void **v3; // r4
  char *v4; // r0

  v3 = a1;
  v4 = strerror(a3);
  sub_C1C58(v3, v4);
  return v3;
}

//----- (000C37B4) --------------------------------------------------------
_DWORD *__fastcall sub_C37B4(_DWORD *result)
{
  *result = &off_F24A8;
  return result;
}
// F24A8: using guessed type void *off_F24A8;

//----- (000C37D0) --------------------------------------------------------
int *sub_C37D0()
{
  return &dword_2FEF50;
}
// 2FEF50: using guessed type int dword_2FEF50;

//----- (000C37F0) --------------------------------------------------------
void __noreturn __gnu_cxx::__verbose_terminate_handler(void)
{
  int v0; // r0
  char *v1; // r0
  char *v2; // r6
  char *v3; // r7
  int v4; // [sp+4h] [bp-1Ch]

  if ( !byte_2FEF54 )
  {
    byte_2FEF54 = 1;
    v0 = _cxa_current_exception_type();
    if ( v0 )
    {
      v1 = *(char **)(v0 + 4);
      if ( *v1 == 42 )
        v2 = v1 + 1;
      else
        v2 = v1;
      v4 = -1;
      v3 = _cxa_demangle(v2, 0, 0, &v4);
      fwrite("terminate called after throwing an instance of '", 1u, 0x30u, (FILE *)((char *)&_sF + 168));
      if ( v4 )
        fputs(v2, (FILE *)((char *)&_sF + 168));
      else
        fputs(v3, (FILE *)((char *)&_sF + 168));
      fwrite("'\n", 1u, 2u, (FILE *)((char *)&_sF + 168));
      if ( !v4 )
        free(v3);
      _cxa_rethrow();
    }
    fwrite("terminate called without an active exception\n", 1u, 0x2Du, (FILE *)((char *)&_sF + 168));
    abort();
  }
  fwrite("terminate called recursively\n", 1u, 0x1Du, (FILE *)((char *)&_sF + 168));
  abort();
}
// 2FEF54: using guessed type char byte_2FEF54;

//----- (000C3918) --------------------------------------------------------
_DWORD *__fastcall sub_C3918(int a1, int a2, int a3, int a4)
{
  int v4; // r5
  _DWORD *result; // r0
  int v6; // r6
  int v7; // r4
  _DWORD *v8; // r4
  int v9; // r4

  v4 = a1;
  switch ( a2 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 11:
    case 33:
    case 43:
    case 45:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 59:
    case 60:
    case 62:
    case 74:
    case 75:
      if ( !a3 )
        goto def_C3926;
      goto LABEL_10;
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 40:
    case 51:
    case 52:
    case 58:
    case 61:
    case 65:
    case 66:
    case 67:
    case 71:
    case 72:
    case 73:
      if ( a3 )
        goto LABEL_6;
      goto def_C3926;
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 41:
    case 46:
    case 47:
LABEL_6:
      v6 = *(_DWORD *)(a1 + 20);
      v7 = *(_DWORD *)(a1 + 24);
      result = 0;
      if ( v6 < v7 )
        goto LABEL_7;
      return result;
    case 42:
    case 48:
LABEL_10:
      if ( !a4 )
        goto def_C3926;
      v6 = *(_DWORD *)(a1 + 20);
      v9 = *(_DWORD *)(a1 + 24);
      result = 0;
      if ( v6 < v9 )
      {
LABEL_7:
        v8 = (_DWORD *)(*(_DWORD *)(v4 + 16) + 12 * v6);
        *(_DWORD *)(v4 + 20) = v6 + 1;
        if ( v8 )
        {
          *v8 = a2;
          v8[1] = a3;
          v8[2] = a4;
          result = v8;
        }
      }
      break;
    default:
def_C3926:
      result = 0;
      break;
  }
  return result;
}

//----- (000C39B4) --------------------------------------------------------
_DWORD *__fastcall sub_C39B4(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // r3
  _DWORD *v4; // r4

  v3 = a1[5];
  if ( v3 >= a1[6] )
    return 0;
  v4 = (_DWORD *)(a1[4] + 12 * v3);
  a1[5] = v3 + 1;
  if ( !v4 || a2 <= 0 || !a3 )
    return 0;
  *v4 = a2 <= 0;
  v4[1] = a2;
  v4[2] = a3;
  return v4;
}

//----- (000C39EC) --------------------------------------------------------
int **__fastcall sub_C39EC(int a1, int **a2, int a3)
{
  unsigned __int8 *v3; // r5
  int v4; // r4
  int **v5; // r8
  int v6; // r7
  int v7; // r3
  int **v8; // r6
  int v9; // r1
  _DWORD *v10; // r0
  int v11; // r1
  int *v13; // r3
  int v14; // r2

  v3 = *(unsigned __int8 **)(a1 + 12);
  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = *v3;
  v8 = a2;
  while ( (unsigned int)(v7 - 86) <= 0 || (unsigned int)(v7 - 114) <= 0 )
  {
    *(_DWORD *)(v4 + 12) = v3 + 1;
    if ( (unsigned int)(v7 - 114) <= 0 )
    {
      v11 = 25;
      if ( v6 )
        v11 = 28;
      goto LABEL_13;
    }
    if ( (unsigned int)(v7 - 86) <= 0 )
    {
      v11 = 26;
      if ( v6 )
        v11 = 29;
LABEL_13:
      *(_DWORD *)(v4 + 48) += 9;
      v10 = sub_C3918(v4, v11, 0, 0);
      *v8 = v10;
      if ( !v10 )
        return 0;
      goto LABEL_8;
    }
LABEL_5:
    v9 = 27;
    if ( v6 )
      v9 = 30;
    *(_DWORD *)(v4 + 48) += 6;
    v10 = sub_C3918(v4, v9, 0, 0);
    *v8 = v10;
    if ( !v10 )
      return 0;
LABEL_8:
    v3 = *(unsigned __int8 **)(v4 + 12);
    v8 = (int **)(v10 + 1);
    v7 = *v3;
  }
  if ( v7 == 75 )
  {
    *(_DWORD *)(v4 + 12) = v3 + 1;
    goto LABEL_5;
  }
  if ( !v6 && v7 == 70 && v8 != v5 )
  {
    do
    {
      while ( 1 )
      {
        v13 = *v5;
        v14 = **v5;
        if ( v14 != 26 )
          break;
        *v13 = 29;
        v5 = (int **)(v13 + 1);
        if ( v8 == (int **)(v13 + 1) )
          return v8;
      }
      if ( v14 == 27 )
      {
        *v13 = 30;
      }
      else if ( v14 == 25 )
      {
        *v13 = 28;
      }
      v5 = (int **)(v13 + 1);
    }
    while ( v8 != (int **)(v13 + 1) );
  }
  return v8;
}

//----- (000C3AC4) --------------------------------------------------------
_DWORD *__fastcall sub_C3AC4(int a1, int a2)
{
  int v2; // r3
  _BYTE *v3; // r0
  int v4; // r2
  int v5; // r1

  v2 = a1;
  v3 = *(_BYTE **)(a1 + 12);
  v4 = a2;
  if ( *v3 != 79 )
  {
    if ( (unsigned int)(unsigned __int8)*v3 - 82 > 0 )
      return (_DWORD *)v4;
    goto LABEL_7;
  }
  if ( (unsigned int)(unsigned __int8)*v3 - 82 <= 0 )
  {
LABEL_7:
    *(_DWORD *)(v2 + 48) += 2;
    v5 = 31;
    goto LABEL_4;
  }
  *(_DWORD *)(v2 + 48) += 3;
  v5 = 32;
LABEL_4:
  *(_DWORD *)(v2 + 12) = v3 + 1;
  return sub_C3918(v2, v5, v4, 0);
}

//----- (000C3B08) --------------------------------------------------------
_DWORD *__fastcall sub_C3B08(_DWORD *a1, int a2)
{
  int v2; // r7
  unsigned __int8 *v3; // r1
  int v4; // r6
  signed int v5; // r4
  unsigned __int8 *v6; // r3
  _DWORD *v7; // r0

  v2 = a2;
  v3 = (unsigned __int8 *)a1[3];
  v4 = (int)a1;
  v5 = *v3;
  v6 = (unsigned __int8 *)a1[3];
  if ( v5 == 46 )
  {
    if ( ((v3[1] - 97) & 0xFFu) > 0x19 && v3[1] != 95 )
    {
      v6 = (unsigned __int8 *)a1[3];
      v5 = 46;
    }
    else
    {
      v5 = v3[2];
      v6 = v3 + 2;
      if ( ((v5 - 97) & 0xFFu) <= 0x19 || v5 == 95 )
      {
        do
        {
          do
            v5 = *++v6;
          while ( ((v5 - 97) & 0xFFu) <= 0x19 );
        }
        while ( v5 == 95 );
      }
    }
  }
LABEL_2:
  if ( v5 == 46 )
  {
    while ( ((v6[1] - 48) & 0xFFu) <= 9 )
    {
      v5 = v6[2];
      if ( ((v5 - 48) & 0xFFu) > 9 )
      {
        v6 += 2;
        goto LABEL_2;
      }
      v6 += 2;
      do
        ++v6;
      while ( ((*v6 - 48) & 0xFFu) <= 9 );
      if ( *v6 != 46 )
        break;
    }
  }
  a1[3] = v6;
  v7 = sub_C39B4(a1, (unsigned int)v3, v6 - v3);
  return sub_C3918(v4, 75, v2, (int)v7);
}

//----- (000C3BB0) --------------------------------------------------------
_DWORD *__fastcall sub_C3BB0(_DWORD *a1, int a2)
{
  _BYTE *v2; // r3
  _DWORD *result; // r0
  int v4; // r3
  int v5; // r5
  char *v6; // r2
  unsigned __int8 v7; // r4
  unsigned int v8; // r2
  unsigned int v9; // r1
  _BYTE *v10; // r3
  unsigned int v11; // r1
  int v12; // r6
  int v13; // r3
  int v14; // r4
  int v15; // r12
  _DWORD *v16; // r8
  int v17; // r9
  _DWORD *v18; // r1
  int v19; // r5
  int v20; // r1
  _DWORD *v21; // r2

  v2 = (_BYTE *)a1[3];
  if ( *v2 != 83 )
    return 0;
  a1[3] = v2 + 1;
  if ( !v2[1] )
  {
    v4 = 0;
    goto LABEL_6;
  }
  a1[3] = v2 + 2;
  v4 = (unsigned __int8)v2[1];
  v7 = v4 - 48;
  if ( ((v4 - 48) & 0xFFu) <= 9 || v4 == 95 )
  {
    if ( v4 == 95 )
    {
      v11 = 0;
      goto LABEL_26;
    }
    goto LABEL_15;
  }
  if ( (unsigned int)(v4 - 65) <= 0x19 )
  {
LABEL_15:
    v8 = 0;
    while ( 1 )
    {
      if ( v7 <= 9u )
      {
        v9 = 36 * v8 + v4 - 48;
      }
      else
      {
        if ( ((v4 - 65) & 0xFFu) > 0x19 )
          return 0;
        v9 = 36 * v8 + v4 - 55;
      }
      if ( v8 > v9 )
        return 0;
      v10 = (_BYTE *)a1[3];
      if ( *v10 )
      {
        a1[3] = v10 + 1;
        v4 = (unsigned __int8)*v10;
        if ( v4 == 95 )
        {
          v11 = v9 + 1;
LABEL_26:
          if ( v11 < a1[8] )
          {
            ++a1[10];
            return *(_DWORD **)(4 * v11 + a1[7]);
          }
          return 0;
        }
      }
      else
      {
        v4 = 0;
      }
      v8 = v9;
      v7 = v4 - 48;
    }
  }
LABEL_6:
  if ( a2 && ((a1[2] >> 3) & 1 ^ 1) << 24 )
    v5 = ((*(unsigned __int8 *)a1[3] - 67) & 0xFFu) <= 1;
  else
    v5 = (a1[2] >> 3) & 1;
  v6 = &byte_EF9F0;
  while ( (unsigned __int8)*v6 != v4 )
  {
    v6 += 28;
    if ( v6 == (char *)&off_EFAB4 )
      return 0;
  }
  v12 = *((_DWORD *)v6 + 5);
  if ( v12 )
  {
    v13 = a1[5];
    v14 = a1[6];
    v15 = *((_DWORD *)v6 + 6);
    v16 = 0;
    if ( v13 < v14 )
    {
      v17 = 12 * v13++;
      v18 = (_DWORD *)(a1[4] + v17);
      a1[5] = v13;
      if ( v18 )
      {
        v18[1] = v12;
        v16 = v18;
        *v18 = 24;
        v18[2] = v15;
      }
    }
    a1[11] = v16;
  }
  else
  {
    v14 = a1[6];
    v13 = a1[5];
  }
  if ( v5 )
  {
    v19 = *((_DWORD *)v6 + 3);
    v20 = *((_DWORD *)v6 + 4);
  }
  else
  {
    v19 = *((_DWORD *)v6 + 1);
    v20 = *((_DWORD *)v6 + 2);
  }
  a1[12] += v20;
  if ( v14 <= v13 )
    return 0;
  v21 = (_DWORD *)(a1[4] + 12 * v13);
  a1[5] = v13 + 1;
  result = 0;
  if ( v21 )
  {
    *v21 = 24;
    v21[1] = v19;
    v21[2] = v20;
    result = v21;
  }
  return result;
}
// EF9F0: using guessed type char byte_EF9F0;
// EFAB4: using guessed type char *;

//----- (000C3D34) --------------------------------------------------------
int __fastcall sub_C3D34(int result, char a2)
{
  int v2; // r3
  int v3; // r4
  char v4; // r5
  int v5; // r1
  int v6; // r2

  v2 = *(_DWORD *)(result + 256);
  v3 = result;
  v4 = a2;
  if ( v2 == 255 )
  {
    *(_BYTE *)(result + 255) = 0;
    v6 = *(_DWORD *)(result + 268);
    result = (*(int (**)(void))(result + 264))();
    v5 = 1;
    ++*(_DWORD *)(v3 + 288);
    v2 = 0;
  }
  else
  {
    v5 = v2 + 1;
  }
  *(_DWORD *)(v3 + 256) = v5;
  *(_BYTE *)(v3 + v2) = v4;
  *(_BYTE *)(v3 + 260) = v4;
  return result;
}

//----- (000C3D7C) --------------------------------------------------------
int __fastcall sub_C3D7C(unsigned __int8 **a1)
{
  int v1; // r3
  int v2; // r2
  _DWORD *v3; // r4
  signed int v4; // r5
  int result; // r0
  unsigned __int8 *v6; // r3
  int v7; // r0
  unsigned int v8; // r1

  v1 = (int)*a1;
  v2 = **a1;
  v3 = a1;
  v4 = 0;
  if ( v2 == 110 )
  {
    *a1 = (unsigned __int8 *)(v1 + 1);
    v4 = 1;
    v2 = *(unsigned __int8 *)(v1 + 1);
  }
  if ( ((v2 - 48) & 0xFFu) > 9 )
  {
    result = 0;
  }
  else
  {
    result = 0;
    v6 = (unsigned __int8 *)(*v3 + 1);
    do
    {
      v7 = 10 * result + v2;
      *v3 = v6;
      v2 = *v6;
      result = v7 - 48;
      v8 = (v2 - 48) << 24;
      ++v6;
    }
    while ( v8 >> 24 <= 9 );
  }
  if ( v4 )
    result = -result;
  return result;
}

//----- (000C3DD0) --------------------------------------------------------
_DWORD *__fastcall sub_C3DD0(int a1)
{
  int v1; // r3
  _DWORD *v2; // r4

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 >= *(_DWORD *)(a1 + 24) )
    return 0;
  v2 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v1);
  *(_DWORD *)(a1 + 20) = v1 + 1;
  if ( !v2 )
    return 0;
  *v2 = 64;
  v2[1] = sub_C3D7C((unsigned __int8 **)(a1 + 12));
  return v2;
}

//----- (000C3E00) --------------------------------------------------------
int __fastcall sub_C3E00(int a1)
{
  _BYTE *v1; // r3
  int v2; // r2
  int v3; // r4
  int v4; // r0
  int result; // r0

  v1 = *(_BYTE **)(a1 + 12);
  v2 = (unsigned __int8)*v1;
  v3 = a1;
  if ( v2 == 95 )
  {
    result = 0;
  }
  else
  {
    if ( v2 == 110 )
      return -1;
    v4 = sub_C3D7C((unsigned __int8 **)(a1 + 12));
    v1 = *(_BYTE **)(v3 + 12);
    result = v4 + 1;
    if ( *v1 != 95 )
      return -1;
  }
  *(_DWORD *)(v3 + 12) = v1 + 1;
  return result;
}

//----- (000C3E30) --------------------------------------------------------
_DWORD *__fastcall sub_C3E30(int a1)
{
  _BYTE *v1; // r3
  _DWORD *v2; // r4
  _DWORD *result; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r0
  _DWORD *v7; // r3

  v1 = *(_BYTE **)(a1 + 12);
  v2 = (_DWORD *)a1;
  if ( *v1 != 84 )
    return 0;
  *(_DWORD *)(a1 + 12) = v1 + 1;
  v4 = sub_C3E00(a1);
  if ( v4 < 0 )
    return 0;
  v5 = v2[5];
  v6 = v2[6];
  ++v2[10];
  if ( v5 >= v6 )
    return 0;
  v7 = (_DWORD *)(v2[4] + 12 * v5);
  v2[5] = v5 + 1;
  result = 0;
  if ( v7 )
  {
    *v7 = 5;
    v7[1] = v4;
    result = v7;
  }
  return result;
}

//----- (000C3E78) --------------------------------------------------------
bool __fastcall sub_C3E78(int a1)
{
  _BYTE *v1; // r2
  _BOOL4 v2; // r3

  v1 = *(_BYTE **)(a1 + 12);
  v2 = 1;
  if ( *v1 == 95 )
  {
    *(_DWORD *)(a1 + 12) = v1 + 1;
    v2 = sub_C3D7C((unsigned __int8 **)(a1 + 12)) >= 0;
  }
  return v2;
}

//----- (000C3E98) --------------------------------------------------------
_DWORD *__fastcall sub_C3E98(int a1)
{
  _DWORD *v1; // r4
  int v2; // r0
  int v3; // r5
  unsigned __int8 *v4; // r6
  int v5; // r2
  unsigned __int8 *v6; // r3
  int v7; // r3
  _DWORD *result; // r0

  v1 = (_DWORD *)a1;
  v2 = sub_C3D7C((unsigned __int8 **)(a1 + 12));
  v3 = v2;
  if ( v2 <= 0 )
    return 0;
  v4 = (unsigned __int8 *)v1[3];
  if ( v2 > v1[1] - (signed int)v4 )
  {
    result = 0;
  }
  else
  {
    v5 = v1[2];
    v6 = &v4[v2];
    v1[3] = &v4[v2];
    if ( v5 & 4 && *v6 == 36 )
      v1[3] = v6 + 1;
    if ( v2 > 9 && !memcmp(v4, "_GLOBAL_", 8u) && ((v7 = v4[8], v7 == 46) || v7 == 95 || v7 == 36) && v4[9] == 78 )
    {
      v1[12] = v1[12] + 22 - v3;
      result = sub_C39B4(v1, (unsigned int)"(anonymous namespace)", 21);
    }
    else
    {
      result = sub_C39B4(v1, (unsigned int)v4, v3);
    }
  }
  v1[11] = result;
  return result;
}

//----- (000C3F24) --------------------------------------------------------
signed int __fastcall sub_C3F24(int a1, int a2)
{
  int v2; // r4
  _BYTE *v3; // r3
  signed int result; // r0
  _BYTE *v5; // r3
  _BYTE *v6; // r3

  v2 = a1;
  if ( !a2 )
  {
    v3 = *(_BYTE **)(a1 + 12);
    if ( !*v3 )
      return 0;
    *(_DWORD *)(a1 + 12) = v3 + 1;
    a2 = (unsigned __int8)*v3;
  }
  if ( a2 == 104 )
  {
    sub_C3D7C((unsigned __int8 **)(a1 + 12));
  }
  else
  {
    if ( a2 != 118 )
      return 0;
    sub_C3D7C((unsigned __int8 **)(a1 + 12));
    v5 = *(_BYTE **)(v2 + 12);
    if ( *v5 != 95 )
      return 0;
    *(_DWORD *)(v2 + 12) = v5 + 1;
    sub_C3D7C((unsigned __int8 **)(v2 + 12));
  }
  v6 = *(_BYTE **)(v2 + 12);
  result = 0;
  if ( *v6 == 95 )
  {
    *(_DWORD *)(v2 + 12) = v6 + 1;
    result = 1;
  }
  return result;
}

//----- (000C3F80) --------------------------------------------------------
int __fastcall sub_C3F80(int a1, int *a2)
{
  int v2; // r3
  int v3; // r2
  _DWORD *v4; // r3
  int result; // r0

  v2 = *(_DWORD *)(a1 + 272);
  if ( !v2 )
  {
    *(_DWORD *)(a1 + 280) = 1;
    return 0;
  }
  v3 = *a2;
  v4 = *(_DWORD **)(*(_DWORD *)(v2 + 4) + 8);
  if ( !v4 || *v4 != 47 )
    return 0;
  if ( v3 > 0 )
  {
    while ( 1 )
    {
      v4 = (_DWORD *)v4[2];
      --v3;
      if ( !v4 || *v4 != 47 )
        break;
      if ( !v3 )
        return v4[1];
    }
    return 0;
  }
  result = 0;
  if ( !v3 )
    return v4[1];
  return result;
}

//----- (000C3FD0) --------------------------------------------------------
_DWORD *__fastcall sub_C3FD0(int a1, _DWORD *a2)
{
  int v2; // r5
  _DWORD *v3; // r4
  _DWORD *result; // r0

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      switch ( *v3 )
      {
        case 0:
        case 6:
        case 0x18:
        case 0x27:
        case 0x31:
        case 0x3F:
        case 0x44:
        case 0x46:
        case 0x49:
        case 0x4A:
          return 0;
        case 5:
          result = (_DWORD *)sub_C3F80(v2, v3 + 1);
          if ( !result || *result != 47 )
            return 0;
          return result;
        case 7:
        case 8:
        case 0x32:
          goto LABEL_4;
        default:
          result = (_DWORD *)sub_C3FD0(v2, v3[1]);
          if ( result )
            return result;
LABEL_4:
          v3 = (_DWORD *)v3[2];
          if ( !v3 )
            return 0;
          break;
      }
    }
  }
  return 0;
}

//----- (000C4058) --------------------------------------------------------
void __fastcall sub_C4058(void *src, size_t n, int a3)
{
  size_t v3; // r4
  size_t v4; // r3
  size_t v5; // r6
  void *v6; // r7
  int v7; // r5
  void *v8; // r0
  void *v9; // r8

  v3 = *(_DWORD *)(a3 + 8);
  v4 = *(_DWORD *)(a3 + 4) + 1 + n;
  v5 = n;
  v6 = src;
  v7 = a3;
  if ( v4 > v3 )
  {
    if ( *(_DWORD *)(a3 + 12) )
      return;
    if ( v3 || (v3 = 2, v4 > 2) )
    {
      do
        v3 *= 2;
      while ( v4 > v3 );
    }
    v8 = realloc(*(void **)a3, v3);
    v9 = v8;
    if ( !v8 )
    {
      free(*(void **)v7);
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 4) = v9;
      *(_DWORD *)(v7 + 8) = v9;
      *(_DWORD *)(v7 + 12) = 1;
      return;
    }
    *(_DWORD *)v7 = v8;
    *(_DWORD *)(v7 + 8) = v3;
  }
  if ( !*(_DWORD *)(v7 + 12) )
  {
    memcpy((void *)(*(_DWORD *)v7 + *(_DWORD *)(v7 + 4)), v6, v5);
    *(_BYTE *)(*(_DWORD *)v7 + v5 + *(_DWORD *)(v7 + 4)) = 0;
    *(_DWORD *)(v7 + 4) += v5;
  }
}

//----- (000C40DC) --------------------------------------------------------
_DWORD *__fastcall sub_C40DC(_DWORD *a1)
{
  _BYTE *v1; // r3
  _DWORD *v2; // r5
  _DWORD *result; // r0
  unsigned __int8 *v4; // r1
  int v5; // r2
  _DWORD *v6; // r0
  int v7; // r6
  unsigned __int8 *v8; // r1
  int v9; // r7
  int v10; // r3
  unsigned __int8 *v11; // r3
  int v12; // r4
  int v13; // r2
  _DWORD *v14; // r0
  int v15; // r3

  v1 = (_BYTE *)a1[3];
  v2 = a1;
  if ( *v1 != 76 )
    return 0;
  v4 = v1 + 1;
  a1[3] = v1 + 1;
  if ( v1[1] == 90 )
  {
    if ( (unsigned int)(unsigned __int8)v1[1] - 95 > 0 )
    {
LABEL_11:
      v2[3] = v4 + 1;
      result = sub_C4D70((int)v2, 0);
      v4 = (unsigned __int8 *)v2[3];
      v5 = *v4;
      goto LABEL_7;
    }
LABEL_10:
    v4 = v1 + 2;
    a1[3] = v1 + 2;
    v5 = (unsigned __int8)v1[2];
    result = 0;
    if ( v5 != 90 )
      goto LABEL_7;
    goto LABEL_11;
  }
  if ( (unsigned int)(unsigned __int8)v1[1] - 95 <= 0 )
    goto LABEL_10;
  v6 = sub_C4568((int)a1);
  v7 = (int)v6;
  if ( !v6 )
    return 0;
  if ( *v6 == 39 )
  {
    v15 = v6[1];
    if ( *(_DWORD *)(v15 + 16) )
      v2[12] -= *(_DWORD *)(v15 + 4);
  }
  v8 = (unsigned __int8 *)v2[3];
  v9 = 59;
  v10 = *v8;
  if ( v10 == 110 )
  {
    v2[3] = v8 + 1;
    v9 = 60;
    v10 = (v8++)[1];
  }
  if ( v10 == 69 )
  {
    v13 = 0;
  }
  else
  {
    if ( !v10 )
      return 0;
    v11 = v8 + 1;
    while ( 1 )
    {
      v2[3] = v11;
      v12 = *v11;
      if ( v12 == 69 )
        break;
      ++v11;
      if ( !v12 )
        return 0;
    }
    v13 = v11 - v8;
  }
  v14 = sub_C39B4(v2, (unsigned int)v8, v13);
  result = sub_C3918((int)v2, v9, v7, (int)v14);
  v4 = (unsigned __int8 *)v2[3];
  v5 = *v4;
LABEL_7:
  if ( v5 != 69 )
    return 0;
  v2[3] = v4 + 1;
  return result;
}

//----- (000C41A4) --------------------------------------------------------
_DWORD *__fastcall sub_C41A4(_DWORD *a1)
{
  unsigned __int8 *v1; // r2
  _DWORD *v2; // r4
  int v3; // r6
  unsigned __int8 *v4; // r3
  int v5; // r0
  int *v6; // r5
  _DWORD *v7; // r2
  _DWORD *v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r0
  _BYTE *v11; // r3
  int v13; // [sp+4h] [bp-14h]

  v1 = (unsigned __int8 *)a1[3];
  v2 = a1;
  v3 = a1[11];
  if ( ((*v1 - 73) & 0xFFu) > 1 )
    return 0;
  v4 = v1 + 1;
  a1[3] = v1 + 1;
  v5 = v1[1];
  if ( v5 != 69 )
  {
    v13 = 0;
    v6 = &v13;
    while ( 1 )
    {
      switch ( v5 )
      {
        case 73:
        case 74:
          v7 = sub_C41A4(v2);
          break;
        case 76:
          v7 = sub_C40DC(v2);
          break;
        case 88:
          v2[3] = v4 + 1;
          v10 = sub_C55E4(v2);
          v11 = (_BYTE *)v2[3];
          if ( *v11 != 69 )
            return 0;
          v2[3] = v11 + 1;
          v7 = v10;
          break;
        default:
          v7 = sub_C4568((int)v2);
          break;
      }
      if ( !v7 )
        break;
      v8 = sub_C3918((int)v2, 47, (int)v7, 0);
      *v6 = (int)v8;
      if ( !v8 )
        break;
      v4 = (unsigned __int8 *)v2[3];
      v9 = v8;
      v5 = *v4;
      v6 = v9 + 2;
      if ( v5 == 69 )
      {
        v2[3] = v4 + 1;
        v2[11] = v3;
        return (_DWORD *)v13;
      }
    }
    return 0;
  }
  v2[3] = v1 + 2;
  return sub_C3918((int)v2, 47, 0, 0);
}

//----- (000C4260) --------------------------------------------------------
_DWORD *__fastcall sub_C4260(_DWORD *a1)
{
  unsigned __int8 *v1; // r3
  _DWORD *v2; // r5
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v6; // r0
  _BYTE *v7; // r3
  int v8; // r7
  _DWORD *v9; // r6
  _DWORD *v10; // r0
  int **v11; // r8
  _DWORD *v12; // r0
  unsigned __int8 *v13; // r3
  int *i; // r6
  signed int v15; // r4
  int v16; // r9
  _DWORD *v17; // r4
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _BYTE *v20; // r1
  int v21; // r3
  int v22; // r3
  _DWORD *v23; // r0
  int v24; // r1
  int v25; // r3
  int *v26; // r0
  int *v27; // r3
  int v28; // r2
  int v29; // r6
  _DWORD *v30; // r0
  _DWORD *v31; // r4
  int v32; // r2
  _DWORD *v33; // r3
  _BYTE *v34; // r3
  int v35; // [sp+4h] [bp-24h]

  v1 = (unsigned __int8 *)a1[3];
  v2 = a1;
  switch ( *v1 )
  {
    case 0x4Cu:
    case 0x55u:
      return sub_C536C(a1);
    case 0x4Eu:
      a1[3] = v1 + 1;
      v11 = sub_C39EC((int)a1, (int **)&v35, 1);
      if ( !v11 )
        goto LABEL_6;
      v12 = sub_C3AC4((int)v2, 0);
      v13 = (unsigned __int8 *)v2[3];
      i = 0;
      v15 = *v13;
      v16 = (int)v12;
LABEL_12:
      if ( !v15 )
        goto LABEL_28;
LABEL_13:
      if ( v15 != 68 )
        goto LABEL_14;
      if ( (v13[1] & 0xDF) != 84 )
        goto LABEL_37;
      v27 = sub_C4568((int)v2);
      if ( !i )
        goto LABEL_49;
      break;
    case 0x53u:
      if ( v1[1] == 116 )
      {
        a1[3] = v1 + 2;
        v17 = sub_C39B4(a1, (unsigned int)"std", 3);
        v18 = sub_C536C(v2);
        v19 = sub_C3918((int)v2, 1, (int)v17, (int)v18);
        v20 = (_BYTE *)v2[3];
        v2[12] += 3;
        v9 = v19;
        v4 = v19;
        if ( *v20 != 73 )
          return v4;
        if ( !v19 )
          goto LABEL_6;
        v21 = v2[8];
        if ( v21 >= v2[9] )
          goto LABEL_6;
        *(_DWORD *)(4 * v21 + v2[7]) = v19;
        v2[8] = v21 + 1;
      }
      else
      {
        v9 = sub_C3BB0(a1, 0);
        v4 = v9;
        if ( *(_BYTE *)v2[3] != 73 )
          return v4;
      }
      v10 = sub_C41A4(v2);
      return sub_C3918((int)v2, 4, (int)v9, (int)v10);
    case 0x5Au:
      a1[3] = v1 + 1;
      v6 = sub_C4D70((int)a1, 0);
      v7 = (_BYTE *)v2[3];
      v8 = (int)v6;
      if ( *v7 != 69 )
        goto LABEL_6;
      v2[3] = v7 + 1;
      v28 = (unsigned __int8)v7[1];
      if ( v28 == 115 )
      {
        v2[3] = v7 + 2;
        if ( !sub_C3E78((int)v2) )
          goto LABEL_6;
        v33 = sub_C39B4(v2, (unsigned int)"string literal", 14);
      }
      else
      {
        if ( v28 == 100 )
        {
          v2[3] = v7 + 2;
          v29 = sub_C3E00((int)v2);
          if ( v29 < 0 )
            return 0;
        }
        else
        {
          v29 = -1;
        }
        v30 = sub_C4260(v2);
        v31 = v30;
        if ( v30 && *v30 != 68 && *v30 != 70 && !sub_C3E78((int)v2) )
          return 0;
        if ( v29 == -1 )
        {
          v33 = v31;
        }
        else
        {
          v32 = v2[5];
          v33 = 0;
          if ( v32 < v2[6] )
          {
            v33 = (_DWORD *)(v2[4] + 12 * v32);
            v2[5] = v32 + 1;
            if ( v33 )
            {
              *v33 = 69;
              v33[2] = v29;
              v33[1] = v31;
            }
          }
        }
      }
      return sub_C3918((int)v2, 2, v8, (int)v33);
    default:
      v3 = sub_C536C(a1);
      v4 = v3;
      if ( *(_BYTE *)v2[3] == 73 )
      {
        if ( v3 && (v22 = v2[8], v22 < v2[9]) )
        {
          *(_DWORD *)(4 * v22 + v2[7]) = v3;
          v2[8] = v22 + 1;
          v23 = sub_C41A4(v2);
          v4 = sub_C3918((int)v2, 4, (int)v4, (int)v23);
        }
        else
        {
LABEL_6:
          v4 = 0;
        }
      }
      return v4;
  }
LABEL_39:
  v24 = 1;
  while ( 2 )
  {
    for ( i = sub_C3918((int)v2, v24, (int)i, (int)v27); ; i = v27 )
    {
      if ( v15 == 83 )
        goto LABEL_46;
      v13 = (unsigned __int8 *)v2[3];
      if ( *v13 != 69 )
      {
        if ( !i )
          goto LABEL_28;
        v25 = v2[8];
        if ( v25 >= v2[9] )
          goto LABEL_28;
        *(_DWORD *)(4 * v25 + v2[7]) = i;
        v2[8] = v25 + 1;
LABEL_46:
        v13 = (unsigned __int8 *)v2[3];
        v15 = *v13;
        goto LABEL_12;
      }
      v15 = 69;
LABEL_14:
      if ( ((v15 - 48) & 0xFFu) > 9 && ((v15 - 97) & 0xFFu) > 0x19 && v15 != 67 && v15 != 85 && v15 != 76 )
        break;
LABEL_37:
      v27 = sub_C536C(v2);
LABEL_38:
      if ( i )
        goto LABEL_39;
LABEL_49:
      ;
    }
    switch ( v15 )
    {
      case 83:
        v27 = sub_C3BB0(v2, 1);
        goto LABEL_38;
      case 73:
        if ( !i )
          goto LABEL_28;
        v26 = sub_C41A4(v2);
        v24 = 4;
        v27 = v26;
        continue;
      case 84:
        v27 = sub_C3E30((int)v2);
        goto LABEL_38;
    }
  }
  if ( v15 != 69 )
  {
    if ( v15 != 77 || !i || (v2[3] = v13 + 1, v15 = v13[1], ++v13, !v15) )
    {
LABEL_28:
      *v11 = 0;
      return 0;
    }
    goto LABEL_13;
  }
  *v11 = i;
  if ( !i )
    goto LABEL_6;
  if ( v16 )
  {
    *(_DWORD *)(v16 + 4) = v35;
    v35 = v16;
  }
  v34 = (_BYTE *)v2[3];
  if ( *v34 != 69 )
    goto LABEL_6;
  v2[3] = v34 + 1;
  return (_DWORD *)v35;
}

//----- (000C4568) --------------------------------------------------------
_DWORD *__fastcall sub_C4568(int a1)
{
  unsigned __int8 *v1; // r2
  int v2; // r3
  int v3; // r4
  _DWORD *v4; // r5
  int **v6; // r5
  int *v7; // r0
  int v8; // r3
  int *v9; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  int v12; // r3
  _BYTE *v13; // r1
  int v14; // r3
  unsigned __int8 *v15; // r2
  int v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _BYTE *v19; // r3
  _DWORD *v20; // r1
  int v21; // r0
  int v22; // r7
  int *v23; // r5
  int *v24; // r0
  int v25; // r1
  int v26; // r3
  int v27; // r0
  int v28; // r0
  int v29; // r0
  int v30; // r3
  _DWORD *v31; // r0
  _BYTE *v32; // r2
  _DWORD *v33; // r0
  _BYTE *v34; // r1
  int v35; // r3
  int v36; // r0
  char **v37; // r1
  int v38; // r3
  int v39; // r3
  char **v40; // r3
  int v41; // r3
  char **v42; // r3
  _BYTE *v43; // r3
  int v44; // r0
  int v45; // r3
  char **v46; // r3
  int v47; // r3
  int v48; // r3
  int v49; // r3
  _DWORD *v50; // r0
  _BYTE *v51; // r3
  int v52; // r3
  _DWORD *v53; // r5
  unsigned int v54; // r2
  _BYTE *v55; // r3
  _BOOL2 v56; // r2
  int v57; // r0
  int v58; // r3
  _DWORD *v59; // r5
  int v60; // r0
  _DWORD *v61; // r0
  int *v62; // r2
  _DWORD *v63; // r5
  _DWORD *v64; // [sp+4h] [bp-1Ch]

  v1 = *(unsigned __int8 **)(a1 + 12);
  v2 = *v1;
  v3 = a1;
  if ( v2 != 114 && v2 != 86 && v2 != 75 )
  {
    switch ( v2 )
    {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 78:
      case 90:
        v11 = sub_C4260((_DWORD *)a1);
        v64 = v11;
        goto LABEL_16;
      case 65:
        v13 = v1 + 1;
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v14 = v1[1];
        if ( v14 == 95 )
        {
          v59 = 0;
LABEL_111:
          *(_DWORD *)(v3 + 12) = v13 + 1;
          v60 = sub_C4568(v3);
          v11 = sub_C3918(v3, 42, (int)v59, v60);
          v64 = v11;
LABEL_16:
          if ( v11 )
          {
LABEL_17:
            v12 = *(_DWORD *)(v3 + 32);
            if ( v12 < *(_DWORD *)(v3 + 36) )
            {
              *(_DWORD *)(4 * v12 + *(_DWORD *)(v3 + 28)) = v11;
              *(_DWORD *)(v3 + 32) = v12 + 1;
              return v64;
            }
          }
          return 0;
        }
        if ( ((v14 - 48) & 0xFFu) <= 9 )
        {
          v15 = v1 + 1;
          do
            *(_DWORD *)(a1 + 12) = ++v15;
          while ( ((*v15 - 48) & 0xFFu) <= 9 );
          v59 = sub_C39B4((_DWORD *)a1, (unsigned int)v13, v15 - v13);
          if ( !v59 )
          {
LABEL_28:
            v11 = 0;
LABEL_29:
            v64 = 0;
            goto LABEL_16;
          }
        }
        else
        {
          v61 = sub_C55E4((_DWORD *)a1);
          v59 = v61;
          if ( !v61 )
          {
            v11 = 0;
            goto LABEL_29;
          }
        }
        v13 = *(_BYTE **)(v3 + 12);
        if ( *v13 == 95 )
          goto LABEL_111;
        goto LABEL_28;
      case 67:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v16 = sub_C4568(a1);
        v11 = sub_C3918(v3, 37, v16, 0);
        v64 = v11;
        goto LABEL_16;
      case 68:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        if ( v1[1] )
        {
          *(_DWORD *)(a1 + 12) = v1 + 2;
          switch ( v1[1] )
          {
            case 0x46u:
              v52 = *(_DWORD *)(a1 + 20);
              v53 = 0;
              if ( v52 < *(_DWORD *)(a1 + 24) )
              {
                v53 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v52);
                *(_DWORD *)(a1 + 20) = v52 + 1;
              }
              v64 = v53;
              *v53 = 44;
              v54 = (v1[2] - 48) & 0xFF;
              *((_WORD *)v53 + 4) = v54 <= 9;
              if ( v54 <= 9 )
              {
                sub_C3D7C((unsigned __int8 **)(a1 + 12));
                v53 = v64;
              }
              v53[1] = sub_C4568(v3);
              if ( !v64[1] )
                return 0;
              sub_C3D7C((unsigned __int8 **)(v3 + 12));
              v55 = *(_BYTE **)(v3 + 12);
              v56 = 0;
              if ( *v55 )
              {
                *(_DWORD *)(v3 + 12) = v55 + 1;
                v56 = (unsigned int)(unsigned __int8)*v55 - 115 <= 0;
              }
              v4 = v64;
              *((_WORD *)v64 + 5) = v56;
              return v4;
            case 0x54u:
            case 0x74u:
              v50 = sub_C55E4((_DWORD *)a1);
              v11 = sub_C3918(v3, 65, (int)v50, 0);
              v64 = v11;
              if ( v11 )
              {
                v51 = *(_BYTE **)(v3 + 12);
                if ( *v51 )
                {
                  *(_DWORD *)(v3 + 12) = v51 + 1;
                  if ( *v51 == 69 )
                    goto LABEL_17;
                }
              }
              return 0;
            case 0x61u:
              return sub_C39B4((_DWORD *)a1, (unsigned int)"auto", 4);
            case 0x64u:
              v49 = *(_DWORD *)(a1 + 20);
              if ( v49 >= *(_DWORD *)(a1 + 24) )
                goto LABEL_118;
              v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v49);
              *(_DWORD *)(a1 + 20) = v49 + 1;
              if ( !v4 )
                goto LABEL_122;
              *v4 = 39;
              v46 = &off_EFCD0;
              v4[1] = &off_EFCD0;
              goto LABEL_82;
            case 0x65u:
              v48 = *(_DWORD *)(a1 + 20);
              if ( v48 >= *(_DWORD *)(a1 + 24) )
                goto LABEL_117;
              v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v48);
              *(_DWORD *)(a1 + 20) = v48 + 1;
              if ( !v4 )
                goto LABEL_120;
              *v4 = 39;
              v40 = &off_EFCE4;
              v4[1] = &off_EFCE4;
              goto LABEL_68;
            case 0x66u:
              v47 = *(_DWORD *)(a1 + 20);
              if ( v47 >= *(_DWORD *)(a1 + 24) )
                goto LABEL_119;
              v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v47);
              *(_DWORD *)(a1 + 20) = v47 + 1;
              if ( !v4 )
                goto LABEL_123;
              *v4 = 39;
              v42 = &off_EFCBC;
              v4[1] = &off_EFCBC;
              goto LABEL_72;
            case 0x68u:
              v41 = *(_DWORD *)(a1 + 20);
              if ( v41 >= *(_DWORD *)(a1 + 24) )
              {
LABEL_119:
                v42 = (char **)("_ZN22AcquireChannelPlayInfoC2EP11CurlWrapperP13TaskSchedulerP22ChannelPlayInfoManagerPFv"
                                "P8DataUnitEiP15FifoDataManager"
                              + 69);
                v4 = 0;
              }
              else
              {
                v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v41);
                *(_DWORD *)(a1 + 20) = v41 + 1;
                if ( v4 )
                {
                  *v4 = 39;
                  v42 = &off_EFCF8;
                  v4[1] = &off_EFCF8;
                }
                else
                {
LABEL_123:
                  v42 = (char **)v4[1];
                }
              }
LABEL_72:
              *(_DWORD *)(a1 + 48) += v42[1];
              return v4;
            case 0x69u:
              v39 = *(_DWORD *)(a1 + 20);
              if ( v39 >= *(_DWORD *)(a1 + 24) )
                goto LABEL_117;
              v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v39);
              *(_DWORD *)(a1 + 20) = v39 + 1;
              if ( !v4 )
                goto LABEL_120;
              *v4 = 39;
              v40 = &off_EFD20;
              v4[1] = &off_EFD20;
              goto LABEL_68;
            case 0x6Eu:
              v58 = *(_DWORD *)(a1 + 20);
              if ( v58 >= *(_DWORD *)(a1 + 24) )
              {
LABEL_117:
                v40 = (char **)("_ZN22AcquireChannelPlayInfoC2EP11CurlWrapperP13TaskSchedulerP22ChannelPlayInfoManagerPFv"
                                "P8DataUnitEiP15FifoDataManager"
                              + 69);
                v4 = 0;
              }
              else
              {
                v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v58);
                *(_DWORD *)(a1 + 20) = v58 + 1;
                if ( v4 )
                {
                  *v4 = 39;
                  v40 = &off_EFD34;
                  v4[1] = &off_EFD34;
                }
                else
                {
LABEL_120:
                  v40 = (char **)v4[1];
                }
              }
LABEL_68:
              *(_DWORD *)(a1 + 48) += v40[1];
              return v4;
            case 0x70u:
              v57 = sub_C4568(a1);
              v11 = sub_C3918(v3, 73, v57, 0);
              v64 = v11;
              goto LABEL_16;
            case 0x73u:
              v45 = *(_DWORD *)(a1 + 20);
              if ( v45 >= *(_DWORD *)(a1 + 24) )
              {
LABEL_118:
                v46 = (char **)("_ZN22AcquireChannelPlayInfoC2EP11CurlWrapperP13TaskSchedulerP22ChannelPlayInfoManagerPFv"
                                "P8DataUnitEiP15FifoDataManager"
                              + 69);
                v4 = 0;
              }
              else
              {
                v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v45);
                *(_DWORD *)(a1 + 20) = v45 + 1;
                if ( v4 )
                {
                  *v4 = 39;
                  v46 = &off_EFD0C;
                  v4[1] = &off_EFD0C;
                }
                else
                {
LABEL_122:
                  v46 = (char **)v4[1];
                }
              }
LABEL_82:
              *(_DWORD *)(a1 + 48) += v46[1];
              return v4;
            case 0x76u:
              if ( v1[2] == 95 )
              {
                *(_DWORD *)(a1 + 12) = v1 + 3;
                v63 = sub_C55E4((_DWORD *)a1);
              }
              else
              {
                v63 = sub_C3DD0(a1);
              }
              if ( !v63 )
                goto LABEL_28;
              v43 = *(_BYTE **)(v3 + 12);
              v11 = 0;
              if ( *v43 != 95 )
                goto LABEL_29;
              *(_DWORD *)(v3 + 12) = v43 + 1;
              v44 = sub_C4568(v3);
              v11 = sub_C3918(v3, 45, (int)v63, v44);
              v64 = v11;
              goto LABEL_16;
            default:
              return 0;
          }
        }
        return 0;
      case 70:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        if ( v1[1] == 89 )
          *(_DWORD *)(a1 + 12) = v1 + 2;
        v17 = sub_C4D34(a1, 1);
        v18 = sub_C3AC4(v3, (int)v17);
        v19 = *(_BYTE **)(v3 + 12);
        v20 = v18;
        v11 = 0;
        if ( *v19 != 69 )
          goto LABEL_29;
        v11 = v20;
        *(_DWORD *)(v3 + 12) = v19 + 1;
        v64 = v20;
        goto LABEL_16;
      case 71:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v21 = sub_C4568(a1);
        v11 = sub_C3918(v3, 38, v21, 0);
        v64 = v11;
        goto LABEL_16;
      case 77:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v22 = sub_C4568(a1);
        v23 = (int *)sub_C39EC(v3, &v64, 1);
        if ( !v23 )
          goto LABEL_28;
        v24 = (int *)sub_C4568(v3);
        *v23 = (int)v24;
        if ( !v24 )
          goto LABEL_28;
        if ( v23 == (int *)&v64 )
          goto LABEL_47;
        v25 = *v24;
        if ( (unsigned int)(*v24 - 31) <= 1 )
        {
          v62 = (int *)v24[1];
          v24[1] = (int)v64;
          v64 = (_DWORD *)*v23;
          v25 = *v62;
          *v23 = (int)v62;
        }
        if ( v25 == 41 )
          goto LABEL_47;
        if ( !v64 )
          goto LABEL_28;
        v26 = *(_DWORD *)(v3 + 32);
        if ( v26 >= *(_DWORD *)(v3 + 36) )
          goto LABEL_28;
        *(_DWORD *)(4 * v26 + *(_DWORD *)(v3 + 28)) = v64;
        *(_DWORD *)(v3 + 32) = v26 + 1;
LABEL_47:
        v11 = sub_C3918(v3, 43, v22, (int)v64);
        v64 = v11;
        goto LABEL_16;
      case 79:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v27 = sub_C4568(a1);
        v11 = sub_C3918(v3, 36, v27, 0);
        v64 = v11;
        goto LABEL_16;
      case 80:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v28 = sub_C4568(a1);
        v11 = sub_C3918(v3, 34, v28, 0);
        v64 = v11;
        goto LABEL_16;
      case 82:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v29 = sub_C4568(a1);
        v11 = sub_C3918(v3, 35, v29, 0);
        v64 = v11;
        goto LABEL_16;
      case 83:
        v30 = v1[1];
        if ( ((v30 - 48) & 0xFFu) <= 9 || v30 == 95 || ((v30 - 65) & 0xFFu) <= 0x19 )
        {
          v31 = sub_C3BB0((_DWORD *)a1, 0);
          v32 = *(_BYTE **)(v3 + 12);
          v64 = v31;
          v4 = v31;
          if ( *v32 != 73 )
            return v4;
LABEL_56:
          v33 = sub_C41A4((_DWORD *)v3);
          v11 = sub_C3918(v3, 4, (int)v4, (int)v33);
          v64 = v11;
          goto LABEL_16;
        }
        v11 = sub_C4260((_DWORD *)a1);
        v4 = v11;
        v64 = v11;
        if ( !v11 )
          return 0;
        if ( *v11 != 24 )
          goto LABEL_17;
        return v4;
      case 84:
        v11 = sub_C3E30(a1);
        v34 = *(_BYTE **)(v3 + 12);
        v64 = v11;
        if ( *v34 != 73 )
          goto LABEL_16;
        if ( !v11 )
          return 0;
        v35 = *(_DWORD *)(v3 + 32);
        if ( v35 >= *(_DWORD *)(v3 + 36) )
          return 0;
        *(_DWORD *)(4 * v35 + *(_DWORD *)(v3 + 28)) = v11;
        *(_DWORD *)(v3 + 32) = v35 + 1;
        v4 = v64;
        goto LABEL_56;
      case 85:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v64 = sub_C3E98(a1);
        v36 = sub_C4568(v3);
        v11 = sub_C3918(v3, 33, v36, (int)v64);
        v64 = v11;
        goto LABEL_16;
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 108:
      case 109:
      case 110:
      case 111:
      case 115:
      case 116:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        v37 = &(&off_EFAB4)[5 * (v2 - 97)];
        v38 = *(_DWORD *)(a1 + 20);
        if ( v38 < *(_DWORD *)(a1 + 24) )
        {
          v4 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 12 * v38);
          *(_DWORD *)(a1 + 20) = v38 + 1;
          if ( v4 )
          {
            *v4 = 39;
            v4[1] = v37;
          }
          else
          {
            v37 = (char **)("_ZN22AcquireChannelPlayInfoC2EP11CurlWrapperP13TaskSchedulerP22ChannelPlayInfoManagerPFvP8Da"
                            "taUnitEiP15FifoDataManager"
                          + 69);
          }
        }
        else
        {
          v37 = (char **)("_ZN22AcquireChannelPlayInfoC2EP11CurlWrapperP13TaskSchedulerP22ChannelPlayInfoManagerPFvP8Data"
                          "UnitEiP15FifoDataManager"
                        + 69);
          v4 = 0;
        }
        *(_DWORD *)(a1 + 48) += v37[1];
        *(_DWORD *)(a1 + 12) = v1 + 1;
        return v4;
      case 117:
        *(_DWORD *)(a1 + 12) = v1 + 1;
        v10 = sub_C3E98(a1);
        v11 = sub_C3918(v3, 40, (int)v10, 0);
        v64 = v11;
        goto LABEL_16;
      default:
        return 0;
    }
  }
  v6 = sub_C39EC(a1, &v64, 0);
  if ( v6 )
  {
    v7 = (int *)sub_C4568(v3);
    *v6 = v7;
    if ( v7 )
    {
      if ( (unsigned int)(*v7 - 31) <= 1 )
      {
        v9 = (int *)v7[1];
        v7[1] = (int)v64;
        v64 = *v6;
        *v6 = v9;
      }
      if ( v64 )
      {
        v8 = *(_DWORD *)(v3 + 32);
        if ( v8 < *(_DWORD *)(v3 + 36) )
        {
          *(_DWORD *)(4 * v8 + *(_DWORD *)(v3 + 28)) = v64;
          *(_DWORD *)(v3 + 32) = v8 + 1;
          return v64;
        }
      }
    }
  }
  return 0;
}
// EFAB4: using guessed type char *off_EFAB4;
// EFCBC: using guessed type char *;
// EFCD0: using guessed type char *;
// EFCE4: using guessed type char *;
// EFCF8: using guessed type char *;
// EFD0C: using guessed type char *;
// EFD20: using guessed type char *;
// EFD34: using guessed type char *;

//----- (000C4CA4) --------------------------------------------------------
int __fastcall sub_C4CA4(int a1)
{
  unsigned __int8 *v1; // r2
  int v2; // r3
  int v3; // r4
  int *v4; // r5
  _DWORD *v5; // r2
  _DWORD *v6; // r0
  int result; // r0
  _DWORD *v8; // r2
  int v9; // r2
  int v10; // [sp+4h] [bp-14h]

  v1 = *(unsigned __int8 **)(a1 + 12);
  v10 = 0;
  v2 = *v1;
  v3 = a1;
  if ( !*v1 || v2 == 69 || v2 == 46 )
    return 0;
  v4 = &v10;
  do
  {
    if ( v2 == 79 )
    {
      if ( v1[1] == 69 )
        break;
    }
    else if ( v2 == 82 && v1[1] == 69 )
    {
      break;
    }
    v5 = sub_C4568(v3);
    if ( !v5 )
      return 0;
    v6 = sub_C3918(v3, 46, (int)v5, 0);
    *v4 = (int)v6;
    if ( !v6 )
      return 0;
    v1 = *(unsigned __int8 **)(v3 + 12);
    v2 = *v1;
    v4 = v6 + 2;
  }
  while ( *v1 && v2 != 69 && v2 != 46 );
  result = v10;
  if ( !v10 )
    return 0;
  if ( !*(_DWORD *)(v10 + 8) )
  {
    v8 = *(_DWORD **)(v10 + 4);
    if ( *v8 == 39 )
    {
      v9 = v8[1];
      if ( *(_DWORD *)(v9 + 16) == 9 )
      {
        *(_DWORD *)(v3 + 48) -= *(_DWORD *)(v9 + 4);
        *(_DWORD *)(result + 4) = 0;
      }
    }
  }
  return result;
}

//----- (000C4D34) --------------------------------------------------------
_DWORD *__fastcall sub_C4D34(int a1, int a2)
{
  _BYTE *v2; // r3
  int v3; // r4
  _DWORD *v4; // r5
  int v5; // r3

  v2 = *(_BYTE **)(a1 + 12);
  v3 = a1;
  if ( *v2 == 74 )
  {
    *(_DWORD *)(a1 + 12) = v2 + 1;
LABEL_7:
    v4 = sub_C4568(a1);
    if ( !v4 )
      return 0;
    goto LABEL_3;
  }
  v4 = 0;
  if ( a2 )
    goto LABEL_7;
LABEL_3:
  v5 = sub_C4CA4(v3);
  if ( v5 )
    return sub_C3918(v3, 41, (int)v4, v5);
  return 0;
}

//----- (000C4D70) --------------------------------------------------------
_DWORD *__fastcall sub_C4D70(int a1, int a2)
{
  unsigned __int8 *v2; // r3
  int v3; // r2
  int v4; // r5
  int v5; // r6
  _DWORD *result; // r0
  _DWORD *v7; // r4
  _DWORD *v8; // r2
  int v9; // r1
  _DWORD *v10; // r0
  int v11; // r3
  _DWORD *i; // r3
  int v13; // r1
  int v14; // r2
  _DWORD *v15; // r3
  int v16; // r0
  _BYTE *v17; // r3
  _BYTE *v18; // r6
  int v19; // r7
  _DWORD *v20; // r8
  int v21; // r4
  _DWORD *v22; // r3
  _DWORD *v23; // r0
  _DWORD *v24; // r4
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r0
  _DWORD *v34; // r0
  _DWORD *v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *v38; // r0
  _DWORD *v39; // r4
  _BYTE *v40; // r2
  _DWORD *v41; // r0
  int v42; // r3
  signed int v43; // r1
  int v44; // r2
  _DWORD *v45; // r0

  v2 = *(unsigned __int8 **)(a1 + 12);
  v3 = *v2;
  v4 = a1;
  v5 = a2;
  if ( v3 == 84 || v3 == 71 )
  {
    v13 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 48) += 20;
    v14 = *v2;
    if ( v14 == 84 )
    {
      *(_DWORD *)(a1 + 12) = v2 + 1;
      if ( v2[1] )
      {
        *(_DWORD *)(a1 + 12) = v2 + 2;
        switch ( v2[1] )
        {
          case 0x43u:
            v39 = sub_C4568(a1);
            if ( sub_C3D7C((unsigned __int8 **)(v4 + 12)) < 0 )
              return 0;
            v40 = *(_BYTE **)(v4 + 12);
            if ( *v40 != 95 )
              return 0;
            *(_DWORD *)(v4 + 12) = v40 + 1;
            v41 = sub_C4568(v4);
            *(_DWORD *)(v4 + 48) += 5;
            result = sub_C3918(v4, 11, (int)v41, (int)v39);
            break;
          case 0x46u:
            v38 = sub_C4568(a1);
            result = sub_C3918(v4, 14, (int)v38, 0);
            break;
          case 0x48u:
            v37 = sub_C4260((_DWORD *)a1);
            result = sub_C3918(v4, 20, (int)v37, 0);
            break;
          case 0x49u:
            v36 = sub_C4568(a1);
            result = sub_C3918(v4, 12, (int)v36, 0);
            break;
          case 0x4Au:
            v35 = sub_C4568(a1);
            result = sub_C3918(v4, 18, (int)v35, 0);
            break;
          case 0x53u:
            v34 = sub_C4568(a1);
            result = sub_C3918(v4, 13, (int)v34, 0);
            break;
          case 0x54u:
            *(_DWORD *)(a1 + 48) = v13 + 10;
            v33 = sub_C4568(a1);
            result = sub_C3918(v4, 10, (int)v33, 0);
            break;
          case 0x56u:
            *(_DWORD *)(a1 + 48) = v13 + 15;
            v32 = sub_C4568(a1);
            result = sub_C3918(v4, 9, (int)v32, 0);
            break;
          case 0x57u:
            v30 = sub_C4260((_DWORD *)a1);
            result = sub_C3918(v4, 21, (int)v30, 0);
            break;
          case 0x63u:
            if ( !sub_C3F24(a1, 0) || !sub_C3F24(v4, 0) )
              return 0;
            v29 = sub_C4D70(v4, 0);
            result = sub_C3918(v4, 17, (int)v29, 0);
            break;
          case 0x68u:
            if ( !sub_C3F24(a1, 104) )
              return 0;
            v31 = sub_C4D70(v4, 0);
            result = sub_C3918(v4, 15, (int)v31, 0);
            break;
          case 0x76u:
            if ( !sub_C3F24(a1, 118) )
              return 0;
            v28 = sub_C4D70(v4, 0);
            result = sub_C3918(v4, 16, (int)v28, 0);
            break;
          default:
            return 0;
        }
        return result;
      }
    }
    else if ( v14 == 71 )
    {
      *(_DWORD *)(a1 + 12) = v2 + 1;
      if ( v2[1] )
      {
        *(_DWORD *)(a1 + 12) = v2 + 2;
        switch ( v2[1] )
        {
          case 0x41u:
            v26 = sub_C4D70(a1, 0);
            return sub_C3918(v4, 23, (int)v26, 0);
          case 0x52u:
            v24 = sub_C4260((_DWORD *)a1);
            v25 = sub_C3DD0(v4);
            return sub_C3918(v4, 22, (int)v24, (int)v25);
          case 0x54u:
            if ( v2[2] && (*(_DWORD *)(a1 + 12) = v2 + 3, v2[2] == 110) )
            {
              v27 = sub_C4D70(a1, 0);
              result = sub_C3918(v4, 72, (int)v27, 0);
            }
            else
            {
              v45 = sub_C4D70(a1, 0);
              result = sub_C3918(v4, 71, (int)v45, 0);
            }
            return result;
          case 0x56u:
            v23 = sub_C4260((_DWORD *)a1);
            return sub_C3918(v4, 19, (int)v23, 0);
          case 0x72u:
            v16 = sub_C3D7C((unsigned __int8 **)(a1 + 12));
            if ( v16 <= 1 )
              return 0;
            v17 = *(_BYTE **)(v4 + 12);
            if ( !*v17 )
              return 0;
            v18 = v17 + 1;
            *(_DWORD *)(v4 + 12) = v17 + 1;
            if ( *v17 != 95 )
              return 0;
            v19 = v16 - 1;
            v20 = 0;
            break;
          default:
            return 0;
        }
        while ( *v18 )
        {
          if ( *v18 == 36 )
          {
            v42 = (unsigned __int8)v18[1];
            switch ( v42 )
            {
              case 83:
                v43 = 47;
                break;
              case 95:
                v43 = 46;
                break;
              case 36:
                v43 = 36;
                break;
              default:
                return 0;
            }
            v44 = *(_DWORD *)(v4 + 20);
            if ( v44 >= *(_DWORD *)(v4 + 24)
              || (v22 = (_DWORD *)(*(_DWORD *)(v4 + 16) + 12 * v44), *(_DWORD *)(v4 + 20) = v44 + 1, !v22) )
            {
              *(_DWORD *)(v4 + 12) += 2;
              return 0;
            }
            v22[1] = v43;
            v18 = (_BYTE *)(*(_DWORD *)(v4 + 12) + 2);
            *v22 = 63;
            v19 -= 2;
            *(_DWORD *)(v4 + 12) = v18;
          }
          else
          {
            v21 = 0;
            do
            {
              if ( !v18[v21] )
                break;
              if ( v18[v21] == 36 )
                break;
              ++v21;
            }
            while ( v21 < v19 );
            v19 -= v21;
            v22 = sub_C39B4((_DWORD *)v4, (unsigned int)v18, v21);
            v18 = (_BYTE *)(*(_DWORD *)(v4 + 12) + v21);
            *(_DWORD *)(v4 + 12) = v18;
            if ( !v22 )
              return 0;
          }
          if ( v20 )
          {
            v20 = sub_C3918(v4, 62, (int)v20, (int)v22);
            if ( !v20 )
              return 0;
          }
          else
          {
            v20 = v22;
          }
          if ( v19 <= 0 )
            return sub_C3918(v4, 61, (int)v20, 0);
        }
      }
    }
    return 0;
  }
  result = sub_C4260((_DWORD *)a1);
  v7 = result;
  if ( result && v5 && !(*(_DWORD *)(v4 + 8) & 1) )
  {
    v11 = *result;
    if ( (unsigned int)(*result - 28) <= 4 )
    {
      do
      {
        v7 = (_DWORD *)v7[1];
        v11 = *v7;
      }
      while ( (unsigned int)(*v7 - 28) <= 4 );
    }
    result = v7;
    if ( v11 == 2 )
    {
      for ( i = (_DWORD *)v7[2]; (unsigned int)(*i - 28) <= 4; i = (_DWORD *)i[1] )
        ;
      v7[2] = i;
      result = v7;
    }
  }
  else if ( result && **(_BYTE **)(v4 + 12) && **(_BYTE **)(v4 + 12) != 69 )
  {
    v8 = result;
    while ( *v8 != 4 )
    {
      if ( *v8 >= 4u && (unsigned int)(*v8 - 28) <= 4 )
      {
        v8 = (_DWORD *)v8[1];
        if ( v8 )
          continue;
      }
LABEL_12:
      v9 = 0;
      goto LABEL_13;
    }
    v15 = (_DWORD *)v8[1];
    if ( v15 )
    {
      while ( 2 )
      {
        switch ( *v15 )
        {
          case 1:
          case 2:
            v15 = (_DWORD *)v15[2];
            if ( v15 )
              continue;
            v9 = 1;
            goto LABEL_13;
          case 7:
          case 8:
          case 0x33:
            goto LABEL_12;
          default:
            goto def_C4F3C;
        }
      }
    }
def_C4F3C:
    v9 = 1;
LABEL_13:
    v10 = sub_C4D34(v4, v9);
    result = sub_C3918(v4, 3, (int)v7, (int)v10);
  }
  return result;
}

//----- (000C5274) --------------------------------------------------------
_DWORD *__fastcall sub_C5274(_DWORD *a1)
{
  unsigned __int8 *v1; // r3
  _DWORD *v2; // r7
  unsigned int v3; // r0
  unsigned int v4; // r8
  _DWORD *v5; // r0
  int v6; // r3
  _DWORD *v7; // r2
  _DWORD *result; // r0
  int v9; // r4
  int v10; // r3
  int v11; // r2
  char **v12; // r6
  unsigned int v13; // r1
  unsigned int v14; // r1
  _DWORD *v15; // r0
  int v16; // r2
  _DWORD *v17; // r3

  v1 = (unsigned __int8 *)a1[3];
  v2 = a1;
  if ( !*v1 )
  {
    v3 = 0;
    v4 = 0;
    goto LABEL_11;
  }
  a1[3] = v1 + 1;
  v3 = *v1;
  v4 = 0;
  if ( v1[1] )
  {
    v2[3] = v1 + 2;
    v4 = v1[1];
  }
  if ( v3 != 118 )
  {
    if ( v4 == 118 && v3 == 99 )
    {
      v15 = sub_C4568((int)v2);
      return sub_C3918((int)v2, 51, (int)v15, 0);
    }
    goto LABEL_11;
  }
  if ( ((v4 - 48) & 0xFF) > 9 )
  {
LABEL_11:
    v9 = 61;
    v10 = 0;
    while ( 1 )
    {
      v11 = (v9 - v10) / 2 + v10;
      v12 = &off_EFD48[4 * v11];
      v13 = (unsigned __int8)**v12;
      if ( v3 == v13 )
      {
        v14 = (unsigned __int8)(*v12)[1];
        if ( v4 == v14 )
        {
          v16 = v2[5];
          result = 0;
          if ( v16 < v2[6] )
          {
            v17 = (_DWORD *)(v2[4] + 12 * v16);
            v2[5] = v16 + 1;
            if ( v17 )
            {
              *v17 = 49;
              v17[1] = v12;
              result = v17;
            }
          }
          return result;
        }
        if ( v14 <= v4 )
        {
LABEL_20:
          v10 = v11 + 1;
          goto LABEL_15;
        }
      }
      else if ( v13 <= v3 )
      {
        goto LABEL_20;
      }
      v9 = (v9 - v10) / 2 + v10;
LABEL_15:
      if ( v10 == v9 )
        return 0;
    }
  }
  v5 = sub_C3E98((int)v2);
  v6 = v2[5];
  if ( v6 >= v2[6] )
    return 0;
  v7 = (_DWORD *)(v2[4] + 12 * v6);
  v2[5] = v6 + 1;
  if ( !v7 || !v5 )
    return 0;
  v7[2] = v5;
  *v7 = 50;
  v7[1] = v4 - 48;
  return v7;
}
// EFD48: using guessed type char *off_EFD48[2];

//----- (000C536C) --------------------------------------------------------
_DWORD *__fastcall sub_C536C(_DWORD *a1)
{
  unsigned __int8 *v1; // r2
  int v2; // r3
  _DWORD *v3; // r4
  int v4; // r3
  _BYTE *v5; // r3
  int v6; // r1
  _DWORD *v7; // r5
  _DWORD *v9; // r0
  int v10; // r1
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  int v14; // r0
  int v15; // r6
  int v16; // r0
  int v17; // r3
  int v18; // r3
  _DWORD *v19; // r6
  _DWORD *v20; // r0
  int v21; // r3
  const char *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  int v25; // r0
  int v26; // r3
  signed int v27; // r0
  int v28; // r1
  int v29; // r5
  signed int v30; // r0
  int v31; // r1
  int v32; // r5

  v1 = (unsigned __int8 *)a1[3];
  v2 = *v1;
  v3 = a1;
  if ( ((v2 - 48) & 0xFFu) <= 9 )
  {
    v9 = sub_C3E98((int)a1);
    v5 = (_BYTE *)v3[3];
    v10 = (unsigned __int8)*v5;
    v7 = v9;
    goto LABEL_15;
  }
  if ( ((v2 - 97) & 0xFFu) <= 0x19 )
  {
    v13 = sub_C5274(a1);
    v7 = v13;
    if ( v13 )
    {
      if ( *v13 == 49 )
      {
        v21 = v13[1];
        v22 = *(const char **)v21;
        v3[12] += *(_DWORD *)(v21 + 8) + 7;
        if ( !strcmp(v22, "li") )
        {
          v23 = sub_C3E98((int)v3);
          v24 = sub_C3918((int)v3, 53, (int)v7, (int)v23);
          v5 = (_BYTE *)v3[3];
          v10 = (unsigned __int8)*v5;
          v7 = v24;
          goto LABEL_15;
        }
      }
    }
LABEL_20:
    v5 = (_BYTE *)v3[3];
    v10 = (unsigned __int8)*v5;
    goto LABEL_15;
  }
  if ( ((v2 - 67) & 0xFFu) <= 1 )
  {
    v19 = (_DWORD *)a1[11];
    if ( v19 )
    {
      if ( *v19 )
      {
        v10 = *v1;
        if ( *v19 == 24 )
        {
          a1[12] += v19[2];
          v10 = *v1;
        }
      }
      else
      {
        a1[12] += v19[2];
        v10 = *v1;
      }
    }
    else
    {
      v10 = *v1;
    }
    if ( v10 == 67 )
    {
      switch ( v1[1] )
      {
        case 0x31u:
          v30 = 1;
          goto LABEL_61;
        case 0x32u:
          v30 = 2;
          goto LABEL_61;
        case 0x33u:
          v30 = 3;
          goto LABEL_61;
        case 0x35u:
          v30 = 4;
LABEL_61:
          v31 = v3[5];
          v32 = v3[6];
          v5 = v1 + 2;
          v3[3] = v1 + 2;
          if ( v31 >= v32 )
            goto LABEL_68;
          v7 = (_DWORD *)(v3[4] + 12 * v31);
          v3[5] = v31 + 1;
          if ( !v7 || !v19 )
            goto LABEL_68;
          *v7 = 7;
          v7[1] = v30;
          v7[2] = v19;
          v10 = v1[2];
          goto LABEL_15;
        default:
def_C5582:
          v7 = 0;
          break;
      }
      return v7;
    }
    if ( v10 == 68 )
    {
      switch ( v1[1] )
      {
        case 0x30u:
          v27 = 1;
          break;
        case 0x31u:
          v27 = 2;
          break;
        case 0x32u:
          v27 = 3;
          break;
        case 0x35u:
          v27 = 4;
          break;
        default:
          goto def_C5582;
      }
      v28 = v3[5];
      v29 = v3[6];
      v5 = v1 + 2;
      v3[3] = v1 + 2;
      if ( v28 < v29 && (v7 = (_DWORD *)(v3[4] + 12 * v28), v3[5] = v28 + 1, v7) && v19 )
      {
        *v7 = 8;
        v7[1] = v27;
        v7[2] = v19;
        v10 = v1[2];
      }
      else
      {
LABEL_68:
        v7 = 0;
        v10 = v1[2];
      }
    }
    else
    {
      v5 = v1;
      v7 = 0;
    }
LABEL_15:
    if ( v10 == 66 )
    {
      do
      {
LABEL_16:
        v3[3] = v5 + 1;
        v11 = sub_C3E98((int)v3);
        v12 = sub_C3918((int)v3, 74, (int)v7, (int)v11);
        v5 = (_BYTE *)v3[3];
        v7 = v12;
      }
      while ( *v5 == 66 );
    }
    return v7;
  }
  if ( v2 == 76 )
  {
    a1[3] = v1 + 1;
    v20 = sub_C3E98((int)a1);
    v7 = v20;
    if ( !v20 || !sub_C3E78((int)v3) )
      return 0;
    goto LABEL_20;
  }
  if ( v2 == 85 )
  {
    v4 = v1[1];
    if ( v4 == 108 )
    {
      v5 = v1 + 1;
      a1[3] = v1 + 1;
      v6 = v1[1];
      if ( v6 == 108 )
      {
        a1[3] = v1 + 2;
        v14 = sub_C4CA4((int)a1);
        v5 = (_BYTE *)v3[3];
        v6 = (unsigned __int8)*v5;
        v15 = v14;
        if ( v14 )
        {
          if ( v6 == 69 )
          {
            v3[3] = v5 + 1;
            v16 = sub_C3E00((int)v3);
            if ( v16 < 0 )
              goto LABEL_48;
            v17 = v3[5];
            if ( v17 >= v3[6] )
              goto LABEL_48;
            v7 = (_DWORD *)(v3[4] + 12 * v17);
            v3[5] = v17 + 1;
            if ( !v7 )
              goto LABEL_48;
            v7[1] = v15;
            v7[2] = v16;
            *v7 = 68;
            v18 = v3[8];
            if ( v18 >= v3[9] )
              goto LABEL_48;
LABEL_28:
            *(_DWORD *)(4 * v18 + v3[7]) = v7;
            v3[8] = v18 + 1;
            goto LABEL_20;
          }
        }
      }
LABEL_11:
      v7 = 0;
      if ( v6 == 66 )
        goto LABEL_16;
      return v7;
    }
    if ( v4 == 116 )
    {
      v5 = v1 + 1;
      a1[3] = v1 + 1;
      v6 = v1[1];
      if ( v6 == 116 )
      {
        a1[3] = v1 + 2;
        v25 = sub_C3E00((int)a1);
        if ( v25 < 0
          || (v26 = v3[5], v26 >= v3[6])
          || (v7 = (_DWORD *)(v3[4] + 12 * v26), v3[5] = v26 + 1, !v7)
          || (v7[1] = v25, *v7 = 70, v18 = v3[8], v18 >= v3[9]) )
        {
LABEL_48:
          v5 = (_BYTE *)v3[3];
          v7 = 0;
          v10 = (unsigned __int8)*v5;
          goto LABEL_15;
        }
        goto LABEL_28;
      }
      goto LABEL_11;
    }
  }
  return 0;
}

//----- (000C55E4) --------------------------------------------------------
_DWORD *__fastcall sub_C55E4(_DWORD *a1)
{
  unsigned __int8 *v1; // r1
  int v2; // r3
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  int *v6; // r0
  int v7; // r6
  int v8; // r7
  signed int v9; // r5
  _BYTE *v10; // r3
  int v11; // r0
  _DWORD *v12; // r0
  int v13; // r2
  _DWORD *v14; // r3
  int v15; // r3
  _DWORD *v16; // r0
  const char **v17; // r5
  const char *v18; // r0
  int v19; // r5
  _DWORD *v20; // r0
  _DWORD *v21; // r5
  unsigned __int8 *v22; // r0
  const char *v23; // r8
  _DWORD *v24; // r0
  _DWORD *v25; // r5
  _DWORD *v26; // r6
  int v27; // r0
  unsigned __int8 *v28; // r3
  _DWORD *v29; // r7
  _DWORD *v30; // r0
  int v31; // r3
  _DWORD *v32; // r5
  _DWORD *v33; // r0
  unsigned __int8 *v34; // r1
  int v35; // r3
  _DWORD *v36; // r7
  _DWORD *v37; // r3
  _DWORD *v38; // r0
  _DWORD *v39; // r0
  _DWORD *v40; // r3
  _DWORD *v41; // r0
  int v42; // r3
  _DWORD *v43; // r0
  _DWORD *v44; // r0
  _DWORD *v45; // r5
  _DWORD *v46; // r0
  int v47; // r3
  _BYTE *v48; // r3

  v1 = (unsigned __int8 *)a1[3];
  v2 = *v1;
  v3 = a1;
  switch ( v2 )
  {
    case 76:
      return sub_C40DC(a1);
    case 84:
      return sub_C3E30((int)a1);
    case 115:
      v15 = v1[1];
      if ( v15 == 114 )
      {
        a1[3] = v1 + 2;
        v25 = sub_C4568((int)a1);
        v26 = sub_C536C(v3);
        if ( *(_BYTE *)v3[3] != 73 )
          return sub_C3918((int)v3, 1, (int)v25, (int)v26);
        v43 = sub_C41A4(v3);
        v44 = sub_C3918((int)v3, 4, (int)v26, (int)v43);
        return sub_C3918((int)v3, 1, (int)v25, (int)v44);
      }
      if ( v15 == 112 )
      {
        a1[3] = v1 + 2;
        v16 = sub_C55E4(a1);
        return sub_C3918((int)v3, 73, (int)v16, 0);
      }
      goto LABEL_15;
    case 102:
      if ( v1[1] != 112 )
        goto LABEL_15;
      a1[3] = v1 + 2;
      if ( v1[2] == 84 )
      {
        a1[3] = v1 + 3;
        v27 = 0;
      }
      else
      {
        v27 = sub_C3E00((int)a1) + 1;
        if ( !v27 )
          return 0;
      }
      v13 = v3[5];
      if ( v13 >= v3[6] )
        return 0;
      v14 = (_DWORD *)(v3[4] + 12 * v13);
      v3[5] = v13 + 1;
      v21 = 0;
      if ( v14 )
      {
        *v14 = 6;
        v14[1] = v27;
        v21 = v14;
      }
      return v21;
  }
  if ( ((v2 - 48) & 0xFFu) <= 9 )
    goto LABEL_8;
  if ( v2 == 111 )
  {
    if ( v1[1] == 110 )
    {
      a1[3] = v1 + 2;
LABEL_8:
      v4 = sub_C536C(a1);
      if ( v4 )
      {
        v21 = v4;
        if ( *(_BYTE *)v3[3] == 73 )
        {
          v24 = sub_C41A4(v3);
          v21 = sub_C3918((int)v3, 4, (int)v21, (int)v24);
        }
        return v21;
      }
      return 0;
    }
LABEL_15:
    v6 = sub_C5274(a1);
    v7 = (int)v6;
    if ( !v6 )
      return 0;
    v8 = *v6;
    if ( *v6 == 49 )
    {
      v17 = (const char **)v6[1];
      v23 = *v17;
      v18 = *v17;
      v3[12] += v17[2] - 2;
      if ( strcmp(v18, "st") )
      {
        v22 = (unsigned __int8 *)v17[3];
        goto LABEL_41;
      }
      v12 = sub_C4568((int)v3);
    }
    else
    {
      if ( v8 == 50 )
      {
        v22 = (unsigned __int8 *)v6[1];
        v23 = 0;
LABEL_41:
        v21 = 0;
        switch ( (unsigned int)v22 )
        {
          case 0u:
            return sub_C3918((int)v3, 52, v7, 0);
          case 1u:
            v9 = 0;
            if ( v23 )
            {
              v47 = *(unsigned __int8 *)v23;
              if ( v47 == 109 || v47 == 112 )
              {
                v9 = 0;
                if ( *((unsigned __int8 *)v23 + 1) == v47 )
                {
                  v48 = (_BYTE *)v3[3];
                  v9 = 1;
                  if ( *v48 == 95 )
                  {
                    v3[3] = v48 + 1;
                    v9 = 0;
                  }
                }
              }
            }
            if ( v8 == 51 )
              goto LABEL_21;
            goto LABEL_23;
          case 2u:
            v28 = **(unsigned __int8 ***)(v7 + 4);
            if ( v28[1] != 99 || (v42 = *v28, ((v42 - 99) & 0xFFu) > 1) && ((v42 - 114) & 0xFFu) > 1 )
              v29 = sub_C55E4(v3);
            else
              v29 = sub_C4568((int)v3);
            if ( !strcmp(v23, "cl") )
            {
              v45 = sub_C59EC((int)v3, 69);
            }
            else if ( !strcmp(v23, "dt") || !strcmp(v23, "pt") )
            {
              v45 = sub_C536C(v3);
              if ( *(_BYTE *)v3[3] == 73 )
              {
                v46 = sub_C41A4(v3);
                v45 = sub_C3918((int)v3, 4, (int)v45, (int)v46);
              }
            }
            else
            {
              v45 = sub_C55E4(v3);
            }
            v30 = sub_C3918((int)v3, 55, (int)v29, (int)v45);
            return sub_C3918((int)v3, 54, v7, (int)v30);
          case 3u:
            if ( !strcmp(v23, "qu") )
            {
              v32 = sub_C55E4(v3);
              v36 = sub_C55E4(v3);
              v37 = sub_C55E4(v3);
            }
            else
            {
              if ( *v23 != 110 )
                return 0;
              v31 = *((unsigned __int8 *)v23 + 1);
              if ( v31 != 97 && v31 != 119 )
                return 0;
              v32 = sub_C59EC((int)v3, 95);
              v33 = sub_C4568((int)v3);
              v34 = (unsigned __int8 *)v3[3];
              v35 = *v34;
              v36 = v33;
              if ( v35 == 69 )
              {
                v3[3] = v34 + 1;
                v37 = 0;
              }
              else if ( v35 == 112 )
              {
                if ( v34[1] != 105 )
                  return 0;
                v3[3] = v34 + 2;
                v37 = sub_C59EC((int)v3, 69);
              }
              else
              {
                if ( v35 != 105 || v34[1] != 108 )
                  return 0;
                v37 = sub_C55E4(v3);
              }
            }
            v38 = sub_C3918((int)v3, 58, (int)v36, (int)v37);
            v39 = sub_C3918((int)v3, 57, (int)v32, (int)v38);
            return sub_C3918((int)v3, 56, v7, (int)v39);
          default:
            return v21;
        }
      }
      if ( v8 != 51 )
        return 0;
      v9 = 0;
LABEL_21:
      v10 = (_BYTE *)v3[3];
      if ( *v10 == 95 )
      {
        v3[3] = v10 + 1;
        v40 = sub_C59EC((int)v3, 69);
      }
      else
      {
LABEL_23:
        v40 = sub_C55E4(v3);
      }
      v11 = (int)v3;
      if ( !v9 )
        return sub_C3918(v11, 53, v7, (int)v40);
      v12 = sub_C3918((int)v3, 55, (int)v40, (int)v40);
    }
    v40 = v12;
    v11 = (int)v3;
    return sub_C3918(v11, 53, v7, (int)v40);
  }
  if ( (unsigned int)(v2 - 116) > 0 && v2 != 105 || v1[1] != 108 )
    goto LABEL_15;
  v19 = 0;
  if ( (unsigned int)(v2 - 116) <= 0 )
  {
    v41 = sub_C4568((int)a1);
    v1 = (unsigned __int8 *)v3[3];
    v19 = (int)v41;
  }
  v3[3] = v1 + 2;
  v20 = sub_C59EC((int)v3, 69);
  return sub_C3918((int)v3, 48, v19, (int)v20);
}

//----- (000C59EC) --------------------------------------------------------
_DWORD *__fastcall sub_C59EC(int a1, int a2)
{
  unsigned __int8 *v2; // r3
  _DWORD *v3; // r4
  int v4; // r6
  _DWORD *v5; // r5
  _DWORD *v6; // r0
  unsigned __int8 *v7; // r3
  _DWORD *v8; // r2
  _DWORD *result; // r0
  _DWORD *v10; // [sp+4h] [bp-14h]

  v10 = 0;
  v2 = *(unsigned __int8 **)(a1 + 12);
  v3 = (_DWORD *)a1;
  v4 = a2;
  v5 = &v10;
  if ( *v2 == a2 )
  {
    *(_DWORD *)(a1 + 12) = v2 + 1;
    result = sub_C3918(a1, 46, 0, 0);
  }
  else
  {
    do
    {
      v8 = sub_C55E4(v3);
      if ( !v8 )
        return 0;
      v6 = sub_C3918((int)v3, 46, (int)v8, 0);
      *v5 = v6;
      if ( !v6 )
        return 0;
      v7 = (unsigned __int8 *)v3[3];
      v5 = v6 + 2;
    }
    while ( *v7 != v4 );
    v3[3] = v7 + 1;
    result = v10;
  }
  return result;
}

//----- (000C5A48) --------------------------------------------------------
size_t __fastcall sub_C5A48(int a1, const char *a2)
{
  int v2; // r4
  const char *v3; // r5
  size_t result; // r0
  int v5; // r3
  int v6; // r7
  int v7; // r2
  char v8; // r6

  v2 = a1;
  v3 = a2;
  result = strlen(a2);
  if ( result )
  {
    v5 = *(_DWORD *)(v2 + 256);
    v6 = (int)&v3[result];
    while ( 1 )
    {
      v8 = *v3;
      if ( v5 == 255 )
      {
        *(_BYTE *)(v2 + 255) = 0;
        result = (*(int (__fastcall **)(int, signed int, _DWORD))(v2 + 264))(v2, 255, *(_DWORD *)(v2 + 268));
        ++*(_DWORD *)(v2 + 288);
        v7 = 1;
        v5 = 0;
      }
      else
      {
        v7 = v5 + 1;
      }
      *(_DWORD *)(v2 + 256) = v7;
      *(_BYTE *)(v2 + v5) = v8;
      ++v3;
      *(_BYTE *)(v2 + 260) = v8;
      if ( v3 == (const char *)v6 )
        break;
      v5 = v7;
    }
  }
  return result;
}

//----- (000C5AD0) --------------------------------------------------------
char *__fastcall sub_C5AD0(int a1, int a2, int *a3)
{
  int v3; // r3
  int v4; // r4
  int *v5; // r5
  char *result; // r0
  int v7; // r3
  int v8; // r3
  int v9; // r2
  int **v10; // r2
  int v11; // r5
  int v12; // r3
  int v13; // r7
  int v14; // r8
  int v15; // r2
  char v16; // r6
  int v17; // STD4_4
  int (__fastcall *v18)(int, signed int, int); // STD0_4
  const char *v19; // r6
  int v20; // r3
  int *v21; // r8
  int v22; // r2
  char v23; // r7
  int v24; // STEC_4
  const char *v25; // r6
  int v26; // r3
  int *v27; // r9
  int v28; // r2
  char v29; // r7
  int v30; // STFC_4
  void (__fastcall *v31)(int, signed int, int); // STF8_4
  const char *v32; // r6
  int v33; // r3
  int *v34; // r8
  int v35; // r2
  char v36; // r7
  int v37; // ST104_4
  const char *v38; // r6
  int v39; // r3
  int *v40; // r8
  int v41; // r2
  char v42; // r7
  int v43; // ST10C_4
  const char *v44; // r6
  int v45; // r3
  int *v46; // r8
  int v47; // r2
  char v48; // r7
  int v49; // ST114_4
  const char *v50; // r6
  int v51; // r3
  int *v52; // r8
  int v53; // r2
  char v54; // r7
  int v55; // ST11C_4
  const char *v56; // r6
  int v57; // r3
  int *v58; // r8
  int v59; // r2
  char v60; // r7
  int v61; // ST124_4
  const char *v62; // r6
  int v63; // r3
  int *v64; // r8
  int v65; // r2
  char v66; // r7
  int v67; // ST12C_4
  const char *v68; // r6
  int v69; // r3
  int *v70; // r8
  int v71; // r2
  char v72; // r7
  int v73; // ST134_4
  const char *v74; // r6
  int v75; // r3
  int *v76; // r8
  int v77; // r2
  char v78; // r7
  int v79; // ST13C_4
  const char *v80; // r6
  int v81; // r3
  int *v82; // r8
  int v83; // r2
  char v84; // r7
  int v85; // ST144_4
  const char *v86; // r6
  int v87; // r3
  int *v88; // r8
  int v89; // r2
  char v90; // r7
  int v91; // ST14C_4
  const char *v92; // r6
  int v93; // r3
  int *v94; // r9
  int v95; // r2
  char v96; // r7
  int v97; // ST15C_4
  void (__fastcall *v98)(int, signed int, int); // ST158_4
  const char *v99; // r6
  int v100; // r3
  int *v101; // r8
  int v102; // r2
  char v103; // r7
  int v104; // ST164_4
  const char *v105; // r6
  int v106; // r3
  int *v107; // r8
  int v108; // r2
  char v109; // r7
  int v110; // r3
  int v111; // r6
  _DWORD *v112; // r7
  int v113; // r11
  char *v114; // r2
  int v115; // r12
  char *v116; // r3
  char *v117; // r1
  int *v118; // r8
  int v119; // r2
  char *v120; // r5
  int *v121; // r5
  char *v122; // r8
  int *v123; // r1
  int v124; // r3
  char *v125; // r2
  char *v126; // r3
  int *v127; // r12
  int v128; // r5
  int v129; // r6
  int v130; // r5
  char *v131; // r6
  int v132; // r3
  int v133; // r2
  int v134; // r3
  const char *v135; // r6
  int v136; // r2
  char v137; // r7
  int v138; // ST18C_4
  int v139; // r5
  int v140; // r3
  int v141; // r7
  int v142; // r8
  int v143; // r2
  char v144; // r6
  int v145; // ST19C_4
  int (__fastcall *v146)(int, signed int, int); // ST198_4
  const char *v147; // r6
  int m; // r3
  int v149; // r2
  char v150; // r7
  int v151; // ST0C_4
  void (__fastcall *v152)(int, signed int, int); // ST08_4
  char *v153; // r2
  _DWORD *v154; // r6
  int v155; // r7
  int v156; // r6
  int v157; // r3
  int v158; // r3
  int v159; // r9
  int v160; // r3
  const char *v161; // r5
  int v162; // r2
  char v163; // r6
  int v164; // ST5C_4
  int (__fastcall *v165)(int, signed int, int); // ST58_4
  const char *v166; // r6
  int l; // r3
  int v168; // r2
  char v169; // r7
  int v170; // ST194_4
  void (__fastcall *v171)(int, signed int, int); // ST190_4
  int v172; // r3
  int v173; // r10
  int v174; // r11
  int v175; // r3
  const char *v176; // r5
  int v177; // r2
  char v178; // r6
  int v179; // ST64_4
  int (__fastcall *v180)(int, signed int, int); // ST60_4
  const char *v181; // r6
  int v182; // r3
  int *v183; // r8
  int v184; // r2
  char v185; // r7
  int v186; // STDC_4
  _DWORD *v187; // r7
  _DWORD *v188; // r6
  int v189; // r5
  const char *v190; // r6
  int v191; // r3
  int *v192; // r8
  int v193; // r2
  char v194; // r7
  int v195; // ST84_4
  int v196; // r8
  const char *v197; // r5
  int k; // r3
  int v199; // r2
  char v200; // r6
  int v201; // ST9C_4
  const char *v202; // r6
  int v203; // r3
  int *v204; // r8
  int v205; // r2
  char v206; // r7
  int v207; // ST8C_4
  int v208; // r2
  int v209; // r6
  int v210; // r3
  int v211; // r3
  int v212; // r2
  unsigned int v213; // r1
  const char *v214; // r6
  int v215; // r3
  char v216; // r7
  int v217; // r2
  int v218; // r2
  const char *v219; // r5
  int v220; // r2
  char v221; // r6
  int v222; // STB4_4
  const char *v223; // r6
  int v224; // r3
  int *v225; // r9
  int v226; // r2
  char v227; // r7
  int v228; // ST6C_4
  void (__fastcall *v229)(int, signed int, int); // ST68_4
  char *v230; // r5
  int v231; // r3
  char *v232; // r6
  int v233; // r2
  char v234; // r7
  int v235; // r3
  char v236; // r5
  const char *v237; // r6
  int v238; // r3
  int *v239; // r8
  int v240; // r2
  char v241; // r7
  int v242; // ST74_4
  _DWORD *v243; // r2
  unsigned int v244; // r6
  int v245; // r2
  int v246; // r3
  int v247; // r3
  int v248; // r1
  _DWORD *v249; // r3
  _DWORD *v250; // r1
  int *v251; // r6
  _DWORD *v252; // r8
  int *v253; // r7
  int *v254; // r5
  int *v255; // r3
  int v256; // r8
  int v257; // r5
  int v258; // r2
  int v259; // r3
  int v260; // r7
  int v261; // r8
  int v262; // r2
  char v263; // r6
  int v264; // STCC_4
  int (__fastcall *v265)(int, signed int, int); // STC8_4
  int v266; // r3
  int v267; // r7
  int v268; // r3
  int v269; // r2
  int v270; // r3
  int v271; // r2
  char *v272; // r2
  int v273; // r3
  char *v274; // r8
  unsigned int v275; // r7
  char *v276; // r3
  int v277; // r11
  char *v278; // r2
  int v279; // r4
  int v280; // r6
  char *v281; // r1
  int v282; // r1
  int v283; // r7
  char *j; // r6
  int v285; // r3
  const char *v286; // r6
  int v287; // r3
  int *v288; // r9
  int v289; // r2
  char v290; // r7
  int v291; // ST1C_4
  void (__fastcall *v292)(int, signed int, int); // ST18_4
  const char *v293; // r6
  int v294; // r3
  int *v295; // r8
  int v296; // r2
  char v297; // r7
  int v298; // STE4_4
  const char *v299; // r6
  int v300; // r3
  int *v301; // r8
  int v302; // r2
  char v303; // r7
  int v304; // ST3C_4
  const char *v305; // r6
  int v306; // r3
  int *v307; // r8
  int v308; // r2
  char v309; // r7
  int v310; // ST44_4
  const char *v311; // r6
  int v312; // r3
  int *v313; // r9
  int v314; // r2
  char v315; // r7
  int v316; // ST34_4
  void (__fastcall *v317)(int, signed int, int); // ST30_4
  int v318; // r3
  const char *v319; // r6
  int v320; // r2
  char v321; // r7
  int v322; // STF4_4
  int v323; // r3
  int v324; // r3
  int v325; // r3
  const char *v326; // r6
  int v327; // r2
  char v328; // r7
  int v329; // ST2C_4
  void (__fastcall *v330)(int, signed int, int); // ST28_4
  char *v331; // r5
  int v332; // r3
  char *v333; // r6
  int v334; // r2
  char v335; // r7
  int v336; // ST24_4
  unsigned __int8 *v337; // r5
  unsigned int v338; // r7
  int v339; // r7
  int v340; // r3
  int v341; // r7
  int v342; // r2
  unsigned __int8 v343; // r6
  int v344; // ST94_4
  char *v345; // r5
  int v346; // r3
  char *v347; // r6
  int v348; // r2
  char v349; // r7
  int v350; // ST14_4
  int v351; // r3
  int v352; // r3
  const char *v353; // r6
  int v354; // r2
  char v355; // r7
  int v356; // ST154_4
  int v357; // r8
  int v358; // r7
  _DWORD *v359; // r8
  const char *v360; // r5
  int v361; // r2
  char v362; // r6
  int v363; // STAC_4
  int (__fastcall *v364)(int, signed int, int); // STA8_4
  const char *v365; // r5
  int v366; // r2
  char v367; // r6
  int v368; // ST54_4
  void (__fastcall *v369)(int, signed int, int); // ST50_4
  char *v370; // r5
  int v371; // r3
  char *v372; // r6
  int v373; // r2
  char v374; // r7
  int v375; // ST4C_4
  int v376; // r8
  int v377; // r5
  int v378; // r2
  int v379; // r3
  int v380; // r7
  int v381; // r8
  int v382; // r2
  char v383; // r6
  int v384; // STC4_4
  int (__fastcall *v385)(int, signed int, int); // STC0_4
  int v386; // r2
  unsigned __int8 **v387; // r3
  int v388; // r0
  int v389; // r2
  int v390; // r7
  const char *v391; // r6
  int v392; // r3
  int v393; // r3
  int v394; // r3
  int v395; // r3
  const char *v396; // r6
  int v397; // r3
  int *v398; // r8
  int v399; // r2
  char v400; // r7
  int v401; // r6
  int v402; // r2
  const char *v403; // r7
  int v404; // r0
  int v405; // r3
  int v406; // r3
  int v407; // r3
  int v408; // r3
  int v409; // r3
  int v410; // r2
  int v411; // r2
  int v412; // r1
  int v413; // r1
  int v414; // r1
  int v415; // r1
  unsigned __int8 *v416; // r6
  unsigned int v417; // r7
  int v418; // r3
  int v419; // r2
  int v420; // r5
  unsigned __int8 *v421; // r11
  unsigned int v422; // r2
  int v423; // r3
  int v424; // r3
  int v425; // r1
  int v426; // r2
  int v427; // r1
  int v428; // r1
  const char *v429; // r5
  int i; // r3
  int v431; // r2
  char v432; // r6
  int v433; // ST184_4
  void (__fastcall *v434)(int, signed int, int); // ST180_4
  size_t v435; // r0
  int v436; // r2
  int v437; // r5
  size_t v438; // r6
  int v439; // r3
  char v440; // r7
  int v441; // ST17C_4
  const char *v442; // r5
  int v443; // r2
  char v444; // r6
  int v445; // ST174_4
  void (__fastcall *v446)(int, signed int, int); // ST170_4
  int v447; // r1
  int v448; // r1
  int v449; // r1
  int v450; // r0
  int v451; // r2
  int v452; // r3
  int v453; // r2
  _DWORD *v454; // r7
  int v455; // r3
  int v456; // r2
  int v457; // r2
  int v458; // r3
  int v459; // r3
  int v460; // r2
  int v461; // r1
  int v462; // r1
  int v463; // r1
  int v464; // r3
  int v465; // r2
  int v466; // r2
  int v467; // r3
  char v468; // r5
  int v469; // r2
  int v470; // r2
  int v471; // r3
  int v472; // [sp+1A8h] [bp-88h]
  char *v473; // [sp+1ACh] [bp-84h]
  int v474; // [sp+1ACh] [bp-84h]
  int v475; // [sp+1B0h] [bp-80h]
  int v476; // [sp+1B4h] [bp-7Ch]
  int v477; // [sp+1BCh] [bp-74h]
  int v478; // [sp+1C0h] [bp-70h]
  _DWORD *v479; // [sp+1C4h] [bp-6Ch]
  char s[4]; // [sp+1C8h] [bp-68h]
  int *v481; // [sp+1CCh] [bp-64h]
  int v482; // [sp+1D0h] [bp-60h]
  int v483; // [sp+1D4h] [bp-5Ch]

  v3 = *a3;
  v472 = a2;
  v4 = a1;
  v5 = a3;
  result = (char *)*a3;
  switch ( v3 )
  {
    case 0:
      if ( a2 & 4 )
      {
        v416 = (unsigned __int8 *)a3[1];
        v417 = (unsigned int)&v416[a3[2]];
        if ( (unsigned int)v416 >= v417 )
          return result;
LABEL_593:
        v420 = *v416;
        if ( (signed int)(v417 - (_DWORD)v416) <= 3 )
          goto LABEL_589;
        if ( v420 != 95 )
          goto LABEL_589;
        if ( v416[1] != 95 )
          goto LABEL_589;
        LOBYTE(v420) = 95;
        if ( v416[2] != 85 )
          goto LABEL_589;
        v421 = v416 + 3;
        if ( v417 <= (unsigned int)(v416 + 3) )
          goto LABEL_589;
        v422 = 0;
        while ( 1 )
        {
          v424 = *v421;
          if ( ((v424 - 48) & 0xFFu) <= 9 )
          {
            v423 = *v421 - 48;
          }
          else if ( ((v424 - 65) & 0xFFu) > 5 )
          {
            if ( ((v424 - 97) & 0xFFu) > 5 )
            {
              LOBYTE(v420) = 95;
              if ( v417 > (unsigned int)v421 && v424 == 95 )
              {
                LOBYTE(v420) = *v421;
                if ( v422 <= 0xFF )
                {
                  v468 = v422;
                  if ( *(_DWORD *)(v4 + 256) == 255 )
                  {
                    v469 = *(_DWORD *)(v4 + 268);
                    *(_BYTE *)(v4 + 255) = 0;
                    (*(void (__fastcall **)(int))(v4 + 264))(v4);
                    v470 = *(_DWORD *)(v4 + 288) + 1;
                    *(_DWORD *)(v4 + 256) = 0;
                    *(_DWORD *)(v4 + 288) = v470;
                  }
                  v471 = *(_DWORD *)(v4 + 256);
                  result = (char *)&dword_104;
                  *(_DWORD *)(v4 + 256) = v471 + 1;
                  *(_BYTE *)(v4 + v471) = v468;
                  v416 = v421;
                  *(_BYTE *)(v4 + 260) = v468;
                  goto LABEL_592;
                }
              }
LABEL_589:
              v418 = *(_DWORD *)(v4 + 256);
              if ( v418 == 255 )
              {
                *(_BYTE *)(v4 + 255) = 0;
                (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
                ++*(_DWORD *)(v4 + 288);
                v419 = 1;
                v418 = 0;
              }
              else
              {
                v419 = v418 + 1;
              }
              result = (char *)&dword_100;
              *(_DWORD *)(v4 + 256) = v419;
              *(_BYTE *)(v4 + v418) = v420;
              *(_BYTE *)(v4 + 260) = v420;
LABEL_592:
              if ( v417 <= (unsigned int)++v416 )
                return result;
              goto LABEL_593;
            }
            v423 = v424 - 87;
          }
          else
          {
            v423 = v424 - 55;
          }
          v422 = v423 + 16 * v422;
          if ( ++v421 == (unsigned __int8 *)v417 )
          {
            LOBYTE(v420) = 95;
            goto LABEL_589;
          }
        }
      }
      if ( a3[2] )
      {
        v139 = 0;
        v140 = *(_DWORD *)(v4 + 256);
        v141 = a3[1];
        v142 = a3[2];
        while ( 1 )
        {
          v144 = *(_BYTE *)(v141 + v139);
          if ( v140 == 255 )
          {
            v145 = *(_DWORD *)(v4 + 268);
            v146 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)v146(v4, 255, v145);
            ++*(_DWORD *)(v4 + 288);
            v143 = 1;
            v140 = 0;
          }
          else
          {
            v143 = v140 + 1;
          }
          *(_DWORD *)(v4 + 256) = v143;
          *(_BYTE *)(v4 + v140) = v144;
          ++v139;
          *(_BYTE *)(v4 + 260) = v144;
          if ( v142 == v139 )
            break;
          v140 = v143;
        }
      }
      return result;
    case 1:
    case 2:
      sub_C89F4(v4, a2, a3[1]);
      v134 = *(_DWORD *)(v4 + 256);
      if ( v472 & 4 )
      {
        if ( v134 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          v463 = 1;
          ++*(_DWORD *)(v4 + 288);
          v134 = 0;
        }
        else
        {
          v463 = v134 + 1;
        }
        *(_DWORD *)(v4 + 256) = v463;
        *(_BYTE *)(v4 + v134) = 46;
        *(_BYTE *)(v4 + 260) = 46;
      }
      else
      {
        v135 = "::";
        while ( 1 )
        {
          v137 = *v135;
          if ( v134 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            v138 = *(_DWORD *)(v4 + 268);
            (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
            ++*(_DWORD *)(v4 + 288);
            v136 = 1;
            v134 = 0;
          }
          else
          {
            v136 = v134 + 1;
          }
          *(_DWORD *)(v4 + 256) = v136;
          *(_BYTE *)(v4 + v134) = v137;
          ++v135;
          *(_BYTE *)(v4 + 260) = v137;
          if ( v135 == "" )
            break;
          v134 = v136;
        }
      }
      v359 = (_DWORD *)v5[2];
      if ( *v359 == 69 )
      {
        v429 = "{default arg#";
        for ( i = *(_DWORD *)(v4 + 256); ; i = v431 )
        {
          v432 = *v429;
          if ( i == 255 )
          {
            v433 = *(_DWORD *)(v4 + 268);
            v434 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            v434(v4, 255, v433);
            ++*(_DWORD *)(v4 + 288);
            v431 = 1;
            i = 0;
          }
          else
          {
            v431 = i + 1;
          }
          *(_DWORD *)(v4 + 256) = v431;
          *(_BYTE *)(v4 + i) = v432;
          ++v429;
          *(_BYTE *)(v4 + 260) = v432;
          if ( v429 == "" )
            break;
        }
        sprintf(s, "%ld", v359[2] + 1);
        v435 = strlen(s);
        if ( v435 )
        {
          v436 = *(_DWORD *)(v4 + 256);
          v437 = 0;
          v438 = v435;
          while ( 1 )
          {
            v440 = s[v437];
            if ( v436 == 255 )
            {
              *(_BYTE *)(v4 + 255) = 0;
              v441 = *(_DWORD *)(v4 + 268);
              (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
              ++*(_DWORD *)(v4 + 288);
              v439 = 1;
              v436 = 0;
            }
            else
            {
              v439 = v436 + 1;
            }
            *(_DWORD *)(v4 + 256) = v439;
            *(_BYTE *)(v4 + v436) = v440;
            ++v437;
            *(_BYTE *)(v4 + 260) = v440;
            if ( v437 == v438 )
              break;
            v436 = v439;
          }
        }
        else
        {
          v439 = *(_DWORD *)(v4 + 256);
        }
        v442 = "}::";
        while ( 1 )
        {
          v444 = *v442;
          if ( v439 == 255 )
          {
            v445 = *(_DWORD *)(v4 + 268);
            v446 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            v446(v4, 255, v445);
            ++*(_DWORD *)(v4 + 288);
            v443 = 1;
            v439 = 0;
          }
          else
          {
            v443 = v439 + 1;
          }
          *(_DWORD *)(v4 + 256) = v443;
          *(_BYTE *)(v4 + v439) = v444;
          ++v442;
          *(_BYTE *)(v4 + 260) = v444;
          if ( v442 == "" )
            break;
          v439 = v443;
        }
        v359 = (_DWORD *)v359[1];
      }
      return (char *)sub_C89F4(v4, v472, (int)v359);
    case 3:
      v111 = *(_DWORD *)(v4 + 276);
      *(_DWORD *)(v4 + 276) = 0;
      v112 = (_DWORD *)a3[1];
      v113 = v111;
      if ( !v112 )
        goto LABEL_662;
      v114 = 0;
      v115 = *(_DWORD *)(v4 + 272);
      v116 = s;
      v117 = 0;
      v118 = v5;
      while ( 2 )
      {
        *(_DWORD *)v116 = v114;
        *((_DWORD *)v116 + 2) = 0;
        v119 = *v112;
        *(_DWORD *)(v4 + 276) = v116;
        *((_DWORD *)v116 + 3) = v115;
        result = (char *)(v119 - 28);
        v120 = v116;
        *((_DWORD *)v116 + 1) = v112;
        ++v117;
        if ( (unsigned int)(v119 - 28) <= 4 )
        {
          v112 = (_DWORD *)v112[1];
          if ( v112 )
          {
            v116 += 16;
            if ( v117 != byte_4 )
            {
              v114 = v120;
              continue;
            }
            *(_DWORD *)(v4 + 280) = 1;
          }
          else
          {
LABEL_662:
            *(_DWORD *)(v4 + 280) = 1;
          }
        }
        else
        {
          v121 = v118;
          v122 = v117;
          if ( v119 == 4 )
          {
            v478 = v115;
            *(_DWORD *)(v4 + 272) = &v478;
            v479 = v112;
            goto LABEL_151;
          }
          if ( v119 != 2 )
            goto LABEL_151;
          v123 = (int *)v112[2];
          v124 = *v123;
          if ( *v123 == 69 )
          {
            v123 = (int *)v123[1];
            v124 = *v123;
          }
          if ( (unsigned int)(v124 - 28) > 4 )
          {
LABEL_151:
            result = (char *)sub_C89F4(v4, v472, v121[2]);
            if ( *v112 == 4 )
              *(_DWORD *)(v4 + 272) = v478;
            if ( v122 )
            {
              v130 = (int)(v122 - 1);
              v131 = &s[16 * (_DWORD)(v122 - 1) + 8];
              v132 = *(_DWORD *)v131;
              if ( !*(_DWORD *)v131 )
                goto LABEL_157;
              while ( 1 )
              {
                v131 -= 16;
                if ( !v130 )
                  break;
                v132 = *(_DWORD *)v131;
                --v130;
                if ( !*(_DWORD *)v131 )
                {
LABEL_157:
                  v133 = *(_DWORD *)(v4 + 256);
                  if ( v133 == 255 )
                  {
                    *(_BYTE *)(v4 + 255) = v132;
                    (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
                    ++*(_DWORD *)(v4 + 288);
                    v133 = 0;
                  }
                  *(_DWORD *)(v4 + 256) = v133 + 1;
                  *(_BYTE *)(v4 + v133) = 32;
                  *(_BYTE *)(v4 + 260) = 32;
                  result = sub_C8A14(v4, v472, *((_DWORD **)v131 - 1));
                }
              }
            }
            *(_DWORD *)(v4 + 276) = v113;
            return result;
          }
          if ( v122 != byte_4 )
          {
            v125 = &s[16 * (_DWORD)(v122 - 1)];
            v126 = &s[16 * (_DWORD)v122];
            v473 = v122;
            v475 = v115;
            v127 = v121;
            while ( 1 )
            {
              v128 = *((_DWORD *)v125 + 1);
              v129 = *((_DWORD *)v125 + 2);
              *(_DWORD *)v126 = *(_DWORD *)v125;
              *((_DWORD *)v126 + 1) = v128;
              *((_DWORD *)v126 + 2) = v129;
              *((_DWORD *)v126 + 3) = *((_DWORD *)v125 + 3);
              *(_DWORD *)v126 = v126 - 16;
              *(_DWORD *)(v4 + 276) = v126;
              *((_DWORD *)v125 + 1) = v123;
              *((_DWORD *)v125 + 2) = 0;
              *((_DWORD *)v125 + 3) = v475;
              v123 = (int *)v123[1];
              result = v473++ + 1;
              if ( (unsigned int)(*v123 - 28) > 4 )
                break;
              v125 += 16;
              v126 += 16;
              if ( v473 == byte_4 )
                goto LABEL_685;
            }
            v121 = v127;
            v122 = result;
            goto LABEL_151;
          }
LABEL_685:
          *(_DWORD *)(v4 + 280) = 1;
        }
        return result;
      }
    case 4:
      v155 = *(_DWORD *)(v4 + 276);
      *(_DWORD *)(v4 + 276) = 0;
      v156 = a3[1];
      if ( a2 & 4
        && !*(_DWORD *)v156
        && *(_DWORD *)(v156 + 8) == 6
        && !strncmp(*(const char **)(v156 + 4), "JArray", 6u) )
      {
        sub_C89F4(v4, v472, v5[2]);
        result = (char *)sub_C5A48(v4, "[]");
      }
      else
      {
        sub_C89F4(v4, v472, v156);
        if ( *(_BYTE *)(v4 + 260) == 60 )
        {
          v457 = *(_DWORD *)(v4 + 256);
          if ( v457 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v457 = 0;
          }
          v157 = v457 + 1;
          *(_DWORD *)(v4 + 256) = v457 + 1;
          *(_BYTE *)(v4 + v457) = 32;
          *(_BYTE *)(v4 + 260) = 32;
        }
        else
        {
          v157 = *(_DWORD *)(v4 + 256);
        }
        if ( v157 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          v449 = 1;
          ++*(_DWORD *)(v4 + 288);
          v157 = 0;
        }
        else
        {
          v449 = v157 + 1;
        }
        *(_DWORD *)(v4 + 256) = v449;
        *(_BYTE *)(v4 + v157) = 60;
        *(_BYTE *)(v4 + 260) = 60;
        result = (char *)sub_C89F4(v4, v472, v5[2]);
        if ( *(_BYTE *)(v4 + 260) == 62 )
        {
          v456 = *(_DWORD *)(v4 + 256);
          if ( v456 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v456 = 0;
          }
          v158 = v456 + 1;
          *(_DWORD *)(v4 + 256) = v456 + 1;
          *(_BYTE *)(v4 + v456) = 32;
          *(_BYTE *)(v4 + 260) = 32;
        }
        else
        {
          v158 = *(_DWORD *)(v4 + 256);
        }
        if ( v158 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          v448 = 1;
          ++*(_DWORD *)(v4 + 288);
          v158 = 0;
        }
        else
        {
          v448 = v158 + 1;
        }
        *(_DWORD *)(v4 + 256) = v448;
        *(_BYTE *)(v4 + v158) = 62;
        *(_BYTE *)(v4 + 260) = 62;
      }
      *(_DWORD *)(v4 + 276) = v155;
      return result;
    case 5:
      result = (char *)sub_C3F80(v4, a3 + 1);
      v153 = result;
      if ( !result )
        goto LABEL_554;
      if ( *(_DWORD *)result != 47 )
        goto LABEL_185;
      v395 = *(_DWORD *)(v4 + 284);
      while ( v395 > 0 )
      {
        v153 = (char *)*((_DWORD *)v153 + 2);
        --v395;
        if ( !v153 || *(_DWORD *)v153 != 47 )
          goto LABEL_554;
      }
      if ( !v395 )
      {
        v153 = (char *)*((_DWORD *)v153 + 1);
        if ( v153 )
        {
LABEL_185:
          v154 = *(_DWORD **)(v4 + 272);
          *(_DWORD *)(v4 + 272) = *v154;
          result = (char *)sub_C89F4(v4, v472, (int)v153);
          *(_DWORD *)(v4 + 272) = v154;
          return result;
        }
      }
LABEL_554:
      *(_DWORD *)(v4 + 280) = 1;
      return result;
    case 6:
      v159 = a3[1];
      v160 = *(_DWORD *)(v4 + 256);
      if ( v159 )
      {
        v365 = "{parm#";
        while ( 1 )
        {
          v367 = *v365;
          if ( v160 == 255 )
          {
            v368 = *(_DWORD *)(v4 + 268);
            v369 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            v369(v4, 255, v368);
            ++*(_DWORD *)(v4 + 288);
            v366 = 1;
            v160 = 0;
          }
          else
          {
            v366 = v160 + 1;
          }
          *(_DWORD *)(v4 + 256) = v366;
          *(_BYTE *)(v4 + v160) = v367;
          ++v365;
          *(_BYTE *)(v4 + 260) = v367;
          if ( v365 == "" )
            break;
          v160 = v366;
        }
        sprintf(s, "%ld", v159);
        result = (char *)strlen(s);
        if ( result )
        {
          v370 = 0;
          v371 = *(_DWORD *)(v4 + 256);
          v372 = result;
          while ( 1 )
          {
            result = s;
            v374 = s[(_DWORD)v370];
            if ( v371 == 255 )
            {
              *(_BYTE *)(v4 + 255) = 0;
              v375 = *(_DWORD *)(v4 + 268);
              result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
              ++*(_DWORD *)(v4 + 288);
              v373 = 1;
              v371 = 0;
            }
            else
            {
              v373 = v371 + 1;
            }
            *(_DWORD *)(v4 + 256) = v373;
            *(_BYTE *)(v4 + v371) = v374;
            ++v370;
            *(_BYTE *)(v4 + 260) = v374;
            if ( v370 == v372 )
              break;
            v371 = v373;
          }
        }
        else
        {
          v373 = *(_DWORD *)(v4 + 256);
        }
        if ( v373 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          v462 = 1;
          ++*(_DWORD *)(v4 + 288);
          v373 = 0;
        }
        else
        {
          v462 = v373 + 1;
        }
        *(_DWORD *)(v4 + 256) = v462;
        *(_BYTE *)(v4 + v373) = 125;
        *(_BYTE *)(v4 + 260) = 125;
      }
      else
      {
        v161 = "this";
        while ( 1 )
        {
          v163 = *v161;
          if ( v160 == 255 )
          {
            v164 = *(_DWORD *)(v4 + 268);
            v165 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)v165(v4, 255, v164);
            ++*(_DWORD *)(v4 + 288);
            v162 = 1;
            v160 = 0;
          }
          else
          {
            v162 = v160 + 1;
          }
          *(_DWORD *)(v4 + 256) = v162;
          *(_BYTE *)(v4 + v160) = v163;
          ++v161;
          *(_BYTE *)(v4 + 260) = v163;
          if ( v161 == "" )
            break;
          v160 = v162;
        }
      }
      return result;
    case 7:
      return (char *)sub_C89F4(v4, a2, a3[2]);
    case 8:
      v110 = *(_DWORD *)(v4 + 256);
      if ( v110 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v428 = 1;
        ++*(_DWORD *)(v4 + 288);
        v110 = 0;
      }
      else
      {
        v428 = v110 + 1;
      }
      *(_DWORD *)(v4 + 256) = v428;
      *(_BYTE *)(v4 + v110) = 126;
      *(_BYTE *)(v4 + 260) = 126;
      return (char *)sub_C89F4(v4, v472, v5[2]);
    case 9:
      v105 = "vtable for ";
      v106 = *(_DWORD *)(v4 + 256);
      v107 = a3;
      while ( 1 )
      {
        v109 = *v105;
        if ( v106 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v108 = 1;
          v106 = 0;
        }
        else
        {
          v108 = v106 + 1;
        }
        *(_DWORD *)(v4 + 256) = v108;
        *(_BYTE *)(v4 + v106) = v109;
        ++v105;
        *(_BYTE *)(v4 + 260) = v109;
        if ( v105 == "" )
          break;
        v106 = v108;
      }
      return (char *)sub_C89F4(v4, v472, v107[1]);
    case 10:
      v99 = "VTT for ";
      v100 = *(_DWORD *)(v4 + 256);
      v101 = a3;
      while ( 1 )
      {
        v103 = *v99;
        if ( v100 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v104 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v102 = 1;
          v100 = 0;
        }
        else
        {
          v102 = v100 + 1;
        }
        *(_DWORD *)(v4 + 256) = v102;
        *(_BYTE *)(v4 + v100) = v103;
        ++v99;
        *(_BYTE *)(v4 + 260) = v103;
        if ( v99 == "" )
          break;
        v100 = v102;
      }
      return (char *)sub_C89F4(v4, v472, v101[1]);
    case 11:
      v92 = "construction vtable for ";
      v93 = *(_DWORD *)(v4 + 256);
      v94 = a3;
      while ( 1 )
      {
        v96 = *v92;
        if ( v93 == 255 )
        {
          v97 = *(_DWORD *)(v4 + 268);
          v98 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v98(v4, 255, v97);
          ++*(_DWORD *)(v4 + 288);
          v95 = 1;
          v93 = 0;
        }
        else
        {
          v95 = v93 + 1;
        }
        *(_DWORD *)(v4 + 256) = v95;
        *(_BYTE *)(v4 + v93) = v96;
        ++v92;
        *(_BYTE *)(v4 + 260) = v96;
        if ( v92 == "" )
          break;
        v93 = v95;
      }
      sub_C89F4(v4, v472, v94[1]);
      v352 = *(_DWORD *)(v4 + 256);
      v353 = "-in-";
      while ( 1 )
      {
        v355 = *v353;
        if ( v352 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v356 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v354 = 1;
          v352 = 0;
        }
        else
        {
          v354 = v352 + 1;
        }
        *(_DWORD *)(v4 + 256) = v354;
        *(_BYTE *)(v4 + v352) = v355;
        ++v353;
        *(_BYTE *)(v4 + 260) = v355;
        if ( v353 == "" )
          break;
        v352 = v354;
      }
      return (char *)sub_C89F4(v4, v472, v94[2]);
    case 12:
      v86 = "typeinfo for ";
      v87 = *(_DWORD *)(v4 + 256);
      v88 = a3;
      while ( 1 )
      {
        v90 = *v86;
        if ( v87 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v91 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v89 = 1;
          v87 = 0;
        }
        else
        {
          v89 = v87 + 1;
        }
        *(_DWORD *)(v4 + 256) = v89;
        *(_BYTE *)(v4 + v87) = v90;
        ++v86;
        *(_BYTE *)(v4 + 260) = v90;
        if ( v86 == "" )
          break;
        v87 = v89;
      }
      return (char *)sub_C89F4(v4, v472, v88[1]);
    case 13:
      v80 = "typeinfo name for ";
      v81 = *(_DWORD *)(v4 + 256);
      v82 = a3;
      while ( 1 )
      {
        v84 = *v80;
        if ( v81 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v85 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v83 = 1;
          v81 = 0;
        }
        else
        {
          v83 = v81 + 1;
        }
        *(_DWORD *)(v4 + 256) = v83;
        *(_BYTE *)(v4 + v81) = v84;
        ++v80;
        *(_BYTE *)(v4 + 260) = v84;
        if ( v80 == "" )
          break;
        v81 = v83;
      }
      return (char *)sub_C89F4(v4, v472, v82[1]);
    case 14:
      v74 = "typeinfo fn for ";
      v75 = *(_DWORD *)(v4 + 256);
      v76 = a3;
      while ( 1 )
      {
        v78 = *v74;
        if ( v75 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v79 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v77 = 1;
          v75 = 0;
        }
        else
        {
          v77 = v75 + 1;
        }
        *(_DWORD *)(v4 + 256) = v77;
        *(_BYTE *)(v4 + v75) = v78;
        ++v74;
        *(_BYTE *)(v4 + 260) = v78;
        if ( v74 == "" )
          break;
        v75 = v77;
      }
      return (char *)sub_C89F4(v4, v472, v76[1]);
    case 15:
      v68 = "non-virtual thunk to ";
      v69 = *(_DWORD *)(v4 + 256);
      v70 = a3;
      while ( 1 )
      {
        v72 = *v68;
        if ( v69 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v73 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v71 = 1;
          v69 = 0;
        }
        else
        {
          v71 = v69 + 1;
        }
        *(_DWORD *)(v4 + 256) = v71;
        *(_BYTE *)(v4 + v69) = v72;
        ++v68;
        *(_BYTE *)(v4 + 260) = v72;
        if ( v68 == "" )
          break;
        v69 = v71;
      }
      return (char *)sub_C89F4(v4, v472, v70[1]);
    case 16:
      v62 = "virtual thunk to ";
      v63 = *(_DWORD *)(v4 + 256);
      v64 = a3;
      while ( 1 )
      {
        v66 = *v62;
        if ( v63 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v67 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v65 = 1;
          v63 = 0;
        }
        else
        {
          v65 = v63 + 1;
        }
        *(_DWORD *)(v4 + 256) = v65;
        *(_BYTE *)(v4 + v63) = v66;
        ++v62;
        *(_BYTE *)(v4 + 260) = v66;
        if ( v62 == "" )
          break;
        v63 = v65;
      }
      return (char *)sub_C89F4(v4, v472, v64[1]);
    case 17:
      v56 = "covariant return thunk to ";
      v57 = *(_DWORD *)(v4 + 256);
      v58 = a3;
      while ( 1 )
      {
        v60 = *v56;
        if ( v57 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v61 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v59 = 1;
          v57 = 0;
        }
        else
        {
          v59 = v57 + 1;
        }
        *(_DWORD *)(v4 + 256) = v59;
        *(_BYTE *)(v4 + v57) = v60;
        ++v56;
        *(_BYTE *)(v4 + 260) = v60;
        if ( v56 == "" )
          break;
        v57 = v59;
      }
      return (char *)sub_C89F4(v4, v472, v58[1]);
    case 18:
      v50 = "java Class for ";
      v51 = *(_DWORD *)(v4 + 256);
      v52 = a3;
      while ( 1 )
      {
        v54 = *v50;
        if ( v51 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v55 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v53 = 1;
          v51 = 0;
        }
        else
        {
          v53 = v51 + 1;
        }
        *(_DWORD *)(v4 + 256) = v53;
        *(_BYTE *)(v4 + v51) = v54;
        ++v50;
        *(_BYTE *)(v4 + 260) = v54;
        if ( v50 == "" )
          break;
        v51 = v53;
      }
      return (char *)sub_C89F4(v4, v472, v52[1]);
    case 19:
      v44 = "guard variable for ";
      v45 = *(_DWORD *)(v4 + 256);
      v46 = a3;
      while ( 1 )
      {
        v48 = *v44;
        if ( v45 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v49 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v47 = 1;
          v45 = 0;
        }
        else
        {
          v47 = v45 + 1;
        }
        *(_DWORD *)(v4 + 256) = v47;
        *(_BYTE *)(v4 + v45) = v48;
        ++v44;
        *(_BYTE *)(v4 + 260) = v48;
        if ( v44 == "" )
          break;
        v45 = v47;
      }
      return (char *)sub_C89F4(v4, v472, v46[1]);
    case 20:
      v38 = "TLS init function for ";
      v39 = *(_DWORD *)(v4 + 256);
      v40 = a3;
      while ( 1 )
      {
        v42 = *v38;
        if ( v39 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v43 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v41 = 1;
          v39 = 0;
        }
        else
        {
          v41 = v39 + 1;
        }
        *(_DWORD *)(v4 + 256) = v41;
        *(_BYTE *)(v4 + v39) = v42;
        ++v38;
        *(_BYTE *)(v4 + 260) = v42;
        if ( v38 == "" )
          break;
        v39 = v41;
      }
      return (char *)sub_C89F4(v4, v472, v40[1]);
    case 21:
      v32 = "TLS wrapper function for ";
      v33 = *(_DWORD *)(v4 + 256);
      v34 = a3;
      while ( 1 )
      {
        v36 = *v32;
        if ( v33 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v37 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v35 = 1;
          v33 = 0;
        }
        else
        {
          v35 = v33 + 1;
        }
        *(_DWORD *)(v4 + 256) = v35;
        *(_BYTE *)(v4 + v33) = v36;
        ++v32;
        *(_BYTE *)(v4 + 260) = v36;
        if ( v32 == "" )
          break;
        v33 = v35;
      }
      return (char *)sub_C89F4(v4, v472, v34[1]);
    case 22:
      v25 = "reference temporary #";
      v26 = *(_DWORD *)(v4 + 256);
      v27 = a3;
      while ( 1 )
      {
        v29 = *v25;
        if ( v26 == 255 )
        {
          v30 = *(_DWORD *)(v4 + 268);
          v31 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v31(v4, 255, v30);
          ++*(_DWORD *)(v4 + 288);
          v28 = 1;
          v26 = 0;
        }
        else
        {
          v28 = v26 + 1;
        }
        *(_DWORD *)(v4 + 256) = v28;
        *(_BYTE *)(v4 + v26) = v29;
        ++v25;
        *(_BYTE *)(v4 + 260) = v29;
        if ( v25 == "" )
          break;
        v26 = v28;
      }
      sub_C89F4(v4, v472, v27[2]);
      v318 = *(_DWORD *)(v4 + 256);
      v319 = " for ";
      while ( 1 )
      {
        v321 = *v319;
        if ( v318 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v322 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v320 = 1;
          v318 = 0;
        }
        else
        {
          v320 = v318 + 1;
        }
        *(_DWORD *)(v4 + 256) = v320;
        *(_BYTE *)(v4 + v318) = v321;
        ++v319;
        *(_BYTE *)(v4 + 260) = v321;
        if ( v319 == "" )
          break;
        v318 = v320;
      }
      return (char *)sub_C89F4(v4, v472, v27[1]);
    case 23:
      v19 = "hidden alias for ";
      v20 = *(_DWORD *)(v4 + 256);
      v21 = a3;
      while ( 1 )
      {
        v23 = *v19;
        if ( v20 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v24 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v22 = 1;
          v20 = 0;
        }
        else
        {
          v22 = v20 + 1;
        }
        *(_DWORD *)(v4 + 256) = v22;
        *(_BYTE *)(v4 + v20) = v23;
        ++v19;
        *(_BYTE *)(v4 + 260) = v23;
        if ( v19 == "" )
          break;
        v20 = v22;
      }
      return (char *)sub_C89F4(v4, v472, v21[1]);
    case 24:
      if ( a3[2] )
      {
        v11 = 0;
        v12 = *(_DWORD *)(v4 + 256);
        v13 = a3[1];
        v14 = a3[2];
        while ( 1 )
        {
          v16 = *(_BYTE *)(v13 + v11);
          if ( v12 == 255 )
          {
            v17 = *(_DWORD *)(v4 + 268);
            v18 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)v18(v4, 255, v17);
            ++*(_DWORD *)(v4 + 288);
            v15 = 1;
            v12 = 0;
          }
          else
          {
            v15 = v12 + 1;
          }
          *(_DWORD *)(v4 + 256) = v15;
          *(_BYTE *)(v4 + v12) = v16;
          ++v11;
          *(_BYTE *)(v4 + 260) = v16;
          if ( v14 == v11 )
            break;
          v12 = v15;
        }
      }
      return result;
    case 25:
    case 26:
    case 27:
      if ( !*(_DWORD *)(v4 + 276) )
      {
        v7 = 0;
        goto LABEL_6;
      }
      v10 = *(int ***)(v4 + 276);
      while ( 1 )
      {
        if ( !v10[2] )
        {
          if ( (unsigned int)(*v10[1] - 25) > 2 )
            goto LABEL_19;
          if ( v3 == *v10[1] )
            return (char *)sub_C89F4(v4, a2, v5[1]);
        }
        v10 = (int **)*v10;
        if ( !v10 )
        {
LABEL_19:
          v7 = *(_DWORD *)(v4 + 276);
          goto LABEL_6;
        }
      }
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 37:
    case 38:
      goto LABEL_5;
    case 35:
    case 36:
      result = (char *)a3[1];
      v266 = *(_DWORD *)result;
      if ( *(_DWORD *)result != 5 )
        goto LABEL_370;
      result = (char *)sub_C3F80(v4, (int *)result + 1);
      if ( !result )
        goto LABEL_690;
      v266 = *(_DWORD *)result;
      if ( *(_DWORD *)result != 47 )
        goto LABEL_370;
      v455 = *(_DWORD *)(v4 + 284);
      while ( v455 > 0 )
      {
        result = (char *)*((_DWORD *)result + 2);
        --v455;
        if ( !result || *(_DWORD *)result != 47 )
          goto LABEL_690;
      }
      if ( v455 || (result = (char *)*((_DWORD *)result + 1)) == 0 )
      {
LABEL_690:
        *(_DWORD *)(v4 + 280) = 1;
        return result;
      }
      v266 = *(_DWORD *)result;
LABEL_370:
      if ( v266 == 35 || *v5 == v266 )
      {
        v7 = *(_DWORD *)(v4 + 276);
        v5 = (int *)result;
        goto LABEL_6;
      }
      if ( v266 != 36 )
      {
LABEL_5:
        v7 = *(_DWORD *)(v4 + 276);
LABEL_6:
        *(_DWORD *)s = v7;
        *(_DWORD *)(v4 + 276) = s;
        v482 = 0;
        v8 = *(_DWORD *)(v4 + 272);
        v481 = v5;
        v483 = v8;
LABEL_7:
        v9 = v5[1];
        goto LABEL_8;
      }
      v9 = *((_DWORD *)result + 1);
      v267 = *(_DWORD *)(v4 + 276);
      *(_DWORD *)(v4 + 276) = s;
      v482 = 0;
      v268 = *(_DWORD *)(v4 + 272);
      *(_DWORD *)s = v267;
      v481 = v5;
      v483 = v268;
      if ( !v9 )
        goto LABEL_7;
LABEL_8:
      sub_C89F4(v4, v472, v9);
      if ( !v482 )
        sub_C8A14(v4, v472, v5);
      result = *(char **)s;
      *(_DWORD *)(v4 + 276) = *(_DWORD *)s;
      return result;
    case 39:
      v255 = (int *)a3[1];
      if ( a2 & 4 )
      {
        v376 = v255[2];
        if ( v255[3] )
        {
          v377 = 0;
          v378 = v255[3];
          v379 = *(_DWORD *)(v4 + 256);
          v380 = v376;
          v381 = v378;
          while ( 1 )
          {
            v383 = *(_BYTE *)(v380 + v377);
            if ( v379 == 255 )
            {
              v384 = *(_DWORD *)(v4 + 268);
              v385 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
              *(_BYTE *)(v4 + 255) = 0;
              result = (char *)v385(v4, 255, v384);
              ++*(_DWORD *)(v4 + 288);
              v382 = 1;
              v379 = 0;
            }
            else
            {
              v382 = v379 + 1;
            }
            *(_DWORD *)(v4 + 256) = v382;
            *(_BYTE *)(v4 + v379) = v383;
            ++v377;
            *(_BYTE *)(v4 + 260) = v383;
            if ( v381 == v377 )
              break;
            v379 = v382;
          }
        }
      }
      else
      {
        v256 = *v255;
        if ( v255[1] )
        {
          v257 = 0;
          v258 = v255[1];
          v259 = *(_DWORD *)(v4 + 256);
          v260 = v256;
          v261 = v258;
          while ( 1 )
          {
            v263 = *(_BYTE *)(v260 + v257);
            if ( v259 == 255 )
            {
              v264 = *(_DWORD *)(v4 + 268);
              v265 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
              *(_BYTE *)(v4 + 255) = 0;
              result = (char *)v265(v4, 255, v264);
              ++*(_DWORD *)(v4 + 288);
              v262 = 1;
              v259 = 0;
            }
            else
            {
              v262 = v259 + 1;
            }
            *(_DWORD *)(v4 + 256) = v262;
            *(_BYTE *)(v4 + v259) = v263;
            ++v257;
            *(_BYTE *)(v4 + 260) = v263;
            if ( v261 == v257 )
              break;
            v259 = v262;
          }
        }
      }
      return result;
    case 40:
      return (char *)sub_C89F4(v4, a2, a3[1]);
    case 41:
      if ( !(a2 & 0x20) )
      {
        if ( a3[1] && !(a2 & 0x40) )
        {
          v482 = a2 & 0x40;
          v450 = *(_DWORD *)(v4 + 276);
          v483 = *(_DWORD *)(v4 + 272);
          *(_DWORD *)s = v450;
          *(_DWORD *)(v4 + 276) = s;
          v451 = a3[1];
          v481 = v5;
          result = (char *)sub_C89F4(v4, a2 & 0xFFFFFF9F, v451);
          v452 = v482;
          *(_DWORD *)(v4 + 276) = *(_DWORD *)s;
          if ( v452 )
            return result;
          sub_C3D34(v4, 32);
        }
        return (char *)sub_C9568(v4, v472 & 0xFFFFFF9F, v5 + 2, *(int **)(v4 + 276));
      }
      v401 = a2 & 0xFFFFFF9F;
      result = (char *)sub_C9568(v4, a2 & 0xFFFFFF9F, a3 + 2, *(int **)(v4 + 276));
      v402 = v5[1];
      if ( v402 )
        result = (char *)sub_C89F4(v4, v401, v402);
      return result;
    case 42:
      result = (char *)&dword_114;
      *(_DWORD *)s = *(_DWORD *)(v4 + 276);
      v272 = *(char **)s;
      v482 = 0;
      v273 = *(_DWORD *)(v4 + 272);
      v274 = *(char **)s;
      *(_DWORD *)(v4 + 276) = s;
      v481 = v5;
      v483 = v273;
      if ( v274 && (unsigned int)(**((_DWORD **)v272 + 1) - 25) <= 2 )
      {
        v275 = 1;
        v276 = v272;
        v277 = v4;
        do
        {
          if ( !*((_DWORD *)v276 + 2) )
          {
            if ( v275 > 3 )
            {
              *(_DWORD *)(v277 + 280) = 1;
              return result;
            }
            v278 = &s[16 * v275];
            v279 = *((_DWORD *)v276 + 1);
            v280 = *((_DWORD *)v276 + 2);
            *(_DWORD *)v278 = *(_DWORD *)v276;
            *((_DWORD *)v278 + 1) = v279;
            *((_DWORD *)v278 + 2) = v280;
            *((_DWORD *)v278 + 3) = *((_DWORD *)v276 + 3);
            *(_DWORD *)&s[16 * v275] = *(_DWORD *)(v277 + 276);
            result = (char *)v277;
            v281 = &s[16 * v275++];
            *(_DWORD *)(v277 + 276) = v281;
            *((_DWORD *)v276 + 2) = 1;
          }
          v276 = *(char **)v276;
        }
        while ( v276 && (unsigned int)(**((_DWORD **)v276 + 1) - 25) <= 2 );
        sub_C89F4(v277, v472, v5[2]);
        v282 = v482;
        v4 = v277;
        result = v274;
        *(_DWORD *)(v277 + 276) = v274;
        if ( v282 )
          return result;
        if ( v275 != 1 )
        {
          v283 = v275 - 1;
          sub_C8A14(v277, v472, *(_DWORD **)&s[16 * v283 + 4]);
          for ( j = &s[16 * v283 - 12]; v283 != 1; j -= 16 )
          {
            --v283;
            sub_C8A14(v277, v472, *(_DWORD **)j);
          }
          v4 = v277;
          v285 = *(_DWORD *)(v277 + 276);
          return (char *)sub_C9390(v4, v472, v5 + 1, v285);
        }
      }
      else
      {
        sub_C89F4(v4, a2, v5[2]);
        result = v274;
        *(_DWORD *)(v4 + 276) = v274;
        if ( v482 )
          return result;
      }
      v285 = (int)v274;
      return (char *)sub_C9390(v4, v472, v5 + 1, v285);
    case 43:
    case 45:
      v269 = *(_DWORD *)(v4 + 276);
      *(_DWORD *)(v4 + 276) = s;
      v482 = 0;
      v270 = *(_DWORD *)(v4 + 272);
      *(_DWORD *)s = v269;
      v271 = v5[2];
      v483 = v270;
      v481 = v5;
      result = (char *)sub_C89F4(v4, a2, v271);
      if ( !v482 )
        result = sub_C8A14(v4, v472, v5);
      *(_DWORD *)(v4 + 276) = *(_DWORD *)s;
      return result;
    case 44:
      if ( *((_WORD *)a3 + 5) )
      {
        v396 = "_Sat ";
        result = "";
        v397 = *(_DWORD *)(v4 + 256);
        v398 = a3;
        while ( 1 )
        {
          v400 = *v396;
          if ( v397 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v399 = 1;
            v397 = 0;
          }
          else
          {
            v399 = v397 + 1;
          }
          *(_DWORD *)(v4 + 256) = v399;
          *(_BYTE *)(v4 + v397) = v400;
          ++v396;
          *(_BYTE *)(v4 + 260) = v400;
          if ( v396 == "" )
            break;
          v397 = v399;
        }
        v5 = v398;
      }
      v217 = v5[1];
      if ( *(char ***)(v217 + 4) == &off_EFB54 )
      {
        v394 = *(_DWORD *)(v4 + 256);
      }
      else
      {
        result = (char *)sub_C89F4(v4, v472, v217);
        v218 = *(_DWORD *)(v4 + 256);
        if ( v218 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v394 = 1;
          v218 = 0;
        }
        else
        {
          v394 = v218 + 1;
        }
        *(_DWORD *)(v4 + 256) = v394;
        *(_BYTE *)(v4 + v218) = 32;
        *(_BYTE *)(v4 + 260) = 32;
      }
      if ( *((_WORD *)v5 + 4) )
      {
        v219 = "_Accum";
        result = 0;
        while ( 1 )
        {
          v221 = *v219;
          if ( v394 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            v222 = *(_DWORD *)(v4 + 268);
            result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
            ++*(_DWORD *)(v4 + 288);
            v220 = 1;
            v394 = 0;
          }
          else
          {
            v220 = v394 + 1;
          }
          *(_DWORD *)(v4 + 256) = v220;
          *(_BYTE *)(v4 + v394) = v221;
          ++v219;
          *(_BYTE *)(v4 + 260) = v221;
          if ( v219 == "" )
            break;
          v394 = v220;
        }
      }
      else
      {
        v360 = "_Fract";
        while ( 1 )
        {
          v362 = *v360;
          if ( v394 == 255 )
          {
            v363 = *(_DWORD *)(v4 + 268);
            v364 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)v364(v4, 255, v363);
            ++*(_DWORD *)(v4 + 288);
            v361 = 1;
            v394 = 0;
          }
          else
          {
            v361 = v394 + 1;
          }
          *(_DWORD *)(v4 + 256) = v361;
          *(_BYTE *)(v4 + v394) = v362;
          ++v360;
          *(_BYTE *)(v4 + 260) = v362;
          if ( v360 == "" )
            break;
          v394 = v361;
        }
      }
      return result;
    case 46:
    case 47:
      v212 = a3[1];
      if ( v212 )
        result = (char *)sub_C89F4(v4, a2, v212);
      if ( v5[2] )
      {
        v213 = *(_DWORD *)(v4 + 256);
        if ( v213 > 0xFD )
        {
          *(_BYTE *)(v4 + v213) = 0;
          v410 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int))(v4 + 264))(v4);
          v411 = *(_DWORD *)(v4 + 288);
          *(_DWORD *)(v4 + 256) = 0;
          *(_DWORD *)(v4 + 288) = v411 + 1;
          v213 = 0;
        }
        v214 = ", ";
        while ( 1 )
        {
          v216 = *v214;
          if ( v213 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            v213 = 0;
            ++*(_DWORD *)(v4 + 288);
            v215 = 1;
          }
          else
          {
            v215 = v213 + 1;
          }
          *(_DWORD *)(v4 + 256) = v215;
          ++v214;
          *(_BYTE *)(v4 + v213) = v216;
          *(_BYTE *)(v4 + 260) = v216;
          if ( v214 == "" )
            break;
          v213 = v215;
        }
        v357 = v215;
        v358 = *(_DWORD *)(v4 + 288);
        result = (char *)sub_C89F4(v4, v472, v5[2]);
        if ( v358 == *(_DWORD *)(v4 + 288) && *(_DWORD *)(v4 + 256) == v357 )
          *(_DWORD *)(v4 + 256) = v357 - 2;
      }
      return result;
    case 48:
      v208 = a3[1];
      v209 = v5[2];
      if ( v208 )
        sub_C89F4(v4, a2, v208);
      v210 = *(_DWORD *)(v4 + 256);
      if ( v210 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        ++*(_DWORD *)(v4 + 288);
        v426 = 1;
        v210 = 0;
      }
      else
      {
        v426 = v210 + 1;
      }
      *(_DWORD *)(v4 + 256) = v426;
      *(_BYTE *)(v4 + v210) = 123;
      *(_BYTE *)(v4 + 260) = 123;
      result = (char *)sub_C89F4(v4, v472, v209);
      v211 = *(_DWORD *)(v4 + 256);
      if ( v211 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v425 = 1;
        ++*(_DWORD *)(v4 + 288);
        v211 = 0;
      }
      else
      {
        v425 = v211 + 1;
      }
      *(_DWORD *)(v4 + 256) = v425;
      *(_BYTE *)(v4 + v211) = 125;
      *(_BYTE *)(v4 + 260) = 125;
      return result;
    case 49:
      v196 = a3[1];
      v197 = "operator";
      v474 = *(_DWORD *)(a3[1] + 8);
      result = 0;
      for ( k = *(_DWORD *)(v4 + 256); ; k = v199 )
      {
        v200 = *v197;
        if ( k == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v201 = *(_DWORD *)(v4 + 268);
          result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v199 = 1;
          k = 0;
        }
        else
        {
          v199 = k + 1;
        }
        *(_DWORD *)(v4 + 256) = v199;
        *(_BYTE *)(v4 + k) = v200;
        ++v197;
        *(_BYTE *)(v4 + 260) = v200;
        if ( v197 == "" )
          break;
      }
      v337 = *(unsigned __int8 **)(v196 + 4);
      if ( ((*v337 - 97) & 0xFFu) <= 0x19 )
      {
        if ( v199 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v464 = 1;
          v199 = 0;
        }
        else
        {
          v464 = v199 + 1;
        }
        *(_DWORD *)(v4 + 256) = v464;
        *(_BYTE *)(v4 + v199) = 32;
        *(_BYTE *)(v4 + 260) = 32;
        v337 = *(unsigned __int8 **)(v196 + 4);
      }
      v338 = v337[v474 - 1] - 32;
      v339 = v474 - (32 - v337[v474 - 1] + (v338 <= 0) + v338);
      if ( v339 )
      {
        result = 0;
        v340 = *(_DWORD *)(v4 + 256);
        v341 = (int)&v337[v339];
        while ( 1 )
        {
          v343 = *v337;
          if ( v340 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            v344 = *(_DWORD *)(v4 + 268);
            result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
            ++*(_DWORD *)(v4 + 288);
            v342 = 1;
            v340 = 0;
          }
          else
          {
            v342 = v340 + 1;
          }
          *(_DWORD *)(v4 + 256) = v342;
          *(_BYTE *)(v4 + v340) = v343;
          ++v337;
          *(_BYTE *)(v4 + 260) = v343;
          if ( v337 == (unsigned __int8 *)v341 )
            break;
          v340 = v342;
        }
      }
      return result;
    case 50:
      v202 = "operator ";
      v203 = *(_DWORD *)(v4 + 256);
      v204 = a3;
      while ( 1 )
      {
        v206 = *v202;
        if ( v203 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v207 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v205 = 1;
          v203 = 0;
        }
        else
        {
          v205 = v203 + 1;
        }
        *(_DWORD *)(v4 + 256) = v205;
        *(_BYTE *)(v4 + v203) = v206;
        ++v202;
        *(_BYTE *)(v4 + 260) = v206;
        if ( v202 == "" )
          break;
        v203 = v205;
      }
      return (char *)sub_C89F4(v4, v472, v204[2]);
    case 51:
      v190 = "operator ";
      v191 = *(_DWORD *)(v4 + 256);
      v192 = a3;
      while ( 1 )
      {
        v194 = *v190;
        if ( v191 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v195 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v193 = 1;
          v191 = 0;
        }
        else
        {
          v193 = v191 + 1;
        }
        *(_DWORD *)(v4 + 256) = v193;
        *(_BYTE *)(v4 + v191) = v194;
        ++v190;
        *(_BYTE *)(v4 + 260) = v194;
        if ( v190 == "" )
          break;
        v191 = v193;
      }
      return (char *)sub_C9790((_DWORD *)v4, v472, v192 + 1);
    case 52:
      return (char *)sub_C9950(v4, a2, (_DWORD *)a3[1]);
    case 53:
      v188 = (_DWORD *)a3[1];
      v189 = a3[2];
      if ( *v188 == 49 )
      {
        v403 = *(const char **)v188[1];
        v404 = strcmp(v403, "ad");
        v405 = *(_DWORD *)v189;
        if ( v404 || v405 != 3 )
        {
          if ( v405 == 55 )
          {
            sub_C99F4(v4, v472, *(int **)(v189 + 4));
            return (char *)sub_C9950(v4, v472, v188);
          }
        }
        else if ( **(_DWORD **)(v189 + 4) == 1 && **(_DWORD **)(v189 + 8) == 41 )
        {
          v189 = *(_DWORD *)(v189 + 4);
        }
        sub_C9950(v4, v472, v188);
        if ( v403 )
        {
          if ( !strcmp(v403, "gs") )
            return (char *)sub_C89F4(v4, v472, v189);
          if ( !strcmp(v403, "st") )
          {
            v406 = *(_DWORD *)(v4 + 256);
            if ( v406 == 255 )
            {
              *(_BYTE *)(v4 + 255) = 0;
              (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
              ++*(_DWORD *)(v4 + 288);
              v406 = 0;
            }
            *(_DWORD *)(v4 + 256) = v406 + 1;
            *(_BYTE *)(v4 + v406) = 40;
            *(_BYTE *)(v4 + 260) = 40;
            result = (char *)sub_C89F4(v4, v472, v189);
            v407 = *(_DWORD *)(v4 + 256);
            if ( v407 == 255 )
            {
              *(_BYTE *)(v4 + 255) = 0;
              result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(
                                 v4,
                                 255,
                                 *(_DWORD *)(v4 + 268));
              ++*(_DWORD *)(v4 + 288);
              v407 = 0;
            }
            *(_DWORD *)(v4 + 256) = v407 + 1;
            *(_BYTE *)(v4 + v407) = 41;
            *(_BYTE *)(v4 + 260) = 41;
            return result;
          }
        }
      }
      else if ( *v188 == 51 )
      {
        v408 = *(_DWORD *)(v4 + 256);
        if ( v408 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v466 = 1;
          v408 = 0;
        }
        else
        {
          v466 = v408 + 1;
        }
        *(_DWORD *)(v4 + 256) = v466;
        *(_BYTE *)(v4 + v408) = 40;
        *(_BYTE *)(v4 + 260) = 40;
        sub_C9790((_DWORD *)v4, v472, v188 + 1);
        v409 = *(_DWORD *)(v4 + 256);
        if ( v409 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
          ++*(_DWORD *)(v4 + 288);
          v465 = 1;
          v409 = 0;
        }
        else
        {
          v465 = v409 + 1;
        }
        *(_DWORD *)(v4 + 256) = v465;
        *(_BYTE *)(v4 + v409) = 41;
        *(_BYTE *)(v4 + 260) = 41;
      }
      else
      {
        sub_C9950(v4, a2, (_DWORD *)a3[1]);
      }
      return (char *)sub_C99F4(v4, v472, (int *)v189);
    case 54:
      v187 = (_DWORD *)a3[2];
      if ( *v187 != 55 )
        goto LABEL_240;
      v386 = a3[1];
      v387 = *(unsigned __int8 ***)(v386 + 4);
      if ( (*v387)[1] != 99 || (v461 = **v387, ((v461 - 99) & 0xFFu) > 1) && (unsigned int)(v461 - 114) > 1 )
      {
        if ( *(_DWORD *)v386 == 49 && v387[2] == (_BYTE *)&dword_0 + 1 && *v387[1] == 62 )
        {
          sub_C3D34(v4, 40);
          v386 = v5[1];
          v187 = (_DWORD *)v5[2];
        }
        v388 = strcmp(**(const char ***)(v386 + 4), "cl");
        v389 = v187[1];
        if ( v388 || *(_DWORD *)v389 != 3 )
        {
          sub_C99F4(v4, v472, (int *)v389);
        }
        else
        {
          if ( **(_DWORD **)(v389 + 8) != 41 )
            *(_DWORD *)(v4 + 280) = 1;
          sub_C99F4(v4, v472, *(int **)(v389 + 4));
        }
        v390 = v5[1];
        v391 = **(const char ***)(v390 + 4);
        if ( !strcmp(v391, "ix") )
        {
          sub_C3D34(v4, 91);
          sub_C89F4(v4, v472, *(_DWORD *)(v5[2] + 8));
          sub_C3D34(v4, 93);
        }
        else
        {
          if ( strcmp(v391, "cl") )
            sub_C9950(v4, v472, (_DWORD *)v390);
          sub_C99F4(v4, v472, *(int **)(v5[2] + 8));
        }
        v392 = v5[1];
        result = *(char **)v392;
        if ( *(_DWORD *)v392 == 49 )
        {
          v393 = *(_DWORD *)(v392 + 4);
          if ( *(_DWORD *)(v393 + 8) == 1 && **(_BYTE **)(v393 + 4) == 62 )
            result = (char *)sub_C3D34(v4, 41);
        }
      }
      else
      {
        sub_C9950(v4, v472, (_DWORD *)v386);
        sub_C3D34(v4, 60);
        sub_C89F4(v4, v472, *(_DWORD *)(v5[2] + 4));
        sub_C5A48(v4, ">(");
        sub_C89F4(v4, v472, *(_DWORD *)(v5[2] + 8));
        result = (char *)sub_C3D34(v4, 41);
      }
      return result;
    case 55:
      *(_DWORD *)(v4 + 280) = 1;
      return result;
    case 56:
      v249 = (_DWORD *)a3[2];
      if ( *v249 != 57 || (v250 = (_DWORD *)v249[2], *v250 != 58) )
      {
LABEL_240:
        *(_DWORD *)(v4 + 280) = 1;
      }
      else
      {
        v251 = (int *)v249[1];
        v252 = (_DWORD *)a3[1];
        v253 = (int *)v250[1];
        v254 = (int *)v250[2];
        if ( !strcmp(**(const char ***)(a3[1] + 4), "qu") )
        {
          sub_C99F4(v4, v472, v251);
          sub_C9950(v4, v472, v252);
          sub_C99F4(v4, v472, v253);
          sub_C5A48(v4, " : ");
          result = (char *)sub_C99F4(v4, v472, v254);
        }
        else
        {
          sub_C5A48(v4, "new ");
          if ( v251[1] )
          {
            sub_C99F4(v4, v472, v251);
            sub_C3D34(v4, 32);
          }
          result = (char *)sub_C89F4(v4, v472, (int)v253);
          if ( v254 )
            result = (char *)sub_C99F4(v4, v472, v254);
        }
      }
      return result;
    case 57:
    case 58:
      *(_DWORD *)(v4 + 280) = 1;
      return result;
    case 59:
    case 60:
      v243 = (_DWORD *)a3[1];
      v244 = 0;
      if ( *v243 != 39 )
        goto LABEL_336;
      v244 = *(_DWORD *)(v243[1] + 16);
      if ( !v244 )
        goto LABEL_336;
      if ( v244 <= 6 )
      {
        v454 = (_DWORD *)v5[2];
        if ( !*v454 )
        {
          if ( v3 == 60 )
          {
            sub_C3D34(v4, 45);
            v454 = (_DWORD *)v5[2];
          }
          sub_C89F4(v4, v472, (int)v454);
          result = (char *)(v244 - 2);
          switch ( v244 )
          {
            case 2u:
              result = (char *)sub_C3D34(v4, 117);
              break;
            case 3u:
              result = (char *)sub_C3D34(v4, 108);
              break;
            case 4u:
              result = (char *)sub_C5A48(v4, "ul");
              break;
            case 5u:
              result = (char *)sub_C5A48(v4, "ll");
              break;
            case 6u:
              result = (char *)sub_C5A48(v4, "ull");
              break;
            default:
              return result;
          }
          return result;
        }
      }
      else if ( v244 == 7 )
      {
        v245 = v5[2];
        if ( !*(_DWORD *)v245 && *(_DWORD *)(v245 + 8) == 1 && v3 == 59 )
        {
          v467 = **(unsigned __int8 **)(v245 + 4);
          if ( v467 == 48 )
            return (char *)sub_C5A48(v4, "false");
          if ( (unsigned __int8)v467 == 49 )
            return (char *)sub_C5A48(v4, "true");
        }
      }
LABEL_336:
      v246 = *(_DWORD *)(v4 + 256);
      if ( v246 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        ++*(_DWORD *)(v4 + 288);
        v453 = 1;
        v246 = 0;
      }
      else
      {
        v453 = v246 + 1;
      }
      *(_DWORD *)(v4 + 256) = v453;
      *(_BYTE *)(v4 + v246) = 40;
      *(_BYTE *)(v4 + 260) = 40;
      sub_C89F4(v4, v472, v5[1]);
      v247 = *(_DWORD *)(v4 + 256);
      if ( v247 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        ++*(_DWORD *)(v4 + 288);
        *(_DWORD *)(v4 + 256) = 1;
        *(_BYTE *)v4 = 41;
        *(_BYTE *)(v4 + 260) = 41;
        if ( *v5 != 60 )
        {
LABEL_342:
          if ( v244 != 8 )
            return (char *)sub_C89F4(v4, v472, v5[2]);
          v458 = *(_DWORD *)(v4 + 256);
          if ( v458 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            (*(void (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v458 = 0;
          }
          *(_DWORD *)(v4 + 256) = v458 + 1;
          *(_BYTE *)(v4 + v458) = 91;
          *(_BYTE *)(v4 + 260) = 91;
          result = (char *)sub_C89F4(v4, v472, v5[2]);
          v459 = *(_DWORD *)(v4 + 256);
          if ( v459 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v459 = 0;
          }
          *(_DWORD *)(v4 + 256) = v459 + 1;
          *(_BYTE *)(v4 + v459) = 93;
          *(_BYTE *)(v4 + 260) = 93;
          return result;
        }
        v248 = 1;
      }
      else
      {
        v248 = v247 + 1;
        *(_DWORD *)(v4 + 256) = v247 + 1;
        *(_BYTE *)(v4 + v247) = 41;
        *(_BYTE *)(v4 + 260) = 41;
        if ( *v5 != 60 )
          goto LABEL_342;
        if ( v248 == 255 )
        {
          v460 = *(_DWORD *)(v4 + 268);
          *(_BYTE *)(v4 + 255) = 0;
          (*(void (__fastcall **)(int))(v4 + 264))(v4);
          v248 = 0;
          ++*(_DWORD *)(v4 + 288);
        }
      }
      *(_DWORD *)(v4 + 256) = v248 + 1;
      *(_BYTE *)(v4 + v248) = 45;
      *(_BYTE *)(v4 + 260) = 45;
      goto LABEL_342;
    case 61:
      v237 = "java resource ";
      v238 = *(_DWORD *)(v4 + 256);
      v239 = a3;
      while ( 1 )
      {
        v241 = *v237;
        if ( v238 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v242 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v240 = 1;
          v238 = 0;
        }
        else
        {
          v240 = v238 + 1;
        }
        *(_DWORD *)(v4 + 256) = v240;
        *(_BYTE *)(v4 + v238) = v241;
        ++v237;
        *(_BYTE *)(v4 + 260) = v241;
        if ( v237 == "" )
          break;
        v238 = v240;
      }
      return (char *)sub_C89F4(v4, v472, v239[1]);
    case 62:
      sub_C89F4(v4, a2, a3[1]);
      return (char *)sub_C89F4(v4, v472, v5[2]);
    case 63:
      v235 = *(_DWORD *)(v4 + 256);
      v236 = *((_BYTE *)a3 + 4);
      if ( v235 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v412 = 1;
        ++*(_DWORD *)(v4 + 288);
        v235 = 0;
      }
      else
      {
        v412 = v235 + 1;
      }
      *(_DWORD *)(v4 + 256) = v412;
      *(_BYTE *)(v4 + v235) = v236;
      *(_BYTE *)(v4 + 260) = v236;
      return result;
    case 64:
      sprintf(s, "%ld", a3[1]);
      result = (char *)strlen(s);
      if ( result )
      {
        v230 = 0;
        v231 = *(_DWORD *)(v4 + 256);
        v232 = result;
        while ( 1 )
        {
          v234 = s[(_DWORD)v230];
          if ( v231 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
            ++*(_DWORD *)(v4 + 288);
            v233 = 1;
            v231 = 0;
          }
          else
          {
            v233 = v231 + 1;
          }
          *(_DWORD *)(v4 + 256) = v233;
          *(_BYTE *)(v4 + v231) = v234;
          ++v230;
          *(_BYTE *)(v4 + 260) = v234;
          if ( v230 == v232 )
            break;
          v231 = v233;
        }
      }
      return result;
    case 65:
      v223 = "decltype (";
      v224 = *(_DWORD *)(v4 + 256);
      v225 = a3;
      while ( 1 )
      {
        v227 = *v223;
        if ( v224 == 255 )
        {
          v228 = *(_DWORD *)(v4 + 268);
          v229 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v229(v4, 255, v228);
          ++*(_DWORD *)(v4 + 288);
          v226 = 1;
          v224 = 0;
        }
        else
        {
          v226 = v224 + 1;
        }
        *(_DWORD *)(v4 + 256) = v226;
        *(_BYTE *)(v4 + v224) = v227;
        ++v223;
        *(_BYTE *)(v4 + 260) = v227;
        if ( v223 == "" )
          break;
        v224 = v226;
      }
      result = (char *)sub_C89F4(v4, v472, v225[1]);
      v351 = *(_DWORD *)(v4 + 256);
      if ( v351 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v415 = 1;
        ++*(_DWORD *)(v4 + 288);
        v351 = 0;
      }
      else
      {
        v415 = v351 + 1;
      }
      *(_DWORD *)(v4 + 256) = v415;
      *(_BYTE *)(v4 + v351) = 41;
      *(_BYTE *)(v4 + 260) = 41;
      return result;
    case 66:
      v305 = "global constructors keyed to ";
      v306 = *(_DWORD *)(v4 + 256);
      v307 = a3;
      while ( 1 )
      {
        v309 = *v305;
        if ( v306 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v310 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v308 = 1;
          v306 = 0;
        }
        else
        {
          v308 = v306 + 1;
        }
        *(_DWORD *)(v4 + 256) = v308;
        *(_BYTE *)(v4 + v306) = v309;
        ++v305;
        *(_BYTE *)(v4 + 260) = v309;
        if ( v305 == "" )
          break;
        v306 = v308;
      }
      return (char *)sub_C89F4(v4, v472, v307[1]);
    case 67:
      v299 = "global destructors keyed to ";
      v300 = *(_DWORD *)(v4 + 256);
      v301 = a3;
      while ( 1 )
      {
        v303 = *v299;
        if ( v300 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v304 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v302 = 1;
          v300 = 0;
        }
        else
        {
          v302 = v300 + 1;
        }
        *(_DWORD *)(v4 + 256) = v302;
        *(_BYTE *)(v4 + v300) = v303;
        ++v299;
        *(_BYTE *)(v4 + 260) = v303;
        if ( v299 == "" )
          break;
        v300 = v302;
      }
      return (char *)sub_C89F4(v4, v472, v301[1]);
    case 68:
      v311 = "{lambda(";
      v312 = *(_DWORD *)(v4 + 256);
      v313 = a3;
      while ( 1 )
      {
        v315 = *v311;
        if ( v312 == 255 )
        {
          v316 = *(_DWORD *)(v4 + 268);
          v317 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v317(v4, 255, v316);
          ++*(_DWORD *)(v4 + 288);
          v314 = 1;
          v312 = 0;
        }
        else
        {
          v314 = v312 + 1;
        }
        *(_DWORD *)(v4 + 256) = v314;
        *(_BYTE *)(v4 + v312) = v315;
        ++v311;
        *(_BYTE *)(v4 + 260) = v315;
        if ( v311 == "" )
          break;
        v312 = v314;
      }
      sub_C89F4(v4, v472, v313[1]);
      v325 = *(_DWORD *)(v4 + 256);
      v326 = ")#";
      while ( 1 )
      {
        v328 = *v326;
        if ( v325 == 255 )
        {
          v329 = *(_DWORD *)(v4 + 268);
          v330 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v330(v4, 255, v329);
          ++*(_DWORD *)(v4 + 288);
          v327 = 1;
          v325 = 0;
        }
        else
        {
          v327 = v325 + 1;
        }
        *(_DWORD *)(v4 + 256) = v327;
        *(_BYTE *)(v4 + v325) = v328;
        ++v326;
        *(_BYTE *)(v4 + 260) = v328;
        if ( v326 == "" )
          break;
        v325 = v327;
      }
      sprintf(s, "%ld", v313[2] + 1);
      result = (char *)strlen(s);
      if ( result )
      {
        v331 = 0;
        v332 = *(_DWORD *)(v4 + 256);
        v333 = result;
        while ( 1 )
        {
          result = s;
          v335 = s[(_DWORD)v331];
          if ( v332 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            v336 = *(_DWORD *)(v4 + 268);
            result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
            ++*(_DWORD *)(v4 + 288);
            v334 = 1;
            v332 = 0;
          }
          else
          {
            v334 = v332 + 1;
          }
          *(_DWORD *)(v4 + 256) = v334;
          *(_BYTE *)(v4 + v332) = v335;
          ++v331;
          *(_BYTE *)(v4 + 260) = v335;
          if ( v331 == v333 )
            break;
          v332 = v334;
        }
      }
      else
      {
        v334 = *(_DWORD *)(v4 + 256);
      }
      if ( v334 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v413 = 1;
        ++*(_DWORD *)(v4 + 288);
        v334 = 0;
      }
      else
      {
        v413 = v334 + 1;
      }
      *(_DWORD *)(v4 + 256) = v413;
      *(_BYTE *)(v4 + v334) = 125;
      *(_BYTE *)(v4 + 260) = 125;
      return result;
    case 70:
      v286 = "{unnamed type#";
      v287 = *(_DWORD *)(v4 + 256);
      v288 = a3;
      while ( 1 )
      {
        v290 = *v286;
        if ( v287 == 255 )
        {
          v291 = *(_DWORD *)(v4 + 268);
          v292 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v292(v4, 255, v291);
          ++*(_DWORD *)(v4 + 288);
          v289 = 1;
          v287 = 0;
        }
        else
        {
          v289 = v287 + 1;
        }
        *(_DWORD *)(v4 + 256) = v289;
        *(_BYTE *)(v4 + v287) = v290;
        ++v286;
        *(_BYTE *)(v4 + 260) = v290;
        if ( v286 == "" )
          break;
        v287 = v289;
      }
      sprintf(s, "%ld", v288[1] + 1);
      result = (char *)strlen(s);
      if ( result )
      {
        v345 = 0;
        v346 = *(_DWORD *)(v4 + 256);
        v347 = result;
        while ( 1 )
        {
          result = s;
          v349 = s[(_DWORD)v345];
          if ( v346 == 255 )
          {
            *(_BYTE *)(v4 + 255) = 0;
            v350 = *(_DWORD *)(v4 + 268);
            result = (char *)(*(int (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
            ++*(_DWORD *)(v4 + 288);
            v348 = 1;
            v346 = 0;
          }
          else
          {
            v348 = v346 + 1;
          }
          *(_DWORD *)(v4 + 256) = v348;
          *(_BYTE *)(v4 + v346) = v349;
          ++v345;
          *(_BYTE *)(v4 + 260) = v349;
          if ( v345 == v347 )
            break;
          v346 = v348;
        }
      }
      else
      {
        v348 = *(_DWORD *)(v4 + 256);
      }
      if ( v348 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v414 = 1;
        ++*(_DWORD *)(v4 + 288);
        v348 = 0;
      }
      else
      {
        v414 = v348 + 1;
      }
      *(_DWORD *)(v4 + 256) = v414;
      *(_BYTE *)(v4 + v348) = 125;
      *(_BYTE *)(v4 + 260) = 125;
      return result;
    case 71:
      v293 = "transaction clone for ";
      v294 = *(_DWORD *)(v4 + 256);
      v295 = a3;
      while ( 1 )
      {
        v297 = *v293;
        if ( v294 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v298 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v296 = 1;
          v294 = 0;
        }
        else
        {
          v296 = v294 + 1;
        }
        *(_DWORD *)(v4 + 256) = v296;
        *(_BYTE *)(v4 + v294) = v297;
        ++v293;
        *(_BYTE *)(v4 + 260) = v297;
        if ( v293 == "" )
          break;
        v294 = v296;
      }
      return (char *)sub_C89F4(v4, v472, v295[1]);
    case 72:
      v181 = "non-transaction clone for ";
      v182 = *(_DWORD *)(v4 + 256);
      v183 = a3;
      while ( 1 )
      {
        v185 = *v181;
        if ( v182 == 255 )
        {
          *(_BYTE *)(v4 + 255) = 0;
          v186 = *(_DWORD *)(v4 + 268);
          (*(void (__fastcall **)(int, signed int))(v4 + 264))(v4, 255);
          ++*(_DWORD *)(v4 + 288);
          v184 = 1;
          v182 = 0;
        }
        else
        {
          v184 = v182 + 1;
        }
        *(_DWORD *)(v4 + 256) = v184;
        *(_BYTE *)(v4 + v182) = v185;
        ++v181;
        *(_BYTE *)(v4 + 260) = v185;
        if ( v181 == "" )
          break;
        v182 = v184;
      }
      return (char *)sub_C89F4(v4, v472, v183[1]);
    case 73:
      result = (char *)sub_C3FD0(v4, (_DWORD *)a3[1]);
      if ( !result )
      {
        sub_C99F4(v4, v472, (int *)v5[1]);
        return (char *)sub_C5A48(v4, "...");
      }
      v172 = 0;
      while ( *(_DWORD *)result == 47 && *((_DWORD *)result + 1) )
      {
        result = (char *)*((_DWORD *)result + 2);
        ++v172;
        if ( !result )
        {
          v173 = v172;
          v476 = v5[1];
          goto LABEL_223;
        }
      }
      v173 = v172;
      v476 = v5[1];
      if ( !v172 )
        return result;
LABEL_223:
      v174 = 0;
      v477 = v173;
      do
      {
        *(_DWORD *)(v4 + 284) = v174;
        result = (char *)sub_C89F4(v4, v472, v476);
        if ( v174 < v173 - 1 )
        {
          v175 = *(_DWORD *)(v4 + 256);
          v176 = ", ";
          while ( 1 )
          {
            v178 = *v176;
            if ( v175 == 255 )
            {
              v179 = *(_DWORD *)(v4 + 268);
              v180 = *(int (__fastcall **)(int, signed int, int))(v4 + 264);
              *(_BYTE *)(v4 + 255) = 0;
              result = (char *)v180(v4, 255, v179);
              ++*(_DWORD *)(v4 + 288);
              v177 = 1;
              v175 = 0;
            }
            else
            {
              v177 = v175 + 1;
            }
            *(_DWORD *)(v4 + 256) = v177;
            *(_BYTE *)(v4 + v175) = v178;
            ++v176;
            *(_BYTE *)(v4 + 260) = v178;
            if ( v176 == "" )
              break;
            v175 = v177;
          }
        }
        ++v174;
      }
      while ( v174 != v477 );
      return result;
    case 74:
      v166 = "[abi:";
      sub_C89F4(v4, a2, a3[1]);
      for ( l = *(_DWORD *)(v4 + 256); ; l = v168 )
      {
        v169 = *v166;
        if ( l == 255 )
        {
          v170 = *(_DWORD *)(v4 + 268);
          v171 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v171(v4, 255, v170);
          ++*(_DWORD *)(v4 + 288);
          v168 = 1;
          l = 0;
        }
        else
        {
          v168 = l + 1;
        }
        *(_DWORD *)(v4 + 256) = v168;
        *(_BYTE *)(v4 + l) = v169;
        ++v166;
        *(_BYTE *)(v4 + 260) = v169;
        if ( v166 == "" )
          break;
      }
      result = (char *)sub_C89F4(v4, v472, v5[2]);
      v324 = *(_DWORD *)(v4 + 256);
      if ( v324 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v447 = 1;
        ++*(_DWORD *)(v4 + 288);
        v324 = 0;
      }
      else
      {
        v447 = v324 + 1;
      }
      *(_DWORD *)(v4 + 256) = v447;
      *(_BYTE *)(v4 + v324) = 93;
      *(_BYTE *)(v4 + 260) = 93;
      return result;
    case 75:
      sub_C89F4(v4, a2, a3[1]);
      v147 = " [clone ";
      for ( m = *(_DWORD *)(v4 + 256); ; m = v149 )
      {
        v150 = *v147;
        if ( m == 255 )
        {
          v151 = *(_DWORD *)(v4 + 268);
          v152 = *(void (__fastcall **)(int, signed int, int))(v4 + 264);
          *(_BYTE *)(v4 + 255) = 0;
          v152(v4, 255, v151);
          ++*(_DWORD *)(v4 + 288);
          v149 = 1;
          m = 0;
        }
        else
        {
          v149 = m + 1;
        }
        *(_DWORD *)(v4 + 256) = v149;
        *(_BYTE *)(v4 + m) = v150;
        ++v147;
        *(_BYTE *)(v4 + 260) = v150;
        if ( v147 == "" )
          break;
      }
      result = (char *)sub_C89F4(v4, v472, v5[2]);
      v323 = *(_DWORD *)(v4 + 256);
      if ( v323 == 255 )
      {
        *(_BYTE *)(v4 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
        v427 = 1;
        ++*(_DWORD *)(v4 + 288);
        v323 = 0;
      }
      else
      {
        v427 = v323 + 1;
      }
      *(_DWORD *)(v4 + 256) = v427;
      *(_BYTE *)(v4 + v323) = 93;
      *(_BYTE *)(v4 + 260) = 93;
      return result;
    default:
      *(_DWORD *)(v4 + 280) = 1;
      return result;
  }
}
// 0: using guessed type int dword_0;
// 100: using guessed type int dword_100;
// 104: using guessed type int dword_104;
// 114: using guessed type int dword_114;
// EFB54: using guessed type char *off_EFB54;

//----- (000C89F4) --------------------------------------------------------
int __fastcall sub_C89F4(int result, int a2, int a3)
{
  if ( a3 )
  {
    if ( !*(_DWORD *)(result + 280) )
      result = (int)sub_C5AD0(result, a2, (int *)a3);
  }
  else
  {
    *(_DWORD *)(result + 280) = 1;
  }
  return result;
}

//----- (000C8A14) --------------------------------------------------------
char *__fastcall sub_C8A14(int a1, int a2, _DWORD *a3)
{
  int v3; // r4
  char *result; // r0
  int v5; // r9
  _DWORD *v6; // r6
  const char *v7; // r5
  int ii; // r3
  int v9; // r1
  char v10; // r7
  int *v11; // r2
  const char *v12; // r5
  int i; // r3
  int v14; // r2
  char v15; // r6
  const char *v16; // r5
  int j; // r3
  int v18; // r2
  char v19; // r6
  const char *v20; // r5
  int k; // r3
  int v22; // r2
  char v23; // r6
  int v24; // r2
  int v25; // r2
  const char *v26; // r5
  int v27; // r2
  char v28; // r6
  int v29; // r3
  int v30; // r2
  const char *v31; // r5
  int l; // r3
  int v33; // r2
  char v34; // r6
  const char *v35; // r5
  int m; // r3
  int v37; // r2
  char v38; // r6
  int v39; // r3
  int *v40; // r2
  const char *v41; // r5
  int n; // r3
  int v43; // r2
  char v44; // r6
  int *v45; // r2
  int v46; // r2
  int v47; // r1
  int v48; // r3
  int v49; // r1
  int v50; // r3
  int v51; // r1
  int v52; // r1

  v3 = a1;
  result = (char *)(*a3 - 3);
  v5 = a2;
  v6 = a3;
  switch ( *a3 )
  {
    case 3:
      v11 = (int *)a3[1];
      if ( !v11 )
        goto LABEL_55;
      goto LABEL_13;
    case 0x19:
    case 0x1C:
      v12 = " restrict";
      for ( i = *(_DWORD *)(v3 + 256); ; i = v14 )
      {
        v15 = *v12;
        if ( i == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v14 = 1;
          i = 0;
        }
        else
        {
          v14 = i + 1;
        }
        *(_DWORD *)(v3 + 256) = v14;
        *(_BYTE *)(v3 + i) = v15;
        ++v12;
        *(_BYTE *)(v3 + 260) = v15;
        if ( v12 == "" )
          break;
      }
      return result;
    case 0x1A:
    case 0x1D:
      v16 = " volatile";
      for ( j = *(_DWORD *)(v3 + 256); ; j = v18 )
      {
        v19 = *v16;
        if ( j == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v18 = 1;
          j = 0;
        }
        else
        {
          v18 = j + 1;
        }
        *(_DWORD *)(v3 + 256) = v18;
        *(_BYTE *)(v3 + j) = v19;
        ++v16;
        *(_BYTE *)(v3 + 260) = v19;
        if ( v16 == "" )
          break;
      }
      return result;
    case 0x1B:
    case 0x1E:
      v20 = " const";
      for ( k = *(_DWORD *)(v3 + 256); ; k = v22 )
      {
        v23 = *v20;
        if ( k == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v22 = 1;
          k = 0;
        }
        else
        {
          v22 = k + 1;
        }
        *(_DWORD *)(v3 + 256) = v22;
        *(_BYTE *)(v3 + k) = v23;
        ++v20;
        *(_BYTE *)(v3 + 260) = v23;
        if ( v20 == "" )
          break;
      }
      return result;
    case 0x1F:
      v24 = *(_DWORD *)(v3 + 256);
      if ( v24 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v48 = 1;
        v24 = 0;
      }
      else
      {
        v48 = v24 + 1;
      }
      *(_DWORD *)(v3 + 256) = v48;
      *(_BYTE *)(v3 + v24) = 32;
      *(_BYTE *)(v3 + 260) = 32;
      goto LABEL_37;
    case 0x20:
      v25 = *(_DWORD *)(v3 + 256);
      if ( v25 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        ++*(_DWORD *)(v3 + 288);
        v50 = 1;
        v25 = 0;
      }
      else
      {
        v50 = v25 + 1;
      }
      *(_DWORD *)(v3 + 256) = v50;
      *(_BYTE *)(v3 + v25) = 32;
      *(_BYTE *)(v3 + 260) = 32;
      goto LABEL_45;
    case 0x21:
      v29 = *(_DWORD *)(v3 + 256);
      if ( v29 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        v49 = 1;
        ++*(_DWORD *)(v3 + 288);
        v29 = 0;
      }
      else
      {
        v49 = v29 + 1;
      }
      *(_DWORD *)(v3 + 256) = v49;
      *(_BYTE *)(v3 + v29) = 32;
      *(_BYTE *)(v3 + 260) = 32;
      v11 = (int *)v6[2];
      if ( v11 )
      {
LABEL_13:
        if ( !*(_DWORD *)(v3 + 280) )
          result = sub_C5AD0(v3, v5, v11);
      }
      else
      {
LABEL_55:
        *(_DWORD *)(v3 + 280) = 1;
      }
      break;
    case 0x22:
      if ( !(a2 & 4) )
      {
        v30 = *(_DWORD *)(v3 + 256);
        if ( v30 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          v52 = 1;
          ++*(_DWORD *)(v3 + 288);
          v30 = 0;
        }
        else
        {
          v52 = v30 + 1;
        }
        *(_DWORD *)(v3 + 256) = v52;
        *(_BYTE *)(v3 + v30) = 42;
        *(_BYTE *)(v3 + 260) = 42;
      }
      break;
    case 0x23:
      v48 = *(_DWORD *)(v3 + 256);
LABEL_37:
      if ( v48 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        v47 = 1;
        ++*(_DWORD *)(v3 + 288);
        v48 = 0;
      }
      else
      {
        v47 = v48 + 1;
      }
      *(_DWORD *)(v3 + 256) = v47;
      *(_BYTE *)(v3 + v48) = 38;
      *(_BYTE *)(v3 + 260) = 38;
      break;
    case 0x24:
      v50 = *(_DWORD *)(v3 + 256);
LABEL_45:
      v26 = "&&";
      while ( 1 )
      {
        v28 = *v26;
        if ( v50 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v27 = 1;
          v50 = 0;
        }
        else
        {
          v27 = v50 + 1;
        }
        *(_DWORD *)(v3 + 256) = v27;
        *(_BYTE *)(v3 + v50) = v28;
        ++v26;
        *(_BYTE *)(v3 + 260) = v28;
        if ( v26 == "" )
          break;
        v50 = v27;
      }
      break;
    case 0x25:
      v31 = "complex ";
      for ( l = *(_DWORD *)(v3 + 256); ; l = v33 )
      {
        v34 = *v31;
        if ( l == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v33 = 1;
          l = 0;
        }
        else
        {
          v33 = l + 1;
        }
        *(_DWORD *)(v3 + 256) = v33;
        *(_BYTE *)(v3 + l) = v34;
        ++v31;
        *(_BYTE *)(v3 + 260) = v34;
        if ( v31 == "" )
          break;
      }
      break;
    case 0x26:
      v35 = "imaginary ";
      for ( m = *(_DWORD *)(v3 + 256); ; m = v37 )
      {
        v38 = *v35;
        if ( m == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v37 = 1;
          m = 0;
        }
        else
        {
          v37 = m + 1;
        }
        *(_DWORD *)(v3 + 256) = v37;
        *(_BYTE *)(v3 + m) = v38;
        ++v35;
        *(_BYTE *)(v3 + 260) = v38;
        if ( v35 == "" )
          break;
      }
      break;
    case 0x2B:
      if ( *(_BYTE *)(v3 + 260) != 40 )
      {
        v39 = *(_DWORD *)(v3 + 256);
        if ( v39 == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          v51 = 1;
          ++*(_DWORD *)(v3 + 288);
          v39 = 0;
        }
        else
        {
          v51 = v39 + 1;
        }
        *(_DWORD *)(v3 + 256) = v51;
        *(_BYTE *)(v3 + v39) = 32;
        *(_BYTE *)(v3 + 260) = 32;
      }
      v40 = (int *)v6[1];
      if ( v40 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
          result = sub_C5AD0(v3, v5, v40);
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      v41 = "::*";
      for ( n = *(_DWORD *)(v3 + 256); ; n = v43 )
      {
        v44 = *v41;
        if ( n == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v43 = 1;
          n = 0;
        }
        else
        {
          v43 = n + 1;
        }
        *(_DWORD *)(v3 + 256) = v43;
        *(_BYTE *)(v3 + n) = v44;
        ++v41;
        *(_BYTE *)(v3 + 260) = v44;
        if ( v41 == "" )
          break;
      }
      break;
    case 0x2D:
      v7 = " __vector(";
      for ( ii = *(_DWORD *)(v3 + 256); ; ii = v9 )
      {
        v10 = *v7;
        if ( ii == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          v9 = 1;
          ++*(_DWORD *)(v3 + 288);
          ii = 0;
        }
        else
        {
          v9 = ii + 1;
        }
        *(_DWORD *)(v3 + 256) = v9;
        *(_BYTE *)(v3 + ii) = v10;
        ++v7;
        *(_BYTE *)(v3 + 260) = v10;
        if ( v7 == "" )
          break;
      }
      v45 = (int *)v6[1];
      if ( v45 )
      {
        if ( !*(_DWORD *)(v3 + 280) )
        {
          result = sub_C5AD0(v3, v5, v45);
          v9 = *(_DWORD *)(v3 + 256);
        }
      }
      else
      {
        *(_DWORD *)(v3 + 280) = 1;
      }
      if ( v9 == 255 )
      {
        *(_BYTE *)(v3 + 255) = 0;
        result = (char *)(*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
        v9 = 0;
        ++*(_DWORD *)(v3 + 288);
        v46 = 1;
      }
      else
      {
        v46 = v9 + 1;
      }
      *(_DWORD *)(v3 + 256) = v46;
      *(_BYTE *)(v3 + v9) = 41;
      *(_BYTE *)(v3 + 260) = 41;
      break;
    default:
      if ( !*(_DWORD *)(v3 + 280) )
        result = sub_C5AD0(v3, a2, a3);
      break;
  }
  return result;
}

//----- (000C9088) --------------------------------------------------------
int __fastcall sub_C9088(int result, int a2, int *a3, int a4)
{
  int v4; // r11
  int v5; // r5
  int *v6; // r4
  int v7; // r9
  int *v8; // r2
  int v9; // r3
  int v10; // r8
  int v11; // r3
  int v12; // r9
  int v13; // r3
  const char *v14; // r6
  int v15; // r2
  char v16; // r7
  int v17; // r1
  _DWORD *v18; // r4
  int v19; // r3
  const char *v20; // r6
  _DWORD *v21; // r10
  int i; // r3
  int v23; // r2
  char v24; // r7
  size_t v25; // r0
  int v26; // r2
  int v27; // r6
  size_t v28; // r4
  int v29; // r3
  char v30; // r7
  const char *v31; // r6
  int v32; // r2
  char v33; // r7
  char s; // [sp+2Ch] [bp-44h]

  v4 = a2;
  v5 = result;
  v6 = a3;
  v7 = a4;
  if ( !a3 || *(_DWORD *)(result + 280) )
    return result;
  while ( v6[2] )
  {
LABEL_9:
    v6 = (int *)*v6;
    if ( !v6 || *(_DWORD *)(v5 + 280) )
      return result;
  }
  if ( v7 )
  {
    v8 = (int *)v6[1];
    v9 = *v8;
    v6[2] = 1;
    v10 = *(_DWORD *)(v5 + 272);
    *(_DWORD *)(v5 + 272) = v6[3];
    if ( v9 == 41 )
    {
LABEL_14:
      result = sub_C9568(v5, v4, v8 + 2, (int *)*v6);
      *(_DWORD *)(v5 + 272) = v10;
      return result;
    }
  }
  else
  {
    v8 = (int *)v6[1];
    v9 = *v8;
    if ( (unsigned int)(*v8 - 28) <= 4 )
      goto LABEL_9;
    v6[2] = 1;
    v10 = *(_DWORD *)(v5 + 272);
    *(_DWORD *)(v5 + 272) = v6[3];
    if ( v9 == 41 )
      goto LABEL_14;
  }
  if ( v9 == 42 )
  {
    result = sub_C9390(v5, v4, v8 + 1, *v6);
    *(_DWORD *)(v5 + 272) = v10;
    return result;
  }
  if ( v9 != 2 )
  {
    result = (int)sub_C8A14(v5, v4, v8);
    *(_DWORD *)(v5 + 272) = v10;
    goto LABEL_9;
  }
  v11 = *(_DWORD *)(v5 + 276);
  *(_DWORD *)(v5 + 276) = 0;
  v12 = v11;
  sub_C89F4(v5, v4, v8[1]);
  *(_DWORD *)(v5 + 276) = v12;
  v13 = *(_DWORD *)(v5 + 256);
  if ( v4 & 4 )
  {
    if ( v13 == 255 )
    {
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      v17 = 1;
      ++*(_DWORD *)(v5 + 288);
      v13 = 0;
    }
    else
    {
      v17 = v13 + 1;
    }
    *(_DWORD *)(v5 + 256) = v17;
    *(_BYTE *)(v5 + v13) = 46;
    *(_BYTE *)(v5 + 260) = 46;
  }
  else
  {
    v14 = "::";
    while ( 1 )
    {
      v16 = *v14;
      if ( v13 == 255 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        v15 = 1;
        v13 = 0;
      }
      else
      {
        v15 = v13 + 1;
      }
      *(_DWORD *)(v5 + 256) = v15;
      *(_BYTE *)(v5 + v13) = v16;
      ++v14;
      *(_BYTE *)(v5 + 260) = v16;
      if ( v14 == "" )
        break;
      v13 = v15;
    }
  }
  v18 = *(_DWORD **)(v6[1] + 8);
  v19 = *v18;
  if ( *v18 != 69 )
    goto LABEL_30;
  v20 = "{default arg#";
  v21 = v18;
  for ( i = *(_DWORD *)(v5 + 256); ; i = v23 )
  {
    v24 = *v20;
    if ( i == 255 )
    {
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      v23 = 1;
      i = 0;
    }
    else
    {
      v23 = i + 1;
    }
    *(_DWORD *)(v5 + 256) = v23;
    *(_BYTE *)(v5 + i) = v24;
    ++v20;
    *(_BYTE *)(v5 + 260) = v24;
    if ( v20 == "" )
      break;
  }
  sprintf(&s, "%ld", v18[2] + 1);
  v25 = strlen(&s);
  if ( v25 )
  {
    v26 = *(_DWORD *)(v5 + 256);
    v27 = 0;
    v28 = v25;
    while ( 1 )
    {
      v30 = *(&s + v27);
      if ( v26 == 255 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        v29 = 1;
        v26 = 0;
      }
      else
      {
        v29 = v26 + 1;
      }
      *(_DWORD *)(v5 + 256) = v29;
      *(_BYTE *)(v5 + v26) = v30;
      ++v27;
      *(_BYTE *)(v5 + 260) = v30;
      if ( v27 == v28 )
        break;
      v26 = v29;
    }
    v18 = v21;
  }
  else
  {
    v29 = *(_DWORD *)(v5 + 256);
  }
  v31 = "}::";
  while ( 1 )
  {
    v33 = *v31;
    if ( v29 == 255 )
    {
      *(_BYTE *)(v5 + 255) = 0;
      (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      v32 = 1;
      v29 = 0;
    }
    else
    {
      v32 = v29 + 1;
    }
    *(_DWORD *)(v5 + 256) = v32;
    *(_BYTE *)(v5 + v29) = v33;
    ++v31;
    *(_BYTE *)(v5 + 260) = v33;
    if ( v31 == "" )
      break;
    v29 = v32;
  }
  do
  {
    v18 = (_DWORD *)v18[1];
    v19 = *v18;
LABEL_30:
    ;
  }
  while ( (unsigned int)(v19 - 28) <= 4 );
  result = sub_C89F4(v5, v4, (int)v18);
  *(_DWORD *)(v5 + 272) = v10;
  return result;
}

//----- (000C9390) --------------------------------------------------------
int __fastcall sub_C9390(int result, int a2, int *a3, int a4)
{
  int v4; // r10
  int v5; // r4
  int *v6; // r11
  int *v7; // r8
  int v8; // r3
  const char *v9; // r5
  int i; // r3
  int v11; // r2
  char v12; // r6
  int v13; // ST04_4
  int v14; // r2
  int v15; // r2
  int v16; // r1
  int v17; // r3

  v4 = a2;
  v5 = result;
  v6 = a3;
  v7 = (int *)a4;
  if ( a4 )
  {
    while ( *(_DWORD *)(a4 + 8) )
    {
      a4 = *(_DWORD *)a4;
      if ( !a4 )
      {
        result = sub_C9088(result, a2, v7, 0);
        goto LABEL_5;
      }
    }
    if ( **(_DWORD **)(a4 + 4) == 42 )
    {
      result = sub_C9088(result, a2, v7, 0);
      v15 = *(_DWORD *)(v5 + 256);
      goto LABEL_10;
    }
    v9 = " (";
    for ( i = *(_DWORD *)(result + 256); ; i = v11 )
    {
      v12 = *v9;
      if ( i == 255 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        v13 = *(_DWORD *)(v5 + 268);
        (*(void (__fastcall **)(int, signed int))(v5 + 264))(v5, 255);
        ++*(_DWORD *)(v5 + 288);
        v11 = 1;
        i = 0;
      }
      else
      {
        v11 = i + 1;
      }
      *(_DWORD *)(v5 + 256) = v11;
      *(_BYTE *)(v5 + i) = v12;
      ++v9;
      *(_BYTE *)(v5 + 260) = v12;
      if ( v9 == "" )
        break;
    }
    result = sub_C9088(v5, v4, v7, 0);
    v14 = *(_DWORD *)(v5 + 256);
    if ( v14 == 255 )
    {
      *(_BYTE *)(v5 + 255) = 0;
      result = (*(int (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
      ++*(_DWORD *)(v5 + 288);
      v8 = 1;
      v14 = 0;
    }
    else
    {
      v8 = v14 + 1;
    }
    *(_DWORD *)(v5 + 256) = v8;
    *(_BYTE *)(v5 + v14) = 41;
    *(_BYTE *)(v5 + 260) = 41;
  }
  else
  {
LABEL_5:
    v8 = *(_DWORD *)(v5 + 256);
  }
  if ( v8 == 255 )
  {
    *(_BYTE *)(v5 + 255) = 0;
    result = (*(int (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    ++*(_DWORD *)(v5 + 288);
    v15 = 1;
    v8 = 0;
  }
  else
  {
    v15 = v8 + 1;
  }
  *(_DWORD *)(v5 + 256) = v15;
  *(_BYTE *)(v5 + v8) = 32;
  *(_BYTE *)(v5 + 260) = 32;
LABEL_10:
  if ( v15 == 255 )
  {
    *(_BYTE *)(v5 + 255) = 0;
    result = (*(int (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    ++*(_DWORD *)(v5 + 288);
    v17 = 1;
    v15 = 0;
  }
  else
  {
    v17 = v15 + 1;
  }
  *(_DWORD *)(v5 + 256) = v17;
  *(_BYTE *)(v5 + v15) = 91;
  *(_BYTE *)(v5 + 260) = 91;
  if ( *v6 )
  {
    result = sub_C89F4(v5, v4, *v6);
    v17 = *(_DWORD *)(v5 + 256);
  }
  if ( v17 == 255 )
  {
    *(_BYTE *)(v5 + 255) = 0;
    result = (*(int (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    v16 = 1;
    ++*(_DWORD *)(v5 + 288);
    v17 = 0;
  }
  else
  {
    v16 = v17 + 1;
  }
  *(_DWORD *)(v5 + 256) = v16;
  *(_BYTE *)(v5 + v17) = 93;
  *(_BYTE *)(v5 + 260) = 93;
  return result;
}

//----- (000C9568) --------------------------------------------------------
int __fastcall sub_C9568(int a1, int a2, _DWORD *a3, int *a4)
{
  int v4; // r8
  int v5; // r6
  int **v6; // r9
  int *v7; // r7
  int *v8; // r4
  unsigned int v9; // r5
  int v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r4
  int v14; // r2
  int v15; // r3
  int v16; // r1
  int result; // r0
  int v18; // r3
  int v19; // r3

  v4 = a2;
  v5 = a1;
  v6 = (int **)a3;
  v7 = a4;
  if ( a4 && !a4[2] )
  {
    v8 = a4;
    while ( 1 )
    {
      v9 = *(_DWORD *)v8[1] - 25;
      if ( v9 <= 0x12 )
      {
        if ( (1 << v9) & 0x43107 )
        {
          v10 = *(unsigned __int8 *)(a1 + 260);
          goto LABEL_10;
        }
        if ( (1 << v9) & 0xE00 )
          break;
      }
      v8 = (int *)*v8;
      if ( !v8 || v8[2] )
        goto LABEL_16;
    }
    v10 = *(unsigned __int8 *)(a1 + 260);
    if ( (v10 & 0xFFFFFFFD) != 40 )
    {
LABEL_10:
      if ( v10 != 32 )
      {
        v11 = *(_DWORD *)(a1 + 256);
        if ( v11 == 255 )
        {
          *(_BYTE *)(a1 + 255) = 0;
          (*(void (__fastcall **)(int, signed int, _DWORD))(a1 + 264))(a1, 255, *(_DWORD *)(a1 + 268));
          ++*(_DWORD *)(v5 + 288);
          v19 = 1;
          v11 = 0;
        }
        else
        {
          v19 = v11 + 1;
        }
        *(_DWORD *)(v5 + 256) = v19;
        *(_BYTE *)(v5 + v11) = 32;
        *(_BYTE *)(v5 + 260) = 32;
        if ( v19 != 255 )
          goto LABEL_27;
        goto LABEL_15;
      }
    }
    v19 = *(_DWORD *)(a1 + 256);
    if ( v19 != 255 )
    {
LABEL_27:
      v12 = v19 + 1;
LABEL_28:
      *(_DWORD *)(v5 + 256) = v12;
      *(_BYTE *)(v5 + v19) = 40;
      *(_BYTE *)(v5 + 260) = 40;
      v13 = *(_DWORD *)(v5 + 276);
      *(_DWORD *)(v5 + 276) = 0;
      sub_C9088(v5, v4, v7, 0);
      v18 = *(_DWORD *)(v5 + 256);
      if ( v18 == 255 )
      {
        *(_BYTE *)(v5 + 255) = 0;
        (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
        ++*(_DWORD *)(v5 + 288);
        v14 = 1;
        v18 = 0;
      }
      else
      {
        v14 = v18 + 1;
      }
      *(_DWORD *)(v5 + 256) = v14;
      *(_BYTE *)(v5 + v18) = 41;
      *(_BYTE *)(v5 + 260) = 41;
      if ( v14 == 255 )
        goto LABEL_31;
      goto LABEL_17;
    }
LABEL_15:
    *(_BYTE *)(v5 + v19) = 0;
    (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    ++*(_DWORD *)(v5 + 288);
    v12 = 1;
    v19 = 0;
    goto LABEL_28;
  }
LABEL_16:
  v13 = *(_DWORD *)(a1 + 276);
  *(_DWORD *)(a1 + 276) = 0;
  sub_C9088(a1, a2, a4, 0);
  v14 = *(_DWORD *)(v5 + 256);
  if ( v14 == 255 )
  {
LABEL_31:
    *(_BYTE *)(v5 + v14) = 0;
    (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    ++*(_DWORD *)(v5 + 288);
    v15 = 1;
    v14 = 0;
    goto LABEL_18;
  }
LABEL_17:
  v15 = v14 + 1;
LABEL_18:
  *(_DWORD *)(v5 + 256) = v15;
  *(_BYTE *)(v5 + v14) = 40;
  *(_BYTE *)(v5 + 260) = 40;
  if ( *v6 && !*(_DWORD *)(v5 + 280) )
  {
    sub_C5AD0(v5, v4, *v6);
    v15 = *(_DWORD *)(v5 + 256);
    if ( v15 != 255 )
      goto LABEL_21;
LABEL_24:
    *(_BYTE *)(v5 + v15) = 0;
    (*(void (__fastcall **)(int, signed int, _DWORD))(v5 + 264))(v5, 255, *(_DWORD *)(v5 + 268));
    v16 = 1;
    ++*(_DWORD *)(v5 + 288);
    v15 = 0;
    goto LABEL_22;
  }
  if ( v15 == 255 )
    goto LABEL_24;
LABEL_21:
  v16 = v15 + 1;
LABEL_22:
  *(_DWORD *)(v5 + 256) = v16;
  *(_BYTE *)(v5 + v15) = 41;
  *(_BYTE *)(v5 + 260) = 41;
  result = sub_C9088(v5, v4, v7, 1);
  *(_DWORD *)(v5 + 276) = v13;
  return result;
}

//----- (000C9790) --------------------------------------------------------
_DWORD *__fastcall sub_C9790(_DWORD *result, int a2, _DWORD *a3)
{
  int *v3; // r5
  int *v4; // r2
  int v5; // r6
  _DWORD *v6; // r4
  int v7; // r8
  int v8; // r3
  int v9; // r2
  int *v10; // r2
  int v11; // r2
  int v12; // r3
  int *v13; // r2
  int v14; // r1
  int v15; // r1
  int v16; // r3
  int v17; // [sp+0h] [bp-28h]
  int v18; // [sp+4h] [bp-24h]

  v3 = a3;
  v4 = (int *)*a3;
  v5 = a2;
  v6 = result;
  if ( *v4 == 4 )
  {
    v7 = result[69];
    result[69] = 0;
    v8 = result[68];
    result[68] = &v17;
    v9 = *v3;
    v18 = v9;
    v10 = *(int **)(v9 + 4);
    v17 = v8;
    if ( v10 )
    {
      if ( !result[70] )
      {
        result = sub_C5AD0((int)result, a2, v10);
        v8 = v17;
      }
    }
    else
    {
      result[70] = 1;
    }
    v6[68] = v8;
    if ( *((_BYTE *)v6 + 260) == 60 )
    {
      v16 = v6[64];
      if ( v16 == 255 )
      {
        *((_BYTE *)v6 + 255) = 0;
        result = (_DWORD *)((int (__fastcall *)(_DWORD *, signed int, _DWORD))v6[66])(v6, 255, v6[67]);
        ++v6[72];
        v11 = 1;
        v16 = 0;
      }
      else
      {
        v11 = v16 + 1;
      }
      v6[64] = v11;
      *((_BYTE *)v6 + v16) = 32;
      *((_BYTE *)v6 + 260) = 32;
    }
    else
    {
      v11 = v6[64];
    }
    if ( v11 == 255 )
    {
      *((_BYTE *)v6 + 255) = 0;
      result = (_DWORD *)((int (__fastcall *)(_DWORD *, signed int, _DWORD))v6[66])(v6, 255, v6[67]);
      ++v6[72];
      v12 = 1;
      v11 = 0;
    }
    else
    {
      v12 = v11 + 1;
    }
    v6[64] = v12;
    *((_BYTE *)v6 + v11) = 60;
    *((_BYTE *)v6 + 260) = 60;
    v13 = *(int **)(*v3 + 8);
    if ( v13 )
    {
      if ( !v6[70] )
      {
        result = sub_C5AD0((int)v6, v5, v13);
        v12 = v6[64];
        if ( *((_BYTE *)v6 + 260) == 62 )
        {
          if ( v12 == 255 )
          {
            *((_BYTE *)v6 + 255) = 0;
            result = (_DWORD *)((int (__fastcall *)(_DWORD *, signed int, _DWORD))v6[66])(v6, 255, v6[67]);
            v15 = 1;
            ++v6[72];
            v12 = 0;
          }
          else
          {
            v15 = v12 + 1;
          }
          v6[64] = v15;
          *((_BYTE *)v6 + v12) = 32;
          *((_BYTE *)v6 + 260) = 32;
          v12 = v15;
        }
      }
    }
    else
    {
      v6[70] = 1;
    }
    if ( v12 == 255 )
    {
      *((_BYTE *)v6 + 255) = 0;
      result = (_DWORD *)((int (__fastcall *)(_DWORD *, signed int, _DWORD))v6[66])(v6, 255, v6[67]);
      v14 = 1;
      ++v6[72];
      v12 = 0;
    }
    else
    {
      v14 = v12 + 1;
    }
    v6[64] = v14;
    *((_BYTE *)v6 + v12) = 62;
    *((_BYTE *)v6 + 260) = 62;
    v6[69] = v7;
  }
  else if ( !result[70] )
  {
    result = sub_C5AD0((int)result, a2, v4);
  }
  return result;
}

//----- (000C9950) --------------------------------------------------------
int __fastcall sub_C9950(int result, int a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r3
  int v5; // r7
  int v6; // r8
  int v7; // r5
  int i; // r3
  int v9; // r2
  char v10; // r6

  v3 = result;
  if ( *a3 == 49 )
  {
    v4 = a3[1];
    v5 = *(_DWORD *)(v4 + 8);
    v6 = *(_DWORD *)(v4 + 4);
    if ( v5 )
    {
      v7 = 0;
      for ( i = *(_DWORD *)(result + 256); ; i = v9 )
      {
        v10 = *(_BYTE *)(v6 + v7);
        if ( i == 255 )
        {
          *(_BYTE *)(v3 + 255) = 0;
          result = (*(int (__fastcall **)(int, signed int, _DWORD))(v3 + 264))(v3, 255, *(_DWORD *)(v3 + 268));
          ++*(_DWORD *)(v3 + 288);
          v9 = 1;
          i = 0;
        }
        else
        {
          v9 = i + 1;
        }
        *(_DWORD *)(v3 + 256) = v9;
        *(_BYTE *)(v3 + i) = v10;
        ++v7;
        *(_BYTE *)(v3 + 260) = v10;
        if ( v5 == v7 )
          break;
      }
    }
  }
  else if ( !*(_DWORD *)(result + 280) )
  {
    result = (int)sub_C5AD0(result, a2, a3);
  }
  return result;
}

//----- (000C99F4) --------------------------------------------------------
int __fastcall sub_C99F4(int result, int a2, int *a3)
{
  int v3; // r3
  int v4; // r4
  int v5; // r7
  int *v6; // r5
  bool v7; // r2
  signed int v8; // r6
  int v9; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2

  v3 = *a3;
  v4 = result;
  v5 = a2;
  v6 = a3;
  if ( (unsigned int)*a3 <= 1 || (v7 = (unsigned int)(v3 - 48) <= 0) != 0 || v3 == 6 )
  {
    v8 = 1;
    if ( !*(_DWORD *)(result + 280) )
      goto LABEL_10;
  }
  else
  {
    v9 = *(_DWORD *)(result + 256);
    if ( v9 == 255 )
    {
      *(_BYTE *)(result + 255) = v7;
      v13 = *(_DWORD *)(result + 268);
      result = (*(int (**)(void))(result + 264))();
      ++*(_DWORD *)(v4 + 288);
      v10 = 1;
      v9 = 0;
    }
    else
    {
      v10 = v9 + 1;
    }
    *(_DWORD *)(v4 + 256) = v10;
    *(_BYTE *)(v4 + v9) = 40;
    *(_BYTE *)(v4 + 260) = 40;
    v8 = 0;
    if ( !*(_DWORD *)(v4 + 280) )
    {
LABEL_10:
      result = (int)sub_C5AD0(v4, v5, v6);
      if ( v8 )
        return result;
      goto LABEL_11;
    }
  }
  if ( v8 )
    return result;
LABEL_11:
  v11 = *(_DWORD *)(v4 + 256);
  if ( v11 == 255 )
  {
    *(_BYTE *)(v4 + 255) = v8;
    result = (*(int (__fastcall **)(int, signed int, _DWORD))(v4 + 264))(v4, 255, *(_DWORD *)(v4 + 268));
    v12 = 1;
    ++*(_DWORD *)(v4 + 288);
    v11 = 0;
  }
  else
  {
    v12 = v11 + 1;
  }
  *(_DWORD *)(v4 + 256) = v12;
  *(_BYTE *)(v4 + v11) = 41;
  *(_BYTE *)(v4 + 260) = 41;
  return result;
}

//----- (000C9AC0) --------------------------------------------------------
bool __fastcall sub_C9AC0(char *s1, void (__fastcall *a2)(int *), int a3)
{
  char *v3; // r5
  int v4; // r0
  void (__fastcall *v5)(int *); // r8
  int v6; // r10
  unsigned int v7; // r6
  int v8; // r3
  size_t v9; // r0
  int v10; // r3
  int v11; // r2
  int v12; // r0
  int *v13; // r0
  char *v14; // r5
  int *v15; // r11
  int v16; // r3
  _BOOL4 v17; // r5
  char *v19; // r3
  int v20; // r2
  int v21; // r3
  int *v22; // r0
  _DWORD *v23; // r2
  int v24; // [sp+0h] [bp+0h]
  int v25; // [sp+4h] [bp+4h]
  char *v26; // [sp+8h] [bp+8h]
  int v27; // [sp+Ch] [bp+Ch]
  int v28; // [sp+10h] [bp+10h]
  char *s; // [sp+14h] [bp+14h]
  int *v30; // [sp+18h] [bp+18h]
  int v31; // [sp+1Ch] [bp+1Ch]
  int v32; // [sp+20h] [bp+20h]
  int *v33; // [sp+24h] [bp+24h]
  int v34; // [sp+28h] [bp+28h]
  size_t v35; // [sp+2Ch] [bp+2Ch]
  int v36; // [sp+30h] [bp+30h]
  int v37; // [sp+34h] [bp+34h]
  int v38; // [sp+38h] [bp+38h]
  int v39; // [sp+3Ch] [bp+3Ch]
  int v40; // [sp+13Ch] [bp+13Ch]
  char v41; // [sp+140h] [bp+140h]
  void (__fastcall *v42)(int *); // [sp+144h] [bp+144h]
  int v43; // [sp+148h] [bp+148h]
  int v44; // [sp+14Ch] [bp+14Ch]
  int v45; // [sp+150h] [bp+150h]
  unsigned int v46; // [sp+154h] [bp+154h]
  int v47; // [sp+158h] [bp+158h]
  int v48; // [sp+15Ch] [bp+15Ch]

  v3 = s1;
  v4 = (unsigned __int8)*s1;
  v5 = a2;
  v25 = a3;
  v6 = v4;
  if ( v4 != 95 || v3[1] != 90 )
  {
    v7 = 0;
    if ( !strncmp(v3, "_GLOBAL_", 8u) )
    {
      v8 = (unsigned __int8)v3[8];
      if ( v8 == 46 || v8 == 95 || v8 == 36 )
      {
        if ( (unsigned int)(unsigned __int8)v3[9] - 73 <= 0 || (v7 = 0, v3[9] == 68) )
        {
          v7 = 0;
          if ( v3[10] == 95 )
            v7 = ((unsigned __int8)((unsigned int)(unsigned __int8)v3[9] - 73 <= 0) <= 0u) + 2;
        }
      }
    }
  }
  else
  {
    v7 = 1;
  }
  v9 = strlen(v3);
  v26 = v3;
  s = v3;
  v10 = (int)&v3[v9];
  v11 = 2 * v9;
  v35 = v9;
  v9 *= 4;
  v27 = v10;
  v32 = v11;
  v28 = 17;
  v31 = 0;
  v34 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v30 = &v24 - (v9 + v11) - 2;
  v33 = &v24 - 2 * ((v9 + 10) >> 3);
  if ( v7 == 1 )
  {
    if ( v6 != 95 )
    {
      v16 = v6;
      v15 = 0;
      goto LABEL_23;
    }
    s = v3 + 1;
    v16 = (unsigned __int8)v3[1];
    if ( v16 != 90 )
    {
      v15 = 0;
      goto LABEL_23;
    }
    s = v3 + 2;
    v15 = sub_C4D70((int)&v26, 1);
    if ( v28 & 1 )
    {
      v19 = s;
      v20 = (unsigned __int8)*s;
      if ( v20 != 46 )
      {
LABEL_38:
        v16 = v20;
        goto LABEL_23;
      }
      while ( 1 )
      {
        v21 = (unsigned __int8)v19[1];
        if ( ((v21 - 97) & 0xFFu) > 0x19 && v21 != 95 && ((v21 - 48) & 0xFFu) > 9 )
          break;
        v22 = sub_C3B08(&v26, (int)v15);
        v19 = s;
        v20 = (unsigned __int8)*s;
        v15 = v22;
        if ( v20 != 46 )
          goto LABEL_38;
      }
    }
    v16 = (unsigned __int8)*s;
    goto LABEL_23;
  }
  if ( v7 && v7 <= 3 )
  {
    s = v3 + 11;
    if ( v3[11] != 95 || v3[12] != 90 )
    {
      v12 = strlen(v3 + 11);
      v23 = sub_C39B4(&v26, (unsigned int)(v3 + 11), v12);
    }
    else
    {
      s = v3 + 13;
      v23 = sub_C4D70((int)&v26, 0);
    }
    v13 = sub_C3918((int)&v26, ((__PAIR__(v7 - 2, v7 - 2) - __PAIR__(v7 - 3, 1)) >> 32) + 66, (int)v23, 0);
    v14 = s;
    v15 = v13;
    s = &v14[strlen(s)];
    v16 = (unsigned __int8)*s;
  }
  else
  {
    v15 = sub_C4568((int)&v26);
    v16 = (unsigned __int8)*s;
  }
LABEL_23:
  v17 = 0;
  if ( !v16 )
  {
    if ( v15 )
    {
      v40 = 0;
      v41 = 0;
      v44 = 0;
      v45 = 0;
      v47 = 0;
      v48 = 0;
      v42 = v5;
      v43 = v25;
      v46 = 0;
      sub_C5AD0((int)&v39, 17, v15);
      *((_BYTE *)&v39 + v40) = 0;
      v42(&v39);
      v17 = v46 <= 0;
    }
    else
    {
      v17 = 0;
    }
  }
  return v17;
}

//----- (000C9CF8) --------------------------------------------------------
char *__fastcall _cxa_demangle(char *a1, void *a2, signed int *a3, _DWORD *a4)
{
  void *v4; // r5
  signed int *v5; // r6
  _DWORD *v6; // r4
  char *result; // r0
  signed int v8; // r8
  char *v9; // r7
  size_t v10; // r0
  signed int v11; // r3
  char *s; // [sp+0h] [bp-28h]
  int v13; // [sp+4h] [bp-24h]
  int v14; // [sp+8h] [bp-20h]
  int v15; // [sp+Ch] [bp-1Ch]

  v4 = a2;
  v5 = a3;
  v6 = a4;
  if ( !a1 || a2 && !a3 )
  {
    if ( a4 )
    {
      result = 0;
      *a4 = -3;
      return result;
    }
    return 0;
  }
  s = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  if ( !sub_C9AC0(a1, (void (__fastcall *)(int *))sub_C4058, (int)&s) )
  {
    free(s);
    if ( !v6 )
      return 0;
LABEL_18:
    v11 = 2;
LABEL_19:
    *v6 = -v11;
    return 0;
  }
  v8 = 1;
  if ( !v15 )
    v8 = v14;
  v9 = s;
  if ( !s )
  {
    if ( !v6 )
      return 0;
    v11 = v8;
    if ( v8 == 1 )
      goto LABEL_19;
    goto LABEL_18;
  }
  if ( !v4 )
  {
    if ( !v5 )
      goto LABEL_14;
    goto LABEL_22;
  }
  v10 = strlen(s);
  if ( v10 >= *v5 )
  {
    free(v4);
LABEL_22:
    *v5 = v8;
    goto LABEL_14;
  }
  memcpy(v4, v9, v10 + 1);
  free(v9);
  v9 = (char *)v4;
LABEL_14:
  if ( v6 )
    *v6 = 0;
  return v9;
}

//----- (000C9DBC) --------------------------------------------------------
signed int __fastcall _gcclibcxx_demangle_callback(char *a1, void (__fastcall *a2)(int *), int a3)
{
  _BOOL4 v3; // r3
  signed int result; // r0

  if ( !a1 || !a2 )
    return -3;
  v3 = sub_C9AC0(a1, a2, a3);
  result = 0;
  if ( !v3 )
    result = -2;
  return result;
}

//----- (000C9DE0) --------------------------------------------------------
int _cxa_current_exception_type()
{
  int result; // r0

  result = *_cxa_get_globals();
  if ( result )
  {
    if ( *(_BYTE *)(result + 39) == 1 )
      result = *(_DWORD *)result - 120;
    result = *(_DWORD *)result;
  }
  return result;
}

//----- (000C9DFC) --------------------------------------------------------
void __fastcall ares_cancel(_DWORD *a1)
{
  _DWORD *v1; // r5
  _DWORD *v2; // r4
  int *v3; // r2
  int *v4; // r6
  int v5; // r9
  _BOOL4 v6; // r0
  int i; // r5
  int v8; // [sp+Ch] [bp-2Ch]
  int *v9; // [sp+10h] [bp-28h]

  v1 = a1 + 99;
  v2 = a1;
  if ( !ares__is_list_empty(a1 + 99) )
  {
    v3 = (int *)v2[100];
    v8 = v2[99];
    v9 = v3;
    *(_DWORD *)(v8 + 4) = &v8;
    *v9 = (int)&v8;
    v4 = v9;
    v2[99] = v1;
    v2[100] = v1;
    while ( v4 != &v8 )
    {
      v5 = v4[2];
      v4 = (int *)v4[1];
      (*(void (__fastcall **)(_DWORD, signed int))(v5 + 76))(*(_DWORD *)(v5 + 80), 24);
      ares__free_query(v5);
    }
  }
  if ( !(*v2 & 0x10) )
  {
    v6 = ares__is_list_empty(v1);
    if ( v6 && v2[29] )
    {
      for ( i = 0; i < v2[30]; ++i )
        ares__close_sockets(v2, (int *)(v2[29] + 80 * i));
    }
  }
}

//----- (000C9E92) --------------------------------------------------------
void __fastcall ares_destroy_options(_DWORD *a1)
{
  _DWORD *v1; // r4
  void *v2; // r0
  int v3; // r5
  _DWORD *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0

  v1 = a1;
  v2 = (void *)a1[7];
  if ( v2 )
    free(v2);
  v3 = 0;
  while ( 1 )
  {
    v4 = (_DWORD *)v1[9];
    if ( v3 >= v1[10] )
      break;
    v5 = (void *)v4[v3++];
    free(v5);
  }
  if ( v4 )
    free(v4);
  v6 = (void *)v1[14];
  if ( v6 )
    free(v6);
  v7 = (void *)v1[11];
  if ( v7 )
    j_free(v7);
}

//----- (000C9ED0) --------------------------------------------------------
void __fastcall ares__destroy_servers_state(int a1)
{
  int v1; // r4
  int i; // r5

  v1 = a1;
  if ( *(_DWORD *)(a1 + 116) )
  {
    for ( i = 0; i < *(_DWORD *)(v1 + 120); ++i )
      ares__close_sockets((_DWORD *)v1, (int *)(*(_DWORD *)(v1 + 116) + 80 * i));
    free(*(void **)(v1 + 116));
    *(_DWORD *)(v1 + 116) = 0;
  }
  *(_DWORD *)(v1 + 120) = -1;
}

//----- (000C9F04) --------------------------------------------------------
void __fastcall ares_destroy(int a1)
{
  int v1; // r4
  int v2; // r5
  int v3; // r9
  int v4; // r6
  int v5; // r5
  void *v6; // r0
  void *v7; // r0
  void *v8; // r0

  v1 = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 400);
    v3 = a1 + 396;
    while ( v2 != v3 )
    {
      v4 = *(_DWORD *)(v2 + 8);
      v2 = *(_DWORD *)(v2 + 4);
      (*(void (__fastcall **)(_DWORD, signed int))(v4 + 76))(*(_DWORD *)(v4 + 80), 16);
      ares__free_query(v4);
    }
    ares__destroy_servers_state(v1);
    if ( *(_DWORD *)(v1 + 36) )
    {
      v5 = 0;
      while ( v5 < *(_DWORD *)(v1 + 40) )
      {
        v6 = *(void **)(*(_DWORD *)(v1 + 36) + 4 * v5++);
        free(v6);
      }
      free(*(void **)(v1 + 36));
    }
    v7 = *(void **)(v1 + 44);
    if ( v7 )
      free(v7);
    v8 = *(void **)(v1 + 52);
    if ( v8 )
      free(v8);
    j_free((void *)v1);
  }
}

//----- (000C9F82) --------------------------------------------------------
int __fastcall ares_fds(int a1, int a2, int a3)
{
  int v3; // r6
  int v4; // r4
  int v5; // r5
  int v6; // r7
  _BOOL4 v7; // r0
  int v8; // r3
  _DWORD *v9; // r8
  int v10; // r2
  int v11; // r2
  int v12; // r2
  int v13; // r2

  v3 = a1;
  v4 = 0;
  v5 = a2;
  v6 = a3;
  v7 = ares__is_list_empty((_DWORD *)(a1 + 396));
  v8 = 0;
  while ( v4 < *(_DWORD *)(v3 + 120) )
  {
    v9 = (_DWORD *)(*(_DWORD *)(v3 + 116) + 80 * v4);
    if ( !v7 )
    {
      v10 = v9[5];
      if ( v10 != -1 )
      {
        *(_DWORD *)(v5 + 4 * (v10 >> 5)) |= 1 << (v10 & 0x1F);
        v11 = v9[5];
        if ( v11 >= v8 )
          v8 = v11 + 1;
      }
    }
    v12 = v9[6];
    if ( v12 != -1 )
    {
      *(_DWORD *)(v5 + 4 * (v12 >> 5)) |= 1 << (v12 & 0x1F);
      if ( v9[12] )
        *(_DWORD *)(v6 + 4 * (v9[6] >> 5)) |= 1 << (v9[6] & 0x1F);
      v13 = v9[6];
      if ( v13 >= v8 )
        v8 = v13 + 1;
    }
    ++v4;
  }
  return v8;
}

//----- (000CA030) --------------------------------------------------------
void __fastcall sub_CA030(int a1, int a2, void **a3)
{
  void **v3; // r5
  void *v4; // r4

  v3 = a3;
  v4 = (void *)a1;
  (*(void (__fastcall **)(_DWORD, int, _DWORD, void **))(a1 + 24))(*(_DWORD *)(a1 + 28), a2, *(_DWORD *)(a1 + 36), a3);
  if ( v3 )
    ares_free_hostent(v3);
  j_free(v4);
}

//----- (000CA054) --------------------------------------------------------
void __fastcall sub_CA054(int a1)
{
  unsigned __int8 *v1; // r9
  int v2; // r10
  int v3; // r4
  unsigned __int8 *v4; // r6
  void **v5; // r2
  void **v6; // t1
  unsigned int v7; // r3
  unsigned int v8; // r9
  size_t v9; // r0
  unsigned int v10; // r10
  int v11; // r0
  int v12; // r1
  int v13; // r2
  FILE *v14; // r7
  void **v15; // r5
  int v16; // r3
  signed int v17; // r6
  const void *v18; // r1
  size_t v19; // r2
  const void *v20; // r0
  int v21; // r0
  int v22; // r1
  int v23; // [sp+38h] [bp-B0h]
  char s[128]; // [sp+3Ch] [bp-ACh]

  v1 = *(unsigned __int8 **)(a1 + 32);
  v2 = a1 + 8;
  v3 = a1;
  while ( 1 )
  {
    v4 = v1;
    v6 = (void **)*v1++;
    v5 = v6;
    if ( !v6 )
      break;
    if ( v5 == (void **)((char *)&dword_60 + 2) )
    {
      if ( *(_DWORD *)(v3 + 4) == 2 )
      {
        v7 = bswap32(*(_DWORD *)(v3 + 8));
        sprintf(
          s,
          "%lu.%lu.%lu.%lu.in-addr.arpa",
          (unsigned __int8)v7,
          (unsigned __int16)v7 >> 8,
          (v7 >> 16) & 0xFF,
          v7 >> 24);
      }
      else
      {
        v8 = *(unsigned __int8 *)(v3 + 22);
        sprintf(
          s,
          "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.",
          *(_BYTE *)(v3 + 23) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 23) >> 4,
          v8 & 0xF,
          v8 >> 4,
          *(_BYTE *)(v3 + 21) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 21) >> 4,
          *(_BYTE *)(v3 + 20) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 20) >> 4,
          *(_BYTE *)(v3 + 19) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 19) >> 4,
          *(_BYTE *)(v3 + 18) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 18) >> 4,
          *(_BYTE *)(v3 + 17) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 17) >> 4,
          *(_BYTE *)(v3 + 16) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 16) >> 4);
        v9 = strlen(s);
        v10 = *(unsigned __int8 *)(v3 + 14);
        sprintf(
          &s[v9],
          "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa",
          *(_BYTE *)(v3 + 15) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 15) >> 4,
          v10 & 0xF,
          v10 >> 4,
          *(_BYTE *)(v3 + 13) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 13) >> 4,
          *(_BYTE *)(v3 + 12) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 12) >> 4,
          *(_BYTE *)(v3 + 11) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 11) >> 4,
          *(_BYTE *)(v3 + 10) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 10) >> 4,
          *(_BYTE *)(v3 + 9) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 9) >> 4,
          *(_BYTE *)(v3 + 8) & 0xF,
          (unsigned int)*(unsigned __int8 *)(v3 + 8) >> 4);
      }
      v11 = *(_DWORD *)v3;
      *(_DWORD *)(v3 + 32) = v4 + 1;
      ares_query(v11, s, 1, 12, (int (__fastcall *)(int, signed int))sub_CA298, v3);
      return;
    }
    if ( v5 != (void **)((char *)&dword_64 + 2) )
      continue;
    v14 = fopen("/etc/hosts", "r");
    if ( !v14 )
    {
      if ( (unsigned int)(*(_DWORD *)_errno(0, v12, v13) - 2) > 1 )
        v23 = 0;
      continue;
    }
    while ( 1 )
    {
      v17 = ares__get_hostent((int)v14, *(_DWORD *)(v3 + 4), (unsigned int *)&v23);
      if ( v17 )
        break;
      v15 = (void **)v23;
      v16 = *(_DWORD *)(v3 + 4);
      if ( v16 != *(_DWORD *)(v23 + 8) )
        goto LABEL_14;
      if ( v16 == 2 )
      {
        v18 = (const void *)v2;
        v19 = 4;
        v20 = **(const void ***)(v23 + 16);
      }
      else
      {
        if ( v16 != 10 )
          goto LABEL_14;
        v18 = (const void *)v2;
        v19 = 16;
        v20 = **(const void ***)(v23 + 16);
      }
      if ( !memcmp(v20, v18, v19) )
        break;
LABEL_14:
      ares_free_hostent(v15);
    }
    fclose(v14);
    if ( v17 != 13 && !v17 )
    {
      v21 = v3;
      v22 = 0;
      v5 = (void **)v23;
      goto LABEL_27;
    }
    v23 = 0;
  }
  v21 = v3;
  v22 = 4;
LABEL_27:
  sub_CA030(v21, v22, v5);
}
// 60: using guessed type int dword_60;
// 64: using guessed type int dword_64;
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// CA054: using guessed type char s[128];

//----- (000CA298) --------------------------------------------------------
void __fastcall sub_CA298(int a1, int a2, int a3, unsigned __int8 *a4, int a5)
{
  int v5; // r4
  void *v6; // r2
  signed int v7; // r0
  void **v8; // r2
  unsigned __int8 *v9; // [sp+Ch] [bp-14h]

  v9 = a4;
  v5 = a1;
  *(_DWORD *)(a1 + 36) += a3;
  if ( !a2 )
  {
    v6 = (void *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 4) == 2 )
      v7 = ares_parse_ptr_reply(a4, a5, v6, 4u, 2, (char **)&v9);
    else
      v7 = ares_parse_ptr_reply(a4, a5, v6, 0x10u, 10, (char **)&v9);
    v8 = (void **)v9;
    a2 = v7;
    a1 = v5;
    goto LABEL_8;
  }
  if ( a2 == 16 )
  {
    v8 = 0;
LABEL_8:
    sub_CA030(a1, a2, v8);
    return;
  }
  sub_CA054(a1);
}

//----- (000CA2EA) --------------------------------------------------------
void __fastcall ares_gethostbyaddr(int a1, _DWORD *a2, int a3, int a4, void (__fastcall *a5)(int, signed int), int a6)
{
  int v6; // r8
  _DWORD *v7; // r4
  int v8; // r5
  int v9; // r0
  signed int v10; // r1
  bool v11; // zf
  _DWORD *v12; // r0
  _DWORD *v13; // r2
  _DWORD *v14; // r12
  int v15; // r9
  int v16; // r0
  int v17; // r1

  v6 = a1;
  v7 = a2;
  v8 = a4;
  if ( a4 == 2 )
  {
    v11 = a3 == 4;
  }
  else
  {
    if ( a4 != 10 )
    {
LABEL_3:
      v9 = a6;
      v10 = 5;
LABEL_10:
      a5(v9, v10);
      return;
    }
    v11 = a3 == 16;
  }
  if ( !v11 )
    goto LABEL_3;
  v12 = malloc(0x28u);
  v13 = v12;
  if ( !v12 )
  {
    v9 = a6;
    v10 = 15;
    goto LABEL_10;
  }
  *v12 = v6;
  if ( v8 == 2 )
  {
    v12[2] = *v7;
  }
  else
  {
    v14 = v12 + 2;
    v15 = (int)(v7 + 4);
    do
    {
      v16 = *v7;
      v7 += 2;
      v17 = *(v7 - 1);
      *v14 = v16;
      v14[1] = v17;
      v14 += 2;
    }
    while ( v7 != (_DWORD *)v15 );
  }
  v13[1] = v8;
  v13[6] = a5;
  v13[7] = a6;
  v13[8] = *(_DWORD *)(v6 + 52);
  v13[9] = 0;
  sub_CA054((int)v13);
}

//----- (000CA368) --------------------------------------------------------
int __fastcall sub_CA368(unsigned __int8 *a1, int a2, int a3)
{
  unsigned __int8 *v3; // r6
  int v4; // r7
  int v5; // r4
  int v6; // r5

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = 0;
  while ( v6 < v4 )
  {
    if ( *(_DWORD *)(v5 + 32) == 2 )
    {
      if ( *(_WORD *)(v5 + 36) == 1 )
      {
        if ( (*(_DWORD *)(v5 + 16) & *(_DWORD *)v3) == *(_DWORD *)v5 )
          return v6;
      }
      else if ( !ares__bitncmp(v3, (unsigned __int8 *)v5, *(unsigned __int16 *)(v5 + 16)) )
      {
        return v6;
      }
    }
    ++v6;
    v5 += 40;
  }
  return v6;
}

//----- (000CA3A6) --------------------------------------------------------
int __fastcall sub_CA3A6(unsigned __int8 *a1, int a2, int a3)
{
  unsigned __int8 *v3; // r7
  int v4; // r6
  int v5; // r4
  int v6; // r5

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = 0;
  while ( v6 < v4
       && (*(_DWORD *)(v5 + 32) != 10 || ares__bitncmp(v3, (unsigned __int8 *)v5, *(unsigned __int16 *)(v5 + 16))) )
  {
    ++v6;
    v5 += 40;
  }
  return v6;
}

//----- (000CA3D0) --------------------------------------------------------
void __fastcall sub_CA3D0(int a1, int a2, void **a3)
{
  void **v3; // r5
  void **v4; // r4

  v3 = a3;
  v4 = (void **)a1;
  (*(void (__fastcall **)(_DWORD, int, _DWORD, void **))(a1 + 8))(*(_DWORD *)(a1 + 12), a2, *(_DWORD *)(a1 + 28), a3);
  if ( v3 )
    ares_free_hostent(v3);
  free(v4[1]);
  j_free(v4);
}

//----- (000CA3F8) --------------------------------------------------------
signed int __fastcall sub_CA3F8(const char *a1, unsigned int a2, unsigned int *a3)
{
  const char *v3; // r8
  unsigned int v4; // r10
  unsigned int *v5; // r6
  int v6; // r1
  int v7; // r2
  FILE *v8; // r5
  unsigned int v10; // r7
  int v11; // r9
  const char *v12; // r0
  const char *v13; // t1
  signed int v14; // r4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v8 = fopen("/etc/hosts", "r");
  if ( v8 )
  {
    while ( 1 )
    {
      v14 = ares__get_hostent((int)v8, v4, v5);
      if ( v14 )
        break;
      v10 = *v5;
      if ( !strcasecmp(*(const char **)*v5, v3) )
        break;
      v11 = *(_DWORD *)(v10 + 4) - 4;
      while ( 1 )
      {
        v13 = *(const char **)(v11 + 4);
        v11 += 4;
        v12 = v13;
        if ( !v13 )
          break;
        if ( !strcasecmp(v12, v3) )
          goto LABEL_12;
      }
      ares_free_hostent((void **)v10);
    }
LABEL_12:
    fclose(v8);
    if ( v14 == 13 )
    {
      v14 = 4;
    }
    else if ( !v14 )
    {
      return v14;
    }
    *v5 = 0;
    return v14;
  }
  if ( (unsigned int)(*(_DWORD *)_errno(0, v6, v7) - 2) <= 1 )
    return 4;
  *v5 = 0;
  return 14;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000CA48C) --------------------------------------------------------
void __fastcall sub_CA48C(int a1, int a2)
{
  unsigned __int8 *v2; // r5
  int v3; // r4
  int v4; // r6
  unsigned __int8 *v5; // r3
  void **v6; // r2
  void **v7; // t1
  int v8; // r3
  int v9; // r0
  char *v10; // r1
  int v11; // r1
  int v12; // r0
  void **v13; // [sp+Ch] [bp+0h]

  v2 = *(unsigned __int8 **)(a1 + 24);
  v3 = a1;
  v4 = a2;
  while ( 1 )
  {
    v5 = v2;
    v7 = (void **)*v2++;
    v6 = v7;
    if ( !v7 )
    {
      v12 = v3;
      v11 = v4;
      goto LABEL_14;
    }
    if ( v6 == (void **)((char *)&dword_60 + 2) )
      break;
    if ( v6 == (void **)((char *)&dword_64 + 2) )
    {
      v11 = sub_CA3F8(*(const char **)(v3 + 4), *(_DWORD *)(v3 + 20), (unsigned int *)&v13);
      if ( !v11 )
      {
        v12 = v3;
        v6 = v13;
LABEL_14:
        sub_CA3D0(v12, v11, v6);
        return;
      }
    }
  }
  *(_DWORD *)(v3 + 24) = v5 + 1;
  v8 = *(_DWORD *)(v3 + 20);
  if ( v8 != 10 && v8 )
  {
    v9 = *(_DWORD *)v3;
    v10 = *(char **)(v3 + 4);
    *(_DWORD *)(v3 + 16) = 2;
    ares_search(v9, v10, 1, 1, (int)sub_CA510, v3);
  }
  else
  {
    *(_DWORD *)(v3 + 16) = 10;
    ares_search(*(_DWORD *)v3, *(char **)(v3 + 4), 1, 28, (int)sub_CA510, v3);
  }
}
// 60: using guessed type int dword_60;
// 64: using guessed type int dword_64;

//----- (000CA510) --------------------------------------------------------
int __fastcall sub_CA510(int a1, int a2, int a3, unsigned __int8 *a4, int a5)
{
  int v5; // r4
  unsigned __int8 *v6; // r0
  int v7; // r5
  int v8; // r7
  int v9; // r9
  int v10; // r3
  signed int v11; // r0
  int v12; // r6
  int v13; // r11
  unsigned __int8 *v14; // r3
  int v15; // r8
  int *v16; // r2
  int v17; // r7
  unsigned __int8 *v18; // ST08_4
  int v19; // r0
  int v20; // r12
  int v21; // ST0C_4
  int v22; // r0
  _DWORD *v23; // r2
  signed int v24; // r0
  int result; // r0
  int v26; // r6
  int v27; // r5
  int v28; // r10
  int *v29; // r3
  char *v30; // r2
  int v31; // r12
  char *v32; // r11
  int v33; // r0
  int v34; // r1
  int v35; // r8
  char *v36; // lr
  int *v37; // r3
  int v38; // r12
  int v39; // r0
  int v40; // r1
  char *v41; // lr
  int v42; // r2
  int v43; // r1
  bool v44; // zf
  int v45; // r2
  int v46; // r1
  int v47; // r0
  void **v48; // r2
  unsigned __int8 *v49; // [sp+8h] [bp-70h]
  int v50; // [sp+10h] [bp-68h]
  int v51; // [sp+10h] [bp-68h]
  int v52; // [sp+14h] [bp-64h]
  int v53; // [sp+18h] [bp-60h]
  void **v54; // [sp+20h] [bp-58h]
  int v55; // [sp+24h] [bp-54h]
  char v56; // [sp+28h] [bp-50h]
  char v57; // [sp+2Ch] [bp-4Ch]
  char v58; // [sp+3Ch] [bp-3Ch]
  int v59; // [sp+4Ch] [bp-2Ch]

  v5 = a1;
  v6 = a4;
  v7 = 0;
  v8 = *(_DWORD *)v5;
  v9 = a2;
  v54 = 0;
  *(_DWORD *)(v5 + 28) += a3;
  if ( a2 )
  {
    if ( a2 != 1 && a2 != 10 && a2 != 12 || *(_DWORD *)(v5 + 16) != 10 || *(_DWORD *)(v5 + 20) )
    {
      v47 = v5;
      if ( a2 == 16 )
      {
        v48 = 0;
        goto LABEL_46;
      }
      sub_CA48C(v5, a2);
    }
    else
    {
      *(_DWORD *)(v5 + 16) = 2;
      ares_search(v8, *(char **)(v5 + 4), 1, 1, (int)sub_CA510, v5);
    }
  }
  else
  {
    v10 = *(_DWORD *)(v5 + 16);
    if ( v10 == 2 )
    {
      v11 = ares_parse_a_reply(v6, a5, &v54, 0, 0);
      v12 = (int)v54;
      v9 = v11;
      if ( v54 )
      {
        v13 = *(_DWORD *)(v8 + 48);
        if ( v13 )
        {
          v14 = (unsigned __int8 *)&v56;
          v50 = *(_DWORD *)(v8 + 44);
          while ( 1 )
          {
            v15 = 4 * v7;
            v16 = *(int **)(*(_DWORD *)(v12 + 16) + 4 * v7);
            if ( !v16 )
              break;
            v17 = v7 - 1;
            v55 = *v16;
            v18 = v14;
            v19 = sub_CA368((unsigned __int8 *)&v55, v50, v13);
            v14 = v18;
            v20 = v19;
            while ( v17 != -1 )
            {
              *(_DWORD *)v14 = **(_DWORD **)(*(_DWORD *)(v12 + 16) + v15 - 4);
              v49 = v14;
              v21 = v20;
              v22 = sub_CA368(v14, v50, v13);
              v20 = v21;
              v14 = v49;
              if ( v22 <= v21 )
                break;
              --v17;
              v23 = *(_DWORD **)(*(_DWORD *)(v12 + 16) + v15);
              v15 -= 4;
              *v23 = *(_DWORD *)v49;
            }
            ++v7;
            **(_DWORD **)(*(_DWORD *)(v12 + 16) + 4 * (v17 + 1)) = v55;
          }
        }
      }
      goto LABEL_36;
    }
    if ( v10 != 10 )
    {
LABEL_36:
      v47 = v5;
      a2 = v9;
      v48 = v54;
LABEL_46:
      sub_CA3D0(v47, a2, v48);
      return result;
    }
    v24 = ares_parse_aaaa_reply(v6, a5, &v54, 0, 0);
    v9 = v24;
    if ( v24 != 1 && v24 != 10 || *(_DWORD *)(v5 + 20) )
    {
      v26 = (int)v54;
      if ( v54 )
      {
        v51 = *(_DWORD *)(v8 + 48);
        if ( v51 )
        {
          v27 = 0;
          v52 = *(_DWORD *)(v8 + 44);
          while ( 1 )
          {
            v28 = 4 * v27;
            v29 = *(int **)(*(_DWORD *)(v26 + 16) + 4 * v27);
            if ( !v29 )
              break;
            v30 = &v57;
            v31 = (int)(v29 + 4);
            v32 = &v57;
            do
            {
              v33 = *v29;
              v29 += 2;
              v34 = *(v29 - 1);
              *(_DWORD *)v30 = v33;
              *((_DWORD *)v30 + 1) = v34;
              v30 += 8;
            }
            while ( v29 != (int *)v31 );
            v35 = v27 - 1;
            v53 = sub_CA3A6((unsigned __int8 *)&v57, v52, v51);
            while ( v35 != -1 )
            {
              v36 = &v58;
              v37 = *(int **)(*(_DWORD *)(v26 + 16) + v28 - 4);
              v38 = (int)(v37 + 4);
              do
              {
                v39 = *v37;
                v37 += 2;
                v40 = *(v37 - 1);
                *(_DWORD *)v36 = v39;
                *((_DWORD *)v36 + 1) = v40;
                v36 += 8;
              }
              while ( v37 != (int *)v38 );
              if ( sub_CA3A6((unsigned __int8 *)&v58, v52, v51) <= v53 )
                break;
              v41 = &v58;
              v42 = *(_DWORD *)(*(_DWORD *)(v26 + 16) + v28);
              do
              {
                v42 += 8;
                v43 = *((_DWORD *)v41 + 1);
                v44 = v41 + 8 == (char *)&v59;
                *(_DWORD *)(v42 - 8) = *(_DWORD *)v41;
                v41 += 8;
                *(_DWORD *)(v42 - 4) = v43;
              }
              while ( !v44 );
              --v35;
              v28 -= 4;
            }
            v45 = *(_DWORD *)(*(_DWORD *)(v26 + 16) + 4 * (v35 + 1));
            do
            {
              v45 += 8;
              v46 = *((_DWORD *)v32 + 1);
              v44 = v32 + 8 == &v58;
              *(_DWORD *)(v45 - 8) = *(_DWORD *)v32;
              v32 += 8;
              *(_DWORD *)(v45 - 4) = v46;
            }
            while ( !v44 );
            ++v27;
          }
        }
      }
      goto LABEL_36;
    }
    *(_DWORD *)(v5 + 16) = 2;
    ares_search(*(_DWORD *)v5, *(char **)(v5 + 4), 1, 1, (int)sub_CA510, v5);
  }
  return result;
}

//----- (000CA758) --------------------------------------------------------
void __fastcall ares_gethostbyname(int a1, char *cp, int a3, int a4, int a5)
{
  void (__fastcall *v5)(int, signed int); // r6
  int v6; // r5
  int v7; // r9
  char *v8; // r8
  int v9; // r0
  signed int v10; // r1
  int v11; // r2
  char *v12; // r1
  int v13; // r3
  int v14; // t1
  _DWORD *v15; // r0
  _DWORD *v16; // r4
  int v17; // r0
  char *v18; // r0
  int v19; // [sp+0h] [bp-58h]
  in_addr_t v20; // [sp+4h] [bp-54h]
  in_addr_t *v21; // [sp+8h] [bp-50h]
  int v22; // [sp+Ch] [bp-4Ch]
  void *ptr; // [sp+10h] [bp-48h]
  int *v24; // [sp+14h] [bp-44h]
  int v25; // [sp+18h] [bp-40h]
  int v26; // [sp+1Ch] [bp-3Ch]
  int *v27; // [sp+20h] [bp-38h]
  char v28; // [sp+24h] [bp-34h]

  v5 = (void (__fastcall *)(int, signed int))a4;
  v6 = a3;
  v7 = a1;
  v8 = cp;
  if ( (unsigned int)a3 > 0xA || !((1 << a3) & 0x405) )
  {
    v9 = a5;
    v10 = 5;
    goto LABEL_22;
  }
  v11 = 0;
  v19 = 0;
  if ( (v6 & 0xFFFFFFF7) != 2 )
  {
LABEL_13:
    v15 = malloc(0x20u);
    v16 = v15;
    if ( v15 )
    {
      *v15 = v7;
      v18 = strdup(v8);
      v16[5] = v6;
      v16[4] = -1;
      v16[1] = v18;
      if ( v18 )
      {
        v16[2] = v5;
        v16[3] = a5;
        v16[6] = *(_DWORD *)(v7 + 52);
        v16[7] = 0;
        sub_CA48C((int)v16, 11);
        return;
      }
      free(v16);
      v9 = a5;
      v10 = 15;
    }
    else
    {
      v9 = a5;
      v10 = 15;
    }
LABEL_22:
    v5(v9, v10);
    return;
  }
  v12 = cp - 1;
  while ( 1 )
  {
    v14 = (unsigned __int8)(v12++)[1];
    v13 = v14;
    if ( !v14 )
      break;
    if ( (unsigned int)(v13 - 48) <= 9 )
    {
      if ( v13 == 46 )
        goto LABEL_12;
    }
    else
    {
      if ( v13 != 46 )
        goto LABEL_9;
LABEL_12:
      ++v11;
    }
  }
  if ( v11 == 3 )
  {
    v20 = inet_addr(v8);
    if ( v20 != -1 )
    {
      LOWORD(v6) = 2;
      v26 = 4;
      v21 = &v20;
      goto LABEL_17;
    }
  }
LABEL_9:
  if ( v6 != 10 || ares_inet_pton(10, v8, &v28, v13) <= 0 )
    goto LABEL_13;
  v21 = (in_addr_t *)&v28;
  v26 = 16;
LABEL_17:
  ptr = strdup(v8);
  if ( !ptr )
  {
    v9 = a5;
    v10 = 15;
    goto LABEL_22;
  }
  v24 = &v19;
  v22 = 0;
  v17 = aresx_sitoss(v6);
  v27 = (int *)&v21;
  v25 = v17;
  ((void (__fastcall *)(int, _DWORD, _DWORD, void **, int, in_addr_t, in_addr_t *))v5)(a5, 0, 0, &ptr, v19, v20, v21);
  free(ptr);
}
// CE0BC: using guessed type int __fastcall ares_inet_pton(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000CA894) --------------------------------------------------------
signed int __fastcall ares_gethostbyname_file(int a1, const char *a2, unsigned int a3, unsigned int *a4)
{
  unsigned int *v4; // r4
  signed int result; // r0

  v4 = a4;
  if ( a1 )
  {
    result = sub_CA3F8(a2, a3, a4);
    if ( result )
      *v4 = 0;
  }
  else
  {
    *a4 = 0;
    result = 4;
  }
  return result;
}

//----- (000CA8B2) --------------------------------------------------------
int __fastcall ares_getsock(int a1, int a2, signed int a3)
{
  int v3; // r6
  int v4; // r8
  signed int v5; // r9
  _BOOL4 v6; // r0
  int v7; // r4
  signed int v8; // r3
  int v9; // r5
  _BOOL4 v10; // r1
  _DWORD *v11; // r0
  int v12; // r2
  int v13; // r2

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = ares__is_list_empty((_DWORD *)(a1 + 396));
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = v6 == 0;
  while ( v9 < *(_DWORD *)(v3 + 120) && v8 <= 15 )
  {
    v11 = (_DWORD *)(*(_DWORD *)(v3 + 116) + 80 * v9);
    if ( v10 )
    {
      v12 = v11[5];
      if ( v12 != -1 )
      {
        if ( v8 >= v5 )
          return v7;
        *(_DWORD *)(v4 + 4 * v8) = v12;
        v7 |= 1 << v8++;
      }
    }
    v13 = v11[6];
    if ( v13 != -1 )
    {
      if ( v8 >= v5 )
        return v7;
      *(_DWORD *)(v4 + 4 * v8) = v13;
      v7 |= 1 << v8;
      if ( v11[12] )
      {
        if ( v10 )
          v7 |= 1 << (v8 + 16);
      }
      ++v8;
    }
    ++v9;
  }
  return v7;
}

//----- (000CA934) --------------------------------------------------------
int __fastcall sub_CA934(const char *a1, int a2, const char *a3)
{
  const char *v3; // r5
  int v4; // r7
  const char *v5; // r6
  unsigned int v6; // r4
  int result; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = strlen(a3);
  if ( v4 - (signed int)v3 >= v6 && !strncmp(v3, v5, v6) )
    result = (int)&v3[v6];
  else
    result = 0;
  return result;
}

//----- (000CA95E) --------------------------------------------------------
signed int __fastcall ares_save_options(_DWORD *a1, _DWORD *a2, int *a3)
{
  _DWORD *v3; // r4
  _DWORD *v4; // r5
  int *v5; // r6
  int v6; // r2
  int v7; // r6
  int v8; // r3
  int v9; // r7
  void *v10; // r0
  int v11; // r2
  int i; // r3
  _DWORD *v13; // r12
  int v14; // r0
  const char *v15; // r0
  char *v16; // r0
  signed int result; // r0
  void *v18; // r0
  int j; // r6
  int v20; // r7
  int v21; // r0
  void *v22; // r0
  int v23; // r12
  int v24; // r3
  int *v25; // r7
  int *v26; // r6
  int v27; // r0
  int v28; // r1
  int v29; // r2
  int v30; // r3
  int v31; // r0
  int v32; // r1
  int v33; // r2
  int v34; // r3
  int v35; // r1

  v3 = a1;
  v4 = a2;
  v5 = a3;
  memset(a2, 0, 0x44u);
  if ( v3[13] && v3[12] >= 0 && v3[30] >= 0 && v3[10] >= 0 && v3[3] >= 0 && v3[1] >= 0 && v3[2] >= 0 )
  {
    *v5 = v3[28] & 0x4000 | 0x27FD;
    *v4 = *v3;
    v4[1] = v3[1];
    v4[2] = v3[2];
    v4[3] = v3[3];
    *((_WORD *)v4 + 8) = __rev16(aresx_sitous(v3[5]));
    *((_WORD *)v4 + 9) = __rev16(aresx_sitous(v3[6]));
    v4[12] = v3[9318];
    v4[13] = v3[9319];
    v6 = v3[30];
    if ( v6 )
    {
      v7 = 0;
      v8 = 0;
      while ( v8 < v6 )
      {
        v9 = 80 * v8++;
        if ( *(_DWORD *)(v3[29] + v9) == 2 )
          ++v7;
      }
      if ( v7 )
      {
        v10 = malloc(4 * v7);
        v4[7] = v10;
        if ( !v10 )
          return 15;
        v11 = 0;
        for ( i = 0; i < v3[30]; ++i )
        {
          v13 = (_DWORD *)(v3[29] + 80 * i);
          if ( *v13 == 2 )
            *(_DWORD *)(v4[7] + 4 * v11++) = v13[1];
        }
      }
    }
    else
    {
      v7 = 0;
    }
    v4[8] = v7;
    v14 = v3[10];
    if ( v14 )
    {
      v18 = malloc(4 * v14);
      v4[9] = v18;
      if ( !v18 )
        return 15;
      for ( j = 0; j < v3[10]; ++j )
      {
        v4[10] = j;
        v20 = v4[9];
        *(_DWORD *)(v20 + 4 * j) = strdup(*(const char **)(v3[9] + 4 * j));
        if ( !*(_DWORD *)(v4[9] + 4 * j) )
          return 15;
      }
    }
    v4[10] = v3[10];
    v15 = (const char *)v3[13];
    if ( v15 )
    {
      v16 = strdup(v15);
      v4[11] = v16;
      if ( !v16 )
      {
        if ( v3[13] )
          return 15;
      }
    }
    v21 = v3[12];
    if ( !v21 )
      goto LABEL_33;
    v22 = malloc(40 * v21);
    v4[14] = v22;
    if ( v22 )
    {
      v23 = 0;
      while ( v23 < v3[12] )
      {
        v24 = 40 * v23++;
        v25 = (int *)(v3[11] + v24);
        v26 = (int *)(v4[14] + v24);
        v27 = *v25;
        v28 = v25[1];
        v29 = v25[2];
        v30 = v25[3];
        v25 += 4;
        *v26 = v27;
        v26[1] = v28;
        v26[2] = v29;
        v26[3] = v30;
        v26 += 4;
        v31 = *v25;
        v32 = v25[1];
        v33 = v25[2];
        v34 = v25[3];
        v25 += 4;
        *v26 = v31;
        v26[1] = v32;
        v26[2] = v33;
        v26[3] = v34;
        v26 += 4;
        v35 = v25[1];
        *v26 = *v25;
        v26[1] = v35;
      }
LABEL_33:
      result = 0;
      v4[15] = v3[12];
      return result;
    }
    return 15;
  }
  return 1;
}

//----- (000CAAF0) --------------------------------------------------------
int __fastcall ares_set_local_ip4(int result, int a2)
{
  *(_DWORD *)(result + 92) = a2;
  return result;
}

//----- (000CAAF4) --------------------------------------------------------
_DWORD *__fastcall ares_set_local_ip6(int a1, int *a2)
{
  _DWORD *result; // r0
  int v3; // r3
  int v4; // t1

  result = (_DWORD *)(a1 + 96);
  v3 = (int)(a2 + 4);
  do
  {
    v4 = *a2;
    ++a2;
    *result = v4;
    ++result;
  }
  while ( a2 != (int *)v3 );
  return result;
}

//----- (000CAB08) --------------------------------------------------------
char *__fastcall ares_set_local_dev(int a1, const char *a2)
{
  int v2; // r4
  char *result; // r0

  v2 = a1;
  result = strncpy((char *)(a1 + 60), a2, 0x20u);
  *(_BYTE *)(v2 + 91) = 0;
  return result;
}

//----- (000CAB1C) --------------------------------------------------------
int __fastcall ares_set_socket_callback(int a1, int a2, int a3)
{
  int result; // r0

  result = a1 + 37120;
  *(_DWORD *)(result + 160) = a2;
  *(_DWORD *)(result + 164) = a3;
  return result;
}

//----- (000CAB2A) --------------------------------------------------------
_DWORD *__fastcall ares__init_servers_state(_DWORD *result)
{
  int v1; // r6
  _DWORD *v2; // r7
  _DWORD *v3; // r4
  int v4; // r3

  v1 = 0;
  v2 = result;
  while ( v1 < v2[30] )
  {
    v3 = (_DWORD *)(v2[29] + 80 * v1++);
    v3[5] = -1;
    v3[6] = -1;
    v4 = v2[96] + 1;
    v2[96] = v4;
    v3[14] = v4;
    v3[8] = 0;
    v3[11] = 0;
    v3[10] = 0;
    v3[9] = 0;
    v3[12] = 0;
    v3[13] = 0;
    result = ares__init_list_head(v3 + 15);
    v3[18] = v2;
    v3[19] = 0;
  }
  return result;
}

//----- (000CAB7C) --------------------------------------------------------
signed int __fastcall ares_init_options(_DWORD *a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r7
  int v5; // r6
  char *v6; // r4
  int v7; // r3
  int v8; // r9
  char *v9; // r0
  int v10; // r9
  char *v11; // r0
  int v12; // r3
  int v13; // r0
  void *v14; // r0
  int v15; // r3
  int v16; // lr
  int v17; // r1
  int v18; // r0
  void *v19; // r0
  int i; // r8
  int v21; // r9
  char *v22; // r0
  int v23; // r0
  void *v24; // r0
  int v25; // r9
  int v26; // r3
  int v27; // r8
  int *v28; // lr
  int *v29; // r8
  int v30; // r0
  int v31; // r1
  int v32; // r2
  int v33; // r3
  int v34; // r0
  int v35; // r1
  int v36; // r2
  int v37; // r3
  int v38; // r1
  char *v39; // r0
  char *v40; // r11
  char *v41; // r3
  int j; // r0
  int v43; // r7
  char *v44; // r1
  int v45; // r7
  int v46; // t1
  void *v47; // r0
  int v48; // r9
  char v49; // r8
  int v50; // r3
  char *v51; // r3
  char *v52; // r7
  int v53; // r2
  int v54; // t1
  int v55; // ST0C_4
  void *v56; // r0
  char *v57; // r5
  char *v58; // r3
  int v59; // r7
  int v60; // r2
  int v61; // t1
  const char *v62; // r0
  int v63; // r0
  const char *v64; // r0
  int v65; // r0
  const char *v66; // r0
  int v67; // r0
  char *v68; // r5
  void *v69; // r5
  signed int v70; // r7
  int *v71; // r8
  int *v72; // r11
  int v73; // r3
  int *v74; // r2
  int *v75; // r1
  int *v76; // r3
  int *v77; // t1
  int v78; // r3
  signed int v79; // r3
  int v80; // r9
  char *v81; // r0
  _DWORD *v82; // r0
  char *v83; // r0
  int v84; // r0
  int v85; // r1
  _DWORD *v86; // r0
  int v87; // r1
  int v88; // r2
  void *v89; // r0
  char *v90; // r7
  _DWORD *v91; // r5
  char *v92; // r0
  char *v93; // r0
  signed int result; // r0
  signed int v95; // r5
  _BYTE *v96; // r7
  FILE *v97; // r0
  FILE *v98; // r8
  int v99; // r0
  int v100; // r5
  unsigned __int8 v101; // r8
  char *v102; // r5
  int v103; // r1
  char v104; // r2
  int v105; // r1
  int v106; // r2
  __int16 v107; // r0
  bool v108; // nf
  void *v109; // r0
  void **v110; // r3
  void *v111; // r0
  void *v112; // r0
  void *v113; // r0
  void *v114; // r0
  void *v115; // r0
  void *v116; // r0
  _DWORD *v117; // r5
  int v118; // r1
  int v119; // r2
  int v120; // r3
  signed int c; // [sp+10h] [bp-D8h]
  _DWORD *v122; // [sp+18h] [bp-D0h]
  int v123; // [sp+24h] [bp-C4h]
  int v124; // [sp+2Ch] [bp-BCh]
  int v125; // [sp+30h] [bp-B8h]
  int v126; // [sp+34h] [bp-B4h]
  int v127; // [sp+38h] [bp-B0h]
  int v128; // [sp+3Ch] [bp-ACh]
  char s; // [sp+40h] [bp-A8h]
  int v130; // [sp+60h] [bp-88h]
  char v131; // [sp+64h] [bp-84h]
  int v132; // [sp+BCh] [bp-2Ch]

  v3 = a2;
  v4 = a3;
  v5 = (int)&GLOBAL_OFFSET_TABLE_;
  v122 = a1;
  v6 = (char *)&_stack_chk_guard;
  c = ares_library_initialized();
  if ( !c )
  {
    v6 = (char *)malloc(0x91A8u);
    if ( !v6 )
    {
      c = 15;
      *v122 = 0;
      goto LABEL_172;
    }
    ares__tvnow(&v123);
    *(_DWORD *)v6 = -1;
    *((_DWORD *)v6 + 1) = -1;
    *((_DWORD *)v6 + 2) = -1;
    *((_DWORD *)v6 + 3) = -1;
    *((_DWORD *)v6 + 4) = -1;
    *((_DWORD *)v6 + 5) = -1;
    *((_DWORD *)v6 + 6) = -1;
    *((_DWORD *)v6 + 14) = -1;
    *((_DWORD *)v6 + 7) = -1;
    *((_DWORD *)v6 + 8) = -1;
    *((_DWORD *)v6 + 30) = -1;
    *((_DWORD *)v6 + 10) = -1;
    *((_DWORD *)v6 + 12) = -1;
    v7 = v123;
    *((_DWORD *)v6 + 96) = 0;
    *((_DWORD *)v6 + 13) = 0;
    *((_DWORD *)v6 + 9) = 0;
    *((_DWORD *)v6 + 11) = 0;
    *((_DWORD *)v6 + 29) = 0;
    *((_DWORD *)v6 + 9318) = 0;
    *((_DWORD *)v6 + 9319) = 0;
    *((_DWORD *)v6 + 9320) = 0;
    *((_DWORD *)v6 + 9321) = 0;
    *((_DWORD *)v6 + 97) = v7;
    *((_DWORD *)v6 + 98) = 0;
    memset(v6 + 60, 0, 0x20u);
    *((_DWORD *)v6 + 23) = 0;
    memset(v6 + 96, 0, 0x10u);
    ares__init_list_head((_DWORD *)v6 + 99);
    v8 = 0;
    do
    {
      v9 = &v6[v8 + 408];
      v8 += 12;
      ares__init_list_head(v9);
    }
    while ( v8 != 24576 );
    v10 = 0;
    do
    {
      v11 = &v6[v10 + 24984];
      v10 += 12;
      ares__init_list_head(v11);
    }
    while ( v10 != 12288 );
    if ( v4 & 1 && *(_DWORD *)v6 == -1 )
      *(_DWORD *)v6 = *(_DWORD *)v3;
    if ( v4 & 0x2000 && *((_DWORD *)v6 + 1) == -1 )
    {
      v12 = *(_DWORD *)(v3 + 4);
    }
    else
    {
      if ( !(v4 & 2) || *((_DWORD *)v6 + 1) != -1 )
        goto LABEL_18;
      v12 = 1000 * *(_DWORD *)(v3 + 4);
    }
    *((_DWORD *)v6 + 1) = v12;
LABEL_18:
    if ( v4 & 4 && *((_DWORD *)v6 + 2) == -1 )
      *((_DWORD *)v6 + 2) = *(_DWORD *)(v3 + 8);
    if ( v4 & 8 && *((_DWORD *)v6 + 3) == -1 )
      *((_DWORD *)v6 + 3) = *(_DWORD *)(v3 + 12);
    if ( v4 & 0x4000 && *((_DWORD *)v6 + 4) == -1 )
      *((_DWORD *)v6 + 4) = 1;
    if ( v4 & 0x10 && *((_DWORD *)v6 + 5) == -1 )
      *((_DWORD *)v6 + 5) = (unsigned __int16)__rev16(*(unsigned __int16 *)(v3 + 16));
    if ( v4 & 0x20 && *((_DWORD *)v6 + 6) == -1 )
      *((_DWORD *)v6 + 6) = (unsigned __int16)__rev16(*(unsigned __int16 *)(v3 + 18));
    if ( v4 & 0x200 && !*((_DWORD *)v6 + 9318) )
    {
      *((_DWORD *)v6 + 9318) = *(_DWORD *)(v3 + 48);
      *((_DWORD *)v6 + 9319) = *(_DWORD *)(v3 + 52);
    }
    if ( v4 & 0x800 && *((_DWORD *)v6 + 7) == -1 )
      *((_DWORD *)v6 + 7) = *(_DWORD *)(v3 + 20);
    if ( v4 & 0x1000 && *((_DWORD *)v6 + 8) == -1 )
      *((_DWORD *)v6 + 8) = *(_DWORD *)(v3 + 24);
    if ( v4 & 0x8000 && *((_DWORD *)v6 + 14) == -1 )
      *((_DWORD *)v6 + 14) = *(_DWORD *)(v3 + 64);
    if ( v4 & 0x40 && *((_DWORD *)v6 + 30) == -1 )
    {
      v13 = *(_DWORD *)(v3 + 32);
      if ( v13 > 0 )
      {
        v14 = malloc(80 * v13);
        *((_DWORD *)v6 + 29) = v14;
        if ( !v14 )
          goto LABEL_134;
        v15 = 0;
        while ( v15 < *(_DWORD *)(v3 + 32) )
        {
          *(_DWORD *)(*((_DWORD *)v6 + 29) + 80 * v15) = 2;
          v16 = 80 * v15 + *((_DWORD *)v6 + 29);
          v17 = *(_DWORD *)(*(_DWORD *)(v3 + 28) + 4 * v15++);
          *(_DWORD *)(v16 + 4) = v17;
        }
      }
      *((_DWORD *)v6 + 30) = *(_DWORD *)(v3 + 32);
    }
    if ( v4 & 0x80 && *((_DWORD *)v6 + 10) == -1 )
    {
      v18 = *(_DWORD *)(v3 + 40);
      if ( v18 > 0 )
      {
        v19 = malloc(4 * v18);
        *((_DWORD *)v6 + 9) = v19;
        if ( !v19 )
          goto LABEL_134;
        for ( i = 0; i < *(_DWORD *)(v3 + 40); ++i )
        {
          *((_DWORD *)v6 + 10) = i;
          v21 = *((_DWORD *)v6 + 9);
          *(_DWORD *)(v21 + 4 * i) = strdup(*(const char **)(*(_DWORD *)(v3 + 36) + 4 * i));
          if ( !*(_DWORD *)(*((_DWORD *)v6 + 9) + 4 * i) )
            goto LABEL_134;
        }
      }
      *((_DWORD *)v6 + 10) = *(_DWORD *)(v3 + 40);
    }
    if ( v4 & 0x100 )
    {
      if ( !*((_DWORD *)v6 + 13) )
      {
        v22 = strdup(*(const char **)(v3 + 44));
        *((_DWORD *)v6 + 13) = v22;
        if ( !v22 )
        {
LABEL_134:
          if ( *(_DWORD *)v6 == -1 )
            *(_DWORD *)v6 = 0;
          if ( *((_DWORD *)v6 + 1) == -1 )
            *((_DWORD *)v6 + 1) = 5000;
          if ( *((_DWORD *)v6 + 2) == -1 )
            *((_DWORD *)v6 + 2) = 4;
          if ( *((_DWORD *)v6 + 3) == -1 )
            *((_DWORD *)v6 + 3) = 1;
          if ( *((_DWORD *)v6 + 4) == -1 )
            *((_DWORD *)v6 + 4) = 0;
          if ( *((_DWORD *)v6 + 5) == -1 )
            *((_DWORD *)v6 + 5) = 13568;
          if ( *((_DWORD *)v6 + 6) == -1 )
            *((_DWORD *)v6 + 6) = 13568;
          if ( *((_DWORD *)v6 + 14) == -1 )
            *((_DWORD *)v6 + 14) = 1280;
          if ( *((_DWORD *)v6 + 30) == -1 )
          {
            v82 = malloc(0x50u);
            *((_DWORD *)v6 + 29) = v82;
            if ( !v82 )
              goto LABEL_192;
            *v82 = 2;
            v82[1] = 16777343;
            *((_DWORD *)v6 + 30) = 1;
          }
          v5 = 0;
          if ( *((_DWORD *)v6 + 10) != -1 )
            goto LABEL_166;
          *((_DWORD *)v6 + 10) = 0;
          v83 = (char *)malloc(0x40u);
          v5 = (int)v83;
          if ( v83 )
          {
            v84 = gethostname(v83, 0x40u);
            if ( v84 == -1 )
            {
              v86 = (_DWORD *)_errno(-1, v85, 0);
              if ( *v86 == 36 || *(_DWORD *)_errno(v86, v87, v88) == 22 )
              {
                v89 = realloc((void *)v5, 0x80u);
                if ( !v89 )
                  goto LABEL_194;
                v5 = (int)v89;
LABEL_162:
                v90 = strchr((const char *)v5, 46);
                if ( !v90 )
                  goto LABEL_166;
                v91 = malloc(4u);
                *((_DWORD *)v6 + 9) = v91;
                if ( v91 )
                {
                  v92 = strdup(v90 + 1);
                  *v91 = v92;
                  if ( v92 )
                  {
                    *((_DWORD *)v6 + 10) = 1;
LABEL_166:
                    if ( *((_DWORD *)v6 + 12) == -1 )
                    {
                      *((_DWORD *)v6 + 11) = 0;
                      *((_DWORD *)v6 + 12) = 0;
                    }
                    if ( *((_DWORD *)v6 + 13) )
                      goto LABEL_173;
                    v93 = strdup("fb");
                    *((_DWORD *)v6 + 13) = v93;
                    if ( v93 )
                      goto LABEL_173;
                    goto LABEL_194;
                  }
                }
LABEL_194:
                v95 = 15;
                goto LABEL_195;
              }
            }
            else if ( !v84 )
            {
              goto LABEL_162;
            }
            v95 = 8;
LABEL_195:
            v109 = (void *)*((_DWORD *)v6 + 29);
            if ( v109 )
            {
              free(v109);
              *((_DWORD *)v6 + 29) = 0;
            }
            v110 = (void **)*((_DWORD *)v6 + 9);
            if ( v110 && *v110 )
              free(*v110);
            v111 = (void *)*((_DWORD *)v6 + 9);
            if ( v111 )
            {
              free(v111);
              *((_DWORD *)v6 + 9) = 0;
            }
            v112 = (void *)*((_DWORD *)v6 + 13);
            if ( v112 )
            {
              free(v112);
              *((_DWORD *)v6 + 13) = 0;
            }
            goto LABEL_174;
          }
LABEL_192:
          v95 = 15;
          v5 = 0;
          goto LABEL_195;
        }
      }
    }
    if ( v4 & 0x400 )
    {
      if ( *((_DWORD *)v6 + 12) == -1 )
      {
        v23 = *(_DWORD *)(v3 + 60);
        if ( v23 > 0 )
        {
          v24 = malloc(40 * v23);
          *((_DWORD *)v6 + 11) = v24;
          if ( !v24 )
            goto LABEL_134;
          v25 = 0;
          while ( 1 )
          {
            v26 = *(_DWORD *)(v3 + 60);
            if ( v25 >= v26 )
              break;
            v27 = 40 * v25++;
            v28 = (int *)(*((_DWORD *)v6 + 11) + v27);
            v29 = (int *)(v27 + *(_DWORD *)(v3 + 56));
            v30 = *v29;
            v31 = v29[1];
            v32 = v29[2];
            v33 = v29[3];
            v29 += 4;
            *v28 = v30;
            v28[1] = v31;
            v28[2] = v32;
            v28[3] = v33;
            v28 += 4;
            v34 = *v29;
            v35 = v29[1];
            v36 = v29[2];
            v37 = v29[3];
            v29 += 4;
            *v28 = v34;
            v28[1] = v35;
            v28[2] = v36;
            v28[3] = v37;
            v28 += 4;
            v38 = v29[1];
            *v28 = *v29;
            v28[1] = v38;
          }
          *((_DWORD *)v6 + 12) = v26;
        }
      }
    }
    *((_DWORD *)v6 + 28) = v4;
    v39 = getenv("LOCALDOMAIN");
    v40 = v39;
    if ( v39 && *((_DWORD *)v6 + 10) == -1 )
    {
      v41 = v39;
      for ( j = 0; ; ++j )
      {
        v43 = (unsigned __int8)*v41;
        if ( !*v41 )
          break;
        do
        {
          v44 = v41;
          v46 = (unsigned __int8)*v41++;
          v45 = v46;
        }
        while ( v46 && !(*(_BYTE *)(v45 + ctype_ + 1) & 8) );
        do
          v41 = v44++;
        while ( *(_BYTE *)((unsigned __int8)*v41 + ctype_ + 1) & 8 );
      }
      if ( j )
      {
        v47 = malloc(4 * j);
        *((_DWORD *)v6 + 9) = v47;
        if ( !v47 )
          goto LABEL_134;
        v48 = v43;
        v49 = v43;
        while ( 1 )
        {
          v50 = (unsigned __int8)*v40;
          *((_DWORD *)v6 + 10) = v48;
          if ( !v50 )
            break;
          v51 = v40;
          do
          {
            v52 = v51;
            v54 = (unsigned __int8)*v51++;
            v53 = v54;
          }
          while ( v54 && !(*(_BYTE *)(v53 + ctype_ + 1) & 8) );
          v55 = *((_DWORD *)v6 + 9);
          *(_DWORD *)(v55 + 4 * v48) = malloc(v52 - v40 + 1);
          v56 = *(void **)(*((_DWORD *)v6 + 9) + 4 * v48);
          if ( !v56 )
            goto LABEL_134;
          memcpy(v56, v40, v52 - v40);
          *(_BYTE *)(*(_DWORD *)(*((_DWORD *)v6 + 9) + 4 * v48) + v52 - v40) = v49;
          do
            v40 = v52++;
          while ( *(_BYTE *)((unsigned __int8)*v40 + ctype_ + 1) & 8 );
          ++v48;
        }
      }
      else
      {
        *((_DWORD *)v6 + 10) = 0;
      }
    }
    v57 = getenv("RES_OPTIONS");
    if ( v57 )
    {
      while ( *v57 )
      {
        v58 = v57;
        do
        {
          v59 = (int)v58;
          v61 = (unsigned __int8)*v58++;
          v60 = v61;
        }
        while ( v61 && !(*(_BYTE *)(v60 + ctype_ + 1) & 8) );
        v62 = (const char *)sub_CA934(v57, v59, "ndots:");
        if ( v62 && *((_DWORD *)v6 + 3) == -1 )
        {
          v63 = strtol(v62, 0, 10);
          *((_DWORD *)v6 + 3) = aresx_sltosi(v63);
        }
        v64 = (const char *)sub_CA934(v57, v59, "retrans:");
        if ( v64 && *((_DWORD *)v6 + 1) == -1 )
        {
          v65 = strtol(v64, 0, 10);
          *((_DWORD *)v6 + 1) = aresx_sltosi(v65);
        }
        v66 = (const char *)sub_CA934(v57, v59, "retry:");
        if ( v66 && *((_DWORD *)v6 + 2) == -1 )
        {
          v67 = strtol(v66, 0, 10);
          *((_DWORD *)v6 + 2) = aresx_sltosi(v67);
        }
        if ( sub_CA934(v57, v59, "rotate") && *((_DWORD *)v6 + 4) == -1 )
          *((_DWORD *)v6 + 4) = 1;
        do
          v57 = (char *)v59++;
        while ( *(_BYTE *)((unsigned __int8)*v57 + ctype_ + 1) & 8 );
      }
    }
    v69 = 0;
    v130 = 0;
    v80 = 0;
    memset(&v131, 0, 0x58u);
    v70 = 1;
LABEL_122:
    v71 = &v130;
    snprintf(&s, 0x20u, "%s%u", "net.dns", v70);
    if ( _system_property_get(&s, &v130) <= 0 )
    {
LABEL_224:
      if ( v69 )
      {
        *((_DWORD *)v6 + 29) = v69;
        *((_DWORD *)v6 + 30) = v80;
      }
      goto LABEL_134;
    }
    while ( 1 )
    {
      do
      {
        v72 = v71;
        v71 = (int *)((char *)v71 + 1);
        v73 = *(unsigned __int8 *)v72;
        if ( !*(_BYTE *)v72 )
        {
LABEL_121:
          if ( ++v70 != 9 )
            goto LABEL_122;
          goto LABEL_224;
        }
      }
      while ( *(_BYTE *)(ctype_ + v73 + 1) & 8 || v73 == 44 );
      v74 = v72;
      do
      {
        v75 = v74;
        v77 = (int *)*(unsigned __int8 *)v74;
        v74 = (int *)((char *)v74 + 1);
        v76 = v77;
        if ( !v77 )
        {
          v71 = v76;
          goto LABEL_129;
        }
      }
      while ( !(*((_BYTE *)v76 + ctype_ + 1) & 8) && v76 != (int *)&word_2C );
      v76 = 0;
      v71 = (int *)((char *)v75 + 1);
      *(_BYTE *)v75 = 0;
LABEL_129:
      if ( ares_inet_pton(2, v72, &v125, v76) == 1 )
      {
        v79 = 2;
      }
      else
      {
        if ( ares_inet_pton(10, v72, &v125, v78) != 1 )
          goto LABEL_120;
        v79 = 10;
      }
      ++v80;
      v124 = v79;
      v81 = (char *)realloc(v69, 80 * v80);
      if ( !v81 )
      {
        if ( v69 )
          free(v69);
        goto LABEL_134;
      }
      v68 = &v81[80 * v80 - 80];
      *(_DWORD *)v68 = v124;
      if ( v124 == 2 )
      {
        *((_DWORD *)v68 + 1) = v125;
      }
      else
      {
        v117 = v68 + 4;
        v118 = v126;
        v119 = v127;
        v120 = v128;
        *v117 = v125;
        v117[1] = v118;
        v117[2] = v119;
        v117[3] = v120;
      }
      v69 = v81;
LABEL_120:
      if ( !v71 )
        goto LABEL_121;
    }
  }
  c = 21;
LABEL_172:
  while ( 1 )
  {
    result = c;
    if ( v132 == _stack_chk_guard )
      return result;
LABEL_173:
    v95 = 0;
LABEL_174:
    if ( v5 )
      free((void *)v5);
    if ( v95 )
    {
LABEL_205:
      v113 = (void *)*((_DWORD *)v6 + 29);
      if ( v113 )
        free(v113);
      if ( *((_DWORD *)v6 + 9) )
      {
        v5 = 0;
        while ( v5 < *((_DWORD *)v6 + 10) )
        {
          v114 = *(void **)(*((_DWORD *)v6 + 9) + 4 * v5++);
          free(v114);
        }
        free(*((void **)v6 + 9));
      }
      v115 = (void *)*((_DWORD *)v6 + 11);
      if ( v115 )
        free(v115);
      v116 = (void *)*((_DWORD *)v6 + 13);
      if ( v116 )
        free(v116);
      free(v6);
      c = v95;
    }
    else
    {
      v96 = calloc(1u, 0x1Fu);
      if ( !v96 )
      {
        v95 = 15;
        goto LABEL_205;
      }
      v5 = (int)(v6 + 126);
      do
      {
        *(_BYTE *)(v5 + v95) = v95;
        ++v95;
      }
      while ( v95 != 256 );
      v97 = fopen("/dev/urandom", "rb");
      v98 = v97;
      if ( v97 )
      {
        v99 = fread(v6 + 126, 1u, 0x1Fu, v97);
        v100 = aresx_uztosi(v99);
        fclose(v98);
      }
      else
      {
        v100 = 0;
      }
      while ( v100 <= 30 )
        *(_BYTE *)(v5 + v100++) = lrand48();
      v101 = 0;
      v102 = v6 + 126;
      v103 = 0;
      v6[382] = 0;
      v6[383] = 0;
      do
      {
        v104 = *v102;
        v101 += v96[v103] + *v102;
        *v102++ = *(_BYTE *)(v5 + v101);
        *(_BYTE *)(v5 + v101) = v104;
        v103 = (unsigned __int8)((v103 + 1) % 31);
      }
      while ( v102 != v6 + 382 );
      free(v96);
      v107 = ares__generate_new_id((int)(v6 + 126), v105, v106);
      v108 = *(_DWORD *)v6 << 30 < 0;
      *((_WORD *)v6 + 62) = v107;
      if ( v108 && *((_DWORD *)v6 + 30) > 1 )
        *((_DWORD *)v6 + 30) = 1;
      ares__init_servers_state(v6);
      *v122 = v6;
    }
  }
}
// 2C: using guessed type __int16 word_2C;
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// 25C64: using guessed type int __fastcall _system_property_get(_DWORD, _DWORD);
// CE0BC: using guessed type int __fastcall ares_inet_pton(_DWORD, _DWORD, _DWORD, _DWORD);
// F2D08: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (000CB3E8) --------------------------------------------------------
signed int __fastcall ares_init(_DWORD *a1)
{
  return ares_init_options(a1, 0, 0);
}

//----- (000CB3F0) --------------------------------------------------------
signed int __fastcall ares_dup(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r4
  signed int result; // r0
  signed int v5; // r7
  int *v6; // r3
  _DWORD *v7; // r2
  int v8; // t1
  int i; // r3
  signed int v10; // r4
  _DWORD *v11; // [sp+4h] [bp-64h]
  int v12; // [sp+8h] [bp-60h]
  char v13; // [sp+Ch] [bp-5Ch]

  v2 = a1;
  v3 = (int)a2;
  *a1 = 0;
  result = ares_save_options(a2, &v13, &v12);
  if ( !result )
  {
    v5 = ares_init_options(v2, (int)&v13, v12);
    ares_destroy_options(&v13);
    if ( v5 )
    {
      result = v5;
    }
    else
    {
      *(_DWORD *)(*v2 + 37280) = *(_DWORD *)(v3 + 37280);
      *(_DWORD *)(*v2 + 37284) = *(_DWORD *)(v3 + 37284);
      strncpy((char *)(*v2 + 60), (const char *)(v3 + 60), 0x20u);
      *(_DWORD *)(*v2 + 92) = *(_DWORD *)(v3 + 92);
      v6 = (int *)(v3 + 96);
      v7 = (_DWORD *)(*v2 + 96);
      do
      {
        v8 = *v6;
        ++v6;
        *v7 = v8;
        ++v7;
      }
      while ( v6 != (int *)(v3 + 112) );
      for ( i = 0; ; ++i )
      {
        if ( i >= *(_DWORD *)(v3 + 120) )
          return 0;
        if ( *(_DWORD *)(*(_DWORD *)(v3 + 116) + 80 * i) != 2 )
          break;
      }
      result = ares_get_servers(v3, &v11);
      if ( !result )
      {
        v10 = ares_set_servers((_DWORD *)*v2, v11);
        ares_free_data(v11);
        result = v10;
      }
    }
  }
  return result;
}

//----- (000CB4B0) --------------------------------------------------------
int __fastcall ares_library_init(int a1)
{
  if ( dword_2FEF58 )
  {
    ++dword_2FEF58;
  }
  else
  {
    dword_2FEF5C = a1;
    dword_2FEF58 = 1;
  }
  return 0;
}
// 2FEF58: using guessed type int dword_2FEF58;
// 2FEF5C: using guessed type int dword_2FEF5C;

//----- (000CB4CC) --------------------------------------------------------
void ares_library_cleanup()
{
  if ( dword_2FEF58 )
  {
    if ( !--dword_2FEF58 )
      dword_2FEF5C = 0;
  }
}
// 2FEF58: using guessed type int dword_2FEF58;
// 2FEF5C: using guessed type int dword_2FEF5C;

//----- (000CB4E4) --------------------------------------------------------
int ares_library_initialized()
{
  return 0;
}

//----- (000CB4E8) --------------------------------------------------------
_DWORD *__fastcall ares__init_list_head(_DWORD *result)
{
  *result = result;
  result[1] = result;
  result[2] = 0;
  return result;
}

//----- (000CB4F2) --------------------------------------------------------
_DWORD *__fastcall ares__init_list_node(_DWORD *result, int a2)
{
  result[2] = a2;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (000CB4FC) --------------------------------------------------------
bool __fastcall ares__is_list_empty(_DWORD *a1)
{
  _DWORD *v1; // r3
  _BOOL4 result; // r0

  v1 = (_DWORD *)a1[1];
  if ( v1 == a1 )
    result = (unsigned int)(*v1 - (_DWORD)v1) <= 0;
  else
    result = 0;
  return result;
}

//----- (000CB510) --------------------------------------------------------
_DWORD *__fastcall ares__insert_in_list(_DWORD *result, int a2)
{
  result[1] = a2;
  *result = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)a2 + 4) = result;
  *(_DWORD *)a2 = result;
  return result;
}

//----- (000CB51E) --------------------------------------------------------
_DWORD *__fastcall ares__remove_from_list(_DWORD *result)
{
  int v1; // r3

  v1 = result[1];
  if ( v1 )
  {
    *(_DWORD *)(*result + 4) = v1;
    *(_DWORD *)result[1] = *result;
    *result = 0;
    result[1] = 0;
  }
  return result;
}

//----- (000CB534) --------------------------------------------------------
int __fastcall aresx_uztosl(int a1)
{
  return a1 & 0x7FFFFFFF;
}

//----- (000CB53A) --------------------------------------------------------
int __fastcall aresx_uztosi(int a1)
{
  return a1 & 0x7FFFFFFF;
}

//----- (000CB540) --------------------------------------------------------
int __fastcall aresx_uztoss(__int16 a1)
{
  return a1 & 0x7FFF;
}

//----- (000CB546) --------------------------------------------------------
int __fastcall aresx_sitoss(__int16 a1)
{
  return a1 & 0x7FFF;
}

//----- (000CB54C) --------------------------------------------------------
int __fastcall aresx_sltosi(int a1)
{
  return a1 & 0x7FFFFFFF;
}

//----- (000CB552) --------------------------------------------------------
int __fastcall aresx_sztosi(int a1)
{
  return a1 & 0x7FFFFFFF;
}

//----- (000CB55A) --------------------------------------------------------
int __fastcall aresx_sitous(int result)
{
  return (unsigned __int16)result;
}

//----- (000CB55E) --------------------------------------------------------
signed int __fastcall ares_get_servers(int a1, _DWORD *a2)
{
  _DWORD *v2; // r9
  int v3; // r7
  int v4; // r5
  int *v5; // r8
  _DWORD *v6; // r6
  int v7; // r0
  int v8; // r4
  int v9; // r2
  bool v10; // zf
  _DWORD *v11; // r2
  int v12; // r1
  int *v13; // r3
  int v14; // r1
  int v15; // t1
  signed int result; // r0
  _DWORD *v17; // r0

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 1;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    if ( v4 >= *(_DWORD *)(v3 + 120) )
    {
      result = 0;
      goto LABEL_17;
    }
    v7 = ares_malloc_data(4);
    v8 = v7;
    if ( !v7 )
      break;
    if ( v5 )
      *v5 = v7;
    else
      v6 = (_DWORD *)v7;
    v9 = *(_DWORD *)(*(_DWORD *)(v3 + 116) + 80 * v4);
    v10 = v9 == 2;
    *(_DWORD *)(v7 + 4) = v9;
    v11 = (_DWORD *)(v7 + 8);
    v12 = *(_DWORD *)(v3 + 116) + 80 * v4;
    if ( v10 )
    {
      *(_DWORD *)(v7 + 8) = *(_DWORD *)(v12 + 4);
    }
    else
    {
      v13 = (int *)(v12 + 4);
      v14 = v12 + 20;
      do
      {
        v15 = *v13;
        ++v13;
        *v11 = v15;
        ++v11;
      }
      while ( v13 != (int *)v14 );
    }
    ++v4;
    v5 = (int *)v7;
  }
  if ( v6 )
  {
    v17 = v6;
    v6 = (_DWORD *)v8;
    ares_free_data(v17);
  }
  result = 15;
LABEL_17:
  *v2 = v6;
  return result;
}

//----- (000CB5E2) --------------------------------------------------------
signed int __fastcall ares_set_servers(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  _DWORD *v3; // r4
  int v4; // r6
  _DWORD *v5; // r8
  int v6; // r7
  void *v7; // r0
  int v8; // r3
  _DWORD *v9; // r2
  int v10; // r1
  _DWORD *v11; // r1
  int v12; // t1

  v2 = a1;
  v3 = a2;
  v4 = ares_library_initialized();
  if ( v4 )
    return 21;
  if ( !v2 )
    return 1;
  v5 = v3;
  ares__destroy_servers_state((int)v2);
  v6 = 0;
  while ( v5 )
  {
    ++v6;
    v5 = (_DWORD *)*v5;
  }
  if ( v6 )
  {
    v7 = malloc(80 * v6);
    v2[29] = v7;
    if ( v7 )
    {
      v8 = 0;
      v2[30] = v6;
      while ( v3 )
      {
        *(_DWORD *)(v2[29] + v8) = v3[1];
        v9 = v3 + 2;
        v10 = v2[29] + v8;
        if ( v3[1] == 2 )
        {
          *(_DWORD *)(v10 + 4) = *v9;
        }
        else
        {
          v11 = (_DWORD *)(v10 + 4);
          do
          {
            v12 = *v9;
            ++v9;
            *v11 = v12;
            ++v11;
          }
          while ( v9 != v3 + 6 );
        }
        v3 = (_DWORD *)*v3;
        v8 += 80;
      }
      ares__init_servers_state(v2);
    }
    else
    {
      v4 = 15;
    }
  }
  return v4;
}

//----- (000CB670) --------------------------------------------------------
signed int __fastcall ares_set_servers_csv(_DWORD *a1, const char *a2)
{
  _DWORD *v2; // r9
  const char *v3; // r7
  int v4; // r4
  size_t v5; // r0
  size_t v6; // r6
  char *v7; // r5
  _DWORD *v8; // r7
  char *v9; // r3
  unsigned int v10; // r8
  _DWORD *v11; // r4
  int v12; // r1
  int v13; // r2
  int v14; // r6
  char *v15; // r2
  const char *v16; // r0
  char *v17; // r11
  int v18; // lr
  int v19; // t1
  bool v20; // zf
  int v21; // r3
  _DWORD *v22; // r0
  _DWORD *v23; // r12
  signed int v24; // r6
  _DWORD *v25; // lr
  int v26; // r1
  int v27; // r2
  int v28; // r3
  _DWORD *v29; // r0
  _DWORD *v30; // r5
  int v32; // [sp+10h] [bp-40h]
  char v33; // [sp+14h] [bp-3Ch]
  int v34; // [sp+18h] [bp-38h]
  int v35; // [sp+1Ch] [bp-34h]
  int v36; // [sp+20h] [bp-30h]

  v2 = a1;
  v3 = a2;
  v4 = ares_library_initialized();
  if ( v4 )
    return 21;
  if ( !v2 )
    return 1;
  ares__destroy_servers_state((int)v2);
  v5 = strlen(v3);
  v6 = v5;
  if ( v5 )
  {
    v7 = (char *)malloc(v5 + 2);
    strcpy(v7, v3);
    if ( v7[v6 - 1] != 44 )
    {
      v7[v6] = 44;
      v7[v6 + 1] = 0;
    }
    v8 = 0;
    v9 = v7;
    v10 = (unsigned int)v7;
    v11 = 0;
    v12 = 0;
    while ( 1 )
    {
      v14 = (int)(v9 + 1);
      v13 = (unsigned __int8)*v9;
      if ( !*v9 )
      {
        v24 = ares_set_servers(v2, v11);
        goto LABEL_42;
      }
      if ( v13 == 58 )
      {
        ++v12;
        goto LABEL_40;
      }
      if ( v13 == 91 )
      {
        v10 = (unsigned int)(v9 + 1);
        goto LABEL_40;
      }
      if ( v13 == 44 )
        break;
LABEL_40:
      v9 = (char *)v14;
    }
    *v9 = 0;
    if ( !v12 )
      goto LABEL_28;
    v15 = v9 - 1;
    while ( 1 )
    {
      v16 = v15 + 1;
      v17 = v15;
      if ( (unsigned int)v15 <= v10 )
      {
LABEL_23:
        if ( v17 == (char *)v10 )
          goto LABEL_28;
LABEL_24:
        if ( v9 > v17 + 1 )
        {
          if ( *v17 == 93 )
            ++v16;
          strtol(v16, 0, 10);
          *v17 = 0;
        }
LABEL_28:
        if ( ares_inet_pton(2, v10, &v32, v9) )
        {
          v29 = malloc(0x18u);
          v23 = v29;
          if ( v29 )
          {
            v29[1] = 2;
            v29[2] = v32;
            goto LABEL_35;
          }
LABEL_31:
          v24 = 15;
        }
        else
        {
          if ( ares_inet_pton(10, v10, &v33, v21) )
          {
            v22 = malloc(0x18u);
            v23 = v22;
            if ( !v22 )
              goto LABEL_31;
            v25 = v22 + 2;
            v22[1] = 10;
            v26 = v34;
            v27 = v35;
            v28 = v36;
            *v25 = *(_DWORD *)&v33;
            v25[1] = v26;
            v25[2] = v27;
            v25[3] = v28;
LABEL_35:
            *v23 = 0;
            if ( v8 )
              *v8 = v23;
            else
              v11 = v23;
            v8 = v23;
            v10 = v14;
            v12 = 0;
            goto LABEL_40;
          }
          v24 = 17;
        }
LABEL_42:
        if ( v7 )
          free(v7);
        while ( v11 )
        {
          v30 = (_DWORD *)*v11;
          free(v11);
          v11 = v30;
        }
        return v24;
      }
      v19 = (unsigned __int8)*v15--;
      v18 = v19;
      if ( v19 == 93 )
        break;
      if ( v18 == 58 )
      {
        v20 = v12 == 1;
LABEL_20:
        if ( v20 )
          goto LABEL_24;
      }
      if ( (unsigned int)(v18 - 48) > 0xA )
      {
        v16 = v9;
        v17 = v9;
        goto LABEL_23;
      }
    }
    v20 = v15[2] == 58;
    goto LABEL_20;
  }
  return v4;
}
// CE0BC: using guessed type int __fastcall ares_inet_pton(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000CB810) --------------------------------------------------------
signed int __fastcall ares_parse_aaaa_reply(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, int *a5)
{
  int v5; // r7
  int v6; // r4
  int v7; // r5
  int v8; // r4
  unsigned int v9; // r11
  char *v10; // r4
  char *v11; // r8
  void *v12; // r0
  _DWORD *v13; // r6
  int v15; // r10
  int v16; // r5
  signed int v17; // r0
  int v18; // r4
  unsigned int v19; // r9
  int v20; // r12
  int v21; // r3
  char *v22; // r0
  int v23; // r12
  char *v24; // lr
  int *v25; // r3
  int v26; // r0
  int v27; // r1
  int *v28; // r3
  _DWORD *v29; // r1
  int v30; // t1
  int v31; // r4
  void *v32; // r0
  int v33; // r1
  int v34; // r2
  int v35; // r3
  signed int v36; // r0
  _DWORD *v37; // r4
  void *v38; // r0
  int j; // r3
  int v40; // r2
  signed int v41; // r4
  _DWORD *v42; // [sp+18h] [bp-70h]
  signed int v43; // [sp+1Ch] [bp-6Ch]
  unsigned int v44; // [sp+20h] [bp-68h]
  int v45; // [sp+24h] [bp-64h]
  char *v46; // [sp+28h] [bp-60h]
  signed int v47; // [sp+2Ch] [bp-5Ch]
  int v48; // [sp+30h] [bp-58h]
  int v49; // [sp+34h] [bp-54h]
  signed int v50; // [sp+38h] [bp-50h]
  int i; // [sp+3Ch] [bp-4Ch]
  int v52; // [sp+40h] [bp-48h]
  int v53; // [sp+50h] [bp-38h]
  void *ptr; // [sp+54h] [bp-34h]
  char *s1; // [sp+58h] [bp-30h]
  void *v56; // [sp+5Ch] [bp-2Ch]

  v5 = (int)a1;
  v45 = a2;
  v42 = a3;
  v49 = a4;
  if ( a4 )
  {
    if ( a5 )
      v6 = *a5;
    else
      v6 = 0;
  }
  else
  {
    v6 = a4;
  }
  v48 = v6;
  if ( a3 )
    *a3 = 0;
  if ( a5 )
    *a5 = 0;
  if ( a2 <= 11 )
    return 10;
  v7 = a1[6];
  v8 = a1[7];
  if ( (a1[5] | (a1[4] << 8)) != 1 )
    return 10;
  v43 = ares__expand_name_for_response((unsigned int)(a1 + 12), (int)a1, a2, &ptr, &v53);
  if ( v43 )
    return v43;
  v9 = v5 + 12 + v53 + 4;
  v44 = v45 + v5;
  if ( v9 > v45 + v5 )
  {
    free(ptr);
    return 10;
  }
  v52 = v8 | (v7 << 8);
  if ( v42 )
  {
    v10 = (char *)malloc(16 * v52);
    v11 = v10;
    if ( !v10 )
    {
      v12 = ptr;
LABEL_20:
      free(v12);
      return 15;
    }
    v13 = malloc(4 * (v52 + 1));
    if ( !v13 )
    {
      free(ptr);
      v12 = v10;
      goto LABEL_20;
    }
  }
  else
  {
    v11 = 0;
    v13 = 0;
  }
  v15 = 0;
  v16 = 0;
  v47 = 0x7FFFFFFF;
  for ( i = 0; i < v52; ++i )
  {
    v17 = ares__expand_name_for_response(v9, v5, v45, &s1, &v53);
    if ( v17 )
      goto LABEL_53;
    v18 = v9 + v53;
    v19 = v9 + v53 + 10;
    if ( v19 > v44
      || (v20 = *(unsigned __int8 *)(v9 + v53),
          v21 = *(unsigned __int8 *)(v18 + 9) | (*(unsigned __int8 *)(v18 + 8) << 8),
          v9 = v19 + v21,
          v19 + v21 > v44) )
    {
      v22 = s1;
      goto LABEL_39;
    }
    if ( (*(unsigned __int8 *)(v18 + 3) | (*(unsigned __int8 *)(v18 + 2) << 8)) != 1 )
      goto LABEL_45;
    v23 = *(unsigned __int8 *)(v18 + 1) | (v20 << 8);
    v50 = _byteswap_ulong(*(_DWORD *)(v18 + 4));
    if ( v23 == 28 )
    {
      if ( v21 == 16 )
      {
        v46 = s1;
        if ( !strcasecmp(s1, (const char *)ptr) )
        {
          if ( v11 )
          {
            if ( v44 < v18 + 26 )
              goto LABEL_38;
            v24 = &v11[16 * v16];
            v25 = (int *)v19;
            do
            {
              v26 = *v25;
              v25 += 2;
              v27 = *(v25 - 1);
              *(_DWORD *)v24 = v26;
              *((_DWORD *)v24 + 1) = v27;
              v24 += 8;
            }
            while ( v25 != (int *)(v19 + 16) );
          }
          if ( v16 < v48 )
          {
            if ( v44 < v18 + 26 )
            {
LABEL_38:
              v22 = v46;
LABEL_39:
              free(v22);
              v17 = 10;
LABEL_53:
              v43 = v17;
              goto LABEL_54;
            }
            v28 = (int *)v19;
            v29 = (_DWORD *)(v49 + 20 * v16);
            do
            {
              v30 = *v28;
              ++v28;
              *v29 = v30;
              ++v29;
            }
            while ( v28 != (int *)(v19 + 16) );
            *(_DWORD *)(v49 + 20 * v16 + 16) = v50;
          }
          ++v16;
        }
      }
LABEL_45:
      free(s1);
      continue;
    }
    if ( v23 != 5 )
      goto LABEL_45;
    if ( v13 )
      v13[v15] = s1;
    else
      free(s1);
    ++v15;
    v17 = ares__expand_name_for_response(v19, v5, v45, &v56, &v53);
    if ( v17 )
      goto LABEL_53;
    free(ptr);
    v41 = v47;
    ptr = v56;
    if ( v47 >= v50 )
      v41 = v50;
    v47 = v41;
  }
  if ( !v16 && !v15 )
  {
    v17 = 1;
    goto LABEL_53;
  }
  if ( a5 )
  {
    v33 = v48;
    v34 = 0;
    v35 = v49;
    if ( v16 < v48 )
      v33 = v16;
    while ( v34 < v33 )
    {
      ++v34;
      v36 = *(_DWORD *)(v35 + 16);
      v35 += 20;
      if ( v36 > v47 )
        *(_DWORD *)(v35 - 4) = v47;
    }
    *a5 = v33;
  }
  if ( v13 )
    v13[v15] = 0;
  if ( !v42 )
  {
LABEL_54:
    if ( v13 )
    {
      v31 = 0;
      while ( v31 < v15 )
      {
        v32 = (void *)v13[v31++];
        free(v32);
      }
      free(v13);
    }
    free(v11);
    free(ptr);
    return v43;
  }
  v37 = malloc(0x14u);
  if ( !v37 )
  {
LABEL_79:
    v43 = 15;
    goto LABEL_54;
  }
  v38 = malloc(4 * (v16 + 1));
  v37[4] = v38;
  if ( !v38 )
  {
    free(v37);
    goto LABEL_79;
  }
  *v37 = ptr;
  v37[1] = v13;
  v37[2] = 10;
  v37[3] = 16;
  for ( j = 0; ; ++j )
  {
    v40 = v37[4];
    if ( j >= v16 )
      break;
    *(_DWORD *)(v40 + 4 * j) = &v11[16 * j];
  }
  *(_DWORD *)(4 * (v16 + 1) + v40 - 4) = 0;
  if ( !v16 && v11 )
    free(v11);
  *v42 = v37;
  return 0;
}

//----- (000CBB44) --------------------------------------------------------
signed int __fastcall ares_parse_a_reply(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, int *a5)
{
  int v5; // r7
  _DWORD *v6; // r10
  int v7; // r4
  int v8; // r5
  int v9; // r4
  unsigned int v10; // r11
  int v11; // r4
  int v12; // r5
  _DWORD *v13; // r4
  _DWORD *v14; // r8
  void *v15; // r0
  _DWORD *v16; // r6
  int v18; // r9
  int v19; // r5
  signed int v20; // r0
  int v21; // r4
  int v22; // r12
  int v23; // r3
  char *v24; // r0
  int v25; // r12
  int v26; // r4
  void *v27; // r0
  int v28; // r2
  int v29; // r3
  int v30; // r1
  _DWORD *v31; // r4
  void *v32; // r0
  int j; // r3
  int v34; // r2
  signed int v35; // r4
  char *v36; // [sp+14h] [bp-74h]
  signed int v37; // [sp+18h] [bp-70h]
  unsigned int v38; // [sp+1Ch] [bp-6Ch]
  _DWORD *v39; // [sp+20h] [bp-68h]
  int v40; // [sp+24h] [bp-64h]
  int v41; // [sp+28h] [bp-60h]
  signed int v42; // [sp+2Ch] [bp-5Ch]
  int v43; // [sp+30h] [bp-58h]
  signed int v44; // [sp+34h] [bp-54h]
  int i; // [sp+38h] [bp-50h]
  int v46; // [sp+40h] [bp-48h]
  int v47; // [sp+50h] [bp-38h]
  void *ptr; // [sp+54h] [bp-34h]
  char *s1; // [sp+58h] [bp-30h]
  void *v50; // [sp+5Ch] [bp-2Ch]

  v5 = (int)a1;
  v6 = a3;
  v40 = a2;
  v41 = a4;
  if ( a4 )
  {
    if ( a5 )
      v7 = *a5;
    else
      v7 = 0;
  }
  else
  {
    v7 = a4;
  }
  v43 = v7;
  if ( a3 )
    *a3 = 0;
  if ( a5 )
    *a5 = 0;
  if ( a2 <= 11 )
    return 10;
  v8 = a1[6];
  v9 = a1[7];
  if ( (a1[5] | (a1[4] << 8)) != 1 )
    return 10;
  v37 = ares__expand_name_for_response((unsigned int)(a1 + 12), (int)a1, a2, &ptr, &v47);
  if ( v37 )
    return v37;
  v10 = v5 + 12 + v47 + 4;
  v38 = v40 + v5;
  if ( v10 > v40 + v5 )
  {
    free(ptr);
    return 10;
  }
  v11 = v9 | (v8 << 8);
  v46 = v11;
  if ( v6 )
  {
    v12 = 4 * v11;
    v13 = malloc(4 * v11);
    v14 = v13;
    if ( !v13 )
    {
      v15 = ptr;
LABEL_20:
      free(v15);
      return 15;
    }
    v16 = malloc(v12 + 4);
    if ( !v16 )
    {
      free(ptr);
      v15 = v13;
      goto LABEL_20;
    }
  }
  else
  {
    v14 = 0;
    v16 = 0;
  }
  v18 = 0;
  v19 = 0;
  v42 = 0x7FFFFFFF;
  for ( i = 0; i < v46; ++i )
  {
    v20 = ares__expand_name_for_response(v10, v5, v40, &s1, &v47);
    if ( v20 )
      goto LABEL_50;
    v21 = v10 + v47;
    v39 = (_DWORD *)(v10 + v47 + 10);
    if ( (unsigned int)v39 > v38
      || (v22 = *(unsigned __int8 *)(v10 + v47),
          v23 = *(unsigned __int8 *)(v21 + 9) | (*(unsigned __int8 *)(v21 + 8) << 8),
          v10 = (unsigned int)v39 + v23,
          (unsigned int)v39 + v23 > v38) )
    {
      v24 = s1;
      goto LABEL_38;
    }
    if ( (*(unsigned __int8 *)(v21 + 3) | (*(unsigned __int8 *)(v21 + 2) << 8)) != 1 )
      goto LABEL_42;
    v25 = *(unsigned __int8 *)(v21 + 1) | (v22 << 8);
    v44 = _byteswap_ulong(*(_DWORD *)(v21 + 4));
    if ( v25 == 1 )
    {
      if ( v23 == 4 )
      {
        v36 = s1;
        if ( !strcasecmp(s1, (const char *)ptr) )
        {
          if ( v14 )
          {
            if ( v38 < v21 + 14 )
              goto LABEL_37;
            v14[v19] = *v39;
          }
          if ( v19 < v43 )
          {
            if ( v38 < v21 + 14 )
            {
LABEL_37:
              v24 = v36;
LABEL_38:
              free(v24);
              v20 = 10;
LABEL_50:
              v37 = v20;
              goto LABEL_51;
            }
            *(_DWORD *)(v41 + 8 * v19) = *v39;
            *(_DWORD *)(v41 + 8 * v19 + 4) = v44;
          }
          ++v19;
        }
      }
LABEL_42:
      free(s1);
      continue;
    }
    if ( v25 != 5 )
      goto LABEL_42;
    if ( v16 )
      v16[v18] = s1;
    else
      free(s1);
    ++v18;
    v20 = ares__expand_name_for_response((unsigned int)v39, v5, v40, &v50, &v47);
    if ( v20 )
      goto LABEL_50;
    free(ptr);
    v35 = v42;
    ptr = v50;
    if ( v42 >= v44 )
      v35 = v44;
    v42 = v35;
  }
  if ( !v19 && !v18 )
  {
    v20 = 1;
    goto LABEL_50;
  }
  if ( a5 )
  {
    v28 = v43;
    v29 = 0;
    if ( v19 < v43 )
      v28 = v19;
    while ( v29 < v28 )
    {
      v30 = v41 + 8 * v29++;
      if ( *(_DWORD *)(v30 + 4) > v42 )
        *(_DWORD *)(v30 + 4) = v42;
    }
    *a5 = v28;
  }
  if ( v16 )
    v16[v18] = 0;
  if ( !v6 )
  {
LABEL_51:
    if ( v16 )
    {
      v26 = 0;
      while ( v26 < v18 )
      {
        v27 = (void *)v16[v26++];
        free(v27);
      }
      free(v16);
    }
    free(v14);
    free(ptr);
    return v37;
  }
  v31 = malloc(0x14u);
  if ( !v31 )
  {
LABEL_76:
    v37 = 15;
    goto LABEL_51;
  }
  v32 = malloc(4 * (v19 + 1));
  v31[4] = v32;
  if ( !v32 )
  {
    free(v31);
    goto LABEL_76;
  }
  *v31 = ptr;
  v31[1] = v16;
  v31[2] = 2;
  v31[3] = 4;
  for ( j = 0; ; ++j )
  {
    v34 = v31[4];
    if ( j >= v19 )
      break;
    *(_DWORD *)(v34 + 4 * j) = &v14[j];
  }
  *(_DWORD *)(4 * (v19 + 1) + v34 - 4) = 0;
  if ( !v19 && v14 )
    free(v14);
  *v6 = v31;
  return 0;
}

//----- (000CBE52) --------------------------------------------------------
signed int __fastcall ares_parse_ptr_reply(unsigned __int8 *a1, int a2, void *a3, size_t a4, __int16 a5, char **a6)
{
  int v6; // r4
  int v7; // r9
  int v8; // r10
  int v9; // r7
  signed int v10; // r5
  unsigned int v11; // r8
  _DWORD *v12; // r6
  signed int v13; // r10
  char *v14; // r7
  signed int result; // r0
  signed int v16; // r11
  unsigned __int8 *v17; // r3
  unsigned int v18; // r2
  int v19; // r0
  int v20; // r3
  size_t v21; // r0
  char *v22; // r0
  char *v23; // r11
  char *v24; // ST0C_4
  size_t v25; // r0
  _DWORD *v26; // r0
  char *v27; // r0
  char *v28; // r4
  _DWORD *v29; // r8
  signed int j; // r4
  void *v31; // r0
  int v32; // r2
  int v33; // r0
  void **v34; // r3
  void *v35; // r9
  void *v36; // r0
  signed int v37; // r3
  int v38; // r2
  char *dest; // [sp+Ch] [bp-5Ch]
  int i; // [sp+14h] [bp-54h]
  unsigned int v41; // [sp+18h] [bp-50h]
  size_t n; // [sp+1Ch] [bp-4Ch]
  int v43; // [sp+24h] [bp-44h]
  void *src; // [sp+28h] [bp-40h]
  int v45; // [sp+30h] [bp-38h]
  void *ptr; // [sp+34h] [bp-34h]
  char *s1; // [sp+38h] [bp-30h]
  char *s; // [sp+3Ch] [bp-2Ch]

  v6 = (int)a1;
  v7 = a2;
  n = a4;
  src = a3;
  *a6 = 0;
  if ( a2 <= 11 )
    return 10;
  v8 = a1[6];
  v9 = a1[7];
  if ( (a1[5] | (a1[4] << 8)) != 1 )
    return 10;
  v10 = ares__expand_name_for_response((unsigned int)(a1 + 12), (int)a1, a2, &ptr, &v45);
  if ( v10 )
    return v10;
  v11 = v6 + 12 + v45 + 4;
  v41 = v6 + v7;
  if ( v11 > v6 + v7 )
  {
    free(ptr);
    return 10;
  }
  v12 = malloc(0x20u);
  if ( v12 )
  {
    v43 = v9 | (v8 << 8);
    v13 = 8;
    v14 = 0;
    for ( i = 0; i < v43; ++i )
    {
      v16 = ares__expand_name_for_response(v11, v6, v7, &s1, &v45);
      if ( v16 )
        goto LABEL_34;
      v17 = (unsigned __int8 *)(v11 + v45);
      v18 = v11 + v45 + 10;
      if ( v18 > v41 || (v19 = *(unsigned __int8 *)(v11 + v45), v11 = (v17[9] | (v17[8] << 8)) + v18, v11 > v41) )
      {
        v16 = 10;
        free(s1);
        goto LABEL_34;
      }
      if ( (v17[3] | (v17[2] << 8)) == 1 )
      {
        v20 = v17[1] | (v19 << 8);
        if ( v20 == 12 )
        {
          dest = (char *)v18;
          if ( !strcasecmp(s1, (const char *)ptr) )
          {
            v16 = ares__expand_name_for_response((unsigned int)dest, v6, v7, &s, &v45);
            if ( v16 )
              goto LABEL_26;
            if ( v14 )
              free(v14);
            v14 = s;
            v21 = strlen(s);
            v22 = (char *)malloc(v21 + 1);
            v12[v10] = v22;
            if ( !v22 )
            {
LABEL_25:
              v27 = s1;
LABEL_32:
              free(v27);
              goto LABEL_33;
            }
            v23 = s;
            ++v10;
            v24 = v22;
            v25 = strlen(s);
            strncpy(v24, v23, v25 + 1);
            if ( v10 >= v13 )
            {
              v13 *= 2;
              v26 = realloc(v12, 4 * v13);
              if ( !v26 )
                goto LABEL_25;
              v12 = v26;
            }
          }
        }
        else if ( v20 == 5 )
        {
          v16 = ares__expand_name_for_response(v18, v6, v7, &s, &v45);
          if ( v16 )
          {
LABEL_26:
            free(s1);
            goto LABEL_34;
          }
          free(ptr);
          ptr = s;
        }
      }
      free(s1);
    }
    if ( !v14 )
    {
      v16 = 1;
      goto LABEL_34;
    }
    v28 = (char *)malloc(0x14u);
    if ( v28 )
    {
      v29 = malloc(8u);
      *((_DWORD *)v28 + 4) = v29;
      if ( v29 )
      {
        v35 = malloc(n);
        *v29 = v35;
        if ( v35 )
        {
          v36 = malloc(4 * (v10 + 1));
          *((_DWORD *)v28 + 1) = v36;
          if ( v36 )
          {
            v37 = 0;
            *(_DWORD *)v28 = v14;
            while ( 1 )
            {
              v38 = *((_DWORD *)v28 + 1);
              if ( v37 >= v10 )
                break;
              *(_DWORD *)(v38 + 4 * v37) = v12[v37];
              ++v37;
            }
            v32 = v38 + 4 * (v10 + 1);
            v10 = 0;
            *(_DWORD *)(v32 - 4) = 0;
            *((_DWORD *)v28 + 2) = aresx_sitoss(a5);
            v33 = aresx_sitoss(n);
            v34 = (void **)*((_DWORD *)v28 + 4);
            *((_DWORD *)v28 + 3) = v33;
            memcpy(*v34, src, n);
            *(_DWORD *)(*((_DWORD *)v28 + 4) + 4) = 0;
            *a6 = v28;
            free(v12);
            free(ptr);
            return v10;
          }
          free(v35);
        }
        free(v29);
      }
      v27 = v28;
      goto LABEL_32;
    }
LABEL_33:
    v16 = 15;
LABEL_34:
    for ( j = 0; j < v10; ++j )
    {
      v31 = (void *)v12[j];
      if ( v31 )
        free(v31);
    }
    free(v12);
    if ( v14 )
      free(v14);
    free(ptr);
    result = v16;
  }
  else
  {
    free(ptr);
    result = 15;
  }
  return result;
}

//----- (000CC0F2) --------------------------------------------------------
void __fastcall sub_CC0F2(int a1, int a2, unsigned int a3)
{
  int v3; // r7
  unsigned int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r4
  unsigned int v7; // r3
  void *v8; // r0
  int v9; // r7
  void (__fastcall *v10)(_DWORD, _DWORD, signed int); // r4

  v3 = a1;
  v4 = a3;
  v5 = (_DWORD *)(*(_DWORD *)(a1 + 116) + 80 * a2);
  while ( (signed int)v4 > 0 )
  {
    v6 = (_DWORD *)v5[12];
    v7 = v6[1];
    if ( v4 < v7 )
    {
      *v6 += v4;
      v6[1] = v7 - v4;
      return;
    }
    v4 -= v7;
    v5[12] = v6[4];
    v8 = (void *)v6[3];
    if ( v8 )
      free(v8);
    free(v6);
    if ( !v5[12] )
    {
      v9 = v3 + 37120;
      v10 = *(void (__fastcall **)(_DWORD, _DWORD, signed int))(v9 + 152);
      if ( v10 )
        v10(*(_DWORD *)(v9 + 156), v5[6], 1);
      v5[13] = 0;
      return;
    }
  }
}

//----- (000CC14E) --------------------------------------------------------
signed int __fastcall sub_CC14E(signed int result, _DWORD *a2, int a3)
{
  if ( result > 1 )
    *(_DWORD *)(*a2 + 8 * a3) = 1;
  return result;
}

//----- (000CC15C) --------------------------------------------------------
signed int __fastcall sub_CC15C(int a1, int a2, _DWORD *a3)
{
  int v3; // r6
  _DWORD *v4; // r4
  int v5; // r5
  int v6; // r0
  signed int result; // r0
  unsigned int v8; // r4
  socklen_t v9; // r2
  int v10; // r0
  int v11; // r9
  int v12; // r4
  int *v13; // r6
  int *v14; // r3
  int v15; // r0
  int v16; // r1
  __int16 s; // [sp+8h] [bp-40h]
  unsigned int v18; // [sp+Ch] [bp-3Ch]
  int v19; // [sp+10h] [bp-38h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = fcntl(a1, 3, 0);
  fcntl(v5, 4, v6 | 0x800);
  if ( fcntl(v5, 2, 1) == -1
    || v4[7] > 0 && setsockopt(v5, 1, 7, v4 + 7, 4u) == -1
    || v4[8] > 0 && setsockopt(v5, 1, 8, v4 + 8, 4u) == -1 )
  {
    return -1;
  }
  if ( *((_BYTE *)v4 + 60) )
    setsockopt(v5, 1, 25, v4 + 15, 0x20u);
  if ( v3 == 2 )
  {
    v8 = v4[23];
    if ( v8 )
    {
      memset(&s, 0, 0x10u);
      s = 2;
      v9 = 16;
      v18 = bswap32(v8);
      v10 = v5;
      return bind(v10, (const struct sockaddr *)&s, v9) >> 31;
    }
    result = 0;
  }
  else
  {
    if ( v3 == 10 )
    {
      v11 = (int)(v4 + 24);
      result = memcmp(v4 + 24, &ares_in6addr_any, 0x10u);
      if ( !result )
        return result;
      v12 = (int)(v4 + 28);
      memset(&s, 0, 0x1Cu);
      s = 10;
      v13 = &v19;
      v14 = (int *)v11;
      do
      {
        v15 = *v14;
        v14 += 2;
        v16 = *(v14 - 1);
        *v13 = v15;
        v13[1] = v16;
        v13 += 2;
      }
      while ( v14 != (int *)v12 );
      v10 = v5;
      v9 = 28;
      return bind(v10, (const struct sockaddr *)&s, v9) >> 31;
    }
    result = 0;
  }
  return result;
}

//----- (000CC288) --------------------------------------------------------
bool __fastcall ares__timedout(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 - *a2 > 0 )
    return 1;
  if ( *a1 == *a2 )
    return a1[1] - a2[1] >= 0;
  return 0;
}

//----- (000CC2A8) --------------------------------------------------------
int __fastcall ares__timeadd(_DWORD *a1, int a2)
{
  int v2; // r5
  int v3; // r1

  v2 = *a1 + a2 / 1000;
  *a1 = v2;
  v3 = a1[1] + 1000 * (a2 % 1000);
  a1[1] = v3;
  if ( v3 > 999999 )
  {
    *a1 = v2 + 1;
    a1[1] = v3 - 1000000;
  }
  return 0;
}

//----- (000CC2F0) --------------------------------------------------------
int __fastcall ares__timeoffset(_DWORD *a1, _DWORD *a2)
{
  return (a2[1] - a1[1]) / 1000 + 1000 * (*a2 - *a1);
}

//----- (000CC310) --------------------------------------------------------
void __fastcall ares__free_query(int a1)
{
  int v1; // r4
  void *v2; // r0

  v1 = a1;
  ares__remove_from_list((_DWORD *)(a1 + 12));
  ares__remove_from_list((_DWORD *)(v1 + 24));
  ares__remove_from_list((_DWORD *)(v1 + 36));
  ares__remove_from_list((_DWORD *)(v1 + 48));
  v2 = *(void **)(v1 + 60);
  *(_DWORD *)(v1 + 76) = 0;
  *(_DWORD *)(v1 + 80) = 0;
  free(v2);
  free(*(void **)(v1 + 92));
  j_free((void *)v1);
}

//----- (000CC34E) --------------------------------------------------------
void __fastcall sub_CC34E(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v5; // r10
  _DWORD *v6; // r5
  int v7; // r6
  int v8; // r8
  int v9; // r7
  int i; // r4
  void *v11; // r0
  int v12; // r4
  size_t n; // [sp+8h] [bp-30h]
  int v14; // [sp+Ch] [bp-2Ch]

  v5 = 0;
  v6 = a1;
  v7 = a2;
  v8 = a3;
  v14 = a4;
  while ( v5 < v6[30] )
  {
    v9 = v6[29] + 80 * v5;
    for ( i = *(_DWORD *)(v9 + 48); i; i = *(_DWORD *)(i + 16) )
    {
      if ( *(_DWORD *)(i + 8) == v7 )
      {
        *(_DWORD *)(i + 8) = 0;
        if ( v8 )
          goto LABEL_19;
        n = *(_DWORD *)(i + 4);
        v11 = malloc(*(_DWORD *)(i + 4));
        *(_DWORD *)(i + 12) = v11;
        if ( v11 )
        {
          memcpy(v11, *(const void **)i, n);
          *(_DWORD *)i = *(_DWORD *)(i + 12);
        }
        if ( !*(_DWORD *)(i + 12) )
        {
LABEL_19:
          *(_DWORD *)(v9 + 76) = 1;
          *(_DWORD *)i = 0;
          *(_DWORD *)(i + 4) = 0;
        }
      }
    }
    ++v5;
  }
  (*(void (__fastcall **)(_DWORD, int, _DWORD, int, int))(v7 + 76))(
    *(_DWORD *)(v7 + 80),
    v8,
    *(_DWORD *)(v7 + 104),
    v14,
    a5);
  ares__free_query(v7);
  v12 = *v6 & 0x10;
  if ( !v12 && ares__is_list_empty(v6 + 99) )
  {
    while ( v12 < v6[30] )
      ares__close_sockets(v6, (int *)(v6[29] + 80 * v12++));
  }
}

//----- (000CC400) --------------------------------------------------------
void __fastcall sub_CC400(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r1
  int v6; // r1
  int v7; // r3
  _DWORD *v8; // r12

  v3 = a2;
  while ( 1 )
  {
    v4 = v3[21] + 1;
    v3[21] = v4;
    v5 = a1[30];
    if ( v4 >= a1[2] * v5 )
      break;
    v6 = (v3[22] + 1) % v5;
    v3[22] = v6;
    v7 = a1[29] + 80 * v6;
    if ( !*(_DWORD *)(v7 + 76) )
    {
      v8 = (_DWORD *)(v3[23] + 8 * v6);
      if ( !*v8 && (!v3[24] || v8[1] != *(_DWORD *)(v7 + 56)) )
      {
        ares__send_query(a1, (int)v3, a3);
        return;
      }
    }
  }
  sub_CC34E(a1, (int)v3, v3[25], 0, 0);
}

//----- (000CC470) --------------------------------------------------------
_DWORD *__fastcall ares__send_query(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // r10
  int v4; // r4
  int v5; // r9
  _DWORD *v6; // r5
  int v7; // r8
  _DWORD *v8; // r6
  int v9; // r7
  int v10; // r0
  __int16 v11; // r0
  int *v12; // r7
  int *v13; // r3
  int v14; // r0
  int v15; // r0
  int v16; // r1
  int v17; // r0
  int v18; // r7
  bool v19; // zf
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int (__fastcall *v24)(int, signed int, _DWORD); // r3
  int v25; // r9
  void (__fastcall *v26)(_DWORD, int, signed int, _DWORD); // r12
  int v27; // r3
  _DWORD *v28; // r0
  _DWORD *v29; // r7
  _DWORD *result; // r0
  int v31; // r2
  int v32; // r3
  void (__fastcall *v33)(_DWORD, _DWORD); // r12
  int v34; // r7
  int v35; // r0
  __int16 v36; // r0
  int *v37; // r7
  int *v38; // r3
  int v39; // r0
  __int16 v40; // r0
  signed int v41; // r3
  int v42; // r0
  int v43; // r1
  int v44; // r0
  bool v45; // nf
  int v46; // r1
  int v47; // r2
  int v48; // r3
  int (__fastcall *v49)(int, signed int, _DWORD); // r3
  int v50; // r9
  void (__fastcall *v51)(_DWORD, int, signed int, _DWORD); // r12
  int v52; // r7
  char v53; // r0
  _DWORD *v54; // r3
  int v55; // r1
  int v56; // kr00_4
  _DWORD *v57; // r7
  signed int v58; // r3
  _DWORD *v59; // r4
  socklen_t len; // [sp+8h] [bp-58h]
  socklen_t lena; // [sp+8h] [bp-58h]
  int v62; // [sp+14h] [bp-4Ch]
  __int16 s; // [sp+18h] [bp-48h]
  __int16 v64; // [sp+1Ah] [bp-46h]
  int v65; // [sp+1Ch] [bp-44h]
  int v66; // [sp+20h] [bp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1[29];
  v6 = a1;
  v7 = 80 * *(_DWORD *)(a2 + 88);
  v8 = (_DWORD *)(v5 + v7);
  if ( *(_DWORD *)(a2 + 96) )
  {
    if ( v8[6] != -1 )
    {
LABEL_22:
      v28 = calloc(1u, 0x14u);
      v29 = v28;
      if ( !v28 )
      {
        sub_CC34E(v6, v4, 15, 0, 0);
        return result;
      }
      v28[3] = 0;
      *v28 = *(_DWORD *)(v4 + 60);
      v31 = *(_DWORD *)(v4 + 64);
      v28[2] = v4;
      v28[4] = 0;
      v28[1] = v31;
      v32 = v8[13];
      if ( v32 )
      {
        *(_DWORD *)(v32 + 16) = v28;
      }
      else
      {
        v33 = (void (__fastcall *)(_DWORD, _DWORD))v6[9318];
        if ( v33 )
          v33(v6[9319], v8[6]);
        v8[12] = v29;
      }
      v8[13] = v29;
      *(_DWORD *)(*(_DWORD *)(v4 + 92) + 8 * *(_DWORD *)(v4 + 88) + 4) = v8[14];
      goto LABEL_53;
    }
    v9 = *(_DWORD *)(v5 + v7);
    if ( v9 == 2 )
    {
      memset(&s, 0, 0x10u);
      v14 = v6[6];
      s = 2;
      len = 16;
      v64 = aresx_sitous(v14);
      v65 = v8[1];
    }
    else
    {
      if ( v9 != 10 )
        goto LABEL_52;
      memset(&s, 0, 0x1Cu);
      v10 = v6[6];
      s = 10;
      v11 = aresx_sitous(v10);
      v12 = &v66;
      v13 = v8 + 1;
      v64 = v11;
      do
      {
        v15 = *v13;
        v13 += 2;
        v16 = *(v13 - 1);
        *v12 = v15;
        v12[1] = v16;
        v12 += 2;
      }
      while ( v13 != v8 + 5 );
      len = 28;
    }
    v17 = socket(*(_DWORD *)(v5 + v7), 1, 0);
    v18 = v17;
    if ( v17 != -1 )
    {
      if ( sub_CC15C(v17, *(_DWORD *)(v5 + v7), v6) >= 0 )
      {
        v62 = 1;
        v19 = setsockopt(v18, 6, 1, &v62, 4u) == -1;
        v20 = v18;
        if ( !v19 )
        {
          if ( connect(v18, (const struct sockaddr *)&s, len) != -1
            || (v23 = *(_DWORD *)_errno(0, v21, v22), v23 == 115)
            || v23 == 11 )
          {
            v24 = (int (__fastcall *)(int, signed int, _DWORD))v6[9320];
            if ( v24 && (v25 = v24(v18, 1, v6[9321]), v25 < 0) )
            {
              close(v18);
              if ( v25 == -1 )
                goto LABEL_52;
            }
            else
            {
              v26 = (void (__fastcall *)(_DWORD, int, signed int, _DWORD))v6[9318];
              if ( v26 )
                v26(v6[9319], v18, 1, 0);
              v8[6] = v18;
              v8[11] = 0;
              v27 = v6[96] + 1;
              v6[96] = v27;
              v8[14] = v27;
            }
            goto LABEL_22;
          }
          goto LABEL_42;
        }
LABEL_43:
        close(v20);
        goto LABEL_52;
      }
      goto LABEL_42;
    }
LABEL_52:
    sub_CC14E(v6[30], (_DWORD *)(v4 + 92), *(_DWORD *)(v4 + 88));
    sub_CC400(v6, (_DWORD *)v4, v3);
    return result;
  }
  if ( v8[5] == -1 )
  {
    v34 = *(_DWORD *)(v5 + v7);
    if ( v34 == 2 )
    {
      memset(&s, 0, 0x10u);
      v39 = v6[5];
      s = 2;
      v40 = aresx_sitous(v39);
      v41 = 16;
      v64 = v40;
      v65 = v8[1];
    }
    else
    {
      if ( v34 != 10 )
        goto LABEL_52;
      memset(&s, 0, 0x1Cu);
      v35 = v6[5];
      s = 10;
      v36 = aresx_sitous(v35);
      v37 = &v66;
      v38 = v8 + 1;
      v64 = v36;
      do
      {
        v42 = *v38;
        v38 += 2;
        v43 = *(v38 - 1);
        *v37 = v42;
        v37[1] = v43;
        v37 += 2;
      }
      while ( v38 != v8 + 5 );
      v41 = 28;
    }
    lena = v41;
    v44 = socket(*(_DWORD *)(v5 + v7), 2, 0);
    v18 = v44;
    if ( v44 == -1 )
      goto LABEL_52;
    v45 = sub_CC15C(v44, *(_DWORD *)(v5 + v7), v6) < 0;
    v20 = v18;
    if ( v45 )
      goto LABEL_43;
    if ( connect(v18, (const struct sockaddr *)&s, lena) == -1 )
    {
      v48 = *(_DWORD *)_errno(0, v46, v47);
      if ( v48 != 115 && v48 != 11 )
      {
LABEL_42:
        v20 = v18;
        goto LABEL_43;
      }
    }
    v49 = (int (__fastcall *)(int, signed int, _DWORD))v6[9320];
    if ( v49 && (v50 = v49(v18, 2, v6[9321]), v50 < 0) )
    {
      close(v18);
      if ( v50 == -1 )
        goto LABEL_52;
    }
    else
    {
      v51 = (void (__fastcall *)(_DWORD, int, signed int, _DWORD))v6[9318];
      if ( v51 )
        v51(v6[9319], v18, 1, 0);
      v8[5] = v18;
    }
  }
  if ( send(v8[5], *(const void **)(v4 + 68), *(_DWORD *)(v4 + 72), 0x4000) == -1 )
    goto LABEL_52;
LABEL_53:
  v52 = v6[1] << *(_DWORD *)(v4 + 84) / v6[30];
  v53 = lrand48();
  v54 = (_DWORD *)(v4 + 4);
  v55 = v3[1];
  *v54 = *v3;
  v54[1] = v55;
  v56 = ((v53 & 7) + 9) * v52;
  v57 = (_DWORD *)(v4 + 24);
  ares__timeadd((_DWORD *)(v4 + 4), v56 / 16);
  ares__remove_from_list((_DWORD *)(v4 + 24));
  v58 = *(_DWORD *)(v4 + 4) & 0x800003FF;
  if ( v58 < 0 )
    v58 = -(~(((*(_DWORD *)(v4 + 4) & 0x800003FF) - 1) << 22) >> 22);
  v59 = (_DWORD *)(v4 + 36);
  ares__insert_in_list(v57, (int)&v6[3 * v58 + 6246]);
  ares__remove_from_list(v59);
  return ares__insert_in_list(v59, (int)(v8 + 15));
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000CC7D8) --------------------------------------------------------
void __fastcall sub_CC7D8(_DWORD *a1, int a2, _DWORD *a3)
{
  int v3; // r8
  _DWORD *v4; // r7
  int *v5; // r6
  int *v6; // r5
  _BOOL4 v7; // ST04_4
  _BOOL4 v8; // r0
  int v9; // r12
  int **v10; // r11
  _DWORD *v11; // r6
  int v12; // r1
  int v13; // r2
  int v14; // r9
  int v15; // r2
  int *v16; // r5
  _DWORD *v17; // r6
  _BOOL4 v18; // [sp+8h] [bp-58h]
  _DWORD *v19; // [sp+Ch] [bp-54h]
  int v20; // [sp+14h] [bp-4Ch]
  int **v21; // [sp+18h] [bp-48h]
  int v22; // [sp+1Ch] [bp-44h]
  int v23; // [sp+20h] [bp-40h]
  int **v24; // [sp+24h] [bp-3Ch]
  int v25; // [sp+28h] [bp-38h]
  int v26; // [sp+2Ch] [bp-34h]
  _DWORD *v27; // [sp+30h] [bp-30h]
  int v28; // [sp+34h] [bp-2Ch]

  v3 = a2;
  v19 = a3;
  v4 = a1;
  v5 = (int *)(a1[29] + 80 * a2);
  v6 = v5 + 15;
  ares__close_sockets(a1, v5);
  ares__init_list_head(&v20);
  v7 = ares__is_list_empty(&v20);
  v8 = ares__is_list_empty(v5 + 15);
  v9 = v20;
  v10 = v21;
  v11 = (_DWORD *)v5[16];
  v18 = v8;
  v23 = v20;
  v24 = v21;
  v25 = v22;
  v12 = v6[1];
  v13 = v6[2];
  v26 = *v6;
  v27 = (_DWORD *)v12;
  v28 = v13;
  v14 = v26;
  if ( v7 )
  {
    ares__init_list_head(v6);
  }
  else
  {
    v23 = v20;
    v24 = v21;
    v15 = v25;
    *v6 = v20;
    v6[1] = (int)v10;
    v6[2] = v15;
    *v10 = v6;
    *(_DWORD *)(v9 + 4) = v6;
  }
  if ( v18 )
  {
    ares__init_list_head(&v20);
  }
  else
  {
    v26 = v14;
    v27 = v11;
    v20 = v14;
    v21 = (int **)v11;
    v22 = v28;
    *v11 = &v20;
    *(_DWORD *)(v14 + 4) = &v20;
  }
  v16 = (int *)v21;
  while ( v16 != &v20 )
  {
    v17 = (_DWORD *)v16[2];
    v16 = (int *)v16[1];
    sub_CC14E(v4[30], v17 + 23, v3);
    sub_CC400(v4, v17, v19);
  }
}

//----- (000CC89C) --------------------------------------------------------
void __fastcall sub_CC89C(int *a1, unsigned __int8 *a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // r7
  int *v7; // r6
  int v8; // r5
  int v9; // r9
  unsigned __int16 *v10; // r4
  int v11; // r8
  int v12; // r11
  int v13; // r3
  int v14; // r10
  int v15; // r2
  int v16; // r3
  char *v17; // r0
  unsigned int v18; // r0
  unsigned __int8 *v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  __int16 v23; // r7
  signed int v24; // r1
  int v25; // [sp+8h] [bp-88h]
  int v26; // [sp+Ch] [bp-84h]
  char *ptr; // [sp+10h] [bp-80h]
  int v28; // [sp+14h] [bp-7Ch]
  int v29; // [sp+18h] [bp-78h]
  int v30; // [sp+1Ch] [bp-74h]
  int v31; // [sp+20h] [bp-70h]
  unsigned __int8 v32; // [sp+28h] [bp-68h]
  unsigned __int8 v33; // [sp+2Ch] [bp-64h]
  unsigned int v34; // [sp+38h] [bp-58h]
  int v35; // [sp+3Ch] [bp-54h]
  char *s1; // [sp+40h] [bp-50h]
  int v37; // [sp+44h] [bp-4Ch]
  int v38; // [sp+48h] [bp-48h]
  int v39; // [sp+4Ch] [bp-44h]
  unsigned int v40; // [sp+50h] [bp-40h]
  int v41; // [sp+54h] [bp-3Ch]
  char *s2; // [sp+58h] [bp-38h]
  int v43; // [sp+5Ch] [bp-34h]
  int v44; // [sp+60h] [bp-30h]
  int v45; // [sp+64h] [bp-2Ch]

  v6 = a3;
  v31 = a4;
  v7 = a1;
  v8 = (int)a2;
  v29 = a2[1] | (*a2 << 8);
  v32 = a2[2];
  v33 = a2[3];
  v30 = (int)&a1[3 * (_byteswap_ushort(*(_WORD *)a2) & 0x7FF) + 102];
  v9 = a1[3 * (_byteswap_ushort(*(_WORD *)a2) & 0x7FF) + 103];
LABEL_2:
  if ( v9 == v30 )
    return;
  v10 = *(unsigned __int16 **)(v9 + 8);
  if ( *v10 != v29 )
    goto LABEL_27;
  v11 = *((_DWORD *)v10 + 17);
  v28 = *((_DWORD *)v10 + 18);
  if ( *((_DWORD *)v10 + 18) <= 11 )
    goto LABEL_27;
  if ( v6 <= 11 )
    goto LABEL_27;
  v35 = *(unsigned __int8 *)(*((_DWORD *)v10 + 17) + 5) | (*(unsigned __int8 *)(*((_DWORD *)v10 + 17) + 4) << 8);
  v41 = *(unsigned __int8 *)(v8 + 5) | (*(unsigned __int8 *)(v8 + 4) << 8);
  if ( v35 != v41 )
    goto LABEL_27;
  v12 = 0;
  v34 = v11 + 12;
  while ( v12 < v35 )
  {
    if ( ares_expand_name(v34, v11, v28, &s1, &v37) )
      goto LABEL_27;
    v13 = v34 + v37;
    if ( v34 + v37 + 4 > v28 + v11 )
    {
LABEL_16:
      v17 = s1;
LABEL_19:
      free(v17);
LABEL_27:
      v9 = *(_DWORD *)(v9 + 4);
      goto LABEL_2;
    }
    v14 = 0;
    v38 = *(unsigned __int8 *)(v34 + v37 + 1) | (*(unsigned __int8 *)(v34 + v37) << 8);
    v34 += v37 + 4;
    v39 = *(unsigned __int8 *)(v13 + 3) | (*(unsigned __int8 *)(v13 + 2) << 8);
    v40 = v8 + 12;
    while ( v14 < v41 )
    {
      if ( ares_expand_name(v40, v8, v6, &s2, &v43) )
        goto LABEL_16;
      v18 = v40;
      v19 = (unsigned __int8 *)(v40 + v43);
      v40 = (unsigned int)v19;
      v20 = (int)(v19 + 4);
      if ( (unsigned int)(v19 + 4) > v8 + v6 )
      {
        free(s1);
        v17 = s2;
        goto LABEL_19;
      }
      v44 = v19[1] | (*(unsigned __int8 *)(v18 + v43) << 8);
      v15 = v19[2];
      v16 = v19[3];
      v40 = v20;
      v45 = v16 | (v15 << 8);
      v25 = v16 | (v15 << 8);
      ptr = s2;
      v26 = v44;
      if ( !strcasecmp(s1, s2) && v38 == v26 && v39 == v25 )
      {
        free(ptr);
        break;
      }
      ++v14;
      free(ptr);
    }
    free(s1);
    if ( v14 == v41 )
      goto LABEL_27;
    ++v12;
  }
  v21 = *v7;
  v22 = v33 & 0xF;
  if ( *v7 & 0x100 )
  {
    v24 = v7[14];
    if ( v22 == 4 || (unsigned int)(v22 - 1) <= 1 )
    {
      *v7 = v21 ^ 0x100;
      v23 = v6 - 11;
      *((_DWORD *)v10 + 16) -= 11;
      *((_DWORD *)v10 + 18) -= 11;
      **((_BYTE **)v10 + 15) = HIBYTE(v23);
      *(_BYTE *)(*((_DWORD *)v10 + 15) + 1) = v23;
      *(_BYTE *)(*((_DWORD *)v10 + 15) + 12) = 0;
      *(_BYTE *)(*((_DWORD *)v10 + 15) + 13) = 0;
      *((_DWORD *)v10 + 15) = realloc(*((void **)v10 + 15), *((_DWORD *)v10 + 16));
LABEL_37:
      ares__send_query(v7, (int)v10, a6);
      return;
    }
  }
  else
  {
    v24 = 512;
  }
  if ( (v32 & 2 || v6 > v24) && !a5 )
  {
    if ( !(v21 & 4) )
    {
      if ( *((_DWORD *)v10 + 24) )
        return;
      *((_DWORD *)v10 + 24) = 1;
      goto LABEL_37;
    }
    if ( v6 >= v24 )
      v6 = v24;
  }
  if ( v21 & 0x80 || v22 != 2 && (unsigned int)(v22 - 4) > 1 )
  {
    sub_CC34E(v7, (int)v10, 0, v8, v6);
  }
  else
  {
    sub_CC14E(v7[30], (_DWORD *)v10 + 23, v31);
    if ( *((_DWORD *)v10 + 22) == v31 )
      sub_CC400(v7, v10, a6);
  }
}

//----- (000CCAEC) --------------------------------------------------------
int *__fastcall sub_CCAEC(int *a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // r6
  int v5; // r7
  int i; // r5
  _DWORD *v7; // r4
  int v8; // r3
  int v9; // r2
  int v10; // r1
  signed int v11; // r3
  int v12; // r0
  socklen_t v13; // r3
  ssize_t v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r10
  const void *v18; // r0
  char *v19; // r1
  size_t v20; // r2
  int v22; // [sp+Ch] [bp-105Ch]
  _DWORD *v23; // [sp+10h] [bp-1058h]
  socklen_t addr_len; // [sp+18h] [bp-1050h]
  unsigned __int16 addr; // [sp+1Ch] [bp-104Ch]
  char v26; // [sp+20h] [bp-1048h]
  int v27; // [sp+24h] [bp-1044h]
  char buf; // [sp+38h] [bp-1030h]
  int v29; // [sp+103Ch] [bp-2Ch]

  v4 = a1;
  v5 = a2;
  v23 = a4;
  v22 = a3;
  if ( a2 || a3 != -1 )
  {
    for ( i = 0; i < v4[30]; ++i )
    {
      v7 = (_DWORD *)(v4[29] + 80 * i);
      v8 = v7[5];
      if ( v8 != -1 && !v7[19] )
      {
        if ( v5 )
        {
          v9 = v8 >> 5;
          v10 = *(_DWORD *)(v5 + 4 * (v8 >> 5));
          v11 = 1 << (v8 & 0x1F);
          if ( v11 & v10 )
          {
            *(_DWORD *)(v5 + 4 * v9) = v10 & ~v11;
            goto LABEL_11;
          }
        }
        else if ( v8 == v22 )
        {
LABEL_11:
          while ( 1 )
          {
            v12 = v7[5];
            if ( v12 == -1 )
              break;
            if ( *v7 == 2 )
              v13 = 16;
            else
              v13 = 28;
            addr_len = v13;
            v14 = recvfrom(v12, &buf, 0x1001u, 0, (struct sockaddr *)&addr, &addr_len);
            v17 = v14;
            if ( v14 == -1 )
            {
              if ( *(_DWORD *)_errno(-1, v15, v16) == 11 )
                goto LABEL_26;
              break;
            }
            if ( v14 <= 0 )
              break;
            if ( addr != *v7 )
              goto LABEL_26;
            if ( addr == 2 )
            {
              v18 = v7 + 1;
              v19 = &v26;
              v20 = 4;
            }
            else
            {
              if ( addr != 10 )
                goto LABEL_26;
              v18 = v7 + 1;
              v19 = (char *)&v27;
              v20 = 16;
            }
            if ( memcmp(v18, v19, v20) )
              goto LABEL_26;
            if ( v17 > 11 )
              sub_CC89C(v4, (unsigned __int8 *)&buf, v17, i, 0, v23);
          }
          sub_CC7D8(v4, i, v23);
        }
      }
LABEL_26:
      ;
    }
  }
  return &v29;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000CCC28) --------------------------------------------------------
void __fastcall sub_CCC28(int *a1, int a2, int a3, int a4, int a5)
{
  int *v5; // r4
  int v6; // r8
  int v7; // r9
  int i; // r6
  _DWORD *v9; // r1
  int v10; // r3
  int v11; // r2
  signed int v12; // r3
  int v13; // r0
  int v14; // r7
  int v15; // r0
  int j; // r2
  const struct iovec *v17; // r0
  _DWORD *v18; // r1
  const struct iovec *v19; // r3
  int v20; // lr
  struct iovec *v21; // ST10_4
  ssize_t v22; // r7
  ssize_t v23; // r0
  int v24; // r1
  unsigned int v25; // r2
  int v26; // r0
  int v27; // r1
  int k; // r6
  int v29; // r7
  int v30; // r3
  int l; // r7
  int v32; // r2
  signed int v33; // r3
  int v34; // r1
  int v35; // r2
  ssize_t v36; // r0
  int v37; // r1
  int v38; // r2
  int v39; // r0
  int v40; // r0
  void *v41; // r0
  int v42; // r3
  int v43; // r2
  void *v44; // r0
  unsigned int v45; // r3
  int v46; // r10
  int v47; // r8
  _DWORD *v48; // r6
  int v49; // r3
  int v50; // r6
  _DWORD *ptr; // [sp+10h] [bp-38h]
  int v52; // [sp+14h] [bp-34h]
  int v53; // [sp+18h] [bp-30h]

  v5 = a1;
  v6 = a4;
  v52 = a2;
  v7 = a3;
  ares__tvnow(&v53);
  if ( v6 || a5 != -1 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v5[30] )
        break;
      v9 = (_DWORD *)(v5[29] + 80 * i);
      if ( v9[12] )
      {
        v10 = v9[6];
        if ( v10 != -1 && !v9[19] )
        {
          if ( v6 )
          {
            v11 = v10 >> 5;
            v12 = 1 << (v10 & 0x1F);
            v13 = *(_DWORD *)(v6 + 4 * v11);
            if ( !(v12 & v13) )
              continue;
            *(_DWORD *)(v6 + 4 * v11) = v13 & ~v12;
          }
          else if ( v10 != a5 )
          {
            continue;
          }
          v14 = v9[12];
          v15 = 0;
          for ( j = v9[12]; j; j = *(_DWORD *)(j + 16) )
            ++v15;
          ptr = v9;
          v17 = (const struct iovec *)malloc(8 * v15);
          v18 = ptr;
          v19 = v17;
          if ( v17 )
          {
            v20 = 0;
            while ( 1 )
            {
              ++v17;
              if ( !v14 )
                break;
              ++v20;
              v17[-1].iov_base = *(void **)v14;
              v17[-1].iov_len = *(_DWORD *)(v14 + 4);
              v14 = *(_DWORD *)(v14 + 16);
            }
            v21 = (struct iovec *)v19;
            v22 = writev(v18[6], v19, v20);
            free(v21);
            if ( v22 >= 0 )
            {
              v26 = (int)v5;
              v27 = i;
              v25 = v22;
LABEL_29:
              sub_CC0F2(v26, v27, v25);
              continue;
            }
          }
          else
          {
            v23 = send(ptr[6], *(const void **)v14, *(_DWORD *)(v14 + 4), 0x4000);
            v25 = v23;
            if ( v23 >= 0 )
            {
              v26 = (int)v5;
              v27 = i;
              goto LABEL_29;
            }
          }
          if ( *(_DWORD *)_errno(v23, v24, v25) != 11 )
            sub_CC7D8(v5, i, &v53);
        }
      }
    }
  }
  if ( v52 || v7 != -1 )
  {
    for ( k = 0; ; ++k )
    {
      if ( k >= v5[30] )
        break;
      v29 = v5[29] + 80 * k;
      v30 = *(_DWORD *)(v29 + 24);
      if ( v30 != -1 && !*(_DWORD *)(v29 + 76) )
      {
        if ( v52 )
        {
          v32 = v30 >> 5;
          v33 = 1 << (v30 & 0x1F);
          v34 = *(_DWORD *)(v52 + 4 * v32);
          if ( !(v33 & v34) )
            continue;
          *(_DWORD *)(v52 + 4 * v32) = v34 & ~v33;
        }
        else if ( v30 != v7 )
        {
          continue;
        }
        v35 = *(_DWORD *)(v29 + 32);
        if ( v35 == 2 )
        {
          v36 = recv(
                  *(_DWORD *)(v29 + 24),
                  (void *)(*(_DWORD *)(v29 + 40) + *(_DWORD *)(v29 + 44)),
                  *(_DWORD *)(v29 + 36) - *(_DWORD *)(v29 + 44),
                  0);
          if ( v36 > 0 )
          {
            v42 = *(_DWORD *)(v29 + 36);
            v43 = *(_DWORD *)(v29 + 44) + v36;
            *(_DWORD *)(v29 + 44) = v43;
            if ( v43 != v42 )
              continue;
            if ( v43 > 11 )
              sub_CC89C(v5, *(unsigned __int8 **)(v29 + 40), v43, k, 1, &v53);
            v44 = *(void **)(v29 + 40);
            if ( v44 )
              free(v44);
            *(_DWORD *)(v29 + 40) = 0;
            *(_DWORD *)(v29 + 32) = 0;
            goto LABEL_56;
          }
        }
        else
        {
          v36 = recv(*(_DWORD *)(v29 + 24), (void *)(v29 + v35 + 28), 2 - v35, 0);
          if ( v36 > 0 )
          {
            v39 = v36 + *(_DWORD *)(v29 + 32);
            *(_DWORD *)(v29 + 32) = v39;
            if ( v39 != 2 )
              continue;
            v40 = *(unsigned __int8 *)(v29 + 29) | (*(unsigned __int8 *)(v29 + 28) << 8);
            *(_DWORD *)(v29 + 36) = v40;
            v41 = malloc(v40);
            *(_DWORD *)(v29 + 40) = v41;
            if ( !v41 )
              sub_CC7D8(v5, k, &v53);
LABEL_56:
            *(_DWORD *)(v29 + 44) = 0;
            continue;
          }
        }
        if ( v36 != -1 || *(_DWORD *)_errno(0, v37, v38) != 11 )
          sub_CC7D8(v5, k, &v53);
      }
    }
  }
  sub_CCAEC(v5, v52, v7, &v53);
  for ( l = v5[97]; l <= v53; ++l )
  {
    v45 = l & 0x800003FF;
    if ( (l & 0x800003FF & 0x80000000) != 0 )
      v45 = -(~((v45 - 1) << 22) >> 22);
    v46 = (int)&v5[3 * v45 + 6246];
    v47 = *(_DWORD *)(v46 + 4);
    while ( v47 != v46 )
    {
      v48 = *(_DWORD **)(v47 + 8);
      v47 = *(_DWORD *)(v47 + 4);
      if ( v48[1] && ares__timedout(&v53, v48 + 1) )
      {
        v49 = v48[26];
        v48[25] = 12;
        v48[26] = v49 + 1;
        sub_CC400(v5, v48, &v53);
      }
    }
  }
  v50 = 0;
  v5[97] = v53;
  while ( v50 < v5[30] )
  {
    if ( *(_DWORD *)(v5[29] + 80 * v50 + 76) )
      sub_CC7D8(v5, v50, &v53);
    ++v50;
  }
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000CCEE0) --------------------------------------------------------
void __fastcall ares_process(int *a1, int a2, int a3)
{
  sub_CCC28(a1, a2, -1, a3, -1);
}

//----- (000CCEF4) --------------------------------------------------------
void __fastcall ares_process_fd(int *a1, int a2, int a3)
{
  sub_CCC28(a1, 0, a2, 0, a3);
}

//----- (000CCF0A) --------------------------------------------------------
void __fastcall sub_CCF0A(_DWORD *a1, signed int a2, int a3, _BYTE *a4, int a5)
{
  void *v5; // r5
  signed int v6; // r4
  void (__fastcall *v7)(_DWORD, signed int, int, _BYTE *, int, signed int); // r7

  v5 = a1;
  v6 = a2;
  v7 = (void (__fastcall *)(_DWORD, signed int, int, _BYTE *, int, signed int))*a1;
  if ( a2 )
  {
    v7(a1[1], a2, a3, a4, a5, a2);
  }
  else
  {
    switch ( a4[3] & 0xF )
    {
      case 0:
        v6 = ((unsigned __int8)a4[7] | ((unsigned __int8)a4[6] << 8)) == 0;
        break;
      case 1:
        v6 = 2;
        break;
      case 2:
        v6 = 3;
        break;
      case 3:
        v6 = 4;
        break;
      case 4:
        v6 = 5;
        break;
      case 5:
        v6 = 6;
        break;
      default:
        break;
    }
    v7(a1[1], v6, a3, a4, a5, a2);
  }
  j_free(v5);
}

//----- (000CCF70) --------------------------------------------------------
int __fastcall ares__generate_new_id(int a1, int a2, int a3)
{
  char v3; // r4
  int v4; // r3
  _DWORD *v5; // r2
  int v6; // r1
  char v7; // r5
  int v9; // [sp+4h] [bp-1Ch]
  int v10; // [sp+8h] [bp-18h]

  v9 = a2;
  v10 = a3;
  v3 = *(_BYTE *)(a1 + 256);
  HIWORD(v9) = 0;
  LOBYTE(v4) = *(_BYTE *)(a1 + 257);
  v5 = (int *)((char *)&v9 + 1);
  do
  {
    v6 = (unsigned __int8)(v3 + 1);
    v7 = *(_BYTE *)(a1 + v6);
    ++v3;
    v4 = (unsigned __int8)(v4 + v7);
    *(_BYTE *)(a1 + v6) = *(_BYTE *)(a1 + v4);
    *(_BYTE *)(a1 + v4) = v7;
    *((_BYTE *)v5 + 1) ^= *(_BYTE *)(a1 + (unsigned __int8)(v7 + *(_BYTE *)(a1 + v6)));
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v9 + 3) );
  *(_BYTE *)(a1 + 256) = v3;
  *(_BYTE *)(a1 + 257) = v4;
  return HIWORD(v9);
}

//----- (000CCFC0) --------------------------------------------------------
int __fastcall ares_query(int a1, const char *a2, __int16 a3, __int16 a4, int (__fastcall *a5)(int, signed int), int a6)
{
  int v6; // r4
  int v7; // r5
  int v8; // r1
  unsigned __int16 *v9; // r2
  signed int v10; // r5
  int v11; // r0
  signed int v12; // r1
  __int16 v13; // r0
  int i; // r3
  _DWORD *v15; // r0
  unsigned __int16 v17; // [sp+16h] [bp-2Ah]
  void *ptr; // [sp+18h] [bp-28h]
  int v19; // [sp+1Ch] [bp-24h]

  v6 = a1;
  v7 = *(_DWORD *)a1 & 0x100;
  if ( v7 )
    v7 = *(_DWORD *)(a1 + 56);
  v10 = ares_create_query(a2, a3, a4, *(_WORD *)(a1 + 124), (*(_DWORD *)a1 & 8) == 0, &ptr, (size_t *)&v19, v7);
  if ( v10 )
  {
    if ( ptr )
      free(ptr);
    v11 = a6;
    v12 = v10;
    return a5(v11, v12);
  }
LABEL_7:
  v13 = ares__generate_new_id(v6 + 126, v8, (int)v9);
  LOBYTE(v17) = HIBYTE(v13);
  HIBYTE(v17) = v13;
  v8 = v6 + 12 * (v17 & 0x7FF) + 408;
  for ( i = *(_DWORD *)(v6 + 12 * (v17 & 0x7FF) + 412); i != v8; i = *(_DWORD *)(i + 4) )
  {
    v9 = *(unsigned __int16 **)(i + 8);
    if ( *v9 == v17 )
    {
      if ( v9 )
        goto LABEL_7;
      break;
    }
  }
  *(_WORD *)(v6 + 124) = v13;
  v15 = malloc(8u);
  if ( !v15 )
  {
    ares_free_string(ptr);
    v11 = a6;
    v12 = 15;
    return a5(v11, v12);
  }
  *v15 = a5;
  v15[1] = a6;
  ares_send((_DWORD *)v6, (unsigned __int8 *)ptr, v19, (int (__fastcall *)(int, signed int))sub_CCF0A, (int)v15);
  return ares_free_string(ptr);
}
// CE4BE: using guessed type int __fastcall ares_free_string(_DWORD);

//----- (000CD0B0) --------------------------------------------------------
void __fastcall sub_CD0B0(int a1, int a2, int a3, int a4)
{
  void **v4; // r4

  v4 = (void **)a1;
  (*(void (__fastcall **)(_DWORD, int, _DWORD, int, int, int))(a1 + 16))(
    *(_DWORD *)(a1 + 20),
    a2,
    *(_DWORD *)(a1 + 36),
    a3,
    a4,
    a2);
  free(v4[1]);
  j_free(v4);
}

//----- (000CD0D4) --------------------------------------------------------
signed int __fastcall sub_CD0D4(const char *a1, const char *a2, _DWORD *a3)
{
  const char *v3; // r8
  _DWORD *v4; // r5
  const char *v5; // r9
  size_t v6; // r4
  size_t v7; // r0
  int v8; // r6
  size_t v9; // r7
  void *v10; // r0
  signed int result; // r0

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = strlen(a1);
  v7 = strlen(v3);
  v8 = v7 + v6;
  v9 = v7;
  v10 = malloc(v7 + v6 + 2);
  *v4 = v10;
  if ( !v10 )
    return 15;
  memcpy(v10, v5, v6);
  *(_BYTE *)(*v4 + v6) = 46;
  memcpy((void *)(v6 + 1 + *v4), v3, v9);
  result = 0;
  *(_BYTE *)(v8 + *v4 + 1) = 0;
  return result;
}

//----- (000CD128) --------------------------------------------------------
void __fastcall sub_CD128(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r4
  int v6; // r6
  int v7; // r2
  int v8; // r3
  int v9; // r3
  int v10; // r3
  void *ptr; // [sp+Ch] [bp-1Ch]

  v5 = (_DWORD *)a1;
  v6 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 36) += a3;
  if ( a2 == 1 || (unsigned int)(a2 - 3) <= 1 )
  {
    if ( *(_DWORD *)(a1 + 32) )
      *(_DWORD *)(a1 + 24) = a2;
    v9 = *(_DWORD *)(a1 + 28);
    if ( a2 == 1 )
      *(_DWORD *)(a1 + 40) = 1;
    if ( v9 >= *(_DWORD *)(v6 + 40) )
    {
      a2 = *(_DWORD *)(a1 + 24);
      if ( a2 == -1 )
      {
        *(_DWORD *)(a1 + 32) = 1;
        ares_query(
          v6,
          *(const char **)(a1 + 4),
          *(_DWORD *)(a1 + 8),
          *(_DWORD *)(a1 + 12),
          (int (__fastcall *)(int, signed int))sub_CD128,
          a1);
        return;
      }
      if ( a2 == 4 )
      {
        if ( *(_DWORD *)(a1 + 40) )
          a2 = 1;
      }
    }
    else
    {
      a2 = sub_CD0D4(*(const char **)(a1 + 4), *(const char **)(*(_DWORD *)(v6 + 36) + 4 * v9), &ptr);
      if ( !a2 )
      {
        v10 = v5[7];
        v5[8] = 0;
        v5[7] = v10 + 1;
        ares_query(v6, (const char *)ptr, v5[2], v5[3], (int (__fastcall *)(int, signed int))sub_CD128, (int)v5);
        free(ptr);
        return;
      }
      a1 = (int)v5;
    }
    v7 = 0;
    v8 = 0;
  }
  else
  {
    v7 = a4;
    v8 = a5;
  }
  sub_CD0B0(a1, a2, v7, v8);
}

//----- (000CD1D4) --------------------------------------------------------
void __fastcall ares_search(int a1, char *s, int a3, int a4, int a5, int a6)
{
  int v6; // r5
  char *v7; // r4
  int v8; // r8
  int v9; // r9
  size_t v10; // r10
  int v11; // r10
  char *v12; // r0
  int v13; // r1
  int v14; // r2
  FILE *v15; // r7
  char *v16; // r11
  char *v17; // r11
  char *v18; // r2
  int v19; // r0
  unsigned __int8 *v20; // r1
  char *v21; // r10
  int v22; // r0
  int v23; // t1
  size_t v24; // r10
  unsigned __int8 *src; // ST0C_4
  void *v26; // r0
  unsigned __int8 *v27; // r1
  _BYTE *v28; // ST0C_4
  int v29; // r0
  signed int v30; // r1
  char *v31; // r11
  _DWORD *v32; // r0
  int v33; // r7
  char *v34; // r2
  int v35; // r3
  int v36; // r10
  int v37; // t1
  signed int v38; // r4
  void *ptr; // [sp+1Ch] [bp-34h]
  char *s1; // [sp+20h] [bp-30h]
  char v41; // [sp+24h] [bp-2Ch]

  v6 = a1;
  v7 = s;
  v8 = a4;
  v9 = a3;
  s1 = 0;
  v10 = strlen(s);
  if ( v7[v10 - 1] != 46 )
  {
    if ( !(*(_DWORD *)v6 & 0x40) && !strchr(v7, 46) )
    {
      v12 = getenv("HOSTALIASES");
      if ( v12 )
      {
        v15 = fopen(v12, "r");
        if ( v15 )
        {
          while ( 1 )
          {
            v16 = ares__read_line((int)v15, &s1, &v41);
            if ( v16 )
              break;
            v17 = s1;
            if ( !strncasecmp(s1, v7, v10) )
            {
              v18 = &v17[v10];
              if ( *(_BYTE *)((unsigned __int8)v17[v10] + ctype_ + 1) & 8 )
              {
                do
                {
                  v19 = (unsigned __int8)*v18;
                  v20 = (unsigned __int8 *)v18++;
                }
                while ( *(_BYTE *)(ctype_ + v19 + 1) & 8 );
                if ( v19 )
                {
                  do
                  {
                    v21 = v18;
                    v23 = (unsigned __int8)*v18++;
                    v22 = v23;
                  }
                  while ( v23 && !(*(_BYTE *)(v22 + ctype_ + 1) & 8) );
                  v24 = v21 - (char *)v20;
                  src = v20;
                  v26 = malloc(v24 + 1);
                  v27 = src;
                  ptr = v26;
                  if ( v26 )
                  {
                    v28 = v26;
                    memcpy(v26, v27, v24);
                    v28[v24] = 0;
                  }
                  free(v17);
                  fclose(v15);
                  if ( ptr )
                    goto LABEL_3;
                  goto LABEL_17;
                }
              }
            }
          }
          free(s1);
          fclose(v15);
          if ( v16 == &byte_9[4] )
            goto LABEL_24;
          v11 = (int)v16;
          if ( !v16 )
            goto LABEL_29;
          goto LABEL_28;
        }
        if ( (unsigned int)(*(_DWORD *)_errno(0, v13, v14) - 2) > 1 )
        {
          ptr = 0;
          v11 = 14;
          goto LABEL_28;
        }
      }
    }
LABEL_24:
    v11 = *(_DWORD *)v6 & 0x20;
    if ( !v11 && *(_DWORD *)(v6 + 40) )
    {
      ptr = (void *)(*(_DWORD *)v6 & 0x20);
      goto LABEL_29;
    }
  }
  ptr = strdup(v7);
  if ( !ptr )
  {
LABEL_17:
    v11 = 15;
LABEL_28:
    v29 = a6;
    v30 = v11;
    goto LABEL_46;
  }
LABEL_3:
  v11 = 0;
LABEL_29:
  v31 = (char *)ptr;
  if ( ptr )
  {
    ares_query(v6, (const char *)ptr, v9, v8, (int (__fastcall *)(int, signed int))a5, a6);
LABEL_44:
    free(ptr);
    return;
  }
  v32 = malloc(0x2Cu);
  v33 = (int)v32;
  if ( v32 )
  {
    *v32 = v6;
    v34 = strdup(v7);
    *(_DWORD *)(v33 + 4) = v34;
    if ( v34 )
    {
      *(_DWORD *)(v33 + 24) = -1;
      *(_DWORD *)(v33 + 8) = v9;
      *(_DWORD *)(v33 + 12) = v8;
      *(_DWORD *)(v33 + 16) = a5;
      v35 = (int)(v7 - 1);
      *(_DWORD *)(v33 + 20) = a6;
      *(_DWORD *)(v33 + 36) = v11;
      *(_DWORD *)(v33 + 40) = v11;
      while ( 1 )
      {
        v37 = *(unsigned __int8 *)(v35++ + 1);
        v36 = v37;
        if ( !v37 )
          break;
        if ( v36 == 46 )
          ++v31;
      }
      if ( (signed int)v31 >= *(_DWORD *)(v6 + 12) )
      {
        *(_DWORD *)(v33 + 32) = 1;
        *(_DWORD *)(v33 + 28) = v36;
        ares_query(v6, v7, v9, v8, (int (__fastcall *)(int, signed int))sub_CD128, v33);
        return;
      }
      *(_DWORD *)(v33 + 28) = 1;
      *(_DWORD *)(v33 + 32) = v36;
      v38 = sub_CD0D4(v7, **(const char ***)(v6 + 36), &ptr);
      if ( !v38 )
      {
        ares_query(v6, (const char *)ptr, v9, v8, (int (__fastcall *)(int, signed int))sub_CD128, v33);
        goto LABEL_44;
      }
      free(*(void **)(v33 + 4));
      free((void *)v33);
      v29 = a6;
      v30 = v38;
    }
    else
    {
      free((void *)v33);
      v29 = a6;
      v30 = 15;
    }
  }
  else
  {
    v29 = a6;
    v30 = 15;
  }
LABEL_46:
  ((void (__fastcall *)(int, signed int))a5)(v29, v30);
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);

//----- (000CD444) --------------------------------------------------------
_DWORD *__fastcall ares_send(_DWORD *a1, unsigned __int8 *a2, signed int a3, int (__fastcall *a4)(int, signed int), int a5)
{
  signed int v5; // r7
  int (__fastcall *v6)(int, signed int); // r9
  _DWORD *v7; // r5
  unsigned __int8 *v8; // r10
  int v9; // r0
  signed int v10; // r1
  _DWORD *v11; // r4
  char *v12; // r6
  void *v13; // r2
  __int16 v15; // r2
  char *v16; // r6
  __int16 v17; // r3
  int v18; // r0
  int v19; // r3
  int v20; // r1
  signed int v21; // r3
  _BOOL4 v22; // r7
  __time_t v23; // [sp+10h] [bp-38h]
  int v24; // [sp+14h] [bp-34h]
  __time_t v25; // [sp+18h] [bp-30h]
  int v26; // [sp+1Ch] [bp-2Ch]

  v5 = a3;
  v6 = a4;
  v7 = a1;
  v8 = a2;
  if ( (unsigned int)(a3 - 12) > 0xFFF3 )
  {
    v9 = a5;
    v10 = 7;
    return (_DWORD *)v6(v9, v10);
  }
  v11 = malloc(0x6Cu);
  if ( !v11 )
  {
    v10 = 15;
    v9 = a5;
    return (_DWORD *)v6(v9, v10);
  }
  v12 = (char *)malloc(v5 + 2);
  v11[15] = v12;
  if ( !v12 )
  {
    free(v11);
    v9 = a5;
    v10 = 15;
    return (_DWORD *)v6(v9, v10);
  }
  v13 = malloc(8 * v7[30]);
  v11[23] = v13;
  if ( !v13 )
  {
    free(v12);
    free(v11);
    v9 = a5;
    v10 = 15;
    return (_DWORD *)v6(v9, v10);
  }
  v15 = *v8;
  v16 = v12 + 2;
  v17 = v8[1];
  *(v16 - 1) = v5;
  *(v16 - 2) = BYTE1(v5);
  *(_WORD *)v11 = v17 | (v15 << 8);
  v11[1] = 0;
  v11[2] = 0;
  memcpy(v16, v8, v5);
  v11[16] = v5 + 2;
  v11[17] = v16;
  v11[18] = v5;
  v11[19] = v6;
  v11[20] = a5;
  v11[21] = 0;
  v18 = v7[98];
  v11[22] = v18;
  if ( v7[4] == 1 )
    v7[98] = (v18 + 1) % v7[30];
  v19 = 0;
  while ( v19 < v7[30] )
  {
    *(_DWORD *)(v11[23] + 8 * v19) = 0;
    v20 = v11[23] + 8 * v19++;
    *(_DWORD *)(v20 + 4) = 0;
  }
  if ( *v7 << 23 >= 0 )
    v21 = 512;
  else
    v21 = v7[14];
  if ( *v7 & 1 )
    v22 = 1;
  else
    v22 = v5 > v21;
  v11[24] = v22;
  v11[25] = 11;
  v11[26] = 0;
  ares__init_list_node(v11 + 3, (int)v11);
  ares__init_list_node(v11 + 6, (int)v11);
  ares__init_list_node(v11 + 9, (int)v11);
  ares__init_list_node(v11 + 12, (int)v11);
  ares__insert_in_list(v11 + 12, (int)(v7 + 99));
  ares__insert_in_list(v11 + 3, (int)&v7[3 * (*(_WORD *)v11 & 0x7FF) + 102]);
  ares__tvnow(&v23);
  v25 = v23;
  v26 = v24;
  return ares__send_query(v7, (int)v11, &v25);
}

//----- (000CD5D0) --------------------------------------------------------
const char *__fastcall ares_strerror(unsigned int a1)
{
  unsigned int v1; // r4
  const char *result; // r0
  char dest; // [sp+4h] [bp-6Ch]
  _DWORD v4[1]; // [sp+68h] [bp-8h]

  v1 = a1;
  memcpy(&dest, &off_F3CD0, 0x64u);
  if ( v1 > 0x18 )
    result = "unknown";
  else
    result = (const char *)v4[v1 - 25];
  return result;
}
// F3CD0: using guessed type char *off_F3CD0;

//----- (000CD604) --------------------------------------------------------
_DWORD *__fastcall ares_timeout(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r9
  int v4; // r5
  _DWORD *v5; // r7
  _DWORD *v6; // r6
  int v8; // r5
  signed int v9; // r4
  int v10; // r1
  int v11; // r0
  int v12; // r0
  int v13; // r1
  int v14; // [sp+0h] [bp-38h]
  int v15; // [sp+4h] [bp-34h]
  int v16; // [sp+8h] [bp-30h]
  int v17; // [sp+Ch] [bp-2Ch]
  int v18; // [sp+10h] [bp-28h]
  int v19; // [sp+14h] [bp-24h]

  v3 = a1 + 396;
  v4 = a1;
  v5 = a2;
  v6 = a3;
  if ( ares__is_list_empty((_DWORD *)(a1 + 396)) )
    return v5;
  ares__tvnow(&v14);
  v8 = *(_DWORD *)(v4 + 400);
  v9 = -1;
  v16 = v14;
  v17 = v15;
  while ( v8 != v3 )
  {
    v10 = *(_DWORD *)(v8 + 8);
    if ( *(_DWORD *)(v10 + 4) )
    {
      v11 = ares__timeoffset(&v16, (_DWORD *)(v10 + 4));
      v12 = v11 & ~(v11 >> 31);
      if ( v9 == -1 )
      {
        v9 = v12;
      }
      else if ( v9 >= v12 )
      {
        v9 = v12;
      }
    }
    v8 = *(_DWORD *)(v8 + 4);
  }
  if ( v9 == -1 )
    return v5;
  v18 = v9 / 1000;
  v19 = 1000 * (v9 % 1000);
  if ( v5 )
  {
    if ( !ares__timedout(v5, &v18) )
      return v5;
  }
  v13 = v19;
  *v6 = v18;
  v6[1] = v13;
  return v6;
}

//----- (000CD6A8) --------------------------------------------------------
int __fastcall ares__close_sockets(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r6
  int *v3; // r4
  _DWORD *v4; // r5
  void *v5; // r0
  void *v6; // r0
  int v7; // r1
  int result; // r0
  void (__fastcall *v9)(_DWORD); // r5
  int v10; // r3
  int v11; // r6
  void (__fastcall *v12)(_DWORD); // r5

  v2 = a1;
  v3 = a2;
  while ( 1 )
  {
    v4 = (_DWORD *)v3[12];
    if ( !v4 )
      break;
    v3[12] = v4[4];
    v5 = (void *)v4[3];
    if ( v5 )
      free(v5);
    free(v4);
  }
  v6 = (void *)v3[10];
  v3[13] = 0;
  if ( v6 )
    free(v6);
  v7 = v3[6];
  v3[10] = 0;
  result = v7 + 1;
  v3[8] = 0;
  v3[19] = 0;
  if ( v7 != -1 )
  {
    v9 = (void (__fastcall *)(_DWORD))v2[9318];
    if ( v9 )
      v9(v2[9319]);
    result = close(v3[6]);
    v3[6] = -1;
    v10 = v2[96] + 1;
    v2[96] = v10;
    v3[14] = v10;
  }
  if ( v3[5] != -1 )
  {
    v11 = (int)(v2 + 9280);
    v12 = *(void (__fastcall **)(_DWORD))(v11 + 152);
    if ( v12 )
      v12(*(_DWORD *)(v11 + 156));
    result = close(v3[5]);
    v3[5] = -1;
  }
  return result;
}

//----- (000CD730) --------------------------------------------------------
signed int __fastcall ares__get_hostent(int a1, unsigned int a2, unsigned int *a3)
{
  signed int v3; // r4
  int *v4; // r11
  unsigned int v5; // r10
  int v6; // r9
  char *v7; // r8
  char *v8; // r1
  char *v9; // r2
  int v10; // r0
  int v11; // t1
  unsigned int v12; // r2
  unsigned __int8 *v13; // r1
  char *v14; // r0
  int v15; // r2
  const char *v16; // r1
  const char *v17; // r0
  char *v18; // r2
  signed int v19; // t1
  const char *v20; // r2
  const char *v21; // r6
  const char *v22; // lr
  char *v23; // r2
  const char *v24; // r3
  signed int v25; // r5
  signed int v26; // t1
  int v27; // r5
  unsigned __int8 *v28; // r2
  unsigned __int8 *v29; // r12
  int v30; // r0
  int v31; // t1
  unsigned __int8 *v32; // r0
  int v33; // r12
  int v34; // t1
  unsigned int v35; // r3
  const char *v36; // ST00_4
  in_addr_t v37; // r0
  _DWORD *v38; // r0
  char *v39; // r0
  _DWORD *v40; // r0
  _DWORD *v41; // ST00_4
  _DWORD *v42; // r0
  int v43; // r1
  int v44; // r2
  int v45; // r3
  _DWORD *v46; // r0
  int v47; // r3
  int v48; // r2
  int v49; // r5
  unsigned __int8 *v50; // r3
  unsigned __int8 *v51; // r0
  int v52; // r6
  int v53; // t1
  unsigned __int8 *v54; // r3
  _BYTE *v55; // r6
  int v56; // r2
  int v57; // t1
  char *v58; // r0
  void *v59; // r0
  void *v60; // t1
  void **v61; // r3
  signed int result; // r0
  unsigned int *v63; // [sp+4h] [bp-54h]
  char *cp; // [sp+10h] [bp-48h]
  char v65; // [sp+14h] [bp-44h]
  int v66; // [sp+18h] [bp-40h]
  in_addr_t v67; // [sp+1Ch] [bp-3Ch]
  int v68; // [sp+20h] [bp-38h]
  int v69; // [sp+24h] [bp-34h]
  int v70; // [sp+28h] [bp-30h]
  int v71; // [sp+2Ch] [bp-2Ch]

  v5 = a2;
  v63 = a3;
  v6 = a1;
  cp = 0;
  *a3 = 0;
  if ( a2 <= 0xA && (1 << a2) & 0x405 )
  {
    v4 = (int *)&v67;
LABEL_4:
    while ( 2 )
    {
      v7 = ares__read_line(v6, &cp, &v65);
      if ( !v7 )
      {
        v8 = cp;
        do
        {
          v9 = v8;
          v11 = (unsigned __int8)*v8++;
          v10 = v11;
        }
        while ( v11 && v10 != 35 );
        *v9 = 0;
        v12 = (unsigned int)(v9 - 1);
        v3 = ctype_;
        do
        {
          v13 = (unsigned __int8 *)v12;
          if ( v12 < (unsigned int)cp )
            break;
          --v12;
        }
        while ( *(_BYTE *)(*v13 + ctype_ + 1) & 8 );
        v13[1] = 0;
        v14 = cp;
        do
        {
          v15 = (unsigned __int8)*v14;
          v16 = v14++;
          if ( !v15 )
            goto LABEL_4;
        }
        while ( *(_BYTE *)(v15 + ctype_ + 1) & 8 );
        v17 = v16;
        do
        {
          v18 = (char *)v17;
          v19 = *(unsigned __int8 *)v17++;
          v3 = v19;
          if ( !v19 )
            goto LABEL_4;
        }
        while ( !(*(_BYTE *)(v3 + ctype_ + 1) & 8) );
        *v18 = 0;
        v20 = v18 + 1;
        do
        {
          v3 = *(unsigned __int8 *)v20;
          v21 = v20++;
          if ( !v3 )
            goto LABEL_4;
        }
        while ( *(_BYTE *)(v3 + ctype_ + 1) & 8 );
        v22 = v21;
        while ( 1 )
        {
          v23 = (char *)v22++;
          v3 = (unsigned __int8)*v23;
          if ( !*v23 )
            break;
          if ( *(_BYTE *)(v3 + ctype_ + 1) & 8 )
          {
            v24 = v22;
            while ( 1 )
            {
              v3 = (signed int)v24;
              v26 = *(unsigned __int8 *)v24++;
              v25 = v26;
              if ( !v26 )
                break;
              if ( !(*(_BYTE *)(v25 + ctype_ + 1) & 8) )
                goto LABEL_29;
            }
            v3 = v25;
            break;
          }
        }
LABEL_29:
        v27 = 0;
        *v23 = 0;
        if ( v3 )
        {
          v28 = (unsigned __int8 *)v3;
          while ( *v28 )
          {
            do
            {
              v29 = v28;
              v31 = *v28++;
              v30 = v31;
            }
            while ( v31 && !(*(_BYTE *)(v30 + ctype_ + 1) & 8) );
            v32 = v29;
            do
            {
              v28 = v32;
              v34 = *v32++;
              v33 = v34;
            }
            while ( v34 && *(_BYTE *)(v33 + ctype_ + 1) & 8 );
            ++v27;
          }
        }
        else
        {
          v27 = 0;
        }
        v35 = v5 & 0xFFFFFFFD;
        v66 = 0;
        v67 = -1;
        if ( v5 & 0xFFFFFFFD )
        {
          if ( v5 != 10 )
            continue;
        }
        else
        {
          v36 = v16;
          v37 = inet_addr(v16);
          v16 = v36;
          v67 = v37;
          if ( v37 != -1 )
          {
            v4 = (_DWORD *)byte_4;
            v66 = 2;
LABEL_46:
            v38 = malloc(0x14u);
            v5 = (unsigned int)v38;
            if ( v38 )
            {
              v38[1] = 0;
              v38[4] = 0;
              v39 = strdup(v21);
              *(_DWORD *)v5 = v39;
              if ( v39 )
              {
                v40 = malloc(8u);
                *(_DWORD *)(v5 + 16) = v40;
                if ( v40 )
                {
                  v40[1] = 0;
                  v41 = v40;
                  v42 = malloc((size_t)v4);
                  *v41 = v42;
                  if ( v42 )
                  {
                    if ( v66 == 2 )
                    {
                      *v42 = v67;
                    }
                    else
                    {
                      v43 = v68;
                      v44 = v69;
                      v45 = v70;
                      *v42 = v67;
                      v42[1] = v43;
                      v42[2] = v44;
                      v42[3] = v45;
                    }
                    v46 = malloc(4 * (v27 + 1));
                    *(_DWORD *)(v5 + 4) = v46;
                    if ( v46 )
                    {
                      v47 = 0;
                      while ( v47 != v27 )
                      {
                        v48 = -1 * v47++;
                        v46[v27 + v48] = 0;
                      }
                      *v46 = 0;
                      v49 = (int)(v46 - 1);
                      while ( 1 )
                      {
                        if ( !v3 )
                          goto LABEL_92;
                        v50 = (unsigned __int8 *)v3;
                        do
                        {
                          v51 = v50;
                          v53 = *v50++;
                          v52 = v53;
                        }
                        while ( v53 && !(*(_BYTE *)(v52 + ctype_ + 1) & 8) );
                        v54 = v51;
                        do
                        {
                          v55 = v54;
                          v57 = *v54++;
                          v56 = v57;
                        }
                        while ( v57 && *(_BYTE *)(v56 + ctype_ + 1) & 8 );
                        *v51 = 0;
                        v58 = strdup((const char *)v3);
                        *(_DWORD *)(v49 + 4) = v58;
                        v49 += 4;
                        if ( !v58 )
                          break;
                        if ( *v55 )
                          v3 = (signed int)v55;
                        else
                          v3 = 0;
                      }
                    }
                  }
                }
              }
            }
            goto LABEL_72;
          }
          if ( v5 )
            continue;
        }
        if ( ares_inet_pton(10, v16, &v67, v35) <= 0 )
          continue;
        v4 = (_DWORD *)&word_10;
        v66 = 10;
        goto LABEL_46;
      }
      break;
    }
    v5 = 0;
LABEL_72:
    if ( cp )
      free(cp);
    if ( v7 )
    {
      result = (signed int)v7;
    }
    else
    {
      if ( v5 )
      {
        if ( *(_DWORD *)v5 )
          free(*(void **)v5);
        v3 = *(_DWORD *)(v5 + 4);
        if ( v3 )
        {
          v3 -= 4;
          while ( 1 )
          {
            v60 = *(void **)(v3 + 4);
            v3 += 4;
            v59 = v60;
            if ( !v60 )
              break;
            free(v59);
          }
          free(*(void **)(v5 + 4));
        }
        v61 = *(void ***)(v5 + 16);
        if ( v61 )
        {
          if ( *v61 )
            free(*v61);
          free(*(void **)(v5 + 16));
        }
        free((void *)v5);
      }
      result = 15;
    }
  }
  else
  {
    result = 9;
  }
  while ( v71 != _stack_chk_guard )
  {
LABEL_92:
    *(_DWORD *)(v5 + 8) = aresx_sitoss(v66);
    *(_DWORD *)(v5 + 12) = aresx_uztoss((__int16)v4);
    free(cp);
    result = v3;
    *v63 = v5;
  }
  return result;
}
// 10: using guessed type __int16 word_10;
// CE0BC: using guessed type int __fastcall ares_inet_pton(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000CDA54) --------------------------------------------------------
char *__fastcall ares__read_line(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r8
  _DWORD *v4; // r5
  _DWORD *v5; // r6
  void *v6; // r0
  unsigned int v7; // r4
  int v8; // r0
  char *result; // r0
  _BYTE *v10; // r7
  void *v11; // r0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !*a2 )
  {
    v6 = malloc(0x80u);
    *v4 = v6;
    if ( !v6 )
      return byte_9 + 6;
    *v5 = 128;
  }
  v7 = 0;
  while ( 1 )
  {
    v8 = aresx_uztosi(*v5 - v7);
    result = fgets((char *)(*v4 + v7), v8, (FILE *)v3);
    if ( !result )
      break;
    v10 = (_BYTE *)*v4;
    v7 += strlen((const char *)(*v4 + v7));
    if ( v10[v7 - 1] == 10 )
    {
      result = 0;
      v10[v7 - 1] = 0;
      return result;
    }
    if ( v7 >= *v5 - 1 )
    {
      v11 = realloc(v10, 2 * *v5);
      if ( !v11 )
        return byte_9 + 6;
      *v4 = v11;
      *v5 *= 2;
    }
  }
  if ( !v7 )
  {
    if ( *(_WORD *)(v3 + 12) & 0x40 )
      result = byte_9 + 5;
    else
      result = byte_9 + 4;
  }
  return result;
}

//----- (000CDADC) --------------------------------------------------------
__time_t *__fastcall ares__tvnow(__time_t *a1)
{
  __time_t *v1; // r4
  int v2; // r1
  __time_t v4; // [sp+0h] [bp-20h]
  int v5; // [sp+4h] [bp-1Ch]
  struct timespec tp; // [sp+8h] [bp-18h]

  v1 = a1;
  if ( clock_gettime(1, &tp) )
  {
    gettimeofday((struct timeval *)&v4, 0);
  }
  else
  {
    v4 = tp.tv_sec;
    v5 = tp.tv_nsec / 1000;
  }
  v2 = v5;
  *v1 = v4;
  v1[1] = v2;
  return v1;
}

//----- (000CDB18) --------------------------------------------------------
int __fastcall ares__bitncmp(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r4
  unsigned __int8 *v4; // r7
  unsigned __int8 *v5; // r6
  int v6; // r5
  int result; // r0
  int v8; // r0
  int v9; // r2
  int i; // r3

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = a3 / 8;
  result = memcmp(a1, a2, a3 / 8);
  if ( !result )
  {
    result = v3 & 7;
    if ( v3 & 7 )
    {
      v8 = v4[v6];
      v9 = v5[v6];
      for ( i = v3 % 8; ; --i )
      {
        if ( i <= 0 )
          return 0;
        if ( (v9 ^ v8) & 0x80 )
          break;
        v8 *= 2;
        v9 *= 2;
      }
      if ( v8 & 0x80 )
        result = 1;
      else
        result = -1;
    }
  }
  return result;
}

//----- (000CDB78) --------------------------------------------------------
signed int __fastcall sub_CDB78(int a1, int *a2)
{
  int v2; // r4
  int v3; // r7
  int *v4; // r6
  int v5; // r5
  char *v6; // r0

  v2 = 0;
  v3 = a1;
  v4 = a2;
  v5 = 0;
  while ( *(_BYTE *)(v3 + v2) )
  {
    v6 = strchr("0123456789", *(unsigned __int8 *)(v3 + v2));
    if ( v6 && (!v2 || v5) )
    {
      ++v2;
      v5 = 10 * v5 + aresx_sztosi(v6 - "0123456789");
      if ( v5 <= 128 )
        continue;
    }
    return 0;
  }
  if ( !v2 )
    return 0;
  *v4 = v5;
  return 1;
}

//----- (000CDBD8) --------------------------------------------------------
int __fastcall ares_inet_net_pton(int a1, unsigned __int8 *a2, unsigned __int8 *a3, _BYTE *a4)
{
  const char *v4; // r9
  unsigned int v5; // r5
  unsigned __int8 *v6; // r7
  unsigned __int8 *v7; // r6
  unsigned int v8; // r2
  int v9; // r3
  unsigned __int8 *v10; // r8
  int v11; // r1
  int v12; // r4
  unsigned int v13; // r10
  int result; // r0
  unsigned __int8 *v15; // r6
  unsigned __int8 *v16; // r4
  int i; // r11
  int v18; // t1
  char *v19; // r0
  unsigned __int8 *v20; // r3
  int v21; // r10
  signed int v22; // r3
  signed int v23; // ST00_4
  char *v24; // r0
  signed int v25; // r8
  char *v26; // r0
  int v27; // t1
  unsigned int v28; // r3
  signed int v29; // r10
  unsigned __int8 *v30; // r11
  unsigned int v31; // r8
  signed int v32; // r3
  char *v33; // r4
  int v34; // r2
  int v35; // t1
  const char *v36; // r12
  char *v37; // r10
  unsigned int v38; // r8
  int v39; // r6
  unsigned int v40; // t1
  int v41; // r6
  int v42; // r2
  signed int v43; // r2
  int v44; // r3
  int v45; // r2
  signed int *v46; // r0
  signed int v47; // r3
  signed int v48; // [sp+0h] [bp-60h]
  int c; // [sp+4h] [bp-5Ch]
  int ca; // [sp+4h] [bp-5Ch]
  unsigned int v51; // [sp+Ch] [bp-54h]
  const char *v52; // [sp+10h] [bp-50h]
  int v53; // [sp+20h] [bp-40h]
  char s; // [sp+24h] [bp-3Ch]
  int v55; // [sp+34h] [bp-2Ch]

  v5 = (unsigned int)a4;
  v6 = a3;
  v7 = a2;
  v8 = _stack_chk_guard;
  if ( a1 == 2 )
  {
    v9 = *a2;
    v10 = a2 + 1;
    v11 = *a2;
    if ( v9 != 48
      || (v8 = v7[1] & 0xDF, v8 != 88)
      || (v12 = v7[2], (v13 = v12 & 0xFFFFFF80) != 0)
      || (result = (int)&ctype_, v4 = (const char *)&ctype_, v8 = *(unsigned __int8 *)(ctype_ + v12 + 1), !(v8 & 0x44)) )
    {
      result = v9 << 24;
      if ( v9 & 0x80 || (unsigned int)(v9 - 48) > 9 )
        goto LABEL_135;
      --v5;
      v16 = v6;
      v4 = "0123456789";
      while ( 1 )
      {
        v21 = 0;
        v22 = 10;
        while ( 1 )
        {
          v23 = v22;
          v24 = strchr("0123456789", v11);
          result = aresx_sztosi(v24 - "0123456789");
          v22 = v23;
          v21 = result + v23 * v21;
          if ( v21 > 255 )
            goto LABEL_135;
          v15 = v10 + 1;
          v11 = *v10;
          if ( !*v10 )
            break;
          v8 = v11 << 24;
          if ( v11 & 0x80 )
            break;
          v8 = v11 - 48;
          if ( (unsigned int)(v11 - 48) > 9 )
            break;
          ++v10;
        }
        result = v5 + 1;
        if ( v5 == -1 )
          break;
        *v16++ = v21;
        if ( !v11 )
          goto LABEL_134;
        if ( v11 == 47 )
          goto LABEL_40;
        if ( v11 != 46 )
          goto LABEL_135;
        v11 = v10[1];
        v8 = v11 << 24;
        if ( v11 & 0x80 )
          goto LABEL_135;
        v8 = v11 - 48;
        --v5;
        if ( (unsigned int)(v11 - 48) > 9 )
          goto LABEL_135;
        v10 += 2;
      }
    }
    else if ( v5 )
    {
      v15 = v7 + 2;
      v16 = v6;
      for ( i = 0; ; i = result )
      {
        v18 = *v15++;
        v11 = v18;
        if ( !v18 || v11 & 0x80 || !(*(_BYTE *)(ctype_ + v11 + 1) & 0x44) )
          break;
        if ( *(_BYTE *)(ctype_ + v11 + 1) & 1 )
          v11 = *(signed __int16 *)(tolower_tab_ + 2 * (v11 + 1));
        v19 = strchr("0123456789abcdef", v11);
        result = aresx_sztosi(v19 - "0123456789abcdef");
        if ( v13 )
        {
          result |= 16 * i;
          if ( !v5 )
            goto LABEL_136;
          *v16 = result;
          --v5;
          ++v16;
          v13 = 0;
        }
        else
        {
          v13 = 1;
        }
      }
      v20 = v16;
      v8 = v5;
      if ( !v13 )
      {
LABEL_39:
        if ( v11 == 47 )
        {
LABEL_40:
          v11 = *v15;
          v25 = v11 & 0xFFFFFF80;
          if ( v11 & 0xFFFFFF80 || (unsigned int)(v11 - 48) > 9 || v16 <= v6 )
            goto LABEL_135;
          v4 = "0123456789";
          while ( 1 )
          {
            v26 = strchr("0123456789", v11);
            result = aresx_sztosi(v26 - "0123456789");
            v25 = result + 10 * v25;
            if ( v25 > 32 )
              goto LABEL_135;
            v27 = (v15++)[1];
            v11 = v27;
            if ( !v27 )
              break;
            if ( v11 & 0x80 || (unsigned int)(v11 - 48) > 9 )
              goto LABEL_135;
          }
          if ( v16 == v6 )
            goto LABEL_135;
          if ( v25 != -1 )
            goto LABEL_69;
        }
        else
        {
          if ( v11 )
            goto LABEL_135;
LABEL_134:
          if ( v16 == v6 )
            goto LABEL_135;
        }
        v28 = *v6;
        if ( v28 > 0xEF )
        {
          v25 = 32;
        }
        else if ( v28 > 0xDF )
        {
          v25 = 8;
        }
        else if ( v28 > 0xBF )
        {
          v25 = 24;
        }
        else if ( v28 & 0x80 )
        {
          v25 = 16;
        }
        else
        {
          v25 = 8;
        }
        result = v16 - v6;
        if ( v25 < 8 * (v16 - v6) )
        {
          result = aresx_sztosi(result);
          v25 = 8 * result;
        }
        if ( v25 == 8 )
        {
          if ( *v6 == 224 )
            v25 = 4;
          else
            v25 = 8;
        }
LABEL_69:
        v5 += (unsigned int)v16;
        v8 = 0;
        while ( 1 )
        {
          if ( v25 <= 8 * (v16 - v6) )
          {
            result = v25;
            goto LABEL_138;
          }
          if ( v16 == (unsigned __int8 *)v5 )
            goto LABEL_136;
          *v16++ = 0;
        }
      }
      --v5;
      if ( v8 )
      {
        ++v16;
        *v20 = 16 * i;
        goto LABEL_39;
      }
    }
LABEL_136:
    v46 = (signed int *)_errno(result, v11, v8);
    v47 = 90;
    goto LABEL_137;
  }
  if ( a1 != 10 )
  {
    v46 = (signed int *)_errno(a1, a2, _stack_chk_guard);
    v47 = 97;
    goto LABEL_137;
  }
  v4 = &s;
  result = (int)memset(&s, 0, 0x10u);
  if ( *v7 == 58 )
  {
    v8 = v7[1];
    if ( v8 != 58 )
      goto LABEL_135;
    ++v7;
  }
  v29 = 0;
  v30 = v7;
  v53 = -1;
  v31 = 0;
  v32 = 0;
  v33 = &s;
  v52 = "0123456789";
  v51 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v35 = *v7++;
      v34 = v35;
      if ( !v35 )
        goto LABEL_113;
      c = v34;
      v48 = v32;
      result = (int)strchr("0123456789abcdef", v34);
      if ( result )
      {
        v36 = "0123456789abcdef";
        goto LABEL_83;
      }
      result = (int)strchr("0123456789ABCDEF", c);
      v8 = c;
      v32 = v48;
      v36 = "0123456789ABCDEF";
      if ( !result )
        break;
LABEL_83:
      ++v29;
      result = aresx_sztoui(result - (_DWORD)v36);
      v31 = result | 16 * v31;
      if ( v29 > 4 )
        goto LABEL_135;
      v32 = 1;
    }
    if ( c != 58 )
      break;
    if ( v48 )
    {
      if ( !*v7 )
        goto LABEL_135;
      if ( v33 + 2 > (char *)&v55 )
        goto LABEL_138;
      v33[1] = v31;
      *v33 = BYTE1(v31);
      v30 = v7;
      v33 += 2;
      v31 = 0;
      v29 = 0;
      v32 = 0;
    }
    else
    {
      v8 = v51;
      if ( v51 )
        goto LABEL_135;
      v30 = v7;
      v51 = (unsigned int)v33;
    }
  }
  v37 = v33;
  if ( c != 46 )
  {
    if ( c != 47 )
      goto LABEL_135;
    result = sub_CDB78((int)v7, &v53);
    v32 = v48;
    if ( result <= 0 )
      goto LABEL_135;
LABEL_113:
    v8 = (unsigned int)v33;
    if ( !v32 )
      goto LABEL_116;
    v11 = (int)&v55;
    if ( v33 + 2 <= (char *)&v55 )
    {
      v11 = v31 >> 8;
      *v33 = BYTE1(v31);
      v33 += 2;
      v32 = 0;
      *(_BYTE *)(v8 + 1) = v31;
      goto LABEL_116;
    }
    goto LABEL_135;
  }
  v52 = v33 + 4;
  v8 = (unsigned int)(v33 + 4);
  if ( v33 + 4 > (char *)&v55 )
    goto LABEL_135;
  v38 = 0;
  v39 = 0;
  while ( 2 )
  {
    v40 = *v30++;
    v8 = v40;
    if ( !v40 )
    {
      if ( v39 && v33 - v37 <= 3 )
      {
        *v33 = v38;
        goto LABEL_139;
      }
      goto LABEL_135;
    }
    ca = v8;
    result = (int)strchr("0123456789", v8);
    v8 = ca;
    if ( result )
    {
      if ( v39 && !v38 )
        goto LABEL_135;
      result = aresx_sztoui(result - (_DWORD)"0123456789");
      v38 = 10 * v38 + result;
      if ( v38 > 0xFF )
        goto LABEL_135;
      ++v39;
      v11 = (int)v33;
      goto LABEL_107;
    }
    if ( (unsigned int)(ca - 46) > 1 || v33 - v37 > 3 )
      goto LABEL_135;
    v11 = (int)(v33 + 1);
    *v33 = v38;
    if ( ca != 47 )
    {
      v38 = 0;
      v39 = 0;
LABEL_107:
      v33 = (char *)v11;
      continue;
    }
    break;
  }
  result = sub_CDB78((int)v30, &v53);
  if ( result > 0 )
    goto LABEL_139;
LABEL_135:
  v46 = (signed int *)_errno(result, v11, v8);
  v47 = 2;
LABEL_137:
  *v46 = v47;
LABEL_138:
  for ( result = -1; ; result = v41 )
  {
    v11 = (int)&_stack_chk_guard;
    if ( v55 == _stack_chk_guard )
      break;
LABEL_139:
    v33 = (char *)v52;
    v32 = 1;
LABEL_116:
    if ( v53 == -1 )
      v53 = 128;
    v41 = v53;
    v42 = v53 + 15;
    if ( v53 + 15 < 0 )
      v42 = v53 + 30;
    v43 = v42 >> 4;
    if ( v43 < 2 )
      v43 = 2;
    if ( v32 )
      v43 = 8;
    v8 = (unsigned int)&v4[2 * v43];
    if ( v51 )
    {
      v11 = (int)&v33[-v51];
      if ( v33 == (char *)v8 )
        goto LABEL_135;
      v44 = 0;
      result = (int)v33;
      while ( ---v44 <= v11 )
      {
        *(_BYTE *)(v8 + v44) = v33[v44];
        v33[v44] = 0;
      }
    }
    else if ( v33 != (char *)v8 )
    {
      goto LABEL_135;
    }
    v45 = v41 + 7;
    if ( v41 + 7 < 0 )
      v45 = v41 + 14;
    v8 = v45 >> 3;
    if ( v8 > v5 )
      goto LABEL_136;
    memcpy(v6, v4, v8);
  }
  return result;
}
// 2567C: using guessed type int __cdecl _errno(_DWORD, _DWORD, _DWORD);
// CB558: using guessed type int __fastcall aresx_sztoui(_DWORD);

//----- (000CE0C4) --------------------------------------------------------
signed int __fastcall ares_create_query(const char *a1, __int16 a2, __int16 a3, __int16 a4, int a5, _DWORD *a6, size_t *a7, int a8)
{
  __int16 v8; // r9
  const char *v9; // r4
  const char *v10; // r5
  __int16 v11; // r7
  signed int v12; // r0
  __int16 v13; // r8
  signed int result; // r0
  signed int v15; // r2
  size_t v16; // r0
  _BYTE *v17; // r0
  _BYTE *v18; // r5
  _BYTE *v19; // r5
  const char *v20; // r3
  signed int v21; // r2
  int v22; // r1
  char v23; // t1
  int v24; // r3

  v8 = a4;
  v9 = a1;
  v10 = a1;
  v11 = a2;
  v12 = 1;
  v13 = a3;
  *a7 = 0;
  *a6 = 0;
  while ( *v10 )
  {
    if ( *v10 == 92 )
    {
      if ( v10[1] )
        ++v10;
    }
    ++v12;
    ++v10;
  }
  if ( *v9 && *(v10 - 1) != 46 )
    ++v12;
  if ( v12 > 255 )
    return 8;
  if ( a8 )
    v15 = 11;
  else
    v15 = 0;
  v16 = v12 + 16 + v15;
  *a7 = v16;
  v17 = malloc(v16);
  v18 = v17;
  *a6 = v17;
  if ( !v17 )
    return 15;
  memset(v17, 0, 0xCu);
  *v18 = HIBYTE(v8);
  v18[1] = v8;
  if ( a5 )
    v18[2] |= 1u;
  v18[4] = 0;
  v18[5] = 1;
  if ( a8 )
  {
    v18[10] = 0;
    v18[11] = 1;
  }
  if ( !strcmp(v9, ".") )
    ++v9;
  v19 = v18 + 12;
LABEL_23:
  if ( *v9 )
  {
    if ( *v9 == 46 )
      return 8;
    v20 = v9;
    v21 = 0;
    while ( 1 )
    {
      v22 = *(unsigned __int8 *)v20;
      if ( !*v20 || v22 == 46 )
        break;
      if ( v22 == 92 && v20[1] )
        ++v20;
      ++v21;
      ++v20;
    }
    if ( v21 > 63 )
      return 8;
    for ( *v19++ = v21; ; *v19++ = v23 )
    {
      v24 = *(unsigned __int8 *)v9;
      if ( !*v9 )
        break;
      if ( v24 == 46 )
      {
        ++v9;
        goto LABEL_23;
      }
      if ( v24 == 92 && v9[1] )
        ++v9;
      v23 = *v9++;
    }
  }
  v19[1] = HIBYTE(v13);
  *v19 = 0;
  v19[2] = v13;
  v19[3] = HIBYTE(v11);
  v19[4] = v11;
  if ( !a8 )
    return 0;
  memset(v19 + 5, 0, 0xBu);
  v19[6] = 0;
  result = 0;
  v19[7] = 41;
  v19[9] = a8;
  v19[8] = BYTE1(a8);
  return result;
}

//----- (000CE200) --------------------------------------------------------
void __fastcall ares_free_data(_DWORD *a1)
{
  _DWORD *v1; // r4
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0

  v1 = a1;
  if ( a1 && *(a1 - 1) == 48813 )
  {
    switch ( *(a1 - 2) )
    {
      case 2:
      case 3:
      case 5:
        if ( *a1 )
          ares_free_data();
        goto LABEL_19;
      case 4:
        if ( *a1 )
          ares_free_data();
        goto LABEL_22;
      case 6:
        if ( *a1 )
          ares_free_data();
        v2 = (void *)v1[1];
        if ( v2 )
          free(v2);
        v3 = (void *)v1[2];
        if ( v3 )
          free(v3);
        v4 = (void *)v1[3];
        if ( v4 )
          free(v4);
        v5 = (void *)v1[4];
        goto LABEL_20;
      case 7:
        v6 = (void *)*a1;
        if ( v6 )
          free(v6);
LABEL_19:
        v5 = (void *)v1[1];
LABEL_20:
        if ( v5 )
          free(v5);
LABEL_22:
        j_free(v1 - 2);
        break;
      default:
        return;
    }
  }
}

//----- (000CE27E) --------------------------------------------------------
int __fastcall ares_malloc_data(int a1)
{
  int v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r4

  v1 = a1;
  v2 = malloc(0x24u);
  v3 = v2;
  if ( !v2 )
    return 0;
  switch ( v1 )
  {
    case 2:
      v2[2] = 0;
      v2[3] = 0;
      *((_WORD *)v2 + 8) = 0;
      *((_WORD *)v2 + 9) = 0;
      *((_WORD *)v2 + 10) = 0;
      break;
    case 3:
      v2[2] = 0;
      v2[3] = 0;
      v2[4] = 0;
      break;
    case 4:
      v2[2] = 0;
      v2[3] = 0;
      memset(v2 + 4, 0, 0x10u);
      break;
    case 5:
      v2[2] = 0;
      v2[3] = 0;
      *((_WORD *)v2 + 8) = 0;
      break;
    case 6:
      v2[2] = 0;
      v2[3] = 0;
      v2[4] = 0;
      v2[5] = 0;
      v2[6] = 0;
      *((_WORD *)v2 + 14) = 0;
      *((_WORD *)v2 + 15) = 0;
      break;
    case 7:
      v2[2] = 0;
      v2[3] = 0;
      v2[4] = 0;
      v2[5] = 0;
      v2[6] = 0;
      v2[7] = 0;
      v2[8] = 0;
      break;
    default:
      free(v2);
      return 0;
  }
  v3[1] = 48813;
  *v3 = v1;
  return (int)(v3 + 2);
}

//----- (000CE306) --------------------------------------------------------
signed int __fastcall ares_expand_name(unsigned int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  unsigned int v5; // r7
  unsigned __int8 *v6; // r5
  int v7; // r8
  _DWORD *v8; // r9
  int v9; // r4
  unsigned __int8 *v10; // r3
  int v11; // r0
  int v12; // r1
  int v13; // r3
  int v14; // r10
  int v15; // r11
  int v16; // r12
  int v17; // t1
  signed int v18; // r12
  int v19; // r7
  _BYTE *v20; // r0
  _BYTE *v21; // r4
  unsigned __int8 *v22; // r11
  signed int v23; // r1
  signed int result; // r0
  signed int v25; // r3
  int v26; // r7
  int v27; // r12
  unsigned __int8 *v28; // r2
  int v29; // r11
  int v30; // r0
  unsigned __int8 v31; // t1

  v5 = a2 + a3;
  v6 = (unsigned __int8 *)a1;
  v7 = a2;
  v8 = a4;
  if ( a1 >= a2 + a3 )
    return 8;
  v9 = 0;
  v10 = (unsigned __int8 *)a1;
  v11 = 0;
  while ( 1 )
  {
    v12 = *v10;
    if ( !*v10 )
      break;
    if ( (v12 & 0xC0) == 192 )
    {
      if ( v5 <= (unsigned int)(v10 + 1) )
        return 8;
      v13 = v10[1] | ((*v10 & 0x3F) << 8);
      if ( v13 >= a3 )
        return 8;
      ++v9;
      v10 = (unsigned __int8 *)(v13 + v7);
      if ( v9 > a3 )
        return 8;
    }
    else
    {
      if ( v5 <= (unsigned int)&v10[v12 + 1] )
        return 8;
      v14 = (int)(v10 + 1);
      v15 = (int)&v10[v12];
      while ( (unsigned __int8 *)v15 != v10 )
      {
        v17 = (v10++)[1];
        v16 = v17;
        if ( v17 == 46 )
        {
          v18 = 2;
        }
        else if ( v16 == 92 )
        {
          v18 = 2;
        }
        else
        {
          v18 = 1;
        }
        v11 += v18;
      }
      v10 = (unsigned __int8 *)(v14 + v12);
      ++v11;
    }
  }
  if ( v11 )
    v19 = v11 - 1;
  else
    v19 = 0;
  v20 = malloc(v19 + 1);
  v21 = v20;
  *v8 = v20;
  if ( !v20 )
    return 15;
  if ( v19 )
  {
    v22 = v6;
    v23 = 0;
    while ( 1 )
    {
      v26 = *v22;
      if ( !*v22 )
        break;
      if ( (v26 & 0xC0) == 192 )
      {
        if ( !v23 )
          *a5 = aresx_uztosl(v22 + 2 - v6);
        v23 = 1;
        v22 = (unsigned __int8 *)((v22[1] | ((*v22 & 0x3F) << 8)) + v7);
      }
      else
      {
        v27 = (int)(v22 + 1);
        v28 = v22;
        v29 = (int)&v22[v26];
        while ( (unsigned __int8 *)v29 != v28 )
        {
          v30 = v28[1];
          if ( v30 == 46 || v30 == 92 )
            *v21++ = 92;
          v31 = (v28++)[1];
          *(++v21 - 1) = v31;
        }
        *v21 = 46;
        v22 = (unsigned __int8 *)(v27 + v26);
        ++v21;
      }
    }
    if ( !v23 )
      *a5 = aresx_uztosl(v22 + 1 - v6);
    result = 0;
    if ( (unsigned int)v21 <= *v8 )
      *v21 = 0;
    else
      *(v21 - 1) = 0;
  }
  else
  {
    *v20 = 0;
    result = 0;
    if ( (*v6 & 0xC0) == 192 )
      v25 = 2;
    else
      v25 = 1;
    *a5 = v25;
  }
  return result;
}

//----- (000CE46E) --------------------------------------------------------
signed int __fastcall ares__expand_name_for_response(unsigned int a1, int a2, int a3, _DWORD *a4, int *a5)
{
  signed int result; // r0

  result = ares_expand_name(a1, a2, a3, a4, a5);
  if ( result == 8 )
    result = 10;
  return result;
}

//----- (000CE482) --------------------------------------------------------
void __fastcall ares_free_hostent(void **a1)
{
  void **v1; // r4
  int v2; // r5
  void *v3; // r0
  void *v4; // t1

  v1 = a1;
  if ( a1 )
  {
    free(*a1);
    v2 = (int)v1[1] - 4;
    while ( 1 )
    {
      v4 = *(void **)(v2 + 4);
      v2 += 4;
      v3 = v4;
      if ( !v4 )
        break;
      free(v3);
    }
    free(v1[1]);
    free(*(void **)v1[4]);
    free(v1[4]);
    j_free(v1);
  }
}

//----- (000CE4C4) --------------------------------------------------------
int __fastcall _gnu_thumb1_case_sqi(int result)
{
  unsigned int v1; // lr
  int v2; // r1

  v2 = *(char *)(2 * (v1 >> 1) + result);
  return result;
}

//----- (000CE4D8) --------------------------------------------------------
int __fastcall _gnu_thumb1_case_uqi(int result)
{
  unsigned int v1; // lr
  int v2; // r1

  v2 = *(unsigned __int8 *)(2 * (v1 >> 1) + result);
  return result;
}

//----- (000CE4EC) --------------------------------------------------------
int __fastcall _gnu_thumb1_case_shi(int result)
{
  unsigned int v1; // lr
  int v2; // r1

  v2 = *(signed __int16 *)(2 * (v1 >> 1) + 2 * result);
  return result;
}

//----- (000CE500) --------------------------------------------------------
int __fastcall _gnu_thumb1_case_uhi(int result)
{
  unsigned int v1; // lr
  int v2; // r1

  v2 = *(unsigned __int16 *)(2 * (v1 >> 1) + 2 * result);
  return result;
}

//----- (000CE514) --------------------------------------------------------
void __fastcall __spoils<R1> _gnu_thumb1_case_si(int a1)
{
  int v1; // lr
  int v2; // r0

  v2 = *(_DWORD *)(4 * ((unsigned int)(v1 + 2) >> 2) + 4 * a1);
}

//----- (000CE5FC) --------------------------------------------------------
int __fastcall sub_CE5FC(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3
  char v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r2
  bool v8; // zf

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      result = -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        result = (v3 >> 31) | 1;
    }
    else if ( a2 & (a2 - 1) )
    {
      v5 = __clz(a2) - __clz(v4);
      v6 = a2 << v5;
      v7 = 1 << v5;
      result = 0;
      while ( 1 )
      {
        if ( v4 >= v6 )
        {
          v4 -= v6;
          result |= v7;
        }
        if ( v4 >= v6 >> 1 )
        {
          v4 -= v6 >> 1;
          result |= v7 >> 1;
        }
        if ( v4 >= v6 >> 2 )
        {
          v4 -= v6 >> 2;
          result |= v7 >> 2;
        }
        if ( v4 >= v6 >> 3 )
        {
          v4 -= v6 >> 3;
          result |= v7 >> 3;
        }
        v8 = v4 == 0;
        if ( v4 )
        {
          v7 >>= 4;
          v8 = v7 == 0;
        }
        if ( v8 )
          break;
        v6 >>= 4;
      }
      if ( v3 < 0 )
        result = -result;
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        result = -result;
    }
  }
  return result;
}

//----- (000CE728) --------------------------------------------------------
int __fastcall _aeabi_drsub(__int64 a1, __int64 a2)
{
  HIDWORD(a1) ^= 0x80000000;
  return _aeabi_dadd(a1, a2);
}

//----- (000CE734) --------------------------------------------------------
int __fastcall _aeabi_dadd(__int64 a1, __int64 a2)
{
  int v2; // r4
  int v3; // r5
  bool v4; // zf
  signed int v5; // r4
  bool v6; // zf
  bool v7; // nf
  unsigned __int8 v8; // vf
  int v9; // r5
  __int64 v10; // r2
  int v11; // r4
  char v12; // lr
  unsigned int v13; // r12
  __int64 v14; // r0
  bool v15; // nf
  char v16; // r5
  int v17; // t0
  int v18; // t2
  unsigned int v19; // t2
  unsigned __int8 v20; // cf
  int v21; // off
  int v22; // r4
  bool v23; // zf
  unsigned int v24; // r3
  int v25; // r3
  bool v26; // zf
  bool v27; // nf
  unsigned __int8 v28; // vf
  int v29; // r2
  int v30; // r4
  int v31; // r4
  int v32; // r4
  bool v33; // zf
  bool v34; // zf

  v2 = 2 * HIDWORD(a1);
  v3 = 2 * HIDWORD(a2);
  v4 = 2 * HIDWORD(a1) == 2 * HIDWORD(a2);
  if ( 2 * HIDWORD(a1) == 2 * HIDWORD(a2) )
    v4 = (_DWORD)a1 == (_DWORD)a2;
  if ( !v4 )
  {
    v4 = (v2 | (unsigned int)a1) == 0;
    if ( v2 | (unsigned int)a1 )
    {
      v4 = (v3 | (unsigned int)a2) == 0;
      if ( v3 | (unsigned int)a2 )
      {
        v4 = v2 >> 21 == -1;
        if ( v2 >> 21 != -1 )
          v4 = v3 >> 21 == -1;
      }
    }
  }
  if ( v4 )
  {
    v33 = v2 >> 21 == -1;
    if ( v2 >> 21 != -1 )
      v33 = v3 >> 21 == -1;
    if ( v33 )
    {
      if ( v2 >> 21 != -1 )
        a1 = a2;
    }
    else
    {
      v34 = v2 == v3;
      if ( v2 == v3 )
        v34 = (_DWORD)a1 == (_DWORD)a2;
      if ( v34 )
      {
        if ( HIDWORD(a1) != HIDWORD(a2) )
        {
          LODWORD(a1) = 0;
          return a1;
        }
        if ( !((unsigned int)v2 >> 21) )
        {
          LODWORD(a1) = 2 * a1;
          return a1;
        }
        if ( (unsigned int)v2 < 0xFFC00000 )
          return a1;
        goto LABEL_69;
      }
      if ( !(v2 | (unsigned int)a1) )
        LODWORD(a1) = a2;
    }
  }
  else
  {
    v5 = (unsigned int)v2 >> 21;
    v8 = __OFSUB__((unsigned int)v3 >> 21, v5);
    v9 = ((unsigned int)v3 >> 21) - v5;
    v6 = v9 == 0;
    v7 = v9 < 0;
    if ( (v9 < 0) ^ v8 )
      v9 = -v9;
    if ( !((unsigned __int8)(v7 ^ v8) | v6) )
    {
      v5 += v9;
      v10 = a1 ^ a2;
      a1 ^= v10;
      a2 = a1 ^ v10;
    }
    if ( (unsigned int)v9 <= 0x36 )
    {
      v4 = a1 >= 0;
      HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
      if ( !v4 )
      {
        v20 = (unsigned int)a1 <= 0;
        LODWORD(a1) = -(signed int)a1;
        HIDWORD(a1) = -(HIDWORD(a1) + !v20);
      }
      v4 = a2 >= 0;
      HIDWORD(a2) = HIDWORD(a2) & 0xFFFFF | 0x100000;
      if ( !v4 )
      {
        v20 = (unsigned int)a2 <= 0;
        LODWORD(a2) = -(signed int)a2;
        HIDWORD(a2) = -(HIDWORD(a2) + !v20);
      }
      if ( v5 == v9 )
      {
        HIDWORD(a2) ^= 0x100000u;
        if ( v5 )
        {
          --v9;
        }
        else
        {
          HIDWORD(a1) ^= 0x100000u;
          v5 = 1;
        }
      }
      v11 = v5 - 1;
      v12 = 32 - v9;
      if ( v9 > 32 )
      {
        v16 = v9 - 32;
        v13 = HIDWORD(a2) << (v12 + 32);
        if ( (unsigned int)a2 >= 1 )
          v13 |= 2u;
        LODWORD(a1) = a1 + (SHIDWORD(a2) >> v16);
        HIDWORD(a1) += (SHIDWORD(a2) >> 31) + __CFSHR__(HIDWORD(a2), 31);
        v15 = a1 < 0;
      }
      else
      {
        v13 = (_DWORD)a2 << v12;
        v14 = a1 + ((unsigned int)a2 >> v9);
        LODWORD(a1) = v14 + (HIDWORD(a2) << v12);
        HIDWORD(a1) += (SHIDWORD(a2) >> v9) + __CFSHR__(HIDWORD(a2), v9);
        v15 = a1 < 0;
      }
      if ( v15 )
      {
        v20 = v13 <= 0;
        v13 = -v13;
        v17 = a1 + !v20;
        v20 = (unsigned int)a1 + !v20 <= 0;
        LODWORD(a1) = -v17;
        HIDWORD(a1) = -(HIDWORD(a1) + !v20);
      }
      if ( HIDWORD(a1) >= 0x100000 )
      {
        if ( HIDWORD(a1) < 0x200000 )
          goto LABEL_30;
        v18 = __RCR__(a1, 1);
        LODWORD(a1) = v18;
        v19 = __RCR__(v13, 1);
        v13 = v19;
        if ( (unsigned int)((v11 + 1) << 21) < 0xFFC00000 )
          goto LABEL_30;
LABEL_69:
        LODWORD(a1) = 0;
        return a1;
      }
      v20 = __CFSHL__(v13, 1);
      v13 *= 2;
      v21 = v20 + (_DWORD)a1;
      v20 = __CFADD__(v20, (_DWORD)a1) | __CFADD__((_DWORD)a1, v21);
      LODWORD(a1) = a1 + v21;
      HIDWORD(a1) += v20 + HIDWORD(a1);
      v22 = v11 - 1;
      if ( a1 & 0x10000000000000LL )
      {
LABEL_30:
        v20 = v13 >= 0x80000000;
        if ( v13 == 0x80000000 )
          v20 = a1 & 1;
        LODWORD(a1) = v20 + (_DWORD)a1;
        return a1;
      }
      v23 = HIDWORD(a1) == 0;
      if ( !HIDWORD(a1) )
      {
        HIDWORD(a1) = a1;
        LODWORD(a1) = 0;
      }
      v24 = __clz(HIDWORD(a1));
      if ( v23 )
        v24 += 32;
      v25 = v24 - 11;
      v28 = __OFSUB__(v25, 32);
      v29 = v25 - 32;
      v26 = v25 == 32;
      v27 = v25 - 32 < 0;
      if ( v25 < 32 )
      {
        v28 = __OFADD__(v29, 12);
        v26 = v25 == 20;
        v27 = v25 - 20 < 0;
        if ( !((unsigned __int8)(v27 ^ __OFADD__(v29, 12)) | (v25 == 20)) )
        {
          LODWORD(a1) = HIDWORD(a1) << v25;
          HIDWORD(a1) >>= 32 - v25;
LABEL_46:
          v8 = __OFSUB__(v22, v25);
          v30 = v22 - v25;
          if ( (v30 < 0) ^ v8 )
          {
            v31 = ~v30;
            v8 = __OFSUB__(v31, 31);
            v32 = v31 - 31;
            if ( (v32 < 0) ^ v8 )
              LODWORD(a1) = ((unsigned int)a1 >> (v32 + 32)) | (HIDWORD(a1) << -(char)v32);
            else
              LODWORD(a1) = HIDWORD(a1) >> v32;
          }
          return a1;
        }
        LOBYTE(v29) = v25;
      }
      if ( (unsigned __int8)(v27 ^ v28) | v26 )
        LOBYTE(v13) = 32 - v29;
      HIDWORD(a1) <<= v29;
      if ( (unsigned __int8)(v27 ^ v28) | v26 )
      {
        HIDWORD(a1) |= (unsigned int)a1 >> v13;
        LODWORD(a1) = (_DWORD)a1 << v29;
      }
      goto LABEL_46;
    }
  }
  return a1;
}

//----- (000CE9E0) --------------------------------------------------------
int __fastcall _floatunsidf(int result)
{
  if ( result )
    JUMPOUT(&loc_CE87C);
  return result;
}

//----- (000CEA04) --------------------------------------------------------
int __fastcall _floatsidf(int result)
{
  if ( result )
    JUMPOUT(&loc_CE87C);
  return result;
}

//----- (000CEA2C) --------------------------------------------------------
int __fastcall _extendsfdf2(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r2
  int result; // r0
  bool v6; // zf

  v4 = 2 * a1;
  v6 = 2 * a1 == 0;
  result = a1 << 29;
  if ( v6 || (a4 = v4 & 0xFF000000) == 0 || a4 == -16777216 )
  {
    v6 = v4 == 0;
    if ( v4 )
      v6 = a4 == -16777216;
    if ( !v6 )
      JUMPOUT(&loc_CE87C);
  }
  return result;
}

//----- (000CEA6C) --------------------------------------------------------
int __fastcall _floatundidf(__int64 a1)
{
  if ( a1 )
    JUMPOUT(&loc_CEA9C);
  return a1;
}

//----- (000CEA80) --------------------------------------------------------
int __fastcall _floatdidf(__int64 a1)
{
  if ( a1 )
  {
    if ( (HIDWORD(a1) & 0x80000000 & 0x80000000) != 0 )
      HIDWORD(a1) = -(HIDWORD(a1) + ((unsigned int)a1 > 0));
    if ( !(HIDWORD(a1) >> 22) )
      JUMPOUT(&loc_CE820);
    JUMPOUT(&loc_CE820);
  }
  return a1;
}

//----- (000CEB60) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (000CEB70) --------------------------------------------------------
int __fastcall _fixdfdi(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // r5
  unsigned int v3; // r4
  bool v4; // zf
  __int64 v5; // r0
  unsigned __int64 v6; // r0

  v2 = a1;
  v3 = a2;
  v4 = _aeabi_dcmplt(a1, a2, 0, 0) == 0;
  LODWORD(v5) = v2;
  if ( v4 )
  {
    v6 = __PAIR__(v3, _fixunsdfdi(v5));
  }
  else
  {
    HIDWORD(v5) = v3 + 2147483648;
    LODWORD(v6) = -_fixunsdfdi(v5);
  }
  return v6;
}

//----- (000CEBB4) --------------------------------------------------------
unsigned int __fastcall _fixunsdfdi(__int64 a1)
{
  __int64 v1; // r4
  int v2; // r0
  int v3; // r1
  int v4; // r0
  __int64 v5; // r0
  int v6; // r0
  int v7; // r1
  unsigned int v8; // r0
  int v9; // r1

  v1 = a1;
  v2 = _muldf3(a1, 4463067230724161536LL);
  v4 = _fixunsdfsi(v2, v3);
  LODWORD(v5) = _floatunsidf(v4);
  v6 = _muldf3(v5, 4751297606875873280LL);
  v8 = _subdf3(v1, HIDWORD(v1), v6, v7);
  return _fixunsdfsi(v8, v9);
}
// CE730: using guessed type int __fastcall _subdf3(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000CEC1C) --------------------------------------------------------
__int64 __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // r4
  __int64 result; // r0

  v3 = a1;
  result = a1 / a2;
  *a3 = v3 - a2 * result;
  return result;
}

//----- (000CEC58) --------------------------------------------------------
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // r4
  unsigned __int64 result; // r0

  v3 = a1;
  result = a1 / a2;
  *a3 = v3 - result * a2;
  return result;
}

//----- (000CEC94) --------------------------------------------------------
int __fastcall sub_CEC94(int *a1)
{
  int v1; // r3
  unsigned int v2; // r3

  v1 = *a1;
  if ( *a1 & 0x40000000 )
    v2 = v1 | 0x80000000;
  else
    v2 = v1 & 0x7FFFFFFF;
  return (int)a1 + v2;
}

//----- (000CECAC) --------------------------------------------------------
int __fastcall sub_CECAC(int a1, int a2, unsigned int a3)
{
  int v3; // r9
  unsigned int v4; // r6
  int v5; // r8
  int v6; // r7
  int v7; // r10
  int v8; // r4
  int v9; // r5
  unsigned int v10; // r0
  unsigned int v11; // r11
  int v12; // r0

  v3 = a1;
  v4 = a3;
  if ( a2 )
  {
    v5 = a2 - 1;
    v6 = 0;
    v7 = a2 - 1;
    while ( 1 )
    {
      v8 = (v6 + v7) / 2;
      v9 = v3 + 8 * v8;
      v10 = sub_CEC94((int *)(v3 + 8 * v8));
      v11 = v10;
      if ( v8 == v5 )
      {
        if ( v4 >= v10 )
          return v9;
LABEL_5:
        if ( v8 == v6 )
          return 0;
        v7 = v8 - 1;
      }
      else
      {
        v12 = sub_CEC94((int *)(v3 + 8 * v8 + 8));
        if ( v4 < v11 )
          goto LABEL_5;
        if ( v4 <= v12 - 1 )
          return v9;
        v6 = v8 + 1;
      }
    }
  }
  return 0;
}

//----- (000CED58) --------------------------------------------------------
signed int (__fastcall *__fastcall sub_CED58(int a1))(int a1, void (__noreturn *a2)(), unsigned int *a3)
{
  if ( a1 == 1 )
    return _aeabi_unwind_cpp_pr1;
  if ( a1 == 2 )
    return _aeabi_unwind_cpp_pr2;
  if ( a1 )
    return 0;
  return _aeabi_unwind_cpp_pr0;
}

//----- (000CEDA8) --------------------------------------------------------
signed int __fastcall sub_CEDA8(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r4
  unsigned int v4; // r5
  void *v5; // r0
  int *v6; // r0
  int *v7; // r5
  signed int result; // r0
  int v9; // r0
  int v10; // r3
  int *v11; // r0
  signed int v12; // r3
  int v13; // r0
  int *v14; // r0
  signed int (__fastcall *v15)(int, void (__noreturn *)(), unsigned int *); // r0
  int v16; // [sp+4h] [bp-14h]
  int v17; // [sp+8h] [bp-10h]

  v16 = a2;
  v17 = a3;
  v3 = a1;
  v4 = a2 - 2;
  if ( &__gnu_Unwind_Find_exidx )
  {
    v5 = (void *)_gnu_Unwind_Find_exidx(a2 - 2, &v16);
    if ( !v5 )
    {
      v3[4] = 0;
      return 9;
    }
  }
  else
  {
    v5 = &unk_D907C;
    v16 = 3596;
  }
  v6 = (int *)sub_CECAC((int)v5, v16, v4);
  v7 = v6;
  if ( !v6 )
  {
    v3[4] = v6;
    return 9;
  }
  v9 = sub_CEC94(v6);
  v10 = v7[1];
  v3[18] = v9;
  if ( v10 == 1 )
  {
    result = 5;
    v3[4] = 0;
  }
  else
  {
    v11 = v7 + 1;
    if ( v10 >= 0 )
    {
      v13 = sub_CEC94(v11);
      v12 = 0;
      v3[19] = v13;
    }
    else
    {
      v3[19] = v11;
      v12 = 1;
    }
    v14 = (int *)v3[19];
    v3[20] = v12;
    if ( *v14 >= 0 )
    {
      v3[4] = sub_CEC94(v14);
      result = 0;
    }
    else
    {
      v15 = sub_CED58(((unsigned int)*v14 >> 24) & 0xF);
      v3[4] = v15;
      if ( v15 )
        result = 0;
      else
        result = 9;
    }
  }
  return result;
}
// 25C88: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);

//----- (000CEEB4) --------------------------------------------------------
__int64 *__fastcall sub_CEEB4(__int64 *result)
{
  int v1; // r3
  __int64 *v2; // r4
  __int64 *v3; // r0

  v1 = *(_DWORD *)result;
  v2 = result;
  if ( !(*(_DWORD *)result & 1) )
  {
    v3 = result + 9;
    if ( v1 & 2 )
      result = _gnu_Unwind_Restore_VFP_D(v3);
    else
      result = _gnu_Unwind_Restore_VFP(v3);
  }
  if ( !(*(_DWORD *)v2 & 4) )
    result = _gnu_Unwind_Restore_VFP_D_16_to_31(v2 + 26);
  if ( !(*(_DWORD *)v2 & 8) )
    result = (__int64 *)_gnu_Unwind_Restore_WMMXD((int *)v2 + 84);
  if ( !(*(_DWORD *)v2 & 0x10) )
    result = (__int64 *)_gnu_Unwind_Restore_WMMXC((int *)v2 + 116);
  return result;
}

//----- (000CEF20) --------------------------------------------------------
int __fastcall sub_CEF20(_DWORD *a1)
{
  int result; // r0

  if ( *a1 )
    result = *(_DWORD *)((char *)a1 + *a1);
  else
    result = 0;
  return result;
}

//----- (000CEF34) --------------------------------------------------------
signed int sub_CEF34()
{
  return 9;
}

//----- (000CEF40) --------------------------------------------------------
int __fastcall sub_CEF40(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r4
  int v5; // r0
  int v6; // r0
  int v7; // r1
  signed int v8; // r2

  v3 = a1;
  v4 = a2;
  do
  {
    if ( sub_CEDA8((_DWORD *)v3, *(_DWORD *)(v4 + 64), a3) )
      goto LABEL_3;
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 64);
    v5 = (*(int (__fastcall **)(signed int, int, int))(v3 + 16))(1, v3, v4);
  }
  while ( v5 == 8 );
  if ( v5 != 7 )
LABEL_3:
    abort();
  nullsub_1(0, *(_DWORD *)(v4 + 64));
  restore_core_regs((int *)(v4 + 4));
  return sub_CEFA4(v6, v7, v8);
}
// CEF3C: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (000CEFA4) --------------------------------------------------------
signed int __fastcall sub_CEFA4(int a1, int a2, signed int a3)
{
  int *v3; // lr
  int (__fastcall *v4)(signed int, signed int, int, int, int *, int); // r8
  int v5; // r4
  int v6; // r9
  signed int v7; // r5
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r7
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r2
  int v22; // r1
  int v23; // r3
  signed int v24; // r0
  signed int v25; // r6
  int v26; // r3
  int v27; // r0
  int v29; // [sp+8h] [bp-1E0h]
  int v30; // [sp+Ch] [bp-1DCh]
  int v31; // [sp+10h] [bp-1D8h]
  int v32; // [sp+14h] [bp-1D4h]
  int v33; // [sp+18h] [bp-1D0h]
  int v34; // [sp+1Ch] [bp-1CCh]
  int v35; // [sp+20h] [bp-1C8h]
  int v36; // [sp+24h] [bp-1C4h]
  int v37; // [sp+28h] [bp-1C0h]
  int v38; // [sp+2Ch] [bp-1BCh]
  int v39; // [sp+30h] [bp-1B8h]
  int v40; // [sp+34h] [bp-1B4h]
  int v41; // [sp+38h] [bp-1B0h]
  int v42; // [sp+3Ch] [bp-1ACh]
  int v43; // [sp+40h] [bp-1A8h]
  int v44; // [sp+44h] [bp-1A4h]
  int v45; // [sp+48h] [bp-1A0h]
  int v46; // [sp+4Ch] [bp-19Ch]
  int v47; // [sp+1E8h] [bp+0h]
  int v48; // [sp+220h] [bp+38h]

  v3 = (int *)(a2 + 4);
  v4 = *(int (__fastcall **)(signed int, signed int, int, int, int *, int))(a1 + 12);
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 24);
  v7 = a3;
  v8 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)(a2 + 8);
  v10 = v3[2];
  v11 = v3[3];
  v3 += 4;
  v12 = 0;
  v30 = v8;
  v31 = v9;
  v32 = v10;
  v33 = v11;
  v13 = *v3;
  v14 = v3[1];
  v15 = v3[2];
  v16 = v3[3];
  v3 += 4;
  v34 = v13;
  v35 = v14;
  v36 = v15;
  v37 = v16;
  v17 = *v3;
  v18 = v3[1];
  v19 = v3[2];
  v20 = v3[3];
  v3 += 4;
  v38 = v17;
  v39 = v18;
  v40 = v19;
  v41 = v20;
  v22 = v3[1];
  v21 = v3[2];
  v23 = v3[3];
  v42 = *v3;
  v43 = v22;
  v44 = v21;
  v45 = v23;
  v29 = 0;
  while ( 1 )
  {
    v24 = sub_CEDA8((_DWORD *)v5, v45, v21);
    if ( v7 )
      v25 = 10;
    else
      v25 = 9;
    v7 = v24;
    if ( v24 )
    {
      v25 |= 0x10u;
      v26 = v43;
    }
    else
    {
      *(_DWORD *)(v5 + 20) = v45;
      memcpy(&v47, &v29, 0x1E0u);
      v27 = (*(int (__fastcall **)(signed int, int, int *))(v5 + 16))(v25, v5, &v47);
      v26 = v48;
      v12 = v27;
    }
    v46 = v26;
    if ( v4(1, v25, v5, v5, &v29, v6) )
      return 9;
    if ( v7 )
      break;
    memcpy(&v29, &v47, 0x1E0u);
    if ( v12 != 8 )
    {
      if ( v12 == 7 )
      {
        nullsub_1(0, v45);
        restore_core_regs(&v30);
      }
      return 9;
    }
  }
  return v7;
}
// CEF3C: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (000CF0C8) --------------------------------------------------------
int __fastcall Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 68);
}

//----- (000CF0D0) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_RaiseException(int a1, _DWORD *a2)
{
  int *v2; // lr
  int v3; // r5
  int v4; // r4
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r2
  int v18; // r1
  int v19; // r3
  int v20; // r7
  int v21; // r2
  int v23; // [sp+0h] [bp-1F8h]
  int v24; // [sp+4h] [bp-1F4h]
  int v25; // [sp+8h] [bp-1F0h]
  int v26; // [sp+Ch] [bp-1ECh]
  int v27; // [sp+10h] [bp-1E8h]
  int v28; // [sp+14h] [bp-1E4h]
  int v29; // [sp+18h] [bp-1E0h]
  int v30; // [sp+1Ch] [bp-1DCh]
  int v31; // [sp+20h] [bp-1D8h]
  int v32; // [sp+24h] [bp-1D4h]
  int v33; // [sp+28h] [bp-1D0h]
  int v34; // [sp+2Ch] [bp-1CCh]
  int v35; // [sp+30h] [bp-1C8h]
  int v36; // [sp+34h] [bp-1C4h]
  int v37; // [sp+38h] [bp-1C0h]
  int v38; // [sp+3Ch] [bp-1BCh]
  int v39; // [sp+40h] [bp-1B8h]

  v2 = a2 + 1;
  a2[16] = a2[15];
  v3 = a1;
  v4 = (int)a2;
  v5 = a2[1];
  v6 = a2[2];
  v7 = v2[2];
  v8 = v2[3];
  v2 += 4;
  v24 = v5;
  v25 = v6;
  v26 = v7;
  v27 = v8;
  v9 = *v2;
  v10 = v2[1];
  v11 = v2[2];
  v12 = v2[3];
  v2 += 4;
  v28 = v9;
  v29 = v10;
  v30 = v11;
  v31 = v12;
  v13 = *v2;
  v14 = v2[1];
  v15 = v2[2];
  v16 = v2[3];
  v2 += 4;
  v32 = v13;
  v33 = v14;
  v34 = v15;
  v35 = v16;
  v18 = v2[1];
  v17 = v2[2];
  v19 = v2[3];
  v36 = *v2;
  v37 = v18;
  v38 = v17;
  v39 = v19;
  v23 = -1;
  while ( !sub_CEDA8((_DWORD *)v3, v39, v17) )
  {
    v20 = (*(int (__cdecl **)(_DWORD, int, int *, _DWORD, int, int, int, int, int, int, int, int, int, int, int, int))(v3 + 16))(
            0,
            v3,
            &v23,
            *(_DWORD *)(v3 + 16),
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34);
    if ( v20 != 8 )
    {
      sub_CEEB4((__int64 *)&v23);
      if ( v20 == 6 )
        sub_CEF40(v3, v4, v21);
      return 9;
    }
  }
  return 9;
}

//----- (000CF174) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_ForcedUnwind(int a1, int a2, int a3, int a4)
{
  int v4; // r2

  *(_DWORD *)(a1 + 24) = a3;
  v4 = *(_DWORD *)(a4 + 60);
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a4 + 64) = v4;
  return sub_CEFA4(a1, a4, 0);
}

//----- (000CF190) --------------------------------------------------------
void __fastcall __noreturn _gnu_Unwind_Resume(int a1, int a2)
{
  int v2; // r5
  int v3; // r6
  int v4; // r4
  int v5; // r0
  int v6; // r2

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 12);
  v4 = a2;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    sub_CEFA4(a1, a2, 1);
    goto LABEL_7;
  }
  v5 = (*(int (__fastcall **)(signed int, int, int))(a1 + 16))(2, a1, a2);
  if ( v5 != 7 )
  {
    if ( v5 != 8 )
      goto LABEL_7;
    sub_CEF40(v2, v4, v6);
  }
  nullsub_1(0, *(_DWORD *)(v4 + 64));
  restore_core_regs((int *)(v4 + 4));
LABEL_7:
  abort();
}
// CEF3C: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (000CF204) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_Resume_or_Rethrow(int a1, _DWORD *a2)
{
  if ( !*(_DWORD *)(a1 + 12) )
    return _gnu_Unwind_RaiseException(a1, a2);
  a2[16] = a2[15];
  return sub_CEFA4(a1, (int)a2, 0);
}

//----- (000CF228) --------------------------------------------------------
int __fastcall Unwind_DeleteException(int result)
{
  int (__fastcall *v1)(signed int, int); // r3

  v1 = *(int (__fastcall **)(signed int, int))(result + 8);
  if ( v1 )
    result = v1(1, result);
  return result;
}

//----- (000CF248) --------------------------------------------------------
signed int __fastcall Unwind_VRS_Get(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  signed int result; // r0
  bool v6; // zf
  int v7; // r2

  switch ( a2 )
  {
    case 0:
      v6 = a3 == 15;
      if ( a3 <= 0xF )
        v6 = a4 == 0;
      if ( !v6 )
        goto LABEL_7;
      v7 = a1 + 4 * a3;
      result = 0;
      *a5 = *(_DWORD *)(v7 + 4);
      break;
    case 1:
    case 3:
    case 4:
      result = 1;
      break;
    default:
LABEL_7:
      result = 2;
      break;
  }
  return result;
}

//----- (000CF2A4) --------------------------------------------------------
int __fastcall sub_CF2A4(int a1, unsigned int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-Ch]

  v5 = a4;
  Unwind_VRS_Get(a1, 0, a2, 0, &v5);
  return v5;
}

//----- (000CF2CC) --------------------------------------------------------
signed int __fastcall Unwind_VRS_Set(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  signed int result; // r0
  bool v6; // zf
  int v7; // r2

  switch ( a2 )
  {
    case 0:
      v6 = a3 == 15;
      if ( a3 <= 0xF )
        v6 = a4 == 0;
      if ( !v6 )
        goto LABEL_7;
      v7 = a1 + 4 * a3;
      result = 0;
      *(_DWORD *)(v7 + 4) = *a5;
      break;
    case 1:
    case 3:
    case 4:
      result = 1;
      break;
    default:
LABEL_7:
      result = 2;
      break;
  }
  return result;
}

//----- (000CF328) --------------------------------------------------------
signed int __fastcall sub_CF328(int a1, unsigned int a2, int a3)
{
  int v4; // [sp+Ch] [bp-Ch]

  v4 = a3;
  return Unwind_VRS_Set(a1, 0, a2, 0, &v4);
}

//----- (000CF354) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, _DWORD *a3)
{
  int *v3; // lr
  int (__fastcall *v4)(int *, int); // r7
  int v5; // r8
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r1
  int v20; // r3
  signed int v21; // r5
  int v22; // r0
  bool v23; // zf
  int v25; // [sp+0h] [bp-250h]
  int (__fastcall *v26)(signed int, int *, int *); // [sp+10h] [bp-240h]
  int v27; // [sp+58h] [bp-1F8h]
  int v28; // [sp+5Ch] [bp-1F4h]
  int v29; // [sp+60h] [bp-1F0h]
  int v30; // [sp+64h] [bp-1ECh]
  int v31; // [sp+68h] [bp-1E8h]
  int v32; // [sp+6Ch] [bp-1E4h]
  int v33; // [sp+70h] [bp-1E0h]
  int v34; // [sp+74h] [bp-1DCh]
  int v35; // [sp+78h] [bp-1D8h]
  int v36; // [sp+7Ch] [bp-1D4h]
  int v37; // [sp+80h] [bp-1D0h]
  int v38; // [sp+84h] [bp-1CCh]
  int v39; // [sp+88h] [bp-1C8h]
  int v40; // [sp+8Ch] [bp-1C4h]
  int v41; // [sp+90h] [bp-1C0h]
  int v42; // [sp+94h] [bp-1BCh]
  int v43; // [sp+98h] [bp-1B8h]

  v3 = a3 + 1;
  a3[16] = a3[15];
  v4 = a1;
  v5 = a2;
  v6 = a3[1];
  v7 = a3[2];
  v8 = a3[3];
  v9 = v3[3];
  v3 += 4;
  v28 = v6;
  v29 = v7;
  v30 = v8;
  v31 = v9;
  v10 = *v3;
  v11 = v3[1];
  v12 = v3[2];
  v13 = v3[3];
  v3 += 4;
  v32 = v10;
  v33 = v11;
  v34 = v12;
  v35 = v13;
  v14 = *v3;
  v15 = v3[1];
  v16 = v3[2];
  v17 = v3[3];
  v3 += 4;
  v36 = v14;
  v37 = v15;
  v38 = v16;
  v39 = v17;
  v19 = v3[1];
  v18 = v3[2];
  v20 = v3[3];
  v40 = *v3;
  v41 = v19;
  v42 = v18;
  v43 = v20;
  v27 = -1;
  while ( !sub_CEDA8(&v25, v43, v18) )
  {
    sub_CF328((int)&v27, 0xCu, (int)&v25);
    if ( v4(&v27, v5) )
      break;
    v22 = v26(8, &v25, &v27);
    v23 = v22 == 9;
    if ( v22 != 9 )
      v23 = v22 == 5;
    v21 = v22;
    if ( v23 )
      goto LABEL_9;
  }
  v21 = 9;
LABEL_9:
  sub_CEEB4((__int64 *)&v27);
  return v21;
}

//----- (000CF418) --------------------------------------------------------
signed int __fastcall sub_CF418(int a1, void (__noreturn *a2)(), unsigned int *a3, unsigned int a4)
{
  unsigned int *v4; // r6
  int *v5; // r2
  signed int v6; // r9
  void (__noreturn *v7)(); // r4
  unsigned __int16 *v8; // r5
  int v9; // r7
  int v10; // r2
  int v11; // r10
  int v12; // r8
  int v13; // r2
  int v14; // r11
  int v15; // r5
  unsigned int v16; // r0
  _BOOL4 v17; // r0
  unsigned int v18; // r8
  int v19; // r0
  int v20; // r0
  void (__fastcall __noreturn *v21)(_BYTE *); // r5
  int v22; // r0
  unsigned int v23; // r1
  void (__fastcall __noreturn *v24)(_BYTE *); // r2
  int v25; // r11
  int v26; // r0
  int v27; // r0
  void (__noreturn *v28)(); // r3
  int v29; // r2
  int v30; // r3
  int v31; // r8
  int v32; // r0
  int v34; // r8
  int v35; // r3
  int v36; // r12
  int v37; // r3
  int v38; // ST04_4
  int v39; // r0
  int v40; // r0
  int v41; // r0
  int v42; // r11
  int v43; // r0
  int v44; // r8
  signed int v45; // r0
  int v46; // r2
  int v47; // r3
  int v48; // r0
  unsigned int v49; // [sp+4h] [bp-44h]
  unsigned int v50; // [sp+Ch] [bp-3Ch]
  void (__noreturn *v51)(); // [sp+10h] [bp-38h]
  int v52; // [sp+14h] [bp-34h]
  unsigned __int16 *v53; // [sp+18h] [bp-30h]
  char v54; // [sp+1Ch] [bp-2Ch]
  char v55; // [sp+1Dh] [bp-2Bh]

  v4 = a3;
  v5 = (int *)*((_DWORD *)a2 + 19);
  v6 = a4;
  v7 = a2;
  v8 = (unsigned __int16 *)(v5 + 1);
  v9 = a1 & 3;
  v10 = *v5;
  v53 = v8;
  v52 = v10;
  if ( a4 )
  {
    if ( (signed int)a4 <= 2 )
    {
      v55 = BYTE2(v10);
      v52 = v10 << 16;
      a4 = BYTE2(v10);
      v10 = 2;
      v54 = 2;
      v8 += 2 * a4;
    }
  }
  else
  {
    v10 <<= 8;
    a4 = 3;
    v52 = v10;
    v55 = v6;
    v54 = 3;
  }
  if ( v9 == 2 )
    v8 = (unsigned __int16 *)*((_DWORD *)a2 + 14);
  v11 = *((_DWORD *)a2 + 20) & 1;
  if ( v11 )
  {
    v11 = 0;
LABEL_65:
    if ( v6 <= 2 )
      v45 = _gnu_unwind_execute(v4, &v52, v10, a4);
    else
      v45 = sub_CEF34();
    if ( v45 )
      return 9;
    if ( !v11 )
      return 8;
    v48 = sub_CF2A4((int)v4, 0xFu, v46, v47);
    sub_CF328((int)v4, 0xEu, v48);
    v22 = (int)v4;
    v23 = 15;
    v24 = _cxa_call_unexpected;
LABEL_42:
    sub_CF328(v22, v23, (int)v24);
    return 7;
  }
  v50 = ((a1 ^ 8u) >> 3) & 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = *(_DWORD *)v8;
      if ( !*(_DWORD *)v8 )
        goto LABEL_65;
      v13 = *((_DWORD *)v7 + 18);
      if ( v6 == 2 )
      {
        v14 = *((_DWORD *)v8 + 1);
        v15 = (int)(v8 + 4);
      }
      else
      {
        v14 = v8[1];
        v12 = *v8;
        v15 = (int)(v8 + 2);
      }
      v49 = (v14 & 0xFFFFFFFE) + v13;
      v16 = sub_CF2A4((int)v4, 0xFu, v13, v49);
      a4 = v49;
      if ( v49 <= v16 )
      {
        v10 = v12 & 0xFFFFFFFE;
        a4 = v49 + (v12 & 0xFFFFFFFE);
        v17 = v16 < a4;
      }
      else
      {
        v17 = 0;
      }
      v18 = v12 & 1 | 2 * (v14 & 1);
      if ( v18 == 1 )
        break;
      if ( v18 < 1 )
      {
        if ( v9 )
          v19 = v17;
        else
          v19 = 0;
        if ( v19 )
        {
          v20 = sub_CEC94((int *)v15);
          *((_DWORD *)v7 + 14) = v15 + 4;
          v21 = (void (__fastcall __noreturn *)(_BYTE *))v20;
          if ( !_cxa_begin_cleanup(v7) )
            return 9;
          v22 = (int)v4;
          v23 = 15;
          v24 = v21;
          goto LABEL_42;
        }
        v8 = (unsigned __int16 *)(v15 + 4);
      }
      else
      {
        if ( v18 != 2 )
          return 9;
        v34 = *(_DWORD *)v15 & 0x7FFFFFFF;
        if ( v9 )
        {
          v42 = *((_DWORD *)v7 + 8);
          if ( v42 != sub_CF2A4((int)v4, 0xDu, v10, a4) || v15 != *((_DWORD *)v7 + 10) )
            goto LABEL_61;
          *((_DWORD *)v7 + 10) = v34;
          *((_DWORD *)v7 + 12) = 4;
          *((_DWORD *)v7 + 11) = 0;
          *((_DWORD *)v7 + 13) = v15 + 4;
          if ( *(_DWORD *)v15 < 0 )
          {
            v43 = sub_CEC94((int *)(v15 + 4 * (v34 + 1)));
            sub_CF328((int)v4, 0xFu, v43);
            v22 = (int)v4;
            v23 = 0;
            goto LABEL_41;
          }
          v11 = 1;
        }
        else if ( v17 )
        {
          v35 = v50;
          if ( !v34 )
            v35 = v50 | 1;
          if ( v35 )
          {
            v36 = 0;
            v37 = (int)v7 + 88;
            while ( v36 != v34 )
            {
              v38 = v36 + 1;
              v51 = (void (__noreturn *)())((char *)v7 + 88);
              v39 = sub_CEF20((_DWORD *)(v15 + 4 * (v36 + 1)));
              v40 = _cxa_type_match(v7, v39, 0, &v51);
              v36 = v38;
              if ( v40 )
                goto LABEL_61;
            }
            v41 = sub_CF2A4((int)v4, 0xDu, v10, v37);
            v30 = (int)v51;
            *((_DWORD *)v7 + 8) = v41;
LABEL_54:
            *((_DWORD *)v7 + 9) = v30;
            goto LABEL_55;
          }
        }
LABEL_61:
        a4 = *(_DWORD *)v15;
        v44 = v34 + 1;
        if ( *(_DWORD *)v15 < 0 )
          v15 += 4;
        v8 = (unsigned __int16 *)(v15 + 4 * v44);
      }
    }
    if ( !v9 )
      break;
    v31 = *((_DWORD *)v7 + 8);
    if ( v31 == sub_CF2A4((int)v4, 0xDu, v10, a4) )
    {
      a4 = *((_DWORD *)v7 + 10);
      if ( v15 == a4 )
      {
        v32 = sub_CEC94((int *)v15);
        sub_CF328((int)v4, 0xFu, v32);
        v22 = (int)v4;
        v23 = 0;
LABEL_41:
        v24 = (void (__fastcall __noreturn *)(_BYTE *))v7;
        goto LABEL_42;
      }
    }
LABEL_43:
    v8 = (unsigned __int16 *)(v15 + 8);
  }
  if ( !v17 )
    goto LABEL_43;
  a4 = *(_DWORD *)(v15 + 4);
  v25 = *(_DWORD *)v15 >> 31;
  if ( a4 == -2 )
    return 9;
  v10 = (int)v7 + 88;
  v51 = (void (__noreturn *)())((char *)v7 + 88);
  if ( a4 != -1 )
  {
    v26 = sub_CEF20((_DWORD *)(v15 + 4));
    v18 = _cxa_type_match(v7, v26, v25, &v51);
    if ( !v18 )
      goto LABEL_43;
  }
  v27 = sub_CF2A4((int)v4, 0xDu, v10, a4);
  v29 = (int)v51;
  if ( v18 == 2 )
    v28 = v7;
  else
    *((_DWORD *)v7 + 9) = v51;
  *((_DWORD *)v7 + 8) = v27;
  if ( v18 == 2 )
  {
    *((_DWORD *)v28 + 11) = v29;
    v30 = (int)v28 + 44;
    goto LABEL_54;
  }
LABEL_55:
  *((_DWORD *)v7 + 10) = v15;
  return 6;
}

//----- (000CF808) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr0(int a1, void (__noreturn *a2)(), unsigned int *a3)
{
  return sub_CF418(a1, a2, a3, 0);
}

//----- (000CF810) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr1(int a1, void (__noreturn *a2)(), unsigned int *a3)
{
  return sub_CF418(a1, a2, a3, 1u);
}

//----- (000CF818) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr2(int a1, void (__noreturn *a2)(), unsigned int *a3)
{
  return sub_CF418(a1, a2, a3, 2u);
}

//----- (000CF820) --------------------------------------------------------
int __fastcall Unwind_VRS_Pop(unsigned int *a1, int a2, unsigned int a3, int a4)
{
  unsigned int *v4; // r4
  unsigned int v5; // r5
  int v6; // r1
  int *v7; // r2
  bool v8; // zf
  int v9; // r12
  int v10; // r6
  int result; // r0
  unsigned int v12; // r6
  int v13; // r5
  unsigned int v14; // r2
  unsigned int v15; // r1
  _BOOL4 v16; // r9
  int v17; // r8
  signed int v18; // r7
  bool v19; // zf
  unsigned int v20; // r2
  _QWORD *v21; // r0
  unsigned int v22; // r2
  int v23; // r3
  int v24; // r5
  int v25; // r0
  unsigned int v26; // r1
  bool v27; // cf
  int v28; // t1
  signed int v29; // r0
  int v30; // r8
  int v31; // r2
  char *v32; // r0
  unsigned int v33; // r7
  int v34; // r5
  int v35; // r5
  unsigned int v36; // r3
  unsigned int v37; // r2
  int v38; // r1
  char *i; // r7
  int v40; // t1
  bool v41; // zf
  int *v42; // r2
  int v43; // r3
  int v44; // r0
  int v45; // [sp+0h] [bp-128h]
  char v46[136]; // [sp+80h] [bp-A8h]
  char v47; // [sp+108h] [bp-20h]

  v4 = a1;
  v5 = a3;
  switch ( a2 )
  {
    case 0:
      if ( a4 )
        return 2;
      v6 = (unsigned __int16)a3;
      v7 = (int *)a1[14];
      do
      {
        v9 = v6 & (1 << a4);
        v8 = (v6 & (1 << a4)) == 0;
        if ( v6 & (1 << a4) )
          v9 = (int)&a1[a4];
        ++a4;
        if ( !v8 )
        {
          v10 = *v7;
          ++v7;
          *(_DWORD *)(v9 + 4) = v10;
        }
      }
      while ( a4 != 16 );
      result = v5 & 0x2000;
      if ( v5 & 0x2000 )
        return 0;
      v4[14] = (unsigned int)v7;
      return result;
    case 1:
      if ( (a4 & 0xFFFFFFFB) != 1 )
        return 2;
      v12 = a3 >> 16;
      v13 = (unsigned __int16)a3;
      v14 = (unsigned __int16)a3 + (a3 >> 16);
      v15 = a4 == 1 ? 16 : 32;
      if ( v14 > v15 )
        return 2;
      v16 = (unsigned int)(a4 - 1) <= 0;
      v17 = v12 > 0xF;
      if ( v16 & v17 )
        return 2;
      if ( v12 > 0xF )
      {
        v17 = v13;
      }
      else if ( v14 > 0x10 )
      {
        v17 = v14 - 16;
      }
      v18 = v17;
      if ( v17 )
        v18 = 1;
      v19 = a4 == 5;
      if ( a4 != 5 )
        v19 = v17 == 0;
      if ( !v19 )
        return 2;
      if ( v12 <= 0xF )
      {
        v20 = *a1;
        if ( *a1 & 1 )
        {
          *a1 = v20 & 0xFFFFFFFE;
          v21 = a1 + 18;
          if ( a4 == 5 )
          {
            *v4 = v20 & 0xFFFFFFFE | 2;
            _gnu_Unwind_Save_VFP_D(v21);
          }
          else
          {
            *v4 = v20 & 0xFFFFFFFC;
            _gnu_Unwind_Save_VFP(v21);
          }
        }
      }
      if ( v18 && *v4 & 4 )
      {
        *v4 &= 0xFFFFFFFB;
        _gnu_Unwind_Save_VFP_D_16_to_31((_QWORD *)v4 + 26);
      }
      if ( v16 )
      {
        _gnu_Unwind_Save_VFP(v46);
        if ( !v18 )
          goto LABEL_44;
      }
      else
      {
        if ( v12 <= 0xF )
          _gnu_Unwind_Save_VFP_D(v46);
        if ( !v18 )
          goto LABEL_44;
        _gnu_Unwind_Save_VFP_D_16_to_31(&v45);
      }
      v13 = 16 - v12;
LABEL_44:
      v22 = v4[14];
      v23 = v4[14];
      if ( v13 > 0 )
      {
        v24 = 2 * v13;
        v25 = v22 - 4;
        v26 = v24;
        while ( 1 )
        {
          v27 = v26-- >= 1;
          if ( !v27 )
            break;
          v28 = *(_DWORD *)(v25 + 4);
          v25 += 4;
          *(_DWORD *)&v46[8 * v12 - v22 + v25] = v28;
        }
        v23 = v22 + 4 * v24;
      }
      if ( v18 )
      {
        if ( v12 < 0x10 )
          v29 = 16;
        else
          v29 = v12;
        v30 = 2 * v17;
        v31 = 0;
        v32 = &v47 + 8 * v29 - 392;
        while ( v31 != v30 )
        {
          *(_DWORD *)&v32[4 * v31] = *(_DWORD *)(v23 + 4 * v31);
          ++v31;
        }
        v23 += 4 * v31;
      }
      if ( v16 )
        v23 += 4;
      v4[14] = v23;
      if ( v16 )
      {
        _gnu_Unwind_Restore_VFP((__int64 *)v46);
      }
      else
      {
        if ( v12 <= 0xF )
          _gnu_Unwind_Restore_VFP_D((__int64 *)v46);
        if ( v18 )
          _gnu_Unwind_Restore_VFP_D_16_to_31((__int64 *)&v45);
      }
      return 0;
    case 3:
      if ( a4 != 3 )
        return 2;
      v33 = a3 >> 16;
      v34 = (unsigned __int16)a3;
      if ( (unsigned __int16)a3 + (a3 >> 16) > 0x10 )
        return 2;
      if ( *a1 & 8 )
      {
        *a1 &= 0xFFFFFFF7;
        _gnu_Unwind_Save_WMMXD();
      }
      v35 = 2 * v34;
      _gnu_Unwind_Save_WMMXD();
      v36 = v4[14];
      v37 = v35;
      v38 = v36 - 4;
      for ( i = &v46[8 * v33 - v36]; ; *(_DWORD *)&i[v38] = v40 )
      {
        v27 = v37-- >= 1;
        if ( !v27 )
          break;
        v40 = *(_DWORD *)(v38 + 4);
        v38 += 4;
      }
      v4[14] = v36 + 4 * v35;
      _gnu_Unwind_Restore_WMMXD((int *)v46);
      return 0;
    case 4:
      v41 = a3 == 16;
      if ( a3 <= 0x10 )
        v41 = a4 == 0;
      if ( !v41 )
        return 2;
      if ( *a1 & 0x10 )
      {
        *a1 &= 0xFFFFFFEF;
        _gnu_Unwind_Save_WMMXC();
      }
      _gnu_Unwind_Save_WMMXC();
      v42 = (int *)v4[14];
      v43 = 0;
      do
      {
        if ( v5 & (1 << v43) )
        {
          v44 = *v42;
          ++v42;
          *(_DWORD *)&v46[4 * v43] = v44;
        }
        ++v43;
      }
      while ( v43 != 4 );
      v4[14] = (unsigned int)v42;
      _gnu_Unwind_Restore_WMMXC((int *)v46);
      return 0;
    default:
      return 2;
  }
}
// CF820: using guessed type char var_A8[136];

//----- (000CFB6C) --------------------------------------------------------
void __fastcall restore_core_regs(int *a1)
{
  int v1; // ST04_4
  int v2; // r0
  int v3; // [sp+8h] [bp-4h]

  v1 = a1[13];
  v2 = *a1;
  JUMPOUT(__CS__, v3);
}

//----- (000CFB80) --------------------------------------------------------
__int64 *__fastcall _gnu_Unwind_Restore_VFP(__int64 *result)
{
  __int64 v1; // d0

  v1 = *result;
  return result;
}

//----- (000CFB88) --------------------------------------------------------
_QWORD *__fastcall _gnu_Unwind_Save_VFP(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}

//----- (000CFB90) --------------------------------------------------------
__int64 *__fastcall _gnu_Unwind_Restore_VFP_D(__int64 *result)
{
  __int64 v1; // d0

  v1 = *result;
  return result;
}

//----- (000CFB98) --------------------------------------------------------
_QWORD *__fastcall _gnu_Unwind_Save_VFP_D(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}

//----- (000CFBA0) --------------------------------------------------------
__int64 *__fastcall _gnu_Unwind_Restore_VFP_D_16_to_31(__int64 *result)
{
  __int64 v1; // d16

  v1 = *result;
  return result;
}

//----- (000CFBA8) --------------------------------------------------------
_QWORD *__fastcall _gnu_Unwind_Save_VFP_D_16_to_31(_QWORD *result)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  __int64 v4; // d19
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d22
  __int64 v8; // d23
  __int64 v9; // d24
  __int64 v10; // d25
  __int64 v11; // d26
  __int64 v12; // d27
  __int64 v13; // d28
  __int64 v14; // d29
  __int64 v15; // d30
  __int64 v16; // d31

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}

//----- (000CFBB0) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_WMMXD(int *a1)
{
  int *v5; // r0
  int result; // r0

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = (int)(v5 + 2);
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (000CFBF4) --------------------------------------------------------
void _gnu_Unwind_Save_WMMXD()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (000CFC38) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_WMMXC(int *a1)
{
  int *v5; // r0
  int result; // r0

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = (int)(v5 + 1);
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (000CFC4C) --------------------------------------------------------
void _gnu_Unwind_Save_WMMXC()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (000CFC60) --------------------------------------------------------
signed int __fastcall __Unwind_RaiseException(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-44h]
  int v6; // [sp+8h] [bp-40h]
  int v7; // [sp+Ch] [bp-3Ch]
  int v8; // [sp+10h] [bp-38h]
  int v9; // [sp+14h] [bp-34h]

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_RaiseException(a1, &v5);
}

//----- (000CFC84) --------------------------------------------------------
void __fastcall __noreturn __Unwind_Resume(int a1, int a2, int a3, int a4)
{
  int v4; // [sp+4h] [bp-44h]
  int v5; // [sp+8h] [bp-40h]
  int v6; // [sp+Ch] [bp-3Ch]
  int v7; // [sp+10h] [bp-38h]
  int v8; // [sp+14h] [bp-34h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v4 = 0;
  _gnu_Unwind_Resume(a1, (int)&v4);
}

//----- (000CFCA8) --------------------------------------------------------
signed int __fastcall __noreturn __Unwind_Resume_or_Rethrow(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-44h]
  int v6; // [sp+8h] [bp-40h]
  int v7; // [sp+Ch] [bp-3Ch]
  int v8; // [sp+10h] [bp-38h]
  int v9; // [sp+14h] [bp-34h]

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_Resume_or_Rethrow(a1, &v5);
}

//----- (000CFCCC) --------------------------------------------------------
signed int __fastcall __Unwind_ForcedUnwind(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-44h]
  int v6; // [sp+8h] [bp-40h]
  int v7; // [sp+Ch] [bp-3Ch]
  int v8; // [sp+10h] [bp-38h]
  int v9; // [sp+14h] [bp-34h]

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_ForcedUnwind(a1, a2, a3, (int)&v5);
}

//----- (000CFCF0) --------------------------------------------------------
signed int __fastcall __Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-44h]
  int (__fastcall *v6)(int *, int); // [sp+8h] [bp-40h]
  int v7; // [sp+Ch] [bp-3Ch]
  int v8; // [sp+10h] [bp-38h]
  int v9; // [sp+14h] [bp-34h]

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_Backtrace(a1, a2, &v5);
}

//----- (000CFD14) --------------------------------------------------------
signed int __fastcall sub_CFD14(int *a1)
{
  int *v1; // r3
  char v2; // r3
  unsigned int v3; // r3

  if ( *((_BYTE *)a1 + 8) )
  {
    v2 = *((_BYTE *)a1 + 8) - 1;
    goto LABEL_5;
  }
  if ( *((_BYTE *)a1 + 9) )
  {
    --*((_BYTE *)a1 + 9);
    v1 = (int *)a1[1];
    a1[1] = (int)(v1 + 1);
    *a1 = *v1;
    v2 = 3;
LABEL_5:
    *((_BYTE *)a1 + 8) = v2;
    v3 = *a1;
    *a1 <<= 8;
    return v3 >> 24;
  }
  return 176;
}

//----- (000CFD74) --------------------------------------------------------
int __fastcall sub_CFD74(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-Ch]

  v5 = a4;
  Unwind_VRS_Get(a1, 0, 0xCu, 0, &v5);
  return v5;
}

//----- (000CFDA0) --------------------------------------------------------
signed int __fastcall _gnu_unwind_execute(unsigned int *a1, int *a2, int a3, int a4)
{
  unsigned int *v4; // r5
  int *v5; // r6
  signed int v6; // r7
  signed int v7; // r0
  char v8; // r4
  unsigned __int8 v9; // r10
  int v10; // r10
  int v11; // r10
  int v12; // r3
  int v13; // r0
  __int16 v15; // r4
  bool v16; // zf
  int v17; // r2
  unsigned int *v18; // r0
  signed int v19; // r1
  signed int v20; // r0
  signed int v21; // r3
  char v22; // r4
  char i; // r0
  int v24; // r1
  int v25; // r0
  char v26; // r0
  int v27; // r2
  int v28; // r3
  int v29; // r2
  char v30; // r0
  signed int v31; // r0
  int v32; // r2
  char v33; // r0
  int v34; // r2
  int v35; // r3
  char v36; // r0
  int v37; // r2
  int v38; // [sp+Ch] [bp-24h]

  v38 = a4;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  while ( 1 )
  {
    v7 = sub_CFD14(v5);
    v8 = v7;
    if ( v7 == 176 )
      break;
    if ( !(v7 & 0x80) )
    {
      v9 = 4 * v7;
      Unwind_VRS_Get((int)v4, v7 & 0x80, 0xDu, v7 & 0x80, &v38);
      v10 = v9 + 4;
      if ( v8 & 0x40 )
        v11 = v38 - v10;
      else
        v11 = v38 + v10;
      v38 = v11;
      goto LABEL_20;
    }
    v12 = v7 & 0xF0;
    switch ( v12 )
    {
      case 128:
        v13 = sub_CFD14(v5) | (v7 << 8);
        if ( v13 == 0x8000 )
          return 9;
        v15 = 16 * v13;
        if ( Unwind_VRS_Pop(v4, 0, (unsigned __int16)(16 * v13), 0) )
          return 9;
        if ( v15 & 0x8000 )
          v6 = 1;
        break;
      case 144:
        if ( (v7 & 0xD) == 13 )
          return 9;
        Unwind_VRS_Get((int)v4, 0, v7 & 0xF, 0, &v38);
LABEL_20:
        Unwind_VRS_Set((int)v4, 0, 0xDu, 0, &v38);
        break;
      case 160:
        v16 = (v7 & 8) == 0;
        v17 = (4080 >> (~(_BYTE)v7 & 7)) & 0xFF0;
        v18 = v4;
        if ( !v16 )
          v17 |= 0x4000u;
        v19 = 0;
        goto LABEL_31;
      case 176:
        if ( v7 == 177 )
        {
          v20 = sub_CFD14(v5);
          v17 = v20;
          if ( !v20 )
            return 9;
          v19 = v20 & 0xF0;
          if ( v20 & 0xF0 )
            return 9;
          v18 = v4;
          goto LABEL_31;
        }
        if ( v7 != 178 )
        {
          if ( v7 == 179 )
          {
            v26 = sub_CFD14(v5);
            v19 = 1;
            v27 = v26 & 0xF0;
            v28 = (v26 & 0xF) + 1;
            v18 = v4;
            goto LABEL_44;
          }
          if ( (v7 & 0xFC) == 180 )
            return 9;
          v19 = 1;
          v29 = (v7 & 7) + 1;
          v18 = v4;
          v17 = v29 | 0x80000;
LABEL_31:
          v21 = v19;
          goto LABEL_59;
        }
        v22 = 2;
        Unwind_VRS_Get((int)v4, 0, 0xDu, 0, &v38);
        for ( i = sub_CFD14(v5); ; i = sub_CFD14(v5) )
        {
          v24 = i & 0x80;
          v16 = v24 == 0;
          v25 = i & 0x7F;
          if ( v16 )
            break;
          v38 += v25 << v22;
          v22 += 7;
        }
        v38 += 516 + (v25 << v22);
        Unwind_VRS_Set((int)v4, v24, 0xDu, v24, &v38);
        break;
      case 192:
        if ( v7 == 198 )
        {
          v30 = sub_CFD14(v5);
          v19 = 3;
          v27 = v30 & 0xF0;
          v28 = (v30 & 0xF) + 1;
          v18 = v4;
LABEL_44:
          v17 = v28 | (v27 << 12);
          goto LABEL_31;
        }
        if ( v7 != 199 )
        {
          if ( (v7 & 0xF8) != 192 )
          {
            if ( v7 == 200 )
            {
              v33 = sub_CFD14(v5);
              v34 = (unsigned __int8)(v33 & 0xF0) + 16;
              v35 = (v33 & 0xF) + 1;
            }
            else
            {
              if ( v7 != 201 )
                return 9;
              v36 = sub_CFD14(v5);
              v34 = v36 & 0xF0;
              v35 = (v36 & 0xF) + 1;
            }
            v18 = v4;
            v19 = 1;
            v17 = v35 | (v34 << 12);
LABEL_58:
            v21 = 5;
            goto LABEL_59;
          }
          v19 = 3;
          v32 = (v7 & 0xF) + 1;
          v18 = v4;
          v17 = v32 | 0xA0000;
          goto LABEL_31;
        }
        v31 = sub_CFD14(v5);
        v17 = v31;
        if ( !v31 )
          return 9;
        v21 = v31 & 0xF0;
        if ( v31 & 0xF0 )
          return 9;
        v18 = v4;
        v19 = 4;
LABEL_59:
        if ( Unwind_VRS_Pop(v18, v19, v17, v21) )
          return 9;
        break;
      default:
        if ( (v7 & 0xF8) != 208 )
          return 9;
        v19 = 1;
        v37 = (v7 & 7) + 1;
        v18 = v4;
        v17 = v37 | 0x80000;
        goto LABEL_58;
    }
  }
  if ( !v6 )
  {
    Unwind_VRS_Get((int)v4, 0, 0xEu, 0, &v38);
    Unwind_VRS_Set((int)v4, 0, 0xFu, 0, &v38);
  }
  return 0;
}

//----- (000D011C) --------------------------------------------------------
signed int __fastcall _gnu_unwind_frame(int a1, unsigned int *a2, int a3, int a4)
{
  int v4; // r3
  int v5; // r3
  unsigned int *v7; // [sp+4h] [bp-14h]
  int v8; // [sp+8h] [bp-10h]
  int v9; // [sp+Ch] [bp-Ch]

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v4 = *(_DWORD *)(a1 + 76);
  v7 = (unsigned int *)(*(_DWORD *)(v4 + 4) << 8);
  v8 = v4 + 8;
  LOBYTE(v9) = 3;
  v5 = *(unsigned __int8 *)(v4 + 7);
  BYTE1(v9) = v5;
  return _gnu_unwind_execute(a2, (int *)&v7, 3, v5);
}

//----- (000D015C) --------------------------------------------------------
int Unwind_GetRegionStart()
{
  return *(_DWORD *)(sub_CFD9C() + 72);
}
// CFD9C: using guessed type int sub_CFD9C(void);

//----- (000D016C) --------------------------------------------------------
int Unwind_GetLanguageSpecificData()
{
  int v0; // r0

  v0 = sub_CFD9C();
  return *(_DWORD *)(v0 + 76) + 4 * *(unsigned __int8 *)(*(_DWORD *)(v0 + 76) + 7) + 8;
}
// CFD9C: using guessed type int sub_CFD9C(void);

//----- (000D0188) --------------------------------------------------------
void __noreturn Unwind_GetDataRelBase()
{
  abort();
}

//----- (000D0190) --------------------------------------------------------
void __noreturn Unwind_GetTextRelBase()
{
  abort();
}

//----- (000D0198) --------------------------------------------------------
int __fastcall _muldf3(__int64 a1, __int64 a2)
{
  int v2; // r5
  bool v3; // zf
  int v4; // r4
  int v5; // r4
  int v6; // r6
  int v7; // r1
  bool v8; // zf
  int v9; // r12
  unsigned int v10; // r5
  unsigned int v11; // lr
  int v12; // r2
  unsigned int v13; // lr
  unsigned __int64 v14; // kr10_8
  unsigned int v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r4
  int v18; // off
  unsigned int v19; // lr
  unsigned __int8 v20; // cf
  bool v21; // zf
  bool v22; // nf
  unsigned __int8 v23; // vf
  unsigned int v24; // r12
  bool v25; // cf
  bool v26; // zf
  bool v27; // nf
  unsigned __int8 v28; // vf
  int v29; // r4
  int v30; // r4
  int v31; // r4
  int v32; // r4
  char v33; // r4
  unsigned int v34; // r3
  char v35; // r4
  unsigned int v36; // r3
  int v37; // lr
  unsigned int v38; // r3
  int v39; // r5
  bool v40; // zf
  bool v41; // zf
  bool v42; // zf

  v4 = (HIDWORD(a1) >> 20) & 0x7FF;
  v3 = v4 == 0;
  if ( v4 )
  {
    v2 = (HIDWORD(a2) >> 20) & 0x7FF;
    v3 = v2 == 0;
  }
  if ( !v3 )
  {
    v3 = v4 == 2047;
    if ( v4 != 2047 )
      v3 = v2 == 2047;
  }
  if ( v3 )
  {
    v40 = v4 == 2047;
    v39 = (HIDWORD(a2) >> 20) & 0x7FF;
    if ( v4 != 2047 )
      v40 = v39 == 2047;
    if ( v40 )
    {
      v42 = ((unsigned int)a1 | 2 * HIDWORD(a1)) == 0;
      if ( (unsigned int)a1 | 2 * HIDWORD(a1) )
        v42 = ((unsigned int)a2 | 2 * HIDWORD(a2)) == 0;
      else
        a1 = a2;
      if ( v42 || v4 == 2047 && (unsigned int)a1 | (HIDWORD(a1) << 12) )
        return a1;
      if ( v39 == 2047 && (unsigned int)a2 | (HIDWORD(a2) << 12) )
      {
        LODWORD(a1) = a2;
        return a1;
      }
LABEL_66:
      LODWORD(a1) = 0;
      return a1;
    }
    v41 = ((unsigned int)a1 | 2 * HIDWORD(a1)) == 0;
    if ( (unsigned int)a1 | 2 * HIDWORD(a1) )
      v41 = ((unsigned int)a2 | 2 * HIDWORD(a2)) == 0;
    if ( v41 )
    {
      LODWORD(a1) = 0;
    }
    else
    {
      if ( v4 )
        goto LABEL_70;
      while ( 1 )
      {
        v20 = __CFSHL__(a1, 1);
        LODWORD(a1) = 2 * a1;
        HIDWORD(a1) += v20 + HIDWORD(a1);
        if ( a1 & 0x10000000000000LL )
          break;
        --v4;
      }
      if ( !v39 )
      {
LABEL_70:
        while ( 1 )
        {
          v20 = __CFSHL__(a2, 1);
          LODWORD(a2) = 2 * a2;
          HIDWORD(a2) += v20 + HIDWORD(a2);
          if ( a2 & 0x10000000000000LL )
            break;
          --v39;
        }
      }
    }
  }
  else
  {
    v5 = v4 + v2;
    v6 = HIDWORD(a1) ^ HIDWORD(a2);
    v7 = HIDWORD(a1) & 0x1FFFFF;
    HIDWORD(a2) &= 0x1FFFFFu;
    v8 = ((unsigned int)a1 | (v7 << 12)) == 0;
    if ( (unsigned int)a1 | (v7 << 12) )
      v8 = ((unsigned int)a2 | (HIDWORD(a2) << 12)) == 0;
    HIDWORD(a1) = v7 | 0x100000;
    HIDWORD(a2) |= 0x100000u;
    if ( v8 )
    {
      LODWORD(a1) = a1 | a2;
      HIDWORD(a1) = (v6 & 0x80000000 | HIDWORD(a1)) ^ HIDWORD(a2);
      v28 = __OFSUB__(v5, 1023);
      v29 = v5 - 1023;
      v26 = v29 == 0;
      v27 = v29 < 0;
      if ( !((unsigned __int8)((v29 < 0) ^ v28) | (v29 == 0)) )
      {
        v28 = __OFSUB__(2047, v29);
        v26 = v29 == 2047;
        v27 = 2047 - v29 < 0;
      }
      if ( !((unsigned __int8)(v27 ^ v28) | v26) )
        return a1;
      HIDWORD(a1) |= 0x100000u;
      v19 = 0;
      v23 = __OFSUB__(v29, 1);
      v17 = v29 - 1;
      v21 = v17 == 0;
      v22 = (v17 & 0x80000000) != 0;
    }
    else
    {
      v9 = a1 * a2;
      v10 = (HIDWORD(a1) * (unsigned __int64)(unsigned int)a2
           + ((unsigned int)a1 * (unsigned __int64)(unsigned int)a2 >> 32)) >> 32;
      v11 = a1 * (unsigned __int64)(unsigned int)a2 >> 32;
      LODWORD(a2) = v6 & 0x80000000;
      v14 = (unsigned int)a1 * (unsigned __int64)HIDWORD(a2) + __PAIR__(v10, v11);
      v13 = v14;
      v16 = (HIDWORD(a1) * (unsigned __int64)HIDWORD(a2) + HIDWORD(v14)) >> 32;
      v15 = HIDWORD(a1) * HIDWORD(a2) + HIDWORD(v14);
      if ( v9 )
        v13 = v14 | 1;
      v17 = (__PAIR__((unsigned int)(v5 - 255), v16) - 3298534883840LL) >> 32;
      if ( v16 < 0x200 )
      {
        v20 = __CFSHL__(v13, 1);
        v13 *= 2;
        v18 = v20 + v15;
        v20 = __CFADD__(v20, v15) | __CFADD__(v15, v18);
        v15 += v18;
        v16 += v20 + v16;
      }
      HIDWORD(a1) = v12 | (v16 << 11) | (v15 >> 21);
      LODWORD(a1) = (v15 << 11) | (v13 >> 21);
      v19 = v13 << 11;
      v23 = __OFSUB__(v17, 253);
      v20 = v17 >= 0xFD;
      v24 = v17 - 253;
      v21 = v17 == 253;
      v22 = (signed int)(v17 - 253) < 0;
      if ( v17 > 0xFD )
      {
        v23 = __OFSUB__(v24, 1792);
        v20 = v24 >= 0x700;
        v21 = v24 == 1792;
        v22 = (signed int)(v17 - 2045) < 0;
      }
      if ( !(!v21 & v20) )
      {
        v25 = v19 >= 0x80000000;
        if ( v19 == 0x80000000 )
          v25 = a1 & 1;
        LODWORD(a1) = v25 + (_DWORD)a1;
        return a1;
      }
    }
    if ( !((unsigned __int8)(v22 ^ v23) | v21) )
      goto LABEL_66;
    if ( (unsigned __int8)(((signed int)(v17 + 54) < 0) ^ __OFADD__(v17, 54)) | (v17 == -54) )
    {
      LODWORD(a1) = 0;
    }
    else
    {
      v30 = -v17;
      v23 = __OFSUB__(v30, 32);
      v31 = v30 - 32;
      if ( (v31 < 0) ^ v23 )
      {
        v23 = __OFADD__(v31, 12);
        v32 = v31 + 12;
        if ( (unsigned __int8)((v32 < 0) ^ v23) | (v32 == 0) )
        {
          v33 = v32 + 20;
          v34 = (_DWORD)a1 << (32 - v33);
          LODWORD(a1) = (((unsigned int)a1 >> v33) | (HIDWORD(a1) << (32 - v33))) + (v34 >> 31);
          if ( !(v19 | 2 * v34) )
            LODWORD(a1) = a1 & ~(v34 >> 31);
        }
        else
        {
          v35 = 12 - v32;
          v36 = (_DWORD)a1 << v35;
          LODWORD(a1) = (((unsigned int)a1 >> (32 - v35)) | (HIDWORD(a1) << v35)) + ((_DWORD)a1 << v35 >> 31);
          if ( !(v19 | 2 * v36) )
            LODWORD(a1) = a1 & ~(v36 >> 31);
        }
      }
      else
      {
        v37 = v19 | ((_DWORD)a1 << (32 - v31));
        v38 = ((unsigned int)a1 >> v31) | (HIDWORD(a1) << (32 - v31));
        LODWORD(a1) = ((HIDWORD(a1) >> v31) & ~((HIDWORD(a1) & 0x80000000) >> v31)) + (v38 >> 31);
        if ( !(v37 | 2 * v38) )
          LODWORD(a1) = a1 & ~(v38 >> 31);
      }
    }
  }
  return a1;
}

//----- (000D0404) --------------------------------------------------------
void __fastcall _divdf3(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v4; // r5
  unsigned int v5; // r12
  bool v6; // zf
  int v7; // r4
  int v8; // r4
  int v9; // lr
  unsigned int v10; // r1
  __int64 v11; // r2
  unsigned int v12; // r5
  unsigned int v13; // r6
  unsigned int v14; // r1
  bool v15; // cf
  unsigned int v16; // r4
  int v17; // t2
  unsigned int v18; // r5
  unsigned int v19; // r6
  unsigned __int64 v20; // r2
  int v21; // t2
  signed int v22; // r0
  unsigned int v23; // r12
  unsigned int v24; // lr
  unsigned int v25; // r3
  int v26; // r2
  unsigned int v27; // t2
  unsigned int v28; // lr
  unsigned int v29; // r3
  unsigned int v30; // r2
  unsigned int v31; // t2
  unsigned int v32; // lr
  __int64 v33; // r2
  unsigned int v34; // t2
  unsigned int v35; // lr
  bool v36; // cf
  bool v37; // zf
  unsigned int v38; // r12
  bool v39; // zf
  bool v40; // nf
  unsigned __int8 v41; // vf
  int v42; // r4

  v5 = 2047;
  v7 = (a2 >> 20) & 0x7FF;
  v6 = v7 == 0;
  if ( v7 )
  {
    v4 = (a4 >> 20) & 0x7FF;
    v6 = v4 == 0;
  }
  if ( !v6 )
  {
    v6 = v7 == 2047;
    if ( v7 != 2047 )
      v6 = v4 == 2047;
  }
  if ( v6 )
    sub_D0598(a1, a2, a3, a4);
  v8 = v7 - v4;
  v9 = a2 ^ a4;
  v10 = a2 << 12;
  if ( a3 | (a4 << 12) )
  {
    HIDWORD(v11) = (a4 << 8) & 0xFFFFFFF | 0x10000000 | (a3 >> 24);
    LODWORD(v11) = a3 << 8;
    v12 = (v10 >> 4) | 0x10000000 | (a1 >> 24);
    v13 = a1 << 8;
    v14 = v9 & 0x80000000;
    v15 = v12 >= HIDWORD(v11);
    if ( v12 == HIDWORD(v11) )
      v15 = v13 >= (unsigned int)v11;
    v16 = v15 + v8 + 1021;
    if ( !v15 )
    {
      HIDWORD(v11) >>= 1;
      v17 = __RCR__(v11, 1);
      LODWORD(v11) = v17;
    }
    v18 = (__PAIR__(v12, v13) - v11) >> 32;
    v19 = v13 - v11;
    HIDWORD(v11) >>= 1;
    v21 = __RCR__(v11, 1);
    LODWORD(v20) = v21;
    v22 = 0x100000;
    v23 = 0x80000;
    while ( 1 )
    {
      v24 = (__PAIR__(v18, v19) - v20) >> 32;
      if ( __PAIR__(v18, v19) >= v20 )
      {
        v19 -= v20;
        v18 = v24;
        v22 |= v23;
      }
      HIDWORD(v20) >>= 1;
      v27 = __RCR__(v20, 1);
      LODWORD(v20) = v27;
      v28 = (__PAIR__(v18, v19) - __PAIR__(HIDWORD(v20), v27)) >> 32;
      if ( __PAIR__(v18, v19) >= __PAIR__(HIDWORD(v20), v27) )
      {
        v19 -= v26;
        v18 = v28;
        v22 |= v23 >> 1;
      }
      v29 = v25 >> 1;
      v31 = __RCR__(v26, 1);
      v30 = v31;
      v32 = (__PAIR__(v18, v19) - __PAIR__(v29, v31)) >> 32;
      if ( __PAIR__(v18, v19) >= __PAIR__(v29, v31) )
      {
        v19 -= v30;
        v18 = v32;
        v22 |= v23 >> 2;
      }
      HIDWORD(v33) = v29 >> 1;
      v34 = __RCR__(v30, 1);
      LODWORD(v33) = v34;
      v35 = (__PAIR__(v18, v19) - __PAIR__(HIDWORD(v33), v34)) >> 32;
      if ( __PAIR__(v18, v19) >= __PAIR__(HIDWORD(v33), v34) )
      {
        v19 -= v33;
        v18 = v35;
        v22 |= v23 >> 3;
      }
      if ( !(v18 | v19) )
        break;
      v18 = 16 * v18 | (v19 >> 28);
      v19 *= 16;
      HIDWORD(v20) = v33 >> 29;
      LODWORD(v20) = 8 * v20;
      v23 >>= 4;
      if ( !v23 )
      {
        if ( v14 & 0x100000 )
          break;
        v14 |= v22;
        v22 = 0;
        v23 = 2147483648;
      }
    }
    v36 = v16 >= 0xFD;
    v38 = v16 - 253;
    v37 = v16 == 253;
    if ( v16 > 0xFD )
    {
      v36 = v38 >= 0x700;
      v37 = v38 == 1792;
    }
    if ( !v37 && v36 )
      JUMPOUT(&loc_D027C);
  }
  else
  {
    v41 = __OFADD__(v8, v5 >> 1);
    v42 = v8 + (v5 >> 1);
    v39 = v42 == 0;
    v40 = v42 < 0;
    if ( !((unsigned __int8)((v42 < 0) ^ v41) | (v42 == 0)) )
    {
      v41 = __OFSUB__(v5, v42);
      v39 = v5 == v42;
      v40 = (signed int)(v5 - v42) < 0;
    }
    if ( (unsigned __int8)(v40 ^ v41) | v39 )
      JUMPOUT(&loc_D027C);
  }
}

//----- (000D0598) --------------------------------------------------------
void __fastcall sub_D0598(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r4
  int v5; // r12
  int v6; // r5
  bool v7; // zf
  bool v8; // zf

  v6 = v5 & (a4 >> 20);
  v7 = v4 == v5;
  if ( v4 == v5 )
    v7 = v6 == v5;
  if ( v7 )
    JUMPOUT(&loc_D03F8);
  if ( v4 == v5 )
  {
    if ( a1 | (a2 << 12) )
      JUMPOUT(&loc_D03F8);
    if ( v6 != v5 )
      JUMPOUT(&loc_D03E0);
    JUMPOUT(&loc_D03F8);
  }
  if ( v6 == v5 )
  {
    if ( !(a3 | (a4 << 12)) )
      JUMPOUT(&loc_D0394);
    JUMPOUT(&loc_D03F8);
  }
  v8 = (a1 | 2 * a2) == 0;
  if ( a1 | 2 * a2 )
    v8 = (a3 | 2 * a4) == 0;
  if ( !v8 )
    JUMPOUT(&loc_D032C);
  if ( a1 | 2 * a2 )
    JUMPOUT(&loc_D03E0);
  if ( a3 | 2 * a4 )
    JUMPOUT(&loc_D0394);
  JUMPOUT(&loc_D03F8);
}

//----- (000D0608) --------------------------------------------------------
void _gtdf2()
{
  JUMPOUT(&loc_D061C);
}

//----- (000D0610) --------------------------------------------------------
void _ltdf2()
{
  JUMPOUT(&loc_D061C);
}

//----- (000D0618) --------------------------------------------------------
int __fastcall _nedf2(unsigned int a1, unsigned int a2, unsigned int a3, signed int a4)
{
  bool v4; // zf
  bool v5; // zf
  bool v7; // cf
  bool v8; // zf
  int v9; // r0

  v4 = (signed int)(2 * a2) >> 21 == -1;
  if ( (signed int)(2 * a2) >> 21 != -1 )
    v4 = 2 * a4 >> 21 == -1;
  if ( v4 && ((signed int)(2 * a2) >> 21 == -1 && a1 | (a2 << 12) || 2 * a4 >> 21 == -1 && a3 | (a4 << 12)) )
    return 1;
  v5 = (a1 | 2 * a2) == 0;
  if ( !(a1 | 2 * a2) )
    v5 = (a3 | 2 * a4) == 0;
  if ( !v5 )
    v5 = a2 == a4;
  if ( v5 && a1 == a3 )
    return 0;
  v7 = 0;
  v8 = a2 == a4;
  if ( ((a2 ^ a4) & 0x80000000) == 0 )
  {
    v7 = a2 >= a4;
    v8 = a2 == a4;
  }
  if ( v8 )
    v7 = a1 >= a3;
  if ( v7 )
    v9 = a4 >> 31;
  else
    v9 = ~(a4 >> 31);
  return v9 | 1;
}

//----- (000D06A0) --------------------------------------------------------
unsigned int __fastcall _aeabi_cdrcmple(unsigned int a1, signed int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // r12
  unsigned int result; // r0

  v4 = a1;
  result = a3;
  _aeabi_cdcmple(a3, a4, v4, a2);
  return result;
}

//----- (000D06BC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12> _aeabi_cdcmple(unsigned int a1, unsigned int a2, unsigned int a3, signed int a4)
{
  _nedf2(a1, a2, a3, a4);
}

//----- (000D06D0) --------------------------------------------------------
signed int __fastcall _aeabi_dcmpeq(unsigned int a1, unsigned int a2, unsigned int a3, signed int a4)
{
  char v4; // zf
  signed int result; // r0

  _aeabi_cdcmple(a1, a2, a3, a4);
  if ( v4 )
    result = 1;
  else
    result = 0;
  return result;
}

//----- (000D06E4) --------------------------------------------------------
signed int __fastcall _aeabi_dcmplt(unsigned int a1, unsigned int a2, unsigned int a3, signed int a4)
{
  char v4; // cf
  signed int result; // r0

  _aeabi_cdcmple(a1, a2, a3, a4);
  if ( v4 )
    result = 0;
  else
    result = 1;
  return result;
}

//----- (000D06F8) --------------------------------------------------------
signed int __fastcall _aeabi_dcmple(unsigned int a1, unsigned int a2, unsigned int a3, signed int a4)
{
  unsigned __int8 v4; // cf
  char v5; // zf
  signed int result; // r0

  _aeabi_cdcmple(a1, a2, a3, a4);
  if ( !v5 & v4 )
    result = 0;
  else
    result = 1;
  return result;
}

//----- (000D070C) --------------------------------------------------------
signed int __fastcall _aeabi_dcmpge(unsigned int a1, signed int a2, unsigned int a3, unsigned int a4)
{
  unsigned __int8 v4; // cf
  char v5; // zf
  signed int result; // r0

  _aeabi_cdrcmple(a1, a2, a3, a4);
  if ( !v5 & v4 )
    result = 0;
  else
    result = 1;
  return result;
}

//----- (000D0720) --------------------------------------------------------
signed int __fastcall _aeabi_dcmpgt(unsigned int a1, signed int a2, unsigned int a3, unsigned int a4)
{
  char v4; // cf
  signed int result; // r0

  _aeabi_cdrcmple(a1, a2, a3, a4);
  if ( v4 )
    result = 0;
  else
    result = 1;
  return result;
}

//----- (000D0734) --------------------------------------------------------
unsigned int __fastcall _fixunsdfsi(unsigned int a1, int a2)
{
  int v2; // r2
  unsigned __int8 v3; // cf
  int v4; // r2
  int v5; // r2

  v2 = 2 * a2;
  if ( __CFSHL__(a2, 1) )
    return 0;
  v3 = __CFADD__(v2, 0x200000);
  v4 = v2 + 0x200000;
  if ( !v3 )
  {
    if ( v4 < 0 )
    {
      v5 = -993 - (v4 >> 21);
      if ( v5 >= 0 )
        return ((a2 << 11) | 0x80000000 | (a1 >> 21)) >> v5;
      return -1;
    }
    return 0;
  }
  if ( !(a1 | (a2 << 12)) )
    return -1;
  return 0;
}

//----- (000D0FE4) --------------------------------------------------------
int sub_D0FE4()
{
  return sub_936DC();
}

//----- (000D0FF4) --------------------------------------------------------
pthread_t *__fastcall TrackerClient::requestPeer(pthread_t *result, pthread_t a2)
{
  return TrackerClient::requestPeer(result, a2);
}

//----- (000D1004) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::downloadPieceDataWithPieceid(AcquireChannelPlayInfo *this, unsigned int a2)
{
  return AcquireChannelPlayInfo::downloadPieceDataWithPieceid(this, a2);
}

//----- (000D1014) --------------------------------------------------------
signed int __fastcall AcquireChannelPlayInfo::downloadPieceDataWithPieceid(AcquireChannelPlayInfo *this, unsigned int a2, int a3, int a4)
{
  return AcquireChannelPlayInfo::downloadPieceDataWithPieceid(this, a2, a3, a4);
}

//----- (000D1024) --------------------------------------------------------
double __fastcall FifoDataManager::getWriteDataTime(FifoDataManager *this)
{
  return FifoDataManager::getWriteDataTime(this);
}

//----- (000D1034) --------------------------------------------------------
int initStatistic(void)
{
  return initStatistic();
}

//----- (000D1044) --------------------------------------------------------
void clientPlayerVout(void)
{
  clientPlayerVout();
}

//----- (000D1054) --------------------------------------------------------
char *__fastcall playerSetDebug(int a1)
{
  return playerSetDebug(a1);
}

//----- (000D1064) --------------------------------------------------------
int Java_com_libfifo_FifoController_getP2PDownloadRate_0()
{
  return getP2PDownloadRate();
}

//----- (000D1074) --------------------------------------------------------
int Java_com_libfifo_FifoController_getCDNDownloadRate_0()
{
  return getCDNDownloadRate();
}

//----- (000D1084) --------------------------------------------------------
int Java_com_libfifo_FifoController_getP2PUploadRate_0()
{
  return getP2PUploadRate();
}

//----- (000D1094) --------------------------------------------------------
void __fastcall operator delete(void *a1)
{
  operator delete(a1);
}

//----- (000D10A4) --------------------------------------------------------
void add_play_fsd(void)
{
  add_play_fsd();
}

//----- (000D10B4) --------------------------------------------------------
int __fastcall LinkManager::unlockTheLink(LinkManager *this)
{
  return LinkManager::unlockTheLink(this);
}

//----- (000D10C4) --------------------------------------------------------
void __fastcall notifyPlayerToChangeSource(int a1)
{
  notifyPlayerToChangeSource(a1);
}

//----- (000D10D4) --------------------------------------------------------
void j_curl_global_cleanup()
{
  curl_global_cleanup();
}

//----- (000D10E4) --------------------------------------------------------
int __fastcall j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (000D10F4) --------------------------------------------------------
void *__fastcall j_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (000D1104) --------------------------------------------------------
int __fastcall j_sprintf(char *s, const char *format)
{
  return sprintf(s, format);
}

//----- (000D1114) --------------------------------------------------------
char *__fastcall j_strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}

//----- (000D1124) --------------------------------------------------------
int *__fastcall sub_D1124(int *a1, _BYTE *a2, size_t a3)
{
  return sub_C0F20(a1, a2, a3);
}

//----- (000D1134) --------------------------------------------------------
int __fastcall j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}

//----- (000D1144) --------------------------------------------------------
int __fastcall j_printf(const char *format)
{
  return printf(format);
}

//----- (000D1154) --------------------------------------------------------
void *__fastcall j_calloc(size_t nmemb, size_t size)
{
  return calloc(nmemb, size);
}

//----- (000D1164) --------------------------------------------------------
int __fastcall j_pthread_mutex_lock(pthread_mutex_t *mutex)
{
  return pthread_mutex_lock(mutex);
}

//----- (000D1174) --------------------------------------------------------
void __fastcall j_free(void *ptr)
{
  free(ptr);
}

//----- (000D1184) --------------------------------------------------------
void *__fastcall j_malloc(size_t size)
{
  return malloc(size);
}

//----- (000D1194) --------------------------------------------------------
int __fastcall j_pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)
{
  return pthread_mutex_init(mutex, mutexattr);
}

//----- (000D11A4) --------------------------------------------------------
signed int __fastcall j_curl_multi_assign(int a1, int a2, int a3)
{
  return curl_multi_assign(a1, a2, a3);
}

//----- (000D11B4) --------------------------------------------------------
void __fastcall operator delete[](void *a1)
{
  operator delete[](a1);
}

//----- (000D11C4) --------------------------------------------------------
void *__fastcall operator new[](unsigned int a1)
{
  return operator new[](a1);
}

//----- (000D11D4) --------------------------------------------------------
int __fastcall j_fcntl(int fd, int cmd)
{
  return fcntl(fd, cmd);
}

//----- (000D11E4) --------------------------------------------------------
const char *__fastcall j_inet_ntop(int af, const void *cp, char *buf, socklen_t len)
{
  return inet_ntop(af, cp, buf, len);
}

//----- (000D11F4) --------------------------------------------------------
void *__fastcall j_memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (000D1204) --------------------------------------------------------
size_t __fastcall j_strlen(const char *s)
{
  return strlen(s);
}

//----- (000D1214) --------------------------------------------------------
void __noreturn j__Unwind_GetDataRelBase()
{
  Unwind_GetDataRelBase();
}

//----- (000D1224) --------------------------------------------------------
int j__Unwind_GetRegionStart()
{
  return Unwind_GetRegionStart();
}

//----- (000D1234) --------------------------------------------------------
void __noreturn j__Unwind_GetTextRelBase()
{
  Unwind_GetTextRelBase();
}

//----- (000D1244) --------------------------------------------------------
int __fastcall j__Unwind_DeleteException(int result)
{
  return Unwind_DeleteException(result);
}

//----- (000D1254) --------------------------------------------------------
int j___cxa_atexit()
{
  return _cxa_atexit();
}
// 253D0: using guessed type int _cxa_atexit(void);

//----- (000D1264) --------------------------------------------------------
int __fastcall j_fflush(FILE *stream)
{
  return fflush(stream);
}

//----- (000D1274) --------------------------------------------------------
size_t __fastcall j_strxfrm(char *dest, const char *src, size_t n)
{
  return strxfrm(dest, src, n);
}

//----- (000D1284) --------------------------------------------------------
size_t __fastcall j_wcsxfrm(wchar_t *s1, const wchar_t *s2, size_t n)
{
  return wcsxfrm(s1, s2, n);
}

//----- (000D1294) --------------------------------------------------------
size_t __fastcall j_fwrite(const void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}

//----- (000D12A4) --------------------------------------------------------
int __fastcall j_ungetc(int c, FILE *stream)
{
  return ungetc(c, stream);
}

//----- (000D12B4) --------------------------------------------------------
wint_t __fastcall j_ungetwc(wint_t wc, __FILE *stream)
{
  return ungetwc(wc, stream);
}

//----- (000D12C4) --------------------------------------------------------
int __fastcall j_putc(int c, FILE *stream)
{
  return putc(c, stream);
}

//----- (000D12D4) --------------------------------------------------------
wint_t __fastcall j_putwc(wchar_t wc, __FILE *stream)
{
  return putwc(wc, stream);
}

//----- (000D12E4) --------------------------------------------------------
wchar_t *__fastcall j_wmemcpy(wchar_t *s1, const wchar_t *s2, size_t n)
{
  return wmemcpy(s1, s2, n);
}

//----- (000D12F4) --------------------------------------------------------
wchar_t *__fastcall j_wmemset(wchar_t *s, wchar_t c, size_t n)
{
  return wmemset(s, c, n);
}

//----- (000D1304) --------------------------------------------------------
wchar_t *__fastcall j_wmemmove(wchar_t *s1, const wchar_t *s2, size_t n)
{
  return wmemmove(s1, s2, n);
}

//----- (000D1314) --------------------------------------------------------
void *__fastcall j_memmove(void *dest, const void *src, size_t n)
{
  return memmove(dest, src, n);
}

//----- (000D1324) --------------------------------------------------------
wctype_t __fastcall j_wctype(const char *property)
{
  return wctype(property);
}

//----- (000D1334) --------------------------------------------------------
wint_t __fastcall j_towupper(wint_t wc)
{
  return towupper(wc);
}

//----- (000D1344) --------------------------------------------------------
wint_t __fastcall j_towlower(wint_t wc)
{
  return towlower(wc);
}

//----- (000D1354) --------------------------------------------------------
int __fastcall j_inet_pton(int af, const char *cp, void *buf)
{
  return inet_pton(af, cp, buf);
}

#error "There were 5 decompilation failure(s) on 3190 function(s)"
